<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: parser.go in package go/parser</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	parser.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/parser.html">go/parser</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package parser implements a parser for Go source files. Input may be</code></span>
<span class="codeline" id="line-6"><code>// provided in a variety of forms (see the various Parse* functions); the</code></span>
<span class="codeline" id="line-7"><code>// output is an abstract syntax tree (AST) representing the Go source. The</code></span>
<span class="codeline" id="line-8"><code>// parser is invoked through one of the Parse* functions.</code></span>
<span class="codeline" id="line-9"><code>//</code></span>
<span class="codeline" id="line-10"><code>// The parser accepts a larger language than is syntactically permitted by</code></span>
<span class="codeline" id="line-11"><code>// the Go spec, for simplicity, and for improved robustness in the presence</code></span>
<span class="codeline" id="line-12"><code>// of syntax errors. For instance, in method declarations, the receiver is</code></span>
<span class="codeline" id="line-13"><code>// treated like an ordinary parameter list and thus may contain multiple</code></span>
<span class="codeline" id="line-14"><code>// entries where the spec permits exactly one. Consequently, the corresponding</code></span>
<span class="codeline" id="line-15"><code>// field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</code></span></div><span class="codeline" id="line-16"><code>package parser</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>import (</code></span>
<span class="codeline" id="line-19"><code>	"fmt"</code></span>
<span class="codeline" id="line-20"><code>	"go/ast"</code></span>
<span class="codeline" id="line-21"><code>	"go/build/constraint"</code></span>
<span class="codeline" id="line-22"><code>	"go/internal/typeparams"</code></span>
<span class="codeline" id="line-23"><code>	"go/scanner"</code></span>
<span class="codeline" id="line-24"><code>	"go/token"</code></span>
<span class="codeline" id="line-25"><code>	"strings"</code></span>
<span class="codeline" id="line-26"><code>)</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>// The parser structure holds the parser's internal state.</code></span>
<span class="codeline" id="line-29"><code>type parser struct {</code></span>
<span class="codeline" id="line-30"><code>	file    *token.File</code></span>
<span class="codeline" id="line-31"><code>	errors  scanner.ErrorList</code></span>
<span class="codeline" id="line-32"><code>	scanner scanner.Scanner</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>	// Tracing/debugging</code></span>
<span class="codeline" id="line-35"><code>	mode   Mode // parsing mode</code></span>
<span class="codeline" id="line-36"><code>	trace  bool // == (mode&amp;Trace != 0)</code></span>
<span class="codeline" id="line-37"><code>	indent int  // indentation used for tracing output</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>	// Comments</code></span>
<span class="codeline" id="line-40"><code>	comments    []*ast.CommentGroup</code></span>
<span class="codeline" id="line-41"><code>	leadComment *ast.CommentGroup // last lead comment</code></span>
<span class="codeline" id="line-42"><code>	lineComment *ast.CommentGroup // last line comment</code></span>
<span class="codeline" id="line-43"><code>	top         bool              // in top of file (before package clause)</code></span>
<span class="codeline" id="line-44"><code>	goVersion   string            // minimum Go version found in //go:build comment</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>	// Next token</code></span>
<span class="codeline" id="line-47"><code>	pos token.Pos   // token position</code></span>
<span class="codeline" id="line-48"><code>	tok token.Token // one token look-ahead</code></span>
<span class="codeline" id="line-49"><code>	lit string      // token literal</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>	// Error recovery</code></span>
<span class="codeline" id="line-52"><code>	// (used to limit the number of calls to parser.advance</code></span>
<span class="codeline" id="line-53"><code>	// w/o making scanning progress - avoids potential endless</code></span>
<span class="codeline" id="line-54"><code>	// loops across multiple parser functions during error recovery)</code></span>
<span class="codeline" id="line-55"><code>	syncPos token.Pos // last synchronization position</code></span>
<span class="codeline" id="line-56"><code>	syncCnt int       // number of parser.advance calls without progress</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>	// Non-syntactic parser control</code></span>
<span class="codeline" id="line-59"><code>	exprLev int  // &lt; 0: in control clause, &gt;= 0: in expression</code></span>
<span class="codeline" id="line-60"><code>	inRhs   bool // if set, the parser is parsing a rhs expression</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	imports []*ast.ImportSpec // list of imports</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>	// nestLev is used to track and limit the recursion depth</code></span>
<span class="codeline" id="line-65"><code>	// during parsing.</code></span>
<span class="codeline" id="line-66"><code>	nestLev int</code></span>
<span class="codeline" id="line-67"><code>}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) {</code></span>
<span class="codeline" id="line-70"><code>	p.file = fset.AddFile(filename, -1, len(src))</code></span>
<span class="codeline" id="line-71"><code>	eh := func(pos token.Position, msg string) { p.errors.Add(pos, msg) }</code></span>
<span class="codeline" id="line-72"><code>	p.scanner.Init(p.file, src, eh, scanner.ScanComments)</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>	p.top = true</code></span>
<span class="codeline" id="line-75"><code>	p.mode = mode</code></span>
<span class="codeline" id="line-76"><code>	p.trace = mode&amp;Trace != 0 // for convenience (p.trace is used frequently)</code></span>
<span class="codeline" id="line-77"><code>	p.next()</code></span>
<span class="codeline" id="line-78"><code>}</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-81"><code>// Parsing support</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>func (p *parser) printTrace(a ...any) {</code></span>
<span class="codeline" id="line-84"><code>	const dots = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "</code></span>
<span class="codeline" id="line-85"><code>	const n = len(dots)</code></span>
<span class="codeline" id="line-86"><code>	pos := p.file.Position(p.pos)</code></span>
<span class="codeline" id="line-87"><code>	fmt.Printf("%5d:%3d: ", pos.Line, pos.Column)</code></span>
<span class="codeline" id="line-88"><code>	i := 2 * p.indent</code></span>
<span class="codeline" id="line-89"><code>	for i &gt; n {</code></span>
<span class="codeline" id="line-90"><code>		fmt.Print(dots)</code></span>
<span class="codeline" id="line-91"><code>		i -= n</code></span>
<span class="codeline" id="line-92"><code>	}</code></span>
<span class="codeline" id="line-93"><code>	// i &lt;= n</code></span>
<span class="codeline" id="line-94"><code>	fmt.Print(dots[0:i])</code></span>
<span class="codeline" id="line-95"><code>	fmt.Println(a...)</code></span>
<span class="codeline" id="line-96"><code>}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>func trace(p *parser, msg string) *parser {</code></span>
<span class="codeline" id="line-99"><code>	p.printTrace(msg, "(")</code></span>
<span class="codeline" id="line-100"><code>	p.indent++</code></span>
<span class="codeline" id="line-101"><code>	return p</code></span>
<span class="codeline" id="line-102"><code>}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>// Usage pattern: defer un(trace(p, "..."))</code></span>
<span class="codeline" id="line-105"><code>func un(p *parser) {</code></span>
<span class="codeline" id="line-106"><code>	p.indent--</code></span>
<span class="codeline" id="line-107"><code>	p.printTrace(")")</code></span>
<span class="codeline" id="line-108"><code>}</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// maxNestLev is the deepest we're willing to recurse during parsing</code></span>
<span class="codeline" id="line-111"><code>const maxNestLev int = 1e5</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>func incNestLev(p *parser) *parser {</code></span>
<span class="codeline" id="line-114"><code>	p.nestLev++</code></span>
<span class="codeline" id="line-115"><code>	if p.nestLev &gt; maxNestLev {</code></span>
<span class="codeline" id="line-116"><code>		p.error(p.pos, "exceeded max nesting depth")</code></span>
<span class="codeline" id="line-117"><code>		panic(bailout{})</code></span>
<span class="codeline" id="line-118"><code>	}</code></span>
<span class="codeline" id="line-119"><code>	return p</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// decNestLev is used to track nesting depth during parsing to prevent stack exhaustion.</code></span>
<span class="codeline" id="line-123"><code>// It is used along with incNestLev in a similar fashion to how un and trace are used.</code></span>
<span class="codeline" id="line-124"><code>func decNestLev(p *parser) {</code></span>
<span class="codeline" id="line-125"><code>	p.nestLev--</code></span>
<span class="codeline" id="line-126"><code>}</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>// Advance to the next token.</code></span>
<span class="codeline" id="line-129"><code>func (p *parser) next0() {</code></span>
<span class="codeline" id="line-130"><code>	// Because of one-token look-ahead, print the previous token</code></span>
<span class="codeline" id="line-131"><code>	// when tracing as it provides a more readable output. The</code></span>
<span class="codeline" id="line-132"><code>	// very first token (!p.pos.IsValid()) is not initialized</code></span>
<span class="codeline" id="line-133"><code>	// (it is token.ILLEGAL), so don't print it.</code></span>
<span class="codeline" id="line-134"><code>	if p.trace &amp;&amp; p.pos.IsValid() {</code></span>
<span class="codeline" id="line-135"><code>		s := p.tok.String()</code></span>
<span class="codeline" id="line-136"><code>		switch {</code></span>
<span class="codeline" id="line-137"><code>		case p.tok.IsLiteral():</code></span>
<span class="codeline" id="line-138"><code>			p.printTrace(s, p.lit)</code></span>
<span class="codeline" id="line-139"><code>		case p.tok.IsOperator(), p.tok.IsKeyword():</code></span>
<span class="codeline" id="line-140"><code>			p.printTrace("\"" + s + "\"")</code></span>
<span class="codeline" id="line-141"><code>		default:</code></span>
<span class="codeline" id="line-142"><code>			p.printTrace(s)</code></span>
<span class="codeline" id="line-143"><code>		}</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	for {</code></span>
<span class="codeline" id="line-147"><code>		p.pos, p.tok, p.lit = p.scanner.Scan()</code></span>
<span class="codeline" id="line-148"><code>		if p.tok == token.COMMENT {</code></span>
<span class="codeline" id="line-149"><code>			if p.top &amp;&amp; strings.HasPrefix(p.lit, "//go:build") {</code></span>
<span class="codeline" id="line-150"><code>				if x, err := constraint.Parse(p.lit); err == nil {</code></span>
<span class="codeline" id="line-151"><code>					p.goVersion = constraint.GoVersion(x)</code></span>
<span class="codeline" id="line-152"><code>				}</code></span>
<span class="codeline" id="line-153"><code>			}</code></span>
<span class="codeline" id="line-154"><code>			if p.mode&amp;ParseComments == 0 {</code></span>
<span class="codeline" id="line-155"><code>				continue</code></span>
<span class="codeline" id="line-156"><code>			}</code></span>
<span class="codeline" id="line-157"><code>		} else {</code></span>
<span class="codeline" id="line-158"><code>			// Found a non-comment; top of file is over.</code></span>
<span class="codeline" id="line-159"><code>			p.top = false</code></span>
<span class="codeline" id="line-160"><code>		}</code></span>
<span class="codeline" id="line-161"><code>		break</code></span>
<span class="codeline" id="line-162"><code>	}</code></span>
<span class="codeline" id="line-163"><code>}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>// Consume a comment and return it and the line on which it ends.</code></span>
<span class="codeline" id="line-166"><code>func (p *parser) consumeComment() (comment *ast.Comment, endline int) {</code></span>
<span class="codeline" id="line-167"><code>	// /*-style comments may end on a different line than where they start.</code></span>
<span class="codeline" id="line-168"><code>	// Scan the comment for '\n' chars and adjust endline accordingly.</code></span>
<span class="codeline" id="line-169"><code>	endline = p.file.Line(p.pos)</code></span>
<span class="codeline" id="line-170"><code>	if p.lit[1] == '*' {</code></span>
<span class="codeline" id="line-171"><code>		// don't use range here - no need to decode Unicode code points</code></span>
<span class="codeline" id="line-172"><code>		for i := 0; i &lt; len(p.lit); i++ {</code></span>
<span class="codeline" id="line-173"><code>			if p.lit[i] == '\n' {</code></span>
<span class="codeline" id="line-174"><code>				endline++</code></span>
<span class="codeline" id="line-175"><code>			}</code></span>
<span class="codeline" id="line-176"><code>		}</code></span>
<span class="codeline" id="line-177"><code>	}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>	comment = &amp;ast.Comment{Slash: p.pos, Text: p.lit}</code></span>
<span class="codeline" id="line-180"><code>	p.next0()</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>	return</code></span>
<span class="codeline" id="line-183"><code>}</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>// Consume a group of adjacent comments, add it to the parser's</code></span>
<span class="codeline" id="line-186"><code>// comments list, and return it together with the line at which</code></span>
<span class="codeline" id="line-187"><code>// the last comment in the group ends. A non-comment token or n</code></span>
<span class="codeline" id="line-188"><code>// empty lines terminate a comment group.</code></span>
<span class="codeline" id="line-189"><code>func (p *parser) consumeCommentGroup(n int) (comments *ast.CommentGroup, endline int) {</code></span>
<span class="codeline" id="line-190"><code>	var list []*ast.Comment</code></span>
<span class="codeline" id="line-191"><code>	endline = p.file.Line(p.pos)</code></span>
<span class="codeline" id="line-192"><code>	for p.tok == token.COMMENT &amp;&amp; p.file.Line(p.pos) &lt;= endline+n {</code></span>
<span class="codeline" id="line-193"><code>		var comment *ast.Comment</code></span>
<span class="codeline" id="line-194"><code>		comment, endline = p.consumeComment()</code></span>
<span class="codeline" id="line-195"><code>		list = append(list, comment)</code></span>
<span class="codeline" id="line-196"><code>	}</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>	// add comment group to the comments list</code></span>
<span class="codeline" id="line-199"><code>	comments = &amp;ast.CommentGroup{List: list}</code></span>
<span class="codeline" id="line-200"><code>	p.comments = append(p.comments, comments)</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>	return</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>// Advance to the next non-comment token. In the process, collect</code></span>
<span class="codeline" id="line-206"><code>// any comment groups encountered, and remember the last lead and</code></span>
<span class="codeline" id="line-207"><code>// line comments.</code></span>
<span class="codeline" id="line-208"><code>//</code></span>
<span class="codeline" id="line-209"><code>// A lead comment is a comment group that starts and ends in a</code></span>
<span class="codeline" id="line-210"><code>// line without any other tokens and that is followed by a non-comment</code></span>
<span class="codeline" id="line-211"><code>// token on the line immediately after the comment group.</code></span>
<span class="codeline" id="line-212"><code>//</code></span>
<span class="codeline" id="line-213"><code>// A line comment is a comment group that follows a non-comment</code></span>
<span class="codeline" id="line-214"><code>// token on the same line, and that has no tokens after it on the line</code></span>
<span class="codeline" id="line-215"><code>// where it ends.</code></span>
<span class="codeline" id="line-216"><code>//</code></span>
<span class="codeline" id="line-217"><code>// Lead and line comments may be considered documentation that is</code></span>
<span class="codeline" id="line-218"><code>// stored in the AST.</code></span>
<span class="codeline" id="line-219"><code>func (p *parser) next() {</code></span>
<span class="codeline" id="line-220"><code>	p.leadComment = nil</code></span>
<span class="codeline" id="line-221"><code>	p.lineComment = nil</code></span>
<span class="codeline" id="line-222"><code>	prev := p.pos</code></span>
<span class="codeline" id="line-223"><code>	p.next0()</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>	if p.tok == token.COMMENT {</code></span>
<span class="codeline" id="line-226"><code>		var comment *ast.CommentGroup</code></span>
<span class="codeline" id="line-227"><code>		var endline int</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>		if p.file.Line(p.pos) == p.file.Line(prev) {</code></span>
<span class="codeline" id="line-230"><code>			// The comment is on same line as the previous token; it</code></span>
<span class="codeline" id="line-231"><code>			// cannot be a lead comment but may be a line comment.</code></span>
<span class="codeline" id="line-232"><code>			comment, endline = p.consumeCommentGroup(0)</code></span>
<span class="codeline" id="line-233"><code>			if p.file.Line(p.pos) != endline || p.tok == token.SEMICOLON || p.tok == token.EOF {</code></span>
<span class="codeline" id="line-234"><code>				// The next token is on a different line, thus</code></span>
<span class="codeline" id="line-235"><code>				// the last comment group is a line comment.</code></span>
<span class="codeline" id="line-236"><code>				p.lineComment = comment</code></span>
<span class="codeline" id="line-237"><code>			}</code></span>
<span class="codeline" id="line-238"><code>		}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>		// consume successor comments, if any</code></span>
<span class="codeline" id="line-241"><code>		endline = -1</code></span>
<span class="codeline" id="line-242"><code>		for p.tok == token.COMMENT {</code></span>
<span class="codeline" id="line-243"><code>			comment, endline = p.consumeCommentGroup(1)</code></span>
<span class="codeline" id="line-244"><code>		}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>		if endline+1 == p.file.Line(p.pos) {</code></span>
<span class="codeline" id="line-247"><code>			// The next token is following on the line immediately after the</code></span>
<span class="codeline" id="line-248"><code>			// comment group, thus the last comment group is a lead comment.</code></span>
<span class="codeline" id="line-249"><code>			p.leadComment = comment</code></span>
<span class="codeline" id="line-250"><code>		}</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code>}</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>// A bailout panic is raised to indicate early termination. pos and msg are</code></span>
<span class="codeline" id="line-255"><code>// only populated when bailing out of object resolution.</code></span>
<span class="codeline" id="line-256"><code>type bailout struct {</code></span>
<span class="codeline" id="line-257"><code>	pos token.Pos</code></span>
<span class="codeline" id="line-258"><code>	msg string</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>func (p *parser) error(pos token.Pos, msg string) {</code></span>
<span class="codeline" id="line-262"><code>	if p.trace {</code></span>
<span class="codeline" id="line-263"><code>		defer un(trace(p, "error: "+msg))</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>	epos := p.file.Position(pos)</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>	// If AllErrors is not set, discard errors reported on the same line</code></span>
<span class="codeline" id="line-269"><code>	// as the last recorded error and stop parsing if there are more than</code></span>
<span class="codeline" id="line-270"><code>	// 10 errors.</code></span>
<span class="codeline" id="line-271"><code>	if p.mode&amp;AllErrors == 0 {</code></span>
<span class="codeline" id="line-272"><code>		n := len(p.errors)</code></span>
<span class="codeline" id="line-273"><code>		if n &gt; 0 &amp;&amp; p.errors[n-1].Pos.Line == epos.Line {</code></span>
<span class="codeline" id="line-274"><code>			return // discard - likely a spurious error</code></span>
<span class="codeline" id="line-275"><code>		}</code></span>
<span class="codeline" id="line-276"><code>		if n &gt; 10 {</code></span>
<span class="codeline" id="line-277"><code>			panic(bailout{})</code></span>
<span class="codeline" id="line-278"><code>		}</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	p.errors.Add(epos, msg)</code></span>
<span class="codeline" id="line-282"><code>}</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>func (p *parser) errorExpected(pos token.Pos, msg string) {</code></span>
<span class="codeline" id="line-285"><code>	msg = "expected " + msg</code></span>
<span class="codeline" id="line-286"><code>	if pos == p.pos {</code></span>
<span class="codeline" id="line-287"><code>		// the error happened at the current position;</code></span>
<span class="codeline" id="line-288"><code>		// make the error message more specific</code></span>
<span class="codeline" id="line-289"><code>		switch {</code></span>
<span class="codeline" id="line-290"><code>		case p.tok == token.SEMICOLON &amp;&amp; p.lit == "\n":</code></span>
<span class="codeline" id="line-291"><code>			msg += ", found newline"</code></span>
<span class="codeline" id="line-292"><code>		case p.tok.IsLiteral():</code></span>
<span class="codeline" id="line-293"><code>			// print 123 rather than 'INT', etc.</code></span>
<span class="codeline" id="line-294"><code>			msg += ", found " + p.lit</code></span>
<span class="codeline" id="line-295"><code>		default:</code></span>
<span class="codeline" id="line-296"><code>			msg += ", found '" + p.tok.String() + "'"</code></span>
<span class="codeline" id="line-297"><code>		}</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	p.error(pos, msg)</code></span>
<span class="codeline" id="line-300"><code>}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>func (p *parser) expect(tok token.Token) token.Pos {</code></span>
<span class="codeline" id="line-303"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-304"><code>	if p.tok != tok {</code></span>
<span class="codeline" id="line-305"><code>		p.errorExpected(pos, "'"+tok.String()+"'")</code></span>
<span class="codeline" id="line-306"><code>	}</code></span>
<span class="codeline" id="line-307"><code>	p.next() // make progress</code></span>
<span class="codeline" id="line-308"><code>	return pos</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>// expect2 is like expect, but it returns an invalid position</code></span>
<span class="codeline" id="line-312"><code>// if the expected token is not found.</code></span>
<span class="codeline" id="line-313"><code>func (p *parser) expect2(tok token.Token) (pos token.Pos) {</code></span>
<span class="codeline" id="line-314"><code>	if p.tok == tok {</code></span>
<span class="codeline" id="line-315"><code>		pos = p.pos</code></span>
<span class="codeline" id="line-316"><code>	} else {</code></span>
<span class="codeline" id="line-317"><code>		p.errorExpected(p.pos, "'"+tok.String()+"'")</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	p.next() // make progress</code></span>
<span class="codeline" id="line-320"><code>	return</code></span>
<span class="codeline" id="line-321"><code>}</code></span>
<span class="codeline" id="line-322"><code></code></span>
<span class="codeline" id="line-323"><code>// expectClosing is like expect but provides a better error message</code></span>
<span class="codeline" id="line-324"><code>// for the common case of a missing comma before a newline.</code></span>
<span class="codeline" id="line-325"><code>func (p *parser) expectClosing(tok token.Token, context string) token.Pos {</code></span>
<span class="codeline" id="line-326"><code>	if p.tok != tok &amp;&amp; p.tok == token.SEMICOLON &amp;&amp; p.lit == "\n" {</code></span>
<span class="codeline" id="line-327"><code>		p.error(p.pos, "missing ',' before newline in "+context)</code></span>
<span class="codeline" id="line-328"><code>		p.next()</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	return p.expect(tok)</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>// expectSemi consumes a semicolon and returns the applicable line comment.</code></span>
<span class="codeline" id="line-334"><code>func (p *parser) expectSemi() (comment *ast.CommentGroup) {</code></span>
<span class="codeline" id="line-335"><code>	// semicolon is optional before a closing ')' or '}'</code></span>
<span class="codeline" id="line-336"><code>	if p.tok != token.RPAREN &amp;&amp; p.tok != token.RBRACE {</code></span>
<span class="codeline" id="line-337"><code>		switch p.tok {</code></span>
<span class="codeline" id="line-338"><code>		case token.COMMA:</code></span>
<span class="codeline" id="line-339"><code>			// permit a ',' instead of a ';' but complain</code></span>
<span class="codeline" id="line-340"><code>			p.errorExpected(p.pos, "';'")</code></span>
<span class="codeline" id="line-341"><code>			fallthrough</code></span>
<span class="codeline" id="line-342"><code>		case token.SEMICOLON:</code></span>
<span class="codeline" id="line-343"><code>			if p.lit == ";" {</code></span>
<span class="codeline" id="line-344"><code>				// explicit semicolon</code></span>
<span class="codeline" id="line-345"><code>				p.next()</code></span>
<span class="codeline" id="line-346"><code>				comment = p.lineComment // use following comments</code></span>
<span class="codeline" id="line-347"><code>			} else {</code></span>
<span class="codeline" id="line-348"><code>				// artificial semicolon</code></span>
<span class="codeline" id="line-349"><code>				comment = p.lineComment // use preceding comments</code></span>
<span class="codeline" id="line-350"><code>				p.next()</code></span>
<span class="codeline" id="line-351"><code>			}</code></span>
<span class="codeline" id="line-352"><code>			return comment</code></span>
<span class="codeline" id="line-353"><code>		default:</code></span>
<span class="codeline" id="line-354"><code>			p.errorExpected(p.pos, "';'")</code></span>
<span class="codeline" id="line-355"><code>			p.advance(stmtStart)</code></span>
<span class="codeline" id="line-356"><code>		}</code></span>
<span class="codeline" id="line-357"><code>	}</code></span>
<span class="codeline" id="line-358"><code>	return nil</code></span>
<span class="codeline" id="line-359"><code>}</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>func (p *parser) atComma(context string, follow token.Token) bool {</code></span>
<span class="codeline" id="line-362"><code>	if p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-363"><code>		return true</code></span>
<span class="codeline" id="line-364"><code>	}</code></span>
<span class="codeline" id="line-365"><code>	if p.tok != follow {</code></span>
<span class="codeline" id="line-366"><code>		msg := "missing ','"</code></span>
<span class="codeline" id="line-367"><code>		if p.tok == token.SEMICOLON &amp;&amp; p.lit == "\n" {</code></span>
<span class="codeline" id="line-368"><code>			msg += " before newline"</code></span>
<span class="codeline" id="line-369"><code>		}</code></span>
<span class="codeline" id="line-370"><code>		p.error(p.pos, msg+" in "+context)</code></span>
<span class="codeline" id="line-371"><code>		return true // "insert" comma and continue</code></span>
<span class="codeline" id="line-372"><code>	}</code></span>
<span class="codeline" id="line-373"><code>	return false</code></span>
<span class="codeline" id="line-374"><code>}</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>func assert(cond bool, msg string) {</code></span>
<span class="codeline" id="line-377"><code>	if !cond {</code></span>
<span class="codeline" id="line-378"><code>		panic("go/parser internal error: " + msg)</code></span>
<span class="codeline" id="line-379"><code>	}</code></span>
<span class="codeline" id="line-380"><code>}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>// advance consumes tokens until the current token p.tok</code></span>
<span class="codeline" id="line-383"><code>// is in the 'to' set, or token.EOF. For error recovery.</code></span>
<span class="codeline" id="line-384"><code>func (p *parser) advance(to map[token.Token]bool) {</code></span>
<span class="codeline" id="line-385"><code>	for ; p.tok != token.EOF; p.next() {</code></span>
<span class="codeline" id="line-386"><code>		if to[p.tok] {</code></span>
<span class="codeline" id="line-387"><code>			// Return only if parser made some progress since last</code></span>
<span class="codeline" id="line-388"><code>			// sync or if it has not reached 10 advance calls without</code></span>
<span class="codeline" id="line-389"><code>			// progress. Otherwise consume at least one token to</code></span>
<span class="codeline" id="line-390"><code>			// avoid an endless parser loop (it is possible that</code></span>
<span class="codeline" id="line-391"><code>			// both parseOperand and parseStmt call advance and</code></span>
<span class="codeline" id="line-392"><code>			// correctly do not advance, thus the need for the</code></span>
<span class="codeline" id="line-393"><code>			// invocation limit p.syncCnt).</code></span>
<span class="codeline" id="line-394"><code>			if p.pos == p.syncPos &amp;&amp; p.syncCnt &lt; 10 {</code></span>
<span class="codeline" id="line-395"><code>				p.syncCnt++</code></span>
<span class="codeline" id="line-396"><code>				return</code></span>
<span class="codeline" id="line-397"><code>			}</code></span>
<span class="codeline" id="line-398"><code>			if p.pos &gt; p.syncPos {</code></span>
<span class="codeline" id="line-399"><code>				p.syncPos = p.pos</code></span>
<span class="codeline" id="line-400"><code>				p.syncCnt = 0</code></span>
<span class="codeline" id="line-401"><code>				return</code></span>
<span class="codeline" id="line-402"><code>			}</code></span>
<span class="codeline" id="line-403"><code>			// Reaching here indicates a parser bug, likely an</code></span>
<span class="codeline" id="line-404"><code>			// incorrect token list in this function, but it only</code></span>
<span class="codeline" id="line-405"><code>			// leads to skipping of possibly correct code if a</code></span>
<span class="codeline" id="line-406"><code>			// previous error is present, and thus is preferred</code></span>
<span class="codeline" id="line-407"><code>			// over a non-terminating parse.</code></span>
<span class="codeline" id="line-408"><code>		}</code></span>
<span class="codeline" id="line-409"><code>	}</code></span>
<span class="codeline" id="line-410"><code>}</code></span>
<span class="codeline" id="line-411"><code></code></span>
<span class="codeline" id="line-412"><code>var stmtStart = map[token.Token]bool{</code></span>
<span class="codeline" id="line-413"><code>	token.BREAK:       true,</code></span>
<span class="codeline" id="line-414"><code>	token.CONST:       true,</code></span>
<span class="codeline" id="line-415"><code>	token.CONTINUE:    true,</code></span>
<span class="codeline" id="line-416"><code>	token.DEFER:       true,</code></span>
<span class="codeline" id="line-417"><code>	token.FALLTHROUGH: true,</code></span>
<span class="codeline" id="line-418"><code>	token.FOR:         true,</code></span>
<span class="codeline" id="line-419"><code>	token.GO:          true,</code></span>
<span class="codeline" id="line-420"><code>	token.GOTO:        true,</code></span>
<span class="codeline" id="line-421"><code>	token.IF:          true,</code></span>
<span class="codeline" id="line-422"><code>	token.RETURN:      true,</code></span>
<span class="codeline" id="line-423"><code>	token.SELECT:      true,</code></span>
<span class="codeline" id="line-424"><code>	token.SWITCH:      true,</code></span>
<span class="codeline" id="line-425"><code>	token.TYPE:        true,</code></span>
<span class="codeline" id="line-426"><code>	token.VAR:         true,</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>var declStart = map[token.Token]bool{</code></span>
<span class="codeline" id="line-430"><code>	token.IMPORT: true,</code></span>
<span class="codeline" id="line-431"><code>	token.CONST:  true,</code></span>
<span class="codeline" id="line-432"><code>	token.TYPE:   true,</code></span>
<span class="codeline" id="line-433"><code>	token.VAR:    true,</code></span>
<span class="codeline" id="line-434"><code>}</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>var exprEnd = map[token.Token]bool{</code></span>
<span class="codeline" id="line-437"><code>	token.COMMA:     true,</code></span>
<span class="codeline" id="line-438"><code>	token.COLON:     true,</code></span>
<span class="codeline" id="line-439"><code>	token.SEMICOLON: true,</code></span>
<span class="codeline" id="line-440"><code>	token.RPAREN:    true,</code></span>
<span class="codeline" id="line-441"><code>	token.RBRACK:    true,</code></span>
<span class="codeline" id="line-442"><code>	token.RBRACE:    true,</code></span>
<span class="codeline" id="line-443"><code>}</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>// safePos returns a valid file position for a given position: If pos</code></span>
<span class="codeline" id="line-446"><code>// is valid to begin with, safePos returns pos. If pos is out-of-range,</code></span>
<span class="codeline" id="line-447"><code>// safePos returns the EOF position.</code></span>
<span class="codeline" id="line-448"><code>//</code></span>
<span class="codeline" id="line-449"><code>// This is hack to work around "artificial" end positions in the AST which</code></span>
<span class="codeline" id="line-450"><code>// are computed by adding 1 to (presumably valid) token positions. If the</code></span>
<span class="codeline" id="line-451"><code>// token positions are invalid due to parse errors, the resulting end position</code></span>
<span class="codeline" id="line-452"><code>// may be past the file's EOF position, which would lead to panics if used</code></span>
<span class="codeline" id="line-453"><code>// later on.</code></span>
<span class="codeline" id="line-454"><code>func (p *parser) safePos(pos token.Pos) (res token.Pos) {</code></span>
<span class="codeline" id="line-455"><code>	defer func() {</code></span>
<span class="codeline" id="line-456"><code>		if recover() != nil {</code></span>
<span class="codeline" id="line-457"><code>			res = token.Pos(p.file.Base() + p.file.Size()) // EOF position</code></span>
<span class="codeline" id="line-458"><code>		}</code></span>
<span class="codeline" id="line-459"><code>	}()</code></span>
<span class="codeline" id="line-460"><code>	_ = p.file.Offset(pos) // trigger a panic if position is out-of-range</code></span>
<span class="codeline" id="line-461"><code>	return pos</code></span>
<span class="codeline" id="line-462"><code>}</code></span>
<span class="codeline" id="line-463"><code></code></span>
<span class="codeline" id="line-464"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-465"><code>// Identifiers</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>func (p *parser) parseIdent() *ast.Ident {</code></span>
<span class="codeline" id="line-468"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-469"><code>	name := "_"</code></span>
<span class="codeline" id="line-470"><code>	if p.tok == token.IDENT {</code></span>
<span class="codeline" id="line-471"><code>		name = p.lit</code></span>
<span class="codeline" id="line-472"><code>		p.next()</code></span>
<span class="codeline" id="line-473"><code>	} else {</code></span>
<span class="codeline" id="line-474"><code>		p.expect(token.IDENT) // use expect() error handling</code></span>
<span class="codeline" id="line-475"><code>	}</code></span>
<span class="codeline" id="line-476"><code>	return &amp;ast.Ident{NamePos: pos, Name: name}</code></span>
<span class="codeline" id="line-477"><code>}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>func (p *parser) parseIdentList() (list []*ast.Ident) {</code></span>
<span class="codeline" id="line-480"><code>	if p.trace {</code></span>
<span class="codeline" id="line-481"><code>		defer un(trace(p, "IdentList"))</code></span>
<span class="codeline" id="line-482"><code>	}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>	list = append(list, p.parseIdent())</code></span>
<span class="codeline" id="line-485"><code>	for p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-486"><code>		p.next()</code></span>
<span class="codeline" id="line-487"><code>		list = append(list, p.parseIdent())</code></span>
<span class="codeline" id="line-488"><code>	}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>	return</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-494"><code>// Common productions</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>// If lhs is set, result list elements which are identifiers are not resolved.</code></span>
<span class="codeline" id="line-497"><code>func (p *parser) parseExprList() (list []ast.Expr) {</code></span>
<span class="codeline" id="line-498"><code>	if p.trace {</code></span>
<span class="codeline" id="line-499"><code>		defer un(trace(p, "ExpressionList"))</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>	list = append(list, p.parseExpr())</code></span>
<span class="codeline" id="line-503"><code>	for p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-504"><code>		p.next()</code></span>
<span class="codeline" id="line-505"><code>		list = append(list, p.parseExpr())</code></span>
<span class="codeline" id="line-506"><code>	}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>	return</code></span>
<span class="codeline" id="line-509"><code>}</code></span>
<span class="codeline" id="line-510"><code></code></span>
<span class="codeline" id="line-511"><code>func (p *parser) parseList(inRhs bool) []ast.Expr {</code></span>
<span class="codeline" id="line-512"><code>	old := p.inRhs</code></span>
<span class="codeline" id="line-513"><code>	p.inRhs = inRhs</code></span>
<span class="codeline" id="line-514"><code>	list := p.parseExprList()</code></span>
<span class="codeline" id="line-515"><code>	p.inRhs = old</code></span>
<span class="codeline" id="line-516"><code>	return list</code></span>
<span class="codeline" id="line-517"><code>}</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-520"><code>// Types</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>func (p *parser) parseType() ast.Expr {</code></span>
<span class="codeline" id="line-523"><code>	if p.trace {</code></span>
<span class="codeline" id="line-524"><code>		defer un(trace(p, "Type"))</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>	typ := p.tryIdentOrType()</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	if typ == nil {</code></span>
<span class="codeline" id="line-530"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-531"><code>		p.errorExpected(pos, "type")</code></span>
<span class="codeline" id="line-532"><code>		p.advance(exprEnd)</code></span>
<span class="codeline" id="line-533"><code>		return &amp;ast.BadExpr{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code></code></span>
<span class="codeline" id="line-536"><code>	return typ</code></span>
<span class="codeline" id="line-537"><code>}</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>func (p *parser) parseQualifiedIdent(ident *ast.Ident) ast.Expr {</code></span>
<span class="codeline" id="line-540"><code>	if p.trace {</code></span>
<span class="codeline" id="line-541"><code>		defer un(trace(p, "QualifiedIdent"))</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>	typ := p.parseTypeName(ident)</code></span>
<span class="codeline" id="line-545"><code>	if p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-546"><code>		typ = p.parseTypeInstance(typ)</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>	return typ</code></span>
<span class="codeline" id="line-550"><code>}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>// If the result is an identifier, it is not resolved.</code></span>
<span class="codeline" id="line-553"><code>func (p *parser) parseTypeName(ident *ast.Ident) ast.Expr {</code></span>
<span class="codeline" id="line-554"><code>	if p.trace {</code></span>
<span class="codeline" id="line-555"><code>		defer un(trace(p, "TypeName"))</code></span>
<span class="codeline" id="line-556"><code>	}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>	if ident == nil {</code></span>
<span class="codeline" id="line-559"><code>		ident = p.parseIdent()</code></span>
<span class="codeline" id="line-560"><code>	}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>	if p.tok == token.PERIOD {</code></span>
<span class="codeline" id="line-563"><code>		// ident is a package name</code></span>
<span class="codeline" id="line-564"><code>		p.next()</code></span>
<span class="codeline" id="line-565"><code>		sel := p.parseIdent()</code></span>
<span class="codeline" id="line-566"><code>		return &amp;ast.SelectorExpr{X: ident, Sel: sel}</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	return ident</code></span>
<span class="codeline" id="line-570"><code>}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>// "[" has already been consumed, and lbrack is its position.</code></span>
<span class="codeline" id="line-573"><code>// If len != nil it is the already consumed array length.</code></span>
<span class="codeline" id="line-574"><code>func (p *parser) parseArrayType(lbrack token.Pos, len ast.Expr) *ast.ArrayType {</code></span>
<span class="codeline" id="line-575"><code>	if p.trace {</code></span>
<span class="codeline" id="line-576"><code>		defer un(trace(p, "ArrayType"))</code></span>
<span class="codeline" id="line-577"><code>	}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>	if len == nil {</code></span>
<span class="codeline" id="line-580"><code>		p.exprLev++</code></span>
<span class="codeline" id="line-581"><code>		// always permit ellipsis for more fault-tolerant parsing</code></span>
<span class="codeline" id="line-582"><code>		if p.tok == token.ELLIPSIS {</code></span>
<span class="codeline" id="line-583"><code>			len = &amp;ast.Ellipsis{Ellipsis: p.pos}</code></span>
<span class="codeline" id="line-584"><code>			p.next()</code></span>
<span class="codeline" id="line-585"><code>		} else if p.tok != token.RBRACK {</code></span>
<span class="codeline" id="line-586"><code>			len = p.parseRhs()</code></span>
<span class="codeline" id="line-587"><code>		}</code></span>
<span class="codeline" id="line-588"><code>		p.exprLev--</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code>	if p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-591"><code>		// Trailing commas are accepted in type parameter</code></span>
<span class="codeline" id="line-592"><code>		// lists but not in array type declarations.</code></span>
<span class="codeline" id="line-593"><code>		// Accept for better error handling but complain.</code></span>
<span class="codeline" id="line-594"><code>		p.error(p.pos, "unexpected comma; expecting ]")</code></span>
<span class="codeline" id="line-595"><code>		p.next()</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code>	p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-598"><code>	elt := p.parseType()</code></span>
<span class="codeline" id="line-599"><code>	return &amp;ast.ArrayType{Lbrack: lbrack, Len: len, Elt: elt}</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>func (p *parser) parseArrayFieldOrTypeInstance(x *ast.Ident) (*ast.Ident, ast.Expr) {</code></span>
<span class="codeline" id="line-603"><code>	if p.trace {</code></span>
<span class="codeline" id="line-604"><code>		defer un(trace(p, "ArrayFieldOrTypeInstance"))</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	lbrack := p.expect(token.LBRACK)</code></span>
<span class="codeline" id="line-608"><code>	trailingComma := token.NoPos // if valid, the position of a trailing comma preceding the ']'</code></span>
<span class="codeline" id="line-609"><code>	var args []ast.Expr</code></span>
<span class="codeline" id="line-610"><code>	if p.tok != token.RBRACK {</code></span>
<span class="codeline" id="line-611"><code>		p.exprLev++</code></span>
<span class="codeline" id="line-612"><code>		args = append(args, p.parseRhs())</code></span>
<span class="codeline" id="line-613"><code>		for p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-614"><code>			comma := p.pos</code></span>
<span class="codeline" id="line-615"><code>			p.next()</code></span>
<span class="codeline" id="line-616"><code>			if p.tok == token.RBRACK {</code></span>
<span class="codeline" id="line-617"><code>				trailingComma = comma</code></span>
<span class="codeline" id="line-618"><code>				break</code></span>
<span class="codeline" id="line-619"><code>			}</code></span>
<span class="codeline" id="line-620"><code>			args = append(args, p.parseRhs())</code></span>
<span class="codeline" id="line-621"><code>		}</code></span>
<span class="codeline" id="line-622"><code>		p.exprLev--</code></span>
<span class="codeline" id="line-623"><code>	}</code></span>
<span class="codeline" id="line-624"><code>	rbrack := p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>	if len(args) == 0 {</code></span>
<span class="codeline" id="line-627"><code>		// x []E</code></span>
<span class="codeline" id="line-628"><code>		elt := p.parseType()</code></span>
<span class="codeline" id="line-629"><code>		return x, &amp;ast.ArrayType{Lbrack: lbrack, Elt: elt}</code></span>
<span class="codeline" id="line-630"><code>	}</code></span>
<span class="codeline" id="line-631"><code></code></span>
<span class="codeline" id="line-632"><code>	// x [P]E or x[P]</code></span>
<span class="codeline" id="line-633"><code>	if len(args) == 1 {</code></span>
<span class="codeline" id="line-634"><code>		elt := p.tryIdentOrType()</code></span>
<span class="codeline" id="line-635"><code>		if elt != nil {</code></span>
<span class="codeline" id="line-636"><code>			// x [P]E</code></span>
<span class="codeline" id="line-637"><code>			if trailingComma.IsValid() {</code></span>
<span class="codeline" id="line-638"><code>				// Trailing commas are invalid in array type fields.</code></span>
<span class="codeline" id="line-639"><code>				p.error(trailingComma, "unexpected comma; expecting ]")</code></span>
<span class="codeline" id="line-640"><code>			}</code></span>
<span class="codeline" id="line-641"><code>			return x, &amp;ast.ArrayType{Lbrack: lbrack, Len: args[0], Elt: elt}</code></span>
<span class="codeline" id="line-642"><code>		}</code></span>
<span class="codeline" id="line-643"><code>	}</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>	// x[P], x[P1, P2], ...</code></span>
<span class="codeline" id="line-646"><code>	return nil, typeparams.PackIndexExpr(x, lbrack, args, rbrack)</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>func (p *parser) parseFieldDecl() *ast.Field {</code></span>
<span class="codeline" id="line-650"><code>	if p.trace {</code></span>
<span class="codeline" id="line-651"><code>		defer un(trace(p, "FieldDecl"))</code></span>
<span class="codeline" id="line-652"><code>	}</code></span>
<span class="codeline" id="line-653"><code></code></span>
<span class="codeline" id="line-654"><code>	doc := p.leadComment</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>	var names []*ast.Ident</code></span>
<span class="codeline" id="line-657"><code>	var typ ast.Expr</code></span>
<span class="codeline" id="line-658"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-659"><code>	case token.IDENT:</code></span>
<span class="codeline" id="line-660"><code>		name := p.parseIdent()</code></span>
<span class="codeline" id="line-661"><code>		if p.tok == token.PERIOD || p.tok == token.STRING || p.tok == token.SEMICOLON || p.tok == token.RBRACE {</code></span>
<span class="codeline" id="line-662"><code>			// embedded type</code></span>
<span class="codeline" id="line-663"><code>			typ = name</code></span>
<span class="codeline" id="line-664"><code>			if p.tok == token.PERIOD {</code></span>
<span class="codeline" id="line-665"><code>				typ = p.parseQualifiedIdent(name)</code></span>
<span class="codeline" id="line-666"><code>			}</code></span>
<span class="codeline" id="line-667"><code>		} else {</code></span>
<span class="codeline" id="line-668"><code>			// name1, name2, ... T</code></span>
<span class="codeline" id="line-669"><code>			names = []*ast.Ident{name}</code></span>
<span class="codeline" id="line-670"><code>			for p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-671"><code>				p.next()</code></span>
<span class="codeline" id="line-672"><code>				names = append(names, p.parseIdent())</code></span>
<span class="codeline" id="line-673"><code>			}</code></span>
<span class="codeline" id="line-674"><code>			// Careful dance: We don't know if we have an embedded instantiated</code></span>
<span class="codeline" id="line-675"><code>			// type T[P1, P2, ...] or a field T of array type []E or [P]E.</code></span>
<span class="codeline" id="line-676"><code>			if len(names) == 1 &amp;&amp; p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-677"><code>				name, typ = p.parseArrayFieldOrTypeInstance(name)</code></span>
<span class="codeline" id="line-678"><code>				if name == nil {</code></span>
<span class="codeline" id="line-679"><code>					names = nil</code></span>
<span class="codeline" id="line-680"><code>				}</code></span>
<span class="codeline" id="line-681"><code>			} else {</code></span>
<span class="codeline" id="line-682"><code>				// T P</code></span>
<span class="codeline" id="line-683"><code>				typ = p.parseType()</code></span>
<span class="codeline" id="line-684"><code>			}</code></span>
<span class="codeline" id="line-685"><code>		}</code></span>
<span class="codeline" id="line-686"><code>	case token.MUL:</code></span>
<span class="codeline" id="line-687"><code>		star := p.pos</code></span>
<span class="codeline" id="line-688"><code>		p.next()</code></span>
<span class="codeline" id="line-689"><code>		if p.tok == token.LPAREN {</code></span>
<span class="codeline" id="line-690"><code>			// *(T)</code></span>
<span class="codeline" id="line-691"><code>			p.error(p.pos, "cannot parenthesize embedded type")</code></span>
<span class="codeline" id="line-692"><code>			p.next()</code></span>
<span class="codeline" id="line-693"><code>			typ = p.parseQualifiedIdent(nil)</code></span>
<span class="codeline" id="line-694"><code>			// expect closing ')' but no need to complain if missing</code></span>
<span class="codeline" id="line-695"><code>			if p.tok == token.RPAREN {</code></span>
<span class="codeline" id="line-696"><code>				p.next()</code></span>
<span class="codeline" id="line-697"><code>			}</code></span>
<span class="codeline" id="line-698"><code>		} else {</code></span>
<span class="codeline" id="line-699"><code>			// *T</code></span>
<span class="codeline" id="line-700"><code>			typ = p.parseQualifiedIdent(nil)</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>		typ = &amp;ast.StarExpr{Star: star, X: typ}</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>	case token.LPAREN:</code></span>
<span class="codeline" id="line-705"><code>		p.error(p.pos, "cannot parenthesize embedded type")</code></span>
<span class="codeline" id="line-706"><code>		p.next()</code></span>
<span class="codeline" id="line-707"><code>		if p.tok == token.MUL {</code></span>
<span class="codeline" id="line-708"><code>			// (*T)</code></span>
<span class="codeline" id="line-709"><code>			star := p.pos</code></span>
<span class="codeline" id="line-710"><code>			p.next()</code></span>
<span class="codeline" id="line-711"><code>			typ = &amp;ast.StarExpr{Star: star, X: p.parseQualifiedIdent(nil)}</code></span>
<span class="codeline" id="line-712"><code>		} else {</code></span>
<span class="codeline" id="line-713"><code>			// (T)</code></span>
<span class="codeline" id="line-714"><code>			typ = p.parseQualifiedIdent(nil)</code></span>
<span class="codeline" id="line-715"><code>		}</code></span>
<span class="codeline" id="line-716"><code>		// expect closing ')' but no need to complain if missing</code></span>
<span class="codeline" id="line-717"><code>		if p.tok == token.RPAREN {</code></span>
<span class="codeline" id="line-718"><code>			p.next()</code></span>
<span class="codeline" id="line-719"><code>		}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>	default:</code></span>
<span class="codeline" id="line-722"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-723"><code>		p.errorExpected(pos, "field name or embedded type")</code></span>
<span class="codeline" id="line-724"><code>		p.advance(exprEnd)</code></span>
<span class="codeline" id="line-725"><code>		typ = &amp;ast.BadExpr{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-726"><code>	}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>	var tag *ast.BasicLit</code></span>
<span class="codeline" id="line-729"><code>	if p.tok == token.STRING {</code></span>
<span class="codeline" id="line-730"><code>		tag = &amp;ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}</code></span>
<span class="codeline" id="line-731"><code>		p.next()</code></span>
<span class="codeline" id="line-732"><code>	}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>	comment := p.expectSemi()</code></span>
<span class="codeline" id="line-735"><code></code></span>
<span class="codeline" id="line-736"><code>	field := &amp;ast.Field{Doc: doc, Names: names, Type: typ, Tag: tag, Comment: comment}</code></span>
<span class="codeline" id="line-737"><code>	return field</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>func (p *parser) parseStructType() *ast.StructType {</code></span>
<span class="codeline" id="line-741"><code>	if p.trace {</code></span>
<span class="codeline" id="line-742"><code>		defer un(trace(p, "StructType"))</code></span>
<span class="codeline" id="line-743"><code>	}</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>	pos := p.expect(token.STRUCT)</code></span>
<span class="codeline" id="line-746"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-747"><code>	var list []*ast.Field</code></span>
<span class="codeline" id="line-748"><code>	for p.tok == token.IDENT || p.tok == token.MUL || p.tok == token.LPAREN {</code></span>
<span class="codeline" id="line-749"><code>		// a field declaration cannot start with a '(' but we accept</code></span>
<span class="codeline" id="line-750"><code>		// it here for more robust parsing and better error messages</code></span>
<span class="codeline" id="line-751"><code>		// (parseFieldDecl will check and complain if necessary)</code></span>
<span class="codeline" id="line-752"><code>		list = append(list, p.parseFieldDecl())</code></span>
<span class="codeline" id="line-753"><code>	}</code></span>
<span class="codeline" id="line-754"><code>	rbrace := p.expect(token.RBRACE)</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>	return &amp;ast.StructType{</code></span>
<span class="codeline" id="line-757"><code>		Struct: pos,</code></span>
<span class="codeline" id="line-758"><code>		Fields: &amp;ast.FieldList{</code></span>
<span class="codeline" id="line-759"><code>			Opening: lbrace,</code></span>
<span class="codeline" id="line-760"><code>			List:    list,</code></span>
<span class="codeline" id="line-761"><code>			Closing: rbrace,</code></span>
<span class="codeline" id="line-762"><code>		},</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code>}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>func (p *parser) parsePointerType() *ast.StarExpr {</code></span>
<span class="codeline" id="line-767"><code>	if p.trace {</code></span>
<span class="codeline" id="line-768"><code>		defer un(trace(p, "PointerType"))</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code></code></span>
<span class="codeline" id="line-771"><code>	star := p.expect(token.MUL)</code></span>
<span class="codeline" id="line-772"><code>	base := p.parseType()</code></span>
<span class="codeline" id="line-773"><code></code></span>
<span class="codeline" id="line-774"><code>	return &amp;ast.StarExpr{Star: star, X: base}</code></span>
<span class="codeline" id="line-775"><code>}</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>func (p *parser) parseDotsType() *ast.Ellipsis {</code></span>
<span class="codeline" id="line-778"><code>	if p.trace {</code></span>
<span class="codeline" id="line-779"><code>		defer un(trace(p, "DotsType"))</code></span>
<span class="codeline" id="line-780"><code>	}</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>	pos := p.expect(token.ELLIPSIS)</code></span>
<span class="codeline" id="line-783"><code>	elt := p.parseType()</code></span>
<span class="codeline" id="line-784"><code></code></span>
<span class="codeline" id="line-785"><code>	return &amp;ast.Ellipsis{Ellipsis: pos, Elt: elt}</code></span>
<span class="codeline" id="line-786"><code>}</code></span>
<span class="codeline" id="line-787"><code></code></span>
<span class="codeline" id="line-788"><code>type field struct {</code></span>
<span class="codeline" id="line-789"><code>	name *ast.Ident</code></span>
<span class="codeline" id="line-790"><code>	typ  ast.Expr</code></span>
<span class="codeline" id="line-791"><code>}</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>func (p *parser) parseParamDecl(name *ast.Ident, typeSetsOK bool) (f field) {</code></span>
<span class="codeline" id="line-794"><code>	// TODO(rFindley) refactor to be more similar to paramDeclOrNil in the syntax</code></span>
<span class="codeline" id="line-795"><code>	// package</code></span>
<span class="codeline" id="line-796"><code>	if p.trace {</code></span>
<span class="codeline" id="line-797"><code>		defer un(trace(p, "ParamDeclOrNil"))</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code></code></span>
<span class="codeline" id="line-800"><code>	ptok := p.tok</code></span>
<span class="codeline" id="line-801"><code>	if name != nil {</code></span>
<span class="codeline" id="line-802"><code>		p.tok = token.IDENT // force token.IDENT case in switch below</code></span>
<span class="codeline" id="line-803"><code>	} else if typeSetsOK &amp;&amp; p.tok == token.TILDE {</code></span>
<span class="codeline" id="line-804"><code>		// "~" ...</code></span>
<span class="codeline" id="line-805"><code>		return field{nil, p.embeddedElem(nil)}</code></span>
<span class="codeline" id="line-806"><code>	}</code></span>
<span class="codeline" id="line-807"><code></code></span>
<span class="codeline" id="line-808"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-809"><code>	case token.IDENT:</code></span>
<span class="codeline" id="line-810"><code>		// name</code></span>
<span class="codeline" id="line-811"><code>		if name != nil {</code></span>
<span class="codeline" id="line-812"><code>			f.name = name</code></span>
<span class="codeline" id="line-813"><code>			p.tok = ptok</code></span>
<span class="codeline" id="line-814"><code>		} else {</code></span>
<span class="codeline" id="line-815"><code>			f.name = p.parseIdent()</code></span>
<span class="codeline" id="line-816"><code>		}</code></span>
<span class="codeline" id="line-817"><code>		switch p.tok {</code></span>
<span class="codeline" id="line-818"><code>		case token.IDENT, token.MUL, token.ARROW, token.FUNC, token.CHAN, token.MAP, token.STRUCT, token.INTERFACE, token.LPAREN:</code></span>
<span class="codeline" id="line-819"><code>			// name type</code></span>
<span class="codeline" id="line-820"><code>			f.typ = p.parseType()</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>		case token.LBRACK:</code></span>
<span class="codeline" id="line-823"><code>			// name "[" type1, ..., typeN "]" or name "[" n "]" type</code></span>
<span class="codeline" id="line-824"><code>			f.name, f.typ = p.parseArrayFieldOrTypeInstance(f.name)</code></span>
<span class="codeline" id="line-825"><code></code></span>
<span class="codeline" id="line-826"><code>		case token.ELLIPSIS:</code></span>
<span class="codeline" id="line-827"><code>			// name "..." type</code></span>
<span class="codeline" id="line-828"><code>			f.typ = p.parseDotsType()</code></span>
<span class="codeline" id="line-829"><code>			return // don't allow ...type "|" ...</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>		case token.PERIOD:</code></span>
<span class="codeline" id="line-832"><code>			// name "." ...</code></span>
<span class="codeline" id="line-833"><code>			f.typ = p.parseQualifiedIdent(f.name)</code></span>
<span class="codeline" id="line-834"><code>			f.name = nil</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>		case token.TILDE:</code></span>
<span class="codeline" id="line-837"><code>			if typeSetsOK {</code></span>
<span class="codeline" id="line-838"><code>				f.typ = p.embeddedElem(nil)</code></span>
<span class="codeline" id="line-839"><code>				return</code></span>
<span class="codeline" id="line-840"><code>			}</code></span>
<span class="codeline" id="line-841"><code></code></span>
<span class="codeline" id="line-842"><code>		case token.OR:</code></span>
<span class="codeline" id="line-843"><code>			if typeSetsOK {</code></span>
<span class="codeline" id="line-844"><code>				// name "|" typeset</code></span>
<span class="codeline" id="line-845"><code>				f.typ = p.embeddedElem(f.name)</code></span>
<span class="codeline" id="line-846"><code>				f.name = nil</code></span>
<span class="codeline" id="line-847"><code>				return</code></span>
<span class="codeline" id="line-848"><code>			}</code></span>
<span class="codeline" id="line-849"><code>		}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>	case token.MUL, token.ARROW, token.FUNC, token.LBRACK, token.CHAN, token.MAP, token.STRUCT, token.INTERFACE, token.LPAREN:</code></span>
<span class="codeline" id="line-852"><code>		// type</code></span>
<span class="codeline" id="line-853"><code>		f.typ = p.parseType()</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>	case token.ELLIPSIS:</code></span>
<span class="codeline" id="line-856"><code>		// "..." type</code></span>
<span class="codeline" id="line-857"><code>		// (always accepted)</code></span>
<span class="codeline" id="line-858"><code>		f.typ = p.parseDotsType()</code></span>
<span class="codeline" id="line-859"><code>		return // don't allow ...type "|" ...</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>	default:</code></span>
<span class="codeline" id="line-862"><code>		// TODO(rfindley): this is incorrect in the case of type parameter lists</code></span>
<span class="codeline" id="line-863"><code>		//                 (should be "']'" in that case)</code></span>
<span class="codeline" id="line-864"><code>		p.errorExpected(p.pos, "')'")</code></span>
<span class="codeline" id="line-865"><code>		p.advance(exprEnd)</code></span>
<span class="codeline" id="line-866"><code>	}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>	// [name] type "|"</code></span>
<span class="codeline" id="line-869"><code>	if typeSetsOK &amp;&amp; p.tok == token.OR &amp;&amp; f.typ != nil {</code></span>
<span class="codeline" id="line-870"><code>		f.typ = p.embeddedElem(f.typ)</code></span>
<span class="codeline" id="line-871"><code>	}</code></span>
<span class="codeline" id="line-872"><code></code></span>
<span class="codeline" id="line-873"><code>	return</code></span>
<span class="codeline" id="line-874"><code>}</code></span>
<span class="codeline" id="line-875"><code></code></span>
<span class="codeline" id="line-876"><code>func (p *parser) parseParameterList(name0 *ast.Ident, typ0 ast.Expr, closing token.Token) (params []*ast.Field) {</code></span>
<span class="codeline" id="line-877"><code>	if p.trace {</code></span>
<span class="codeline" id="line-878"><code>		defer un(trace(p, "ParameterList"))</code></span>
<span class="codeline" id="line-879"><code>	}</code></span>
<span class="codeline" id="line-880"><code></code></span>
<span class="codeline" id="line-881"><code>	// Type parameters are the only parameter list closed by ']'.</code></span>
<span class="codeline" id="line-882"><code>	tparams := closing == token.RBRACK</code></span>
<span class="codeline" id="line-883"><code></code></span>
<span class="codeline" id="line-884"><code>	pos0 := p.pos</code></span>
<span class="codeline" id="line-885"><code>	if name0 != nil {</code></span>
<span class="codeline" id="line-886"><code>		pos0 = name0.Pos()</code></span>
<span class="codeline" id="line-887"><code>	} else if typ0 != nil {</code></span>
<span class="codeline" id="line-888"><code>		pos0 = typ0.Pos()</code></span>
<span class="codeline" id="line-889"><code>	}</code></span>
<span class="codeline" id="line-890"><code></code></span>
<span class="codeline" id="line-891"><code>	// Note: The code below matches the corresponding code in the syntax</code></span>
<span class="codeline" id="line-892"><code>	//       parser closely. Changes must be reflected in either parser.</code></span>
<span class="codeline" id="line-893"><code>	//       For the code to match, we use the local []field list that</code></span>
<span class="codeline" id="line-894"><code>	//       corresponds to []syntax.Field. At the end, the list must be</code></span>
<span class="codeline" id="line-895"><code>	//       converted into an []*ast.Field.</code></span>
<span class="codeline" id="line-896"><code></code></span>
<span class="codeline" id="line-897"><code>	var list []field</code></span>
<span class="codeline" id="line-898"><code>	var named int // number of parameters that have an explicit name and type</code></span>
<span class="codeline" id="line-899"><code>	var typed int // number of parameters that have an explicit type</code></span>
<span class="codeline" id="line-900"><code></code></span>
<span class="codeline" id="line-901"><code>	for name0 != nil || p.tok != closing &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-902"><code>		var par field</code></span>
<span class="codeline" id="line-903"><code>		if typ0 != nil {</code></span>
<span class="codeline" id="line-904"><code>			if tparams {</code></span>
<span class="codeline" id="line-905"><code>				typ0 = p.embeddedElem(typ0)</code></span>
<span class="codeline" id="line-906"><code>			}</code></span>
<span class="codeline" id="line-907"><code>			par = field{name0, typ0}</code></span>
<span class="codeline" id="line-908"><code>		} else {</code></span>
<span class="codeline" id="line-909"><code>			par = p.parseParamDecl(name0, tparams)</code></span>
<span class="codeline" id="line-910"><code>		}</code></span>
<span class="codeline" id="line-911"><code>		name0 = nil // 1st name was consumed if present</code></span>
<span class="codeline" id="line-912"><code>		typ0 = nil  // 1st typ was consumed if present</code></span>
<span class="codeline" id="line-913"><code>		if par.name != nil || par.typ != nil {</code></span>
<span class="codeline" id="line-914"><code>			list = append(list, par)</code></span>
<span class="codeline" id="line-915"><code>			if par.name != nil &amp;&amp; par.typ != nil {</code></span>
<span class="codeline" id="line-916"><code>				named++</code></span>
<span class="codeline" id="line-917"><code>			}</code></span>
<span class="codeline" id="line-918"><code>			if par.typ != nil {</code></span>
<span class="codeline" id="line-919"><code>				typed++</code></span>
<span class="codeline" id="line-920"><code>			}</code></span>
<span class="codeline" id="line-921"><code>		}</code></span>
<span class="codeline" id="line-922"><code>		if !p.atComma("parameter list", closing) {</code></span>
<span class="codeline" id="line-923"><code>			break</code></span>
<span class="codeline" id="line-924"><code>		}</code></span>
<span class="codeline" id="line-925"><code>		p.next()</code></span>
<span class="codeline" id="line-926"><code>	}</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>	if len(list) == 0 {</code></span>
<span class="codeline" id="line-929"><code>		return // not uncommon</code></span>
<span class="codeline" id="line-930"><code>	}</code></span>
<span class="codeline" id="line-931"><code></code></span>
<span class="codeline" id="line-932"><code>	// distribute parameter types (len(list) &gt; 0)</code></span>
<span class="codeline" id="line-933"><code>	if named == 0 {</code></span>
<span class="codeline" id="line-934"><code>		// all unnamed =&gt; found names are type names</code></span>
<span class="codeline" id="line-935"><code>		for i := 0; i &lt; len(list); i++ {</code></span>
<span class="codeline" id="line-936"><code>			par := &amp;list[i]</code></span>
<span class="codeline" id="line-937"><code>			if typ := par.name; typ != nil {</code></span>
<span class="codeline" id="line-938"><code>				par.typ = typ</code></span>
<span class="codeline" id="line-939"><code>				par.name = nil</code></span>
<span class="codeline" id="line-940"><code>			}</code></span>
<span class="codeline" id="line-941"><code>		}</code></span>
<span class="codeline" id="line-942"><code>		if tparams {</code></span>
<span class="codeline" id="line-943"><code>			// This is the same error handling as below, adjusted for type parameters only.</code></span>
<span class="codeline" id="line-944"><code>			// See comment below for details. (go.dev/issue/64534)</code></span>
<span class="codeline" id="line-945"><code>			var errPos token.Pos</code></span>
<span class="codeline" id="line-946"><code>			var msg string</code></span>
<span class="codeline" id="line-947"><code>			if named == typed /* same as typed == 0 */ {</code></span>
<span class="codeline" id="line-948"><code>				errPos = p.pos // position error at closing ]</code></span>
<span class="codeline" id="line-949"><code>				msg = "missing type constraint"</code></span>
<span class="codeline" id="line-950"><code>			} else {</code></span>
<span class="codeline" id="line-951"><code>				errPos = pos0 // position at opening [ or first name</code></span>
<span class="codeline" id="line-952"><code>				msg = "missing type parameter name"</code></span>
<span class="codeline" id="line-953"><code>				if len(list) == 1 {</code></span>
<span class="codeline" id="line-954"><code>					msg += " or invalid array length"</code></span>
<span class="codeline" id="line-955"><code>				}</code></span>
<span class="codeline" id="line-956"><code>			}</code></span>
<span class="codeline" id="line-957"><code>			p.error(errPos, msg)</code></span>
<span class="codeline" id="line-958"><code>		}</code></span>
<span class="codeline" id="line-959"><code>	} else if named != len(list) {</code></span>
<span class="codeline" id="line-960"><code>		// some named or we're in a type parameter list =&gt; all must be named</code></span>
<span class="codeline" id="line-961"><code>		var errPos token.Pos // left-most error position (or invalid)</code></span>
<span class="codeline" id="line-962"><code>		var typ ast.Expr     // current type (from right to left)</code></span>
<span class="codeline" id="line-963"><code>		for i := len(list) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-964"><code>			if par := &amp;list[i]; par.typ != nil {</code></span>
<span class="codeline" id="line-965"><code>				typ = par.typ</code></span>
<span class="codeline" id="line-966"><code>				if par.name == nil {</code></span>
<span class="codeline" id="line-967"><code>					errPos = typ.Pos()</code></span>
<span class="codeline" id="line-968"><code>					n := ast.NewIdent("_")</code></span>
<span class="codeline" id="line-969"><code>					n.NamePos = errPos // correct position</code></span>
<span class="codeline" id="line-970"><code>					par.name = n</code></span>
<span class="codeline" id="line-971"><code>				}</code></span>
<span class="codeline" id="line-972"><code>			} else if typ != nil {</code></span>
<span class="codeline" id="line-973"><code>				par.typ = typ</code></span>
<span class="codeline" id="line-974"><code>			} else {</code></span>
<span class="codeline" id="line-975"><code>				// par.typ == nil &amp;&amp; typ == nil =&gt; we only have a par.name</code></span>
<span class="codeline" id="line-976"><code>				errPos = par.name.Pos()</code></span>
<span class="codeline" id="line-977"><code>				par.typ = &amp;ast.BadExpr{From: errPos, To: p.pos}</code></span>
<span class="codeline" id="line-978"><code>			}</code></span>
<span class="codeline" id="line-979"><code>		}</code></span>
<span class="codeline" id="line-980"><code>		if errPos.IsValid() {</code></span>
<span class="codeline" id="line-981"><code>			var msg string</code></span>
<span class="codeline" id="line-982"><code>			if tparams {</code></span>
<span class="codeline" id="line-983"><code>				// Not all parameters are named because named != len(list).</code></span>
<span class="codeline" id="line-984"><code>				// If named == typed we must have parameters that have no types,</code></span>
<span class="codeline" id="line-985"><code>				// and they must be at the end of the parameter list, otherwise</code></span>
<span class="codeline" id="line-986"><code>				// the types would have been filled in by the right-to-left sweep</code></span>
<span class="codeline" id="line-987"><code>				// above and we wouldn't have an error. Since we are in a type</code></span>
<span class="codeline" id="line-988"><code>				// parameter list, the missing types are constraints.</code></span>
<span class="codeline" id="line-989"><code>				if named == typed {</code></span>
<span class="codeline" id="line-990"><code>					errPos = p.pos // position error at closing ]</code></span>
<span class="codeline" id="line-991"><code>					msg = "missing type constraint"</code></span>
<span class="codeline" id="line-992"><code>				} else {</code></span>
<span class="codeline" id="line-993"><code>					msg = "missing type parameter name"</code></span>
<span class="codeline" id="line-994"><code>					// go.dev/issue/60812</code></span>
<span class="codeline" id="line-995"><code>					if len(list) == 1 {</code></span>
<span class="codeline" id="line-996"><code>						msg += " or invalid array length"</code></span>
<span class="codeline" id="line-997"><code>					}</code></span>
<span class="codeline" id="line-998"><code>				}</code></span>
<span class="codeline" id="line-999"><code>			} else {</code></span>
<span class="codeline" id="line-1000"><code>				msg = "mixed named and unnamed parameters"</code></span>
<span class="codeline" id="line-1001"><code>			}</code></span>
<span class="codeline" id="line-1002"><code>			p.error(errPos, msg)</code></span>
<span class="codeline" id="line-1003"><code>		}</code></span>
<span class="codeline" id="line-1004"><code>	}</code></span>
<span class="codeline" id="line-1005"><code></code></span>
<span class="codeline" id="line-1006"><code>	// Convert list to []*ast.Field.</code></span>
<span class="codeline" id="line-1007"><code>	// If list contains types only, each type gets its own ast.Field.</code></span>
<span class="codeline" id="line-1008"><code>	if named == 0 {</code></span>
<span class="codeline" id="line-1009"><code>		// parameter list consists of types only</code></span>
<span class="codeline" id="line-1010"><code>		for _, par := range list {</code></span>
<span class="codeline" id="line-1011"><code>			assert(par.typ != nil, "nil type in unnamed parameter list")</code></span>
<span class="codeline" id="line-1012"><code>			params = append(params, &amp;ast.Field{Type: par.typ})</code></span>
<span class="codeline" id="line-1013"><code>		}</code></span>
<span class="codeline" id="line-1014"><code>		return</code></span>
<span class="codeline" id="line-1015"><code>	}</code></span>
<span class="codeline" id="line-1016"><code></code></span>
<span class="codeline" id="line-1017"><code>	// If the parameter list consists of named parameters with types,</code></span>
<span class="codeline" id="line-1018"><code>	// collect all names with the same types into a single ast.Field.</code></span>
<span class="codeline" id="line-1019"><code>	var names []*ast.Ident</code></span>
<span class="codeline" id="line-1020"><code>	var typ ast.Expr</code></span>
<span class="codeline" id="line-1021"><code>	addParams := func() {</code></span>
<span class="codeline" id="line-1022"><code>		assert(typ != nil, "nil type in named parameter list")</code></span>
<span class="codeline" id="line-1023"><code>		field := &amp;ast.Field{Names: names, Type: typ}</code></span>
<span class="codeline" id="line-1024"><code>		params = append(params, field)</code></span>
<span class="codeline" id="line-1025"><code>		names = nil</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code>	for _, par := range list {</code></span>
<span class="codeline" id="line-1028"><code>		if par.typ != typ {</code></span>
<span class="codeline" id="line-1029"><code>			if len(names) &gt; 0 {</code></span>
<span class="codeline" id="line-1030"><code>				addParams()</code></span>
<span class="codeline" id="line-1031"><code>			}</code></span>
<span class="codeline" id="line-1032"><code>			typ = par.typ</code></span>
<span class="codeline" id="line-1033"><code>		}</code></span>
<span class="codeline" id="line-1034"><code>		names = append(names, par.name)</code></span>
<span class="codeline" id="line-1035"><code>	}</code></span>
<span class="codeline" id="line-1036"><code>	if len(names) &gt; 0 {</code></span>
<span class="codeline" id="line-1037"><code>		addParams()</code></span>
<span class="codeline" id="line-1038"><code>	}</code></span>
<span class="codeline" id="line-1039"><code>	return</code></span>
<span class="codeline" id="line-1040"><code>}</code></span>
<span class="codeline" id="line-1041"><code></code></span>
<span class="codeline" id="line-1042"><code>func (p *parser) parseParameters(acceptTParams bool) (tparams, params *ast.FieldList) {</code></span>
<span class="codeline" id="line-1043"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1044"><code>		defer un(trace(p, "Parameters"))</code></span>
<span class="codeline" id="line-1045"><code>	}</code></span>
<span class="codeline" id="line-1046"><code></code></span>
<span class="codeline" id="line-1047"><code>	if acceptTParams &amp;&amp; p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-1048"><code>		opening := p.pos</code></span>
<span class="codeline" id="line-1049"><code>		p.next()</code></span>
<span class="codeline" id="line-1050"><code>		// [T any](params) syntax</code></span>
<span class="codeline" id="line-1051"><code>		list := p.parseParameterList(nil, nil, token.RBRACK)</code></span>
<span class="codeline" id="line-1052"><code>		rbrack := p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-1053"><code>		tparams = &amp;ast.FieldList{Opening: opening, List: list, Closing: rbrack}</code></span>
<span class="codeline" id="line-1054"><code>		// Type parameter lists must not be empty.</code></span>
<span class="codeline" id="line-1055"><code>		if tparams.NumFields() == 0 {</code></span>
<span class="codeline" id="line-1056"><code>			p.error(tparams.Closing, "empty type parameter list")</code></span>
<span class="codeline" id="line-1057"><code>			tparams = nil // avoid follow-on errors</code></span>
<span class="codeline" id="line-1058"><code>		}</code></span>
<span class="codeline" id="line-1059"><code>	}</code></span>
<span class="codeline" id="line-1060"><code></code></span>
<span class="codeline" id="line-1061"><code>	opening := p.expect(token.LPAREN)</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>	var fields []*ast.Field</code></span>
<span class="codeline" id="line-1064"><code>	if p.tok != token.RPAREN {</code></span>
<span class="codeline" id="line-1065"><code>		fields = p.parseParameterList(nil, nil, token.RPAREN)</code></span>
<span class="codeline" id="line-1066"><code>	}</code></span>
<span class="codeline" id="line-1067"><code></code></span>
<span class="codeline" id="line-1068"><code>	rparen := p.expect(token.RPAREN)</code></span>
<span class="codeline" id="line-1069"><code>	params = &amp;ast.FieldList{Opening: opening, List: fields, Closing: rparen}</code></span>
<span class="codeline" id="line-1070"><code></code></span>
<span class="codeline" id="line-1071"><code>	return</code></span>
<span class="codeline" id="line-1072"><code>}</code></span>
<span class="codeline" id="line-1073"><code></code></span>
<span class="codeline" id="line-1074"><code>func (p *parser) parseResult() *ast.FieldList {</code></span>
<span class="codeline" id="line-1075"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1076"><code>		defer un(trace(p, "Result"))</code></span>
<span class="codeline" id="line-1077"><code>	}</code></span>
<span class="codeline" id="line-1078"><code></code></span>
<span class="codeline" id="line-1079"><code>	if p.tok == token.LPAREN {</code></span>
<span class="codeline" id="line-1080"><code>		_, results := p.parseParameters(false)</code></span>
<span class="codeline" id="line-1081"><code>		return results</code></span>
<span class="codeline" id="line-1082"><code>	}</code></span>
<span class="codeline" id="line-1083"><code></code></span>
<span class="codeline" id="line-1084"><code>	typ := p.tryIdentOrType()</code></span>
<span class="codeline" id="line-1085"><code>	if typ != nil {</code></span>
<span class="codeline" id="line-1086"><code>		list := make([]*ast.Field, 1)</code></span>
<span class="codeline" id="line-1087"><code>		list[0] = &amp;ast.Field{Type: typ}</code></span>
<span class="codeline" id="line-1088"><code>		return &amp;ast.FieldList{List: list}</code></span>
<span class="codeline" id="line-1089"><code>	}</code></span>
<span class="codeline" id="line-1090"><code></code></span>
<span class="codeline" id="line-1091"><code>	return nil</code></span>
<span class="codeline" id="line-1092"><code>}</code></span>
<span class="codeline" id="line-1093"><code></code></span>
<span class="codeline" id="line-1094"><code>func (p *parser) parseFuncType() *ast.FuncType {</code></span>
<span class="codeline" id="line-1095"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1096"><code>		defer un(trace(p, "FuncType"))</code></span>
<span class="codeline" id="line-1097"><code>	}</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>	pos := p.expect(token.FUNC)</code></span>
<span class="codeline" id="line-1100"><code>	tparams, params := p.parseParameters(true)</code></span>
<span class="codeline" id="line-1101"><code>	if tparams != nil {</code></span>
<span class="codeline" id="line-1102"><code>		p.error(tparams.Pos(), "function type must have no type parameters")</code></span>
<span class="codeline" id="line-1103"><code>	}</code></span>
<span class="codeline" id="line-1104"><code>	results := p.parseResult()</code></span>
<span class="codeline" id="line-1105"><code></code></span>
<span class="codeline" id="line-1106"><code>	return &amp;ast.FuncType{Func: pos, Params: params, Results: results}</code></span>
<span class="codeline" id="line-1107"><code>}</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>func (p *parser) parseMethodSpec() *ast.Field {</code></span>
<span class="codeline" id="line-1110"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1111"><code>		defer un(trace(p, "MethodSpec"))</code></span>
<span class="codeline" id="line-1112"><code>	}</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>	doc := p.leadComment</code></span>
<span class="codeline" id="line-1115"><code>	var idents []*ast.Ident</code></span>
<span class="codeline" id="line-1116"><code>	var typ ast.Expr</code></span>
<span class="codeline" id="line-1117"><code>	x := p.parseTypeName(nil)</code></span>
<span class="codeline" id="line-1118"><code>	if ident, _ := x.(*ast.Ident); ident != nil {</code></span>
<span class="codeline" id="line-1119"><code>		switch {</code></span>
<span class="codeline" id="line-1120"><code>		case p.tok == token.LBRACK:</code></span>
<span class="codeline" id="line-1121"><code>			// generic method or embedded instantiated type</code></span>
<span class="codeline" id="line-1122"><code>			lbrack := p.pos</code></span>
<span class="codeline" id="line-1123"><code>			p.next()</code></span>
<span class="codeline" id="line-1124"><code>			p.exprLev++</code></span>
<span class="codeline" id="line-1125"><code>			x := p.parseExpr()</code></span>
<span class="codeline" id="line-1126"><code>			p.exprLev--</code></span>
<span class="codeline" id="line-1127"><code>			if name0, _ := x.(*ast.Ident); name0 != nil &amp;&amp; p.tok != token.COMMA &amp;&amp; p.tok != token.RBRACK {</code></span>
<span class="codeline" id="line-1128"><code>				// generic method m[T any]</code></span>
<span class="codeline" id="line-1129"><code>				//</code></span>
<span class="codeline" id="line-1130"><code>				// Interface methods do not have type parameters. We parse them for a</code></span>
<span class="codeline" id="line-1131"><code>				// better error message and improved error recovery.</code></span>
<span class="codeline" id="line-1132"><code>				_ = p.parseParameterList(name0, nil, token.RBRACK)</code></span>
<span class="codeline" id="line-1133"><code>				_ = p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-1134"><code>				p.error(lbrack, "interface method must have no type parameters")</code></span>
<span class="codeline" id="line-1135"><code></code></span>
<span class="codeline" id="line-1136"><code>				// TODO(rfindley) refactor to share code with parseFuncType.</code></span>
<span class="codeline" id="line-1137"><code>				_, params := p.parseParameters(false)</code></span>
<span class="codeline" id="line-1138"><code>				results := p.parseResult()</code></span>
<span class="codeline" id="line-1139"><code>				idents = []*ast.Ident{ident}</code></span>
<span class="codeline" id="line-1140"><code>				typ = &amp;ast.FuncType{</code></span>
<span class="codeline" id="line-1141"><code>					Func:    token.NoPos,</code></span>
<span class="codeline" id="line-1142"><code>					Params:  params,</code></span>
<span class="codeline" id="line-1143"><code>					Results: results,</code></span>
<span class="codeline" id="line-1144"><code>				}</code></span>
<span class="codeline" id="line-1145"><code>			} else {</code></span>
<span class="codeline" id="line-1146"><code>				// embedded instantiated type</code></span>
<span class="codeline" id="line-1147"><code>				// TODO(rfindley) should resolve all identifiers in x.</code></span>
<span class="codeline" id="line-1148"><code>				list := []ast.Expr{x}</code></span>
<span class="codeline" id="line-1149"><code>				if p.atComma("type argument list", token.RBRACK) {</code></span>
<span class="codeline" id="line-1150"><code>					p.exprLev++</code></span>
<span class="codeline" id="line-1151"><code>					p.next()</code></span>
<span class="codeline" id="line-1152"><code>					for p.tok != token.RBRACK &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1153"><code>						list = append(list, p.parseType())</code></span>
<span class="codeline" id="line-1154"><code>						if !p.atComma("type argument list", token.RBRACK) {</code></span>
<span class="codeline" id="line-1155"><code>							break</code></span>
<span class="codeline" id="line-1156"><code>						}</code></span>
<span class="codeline" id="line-1157"><code>						p.next()</code></span>
<span class="codeline" id="line-1158"><code>					}</code></span>
<span class="codeline" id="line-1159"><code>					p.exprLev--</code></span>
<span class="codeline" id="line-1160"><code>				}</code></span>
<span class="codeline" id="line-1161"><code>				rbrack := p.expectClosing(token.RBRACK, "type argument list")</code></span>
<span class="codeline" id="line-1162"><code>				typ = typeparams.PackIndexExpr(ident, lbrack, list, rbrack)</code></span>
<span class="codeline" id="line-1163"><code>			}</code></span>
<span class="codeline" id="line-1164"><code>		case p.tok == token.LPAREN:</code></span>
<span class="codeline" id="line-1165"><code>			// ordinary method</code></span>
<span class="codeline" id="line-1166"><code>			// TODO(rfindley) refactor to share code with parseFuncType.</code></span>
<span class="codeline" id="line-1167"><code>			_, params := p.parseParameters(false)</code></span>
<span class="codeline" id="line-1168"><code>			results := p.parseResult()</code></span>
<span class="codeline" id="line-1169"><code>			idents = []*ast.Ident{ident}</code></span>
<span class="codeline" id="line-1170"><code>			typ = &amp;ast.FuncType{Func: token.NoPos, Params: params, Results: results}</code></span>
<span class="codeline" id="line-1171"><code>		default:</code></span>
<span class="codeline" id="line-1172"><code>			// embedded type</code></span>
<span class="codeline" id="line-1173"><code>			typ = x</code></span>
<span class="codeline" id="line-1174"><code>		}</code></span>
<span class="codeline" id="line-1175"><code>	} else {</code></span>
<span class="codeline" id="line-1176"><code>		// embedded, possibly instantiated type</code></span>
<span class="codeline" id="line-1177"><code>		typ = x</code></span>
<span class="codeline" id="line-1178"><code>		if p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-1179"><code>			// embedded instantiated interface</code></span>
<span class="codeline" id="line-1180"><code>			typ = p.parseTypeInstance(typ)</code></span>
<span class="codeline" id="line-1181"><code>		}</code></span>
<span class="codeline" id="line-1182"><code>	}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>	// Comment is added at the callsite: the field below may joined with</code></span>
<span class="codeline" id="line-1185"><code>	// additional type specs using '|'.</code></span>
<span class="codeline" id="line-1186"><code>	// TODO(rfindley) this should be refactored.</code></span>
<span class="codeline" id="line-1187"><code>	// TODO(rfindley) add more tests for comment handling.</code></span>
<span class="codeline" id="line-1188"><code>	return &amp;ast.Field{Doc: doc, Names: idents, Type: typ}</code></span>
<span class="codeline" id="line-1189"><code>}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>func (p *parser) embeddedElem(x ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1192"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1193"><code>		defer un(trace(p, "EmbeddedElem"))</code></span>
<span class="codeline" id="line-1194"><code>	}</code></span>
<span class="codeline" id="line-1195"><code>	if x == nil {</code></span>
<span class="codeline" id="line-1196"><code>		x = p.embeddedTerm()</code></span>
<span class="codeline" id="line-1197"><code>	}</code></span>
<span class="codeline" id="line-1198"><code>	for p.tok == token.OR {</code></span>
<span class="codeline" id="line-1199"><code>		t := new(ast.BinaryExpr)</code></span>
<span class="codeline" id="line-1200"><code>		t.OpPos = p.pos</code></span>
<span class="codeline" id="line-1201"><code>		t.Op = token.OR</code></span>
<span class="codeline" id="line-1202"><code>		p.next()</code></span>
<span class="codeline" id="line-1203"><code>		t.X = x</code></span>
<span class="codeline" id="line-1204"><code>		t.Y = p.embeddedTerm()</code></span>
<span class="codeline" id="line-1205"><code>		x = t</code></span>
<span class="codeline" id="line-1206"><code>	}</code></span>
<span class="codeline" id="line-1207"><code>	return x</code></span>
<span class="codeline" id="line-1208"><code>}</code></span>
<span class="codeline" id="line-1209"><code></code></span>
<span class="codeline" id="line-1210"><code>func (p *parser) embeddedTerm() ast.Expr {</code></span>
<span class="codeline" id="line-1211"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1212"><code>		defer un(trace(p, "EmbeddedTerm"))</code></span>
<span class="codeline" id="line-1213"><code>	}</code></span>
<span class="codeline" id="line-1214"><code>	if p.tok == token.TILDE {</code></span>
<span class="codeline" id="line-1215"><code>		t := new(ast.UnaryExpr)</code></span>
<span class="codeline" id="line-1216"><code>		t.OpPos = p.pos</code></span>
<span class="codeline" id="line-1217"><code>		t.Op = token.TILDE</code></span>
<span class="codeline" id="line-1218"><code>		p.next()</code></span>
<span class="codeline" id="line-1219"><code>		t.X = p.parseType()</code></span>
<span class="codeline" id="line-1220"><code>		return t</code></span>
<span class="codeline" id="line-1221"><code>	}</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>	t := p.tryIdentOrType()</code></span>
<span class="codeline" id="line-1224"><code>	if t == nil {</code></span>
<span class="codeline" id="line-1225"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-1226"><code>		p.errorExpected(pos, "~ term or type")</code></span>
<span class="codeline" id="line-1227"><code>		p.advance(exprEnd)</code></span>
<span class="codeline" id="line-1228"><code>		return &amp;ast.BadExpr{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-1229"><code>	}</code></span>
<span class="codeline" id="line-1230"><code></code></span>
<span class="codeline" id="line-1231"><code>	return t</code></span>
<span class="codeline" id="line-1232"><code>}</code></span>
<span class="codeline" id="line-1233"><code></code></span>
<span class="codeline" id="line-1234"><code>func (p *parser) parseInterfaceType() *ast.InterfaceType {</code></span>
<span class="codeline" id="line-1235"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1236"><code>		defer un(trace(p, "InterfaceType"))</code></span>
<span class="codeline" id="line-1237"><code>	}</code></span>
<span class="codeline" id="line-1238"><code></code></span>
<span class="codeline" id="line-1239"><code>	pos := p.expect(token.INTERFACE)</code></span>
<span class="codeline" id="line-1240"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-1241"><code></code></span>
<span class="codeline" id="line-1242"><code>	var list []*ast.Field</code></span>
<span class="codeline" id="line-1243"><code></code></span>
<span class="codeline" id="line-1244"><code>parseElements:</code></span>
<span class="codeline" id="line-1245"><code>	for {</code></span>
<span class="codeline" id="line-1246"><code>		switch {</code></span>
<span class="codeline" id="line-1247"><code>		case p.tok == token.IDENT:</code></span>
<span class="codeline" id="line-1248"><code>			f := p.parseMethodSpec()</code></span>
<span class="codeline" id="line-1249"><code>			if f.Names == nil {</code></span>
<span class="codeline" id="line-1250"><code>				f.Type = p.embeddedElem(f.Type)</code></span>
<span class="codeline" id="line-1251"><code>			}</code></span>
<span class="codeline" id="line-1252"><code>			f.Comment = p.expectSemi()</code></span>
<span class="codeline" id="line-1253"><code>			list = append(list, f)</code></span>
<span class="codeline" id="line-1254"><code>		case p.tok == token.TILDE:</code></span>
<span class="codeline" id="line-1255"><code>			typ := p.embeddedElem(nil)</code></span>
<span class="codeline" id="line-1256"><code>			comment := p.expectSemi()</code></span>
<span class="codeline" id="line-1257"><code>			list = append(list, &amp;ast.Field{Type: typ, Comment: comment})</code></span>
<span class="codeline" id="line-1258"><code>		default:</code></span>
<span class="codeline" id="line-1259"><code>			if t := p.tryIdentOrType(); t != nil {</code></span>
<span class="codeline" id="line-1260"><code>				typ := p.embeddedElem(t)</code></span>
<span class="codeline" id="line-1261"><code>				comment := p.expectSemi()</code></span>
<span class="codeline" id="line-1262"><code>				list = append(list, &amp;ast.Field{Type: typ, Comment: comment})</code></span>
<span class="codeline" id="line-1263"><code>			} else {</code></span>
<span class="codeline" id="line-1264"><code>				break parseElements</code></span>
<span class="codeline" id="line-1265"><code>			}</code></span>
<span class="codeline" id="line-1266"><code>		}</code></span>
<span class="codeline" id="line-1267"><code>	}</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>	// TODO(rfindley): the error produced here could be improved, since we could</code></span>
<span class="codeline" id="line-1270"><code>	// accept an identifier, 'type', or a '}' at this point.</code></span>
<span class="codeline" id="line-1271"><code>	rbrace := p.expect(token.RBRACE)</code></span>
<span class="codeline" id="line-1272"><code></code></span>
<span class="codeline" id="line-1273"><code>	return &amp;ast.InterfaceType{</code></span>
<span class="codeline" id="line-1274"><code>		Interface: pos,</code></span>
<span class="codeline" id="line-1275"><code>		Methods: &amp;ast.FieldList{</code></span>
<span class="codeline" id="line-1276"><code>			Opening: lbrace,</code></span>
<span class="codeline" id="line-1277"><code>			List:    list,</code></span>
<span class="codeline" id="line-1278"><code>			Closing: rbrace,</code></span>
<span class="codeline" id="line-1279"><code>		},</code></span>
<span class="codeline" id="line-1280"><code>	}</code></span>
<span class="codeline" id="line-1281"><code>}</code></span>
<span class="codeline" id="line-1282"><code></code></span>
<span class="codeline" id="line-1283"><code>func (p *parser) parseMapType() *ast.MapType {</code></span>
<span class="codeline" id="line-1284"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1285"><code>		defer un(trace(p, "MapType"))</code></span>
<span class="codeline" id="line-1286"><code>	}</code></span>
<span class="codeline" id="line-1287"><code></code></span>
<span class="codeline" id="line-1288"><code>	pos := p.expect(token.MAP)</code></span>
<span class="codeline" id="line-1289"><code>	p.expect(token.LBRACK)</code></span>
<span class="codeline" id="line-1290"><code>	key := p.parseType()</code></span>
<span class="codeline" id="line-1291"><code>	p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-1292"><code>	value := p.parseType()</code></span>
<span class="codeline" id="line-1293"><code></code></span>
<span class="codeline" id="line-1294"><code>	return &amp;ast.MapType{Map: pos, Key: key, Value: value}</code></span>
<span class="codeline" id="line-1295"><code>}</code></span>
<span class="codeline" id="line-1296"><code></code></span>
<span class="codeline" id="line-1297"><code>func (p *parser) parseChanType() *ast.ChanType {</code></span>
<span class="codeline" id="line-1298"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1299"><code>		defer un(trace(p, "ChanType"))</code></span>
<span class="codeline" id="line-1300"><code>	}</code></span>
<span class="codeline" id="line-1301"><code></code></span>
<span class="codeline" id="line-1302"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-1303"><code>	dir := ast.SEND | ast.RECV</code></span>
<span class="codeline" id="line-1304"><code>	var arrow token.Pos</code></span>
<span class="codeline" id="line-1305"><code>	if p.tok == token.CHAN {</code></span>
<span class="codeline" id="line-1306"><code>		p.next()</code></span>
<span class="codeline" id="line-1307"><code>		if p.tok == token.ARROW {</code></span>
<span class="codeline" id="line-1308"><code>			arrow = p.pos</code></span>
<span class="codeline" id="line-1309"><code>			p.next()</code></span>
<span class="codeline" id="line-1310"><code>			dir = ast.SEND</code></span>
<span class="codeline" id="line-1311"><code>		}</code></span>
<span class="codeline" id="line-1312"><code>	} else {</code></span>
<span class="codeline" id="line-1313"><code>		arrow = p.expect(token.ARROW)</code></span>
<span class="codeline" id="line-1314"><code>		p.expect(token.CHAN)</code></span>
<span class="codeline" id="line-1315"><code>		dir = ast.RECV</code></span>
<span class="codeline" id="line-1316"><code>	}</code></span>
<span class="codeline" id="line-1317"><code>	value := p.parseType()</code></span>
<span class="codeline" id="line-1318"><code></code></span>
<span class="codeline" id="line-1319"><code>	return &amp;ast.ChanType{Begin: pos, Arrow: arrow, Dir: dir, Value: value}</code></span>
<span class="codeline" id="line-1320"><code>}</code></span>
<span class="codeline" id="line-1321"><code></code></span>
<span class="codeline" id="line-1322"><code>func (p *parser) parseTypeInstance(typ ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1323"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1324"><code>		defer un(trace(p, "TypeInstance"))</code></span>
<span class="codeline" id="line-1325"><code>	}</code></span>
<span class="codeline" id="line-1326"><code></code></span>
<span class="codeline" id="line-1327"><code>	opening := p.expect(token.LBRACK)</code></span>
<span class="codeline" id="line-1328"><code>	p.exprLev++</code></span>
<span class="codeline" id="line-1329"><code>	var list []ast.Expr</code></span>
<span class="codeline" id="line-1330"><code>	for p.tok != token.RBRACK &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1331"><code>		list = append(list, p.parseType())</code></span>
<span class="codeline" id="line-1332"><code>		if !p.atComma("type argument list", token.RBRACK) {</code></span>
<span class="codeline" id="line-1333"><code>			break</code></span>
<span class="codeline" id="line-1334"><code>		}</code></span>
<span class="codeline" id="line-1335"><code>		p.next()</code></span>
<span class="codeline" id="line-1336"><code>	}</code></span>
<span class="codeline" id="line-1337"><code>	p.exprLev--</code></span>
<span class="codeline" id="line-1338"><code></code></span>
<span class="codeline" id="line-1339"><code>	closing := p.expectClosing(token.RBRACK, "type argument list")</code></span>
<span class="codeline" id="line-1340"><code></code></span>
<span class="codeline" id="line-1341"><code>	if len(list) == 0 {</code></span>
<span class="codeline" id="line-1342"><code>		p.errorExpected(closing, "type argument list")</code></span>
<span class="codeline" id="line-1343"><code>		return &amp;ast.IndexExpr{</code></span>
<span class="codeline" id="line-1344"><code>			X:      typ,</code></span>
<span class="codeline" id="line-1345"><code>			Lbrack: opening,</code></span>
<span class="codeline" id="line-1346"><code>			Index:  &amp;ast.BadExpr{From: opening + 1, To: closing},</code></span>
<span class="codeline" id="line-1347"><code>			Rbrack: closing,</code></span>
<span class="codeline" id="line-1348"><code>		}</code></span>
<span class="codeline" id="line-1349"><code>	}</code></span>
<span class="codeline" id="line-1350"><code></code></span>
<span class="codeline" id="line-1351"><code>	return typeparams.PackIndexExpr(typ, opening, list, closing)</code></span>
<span class="codeline" id="line-1352"><code>}</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>func (p *parser) tryIdentOrType() ast.Expr {</code></span>
<span class="codeline" id="line-1355"><code>	defer decNestLev(incNestLev(p))</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1358"><code>	case token.IDENT:</code></span>
<span class="codeline" id="line-1359"><code>		typ := p.parseTypeName(nil)</code></span>
<span class="codeline" id="line-1360"><code>		if p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-1361"><code>			typ = p.parseTypeInstance(typ)</code></span>
<span class="codeline" id="line-1362"><code>		}</code></span>
<span class="codeline" id="line-1363"><code>		return typ</code></span>
<span class="codeline" id="line-1364"><code>	case token.LBRACK:</code></span>
<span class="codeline" id="line-1365"><code>		lbrack := p.expect(token.LBRACK)</code></span>
<span class="codeline" id="line-1366"><code>		return p.parseArrayType(lbrack, nil)</code></span>
<span class="codeline" id="line-1367"><code>	case token.STRUCT:</code></span>
<span class="codeline" id="line-1368"><code>		return p.parseStructType()</code></span>
<span class="codeline" id="line-1369"><code>	case token.MUL:</code></span>
<span class="codeline" id="line-1370"><code>		return p.parsePointerType()</code></span>
<span class="codeline" id="line-1371"><code>	case token.FUNC:</code></span>
<span class="codeline" id="line-1372"><code>		return p.parseFuncType()</code></span>
<span class="codeline" id="line-1373"><code>	case token.INTERFACE:</code></span>
<span class="codeline" id="line-1374"><code>		return p.parseInterfaceType()</code></span>
<span class="codeline" id="line-1375"><code>	case token.MAP:</code></span>
<span class="codeline" id="line-1376"><code>		return p.parseMapType()</code></span>
<span class="codeline" id="line-1377"><code>	case token.CHAN, token.ARROW:</code></span>
<span class="codeline" id="line-1378"><code>		return p.parseChanType()</code></span>
<span class="codeline" id="line-1379"><code>	case token.LPAREN:</code></span>
<span class="codeline" id="line-1380"><code>		lparen := p.pos</code></span>
<span class="codeline" id="line-1381"><code>		p.next()</code></span>
<span class="codeline" id="line-1382"><code>		typ := p.parseType()</code></span>
<span class="codeline" id="line-1383"><code>		rparen := p.expect(token.RPAREN)</code></span>
<span class="codeline" id="line-1384"><code>		return &amp;ast.ParenExpr{Lparen: lparen, X: typ, Rparen: rparen}</code></span>
<span class="codeline" id="line-1385"><code>	}</code></span>
<span class="codeline" id="line-1386"><code></code></span>
<span class="codeline" id="line-1387"><code>	// no type found</code></span>
<span class="codeline" id="line-1388"><code>	return nil</code></span>
<span class="codeline" id="line-1389"><code>}</code></span>
<span class="codeline" id="line-1390"><code></code></span>
<span class="codeline" id="line-1391"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-1392"><code>// Blocks</code></span>
<span class="codeline" id="line-1393"><code></code></span>
<span class="codeline" id="line-1394"><code>func (p *parser) parseStmtList() (list []ast.Stmt) {</code></span>
<span class="codeline" id="line-1395"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1396"><code>		defer un(trace(p, "StatementList"))</code></span>
<span class="codeline" id="line-1397"><code>	}</code></span>
<span class="codeline" id="line-1398"><code></code></span>
<span class="codeline" id="line-1399"><code>	for p.tok != token.CASE &amp;&amp; p.tok != token.DEFAULT &amp;&amp; p.tok != token.RBRACE &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1400"><code>		list = append(list, p.parseStmt())</code></span>
<span class="codeline" id="line-1401"><code>	}</code></span>
<span class="codeline" id="line-1402"><code></code></span>
<span class="codeline" id="line-1403"><code>	return</code></span>
<span class="codeline" id="line-1404"><code>}</code></span>
<span class="codeline" id="line-1405"><code></code></span>
<span class="codeline" id="line-1406"><code>func (p *parser) parseBody() *ast.BlockStmt {</code></span>
<span class="codeline" id="line-1407"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1408"><code>		defer un(trace(p, "Body"))</code></span>
<span class="codeline" id="line-1409"><code>	}</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-1412"><code>	list := p.parseStmtList()</code></span>
<span class="codeline" id="line-1413"><code>	rbrace := p.expect2(token.RBRACE)</code></span>
<span class="codeline" id="line-1414"><code></code></span>
<span class="codeline" id="line-1415"><code>	return &amp;ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}</code></span>
<span class="codeline" id="line-1416"><code>}</code></span>
<span class="codeline" id="line-1417"><code></code></span>
<span class="codeline" id="line-1418"><code>func (p *parser) parseBlockStmt() *ast.BlockStmt {</code></span>
<span class="codeline" id="line-1419"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1420"><code>		defer un(trace(p, "BlockStmt"))</code></span>
<span class="codeline" id="line-1421"><code>	}</code></span>
<span class="codeline" id="line-1422"><code></code></span>
<span class="codeline" id="line-1423"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-1424"><code>	list := p.parseStmtList()</code></span>
<span class="codeline" id="line-1425"><code>	rbrace := p.expect2(token.RBRACE)</code></span>
<span class="codeline" id="line-1426"><code></code></span>
<span class="codeline" id="line-1427"><code>	return &amp;ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}</code></span>
<span class="codeline" id="line-1428"><code>}</code></span>
<span class="codeline" id="line-1429"><code></code></span>
<span class="codeline" id="line-1430"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-1431"><code>// Expressions</code></span>
<span class="codeline" id="line-1432"><code></code></span>
<span class="codeline" id="line-1433"><code>func (p *parser) parseFuncTypeOrLit() ast.Expr {</code></span>
<span class="codeline" id="line-1434"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1435"><code>		defer un(trace(p, "FuncTypeOrLit"))</code></span>
<span class="codeline" id="line-1436"><code>	}</code></span>
<span class="codeline" id="line-1437"><code></code></span>
<span class="codeline" id="line-1438"><code>	typ := p.parseFuncType()</code></span>
<span class="codeline" id="line-1439"><code>	if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-1440"><code>		// function type only</code></span>
<span class="codeline" id="line-1441"><code>		return typ</code></span>
<span class="codeline" id="line-1442"><code>	}</code></span>
<span class="codeline" id="line-1443"><code></code></span>
<span class="codeline" id="line-1444"><code>	p.exprLev++</code></span>
<span class="codeline" id="line-1445"><code>	body := p.parseBody()</code></span>
<span class="codeline" id="line-1446"><code>	p.exprLev--</code></span>
<span class="codeline" id="line-1447"><code></code></span>
<span class="codeline" id="line-1448"><code>	return &amp;ast.FuncLit{Type: typ, Body: body}</code></span>
<span class="codeline" id="line-1449"><code>}</code></span>
<span class="codeline" id="line-1450"><code></code></span>
<span class="codeline" id="line-1451"><code>// parseOperand may return an expression or a raw type (incl. array</code></span>
<span class="codeline" id="line-1452"><code>// types of the form [...]T). Callers must verify the result.</code></span>
<span class="codeline" id="line-1453"><code>func (p *parser) parseOperand() ast.Expr {</code></span>
<span class="codeline" id="line-1454"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1455"><code>		defer un(trace(p, "Operand"))</code></span>
<span class="codeline" id="line-1456"><code>	}</code></span>
<span class="codeline" id="line-1457"><code></code></span>
<span class="codeline" id="line-1458"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1459"><code>	case token.IDENT:</code></span>
<span class="codeline" id="line-1460"><code>		x := p.parseIdent()</code></span>
<span class="codeline" id="line-1461"><code>		return x</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>	case token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:</code></span>
<span class="codeline" id="line-1464"><code>		x := &amp;ast.BasicLit{ValuePos: p.pos, Kind: p.tok, Value: p.lit}</code></span>
<span class="codeline" id="line-1465"><code>		p.next()</code></span>
<span class="codeline" id="line-1466"><code>		return x</code></span>
<span class="codeline" id="line-1467"><code></code></span>
<span class="codeline" id="line-1468"><code>	case token.LPAREN:</code></span>
<span class="codeline" id="line-1469"><code>		lparen := p.pos</code></span>
<span class="codeline" id="line-1470"><code>		p.next()</code></span>
<span class="codeline" id="line-1471"><code>		p.exprLev++</code></span>
<span class="codeline" id="line-1472"><code>		x := p.parseRhs() // types may be parenthesized: (some type)</code></span>
<span class="codeline" id="line-1473"><code>		p.exprLev--</code></span>
<span class="codeline" id="line-1474"><code>		rparen := p.expect(token.RPAREN)</code></span>
<span class="codeline" id="line-1475"><code>		return &amp;ast.ParenExpr{Lparen: lparen, X: x, Rparen: rparen}</code></span>
<span class="codeline" id="line-1476"><code></code></span>
<span class="codeline" id="line-1477"><code>	case token.FUNC:</code></span>
<span class="codeline" id="line-1478"><code>		return p.parseFuncTypeOrLit()</code></span>
<span class="codeline" id="line-1479"><code>	}</code></span>
<span class="codeline" id="line-1480"><code></code></span>
<span class="codeline" id="line-1481"><code>	if typ := p.tryIdentOrType(); typ != nil { // do not consume trailing type parameters</code></span>
<span class="codeline" id="line-1482"><code>		// could be type for composite literal or conversion</code></span>
<span class="codeline" id="line-1483"><code>		_, isIdent := typ.(*ast.Ident)</code></span>
<span class="codeline" id="line-1484"><code>		assert(!isIdent, "type cannot be identifier")</code></span>
<span class="codeline" id="line-1485"><code>		return typ</code></span>
<span class="codeline" id="line-1486"><code>	}</code></span>
<span class="codeline" id="line-1487"><code></code></span>
<span class="codeline" id="line-1488"><code>	// we have an error</code></span>
<span class="codeline" id="line-1489"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-1490"><code>	p.errorExpected(pos, "operand")</code></span>
<span class="codeline" id="line-1491"><code>	p.advance(stmtStart)</code></span>
<span class="codeline" id="line-1492"><code>	return &amp;ast.BadExpr{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-1493"><code>}</code></span>
<span class="codeline" id="line-1494"><code></code></span>
<span class="codeline" id="line-1495"><code>func (p *parser) parseSelector(x ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1496"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1497"><code>		defer un(trace(p, "Selector"))</code></span>
<span class="codeline" id="line-1498"><code>	}</code></span>
<span class="codeline" id="line-1499"><code></code></span>
<span class="codeline" id="line-1500"><code>	sel := p.parseIdent()</code></span>
<span class="codeline" id="line-1501"><code></code></span>
<span class="codeline" id="line-1502"><code>	return &amp;ast.SelectorExpr{X: x, Sel: sel}</code></span>
<span class="codeline" id="line-1503"><code>}</code></span>
<span class="codeline" id="line-1504"><code></code></span>
<span class="codeline" id="line-1505"><code>func (p *parser) parseTypeAssertion(x ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1506"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1507"><code>		defer un(trace(p, "TypeAssertion"))</code></span>
<span class="codeline" id="line-1508"><code>	}</code></span>
<span class="codeline" id="line-1509"><code></code></span>
<span class="codeline" id="line-1510"><code>	lparen := p.expect(token.LPAREN)</code></span>
<span class="codeline" id="line-1511"><code>	var typ ast.Expr</code></span>
<span class="codeline" id="line-1512"><code>	if p.tok == token.TYPE {</code></span>
<span class="codeline" id="line-1513"><code>		// type switch: typ == nil</code></span>
<span class="codeline" id="line-1514"><code>		p.next()</code></span>
<span class="codeline" id="line-1515"><code>	} else {</code></span>
<span class="codeline" id="line-1516"><code>		typ = p.parseType()</code></span>
<span class="codeline" id="line-1517"><code>	}</code></span>
<span class="codeline" id="line-1518"><code>	rparen := p.expect(token.RPAREN)</code></span>
<span class="codeline" id="line-1519"><code></code></span>
<span class="codeline" id="line-1520"><code>	return &amp;ast.TypeAssertExpr{X: x, Type: typ, Lparen: lparen, Rparen: rparen}</code></span>
<span class="codeline" id="line-1521"><code>}</code></span>
<span class="codeline" id="line-1522"><code></code></span>
<span class="codeline" id="line-1523"><code>func (p *parser) parseIndexOrSliceOrInstance(x ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1524"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1525"><code>		defer un(trace(p, "parseIndexOrSliceOrInstance"))</code></span>
<span class="codeline" id="line-1526"><code>	}</code></span>
<span class="codeline" id="line-1527"><code></code></span>
<span class="codeline" id="line-1528"><code>	lbrack := p.expect(token.LBRACK)</code></span>
<span class="codeline" id="line-1529"><code>	if p.tok == token.RBRACK {</code></span>
<span class="codeline" id="line-1530"><code>		// empty index, slice or index expressions are not permitted;</code></span>
<span class="codeline" id="line-1531"><code>		// accept them for parsing tolerance, but complain</code></span>
<span class="codeline" id="line-1532"><code>		p.errorExpected(p.pos, "operand")</code></span>
<span class="codeline" id="line-1533"><code>		rbrack := p.pos</code></span>
<span class="codeline" id="line-1534"><code>		p.next()</code></span>
<span class="codeline" id="line-1535"><code>		return &amp;ast.IndexExpr{</code></span>
<span class="codeline" id="line-1536"><code>			X:      x,</code></span>
<span class="codeline" id="line-1537"><code>			Lbrack: lbrack,</code></span>
<span class="codeline" id="line-1538"><code>			Index:  &amp;ast.BadExpr{From: rbrack, To: rbrack},</code></span>
<span class="codeline" id="line-1539"><code>			Rbrack: rbrack,</code></span>
<span class="codeline" id="line-1540"><code>		}</code></span>
<span class="codeline" id="line-1541"><code>	}</code></span>
<span class="codeline" id="line-1542"><code>	p.exprLev++</code></span>
<span class="codeline" id="line-1543"><code></code></span>
<span class="codeline" id="line-1544"><code>	const N = 3 // change the 3 to 2 to disable 3-index slices</code></span>
<span class="codeline" id="line-1545"><code>	var args []ast.Expr</code></span>
<span class="codeline" id="line-1546"><code>	var index [N]ast.Expr</code></span>
<span class="codeline" id="line-1547"><code>	var colons [N - 1]token.Pos</code></span>
<span class="codeline" id="line-1548"><code>	if p.tok != token.COLON {</code></span>
<span class="codeline" id="line-1549"><code>		// We can't know if we have an index expression or a type instantiation;</code></span>
<span class="codeline" id="line-1550"><code>		// so even if we see a (named) type we are not going to be in type context.</code></span>
<span class="codeline" id="line-1551"><code>		index[0] = p.parseRhs()</code></span>
<span class="codeline" id="line-1552"><code>	}</code></span>
<span class="codeline" id="line-1553"><code>	ncolons := 0</code></span>
<span class="codeline" id="line-1554"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1555"><code>	case token.COLON:</code></span>
<span class="codeline" id="line-1556"><code>		// slice expression</code></span>
<span class="codeline" id="line-1557"><code>		for p.tok == token.COLON &amp;&amp; ncolons &lt; len(colons) {</code></span>
<span class="codeline" id="line-1558"><code>			colons[ncolons] = p.pos</code></span>
<span class="codeline" id="line-1559"><code>			ncolons++</code></span>
<span class="codeline" id="line-1560"><code>			p.next()</code></span>
<span class="codeline" id="line-1561"><code>			if p.tok != token.COLON &amp;&amp; p.tok != token.RBRACK &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1562"><code>				index[ncolons] = p.parseRhs()</code></span>
<span class="codeline" id="line-1563"><code>			}</code></span>
<span class="codeline" id="line-1564"><code>		}</code></span>
<span class="codeline" id="line-1565"><code>	case token.COMMA:</code></span>
<span class="codeline" id="line-1566"><code>		// instance expression</code></span>
<span class="codeline" id="line-1567"><code>		args = append(args, index[0])</code></span>
<span class="codeline" id="line-1568"><code>		for p.tok == token.COMMA {</code></span>
<span class="codeline" id="line-1569"><code>			p.next()</code></span>
<span class="codeline" id="line-1570"><code>			if p.tok != token.RBRACK &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1571"><code>				args = append(args, p.parseType())</code></span>
<span class="codeline" id="line-1572"><code>			}</code></span>
<span class="codeline" id="line-1573"><code>		}</code></span>
<span class="codeline" id="line-1574"><code>	}</code></span>
<span class="codeline" id="line-1575"><code></code></span>
<span class="codeline" id="line-1576"><code>	p.exprLev--</code></span>
<span class="codeline" id="line-1577"><code>	rbrack := p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-1578"><code></code></span>
<span class="codeline" id="line-1579"><code>	if ncolons &gt; 0 {</code></span>
<span class="codeline" id="line-1580"><code>		// slice expression</code></span>
<span class="codeline" id="line-1581"><code>		slice3 := false</code></span>
<span class="codeline" id="line-1582"><code>		if ncolons == 2 {</code></span>
<span class="codeline" id="line-1583"><code>			slice3 = true</code></span>
<span class="codeline" id="line-1584"><code>			// Check presence of middle and final index here rather than during type-checking</code></span>
<span class="codeline" id="line-1585"><code>			// to prevent erroneous programs from passing through gofmt (was go.dev/issue/7305).</code></span>
<span class="codeline" id="line-1586"><code>			if index[1] == nil {</code></span>
<span class="codeline" id="line-1587"><code>				p.error(colons[0], "middle index required in 3-index slice")</code></span>
<span class="codeline" id="line-1588"><code>				index[1] = &amp;ast.BadExpr{From: colons[0] + 1, To: colons[1]}</code></span>
<span class="codeline" id="line-1589"><code>			}</code></span>
<span class="codeline" id="line-1590"><code>			if index[2] == nil {</code></span>
<span class="codeline" id="line-1591"><code>				p.error(colons[1], "final index required in 3-index slice")</code></span>
<span class="codeline" id="line-1592"><code>				index[2] = &amp;ast.BadExpr{From: colons[1] + 1, To: rbrack}</code></span>
<span class="codeline" id="line-1593"><code>			}</code></span>
<span class="codeline" id="line-1594"><code>		}</code></span>
<span class="codeline" id="line-1595"><code>		return &amp;ast.SliceExpr{X: x, Lbrack: lbrack, Low: index[0], High: index[1], Max: index[2], Slice3: slice3, Rbrack: rbrack}</code></span>
<span class="codeline" id="line-1596"><code>	}</code></span>
<span class="codeline" id="line-1597"><code></code></span>
<span class="codeline" id="line-1598"><code>	if len(args) == 0 {</code></span>
<span class="codeline" id="line-1599"><code>		// index expression</code></span>
<span class="codeline" id="line-1600"><code>		return &amp;ast.IndexExpr{X: x, Lbrack: lbrack, Index: index[0], Rbrack: rbrack}</code></span>
<span class="codeline" id="line-1601"><code>	}</code></span>
<span class="codeline" id="line-1602"><code></code></span>
<span class="codeline" id="line-1603"><code>	// instance expression</code></span>
<span class="codeline" id="line-1604"><code>	return typeparams.PackIndexExpr(x, lbrack, args, rbrack)</code></span>
<span class="codeline" id="line-1605"><code>}</code></span>
<span class="codeline" id="line-1606"><code></code></span>
<span class="codeline" id="line-1607"><code>func (p *parser) parseCallOrConversion(fun ast.Expr) *ast.CallExpr {</code></span>
<span class="codeline" id="line-1608"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1609"><code>		defer un(trace(p, "CallOrConversion"))</code></span>
<span class="codeline" id="line-1610"><code>	}</code></span>
<span class="codeline" id="line-1611"><code></code></span>
<span class="codeline" id="line-1612"><code>	lparen := p.expect(token.LPAREN)</code></span>
<span class="codeline" id="line-1613"><code>	p.exprLev++</code></span>
<span class="codeline" id="line-1614"><code>	var list []ast.Expr</code></span>
<span class="codeline" id="line-1615"><code>	var ellipsis token.Pos</code></span>
<span class="codeline" id="line-1616"><code>	for p.tok != token.RPAREN &amp;&amp; p.tok != token.EOF &amp;&amp; !ellipsis.IsValid() {</code></span>
<span class="codeline" id="line-1617"><code>		list = append(list, p.parseRhs()) // builtins may expect a type: make(some type, ...)</code></span>
<span class="codeline" id="line-1618"><code>		if p.tok == token.ELLIPSIS {</code></span>
<span class="codeline" id="line-1619"><code>			ellipsis = p.pos</code></span>
<span class="codeline" id="line-1620"><code>			p.next()</code></span>
<span class="codeline" id="line-1621"><code>		}</code></span>
<span class="codeline" id="line-1622"><code>		if !p.atComma("argument list", token.RPAREN) {</code></span>
<span class="codeline" id="line-1623"><code>			break</code></span>
<span class="codeline" id="line-1624"><code>		}</code></span>
<span class="codeline" id="line-1625"><code>		p.next()</code></span>
<span class="codeline" id="line-1626"><code>	}</code></span>
<span class="codeline" id="line-1627"><code>	p.exprLev--</code></span>
<span class="codeline" id="line-1628"><code>	rparen := p.expectClosing(token.RPAREN, "argument list")</code></span>
<span class="codeline" id="line-1629"><code></code></span>
<span class="codeline" id="line-1630"><code>	return &amp;ast.CallExpr{Fun: fun, Lparen: lparen, Args: list, Ellipsis: ellipsis, Rparen: rparen}</code></span>
<span class="codeline" id="line-1631"><code>}</code></span>
<span class="codeline" id="line-1632"><code></code></span>
<span class="codeline" id="line-1633"><code>func (p *parser) parseValue() ast.Expr {</code></span>
<span class="codeline" id="line-1634"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1635"><code>		defer un(trace(p, "Element"))</code></span>
<span class="codeline" id="line-1636"><code>	}</code></span>
<span class="codeline" id="line-1637"><code></code></span>
<span class="codeline" id="line-1638"><code>	if p.tok == token.LBRACE {</code></span>
<span class="codeline" id="line-1639"><code>		return p.parseLiteralValue(nil)</code></span>
<span class="codeline" id="line-1640"><code>	}</code></span>
<span class="codeline" id="line-1641"><code></code></span>
<span class="codeline" id="line-1642"><code>	x := p.parseExpr()</code></span>
<span class="codeline" id="line-1643"><code></code></span>
<span class="codeline" id="line-1644"><code>	return x</code></span>
<span class="codeline" id="line-1645"><code>}</code></span>
<span class="codeline" id="line-1646"><code></code></span>
<span class="codeline" id="line-1647"><code>func (p *parser) parseElement() ast.Expr {</code></span>
<span class="codeline" id="line-1648"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1649"><code>		defer un(trace(p, "Element"))</code></span>
<span class="codeline" id="line-1650"><code>	}</code></span>
<span class="codeline" id="line-1651"><code></code></span>
<span class="codeline" id="line-1652"><code>	x := p.parseValue()</code></span>
<span class="codeline" id="line-1653"><code>	if p.tok == token.COLON {</code></span>
<span class="codeline" id="line-1654"><code>		colon := p.pos</code></span>
<span class="codeline" id="line-1655"><code>		p.next()</code></span>
<span class="codeline" id="line-1656"><code>		x = &amp;ast.KeyValueExpr{Key: x, Colon: colon, Value: p.parseValue()}</code></span>
<span class="codeline" id="line-1657"><code>	}</code></span>
<span class="codeline" id="line-1658"><code></code></span>
<span class="codeline" id="line-1659"><code>	return x</code></span>
<span class="codeline" id="line-1660"><code>}</code></span>
<span class="codeline" id="line-1661"><code></code></span>
<span class="codeline" id="line-1662"><code>func (p *parser) parseElementList() (list []ast.Expr) {</code></span>
<span class="codeline" id="line-1663"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1664"><code>		defer un(trace(p, "ElementList"))</code></span>
<span class="codeline" id="line-1665"><code>	}</code></span>
<span class="codeline" id="line-1666"><code></code></span>
<span class="codeline" id="line-1667"><code>	for p.tok != token.RBRACE &amp;&amp; p.tok != token.EOF {</code></span>
<span class="codeline" id="line-1668"><code>		list = append(list, p.parseElement())</code></span>
<span class="codeline" id="line-1669"><code>		if !p.atComma("composite literal", token.RBRACE) {</code></span>
<span class="codeline" id="line-1670"><code>			break</code></span>
<span class="codeline" id="line-1671"><code>		}</code></span>
<span class="codeline" id="line-1672"><code>		p.next()</code></span>
<span class="codeline" id="line-1673"><code>	}</code></span>
<span class="codeline" id="line-1674"><code></code></span>
<span class="codeline" id="line-1675"><code>	return</code></span>
<span class="codeline" id="line-1676"><code>}</code></span>
<span class="codeline" id="line-1677"><code></code></span>
<span class="codeline" id="line-1678"><code>func (p *parser) parseLiteralValue(typ ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1679"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1680"><code>		defer un(trace(p, "LiteralValue"))</code></span>
<span class="codeline" id="line-1681"><code>	}</code></span>
<span class="codeline" id="line-1682"><code></code></span>
<span class="codeline" id="line-1683"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-1684"><code>	var elts []ast.Expr</code></span>
<span class="codeline" id="line-1685"><code>	p.exprLev++</code></span>
<span class="codeline" id="line-1686"><code>	if p.tok != token.RBRACE {</code></span>
<span class="codeline" id="line-1687"><code>		elts = p.parseElementList()</code></span>
<span class="codeline" id="line-1688"><code>	}</code></span>
<span class="codeline" id="line-1689"><code>	p.exprLev--</code></span>
<span class="codeline" id="line-1690"><code>	rbrace := p.expectClosing(token.RBRACE, "composite literal")</code></span>
<span class="codeline" id="line-1691"><code>	return &amp;ast.CompositeLit{Type: typ, Lbrace: lbrace, Elts: elts, Rbrace: rbrace}</code></span>
<span class="codeline" id="line-1692"><code>}</code></span>
<span class="codeline" id="line-1693"><code></code></span>
<span class="codeline" id="line-1694"><code>func (p *parser) parsePrimaryExpr(x ast.Expr) ast.Expr {</code></span>
<span class="codeline" id="line-1695"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1696"><code>		defer un(trace(p, "PrimaryExpr"))</code></span>
<span class="codeline" id="line-1697"><code>	}</code></span>
<span class="codeline" id="line-1698"><code></code></span>
<span class="codeline" id="line-1699"><code>	if x == nil {</code></span>
<span class="codeline" id="line-1700"><code>		x = p.parseOperand()</code></span>
<span class="codeline" id="line-1701"><code>	}</code></span>
<span class="codeline" id="line-1702"><code>	// We track the nesting here rather than at the entry for the function,</code></span>
<span class="codeline" id="line-1703"><code>	// since it can iteratively produce a nested output, and we want to</code></span>
<span class="codeline" id="line-1704"><code>	// limit how deep a structure we generate.</code></span>
<span class="codeline" id="line-1705"><code>	var n int</code></span>
<span class="codeline" id="line-1706"><code>	defer func() { p.nestLev -= n }()</code></span>
<span class="codeline" id="line-1707"><code>	for n = 1; ; n++ {</code></span>
<span class="codeline" id="line-1708"><code>		incNestLev(p)</code></span>
<span class="codeline" id="line-1709"><code>		switch p.tok {</code></span>
<span class="codeline" id="line-1710"><code>		case token.PERIOD:</code></span>
<span class="codeline" id="line-1711"><code>			p.next()</code></span>
<span class="codeline" id="line-1712"><code>			switch p.tok {</code></span>
<span class="codeline" id="line-1713"><code>			case token.IDENT:</code></span>
<span class="codeline" id="line-1714"><code>				x = p.parseSelector(x)</code></span>
<span class="codeline" id="line-1715"><code>			case token.LPAREN:</code></span>
<span class="codeline" id="line-1716"><code>				x = p.parseTypeAssertion(x)</code></span>
<span class="codeline" id="line-1717"><code>			default:</code></span>
<span class="codeline" id="line-1718"><code>				pos := p.pos</code></span>
<span class="codeline" id="line-1719"><code>				p.errorExpected(pos, "selector or type assertion")</code></span>
<span class="codeline" id="line-1720"><code>				// TODO(rFindley) The check for token.RBRACE below is a targeted fix</code></span>
<span class="codeline" id="line-1721"><code>				//                to error recovery sufficient to make the x/tools tests to</code></span>
<span class="codeline" id="line-1722"><code>				//                pass with the new parsing logic introduced for type</code></span>
<span class="codeline" id="line-1723"><code>				//                parameters. Remove this once error recovery has been</code></span>
<span class="codeline" id="line-1724"><code>				//                more generally reconsidered.</code></span>
<span class="codeline" id="line-1725"><code>				if p.tok != token.RBRACE {</code></span>
<span class="codeline" id="line-1726"><code>					p.next() // make progress</code></span>
<span class="codeline" id="line-1727"><code>				}</code></span>
<span class="codeline" id="line-1728"><code>				sel := &amp;ast.Ident{NamePos: pos, Name: "_"}</code></span>
<span class="codeline" id="line-1729"><code>				x = &amp;ast.SelectorExpr{X: x, Sel: sel}</code></span>
<span class="codeline" id="line-1730"><code>			}</code></span>
<span class="codeline" id="line-1731"><code>		case token.LBRACK:</code></span>
<span class="codeline" id="line-1732"><code>			x = p.parseIndexOrSliceOrInstance(x)</code></span>
<span class="codeline" id="line-1733"><code>		case token.LPAREN:</code></span>
<span class="codeline" id="line-1734"><code>			x = p.parseCallOrConversion(x)</code></span>
<span class="codeline" id="line-1735"><code>		case token.LBRACE:</code></span>
<span class="codeline" id="line-1736"><code>			// operand may have returned a parenthesized complit</code></span>
<span class="codeline" id="line-1737"><code>			// type; accept it but complain if we have a complit</code></span>
<span class="codeline" id="line-1738"><code>			t := ast.Unparen(x)</code></span>
<span class="codeline" id="line-1739"><code>			// determine if '{' belongs to a composite literal or a block statement</code></span>
<span class="codeline" id="line-1740"><code>			switch t.(type) {</code></span>
<span class="codeline" id="line-1741"><code>			case *ast.BadExpr, *ast.Ident, *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-1742"><code>				if p.exprLev &lt; 0 {</code></span>
<span class="codeline" id="line-1743"><code>					return x</code></span>
<span class="codeline" id="line-1744"><code>				}</code></span>
<span class="codeline" id="line-1745"><code>				// x is possibly a composite literal type</code></span>
<span class="codeline" id="line-1746"><code>			case *ast.IndexExpr, *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-1747"><code>				if p.exprLev &lt; 0 {</code></span>
<span class="codeline" id="line-1748"><code>					return x</code></span>
<span class="codeline" id="line-1749"><code>				}</code></span>
<span class="codeline" id="line-1750"><code>				// x is possibly a composite literal type</code></span>
<span class="codeline" id="line-1751"><code>			case *ast.ArrayType, *ast.StructType, *ast.MapType:</code></span>
<span class="codeline" id="line-1752"><code>				// x is a composite literal type</code></span>
<span class="codeline" id="line-1753"><code>			default:</code></span>
<span class="codeline" id="line-1754"><code>				return x</code></span>
<span class="codeline" id="line-1755"><code>			}</code></span>
<span class="codeline" id="line-1756"><code>			if t != x {</code></span>
<span class="codeline" id="line-1757"><code>				p.error(t.Pos(), "cannot parenthesize type in composite literal")</code></span>
<span class="codeline" id="line-1758"><code>				// already progressed, no need to advance</code></span>
<span class="codeline" id="line-1759"><code>			}</code></span>
<span class="codeline" id="line-1760"><code>			x = p.parseLiteralValue(x)</code></span>
<span class="codeline" id="line-1761"><code>		default:</code></span>
<span class="codeline" id="line-1762"><code>			return x</code></span>
<span class="codeline" id="line-1763"><code>		}</code></span>
<span class="codeline" id="line-1764"><code>	}</code></span>
<span class="codeline" id="line-1765"><code>}</code></span>
<span class="codeline" id="line-1766"><code></code></span>
<span class="codeline" id="line-1767"><code>func (p *parser) parseUnaryExpr() ast.Expr {</code></span>
<span class="codeline" id="line-1768"><code>	defer decNestLev(incNestLev(p))</code></span>
<span class="codeline" id="line-1769"><code></code></span>
<span class="codeline" id="line-1770"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1771"><code>		defer un(trace(p, "UnaryExpr"))</code></span>
<span class="codeline" id="line-1772"><code>	}</code></span>
<span class="codeline" id="line-1773"><code></code></span>
<span class="codeline" id="line-1774"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1775"><code>	case token.ADD, token.SUB, token.NOT, token.XOR, token.AND, token.TILDE:</code></span>
<span class="codeline" id="line-1776"><code>		pos, op := p.pos, p.tok</code></span>
<span class="codeline" id="line-1777"><code>		p.next()</code></span>
<span class="codeline" id="line-1778"><code>		x := p.parseUnaryExpr()</code></span>
<span class="codeline" id="line-1779"><code>		return &amp;ast.UnaryExpr{OpPos: pos, Op: op, X: x}</code></span>
<span class="codeline" id="line-1780"><code></code></span>
<span class="codeline" id="line-1781"><code>	case token.ARROW:</code></span>
<span class="codeline" id="line-1782"><code>		// channel type or receive expression</code></span>
<span class="codeline" id="line-1783"><code>		arrow := p.pos</code></span>
<span class="codeline" id="line-1784"><code>		p.next()</code></span>
<span class="codeline" id="line-1785"><code></code></span>
<span class="codeline" id="line-1786"><code>		// If the next token is token.CHAN we still don't know if it</code></span>
<span class="codeline" id="line-1787"><code>		// is a channel type or a receive operation - we only know</code></span>
<span class="codeline" id="line-1788"><code>		// once we have found the end of the unary expression. There</code></span>
<span class="codeline" id="line-1789"><code>		// are two cases:</code></span>
<span class="codeline" id="line-1790"><code>		//</code></span>
<span class="codeline" id="line-1791"><code>		//   &lt;- type  =&gt; (&lt;-type) must be channel type</code></span>
<span class="codeline" id="line-1792"><code>		//   &lt;- expr  =&gt; &lt;-(expr) is a receive from an expression</code></span>
<span class="codeline" id="line-1793"><code>		//</code></span>
<span class="codeline" id="line-1794"><code>		// In the first case, the arrow must be re-associated with</code></span>
<span class="codeline" id="line-1795"><code>		// the channel type parsed already:</code></span>
<span class="codeline" id="line-1796"><code>		//</code></span>
<span class="codeline" id="line-1797"><code>		//   &lt;- (chan type)    =&gt;  (&lt;-chan type)</code></span>
<span class="codeline" id="line-1798"><code>		//   &lt;- (chan&lt;- type)  =&gt;  (&lt;-chan (&lt;-type))</code></span>
<span class="codeline" id="line-1799"><code></code></span>
<span class="codeline" id="line-1800"><code>		x := p.parseUnaryExpr()</code></span>
<span class="codeline" id="line-1801"><code></code></span>
<span class="codeline" id="line-1802"><code>		// determine which case we have</code></span>
<span class="codeline" id="line-1803"><code>		if typ, ok := x.(*ast.ChanType); ok {</code></span>
<span class="codeline" id="line-1804"><code>			// (&lt;-type)</code></span>
<span class="codeline" id="line-1805"><code></code></span>
<span class="codeline" id="line-1806"><code>			// re-associate position info and &lt;-</code></span>
<span class="codeline" id="line-1807"><code>			dir := ast.SEND</code></span>
<span class="codeline" id="line-1808"><code>			for ok &amp;&amp; dir == ast.SEND {</code></span>
<span class="codeline" id="line-1809"><code>				if typ.Dir == ast.RECV {</code></span>
<span class="codeline" id="line-1810"><code>					// error: (&lt;-type) is (&lt;-(&lt;-chan T))</code></span>
<span class="codeline" id="line-1811"><code>					p.errorExpected(typ.Arrow, "'chan'")</code></span>
<span class="codeline" id="line-1812"><code>				}</code></span>
<span class="codeline" id="line-1813"><code>				arrow, typ.Begin, typ.Arrow = typ.Arrow, arrow, arrow</code></span>
<span class="codeline" id="line-1814"><code>				dir, typ.Dir = typ.Dir, ast.RECV</code></span>
<span class="codeline" id="line-1815"><code>				typ, ok = typ.Value.(*ast.ChanType)</code></span>
<span class="codeline" id="line-1816"><code>			}</code></span>
<span class="codeline" id="line-1817"><code>			if dir == ast.SEND {</code></span>
<span class="codeline" id="line-1818"><code>				p.errorExpected(arrow, "channel type")</code></span>
<span class="codeline" id="line-1819"><code>			}</code></span>
<span class="codeline" id="line-1820"><code></code></span>
<span class="codeline" id="line-1821"><code>			return x</code></span>
<span class="codeline" id="line-1822"><code>		}</code></span>
<span class="codeline" id="line-1823"><code></code></span>
<span class="codeline" id="line-1824"><code>		// &lt;-(expr)</code></span>
<span class="codeline" id="line-1825"><code>		return &amp;ast.UnaryExpr{OpPos: arrow, Op: token.ARROW, X: x}</code></span>
<span class="codeline" id="line-1826"><code></code></span>
<span class="codeline" id="line-1827"><code>	case token.MUL:</code></span>
<span class="codeline" id="line-1828"><code>		// pointer type or unary "*" expression</code></span>
<span class="codeline" id="line-1829"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-1830"><code>		p.next()</code></span>
<span class="codeline" id="line-1831"><code>		x := p.parseUnaryExpr()</code></span>
<span class="codeline" id="line-1832"><code>		return &amp;ast.StarExpr{Star: pos, X: x}</code></span>
<span class="codeline" id="line-1833"><code>	}</code></span>
<span class="codeline" id="line-1834"><code></code></span>
<span class="codeline" id="line-1835"><code>	return p.parsePrimaryExpr(nil)</code></span>
<span class="codeline" id="line-1836"><code>}</code></span>
<span class="codeline" id="line-1837"><code></code></span>
<span class="codeline" id="line-1838"><code>func (p *parser) tokPrec() (token.Token, int) {</code></span>
<span class="codeline" id="line-1839"><code>	tok := p.tok</code></span>
<span class="codeline" id="line-1840"><code>	if p.inRhs &amp;&amp; tok == token.ASSIGN {</code></span>
<span class="codeline" id="line-1841"><code>		tok = token.EQL</code></span>
<span class="codeline" id="line-1842"><code>	}</code></span>
<span class="codeline" id="line-1843"><code>	return tok, tok.Precedence()</code></span>
<span class="codeline" id="line-1844"><code>}</code></span>
<span class="codeline" id="line-1845"><code></code></span>
<span class="codeline" id="line-1846"><code>// parseBinaryExpr parses a (possibly) binary expression.</code></span>
<span class="codeline" id="line-1847"><code>// If x is non-nil, it is used as the left operand.</code></span>
<span class="codeline" id="line-1848"><code>//</code></span>
<span class="codeline" id="line-1849"><code>// TODO(rfindley): parseBinaryExpr has become overloaded. Consider refactoring.</code></span>
<span class="codeline" id="line-1850"><code>func (p *parser) parseBinaryExpr(x ast.Expr, prec1 int) ast.Expr {</code></span>
<span class="codeline" id="line-1851"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1852"><code>		defer un(trace(p, "BinaryExpr"))</code></span>
<span class="codeline" id="line-1853"><code>	}</code></span>
<span class="codeline" id="line-1854"><code></code></span>
<span class="codeline" id="line-1855"><code>	if x == nil {</code></span>
<span class="codeline" id="line-1856"><code>		x = p.parseUnaryExpr()</code></span>
<span class="codeline" id="line-1857"><code>	}</code></span>
<span class="codeline" id="line-1858"><code>	// We track the nesting here rather than at the entry for the function,</code></span>
<span class="codeline" id="line-1859"><code>	// since it can iteratively produce a nested output, and we want to</code></span>
<span class="codeline" id="line-1860"><code>	// limit how deep a structure we generate.</code></span>
<span class="codeline" id="line-1861"><code>	var n int</code></span>
<span class="codeline" id="line-1862"><code>	defer func() { p.nestLev -= n }()</code></span>
<span class="codeline" id="line-1863"><code>	for n = 1; ; n++ {</code></span>
<span class="codeline" id="line-1864"><code>		incNestLev(p)</code></span>
<span class="codeline" id="line-1865"><code>		op, oprec := p.tokPrec()</code></span>
<span class="codeline" id="line-1866"><code>		if oprec &lt; prec1 {</code></span>
<span class="codeline" id="line-1867"><code>			return x</code></span>
<span class="codeline" id="line-1868"><code>		}</code></span>
<span class="codeline" id="line-1869"><code>		pos := p.expect(op)</code></span>
<span class="codeline" id="line-1870"><code>		y := p.parseBinaryExpr(nil, oprec+1)</code></span>
<span class="codeline" id="line-1871"><code>		x = &amp;ast.BinaryExpr{X: x, OpPos: pos, Op: op, Y: y}</code></span>
<span class="codeline" id="line-1872"><code>	}</code></span>
<span class="codeline" id="line-1873"><code>}</code></span>
<span class="codeline" id="line-1874"><code></code></span>
<span class="codeline" id="line-1875"><code>// The result may be a type or even a raw type ([...]int).</code></span>
<span class="codeline" id="line-1876"><code>func (p *parser) parseExpr() ast.Expr {</code></span>
<span class="codeline" id="line-1877"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1878"><code>		defer un(trace(p, "Expression"))</code></span>
<span class="codeline" id="line-1879"><code>	}</code></span>
<span class="codeline" id="line-1880"><code></code></span>
<span class="codeline" id="line-1881"><code>	return p.parseBinaryExpr(nil, token.LowestPrec+1)</code></span>
<span class="codeline" id="line-1882"><code>}</code></span>
<span class="codeline" id="line-1883"><code></code></span>
<span class="codeline" id="line-1884"><code>func (p *parser) parseRhs() ast.Expr {</code></span>
<span class="codeline" id="line-1885"><code>	old := p.inRhs</code></span>
<span class="codeline" id="line-1886"><code>	p.inRhs = true</code></span>
<span class="codeline" id="line-1887"><code>	x := p.parseExpr()</code></span>
<span class="codeline" id="line-1888"><code>	p.inRhs = old</code></span>
<span class="codeline" id="line-1889"><code>	return x</code></span>
<span class="codeline" id="line-1890"><code>}</code></span>
<span class="codeline" id="line-1891"><code></code></span>
<span class="codeline" id="line-1892"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-1893"><code>// Statements</code></span>
<span class="codeline" id="line-1894"><code></code></span>
<span class="codeline" id="line-1895"><code>// Parsing modes for parseSimpleStmt.</code></span>
<span class="codeline" id="line-1896"><code>const (</code></span>
<span class="codeline" id="line-1897"><code>	basic = iota</code></span>
<span class="codeline" id="line-1898"><code>	labelOk</code></span>
<span class="codeline" id="line-1899"><code>	rangeOk</code></span>
<span class="codeline" id="line-1900"><code>)</code></span>
<span class="codeline" id="line-1901"><code></code></span>
<span class="codeline" id="line-1902"><code>// parseSimpleStmt returns true as 2nd result if it parsed the assignment</code></span>
<span class="codeline" id="line-1903"><code>// of a range clause (with mode == rangeOk). The returned statement is an</code></span>
<span class="codeline" id="line-1904"><code>// assignment with a right-hand side that is a single unary expression of</code></span>
<span class="codeline" id="line-1905"><code>// the form "range x". No guarantees are given for the left-hand side.</code></span>
<span class="codeline" id="line-1906"><code>func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {</code></span>
<span class="codeline" id="line-1907"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1908"><code>		defer un(trace(p, "SimpleStmt"))</code></span>
<span class="codeline" id="line-1909"><code>	}</code></span>
<span class="codeline" id="line-1910"><code></code></span>
<span class="codeline" id="line-1911"><code>	x := p.parseList(false)</code></span>
<span class="codeline" id="line-1912"><code></code></span>
<span class="codeline" id="line-1913"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1914"><code>	case</code></span>
<span class="codeline" id="line-1915"><code>		token.DEFINE, token.ASSIGN, token.ADD_ASSIGN,</code></span>
<span class="codeline" id="line-1916"><code>		token.SUB_ASSIGN, token.MUL_ASSIGN, token.QUO_ASSIGN,</code></span>
<span class="codeline" id="line-1917"><code>		token.REM_ASSIGN, token.AND_ASSIGN, token.OR_ASSIGN,</code></span>
<span class="codeline" id="line-1918"><code>		token.XOR_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.AND_NOT_ASSIGN:</code></span>
<span class="codeline" id="line-1919"><code>		// assignment statement, possibly part of a range clause</code></span>
<span class="codeline" id="line-1920"><code>		pos, tok := p.pos, p.tok</code></span>
<span class="codeline" id="line-1921"><code>		p.next()</code></span>
<span class="codeline" id="line-1922"><code>		var y []ast.Expr</code></span>
<span class="codeline" id="line-1923"><code>		isRange := false</code></span>
<span class="codeline" id="line-1924"><code>		if mode == rangeOk &amp;&amp; p.tok == token.RANGE &amp;&amp; (tok == token.DEFINE || tok == token.ASSIGN) {</code></span>
<span class="codeline" id="line-1925"><code>			pos := p.pos</code></span>
<span class="codeline" id="line-1926"><code>			p.next()</code></span>
<span class="codeline" id="line-1927"><code>			y = []ast.Expr{&amp;ast.UnaryExpr{OpPos: pos, Op: token.RANGE, X: p.parseRhs()}}</code></span>
<span class="codeline" id="line-1928"><code>			isRange = true</code></span>
<span class="codeline" id="line-1929"><code>		} else {</code></span>
<span class="codeline" id="line-1930"><code>			y = p.parseList(true)</code></span>
<span class="codeline" id="line-1931"><code>		}</code></span>
<span class="codeline" id="line-1932"><code>		return &amp;ast.AssignStmt{Lhs: x, TokPos: pos, Tok: tok, Rhs: y}, isRange</code></span>
<span class="codeline" id="line-1933"><code>	}</code></span>
<span class="codeline" id="line-1934"><code></code></span>
<span class="codeline" id="line-1935"><code>	if len(x) &gt; 1 {</code></span>
<span class="codeline" id="line-1936"><code>		p.errorExpected(x[0].Pos(), "1 expression")</code></span>
<span class="codeline" id="line-1937"><code>		// continue with first expression</code></span>
<span class="codeline" id="line-1938"><code>	}</code></span>
<span class="codeline" id="line-1939"><code></code></span>
<span class="codeline" id="line-1940"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-1941"><code>	case token.COLON:</code></span>
<span class="codeline" id="line-1942"><code>		// labeled statement</code></span>
<span class="codeline" id="line-1943"><code>		colon := p.pos</code></span>
<span class="codeline" id="line-1944"><code>		p.next()</code></span>
<span class="codeline" id="line-1945"><code>		if label, isIdent := x[0].(*ast.Ident); mode == labelOk &amp;&amp; isIdent {</code></span>
<span class="codeline" id="line-1946"><code>			// Go spec: The scope of a label is the body of the function</code></span>
<span class="codeline" id="line-1947"><code>			// in which it is declared and excludes the body of any nested</code></span>
<span class="codeline" id="line-1948"><code>			// function.</code></span>
<span class="codeline" id="line-1949"><code>			stmt := &amp;ast.LabeledStmt{Label: label, Colon: colon, Stmt: p.parseStmt()}</code></span>
<span class="codeline" id="line-1950"><code>			return stmt, false</code></span>
<span class="codeline" id="line-1951"><code>		}</code></span>
<span class="codeline" id="line-1952"><code>		// The label declaration typically starts at x[0].Pos(), but the label</code></span>
<span class="codeline" id="line-1953"><code>		// declaration may be erroneous due to a token after that position (and</code></span>
<span class="codeline" id="line-1954"><code>		// before the ':'). If SpuriousErrors is not set, the (only) error</code></span>
<span class="codeline" id="line-1955"><code>		// reported for the line is the illegal label error instead of the token</code></span>
<span class="codeline" id="line-1956"><code>		// before the ':' that caused the problem. Thus, use the (latest) colon</code></span>
<span class="codeline" id="line-1957"><code>		// position for error reporting.</code></span>
<span class="codeline" id="line-1958"><code>		p.error(colon, "illegal label declaration")</code></span>
<span class="codeline" id="line-1959"><code>		return &amp;ast.BadStmt{From: x[0].Pos(), To: colon + 1}, false</code></span>
<span class="codeline" id="line-1960"><code></code></span>
<span class="codeline" id="line-1961"><code>	case token.ARROW:</code></span>
<span class="codeline" id="line-1962"><code>		// send statement</code></span>
<span class="codeline" id="line-1963"><code>		arrow := p.pos</code></span>
<span class="codeline" id="line-1964"><code>		p.next()</code></span>
<span class="codeline" id="line-1965"><code>		y := p.parseRhs()</code></span>
<span class="codeline" id="line-1966"><code>		return &amp;ast.SendStmt{Chan: x[0], Arrow: arrow, Value: y}, false</code></span>
<span class="codeline" id="line-1967"><code></code></span>
<span class="codeline" id="line-1968"><code>	case token.INC, token.DEC:</code></span>
<span class="codeline" id="line-1969"><code>		// increment or decrement</code></span>
<span class="codeline" id="line-1970"><code>		s := &amp;ast.IncDecStmt{X: x[0], TokPos: p.pos, Tok: p.tok}</code></span>
<span class="codeline" id="line-1971"><code>		p.next()</code></span>
<span class="codeline" id="line-1972"><code>		return s, false</code></span>
<span class="codeline" id="line-1973"><code>	}</code></span>
<span class="codeline" id="line-1974"><code></code></span>
<span class="codeline" id="line-1975"><code>	// expression</code></span>
<span class="codeline" id="line-1976"><code>	return &amp;ast.ExprStmt{X: x[0]}, false</code></span>
<span class="codeline" id="line-1977"><code>}</code></span>
<span class="codeline" id="line-1978"><code></code></span>
<span class="codeline" id="line-1979"><code>func (p *parser) parseCallExpr(callType string) *ast.CallExpr {</code></span>
<span class="codeline" id="line-1980"><code>	x := p.parseRhs() // could be a conversion: (some type)(x)</code></span>
<span class="codeline" id="line-1981"><code>	if t := ast.Unparen(x); t != x {</code></span>
<span class="codeline" id="line-1982"><code>		p.error(x.Pos(), fmt.Sprintf("expression in %s must not be parenthesized", callType))</code></span>
<span class="codeline" id="line-1983"><code>		x = t</code></span>
<span class="codeline" id="line-1984"><code>	}</code></span>
<span class="codeline" id="line-1985"><code>	if call, isCall := x.(*ast.CallExpr); isCall {</code></span>
<span class="codeline" id="line-1986"><code>		return call</code></span>
<span class="codeline" id="line-1987"><code>	}</code></span>
<span class="codeline" id="line-1988"><code>	if _, isBad := x.(*ast.BadExpr); !isBad {</code></span>
<span class="codeline" id="line-1989"><code>		// only report error if it's a new one</code></span>
<span class="codeline" id="line-1990"><code>		p.error(p.safePos(x.End()), fmt.Sprintf("expression in %s must be function call", callType))</code></span>
<span class="codeline" id="line-1991"><code>	}</code></span>
<span class="codeline" id="line-1992"><code>	return nil</code></span>
<span class="codeline" id="line-1993"><code>}</code></span>
<span class="codeline" id="line-1994"><code></code></span>
<span class="codeline" id="line-1995"><code>func (p *parser) parseGoStmt() ast.Stmt {</code></span>
<span class="codeline" id="line-1996"><code>	if p.trace {</code></span>
<span class="codeline" id="line-1997"><code>		defer un(trace(p, "GoStmt"))</code></span>
<span class="codeline" id="line-1998"><code>	}</code></span>
<span class="codeline" id="line-1999"><code></code></span>
<span class="codeline" id="line-2000"><code>	pos := p.expect(token.GO)</code></span>
<span class="codeline" id="line-2001"><code>	call := p.parseCallExpr("go")</code></span>
<span class="codeline" id="line-2002"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2003"><code>	if call == nil {</code></span>
<span class="codeline" id="line-2004"><code>		return &amp;ast.BadStmt{From: pos, To: pos + 2} // len("go")</code></span>
<span class="codeline" id="line-2005"><code>	}</code></span>
<span class="codeline" id="line-2006"><code></code></span>
<span class="codeline" id="line-2007"><code>	return &amp;ast.GoStmt{Go: pos, Call: call}</code></span>
<span class="codeline" id="line-2008"><code>}</code></span>
<span class="codeline" id="line-2009"><code></code></span>
<span class="codeline" id="line-2010"><code>func (p *parser) parseDeferStmt() ast.Stmt {</code></span>
<span class="codeline" id="line-2011"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2012"><code>		defer un(trace(p, "DeferStmt"))</code></span>
<span class="codeline" id="line-2013"><code>	}</code></span>
<span class="codeline" id="line-2014"><code></code></span>
<span class="codeline" id="line-2015"><code>	pos := p.expect(token.DEFER)</code></span>
<span class="codeline" id="line-2016"><code>	call := p.parseCallExpr("defer")</code></span>
<span class="codeline" id="line-2017"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2018"><code>	if call == nil {</code></span>
<span class="codeline" id="line-2019"><code>		return &amp;ast.BadStmt{From: pos, To: pos + 5} // len("defer")</code></span>
<span class="codeline" id="line-2020"><code>	}</code></span>
<span class="codeline" id="line-2021"><code></code></span>
<span class="codeline" id="line-2022"><code>	return &amp;ast.DeferStmt{Defer: pos, Call: call}</code></span>
<span class="codeline" id="line-2023"><code>}</code></span>
<span class="codeline" id="line-2024"><code></code></span>
<span class="codeline" id="line-2025"><code>func (p *parser) parseReturnStmt() *ast.ReturnStmt {</code></span>
<span class="codeline" id="line-2026"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2027"><code>		defer un(trace(p, "ReturnStmt"))</code></span>
<span class="codeline" id="line-2028"><code>	}</code></span>
<span class="codeline" id="line-2029"><code></code></span>
<span class="codeline" id="line-2030"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-2031"><code>	p.expect(token.RETURN)</code></span>
<span class="codeline" id="line-2032"><code>	var x []ast.Expr</code></span>
<span class="codeline" id="line-2033"><code>	if p.tok != token.SEMICOLON &amp;&amp; p.tok != token.RBRACE {</code></span>
<span class="codeline" id="line-2034"><code>		x = p.parseList(true)</code></span>
<span class="codeline" id="line-2035"><code>	}</code></span>
<span class="codeline" id="line-2036"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2037"><code></code></span>
<span class="codeline" id="line-2038"><code>	return &amp;ast.ReturnStmt{Return: pos, Results: x}</code></span>
<span class="codeline" id="line-2039"><code>}</code></span>
<span class="codeline" id="line-2040"><code></code></span>
<span class="codeline" id="line-2041"><code>func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {</code></span>
<span class="codeline" id="line-2042"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2043"><code>		defer un(trace(p, "BranchStmt"))</code></span>
<span class="codeline" id="line-2044"><code>	}</code></span>
<span class="codeline" id="line-2045"><code></code></span>
<span class="codeline" id="line-2046"><code>	pos := p.expect(tok)</code></span>
<span class="codeline" id="line-2047"><code>	var label *ast.Ident</code></span>
<span class="codeline" id="line-2048"><code>	if tok != token.FALLTHROUGH &amp;&amp; p.tok == token.IDENT {</code></span>
<span class="codeline" id="line-2049"><code>		label = p.parseIdent()</code></span>
<span class="codeline" id="line-2050"><code>	}</code></span>
<span class="codeline" id="line-2051"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2052"><code></code></span>
<span class="codeline" id="line-2053"><code>	return &amp;ast.BranchStmt{TokPos: pos, Tok: tok, Label: label}</code></span>
<span class="codeline" id="line-2054"><code>}</code></span>
<span class="codeline" id="line-2055"><code></code></span>
<span class="codeline" id="line-2056"><code>func (p *parser) makeExpr(s ast.Stmt, want string) ast.Expr {</code></span>
<span class="codeline" id="line-2057"><code>	if s == nil {</code></span>
<span class="codeline" id="line-2058"><code>		return nil</code></span>
<span class="codeline" id="line-2059"><code>	}</code></span>
<span class="codeline" id="line-2060"><code>	if es, isExpr := s.(*ast.ExprStmt); isExpr {</code></span>
<span class="codeline" id="line-2061"><code>		return es.X</code></span>
<span class="codeline" id="line-2062"><code>	}</code></span>
<span class="codeline" id="line-2063"><code>	found := "simple statement"</code></span>
<span class="codeline" id="line-2064"><code>	if _, isAss := s.(*ast.AssignStmt); isAss {</code></span>
<span class="codeline" id="line-2065"><code>		found = "assignment"</code></span>
<span class="codeline" id="line-2066"><code>	}</code></span>
<span class="codeline" id="line-2067"><code>	p.error(s.Pos(), fmt.Sprintf("expected %s, found %s (missing parentheses around composite literal?)", want, found))</code></span>
<span class="codeline" id="line-2068"><code>	return &amp;ast.BadExpr{From: s.Pos(), To: p.safePos(s.End())}</code></span>
<span class="codeline" id="line-2069"><code>}</code></span>
<span class="codeline" id="line-2070"><code></code></span>
<span class="codeline" id="line-2071"><code>// parseIfHeader is an adjusted version of parser.header</code></span>
<span class="codeline" id="line-2072"><code>// in cmd/compile/internal/syntax/parser.go, which has</code></span>
<span class="codeline" id="line-2073"><code>// been tuned for better error handling.</code></span>
<span class="codeline" id="line-2074"><code>func (p *parser) parseIfHeader() (init ast.Stmt, cond ast.Expr) {</code></span>
<span class="codeline" id="line-2075"><code>	if p.tok == token.LBRACE {</code></span>
<span class="codeline" id="line-2076"><code>		p.error(p.pos, "missing condition in if statement")</code></span>
<span class="codeline" id="line-2077"><code>		cond = &amp;ast.BadExpr{From: p.pos, To: p.pos}</code></span>
<span class="codeline" id="line-2078"><code>		return</code></span>
<span class="codeline" id="line-2079"><code>	}</code></span>
<span class="codeline" id="line-2080"><code>	// p.tok != token.LBRACE</code></span>
<span class="codeline" id="line-2081"><code></code></span>
<span class="codeline" id="line-2082"><code>	prevLev := p.exprLev</code></span>
<span class="codeline" id="line-2083"><code>	p.exprLev = -1</code></span>
<span class="codeline" id="line-2084"><code></code></span>
<span class="codeline" id="line-2085"><code>	if p.tok != token.SEMICOLON {</code></span>
<span class="codeline" id="line-2086"><code>		// accept potential variable declaration but complain</code></span>
<span class="codeline" id="line-2087"><code>		if p.tok == token.VAR {</code></span>
<span class="codeline" id="line-2088"><code>			p.next()</code></span>
<span class="codeline" id="line-2089"><code>			p.error(p.pos, "var declaration not allowed in if initializer")</code></span>
<span class="codeline" id="line-2090"><code>		}</code></span>
<span class="codeline" id="line-2091"><code>		init, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2092"><code>	}</code></span>
<span class="codeline" id="line-2093"><code></code></span>
<span class="codeline" id="line-2094"><code>	var condStmt ast.Stmt</code></span>
<span class="codeline" id="line-2095"><code>	var semi struct {</code></span>
<span class="codeline" id="line-2096"><code>		pos token.Pos</code></span>
<span class="codeline" id="line-2097"><code>		lit string // ";" or "\n"; valid if pos.IsValid()</code></span>
<span class="codeline" id="line-2098"><code>	}</code></span>
<span class="codeline" id="line-2099"><code>	if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2100"><code>		if p.tok == token.SEMICOLON {</code></span>
<span class="codeline" id="line-2101"><code>			semi.pos = p.pos</code></span>
<span class="codeline" id="line-2102"><code>			semi.lit = p.lit</code></span>
<span class="codeline" id="line-2103"><code>			p.next()</code></span>
<span class="codeline" id="line-2104"><code>		} else {</code></span>
<span class="codeline" id="line-2105"><code>			p.expect(token.SEMICOLON)</code></span>
<span class="codeline" id="line-2106"><code>		}</code></span>
<span class="codeline" id="line-2107"><code>		if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2108"><code>			condStmt, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2109"><code>		}</code></span>
<span class="codeline" id="line-2110"><code>	} else {</code></span>
<span class="codeline" id="line-2111"><code>		condStmt = init</code></span>
<span class="codeline" id="line-2112"><code>		init = nil</code></span>
<span class="codeline" id="line-2113"><code>	}</code></span>
<span class="codeline" id="line-2114"><code></code></span>
<span class="codeline" id="line-2115"><code>	if condStmt != nil {</code></span>
<span class="codeline" id="line-2116"><code>		cond = p.makeExpr(condStmt, "boolean expression")</code></span>
<span class="codeline" id="line-2117"><code>	} else if semi.pos.IsValid() {</code></span>
<span class="codeline" id="line-2118"><code>		if semi.lit == "\n" {</code></span>
<span class="codeline" id="line-2119"><code>			p.error(semi.pos, "unexpected newline, expecting { after if clause")</code></span>
<span class="codeline" id="line-2120"><code>		} else {</code></span>
<span class="codeline" id="line-2121"><code>			p.error(semi.pos, "missing condition in if statement")</code></span>
<span class="codeline" id="line-2122"><code>		}</code></span>
<span class="codeline" id="line-2123"><code>	}</code></span>
<span class="codeline" id="line-2124"><code></code></span>
<span class="codeline" id="line-2125"><code>	// make sure we have a valid AST</code></span>
<span class="codeline" id="line-2126"><code>	if cond == nil {</code></span>
<span class="codeline" id="line-2127"><code>		cond = &amp;ast.BadExpr{From: p.pos, To: p.pos}</code></span>
<span class="codeline" id="line-2128"><code>	}</code></span>
<span class="codeline" id="line-2129"><code></code></span>
<span class="codeline" id="line-2130"><code>	p.exprLev = prevLev</code></span>
<span class="codeline" id="line-2131"><code>	return</code></span>
<span class="codeline" id="line-2132"><code>}</code></span>
<span class="codeline" id="line-2133"><code></code></span>
<span class="codeline" id="line-2134"><code>func (p *parser) parseIfStmt() *ast.IfStmt {</code></span>
<span class="codeline" id="line-2135"><code>	defer decNestLev(incNestLev(p))</code></span>
<span class="codeline" id="line-2136"><code></code></span>
<span class="codeline" id="line-2137"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2138"><code>		defer un(trace(p, "IfStmt"))</code></span>
<span class="codeline" id="line-2139"><code>	}</code></span>
<span class="codeline" id="line-2140"><code></code></span>
<span class="codeline" id="line-2141"><code>	pos := p.expect(token.IF)</code></span>
<span class="codeline" id="line-2142"><code></code></span>
<span class="codeline" id="line-2143"><code>	init, cond := p.parseIfHeader()</code></span>
<span class="codeline" id="line-2144"><code>	body := p.parseBlockStmt()</code></span>
<span class="codeline" id="line-2145"><code></code></span>
<span class="codeline" id="line-2146"><code>	var else_ ast.Stmt</code></span>
<span class="codeline" id="line-2147"><code>	if p.tok == token.ELSE {</code></span>
<span class="codeline" id="line-2148"><code>		p.next()</code></span>
<span class="codeline" id="line-2149"><code>		switch p.tok {</code></span>
<span class="codeline" id="line-2150"><code>		case token.IF:</code></span>
<span class="codeline" id="line-2151"><code>			else_ = p.parseIfStmt()</code></span>
<span class="codeline" id="line-2152"><code>		case token.LBRACE:</code></span>
<span class="codeline" id="line-2153"><code>			else_ = p.parseBlockStmt()</code></span>
<span class="codeline" id="line-2154"><code>			p.expectSemi()</code></span>
<span class="codeline" id="line-2155"><code>		default:</code></span>
<span class="codeline" id="line-2156"><code>			p.errorExpected(p.pos, "if statement or block")</code></span>
<span class="codeline" id="line-2157"><code>			else_ = &amp;ast.BadStmt{From: p.pos, To: p.pos}</code></span>
<span class="codeline" id="line-2158"><code>		}</code></span>
<span class="codeline" id="line-2159"><code>	} else {</code></span>
<span class="codeline" id="line-2160"><code>		p.expectSemi()</code></span>
<span class="codeline" id="line-2161"><code>	}</code></span>
<span class="codeline" id="line-2162"><code></code></span>
<span class="codeline" id="line-2163"><code>	return &amp;ast.IfStmt{If: pos, Init: init, Cond: cond, Body: body, Else: else_}</code></span>
<span class="codeline" id="line-2164"><code>}</code></span>
<span class="codeline" id="line-2165"><code></code></span>
<span class="codeline" id="line-2166"><code>func (p *parser) parseCaseClause() *ast.CaseClause {</code></span>
<span class="codeline" id="line-2167"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2168"><code>		defer un(trace(p, "CaseClause"))</code></span>
<span class="codeline" id="line-2169"><code>	}</code></span>
<span class="codeline" id="line-2170"><code></code></span>
<span class="codeline" id="line-2171"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-2172"><code>	var list []ast.Expr</code></span>
<span class="codeline" id="line-2173"><code>	if p.tok == token.CASE {</code></span>
<span class="codeline" id="line-2174"><code>		p.next()</code></span>
<span class="codeline" id="line-2175"><code>		list = p.parseList(true)</code></span>
<span class="codeline" id="line-2176"><code>	} else {</code></span>
<span class="codeline" id="line-2177"><code>		p.expect(token.DEFAULT)</code></span>
<span class="codeline" id="line-2178"><code>	}</code></span>
<span class="codeline" id="line-2179"><code></code></span>
<span class="codeline" id="line-2180"><code>	colon := p.expect(token.COLON)</code></span>
<span class="codeline" id="line-2181"><code>	body := p.parseStmtList()</code></span>
<span class="codeline" id="line-2182"><code></code></span>
<span class="codeline" id="line-2183"><code>	return &amp;ast.CaseClause{Case: pos, List: list, Colon: colon, Body: body}</code></span>
<span class="codeline" id="line-2184"><code>}</code></span>
<span class="codeline" id="line-2185"><code></code></span>
<span class="codeline" id="line-2186"><code>func isTypeSwitchAssert(x ast.Expr) bool {</code></span>
<span class="codeline" id="line-2187"><code>	a, ok := x.(*ast.TypeAssertExpr)</code></span>
<span class="codeline" id="line-2188"><code>	return ok &amp;&amp; a.Type == nil</code></span>
<span class="codeline" id="line-2189"><code>}</code></span>
<span class="codeline" id="line-2190"><code></code></span>
<span class="codeline" id="line-2191"><code>func (p *parser) isTypeSwitchGuard(s ast.Stmt) bool {</code></span>
<span class="codeline" id="line-2192"><code>	switch t := s.(type) {</code></span>
<span class="codeline" id="line-2193"><code>	case *ast.ExprStmt:</code></span>
<span class="codeline" id="line-2194"><code>		// x.(type)</code></span>
<span class="codeline" id="line-2195"><code>		return isTypeSwitchAssert(t.X)</code></span>
<span class="codeline" id="line-2196"><code>	case *ast.AssignStmt:</code></span>
<span class="codeline" id="line-2197"><code>		// v := x.(type)</code></span>
<span class="codeline" id="line-2198"><code>		if len(t.Lhs) == 1 &amp;&amp; len(t.Rhs) == 1 &amp;&amp; isTypeSwitchAssert(t.Rhs[0]) {</code></span>
<span class="codeline" id="line-2199"><code>			switch t.Tok {</code></span>
<span class="codeline" id="line-2200"><code>			case token.ASSIGN:</code></span>
<span class="codeline" id="line-2201"><code>				// permit v = x.(type) but complain</code></span>
<span class="codeline" id="line-2202"><code>				p.error(t.TokPos, "expected ':=', found '='")</code></span>
<span class="codeline" id="line-2203"><code>				fallthrough</code></span>
<span class="codeline" id="line-2204"><code>			case token.DEFINE:</code></span>
<span class="codeline" id="line-2205"><code>				return true</code></span>
<span class="codeline" id="line-2206"><code>			}</code></span>
<span class="codeline" id="line-2207"><code>		}</code></span>
<span class="codeline" id="line-2208"><code>	}</code></span>
<span class="codeline" id="line-2209"><code>	return false</code></span>
<span class="codeline" id="line-2210"><code>}</code></span>
<span class="codeline" id="line-2211"><code></code></span>
<span class="codeline" id="line-2212"><code>func (p *parser) parseSwitchStmt() ast.Stmt {</code></span>
<span class="codeline" id="line-2213"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2214"><code>		defer un(trace(p, "SwitchStmt"))</code></span>
<span class="codeline" id="line-2215"><code>	}</code></span>
<span class="codeline" id="line-2216"><code></code></span>
<span class="codeline" id="line-2217"><code>	pos := p.expect(token.SWITCH)</code></span>
<span class="codeline" id="line-2218"><code></code></span>
<span class="codeline" id="line-2219"><code>	var s1, s2 ast.Stmt</code></span>
<span class="codeline" id="line-2220"><code>	if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2221"><code>		prevLev := p.exprLev</code></span>
<span class="codeline" id="line-2222"><code>		p.exprLev = -1</code></span>
<span class="codeline" id="line-2223"><code>		if p.tok != token.SEMICOLON {</code></span>
<span class="codeline" id="line-2224"><code>			s2, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2225"><code>		}</code></span>
<span class="codeline" id="line-2226"><code>		if p.tok == token.SEMICOLON {</code></span>
<span class="codeline" id="line-2227"><code>			p.next()</code></span>
<span class="codeline" id="line-2228"><code>			s1 = s2</code></span>
<span class="codeline" id="line-2229"><code>			s2 = nil</code></span>
<span class="codeline" id="line-2230"><code>			if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2231"><code>				// A TypeSwitchGuard may declare a variable in addition</code></span>
<span class="codeline" id="line-2232"><code>				// to the variable declared in the initial SimpleStmt.</code></span>
<span class="codeline" id="line-2233"><code>				// Introduce extra scope to avoid redeclaration errors:</code></span>
<span class="codeline" id="line-2234"><code>				//</code></span>
<span class="codeline" id="line-2235"><code>				//	switch t := 0; t := x.(T) { ... }</code></span>
<span class="codeline" id="line-2236"><code>				//</code></span>
<span class="codeline" id="line-2237"><code>				// (this code is not valid Go because the first t</code></span>
<span class="codeline" id="line-2238"><code>				// cannot be accessed and thus is never used, the extra</code></span>
<span class="codeline" id="line-2239"><code>				// scope is needed for the correct error message).</code></span>
<span class="codeline" id="line-2240"><code>				//</code></span>
<span class="codeline" id="line-2241"><code>				// If we don't have a type switch, s2 must be an expression.</code></span>
<span class="codeline" id="line-2242"><code>				// Having the extra nested but empty scope won't affect it.</code></span>
<span class="codeline" id="line-2243"><code>				s2, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2244"><code>			}</code></span>
<span class="codeline" id="line-2245"><code>		}</code></span>
<span class="codeline" id="line-2246"><code>		p.exprLev = prevLev</code></span>
<span class="codeline" id="line-2247"><code>	}</code></span>
<span class="codeline" id="line-2248"><code></code></span>
<span class="codeline" id="line-2249"><code>	typeSwitch := p.isTypeSwitchGuard(s2)</code></span>
<span class="codeline" id="line-2250"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-2251"><code>	var list []ast.Stmt</code></span>
<span class="codeline" id="line-2252"><code>	for p.tok == token.CASE || p.tok == token.DEFAULT {</code></span>
<span class="codeline" id="line-2253"><code>		list = append(list, p.parseCaseClause())</code></span>
<span class="codeline" id="line-2254"><code>	}</code></span>
<span class="codeline" id="line-2255"><code>	rbrace := p.expect(token.RBRACE)</code></span>
<span class="codeline" id="line-2256"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2257"><code>	body := &amp;ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}</code></span>
<span class="codeline" id="line-2258"><code></code></span>
<span class="codeline" id="line-2259"><code>	if typeSwitch {</code></span>
<span class="codeline" id="line-2260"><code>		return &amp;ast.TypeSwitchStmt{Switch: pos, Init: s1, Assign: s2, Body: body}</code></span>
<span class="codeline" id="line-2261"><code>	}</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>	return &amp;ast.SwitchStmt{Switch: pos, Init: s1, Tag: p.makeExpr(s2, "switch expression"), Body: body}</code></span>
<span class="codeline" id="line-2264"><code>}</code></span>
<span class="codeline" id="line-2265"><code></code></span>
<span class="codeline" id="line-2266"><code>func (p *parser) parseCommClause() *ast.CommClause {</code></span>
<span class="codeline" id="line-2267"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2268"><code>		defer un(trace(p, "CommClause"))</code></span>
<span class="codeline" id="line-2269"><code>	}</code></span>
<span class="codeline" id="line-2270"><code></code></span>
<span class="codeline" id="line-2271"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-2272"><code>	var comm ast.Stmt</code></span>
<span class="codeline" id="line-2273"><code>	if p.tok == token.CASE {</code></span>
<span class="codeline" id="line-2274"><code>		p.next()</code></span>
<span class="codeline" id="line-2275"><code>		lhs := p.parseList(false)</code></span>
<span class="codeline" id="line-2276"><code>		if p.tok == token.ARROW {</code></span>
<span class="codeline" id="line-2277"><code>			// SendStmt</code></span>
<span class="codeline" id="line-2278"><code>			if len(lhs) &gt; 1 {</code></span>
<span class="codeline" id="line-2279"><code>				p.errorExpected(lhs[0].Pos(), "1 expression")</code></span>
<span class="codeline" id="line-2280"><code>				// continue with first expression</code></span>
<span class="codeline" id="line-2281"><code>			}</code></span>
<span class="codeline" id="line-2282"><code>			arrow := p.pos</code></span>
<span class="codeline" id="line-2283"><code>			p.next()</code></span>
<span class="codeline" id="line-2284"><code>			rhs := p.parseRhs()</code></span>
<span class="codeline" id="line-2285"><code>			comm = &amp;ast.SendStmt{Chan: lhs[0], Arrow: arrow, Value: rhs}</code></span>
<span class="codeline" id="line-2286"><code>		} else {</code></span>
<span class="codeline" id="line-2287"><code>			// RecvStmt</code></span>
<span class="codeline" id="line-2288"><code>			if tok := p.tok; tok == token.ASSIGN || tok == token.DEFINE {</code></span>
<span class="codeline" id="line-2289"><code>				// RecvStmt with assignment</code></span>
<span class="codeline" id="line-2290"><code>				if len(lhs) &gt; 2 {</code></span>
<span class="codeline" id="line-2291"><code>					p.errorExpected(lhs[0].Pos(), "1 or 2 expressions")</code></span>
<span class="codeline" id="line-2292"><code>					// continue with first two expressions</code></span>
<span class="codeline" id="line-2293"><code>					lhs = lhs[0:2]</code></span>
<span class="codeline" id="line-2294"><code>				}</code></span>
<span class="codeline" id="line-2295"><code>				pos := p.pos</code></span>
<span class="codeline" id="line-2296"><code>				p.next()</code></span>
<span class="codeline" id="line-2297"><code>				rhs := p.parseRhs()</code></span>
<span class="codeline" id="line-2298"><code>				comm = &amp;ast.AssignStmt{Lhs: lhs, TokPos: pos, Tok: tok, Rhs: []ast.Expr{rhs}}</code></span>
<span class="codeline" id="line-2299"><code>			} else {</code></span>
<span class="codeline" id="line-2300"><code>				// lhs must be single receive operation</code></span>
<span class="codeline" id="line-2301"><code>				if len(lhs) &gt; 1 {</code></span>
<span class="codeline" id="line-2302"><code>					p.errorExpected(lhs[0].Pos(), "1 expression")</code></span>
<span class="codeline" id="line-2303"><code>					// continue with first expression</code></span>
<span class="codeline" id="line-2304"><code>				}</code></span>
<span class="codeline" id="line-2305"><code>				comm = &amp;ast.ExprStmt{X: lhs[0]}</code></span>
<span class="codeline" id="line-2306"><code>			}</code></span>
<span class="codeline" id="line-2307"><code>		}</code></span>
<span class="codeline" id="line-2308"><code>	} else {</code></span>
<span class="codeline" id="line-2309"><code>		p.expect(token.DEFAULT)</code></span>
<span class="codeline" id="line-2310"><code>	}</code></span>
<span class="codeline" id="line-2311"><code></code></span>
<span class="codeline" id="line-2312"><code>	colon := p.expect(token.COLON)</code></span>
<span class="codeline" id="line-2313"><code>	body := p.parseStmtList()</code></span>
<span class="codeline" id="line-2314"><code></code></span>
<span class="codeline" id="line-2315"><code>	return &amp;ast.CommClause{Case: pos, Comm: comm, Colon: colon, Body: body}</code></span>
<span class="codeline" id="line-2316"><code>}</code></span>
<span class="codeline" id="line-2317"><code></code></span>
<span class="codeline" id="line-2318"><code>func (p *parser) parseSelectStmt() *ast.SelectStmt {</code></span>
<span class="codeline" id="line-2319"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2320"><code>		defer un(trace(p, "SelectStmt"))</code></span>
<span class="codeline" id="line-2321"><code>	}</code></span>
<span class="codeline" id="line-2322"><code></code></span>
<span class="codeline" id="line-2323"><code>	pos := p.expect(token.SELECT)</code></span>
<span class="codeline" id="line-2324"><code>	lbrace := p.expect(token.LBRACE)</code></span>
<span class="codeline" id="line-2325"><code>	var list []ast.Stmt</code></span>
<span class="codeline" id="line-2326"><code>	for p.tok == token.CASE || p.tok == token.DEFAULT {</code></span>
<span class="codeline" id="line-2327"><code>		list = append(list, p.parseCommClause())</code></span>
<span class="codeline" id="line-2328"><code>	}</code></span>
<span class="codeline" id="line-2329"><code>	rbrace := p.expect(token.RBRACE)</code></span>
<span class="codeline" id="line-2330"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2331"><code>	body := &amp;ast.BlockStmt{Lbrace: lbrace, List: list, Rbrace: rbrace}</code></span>
<span class="codeline" id="line-2332"><code></code></span>
<span class="codeline" id="line-2333"><code>	return &amp;ast.SelectStmt{Select: pos, Body: body}</code></span>
<span class="codeline" id="line-2334"><code>}</code></span>
<span class="codeline" id="line-2335"><code></code></span>
<span class="codeline" id="line-2336"><code>func (p *parser) parseForStmt() ast.Stmt {</code></span>
<span class="codeline" id="line-2337"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2338"><code>		defer un(trace(p, "ForStmt"))</code></span>
<span class="codeline" id="line-2339"><code>	}</code></span>
<span class="codeline" id="line-2340"><code></code></span>
<span class="codeline" id="line-2341"><code>	pos := p.expect(token.FOR)</code></span>
<span class="codeline" id="line-2342"><code></code></span>
<span class="codeline" id="line-2343"><code>	var s1, s2, s3 ast.Stmt</code></span>
<span class="codeline" id="line-2344"><code>	var isRange bool</code></span>
<span class="codeline" id="line-2345"><code>	if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2346"><code>		prevLev := p.exprLev</code></span>
<span class="codeline" id="line-2347"><code>		p.exprLev = -1</code></span>
<span class="codeline" id="line-2348"><code>		if p.tok != token.SEMICOLON {</code></span>
<span class="codeline" id="line-2349"><code>			if p.tok == token.RANGE {</code></span>
<span class="codeline" id="line-2350"><code>				// "for range x" (nil lhs in assignment)</code></span>
<span class="codeline" id="line-2351"><code>				pos := p.pos</code></span>
<span class="codeline" id="line-2352"><code>				p.next()</code></span>
<span class="codeline" id="line-2353"><code>				y := []ast.Expr{&amp;ast.UnaryExpr{OpPos: pos, Op: token.RANGE, X: p.parseRhs()}}</code></span>
<span class="codeline" id="line-2354"><code>				s2 = &amp;ast.AssignStmt{Rhs: y}</code></span>
<span class="codeline" id="line-2355"><code>				isRange = true</code></span>
<span class="codeline" id="line-2356"><code>			} else {</code></span>
<span class="codeline" id="line-2357"><code>				s2, isRange = p.parseSimpleStmt(rangeOk)</code></span>
<span class="codeline" id="line-2358"><code>			}</code></span>
<span class="codeline" id="line-2359"><code>		}</code></span>
<span class="codeline" id="line-2360"><code>		if !isRange &amp;&amp; p.tok == token.SEMICOLON {</code></span>
<span class="codeline" id="line-2361"><code>			p.next()</code></span>
<span class="codeline" id="line-2362"><code>			s1 = s2</code></span>
<span class="codeline" id="line-2363"><code>			s2 = nil</code></span>
<span class="codeline" id="line-2364"><code>			if p.tok != token.SEMICOLON {</code></span>
<span class="codeline" id="line-2365"><code>				s2, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2366"><code>			}</code></span>
<span class="codeline" id="line-2367"><code>			p.expectSemi()</code></span>
<span class="codeline" id="line-2368"><code>			if p.tok != token.LBRACE {</code></span>
<span class="codeline" id="line-2369"><code>				s3, _ = p.parseSimpleStmt(basic)</code></span>
<span class="codeline" id="line-2370"><code>			}</code></span>
<span class="codeline" id="line-2371"><code>		}</code></span>
<span class="codeline" id="line-2372"><code>		p.exprLev = prevLev</code></span>
<span class="codeline" id="line-2373"><code>	}</code></span>
<span class="codeline" id="line-2374"><code></code></span>
<span class="codeline" id="line-2375"><code>	body := p.parseBlockStmt()</code></span>
<span class="codeline" id="line-2376"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2377"><code></code></span>
<span class="codeline" id="line-2378"><code>	if isRange {</code></span>
<span class="codeline" id="line-2379"><code>		as := s2.(*ast.AssignStmt)</code></span>
<span class="codeline" id="line-2380"><code>		// check lhs</code></span>
<span class="codeline" id="line-2381"><code>		var key, value ast.Expr</code></span>
<span class="codeline" id="line-2382"><code>		switch len(as.Lhs) {</code></span>
<span class="codeline" id="line-2383"><code>		case 0:</code></span>
<span class="codeline" id="line-2384"><code>			// nothing to do</code></span>
<span class="codeline" id="line-2385"><code>		case 1:</code></span>
<span class="codeline" id="line-2386"><code>			key = as.Lhs[0]</code></span>
<span class="codeline" id="line-2387"><code>		case 2:</code></span>
<span class="codeline" id="line-2388"><code>			key, value = as.Lhs[0], as.Lhs[1]</code></span>
<span class="codeline" id="line-2389"><code>		default:</code></span>
<span class="codeline" id="line-2390"><code>			p.errorExpected(as.Lhs[len(as.Lhs)-1].Pos(), "at most 2 expressions")</code></span>
<span class="codeline" id="line-2391"><code>			return &amp;ast.BadStmt{From: pos, To: p.safePos(body.End())}</code></span>
<span class="codeline" id="line-2392"><code>		}</code></span>
<span class="codeline" id="line-2393"><code>		// parseSimpleStmt returned a right-hand side that</code></span>
<span class="codeline" id="line-2394"><code>		// is a single unary expression of the form "range x"</code></span>
<span class="codeline" id="line-2395"><code>		x := as.Rhs[0].(*ast.UnaryExpr).X</code></span>
<span class="codeline" id="line-2396"><code>		return &amp;ast.RangeStmt{</code></span>
<span class="codeline" id="line-2397"><code>			For:    pos,</code></span>
<span class="codeline" id="line-2398"><code>			Key:    key,</code></span>
<span class="codeline" id="line-2399"><code>			Value:  value,</code></span>
<span class="codeline" id="line-2400"><code>			TokPos: as.TokPos,</code></span>
<span class="codeline" id="line-2401"><code>			Tok:    as.Tok,</code></span>
<span class="codeline" id="line-2402"><code>			Range:  as.Rhs[0].Pos(),</code></span>
<span class="codeline" id="line-2403"><code>			X:      x,</code></span>
<span class="codeline" id="line-2404"><code>			Body:   body,</code></span>
<span class="codeline" id="line-2405"><code>		}</code></span>
<span class="codeline" id="line-2406"><code>	}</code></span>
<span class="codeline" id="line-2407"><code></code></span>
<span class="codeline" id="line-2408"><code>	// regular for statement</code></span>
<span class="codeline" id="line-2409"><code>	return &amp;ast.ForStmt{</code></span>
<span class="codeline" id="line-2410"><code>		For:  pos,</code></span>
<span class="codeline" id="line-2411"><code>		Init: s1,</code></span>
<span class="codeline" id="line-2412"><code>		Cond: p.makeExpr(s2, "boolean or range expression"),</code></span>
<span class="codeline" id="line-2413"><code>		Post: s3,</code></span>
<span class="codeline" id="line-2414"><code>		Body: body,</code></span>
<span class="codeline" id="line-2415"><code>	}</code></span>
<span class="codeline" id="line-2416"><code>}</code></span>
<span class="codeline" id="line-2417"><code></code></span>
<span class="codeline" id="line-2418"><code>func (p *parser) parseStmt() (s ast.Stmt) {</code></span>
<span class="codeline" id="line-2419"><code>	defer decNestLev(incNestLev(p))</code></span>
<span class="codeline" id="line-2420"><code></code></span>
<span class="codeline" id="line-2421"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2422"><code>		defer un(trace(p, "Statement"))</code></span>
<span class="codeline" id="line-2423"><code>	}</code></span>
<span class="codeline" id="line-2424"><code></code></span>
<span class="codeline" id="line-2425"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-2426"><code>	case token.CONST, token.TYPE, token.VAR:</code></span>
<span class="codeline" id="line-2427"><code>		s = &amp;ast.DeclStmt{Decl: p.parseDecl(stmtStart)}</code></span>
<span class="codeline" id="line-2428"><code>	case</code></span>
<span class="codeline" id="line-2429"><code>		// tokens that may start an expression</code></span>
<span class="codeline" id="line-2430"><code>		token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands</code></span>
<span class="codeline" id="line-2431"><code>		token.LBRACK, token.STRUCT, token.MAP, token.CHAN, token.INTERFACE, // composite types</code></span>
<span class="codeline" id="line-2432"><code>		token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators</code></span>
<span class="codeline" id="line-2433"><code>		s, _ = p.parseSimpleStmt(labelOk)</code></span>
<span class="codeline" id="line-2434"><code>		// because of the required look-ahead, labeled statements are</code></span>
<span class="codeline" id="line-2435"><code>		// parsed by parseSimpleStmt - don't expect a semicolon after</code></span>
<span class="codeline" id="line-2436"><code>		// them</code></span>
<span class="codeline" id="line-2437"><code>		if _, isLabeledStmt := s.(*ast.LabeledStmt); !isLabeledStmt {</code></span>
<span class="codeline" id="line-2438"><code>			p.expectSemi()</code></span>
<span class="codeline" id="line-2439"><code>		}</code></span>
<span class="codeline" id="line-2440"><code>	case token.GO:</code></span>
<span class="codeline" id="line-2441"><code>		s = p.parseGoStmt()</code></span>
<span class="codeline" id="line-2442"><code>	case token.DEFER:</code></span>
<span class="codeline" id="line-2443"><code>		s = p.parseDeferStmt()</code></span>
<span class="codeline" id="line-2444"><code>	case token.RETURN:</code></span>
<span class="codeline" id="line-2445"><code>		s = p.parseReturnStmt()</code></span>
<span class="codeline" id="line-2446"><code>	case token.BREAK, token.CONTINUE, token.GOTO, token.FALLTHROUGH:</code></span>
<span class="codeline" id="line-2447"><code>		s = p.parseBranchStmt(p.tok)</code></span>
<span class="codeline" id="line-2448"><code>	case token.LBRACE:</code></span>
<span class="codeline" id="line-2449"><code>		s = p.parseBlockStmt()</code></span>
<span class="codeline" id="line-2450"><code>		p.expectSemi()</code></span>
<span class="codeline" id="line-2451"><code>	case token.IF:</code></span>
<span class="codeline" id="line-2452"><code>		s = p.parseIfStmt()</code></span>
<span class="codeline" id="line-2453"><code>	case token.SWITCH:</code></span>
<span class="codeline" id="line-2454"><code>		s = p.parseSwitchStmt()</code></span>
<span class="codeline" id="line-2455"><code>	case token.SELECT:</code></span>
<span class="codeline" id="line-2456"><code>		s = p.parseSelectStmt()</code></span>
<span class="codeline" id="line-2457"><code>	case token.FOR:</code></span>
<span class="codeline" id="line-2458"><code>		s = p.parseForStmt()</code></span>
<span class="codeline" id="line-2459"><code>	case token.SEMICOLON:</code></span>
<span class="codeline" id="line-2460"><code>		// Is it ever possible to have an implicit semicolon</code></span>
<span class="codeline" id="line-2461"><code>		// producing an empty statement in a valid program?</code></span>
<span class="codeline" id="line-2462"><code>		// (handle correctly anyway)</code></span>
<span class="codeline" id="line-2463"><code>		s = &amp;ast.EmptyStmt{Semicolon: p.pos, Implicit: p.lit == "\n"}</code></span>
<span class="codeline" id="line-2464"><code>		p.next()</code></span>
<span class="codeline" id="line-2465"><code>	case token.RBRACE:</code></span>
<span class="codeline" id="line-2466"><code>		// a semicolon may be omitted before a closing "}"</code></span>
<span class="codeline" id="line-2467"><code>		s = &amp;ast.EmptyStmt{Semicolon: p.pos, Implicit: true}</code></span>
<span class="codeline" id="line-2468"><code>	default:</code></span>
<span class="codeline" id="line-2469"><code>		// no statement found</code></span>
<span class="codeline" id="line-2470"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-2471"><code>		p.errorExpected(pos, "statement")</code></span>
<span class="codeline" id="line-2472"><code>		p.advance(stmtStart)</code></span>
<span class="codeline" id="line-2473"><code>		s = &amp;ast.BadStmt{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-2474"><code>	}</code></span>
<span class="codeline" id="line-2475"><code></code></span>
<span class="codeline" id="line-2476"><code>	return</code></span>
<span class="codeline" id="line-2477"><code>}</code></span>
<span class="codeline" id="line-2478"><code></code></span>
<span class="codeline" id="line-2479"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-2480"><code>// Declarations</code></span>
<span class="codeline" id="line-2481"><code></code></span>
<span class="codeline" id="line-2482"><code>type parseSpecFunction func(doc *ast.CommentGroup, keyword token.Token, iota int) ast.Spec</code></span>
<span class="codeline" id="line-2483"><code></code></span>
<span class="codeline" id="line-2484"><code>func (p *parser) parseImportSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {</code></span>
<span class="codeline" id="line-2485"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2486"><code>		defer un(trace(p, "ImportSpec"))</code></span>
<span class="codeline" id="line-2487"><code>	}</code></span>
<span class="codeline" id="line-2488"><code></code></span>
<span class="codeline" id="line-2489"><code>	var ident *ast.Ident</code></span>
<span class="codeline" id="line-2490"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-2491"><code>	case token.IDENT:</code></span>
<span class="codeline" id="line-2492"><code>		ident = p.parseIdent()</code></span>
<span class="codeline" id="line-2493"><code>	case token.PERIOD:</code></span>
<span class="codeline" id="line-2494"><code>		ident = &amp;ast.Ident{NamePos: p.pos, Name: "."}</code></span>
<span class="codeline" id="line-2495"><code>		p.next()</code></span>
<span class="codeline" id="line-2496"><code>	}</code></span>
<span class="codeline" id="line-2497"><code></code></span>
<span class="codeline" id="line-2498"><code>	pos := p.pos</code></span>
<span class="codeline" id="line-2499"><code>	var path string</code></span>
<span class="codeline" id="line-2500"><code>	if p.tok == token.STRING {</code></span>
<span class="codeline" id="line-2501"><code>		path = p.lit</code></span>
<span class="codeline" id="line-2502"><code>		p.next()</code></span>
<span class="codeline" id="line-2503"><code>	} else if p.tok.IsLiteral() {</code></span>
<span class="codeline" id="line-2504"><code>		p.error(pos, "import path must be a string")</code></span>
<span class="codeline" id="line-2505"><code>		p.next()</code></span>
<span class="codeline" id="line-2506"><code>	} else {</code></span>
<span class="codeline" id="line-2507"><code>		p.error(pos, "missing import path")</code></span>
<span class="codeline" id="line-2508"><code>		p.advance(exprEnd)</code></span>
<span class="codeline" id="line-2509"><code>	}</code></span>
<span class="codeline" id="line-2510"><code>	comment := p.expectSemi()</code></span>
<span class="codeline" id="line-2511"><code></code></span>
<span class="codeline" id="line-2512"><code>	// collect imports</code></span>
<span class="codeline" id="line-2513"><code>	spec := &amp;ast.ImportSpec{</code></span>
<span class="codeline" id="line-2514"><code>		Doc:     doc,</code></span>
<span class="codeline" id="line-2515"><code>		Name:    ident,</code></span>
<span class="codeline" id="line-2516"><code>		Path:    &amp;ast.BasicLit{ValuePos: pos, Kind: token.STRING, Value: path},</code></span>
<span class="codeline" id="line-2517"><code>		Comment: comment,</code></span>
<span class="codeline" id="line-2518"><code>	}</code></span>
<span class="codeline" id="line-2519"><code>	p.imports = append(p.imports, spec)</code></span>
<span class="codeline" id="line-2520"><code></code></span>
<span class="codeline" id="line-2521"><code>	return spec</code></span>
<span class="codeline" id="line-2522"><code>}</code></span>
<span class="codeline" id="line-2523"><code></code></span>
<span class="codeline" id="line-2524"><code>func (p *parser) parseValueSpec(doc *ast.CommentGroup, keyword token.Token, iota int) ast.Spec {</code></span>
<span class="codeline" id="line-2525"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2526"><code>		defer un(trace(p, keyword.String()+"Spec"))</code></span>
<span class="codeline" id="line-2527"><code>	}</code></span>
<span class="codeline" id="line-2528"><code></code></span>
<span class="codeline" id="line-2529"><code>	idents := p.parseIdentList()</code></span>
<span class="codeline" id="line-2530"><code>	var typ ast.Expr</code></span>
<span class="codeline" id="line-2531"><code>	var values []ast.Expr</code></span>
<span class="codeline" id="line-2532"><code>	switch keyword {</code></span>
<span class="codeline" id="line-2533"><code>	case token.CONST:</code></span>
<span class="codeline" id="line-2534"><code>		// always permit optional type and initialization for more tolerant parsing</code></span>
<span class="codeline" id="line-2535"><code>		if p.tok != token.EOF &amp;&amp; p.tok != token.SEMICOLON &amp;&amp; p.tok != token.RPAREN {</code></span>
<span class="codeline" id="line-2536"><code>			typ = p.tryIdentOrType()</code></span>
<span class="codeline" id="line-2537"><code>			if p.tok == token.ASSIGN {</code></span>
<span class="codeline" id="line-2538"><code>				p.next()</code></span>
<span class="codeline" id="line-2539"><code>				values = p.parseList(true)</code></span>
<span class="codeline" id="line-2540"><code>			}</code></span>
<span class="codeline" id="line-2541"><code>		}</code></span>
<span class="codeline" id="line-2542"><code>	case token.VAR:</code></span>
<span class="codeline" id="line-2543"><code>		if p.tok != token.ASSIGN {</code></span>
<span class="codeline" id="line-2544"><code>			typ = p.parseType()</code></span>
<span class="codeline" id="line-2545"><code>		}</code></span>
<span class="codeline" id="line-2546"><code>		if p.tok == token.ASSIGN {</code></span>
<span class="codeline" id="line-2547"><code>			p.next()</code></span>
<span class="codeline" id="line-2548"><code>			values = p.parseList(true)</code></span>
<span class="codeline" id="line-2549"><code>		}</code></span>
<span class="codeline" id="line-2550"><code>	default:</code></span>
<span class="codeline" id="line-2551"><code>		panic("unreachable")</code></span>
<span class="codeline" id="line-2552"><code>	}</code></span>
<span class="codeline" id="line-2553"><code>	comment := p.expectSemi()</code></span>
<span class="codeline" id="line-2554"><code></code></span>
<span class="codeline" id="line-2555"><code>	spec := &amp;ast.ValueSpec{</code></span>
<span class="codeline" id="line-2556"><code>		Doc:     doc,</code></span>
<span class="codeline" id="line-2557"><code>		Names:   idents,</code></span>
<span class="codeline" id="line-2558"><code>		Type:    typ,</code></span>
<span class="codeline" id="line-2559"><code>		Values:  values,</code></span>
<span class="codeline" id="line-2560"><code>		Comment: comment,</code></span>
<span class="codeline" id="line-2561"><code>	}</code></span>
<span class="codeline" id="line-2562"><code>	return spec</code></span>
<span class="codeline" id="line-2563"><code>}</code></span>
<span class="codeline" id="line-2564"><code></code></span>
<span class="codeline" id="line-2565"><code>func (p *parser) parseGenericType(spec *ast.TypeSpec, openPos token.Pos, name0 *ast.Ident, typ0 ast.Expr) {</code></span>
<span class="codeline" id="line-2566"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2567"><code>		defer un(trace(p, "parseGenericType"))</code></span>
<span class="codeline" id="line-2568"><code>	}</code></span>
<span class="codeline" id="line-2569"><code></code></span>
<span class="codeline" id="line-2570"><code>	list := p.parseParameterList(name0, typ0, token.RBRACK)</code></span>
<span class="codeline" id="line-2571"><code>	closePos := p.expect(token.RBRACK)</code></span>
<span class="codeline" id="line-2572"><code>	spec.TypeParams = &amp;ast.FieldList{Opening: openPos, List: list, Closing: closePos}</code></span>
<span class="codeline" id="line-2573"><code>	// Let the type checker decide whether to accept type parameters on aliases:</code></span>
<span class="codeline" id="line-2574"><code>	// see go.dev/issue/46477.</code></span>
<span class="codeline" id="line-2575"><code>	if p.tok == token.ASSIGN {</code></span>
<span class="codeline" id="line-2576"><code>		// type alias</code></span>
<span class="codeline" id="line-2577"><code>		spec.Assign = p.pos</code></span>
<span class="codeline" id="line-2578"><code>		p.next()</code></span>
<span class="codeline" id="line-2579"><code>	}</code></span>
<span class="codeline" id="line-2580"><code>	spec.Type = p.parseType()</code></span>
<span class="codeline" id="line-2581"><code>}</code></span>
<span class="codeline" id="line-2582"><code></code></span>
<span class="codeline" id="line-2583"><code>func (p *parser) parseTypeSpec(doc *ast.CommentGroup, _ token.Token, _ int) ast.Spec {</code></span>
<span class="codeline" id="line-2584"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2585"><code>		defer un(trace(p, "TypeSpec"))</code></span>
<span class="codeline" id="line-2586"><code>	}</code></span>
<span class="codeline" id="line-2587"><code></code></span>
<span class="codeline" id="line-2588"><code>	name := p.parseIdent()</code></span>
<span class="codeline" id="line-2589"><code>	spec := &amp;ast.TypeSpec{Doc: doc, Name: name}</code></span>
<span class="codeline" id="line-2590"><code></code></span>
<span class="codeline" id="line-2591"><code>	if p.tok == token.LBRACK {</code></span>
<span class="codeline" id="line-2592"><code>		// spec.Name "[" ...</code></span>
<span class="codeline" id="line-2593"><code>		// array/slice type or type parameter list</code></span>
<span class="codeline" id="line-2594"><code>		lbrack := p.pos</code></span>
<span class="codeline" id="line-2595"><code>		p.next()</code></span>
<span class="codeline" id="line-2596"><code>		if p.tok == token.IDENT {</code></span>
<span class="codeline" id="line-2597"><code>			// We may have an array type or a type parameter list.</code></span>
<span class="codeline" id="line-2598"><code>			// In either case we expect an expression x (which may</code></span>
<span class="codeline" id="line-2599"><code>			// just be a name, or a more complex expression) which</code></span>
<span class="codeline" id="line-2600"><code>			// we can analyze further.</code></span>
<span class="codeline" id="line-2601"><code>			//</code></span>
<span class="codeline" id="line-2602"><code>			// A type parameter list may have a type bound starting</code></span>
<span class="codeline" id="line-2603"><code>			// with a "[" as in: P []E. In that case, simply parsing</code></span>
<span class="codeline" id="line-2604"><code>			// an expression would lead to an error: P[] is invalid.</code></span>
<span class="codeline" id="line-2605"><code>			// But since index or slice expressions are never constant</code></span>
<span class="codeline" id="line-2606"><code>			// and thus invalid array length expressions, if the name</code></span>
<span class="codeline" id="line-2607"><code>			// is followed by "[" it must be the start of an array or</code></span>
<span class="codeline" id="line-2608"><code>			// slice constraint. Only if we don't see a "[" do we</code></span>
<span class="codeline" id="line-2609"><code>			// need to parse a full expression. Notably, name &lt;- x</code></span>
<span class="codeline" id="line-2610"><code>			// is not a concern because name &lt;- x is a statement and</code></span>
<span class="codeline" id="line-2611"><code>			// not an expression.</code></span>
<span class="codeline" id="line-2612"><code>			var x ast.Expr = p.parseIdent()</code></span>
<span class="codeline" id="line-2613"><code>			if p.tok != token.LBRACK {</code></span>
<span class="codeline" id="line-2614"><code>				// To parse the expression starting with name, expand</code></span>
<span class="codeline" id="line-2615"><code>				// the call sequence we would get by passing in name</code></span>
<span class="codeline" id="line-2616"><code>				// to parser.expr, and pass in name to parsePrimaryExpr.</code></span>
<span class="codeline" id="line-2617"><code>				p.exprLev++</code></span>
<span class="codeline" id="line-2618"><code>				lhs := p.parsePrimaryExpr(x)</code></span>
<span class="codeline" id="line-2619"><code>				x = p.parseBinaryExpr(lhs, token.LowestPrec+1)</code></span>
<span class="codeline" id="line-2620"><code>				p.exprLev--</code></span>
<span class="codeline" id="line-2621"><code>			}</code></span>
<span class="codeline" id="line-2622"><code>			// Analyze expression x. If we can split x into a type parameter</code></span>
<span class="codeline" id="line-2623"><code>			// name, possibly followed by a type parameter type, we consider</code></span>
<span class="codeline" id="line-2624"><code>			// this the start of a type parameter list, with some caveats:</code></span>
<span class="codeline" id="line-2625"><code>			// a single name followed by "]" tilts the decision towards an</code></span>
<span class="codeline" id="line-2626"><code>			// array declaration; a type parameter type that could also be</code></span>
<span class="codeline" id="line-2627"><code>			// an ordinary expression but which is followed by a comma tilts</code></span>
<span class="codeline" id="line-2628"><code>			// the decision towards a type parameter list.</code></span>
<span class="codeline" id="line-2629"><code>			if pname, ptype := extractName(x, p.tok == token.COMMA); pname != nil &amp;&amp; (ptype != nil || p.tok != token.RBRACK) {</code></span>
<span class="codeline" id="line-2630"><code>				// spec.Name "[" pname ...</code></span>
<span class="codeline" id="line-2631"><code>				// spec.Name "[" pname ptype ...</code></span>
<span class="codeline" id="line-2632"><code>				// spec.Name "[" pname ptype "," ...</code></span>
<span class="codeline" id="line-2633"><code>				p.parseGenericType(spec, lbrack, pname, ptype) // ptype may be nil</code></span>
<span class="codeline" id="line-2634"><code>			} else {</code></span>
<span class="codeline" id="line-2635"><code>				// spec.Name "[" pname "]" ...</code></span>
<span class="codeline" id="line-2636"><code>				// spec.Name "[" x ...</code></span>
<span class="codeline" id="line-2637"><code>				spec.Type = p.parseArrayType(lbrack, x)</code></span>
<span class="codeline" id="line-2638"><code>			}</code></span>
<span class="codeline" id="line-2639"><code>		} else {</code></span>
<span class="codeline" id="line-2640"><code>			// array type</code></span>
<span class="codeline" id="line-2641"><code>			spec.Type = p.parseArrayType(lbrack, nil)</code></span>
<span class="codeline" id="line-2642"><code>		}</code></span>
<span class="codeline" id="line-2643"><code>	} else {</code></span>
<span class="codeline" id="line-2644"><code>		// no type parameters</code></span>
<span class="codeline" id="line-2645"><code>		if p.tok == token.ASSIGN {</code></span>
<span class="codeline" id="line-2646"><code>			// type alias</code></span>
<span class="codeline" id="line-2647"><code>			spec.Assign = p.pos</code></span>
<span class="codeline" id="line-2648"><code>			p.next()</code></span>
<span class="codeline" id="line-2649"><code>		}</code></span>
<span class="codeline" id="line-2650"><code>		spec.Type = p.parseType()</code></span>
<span class="codeline" id="line-2651"><code>	}</code></span>
<span class="codeline" id="line-2652"><code></code></span>
<span class="codeline" id="line-2653"><code>	spec.Comment = p.expectSemi()</code></span>
<span class="codeline" id="line-2654"><code></code></span>
<span class="codeline" id="line-2655"><code>	return spec</code></span>
<span class="codeline" id="line-2656"><code>}</code></span>
<span class="codeline" id="line-2657"><code></code></span>
<span class="codeline" id="line-2658"><code>// extractName splits the expression x into (name, expr) if syntactically</code></span>
<span class="codeline" id="line-2659"><code>// x can be written as name expr. The split only happens if expr is a type</code></span>
<span class="codeline" id="line-2660"><code>// element (per the isTypeElem predicate) or if force is set.</code></span>
<span class="codeline" id="line-2661"><code>// If x is just a name, the result is (name, nil). If the split succeeds,</code></span>
<span class="codeline" id="line-2662"><code>// the result is (name, expr). Otherwise the result is (nil, x).</code></span>
<span class="codeline" id="line-2663"><code>// Examples:</code></span>
<span class="codeline" id="line-2664"><code>//</code></span>
<span class="codeline" id="line-2665"><code>//	x           force    name    expr</code></span>
<span class="codeline" id="line-2666"><code>//	------------------------------------</code></span>
<span class="codeline" id="line-2667"><code>//	P*[]int     T/F      P       *[]int</code></span>
<span class="codeline" id="line-2668"><code>//	P*E         T        P       *E</code></span>
<span class="codeline" id="line-2669"><code>//	P*E         F        nil     P*E</code></span>
<span class="codeline" id="line-2670"><code>//	P([]int)    T/F      P       []int</code></span>
<span class="codeline" id="line-2671"><code>//	P(E)        T        P       E</code></span>
<span class="codeline" id="line-2672"><code>//	P(E)        F        nil     P(E)</code></span>
<span class="codeline" id="line-2673"><code>//	P*E|F|~G    T/F      P       *E|F|~G</code></span>
<span class="codeline" id="line-2674"><code>//	P*E|F|G     T        P       *E|F|G</code></span>
<span class="codeline" id="line-2675"><code>//	P*E|F|G     F        nil     P*E|F|G</code></span>
<span class="codeline" id="line-2676"><code>func extractName(x ast.Expr, force bool) (*ast.Ident, ast.Expr) {</code></span>
<span class="codeline" id="line-2677"><code>	switch x := x.(type) {</code></span>
<span class="codeline" id="line-2678"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-2679"><code>		return x, nil</code></span>
<span class="codeline" id="line-2680"><code>	case *ast.BinaryExpr:</code></span>
<span class="codeline" id="line-2681"><code>		switch x.Op {</code></span>
<span class="codeline" id="line-2682"><code>		case token.MUL:</code></span>
<span class="codeline" id="line-2683"><code>			if name, _ := x.X.(*ast.Ident); name != nil &amp;&amp; (force || isTypeElem(x.Y)) {</code></span>
<span class="codeline" id="line-2684"><code>				// x = name *x.Y</code></span>
<span class="codeline" id="line-2685"><code>				return name, &amp;ast.StarExpr{Star: x.OpPos, X: x.Y}</code></span>
<span class="codeline" id="line-2686"><code>			}</code></span>
<span class="codeline" id="line-2687"><code>		case token.OR:</code></span>
<span class="codeline" id="line-2688"><code>			if name, lhs := extractName(x.X, force || isTypeElem(x.Y)); name != nil &amp;&amp; lhs != nil {</code></span>
<span class="codeline" id="line-2689"><code>				// x = name lhs|x.Y</code></span>
<span class="codeline" id="line-2690"><code>				op := *x</code></span>
<span class="codeline" id="line-2691"><code>				op.X = lhs</code></span>
<span class="codeline" id="line-2692"><code>				return name, &amp;op</code></span>
<span class="codeline" id="line-2693"><code>			}</code></span>
<span class="codeline" id="line-2694"><code>		}</code></span>
<span class="codeline" id="line-2695"><code>	case *ast.CallExpr:</code></span>
<span class="codeline" id="line-2696"><code>		if name, _ := x.Fun.(*ast.Ident); name != nil {</code></span>
<span class="codeline" id="line-2697"><code>			if len(x.Args) == 1 &amp;&amp; x.Ellipsis == token.NoPos &amp;&amp; (force || isTypeElem(x.Args[0])) {</code></span>
<span class="codeline" id="line-2698"><code>				// x = name "(" x.ArgList[0] ")"</code></span>
<span class="codeline" id="line-2699"><code>				return name, x.Args[0]</code></span>
<span class="codeline" id="line-2700"><code>			}</code></span>
<span class="codeline" id="line-2701"><code>		}</code></span>
<span class="codeline" id="line-2702"><code>	}</code></span>
<span class="codeline" id="line-2703"><code>	return nil, x</code></span>
<span class="codeline" id="line-2704"><code>}</code></span>
<span class="codeline" id="line-2705"><code></code></span>
<span class="codeline" id="line-2706"><code>// isTypeElem reports whether x is a (possibly parenthesized) type element expression.</code></span>
<span class="codeline" id="line-2707"><code>// The result is false if x could be a type element OR an ordinary (value) expression.</code></span>
<span class="codeline" id="line-2708"><code>func isTypeElem(x ast.Expr) bool {</code></span>
<span class="codeline" id="line-2709"><code>	switch x := x.(type) {</code></span>
<span class="codeline" id="line-2710"><code>	case *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType, *ast.MapType, *ast.ChanType:</code></span>
<span class="codeline" id="line-2711"><code>		return true</code></span>
<span class="codeline" id="line-2712"><code>	case *ast.BinaryExpr:</code></span>
<span class="codeline" id="line-2713"><code>		return isTypeElem(x.X) || isTypeElem(x.Y)</code></span>
<span class="codeline" id="line-2714"><code>	case *ast.UnaryExpr:</code></span>
<span class="codeline" id="line-2715"><code>		return x.Op == token.TILDE</code></span>
<span class="codeline" id="line-2716"><code>	case *ast.ParenExpr:</code></span>
<span class="codeline" id="line-2717"><code>		return isTypeElem(x.X)</code></span>
<span class="codeline" id="line-2718"><code>	}</code></span>
<span class="codeline" id="line-2719"><code>	return false</code></span>
<span class="codeline" id="line-2720"><code>}</code></span>
<span class="codeline" id="line-2721"><code></code></span>
<span class="codeline" id="line-2722"><code>func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl {</code></span>
<span class="codeline" id="line-2723"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2724"><code>		defer un(trace(p, "GenDecl("+keyword.String()+")"))</code></span>
<span class="codeline" id="line-2725"><code>	}</code></span>
<span class="codeline" id="line-2726"><code></code></span>
<span class="codeline" id="line-2727"><code>	doc := p.leadComment</code></span>
<span class="codeline" id="line-2728"><code>	pos := p.expect(keyword)</code></span>
<span class="codeline" id="line-2729"><code>	var lparen, rparen token.Pos</code></span>
<span class="codeline" id="line-2730"><code>	var list []ast.Spec</code></span>
<span class="codeline" id="line-2731"><code>	if p.tok == token.LPAREN {</code></span>
<span class="codeline" id="line-2732"><code>		lparen = p.pos</code></span>
<span class="codeline" id="line-2733"><code>		p.next()</code></span>
<span class="codeline" id="line-2734"><code>		for iota := 0; p.tok != token.RPAREN &amp;&amp; p.tok != token.EOF; iota++ {</code></span>
<span class="codeline" id="line-2735"><code>			list = append(list, f(p.leadComment, keyword, iota))</code></span>
<span class="codeline" id="line-2736"><code>		}</code></span>
<span class="codeline" id="line-2737"><code>		rparen = p.expect(token.RPAREN)</code></span>
<span class="codeline" id="line-2738"><code>		p.expectSemi()</code></span>
<span class="codeline" id="line-2739"><code>	} else {</code></span>
<span class="codeline" id="line-2740"><code>		list = append(list, f(nil, keyword, 0))</code></span>
<span class="codeline" id="line-2741"><code>	}</code></span>
<span class="codeline" id="line-2742"><code></code></span>
<span class="codeline" id="line-2743"><code>	return &amp;ast.GenDecl{</code></span>
<span class="codeline" id="line-2744"><code>		Doc:    doc,</code></span>
<span class="codeline" id="line-2745"><code>		TokPos: pos,</code></span>
<span class="codeline" id="line-2746"><code>		Tok:    keyword,</code></span>
<span class="codeline" id="line-2747"><code>		Lparen: lparen,</code></span>
<span class="codeline" id="line-2748"><code>		Specs:  list,</code></span>
<span class="codeline" id="line-2749"><code>		Rparen: rparen,</code></span>
<span class="codeline" id="line-2750"><code>	}</code></span>
<span class="codeline" id="line-2751"><code>}</code></span>
<span class="codeline" id="line-2752"><code></code></span>
<span class="codeline" id="line-2753"><code>func (p *parser) parseFuncDecl() *ast.FuncDecl {</code></span>
<span class="codeline" id="line-2754"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2755"><code>		defer un(trace(p, "FunctionDecl"))</code></span>
<span class="codeline" id="line-2756"><code>	}</code></span>
<span class="codeline" id="line-2757"><code></code></span>
<span class="codeline" id="line-2758"><code>	doc := p.leadComment</code></span>
<span class="codeline" id="line-2759"><code>	pos := p.expect(token.FUNC)</code></span>
<span class="codeline" id="line-2760"><code></code></span>
<span class="codeline" id="line-2761"><code>	var recv *ast.FieldList</code></span>
<span class="codeline" id="line-2762"><code>	if p.tok == token.LPAREN {</code></span>
<span class="codeline" id="line-2763"><code>		_, recv = p.parseParameters(false)</code></span>
<span class="codeline" id="line-2764"><code>	}</code></span>
<span class="codeline" id="line-2765"><code></code></span>
<span class="codeline" id="line-2766"><code>	ident := p.parseIdent()</code></span>
<span class="codeline" id="line-2767"><code></code></span>
<span class="codeline" id="line-2768"><code>	tparams, params := p.parseParameters(true)</code></span>
<span class="codeline" id="line-2769"><code>	if recv != nil &amp;&amp; tparams != nil {</code></span>
<span class="codeline" id="line-2770"><code>		// Method declarations do not have type parameters. We parse them for a</code></span>
<span class="codeline" id="line-2771"><code>		// better error message and improved error recovery.</code></span>
<span class="codeline" id="line-2772"><code>		p.error(tparams.Opening, "method must have no type parameters")</code></span>
<span class="codeline" id="line-2773"><code>		tparams = nil</code></span>
<span class="codeline" id="line-2774"><code>	}</code></span>
<span class="codeline" id="line-2775"><code>	results := p.parseResult()</code></span>
<span class="codeline" id="line-2776"><code></code></span>
<span class="codeline" id="line-2777"><code>	var body *ast.BlockStmt</code></span>
<span class="codeline" id="line-2778"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-2779"><code>	case token.LBRACE:</code></span>
<span class="codeline" id="line-2780"><code>		body = p.parseBody()</code></span>
<span class="codeline" id="line-2781"><code>		p.expectSemi()</code></span>
<span class="codeline" id="line-2782"><code>	case token.SEMICOLON:</code></span>
<span class="codeline" id="line-2783"><code>		p.next()</code></span>
<span class="codeline" id="line-2784"><code>		if p.tok == token.LBRACE {</code></span>
<span class="codeline" id="line-2785"><code>			// opening { of function declaration on next line</code></span>
<span class="codeline" id="line-2786"><code>			p.error(p.pos, "unexpected semicolon or newline before {")</code></span>
<span class="codeline" id="line-2787"><code>			body = p.parseBody()</code></span>
<span class="codeline" id="line-2788"><code>			p.expectSemi()</code></span>
<span class="codeline" id="line-2789"><code>		}</code></span>
<span class="codeline" id="line-2790"><code>	default:</code></span>
<span class="codeline" id="line-2791"><code>		p.expectSemi()</code></span>
<span class="codeline" id="line-2792"><code>	}</code></span>
<span class="codeline" id="line-2793"><code></code></span>
<span class="codeline" id="line-2794"><code>	decl := &amp;ast.FuncDecl{</code></span>
<span class="codeline" id="line-2795"><code>		Doc:  doc,</code></span>
<span class="codeline" id="line-2796"><code>		Recv: recv,</code></span>
<span class="codeline" id="line-2797"><code>		Name: ident,</code></span>
<span class="codeline" id="line-2798"><code>		Type: &amp;ast.FuncType{</code></span>
<span class="codeline" id="line-2799"><code>			Func:       pos,</code></span>
<span class="codeline" id="line-2800"><code>			TypeParams: tparams,</code></span>
<span class="codeline" id="line-2801"><code>			Params:     params,</code></span>
<span class="codeline" id="line-2802"><code>			Results:    results,</code></span>
<span class="codeline" id="line-2803"><code>		},</code></span>
<span class="codeline" id="line-2804"><code>		Body: body,</code></span>
<span class="codeline" id="line-2805"><code>	}</code></span>
<span class="codeline" id="line-2806"><code>	return decl</code></span>
<span class="codeline" id="line-2807"><code>}</code></span>
<span class="codeline" id="line-2808"><code></code></span>
<span class="codeline" id="line-2809"><code>func (p *parser) parseDecl(sync map[token.Token]bool) ast.Decl {</code></span>
<span class="codeline" id="line-2810"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2811"><code>		defer un(trace(p, "Declaration"))</code></span>
<span class="codeline" id="line-2812"><code>	}</code></span>
<span class="codeline" id="line-2813"><code></code></span>
<span class="codeline" id="line-2814"><code>	var f parseSpecFunction</code></span>
<span class="codeline" id="line-2815"><code>	switch p.tok {</code></span>
<span class="codeline" id="line-2816"><code>	case token.IMPORT:</code></span>
<span class="codeline" id="line-2817"><code>		f = p.parseImportSpec</code></span>
<span class="codeline" id="line-2818"><code></code></span>
<span class="codeline" id="line-2819"><code>	case token.CONST, token.VAR:</code></span>
<span class="codeline" id="line-2820"><code>		f = p.parseValueSpec</code></span>
<span class="codeline" id="line-2821"><code></code></span>
<span class="codeline" id="line-2822"><code>	case token.TYPE:</code></span>
<span class="codeline" id="line-2823"><code>		f = p.parseTypeSpec</code></span>
<span class="codeline" id="line-2824"><code></code></span>
<span class="codeline" id="line-2825"><code>	case token.FUNC:</code></span>
<span class="codeline" id="line-2826"><code>		return p.parseFuncDecl()</code></span>
<span class="codeline" id="line-2827"><code></code></span>
<span class="codeline" id="line-2828"><code>	default:</code></span>
<span class="codeline" id="line-2829"><code>		pos := p.pos</code></span>
<span class="codeline" id="line-2830"><code>		p.errorExpected(pos, "declaration")</code></span>
<span class="codeline" id="line-2831"><code>		p.advance(sync)</code></span>
<span class="codeline" id="line-2832"><code>		return &amp;ast.BadDecl{From: pos, To: p.pos}</code></span>
<span class="codeline" id="line-2833"><code>	}</code></span>
<span class="codeline" id="line-2834"><code></code></span>
<span class="codeline" id="line-2835"><code>	return p.parseGenDecl(p.tok, f)</code></span>
<span class="codeline" id="line-2836"><code>}</code></span>
<span class="codeline" id="line-2837"><code></code></span>
<span class="codeline" id="line-2838"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-2839"><code>// Source files</code></span>
<span class="codeline" id="line-2840"><code></code></span>
<span class="codeline" id="line-2841"><code>func (p *parser) parseFile() *ast.File {</code></span>
<span class="codeline" id="line-2842"><code>	if p.trace {</code></span>
<span class="codeline" id="line-2843"><code>		defer un(trace(p, "File"))</code></span>
<span class="codeline" id="line-2844"><code>	}</code></span>
<span class="codeline" id="line-2845"><code></code></span>
<span class="codeline" id="line-2846"><code>	// Don't bother parsing the rest if we had errors scanning the first token.</code></span>
<span class="codeline" id="line-2847"><code>	// Likely not a Go source file at all.</code></span>
<span class="codeline" id="line-2848"><code>	if p.errors.Len() != 0 {</code></span>
<span class="codeline" id="line-2849"><code>		return nil</code></span>
<span class="codeline" id="line-2850"><code>	}</code></span>
<span class="codeline" id="line-2851"><code></code></span>
<span class="codeline" id="line-2852"><code>	// package clause</code></span>
<span class="codeline" id="line-2853"><code>	doc := p.leadComment</code></span>
<span class="codeline" id="line-2854"><code>	pos := p.expect(token.PACKAGE)</code></span>
<span class="codeline" id="line-2855"><code>	// Go spec: The package clause is not a declaration;</code></span>
<span class="codeline" id="line-2856"><code>	// the package name does not appear in any scope.</code></span>
<span class="codeline" id="line-2857"><code>	ident := p.parseIdent()</code></span>
<span class="codeline" id="line-2858"><code>	if ident.Name == "_" &amp;&amp; p.mode&amp;DeclarationErrors != 0 {</code></span>
<span class="codeline" id="line-2859"><code>		p.error(p.pos, "invalid package name _")</code></span>
<span class="codeline" id="line-2860"><code>	}</code></span>
<span class="codeline" id="line-2861"><code>	p.expectSemi()</code></span>
<span class="codeline" id="line-2862"><code></code></span>
<span class="codeline" id="line-2863"><code>	// Don't bother parsing the rest if we had errors parsing the package clause.</code></span>
<span class="codeline" id="line-2864"><code>	// Likely not a Go source file at all.</code></span>
<span class="codeline" id="line-2865"><code>	if p.errors.Len() != 0 {</code></span>
<span class="codeline" id="line-2866"><code>		return nil</code></span>
<span class="codeline" id="line-2867"><code>	}</code></span>
<span class="codeline" id="line-2868"><code></code></span>
<span class="codeline" id="line-2869"><code>	var decls []ast.Decl</code></span>
<span class="codeline" id="line-2870"><code>	if p.mode&amp;PackageClauseOnly == 0 {</code></span>
<span class="codeline" id="line-2871"><code>		// import decls</code></span>
<span class="codeline" id="line-2872"><code>		for p.tok == token.IMPORT {</code></span>
<span class="codeline" id="line-2873"><code>			decls = append(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))</code></span>
<span class="codeline" id="line-2874"><code>		}</code></span>
<span class="codeline" id="line-2875"><code></code></span>
<span class="codeline" id="line-2876"><code>		if p.mode&amp;ImportsOnly == 0 {</code></span>
<span class="codeline" id="line-2877"><code>			// rest of package body</code></span>
<span class="codeline" id="line-2878"><code>			prev := token.IMPORT</code></span>
<span class="codeline" id="line-2879"><code>			for p.tok != token.EOF {</code></span>
<span class="codeline" id="line-2880"><code>				// Continue to accept import declarations for error tolerance, but complain.</code></span>
<span class="codeline" id="line-2881"><code>				if p.tok == token.IMPORT &amp;&amp; prev != token.IMPORT {</code></span>
<span class="codeline" id="line-2882"><code>					p.error(p.pos, "imports must appear before other declarations")</code></span>
<span class="codeline" id="line-2883"><code>				}</code></span>
<span class="codeline" id="line-2884"><code>				prev = p.tok</code></span>
<span class="codeline" id="line-2885"><code></code></span>
<span class="codeline" id="line-2886"><code>				decls = append(decls, p.parseDecl(declStart))</code></span>
<span class="codeline" id="line-2887"><code>			}</code></span>
<span class="codeline" id="line-2888"><code>		}</code></span>
<span class="codeline" id="line-2889"><code>	}</code></span>
<span class="codeline" id="line-2890"><code></code></span>
<span class="codeline" id="line-2891"><code>	f := &amp;ast.File{</code></span>
<span class="codeline" id="line-2892"><code>		Doc:       doc,</code></span>
<span class="codeline" id="line-2893"><code>		Package:   pos,</code></span>
<span class="codeline" id="line-2894"><code>		Name:      ident,</code></span>
<span class="codeline" id="line-2895"><code>		Decls:     decls,</code></span>
<span class="codeline" id="line-2896"><code>		FileStart: token.Pos(p.file.Base()),</code></span>
<span class="codeline" id="line-2897"><code>		FileEnd:   token.Pos(p.file.Base() + p.file.Size()),</code></span>
<span class="codeline" id="line-2898"><code>		Imports:   p.imports,</code></span>
<span class="codeline" id="line-2899"><code>		Comments:  p.comments,</code></span>
<span class="codeline" id="line-2900"><code>		GoVersion: p.goVersion,</code></span>
<span class="codeline" id="line-2901"><code>	}</code></span>
<span class="codeline" id="line-2902"><code>	var declErr func(token.Pos, string)</code></span>
<span class="codeline" id="line-2903"><code>	if p.mode&amp;DeclarationErrors != 0 {</code></span>
<span class="codeline" id="line-2904"><code>		declErr = p.error</code></span>
<span class="codeline" id="line-2905"><code>	}</code></span>
<span class="codeline" id="line-2906"><code>	if p.mode&amp;SkipObjectResolution == 0 {</code></span>
<span class="codeline" id="line-2907"><code>		resolveFile(f, p.file, declErr)</code></span>
<span class="codeline" id="line-2908"><code>	}</code></span>
<span class="codeline" id="line-2909"><code></code></span>
<span class="codeline" id="line-2910"><code>	return f</code></span>
<span class="codeline" id="line-2911"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>