<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: reader.go in package go/doc</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	reader.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/doc.html">go/doc</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package doc</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"go/ast"</code></span>
<span class="codeline" id="line-10"><code>	"go/token"</code></span>
<span class="codeline" id="line-11"><code>	"internal/lazyregexp"</code></span>
<span class="codeline" id="line-12"><code>	"path"</code></span>
<span class="codeline" id="line-13"><code>	"sort"</code></span>
<span class="codeline" id="line-14"><code>	"strconv"</code></span>
<span class="codeline" id="line-15"><code>	"strings"</code></span>
<span class="codeline" id="line-16"><code>	"unicode"</code></span>
<span class="codeline" id="line-17"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-18"><code>)</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-21"><code>// function/method sets</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>// Internally, we treat functions like methods and collect them in method sets.</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>// A methodSet describes a set of methods. Entries where Decl == nil are conflict</code></span>
<span class="codeline" id="line-26"><code>// entries (more than one method with the same name at the same embedding level).</code></span>
<span class="codeline" id="line-27"><code>type methodSet map[string]*Func</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// recvString returns a string representation of recv of the form "T", "*T",</code></span>
<span class="codeline" id="line-30"><code>// "T[A, ...]", "*T[A, ...]" or "BADRECV" (if not a proper receiver type).</code></span>
<span class="codeline" id="line-31"><code>func recvString(recv ast.Expr) string {</code></span>
<span class="codeline" id="line-32"><code>	switch t := recv.(type) {</code></span>
<span class="codeline" id="line-33"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-34"><code>		return t.Name</code></span>
<span class="codeline" id="line-35"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-36"><code>		return "*" + recvString(t.X)</code></span>
<span class="codeline" id="line-37"><code>	case *ast.IndexExpr:</code></span>
<span class="codeline" id="line-38"><code>		// Generic type with one parameter.</code></span>
<span class="codeline" id="line-39"><code>		return fmt.Sprintf("%s[%s]", recvString(t.X), recvParam(t.Index))</code></span>
<span class="codeline" id="line-40"><code>	case *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-41"><code>		// Generic type with multiple parameters.</code></span>
<span class="codeline" id="line-42"><code>		if len(t.Indices) &gt; 0 {</code></span>
<span class="codeline" id="line-43"><code>			var b strings.Builder</code></span>
<span class="codeline" id="line-44"><code>			b.WriteString(recvString(t.X))</code></span>
<span class="codeline" id="line-45"><code>			b.WriteByte('[')</code></span>
<span class="codeline" id="line-46"><code>			b.WriteString(recvParam(t.Indices[0]))</code></span>
<span class="codeline" id="line-47"><code>			for _, e := range t.Indices[1:] {</code></span>
<span class="codeline" id="line-48"><code>				b.WriteString(", ")</code></span>
<span class="codeline" id="line-49"><code>				b.WriteString(recvParam(e))</code></span>
<span class="codeline" id="line-50"><code>			}</code></span>
<span class="codeline" id="line-51"><code>			b.WriteByte(']')</code></span>
<span class="codeline" id="line-52"><code>			return b.String()</code></span>
<span class="codeline" id="line-53"><code>		}</code></span>
<span class="codeline" id="line-54"><code>	}</code></span>
<span class="codeline" id="line-55"><code>	return "BADRECV"</code></span>
<span class="codeline" id="line-56"><code>}</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>func recvParam(p ast.Expr) string {</code></span>
<span class="codeline" id="line-59"><code>	if id, ok := p.(*ast.Ident); ok {</code></span>
<span class="codeline" id="line-60"><code>		return id.Name</code></span>
<span class="codeline" id="line-61"><code>	}</code></span>
<span class="codeline" id="line-62"><code>	return "BADPARAM"</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// set creates the corresponding Func for f and adds it to mset.</code></span>
<span class="codeline" id="line-66"><code>// If there are multiple f's with the same name, set keeps the first</code></span>
<span class="codeline" id="line-67"><code>// one with documentation; conflicts are ignored. The boolean</code></span>
<span class="codeline" id="line-68"><code>// specifies whether to leave the AST untouched.</code></span>
<span class="codeline" id="line-69"><code>func (mset methodSet) set(f *ast.FuncDecl, preserveAST bool) {</code></span>
<span class="codeline" id="line-70"><code>	name := f.Name.Name</code></span>
<span class="codeline" id="line-71"><code>	if g := mset[name]; g != nil &amp;&amp; g.Doc != "" {</code></span>
<span class="codeline" id="line-72"><code>		// A function with the same name has already been registered;</code></span>
<span class="codeline" id="line-73"><code>		// since it has documentation, assume f is simply another</code></span>
<span class="codeline" id="line-74"><code>		// implementation and ignore it. This does not happen if the</code></span>
<span class="codeline" id="line-75"><code>		// caller is using go/build.ScanDir to determine the list of</code></span>
<span class="codeline" id="line-76"><code>		// files implementing a package.</code></span>
<span class="codeline" id="line-77"><code>		return</code></span>
<span class="codeline" id="line-78"><code>	}</code></span>
<span class="codeline" id="line-79"><code>	// function doesn't exist or has no documentation; use f</code></span>
<span class="codeline" id="line-80"><code>	recv := ""</code></span>
<span class="codeline" id="line-81"><code>	if f.Recv != nil {</code></span>
<span class="codeline" id="line-82"><code>		var typ ast.Expr</code></span>
<span class="codeline" id="line-83"><code>		// be careful in case of incorrect ASTs</code></span>
<span class="codeline" id="line-84"><code>		if list := f.Recv.List; len(list) == 1 {</code></span>
<span class="codeline" id="line-85"><code>			typ = list[0].Type</code></span>
<span class="codeline" id="line-86"><code>		}</code></span>
<span class="codeline" id="line-87"><code>		recv = recvString(typ)</code></span>
<span class="codeline" id="line-88"><code>	}</code></span>
<span class="codeline" id="line-89"><code>	mset[name] = &amp;Func{</code></span>
<span class="codeline" id="line-90"><code>		Doc:  f.Doc.Text(),</code></span>
<span class="codeline" id="line-91"><code>		Name: name,</code></span>
<span class="codeline" id="line-92"><code>		Decl: f,</code></span>
<span class="codeline" id="line-93"><code>		Recv: recv,</code></span>
<span class="codeline" id="line-94"><code>		Orig: recv,</code></span>
<span class="codeline" id="line-95"><code>	}</code></span>
<span class="codeline" id="line-96"><code>	if !preserveAST {</code></span>
<span class="codeline" id="line-97"><code>		f.Doc = nil // doc consumed - remove from AST</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>// add adds method m to the method set; m is ignored if the method set</code></span>
<span class="codeline" id="line-102"><code>// already contains a method with the same name at the same or a higher</code></span>
<span class="codeline" id="line-103"><code>// level than m.</code></span>
<span class="codeline" id="line-104"><code>func (mset methodSet) add(m *Func) {</code></span>
<span class="codeline" id="line-105"><code>	old := mset[m.Name]</code></span>
<span class="codeline" id="line-106"><code>	if old == nil || m.Level &lt; old.Level {</code></span>
<span class="codeline" id="line-107"><code>		mset[m.Name] = m</code></span>
<span class="codeline" id="line-108"><code>		return</code></span>
<span class="codeline" id="line-109"><code>	}</code></span>
<span class="codeline" id="line-110"><code>	if m.Level == old.Level {</code></span>
<span class="codeline" id="line-111"><code>		// conflict - mark it using a method with nil Decl</code></span>
<span class="codeline" id="line-112"><code>		mset[m.Name] = &amp;Func{</code></span>
<span class="codeline" id="line-113"><code>			Name:  m.Name,</code></span>
<span class="codeline" id="line-114"><code>			Level: m.Level,</code></span>
<span class="codeline" id="line-115"><code>		}</code></span>
<span class="codeline" id="line-116"><code>	}</code></span>
<span class="codeline" id="line-117"><code>}</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-120"><code>// Named types</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// baseTypeName returns the name of the base type of x (or "")</code></span>
<span class="codeline" id="line-123"><code>// and whether the type is imported or not.</code></span>
<span class="codeline" id="line-124"><code>func baseTypeName(x ast.Expr) (name string, imported bool) {</code></span>
<span class="codeline" id="line-125"><code>	switch t := x.(type) {</code></span>
<span class="codeline" id="line-126"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-127"><code>		return t.Name, false</code></span>
<span class="codeline" id="line-128"><code>	case *ast.IndexExpr:</code></span>
<span class="codeline" id="line-129"><code>		return baseTypeName(t.X)</code></span>
<span class="codeline" id="line-130"><code>	case *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-131"><code>		return baseTypeName(t.X)</code></span>
<span class="codeline" id="line-132"><code>	case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-133"><code>		if _, ok := t.X.(*ast.Ident); ok {</code></span>
<span class="codeline" id="line-134"><code>			// only possible for qualified type names;</code></span>
<span class="codeline" id="line-135"><code>			// assume type is imported</code></span>
<span class="codeline" id="line-136"><code>			return t.Sel.Name, true</code></span>
<span class="codeline" id="line-137"><code>		}</code></span>
<span class="codeline" id="line-138"><code>	case *ast.ParenExpr:</code></span>
<span class="codeline" id="line-139"><code>		return baseTypeName(t.X)</code></span>
<span class="codeline" id="line-140"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-141"><code>		return baseTypeName(t.X)</code></span>
<span class="codeline" id="line-142"><code>	}</code></span>
<span class="codeline" id="line-143"><code>	return "", false</code></span>
<span class="codeline" id="line-144"><code>}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>// An embeddedSet describes a set of embedded types.</code></span>
<span class="codeline" id="line-147"><code>type embeddedSet map[*namedType]bool</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>// A namedType represents a named unqualified (package local, or possibly</code></span>
<span class="codeline" id="line-150"><code>// predeclared) type. The namedType for a type name is always found via</code></span>
<span class="codeline" id="line-151"><code>// reader.lookupType.</code></span>
<span class="codeline" id="line-152"><code>type namedType struct {</code></span>
<span class="codeline" id="line-153"><code>	doc  string       // doc comment for type</code></span>
<span class="codeline" id="line-154"><code>	name string       // type name</code></span>
<span class="codeline" id="line-155"><code>	decl *ast.GenDecl // nil if declaration hasn't been seen yet</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>	isEmbedded bool        // true if this type is embedded</code></span>
<span class="codeline" id="line-158"><code>	isStruct   bool        // true if this type is a struct</code></span>
<span class="codeline" id="line-159"><code>	embedded   embeddedSet // true if the embedded type is a pointer</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	// associated declarations</code></span>
<span class="codeline" id="line-162"><code>	values  []*Value // consts and vars</code></span>
<span class="codeline" id="line-163"><code>	funcs   methodSet</code></span>
<span class="codeline" id="line-164"><code>	methods methodSet</code></span>
<span class="codeline" id="line-165"><code>}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-168"><code>// AST reader</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>// reader accumulates documentation for a single package.</code></span>
<span class="codeline" id="line-171"><code>// It modifies the AST: Comments (declaration documentation)</code></span>
<span class="codeline" id="line-172"><code>// that have been collected by the reader are set to nil</code></span>
<span class="codeline" id="line-173"><code>// in the respective AST nodes so that they are not printed</code></span>
<span class="codeline" id="line-174"><code>// twice (once when printing the documentation and once when</code></span>
<span class="codeline" id="line-175"><code>// printing the corresponding AST node).</code></span>
<span class="codeline" id="line-176"><code>type reader struct {</code></span>
<span class="codeline" id="line-177"><code>	mode Mode</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>	// package properties</code></span>
<span class="codeline" id="line-180"><code>	doc       string // package documentation, if any</code></span>
<span class="codeline" id="line-181"><code>	filenames []string</code></span>
<span class="codeline" id="line-182"><code>	notes     map[string][]*Note</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	// imports</code></span>
<span class="codeline" id="line-185"><code>	imports      map[string]int</code></span>
<span class="codeline" id="line-186"><code>	hasDotImp    bool // if set, package contains a dot import</code></span>
<span class="codeline" id="line-187"><code>	importByName map[string]string</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	// declarations</code></span>
<span class="codeline" id="line-190"><code>	values []*Value // consts and vars</code></span>
<span class="codeline" id="line-191"><code>	order  int      // sort order of const and var declarations (when we can't use a name)</code></span>
<span class="codeline" id="line-192"><code>	types  map[string]*namedType</code></span>
<span class="codeline" id="line-193"><code>	funcs  methodSet</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	// support for package-local shadowing of predeclared types</code></span>
<span class="codeline" id="line-196"><code>	shadowedPredecl map[string]bool</code></span>
<span class="codeline" id="line-197"><code>	fixmap          map[string][]*ast.InterfaceType</code></span>
<span class="codeline" id="line-198"><code>}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>func (r *reader) isVisible(name string) bool {</code></span>
<span class="codeline" id="line-201"><code>	return r.mode&amp;AllDecls != 0 || token.IsExported(name)</code></span>
<span class="codeline" id="line-202"><code>}</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>// lookupType returns the base type with the given name.</code></span>
<span class="codeline" id="line-205"><code>// If the base type has not been encountered yet, a new</code></span>
<span class="codeline" id="line-206"><code>// type with the given name but no associated declaration</code></span>
<span class="codeline" id="line-207"><code>// is added to the type map.</code></span>
<span class="codeline" id="line-208"><code>func (r *reader) lookupType(name string) *namedType {</code></span>
<span class="codeline" id="line-209"><code>	if name == "" || name == "_" {</code></span>
<span class="codeline" id="line-210"><code>		return nil // no type docs for anonymous types</code></span>
<span class="codeline" id="line-211"><code>	}</code></span>
<span class="codeline" id="line-212"><code>	if typ, found := r.types[name]; found {</code></span>
<span class="codeline" id="line-213"><code>		return typ</code></span>
<span class="codeline" id="line-214"><code>	}</code></span>
<span class="codeline" id="line-215"><code>	// type not found - add one without declaration</code></span>
<span class="codeline" id="line-216"><code>	typ := &amp;namedType{</code></span>
<span class="codeline" id="line-217"><code>		name:     name,</code></span>
<span class="codeline" id="line-218"><code>		embedded: make(embeddedSet),</code></span>
<span class="codeline" id="line-219"><code>		funcs:    make(methodSet),</code></span>
<span class="codeline" id="line-220"><code>		methods:  make(methodSet),</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	r.types[name] = typ</code></span>
<span class="codeline" id="line-223"><code>	return typ</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// recordAnonymousField registers fieldType as the type of an</code></span>
<span class="codeline" id="line-227"><code>// anonymous field in the parent type. If the field is imported</code></span>
<span class="codeline" id="line-228"><code>// (qualified name) or the parent is nil, the field is ignored.</code></span>
<span class="codeline" id="line-229"><code>// The function returns the field name.</code></span>
<span class="codeline" id="line-230"><code>func (r *reader) recordAnonymousField(parent *namedType, fieldType ast.Expr) (fname string) {</code></span>
<span class="codeline" id="line-231"><code>	fname, imp := baseTypeName(fieldType)</code></span>
<span class="codeline" id="line-232"><code>	if parent == nil || imp {</code></span>
<span class="codeline" id="line-233"><code>		return</code></span>
<span class="codeline" id="line-234"><code>	}</code></span>
<span class="codeline" id="line-235"><code>	if ftype := r.lookupType(fname); ftype != nil {</code></span>
<span class="codeline" id="line-236"><code>		ftype.isEmbedded = true</code></span>
<span class="codeline" id="line-237"><code>		_, ptr := fieldType.(*ast.StarExpr)</code></span>
<span class="codeline" id="line-238"><code>		parent.embedded[ftype] = ptr</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code>	return</code></span>
<span class="codeline" id="line-241"><code>}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>func (r *reader) readDoc(comment *ast.CommentGroup) {</code></span>
<span class="codeline" id="line-244"><code>	// By convention there should be only one package comment</code></span>
<span class="codeline" id="line-245"><code>	// but collect all of them if there are more than one.</code></span>
<span class="codeline" id="line-246"><code>	text := comment.Text()</code></span>
<span class="codeline" id="line-247"><code>	if r.doc == "" {</code></span>
<span class="codeline" id="line-248"><code>		r.doc = text</code></span>
<span class="codeline" id="line-249"><code>		return</code></span>
<span class="codeline" id="line-250"><code>	}</code></span>
<span class="codeline" id="line-251"><code>	r.doc += "\n" + text</code></span>
<span class="codeline" id="line-252"><code>}</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>func (r *reader) remember(predecl string, typ *ast.InterfaceType) {</code></span>
<span class="codeline" id="line-255"><code>	if r.fixmap == nil {</code></span>
<span class="codeline" id="line-256"><code>		r.fixmap = make(map[string][]*ast.InterfaceType)</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>	r.fixmap[predecl] = append(r.fixmap[predecl], typ)</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>func specNames(specs []ast.Spec) []string {</code></span>
<span class="codeline" id="line-262"><code>	names := make([]string, 0, len(specs)) // reasonable estimate</code></span>
<span class="codeline" id="line-263"><code>	for _, s := range specs {</code></span>
<span class="codeline" id="line-264"><code>		// s guaranteed to be an *ast.ValueSpec by readValue</code></span>
<span class="codeline" id="line-265"><code>		for _, ident := range s.(*ast.ValueSpec).Names {</code></span>
<span class="codeline" id="line-266"><code>			names = append(names, ident.Name)</code></span>
<span class="codeline" id="line-267"><code>		}</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	return names</code></span>
<span class="codeline" id="line-270"><code>}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>// readValue processes a const or var declaration.</code></span>
<span class="codeline" id="line-273"><code>func (r *reader) readValue(decl *ast.GenDecl) {</code></span>
<span class="codeline" id="line-274"><code>	// determine if decl should be associated with a type</code></span>
<span class="codeline" id="line-275"><code>	// Heuristic: For each typed entry, determine the type name, if any.</code></span>
<span class="codeline" id="line-276"><code>	//            If there is exactly one type name that is sufficiently</code></span>
<span class="codeline" id="line-277"><code>	//            frequent, associate the decl with the respective type.</code></span>
<span class="codeline" id="line-278"><code>	domName := ""</code></span>
<span class="codeline" id="line-279"><code>	domFreq := 0</code></span>
<span class="codeline" id="line-280"><code>	prev := ""</code></span>
<span class="codeline" id="line-281"><code>	n := 0</code></span>
<span class="codeline" id="line-282"><code>	for _, spec := range decl.Specs {</code></span>
<span class="codeline" id="line-283"><code>		s, ok := spec.(*ast.ValueSpec)</code></span>
<span class="codeline" id="line-284"><code>		if !ok {</code></span>
<span class="codeline" id="line-285"><code>			continue // should not happen, but be conservative</code></span>
<span class="codeline" id="line-286"><code>		}</code></span>
<span class="codeline" id="line-287"><code>		name := ""</code></span>
<span class="codeline" id="line-288"><code>		switch {</code></span>
<span class="codeline" id="line-289"><code>		case s.Type != nil:</code></span>
<span class="codeline" id="line-290"><code>			// a type is present; determine its name</code></span>
<span class="codeline" id="line-291"><code>			if n, imp := baseTypeName(s.Type); !imp {</code></span>
<span class="codeline" id="line-292"><code>				name = n</code></span>
<span class="codeline" id="line-293"><code>			}</code></span>
<span class="codeline" id="line-294"><code>		case decl.Tok == token.CONST &amp;&amp; len(s.Values) == 0:</code></span>
<span class="codeline" id="line-295"><code>			// no type or value is present but we have a constant declaration;</code></span>
<span class="codeline" id="line-296"><code>			// use the previous type name (possibly the empty string)</code></span>
<span class="codeline" id="line-297"><code>			name = prev</code></span>
<span class="codeline" id="line-298"><code>		}</code></span>
<span class="codeline" id="line-299"><code>		if name != "" {</code></span>
<span class="codeline" id="line-300"><code>			// entry has a named type</code></span>
<span class="codeline" id="line-301"><code>			if domName != "" &amp;&amp; domName != name {</code></span>
<span class="codeline" id="line-302"><code>				// more than one type name - do not associate</code></span>
<span class="codeline" id="line-303"><code>				// with any type</code></span>
<span class="codeline" id="line-304"><code>				domName = ""</code></span>
<span class="codeline" id="line-305"><code>				break</code></span>
<span class="codeline" id="line-306"><code>			}</code></span>
<span class="codeline" id="line-307"><code>			domName = name</code></span>
<span class="codeline" id="line-308"><code>			domFreq++</code></span>
<span class="codeline" id="line-309"><code>		}</code></span>
<span class="codeline" id="line-310"><code>		prev = name</code></span>
<span class="codeline" id="line-311"><code>		n++</code></span>
<span class="codeline" id="line-312"><code>	}</code></span>
<span class="codeline" id="line-313"><code></code></span>
<span class="codeline" id="line-314"><code>	// nothing to do w/o a legal declaration</code></span>
<span class="codeline" id="line-315"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-316"><code>		return</code></span>
<span class="codeline" id="line-317"><code>	}</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>	// determine values list with which to associate the Value for this decl</code></span>
<span class="codeline" id="line-320"><code>	values := &amp;r.values</code></span>
<span class="codeline" id="line-321"><code>	const threshold = 0.75</code></span>
<span class="codeline" id="line-322"><code>	if domName != "" &amp;&amp; r.isVisible(domName) &amp;&amp; domFreq &gt;= int(float64(len(decl.Specs))*threshold) {</code></span>
<span class="codeline" id="line-323"><code>		// typed entries are sufficiently frequent</code></span>
<span class="codeline" id="line-324"><code>		if typ := r.lookupType(domName); typ != nil {</code></span>
<span class="codeline" id="line-325"><code>			values = &amp;typ.values // associate with that type</code></span>
<span class="codeline" id="line-326"><code>		}</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>	*values = append(*values, &amp;Value{</code></span>
<span class="codeline" id="line-330"><code>		Doc:   decl.Doc.Text(),</code></span>
<span class="codeline" id="line-331"><code>		Names: specNames(decl.Specs),</code></span>
<span class="codeline" id="line-332"><code>		Decl:  decl,</code></span>
<span class="codeline" id="line-333"><code>		order: r.order,</code></span>
<span class="codeline" id="line-334"><code>	})</code></span>
<span class="codeline" id="line-335"><code>	if r.mode&amp;PreserveAST == 0 {</code></span>
<span class="codeline" id="line-336"><code>		decl.Doc = nil // doc consumed - remove from AST</code></span>
<span class="codeline" id="line-337"><code>	}</code></span>
<span class="codeline" id="line-338"><code>	// Note: It's important that the order used here is global because the cleanupTypes</code></span>
<span class="codeline" id="line-339"><code>	// methods may move values associated with types back into the global list. If the</code></span>
<span class="codeline" id="line-340"><code>	// order is list-specific, sorting is not deterministic because the same order value</code></span>
<span class="codeline" id="line-341"><code>	// may appear multiple times (was bug, found when fixing #16153).</code></span>
<span class="codeline" id="line-342"><code>	r.order++</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>// fields returns a struct's fields or an interface's methods.</code></span>
<span class="codeline" id="line-346"><code>func fields(typ ast.Expr) (list []*ast.Field, isStruct bool) {</code></span>
<span class="codeline" id="line-347"><code>	var fields *ast.FieldList</code></span>
<span class="codeline" id="line-348"><code>	switch t := typ.(type) {</code></span>
<span class="codeline" id="line-349"><code>	case *ast.StructType:</code></span>
<span class="codeline" id="line-350"><code>		fields = t.Fields</code></span>
<span class="codeline" id="line-351"><code>		isStruct = true</code></span>
<span class="codeline" id="line-352"><code>	case *ast.InterfaceType:</code></span>
<span class="codeline" id="line-353"><code>		fields = t.Methods</code></span>
<span class="codeline" id="line-354"><code>	}</code></span>
<span class="codeline" id="line-355"><code>	if fields != nil {</code></span>
<span class="codeline" id="line-356"><code>		list = fields.List</code></span>
<span class="codeline" id="line-357"><code>	}</code></span>
<span class="codeline" id="line-358"><code>	return</code></span>
<span class="codeline" id="line-359"><code>}</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>// readType processes a type declaration.</code></span>
<span class="codeline" id="line-362"><code>func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec) {</code></span>
<span class="codeline" id="line-363"><code>	typ := r.lookupType(spec.Name.Name)</code></span>
<span class="codeline" id="line-364"><code>	if typ == nil {</code></span>
<span class="codeline" id="line-365"><code>		return // no name or blank name - ignore the type</code></span>
<span class="codeline" id="line-366"><code>	}</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>	// A type should be added at most once, so typ.decl</code></span>
<span class="codeline" id="line-369"><code>	// should be nil - if it is not, simply overwrite it.</code></span>
<span class="codeline" id="line-370"><code>	typ.decl = decl</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>	// compute documentation</code></span>
<span class="codeline" id="line-373"><code>	doc := spec.Doc</code></span>
<span class="codeline" id="line-374"><code>	if doc == nil {</code></span>
<span class="codeline" id="line-375"><code>		// no doc associated with the spec, use the declaration doc, if any</code></span>
<span class="codeline" id="line-376"><code>		doc = decl.Doc</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	if r.mode&amp;PreserveAST == 0 {</code></span>
<span class="codeline" id="line-379"><code>		spec.Doc = nil // doc consumed - remove from AST</code></span>
<span class="codeline" id="line-380"><code>		decl.Doc = nil // doc consumed - remove from AST</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code>	typ.doc = doc.Text()</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	// record anonymous fields (they may contribute methods)</code></span>
<span class="codeline" id="line-385"><code>	// (some fields may have been recorded already when filtering</code></span>
<span class="codeline" id="line-386"><code>	// exports, but that's ok)</code></span>
<span class="codeline" id="line-387"><code>	var list []*ast.Field</code></span>
<span class="codeline" id="line-388"><code>	list, typ.isStruct = fields(spec.Type)</code></span>
<span class="codeline" id="line-389"><code>	for _, field := range list {</code></span>
<span class="codeline" id="line-390"><code>		if len(field.Names) == 0 {</code></span>
<span class="codeline" id="line-391"><code>			r.recordAnonymousField(typ, field.Type)</code></span>
<span class="codeline" id="line-392"><code>		}</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>// isPredeclared reports whether n denotes a predeclared type.</code></span>
<span class="codeline" id="line-397"><code>func (r *reader) isPredeclared(n string) bool {</code></span>
<span class="codeline" id="line-398"><code>	return predeclaredTypes[n] &amp;&amp; r.types[n] == nil</code></span>
<span class="codeline" id="line-399"><code>}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>// readFunc processes a func or method declaration.</code></span>
<span class="codeline" id="line-402"><code>func (r *reader) readFunc(fun *ast.FuncDecl) {</code></span>
<span class="codeline" id="line-403"><code>	// strip function body if requested.</code></span>
<span class="codeline" id="line-404"><code>	if r.mode&amp;PreserveAST == 0 {</code></span>
<span class="codeline" id="line-405"><code>		fun.Body = nil</code></span>
<span class="codeline" id="line-406"><code>	}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>	// associate methods with the receiver type, if any</code></span>
<span class="codeline" id="line-409"><code>	if fun.Recv != nil {</code></span>
<span class="codeline" id="line-410"><code>		// method</code></span>
<span class="codeline" id="line-411"><code>		if len(fun.Recv.List) == 0 {</code></span>
<span class="codeline" id="line-412"><code>			// should not happen (incorrect AST); (See issue 17788)</code></span>
<span class="codeline" id="line-413"><code>			// don't show this method</code></span>
<span class="codeline" id="line-414"><code>			return</code></span>
<span class="codeline" id="line-415"><code>		}</code></span>
<span class="codeline" id="line-416"><code>		recvTypeName, imp := baseTypeName(fun.Recv.List[0].Type)</code></span>
<span class="codeline" id="line-417"><code>		if imp {</code></span>
<span class="codeline" id="line-418"><code>			// should not happen (incorrect AST);</code></span>
<span class="codeline" id="line-419"><code>			// don't show this method</code></span>
<span class="codeline" id="line-420"><code>			return</code></span>
<span class="codeline" id="line-421"><code>		}</code></span>
<span class="codeline" id="line-422"><code>		if typ := r.lookupType(recvTypeName); typ != nil {</code></span>
<span class="codeline" id="line-423"><code>			typ.methods.set(fun, r.mode&amp;PreserveAST != 0)</code></span>
<span class="codeline" id="line-424"><code>		}</code></span>
<span class="codeline" id="line-425"><code>		// otherwise ignore the method</code></span>
<span class="codeline" id="line-426"><code>		// TODO(gri): There may be exported methods of non-exported types</code></span>
<span class="codeline" id="line-427"><code>		// that can be called because of exported values (consts, vars, or</code></span>
<span class="codeline" id="line-428"><code>		// function results) of that type. Could determine if that is the</code></span>
<span class="codeline" id="line-429"><code>		// case and then show those methods in an appropriate section.</code></span>
<span class="codeline" id="line-430"><code>		return</code></span>
<span class="codeline" id="line-431"><code>	}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>	// Associate factory functions with the first visible result type, as long as</code></span>
<span class="codeline" id="line-434"><code>	// others are predeclared types.</code></span>
<span class="codeline" id="line-435"><code>	if fun.Type.Results.NumFields() &gt;= 1 {</code></span>
<span class="codeline" id="line-436"><code>		var typ *namedType // type to associate the function with</code></span>
<span class="codeline" id="line-437"><code>		numResultTypes := 0</code></span>
<span class="codeline" id="line-438"><code>		for _, res := range fun.Type.Results.List {</code></span>
<span class="codeline" id="line-439"><code>			factoryType := res.Type</code></span>
<span class="codeline" id="line-440"><code>			if t, ok := factoryType.(*ast.ArrayType); ok {</code></span>
<span class="codeline" id="line-441"><code>				// We consider functions that return slices or arrays of type</code></span>
<span class="codeline" id="line-442"><code>				// T (or pointers to T) as factory functions of T.</code></span>
<span class="codeline" id="line-443"><code>				factoryType = t.Elt</code></span>
<span class="codeline" id="line-444"><code>			}</code></span>
<span class="codeline" id="line-445"><code>			if n, imp := baseTypeName(factoryType); !imp &amp;&amp; r.isVisible(n) &amp;&amp; !r.isPredeclared(n) {</code></span>
<span class="codeline" id="line-446"><code>				if lookupTypeParam(n, fun.Type.TypeParams) != nil {</code></span>
<span class="codeline" id="line-447"><code>					// Issue #49477: don't associate fun with its type parameter result.</code></span>
<span class="codeline" id="line-448"><code>					// A type parameter is not a defined type.</code></span>
<span class="codeline" id="line-449"><code>					continue</code></span>
<span class="codeline" id="line-450"><code>				}</code></span>
<span class="codeline" id="line-451"><code>				if t := r.lookupType(n); t != nil {</code></span>
<span class="codeline" id="line-452"><code>					typ = t</code></span>
<span class="codeline" id="line-453"><code>					numResultTypes++</code></span>
<span class="codeline" id="line-454"><code>					if numResultTypes &gt; 1 {</code></span>
<span class="codeline" id="line-455"><code>						break</code></span>
<span class="codeline" id="line-456"><code>					}</code></span>
<span class="codeline" id="line-457"><code>				}</code></span>
<span class="codeline" id="line-458"><code>			}</code></span>
<span class="codeline" id="line-459"><code>		}</code></span>
<span class="codeline" id="line-460"><code>		// If there is exactly one result type,</code></span>
<span class="codeline" id="line-461"><code>		// associate the function with that type.</code></span>
<span class="codeline" id="line-462"><code>		if numResultTypes == 1 {</code></span>
<span class="codeline" id="line-463"><code>			typ.funcs.set(fun, r.mode&amp;PreserveAST != 0)</code></span>
<span class="codeline" id="line-464"><code>			return</code></span>
<span class="codeline" id="line-465"><code>		}</code></span>
<span class="codeline" id="line-466"><code>	}</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>	// just an ordinary function</code></span>
<span class="codeline" id="line-469"><code>	r.funcs.set(fun, r.mode&amp;PreserveAST != 0)</code></span>
<span class="codeline" id="line-470"><code>}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>// lookupTypeParam searches for type parameters named name within the tparams</code></span>
<span class="codeline" id="line-473"><code>// field list, returning the relevant identifier if found, or nil if not.</code></span>
<span class="codeline" id="line-474"><code>func lookupTypeParam(name string, tparams *ast.FieldList) *ast.Ident {</code></span>
<span class="codeline" id="line-475"><code>	if tparams == nil {</code></span>
<span class="codeline" id="line-476"><code>		return nil</code></span>
<span class="codeline" id="line-477"><code>	}</code></span>
<span class="codeline" id="line-478"><code>	for _, field := range tparams.List {</code></span>
<span class="codeline" id="line-479"><code>		for _, id := range field.Names {</code></span>
<span class="codeline" id="line-480"><code>			if id.Name == name {</code></span>
<span class="codeline" id="line-481"><code>				return id</code></span>
<span class="codeline" id="line-482"><code>			}</code></span>
<span class="codeline" id="line-483"><code>		}</code></span>
<span class="codeline" id="line-484"><code>	}</code></span>
<span class="codeline" id="line-485"><code>	return nil</code></span>
<span class="codeline" id="line-486"><code>}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>var (</code></span>
<span class="codeline" id="line-489"><code>	noteMarker    = `([A-Z][A-Z]+)\(([^)]+)\):?`                // MARKER(uid), MARKER at least 2 chars, uid at least 1 char</code></span>
<span class="codeline" id="line-490"><code>	noteMarkerRx  = lazyregexp.New(`^[ \t]*` + noteMarker)      // MARKER(uid) at text start</code></span>
<span class="codeline" id="line-491"><code>	noteCommentRx = lazyregexp.New(`^/[/*][ \t]*` + noteMarker) // MARKER(uid) at comment start</code></span>
<span class="codeline" id="line-492"><code>)</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>// clean replaces each sequence of space, \r, or \t characters</code></span>
<span class="codeline" id="line-495"><code>// with a single space and removes any trailing and leading spaces.</code></span>
<span class="codeline" id="line-496"><code>func clean(s string) string {</code></span>
<span class="codeline" id="line-497"><code>	var b []byte</code></span>
<span class="codeline" id="line-498"><code>	p := byte(' ')</code></span>
<span class="codeline" id="line-499"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-500"><code>		q := s[i]</code></span>
<span class="codeline" id="line-501"><code>		if q == '\r' || q == '\t' {</code></span>
<span class="codeline" id="line-502"><code>			q = ' '</code></span>
<span class="codeline" id="line-503"><code>		}</code></span>
<span class="codeline" id="line-504"><code>		if q != ' ' || p != ' ' {</code></span>
<span class="codeline" id="line-505"><code>			b = append(b, q)</code></span>
<span class="codeline" id="line-506"><code>			p = q</code></span>
<span class="codeline" id="line-507"><code>		}</code></span>
<span class="codeline" id="line-508"><code>	}</code></span>
<span class="codeline" id="line-509"><code>	// remove trailing blank, if any</code></span>
<span class="codeline" id="line-510"><code>	if n := len(b); n &gt; 0 &amp;&amp; p == ' ' {</code></span>
<span class="codeline" id="line-511"><code>		b = b[0 : n-1]</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code>	return string(b)</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>// readNote collects a single note from a sequence of comments.</code></span>
<span class="codeline" id="line-517"><code>func (r *reader) readNote(list []*ast.Comment) {</code></span>
<span class="codeline" id="line-518"><code>	text := (&amp;ast.CommentGroup{List: list}).Text()</code></span>
<span class="codeline" id="line-519"><code>	if m := noteMarkerRx.FindStringSubmatchIndex(text); m != nil {</code></span>
<span class="codeline" id="line-520"><code>		// The note body starts after the marker.</code></span>
<span class="codeline" id="line-521"><code>		// We remove any formatting so that we don't</code></span>
<span class="codeline" id="line-522"><code>		// get spurious line breaks/indentation when</code></span>
<span class="codeline" id="line-523"><code>		// showing the TODO body.</code></span>
<span class="codeline" id="line-524"><code>		body := clean(text[m[1]:])</code></span>
<span class="codeline" id="line-525"><code>		if body != "" {</code></span>
<span class="codeline" id="line-526"><code>			marker := text[m[2]:m[3]]</code></span>
<span class="codeline" id="line-527"><code>			r.notes[marker] = append(r.notes[marker], &amp;Note{</code></span>
<span class="codeline" id="line-528"><code>				Pos:  list[0].Pos(),</code></span>
<span class="codeline" id="line-529"><code>				End:  list[len(list)-1].End(),</code></span>
<span class="codeline" id="line-530"><code>				UID:  text[m[4]:m[5]],</code></span>
<span class="codeline" id="line-531"><code>				Body: body,</code></span>
<span class="codeline" id="line-532"><code>			})</code></span>
<span class="codeline" id="line-533"><code>		}</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>// readNotes extracts notes from comments.</code></span>
<span class="codeline" id="line-538"><code>// A note must start at the beginning of a comment with "MARKER(uid):"</code></span>
<span class="codeline" id="line-539"><code>// and is followed by the note body (e.g., "// BUG(gri): fix this").</code></span>
<span class="codeline" id="line-540"><code>// The note ends at the end of the comment group or at the start of</code></span>
<span class="codeline" id="line-541"><code>// another note in the same comment group, whichever comes first.</code></span>
<span class="codeline" id="line-542"><code>func (r *reader) readNotes(comments []*ast.CommentGroup) {</code></span>
<span class="codeline" id="line-543"><code>	for _, group := range comments {</code></span>
<span class="codeline" id="line-544"><code>		i := -1 // comment index of most recent note start, valid if &gt;= 0</code></span>
<span class="codeline" id="line-545"><code>		list := group.List</code></span>
<span class="codeline" id="line-546"><code>		for j, c := range list {</code></span>
<span class="codeline" id="line-547"><code>			if noteCommentRx.MatchString(c.Text) {</code></span>
<span class="codeline" id="line-548"><code>				if i &gt;= 0 {</code></span>
<span class="codeline" id="line-549"><code>					r.readNote(list[i:j])</code></span>
<span class="codeline" id="line-550"><code>				}</code></span>
<span class="codeline" id="line-551"><code>				i = j</code></span>
<span class="codeline" id="line-552"><code>			}</code></span>
<span class="codeline" id="line-553"><code>		}</code></span>
<span class="codeline" id="line-554"><code>		if i &gt;= 0 {</code></span>
<span class="codeline" id="line-555"><code>			r.readNote(list[i:])</code></span>
<span class="codeline" id="line-556"><code>		}</code></span>
<span class="codeline" id="line-557"><code>	}</code></span>
<span class="codeline" id="line-558"><code>}</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>// readFile adds the AST for a source file to the reader.</code></span>
<span class="codeline" id="line-561"><code>func (r *reader) readFile(src *ast.File) {</code></span>
<span class="codeline" id="line-562"><code>	// add package documentation</code></span>
<span class="codeline" id="line-563"><code>	if src.Doc != nil {</code></span>
<span class="codeline" id="line-564"><code>		r.readDoc(src.Doc)</code></span>
<span class="codeline" id="line-565"><code>		if r.mode&amp;PreserveAST == 0 {</code></span>
<span class="codeline" id="line-566"><code>			src.Doc = nil // doc consumed - remove from AST</code></span>
<span class="codeline" id="line-567"><code>		}</code></span>
<span class="codeline" id="line-568"><code>	}</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>	// add all declarations but for functions which are processed in a separate pass</code></span>
<span class="codeline" id="line-571"><code>	for _, decl := range src.Decls {</code></span>
<span class="codeline" id="line-572"><code>		switch d := decl.(type) {</code></span>
<span class="codeline" id="line-573"><code>		case *ast.GenDecl:</code></span>
<span class="codeline" id="line-574"><code>			switch d.Tok {</code></span>
<span class="codeline" id="line-575"><code>			case token.IMPORT:</code></span>
<span class="codeline" id="line-576"><code>				// imports are handled individually</code></span>
<span class="codeline" id="line-577"><code>				for _, spec := range d.Specs {</code></span>
<span class="codeline" id="line-578"><code>					if s, ok := spec.(*ast.ImportSpec); ok {</code></span>
<span class="codeline" id="line-579"><code>						if import_, err := strconv.Unquote(s.Path.Value); err == nil {</code></span>
<span class="codeline" id="line-580"><code>							r.imports[import_] = 1</code></span>
<span class="codeline" id="line-581"><code>							var name string</code></span>
<span class="codeline" id="line-582"><code>							if s.Name != nil {</code></span>
<span class="codeline" id="line-583"><code>								name = s.Name.Name</code></span>
<span class="codeline" id="line-584"><code>								if name == "." {</code></span>
<span class="codeline" id="line-585"><code>									r.hasDotImp = true</code></span>
<span class="codeline" id="line-586"><code>								}</code></span>
<span class="codeline" id="line-587"><code>							}</code></span>
<span class="codeline" id="line-588"><code>							if name != "." {</code></span>
<span class="codeline" id="line-589"><code>								if name == "" {</code></span>
<span class="codeline" id="line-590"><code>									name = assumedPackageName(import_)</code></span>
<span class="codeline" id="line-591"><code>								}</code></span>
<span class="codeline" id="line-592"><code>								old, ok := r.importByName[name]</code></span>
<span class="codeline" id="line-593"><code>								if !ok {</code></span>
<span class="codeline" id="line-594"><code>									r.importByName[name] = import_</code></span>
<span class="codeline" id="line-595"><code>								} else if old != import_ &amp;&amp; old != "" {</code></span>
<span class="codeline" id="line-596"><code>									r.importByName[name] = "" // ambiguous</code></span>
<span class="codeline" id="line-597"><code>								}</code></span>
<span class="codeline" id="line-598"><code>							}</code></span>
<span class="codeline" id="line-599"><code>						}</code></span>
<span class="codeline" id="line-600"><code>					}</code></span>
<span class="codeline" id="line-601"><code>				}</code></span>
<span class="codeline" id="line-602"><code>			case token.CONST, token.VAR:</code></span>
<span class="codeline" id="line-603"><code>				// constants and variables are always handled as a group</code></span>
<span class="codeline" id="line-604"><code>				r.readValue(d)</code></span>
<span class="codeline" id="line-605"><code>			case token.TYPE:</code></span>
<span class="codeline" id="line-606"><code>				// types are handled individually</code></span>
<span class="codeline" id="line-607"><code>				if len(d.Specs) == 1 &amp;&amp; !d.Lparen.IsValid() {</code></span>
<span class="codeline" id="line-608"><code>					// common case: single declaration w/o parentheses</code></span>
<span class="codeline" id="line-609"><code>					// (if a single declaration is parenthesized,</code></span>
<span class="codeline" id="line-610"><code>					// create a new fake declaration below, so that</code></span>
<span class="codeline" id="line-611"><code>					// go/doc type declarations always appear w/o</code></span>
<span class="codeline" id="line-612"><code>					// parentheses)</code></span>
<span class="codeline" id="line-613"><code>					if s, ok := d.Specs[0].(*ast.TypeSpec); ok {</code></span>
<span class="codeline" id="line-614"><code>						r.readType(d, s)</code></span>
<span class="codeline" id="line-615"><code>					}</code></span>
<span class="codeline" id="line-616"><code>					break</code></span>
<span class="codeline" id="line-617"><code>				}</code></span>
<span class="codeline" id="line-618"><code>				for _, spec := range d.Specs {</code></span>
<span class="codeline" id="line-619"><code>					if s, ok := spec.(*ast.TypeSpec); ok {</code></span>
<span class="codeline" id="line-620"><code>						// use an individual (possibly fake) declaration</code></span>
<span class="codeline" id="line-621"><code>						// for each type; this also ensures that each type</code></span>
<span class="codeline" id="line-622"><code>						// gets to (re-)use the declaration documentation</code></span>
<span class="codeline" id="line-623"><code>						// if there's none associated with the spec itself</code></span>
<span class="codeline" id="line-624"><code>						fake := &amp;ast.GenDecl{</code></span>
<span class="codeline" id="line-625"><code>							Doc: d.Doc,</code></span>
<span class="codeline" id="line-626"><code>							// don't use the existing TokPos because it</code></span>
<span class="codeline" id="line-627"><code>							// will lead to the wrong selection range for</code></span>
<span class="codeline" id="line-628"><code>							// the fake declaration if there are more</code></span>
<span class="codeline" id="line-629"><code>							// than one type in the group (this affects</code></span>
<span class="codeline" id="line-630"><code>							// src/cmd/godoc/godoc.go's posLink_urlFunc)</code></span>
<span class="codeline" id="line-631"><code>							TokPos: s.Pos(),</code></span>
<span class="codeline" id="line-632"><code>							Tok:    token.TYPE,</code></span>
<span class="codeline" id="line-633"><code>							Specs:  []ast.Spec{s},</code></span>
<span class="codeline" id="line-634"><code>						}</code></span>
<span class="codeline" id="line-635"><code>						r.readType(fake, s)</code></span>
<span class="codeline" id="line-636"><code>					}</code></span>
<span class="codeline" id="line-637"><code>				}</code></span>
<span class="codeline" id="line-638"><code>			}</code></span>
<span class="codeline" id="line-639"><code>		}</code></span>
<span class="codeline" id="line-640"><code>	}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>	// collect MARKER(...): annotations</code></span>
<span class="codeline" id="line-643"><code>	r.readNotes(src.Comments)</code></span>
<span class="codeline" id="line-644"><code>	if r.mode&amp;PreserveAST == 0 {</code></span>
<span class="codeline" id="line-645"><code>		src.Comments = nil // consumed unassociated comments - remove from AST</code></span>
<span class="codeline" id="line-646"><code>	}</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>func (r *reader) readPackage(pkg *ast.Package, mode Mode) {</code></span>
<span class="codeline" id="line-650"><code>	// initialize reader</code></span>
<span class="codeline" id="line-651"><code>	r.filenames = make([]string, len(pkg.Files))</code></span>
<span class="codeline" id="line-652"><code>	r.imports = make(map[string]int)</code></span>
<span class="codeline" id="line-653"><code>	r.mode = mode</code></span>
<span class="codeline" id="line-654"><code>	r.types = make(map[string]*namedType)</code></span>
<span class="codeline" id="line-655"><code>	r.funcs = make(methodSet)</code></span>
<span class="codeline" id="line-656"><code>	r.notes = make(map[string][]*Note)</code></span>
<span class="codeline" id="line-657"><code>	r.importByName = make(map[string]string)</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>	// sort package files before reading them so that the</code></span>
<span class="codeline" id="line-660"><code>	// result does not depend on map iteration order</code></span>
<span class="codeline" id="line-661"><code>	i := 0</code></span>
<span class="codeline" id="line-662"><code>	for filename := range pkg.Files {</code></span>
<span class="codeline" id="line-663"><code>		r.filenames[i] = filename</code></span>
<span class="codeline" id="line-664"><code>		i++</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>	sort.Strings(r.filenames)</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>	// process files in sorted order</code></span>
<span class="codeline" id="line-669"><code>	for _, filename := range r.filenames {</code></span>
<span class="codeline" id="line-670"><code>		f := pkg.Files[filename]</code></span>
<span class="codeline" id="line-671"><code>		if mode&amp;AllDecls == 0 {</code></span>
<span class="codeline" id="line-672"><code>			r.fileExports(f)</code></span>
<span class="codeline" id="line-673"><code>		}</code></span>
<span class="codeline" id="line-674"><code>		r.readFile(f)</code></span>
<span class="codeline" id="line-675"><code>	}</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	for name, path := range r.importByName {</code></span>
<span class="codeline" id="line-678"><code>		if path == "" {</code></span>
<span class="codeline" id="line-679"><code>			delete(r.importByName, name)</code></span>
<span class="codeline" id="line-680"><code>		}</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code></code></span>
<span class="codeline" id="line-683"><code>	// process functions now that we have better type information</code></span>
<span class="codeline" id="line-684"><code>	for _, f := range pkg.Files {</code></span>
<span class="codeline" id="line-685"><code>		for _, decl := range f.Decls {</code></span>
<span class="codeline" id="line-686"><code>			if d, ok := decl.(*ast.FuncDecl); ok {</code></span>
<span class="codeline" id="line-687"><code>				r.readFunc(d)</code></span>
<span class="codeline" id="line-688"><code>			}</code></span>
<span class="codeline" id="line-689"><code>		}</code></span>
<span class="codeline" id="line-690"><code>	}</code></span>
<span class="codeline" id="line-691"><code>}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-694"><code>// Types</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>func customizeRecv(f *Func, recvTypeName string, embeddedIsPtr bool, level int) *Func {</code></span>
<span class="codeline" id="line-697"><code>	if f == nil || f.Decl == nil || f.Decl.Recv == nil || len(f.Decl.Recv.List) != 1 {</code></span>
<span class="codeline" id="line-698"><code>		return f // shouldn't happen, but be safe</code></span>
<span class="codeline" id="line-699"><code>	}</code></span>
<span class="codeline" id="line-700"><code></code></span>
<span class="codeline" id="line-701"><code>	// copy existing receiver field and set new type</code></span>
<span class="codeline" id="line-702"><code>	newField := *f.Decl.Recv.List[0]</code></span>
<span class="codeline" id="line-703"><code>	origPos := newField.Type.Pos()</code></span>
<span class="codeline" id="line-704"><code>	_, origRecvIsPtr := newField.Type.(*ast.StarExpr)</code></span>
<span class="codeline" id="line-705"><code>	newIdent := &amp;ast.Ident{NamePos: origPos, Name: recvTypeName}</code></span>
<span class="codeline" id="line-706"><code>	var typ ast.Expr = newIdent</code></span>
<span class="codeline" id="line-707"><code>	if !embeddedIsPtr &amp;&amp; origRecvIsPtr {</code></span>
<span class="codeline" id="line-708"><code>		newIdent.NamePos++ // '*' is one character</code></span>
<span class="codeline" id="line-709"><code>		typ = &amp;ast.StarExpr{Star: origPos, X: newIdent}</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>	newField.Type = typ</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>	// copy existing receiver field list and set new receiver field</code></span>
<span class="codeline" id="line-714"><code>	newFieldList := *f.Decl.Recv</code></span>
<span class="codeline" id="line-715"><code>	newFieldList.List = []*ast.Field{&amp;newField}</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>	// copy existing function declaration and set new receiver field list</code></span>
<span class="codeline" id="line-718"><code>	newFuncDecl := *f.Decl</code></span>
<span class="codeline" id="line-719"><code>	newFuncDecl.Recv = &amp;newFieldList</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>	// copy existing function documentation and set new declaration</code></span>
<span class="codeline" id="line-722"><code>	newF := *f</code></span>
<span class="codeline" id="line-723"><code>	newF.Decl = &amp;newFuncDecl</code></span>
<span class="codeline" id="line-724"><code>	newF.Recv = recvString(typ)</code></span>
<span class="codeline" id="line-725"><code>	// the Orig field never changes</code></span>
<span class="codeline" id="line-726"><code>	newF.Level = level</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>	return &amp;newF</code></span>
<span class="codeline" id="line-729"><code>}</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>// collectEmbeddedMethods collects the embedded methods of typ in mset.</code></span>
<span class="codeline" id="line-732"><code>func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvTypeName string, embeddedIsPtr bool, level int, visited embeddedSet) {</code></span>
<span class="codeline" id="line-733"><code>	visited[typ] = true</code></span>
<span class="codeline" id="line-734"><code>	for embedded, isPtr := range typ.embedded {</code></span>
<span class="codeline" id="line-735"><code>		// Once an embedded type is embedded as a pointer type</code></span>
<span class="codeline" id="line-736"><code>		// all embedded types in those types are treated like</code></span>
<span class="codeline" id="line-737"><code>		// pointer types for the purpose of the receiver type</code></span>
<span class="codeline" id="line-738"><code>		// computation; i.e., embeddedIsPtr is sticky for this</code></span>
<span class="codeline" id="line-739"><code>		// embedding hierarchy.</code></span>
<span class="codeline" id="line-740"><code>		thisEmbeddedIsPtr := embeddedIsPtr || isPtr</code></span>
<span class="codeline" id="line-741"><code>		for _, m := range embedded.methods {</code></span>
<span class="codeline" id="line-742"><code>			// only top-level methods are embedded</code></span>
<span class="codeline" id="line-743"><code>			if m.Level == 0 {</code></span>
<span class="codeline" id="line-744"><code>				mset.add(customizeRecv(m, recvTypeName, thisEmbeddedIsPtr, level))</code></span>
<span class="codeline" id="line-745"><code>			}</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code>		if !visited[embedded] {</code></span>
<span class="codeline" id="line-748"><code>			r.collectEmbeddedMethods(mset, embedded, recvTypeName, thisEmbeddedIsPtr, level+1, visited)</code></span>
<span class="codeline" id="line-749"><code>		}</code></span>
<span class="codeline" id="line-750"><code>	}</code></span>
<span class="codeline" id="line-751"><code>	delete(visited, typ)</code></span>
<span class="codeline" id="line-752"><code>}</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>// computeMethodSets determines the actual method sets for each type encountered.</code></span>
<span class="codeline" id="line-755"><code>func (r *reader) computeMethodSets() {</code></span>
<span class="codeline" id="line-756"><code>	for _, t := range r.types {</code></span>
<span class="codeline" id="line-757"><code>		// collect embedded methods for t</code></span>
<span class="codeline" id="line-758"><code>		if t.isStruct {</code></span>
<span class="codeline" id="line-759"><code>			// struct</code></span>
<span class="codeline" id="line-760"><code>			r.collectEmbeddedMethods(t.methods, t, t.name, false, 1, make(embeddedSet))</code></span>
<span class="codeline" id="line-761"><code>		} else {</code></span>
<span class="codeline" id="line-762"><code>			// interface</code></span>
<span class="codeline" id="line-763"><code>			// TODO(gri) fix this</code></span>
<span class="codeline" id="line-764"><code>		}</code></span>
<span class="codeline" id="line-765"><code>	}</code></span>
<span class="codeline" id="line-766"><code></code></span>
<span class="codeline" id="line-767"><code>	// For any predeclared names that are declared locally, don't treat them as</code></span>
<span class="codeline" id="line-768"><code>	// exported fields anymore.</code></span>
<span class="codeline" id="line-769"><code>	for predecl := range r.shadowedPredecl {</code></span>
<span class="codeline" id="line-770"><code>		for _, ityp := range r.fixmap[predecl] {</code></span>
<span class="codeline" id="line-771"><code>			removeAnonymousField(predecl, ityp)</code></span>
<span class="codeline" id="line-772"><code>		}</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code>}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>// cleanupTypes removes the association of functions and methods with</code></span>
<span class="codeline" id="line-777"><code>// types that have no declaration. Instead, these functions and methods</code></span>
<span class="codeline" id="line-778"><code>// are shown at the package level. It also removes types with missing</code></span>
<span class="codeline" id="line-779"><code>// declarations or which are not visible.</code></span>
<span class="codeline" id="line-780"><code>func (r *reader) cleanupTypes() {</code></span>
<span class="codeline" id="line-781"><code>	for _, t := range r.types {</code></span>
<span class="codeline" id="line-782"><code>		visible := r.isVisible(t.name)</code></span>
<span class="codeline" id="line-783"><code>		predeclared := predeclaredTypes[t.name]</code></span>
<span class="codeline" id="line-784"><code></code></span>
<span class="codeline" id="line-785"><code>		if t.decl == nil &amp;&amp; (predeclared || visible &amp;&amp; (t.isEmbedded || r.hasDotImp)) {</code></span>
<span class="codeline" id="line-786"><code>			// t.name is a predeclared type (and was not redeclared in this package),</code></span>
<span class="codeline" id="line-787"><code>			// or it was embedded somewhere but its declaration is missing (because</code></span>
<span class="codeline" id="line-788"><code>			// the AST is incomplete), or we have a dot-import (and all bets are off):</code></span>
<span class="codeline" id="line-789"><code>			// move any associated values, funcs, and methods back to the top-level so</code></span>
<span class="codeline" id="line-790"><code>			// that they are not lost.</code></span>
<span class="codeline" id="line-791"><code>			// 1) move values</code></span>
<span class="codeline" id="line-792"><code>			r.values = append(r.values, t.values...)</code></span>
<span class="codeline" id="line-793"><code>			// 2) move factory functions</code></span>
<span class="codeline" id="line-794"><code>			for name, f := range t.funcs {</code></span>
<span class="codeline" id="line-795"><code>				// in a correct AST, package-level function names</code></span>
<span class="codeline" id="line-796"><code>				// are all different - no need to check for conflicts</code></span>
<span class="codeline" id="line-797"><code>				r.funcs[name] = f</code></span>
<span class="codeline" id="line-798"><code>			}</code></span>
<span class="codeline" id="line-799"><code>			// 3) move methods</code></span>
<span class="codeline" id="line-800"><code>			if !predeclared {</code></span>
<span class="codeline" id="line-801"><code>				for name, m := range t.methods {</code></span>
<span class="codeline" id="line-802"><code>					// don't overwrite functions with the same name - drop them</code></span>
<span class="codeline" id="line-803"><code>					if _, found := r.funcs[name]; !found {</code></span>
<span class="codeline" id="line-804"><code>						r.funcs[name] = m</code></span>
<span class="codeline" id="line-805"><code>					}</code></span>
<span class="codeline" id="line-806"><code>				}</code></span>
<span class="codeline" id="line-807"><code>			}</code></span>
<span class="codeline" id="line-808"><code>		}</code></span>
<span class="codeline" id="line-809"><code>		// remove types w/o declaration or which are not visible</code></span>
<span class="codeline" id="line-810"><code>		if t.decl == nil || !visible {</code></span>
<span class="codeline" id="line-811"><code>			delete(r.types, t.name)</code></span>
<span class="codeline" id="line-812"><code>		}</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-817"><code>// Sorting</code></span>
<span class="codeline" id="line-818"><code></code></span>
<span class="codeline" id="line-819"><code>type data struct {</code></span>
<span class="codeline" id="line-820"><code>	n    int</code></span>
<span class="codeline" id="line-821"><code>	swap func(i, j int)</code></span>
<span class="codeline" id="line-822"><code>	less func(i, j int) bool</code></span>
<span class="codeline" id="line-823"><code>}</code></span>
<span class="codeline" id="line-824"><code></code></span>
<span class="codeline" id="line-825"><code>func (d *data) Len() int           { return d.n }</code></span>
<span class="codeline" id="line-826"><code>func (d *data) Swap(i, j int)      { d.swap(i, j) }</code></span>
<span class="codeline" id="line-827"><code>func (d *data) Less(i, j int) bool { return d.less(i, j) }</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>// sortBy is a helper function for sorting.</code></span>
<span class="codeline" id="line-830"><code>func sortBy(less func(i, j int) bool, swap func(i, j int), n int) {</code></span>
<span class="codeline" id="line-831"><code>	sort.Sort(&amp;data{n, swap, less})</code></span>
<span class="codeline" id="line-832"><code>}</code></span>
<span class="codeline" id="line-833"><code></code></span>
<span class="codeline" id="line-834"><code>func sortedKeys(m map[string]int) []string {</code></span>
<span class="codeline" id="line-835"><code>	list := make([]string, len(m))</code></span>
<span class="codeline" id="line-836"><code>	i := 0</code></span>
<span class="codeline" id="line-837"><code>	for key := range m {</code></span>
<span class="codeline" id="line-838"><code>		list[i] = key</code></span>
<span class="codeline" id="line-839"><code>		i++</code></span>
<span class="codeline" id="line-840"><code>	}</code></span>
<span class="codeline" id="line-841"><code>	sort.Strings(list)</code></span>
<span class="codeline" id="line-842"><code>	return list</code></span>
<span class="codeline" id="line-843"><code>}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>// sortingName returns the name to use when sorting d into place.</code></span>
<span class="codeline" id="line-846"><code>func sortingName(d *ast.GenDecl) string {</code></span>
<span class="codeline" id="line-847"><code>	if len(d.Specs) == 1 {</code></span>
<span class="codeline" id="line-848"><code>		if s, ok := d.Specs[0].(*ast.ValueSpec); ok {</code></span>
<span class="codeline" id="line-849"><code>			return s.Names[0].Name</code></span>
<span class="codeline" id="line-850"><code>		}</code></span>
<span class="codeline" id="line-851"><code>	}</code></span>
<span class="codeline" id="line-852"><code>	return ""</code></span>
<span class="codeline" id="line-853"><code>}</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>func sortedValues(m []*Value, tok token.Token) []*Value {</code></span>
<span class="codeline" id="line-856"><code>	list := make([]*Value, len(m)) // big enough in any case</code></span>
<span class="codeline" id="line-857"><code>	i := 0</code></span>
<span class="codeline" id="line-858"><code>	for _, val := range m {</code></span>
<span class="codeline" id="line-859"><code>		if val.Decl.Tok == tok {</code></span>
<span class="codeline" id="line-860"><code>			list[i] = val</code></span>
<span class="codeline" id="line-861"><code>			i++</code></span>
<span class="codeline" id="line-862"><code>		}</code></span>
<span class="codeline" id="line-863"><code>	}</code></span>
<span class="codeline" id="line-864"><code>	list = list[0:i]</code></span>
<span class="codeline" id="line-865"><code></code></span>
<span class="codeline" id="line-866"><code>	sortBy(</code></span>
<span class="codeline" id="line-867"><code>		func(i, j int) bool {</code></span>
<span class="codeline" id="line-868"><code>			if ni, nj := sortingName(list[i].Decl), sortingName(list[j].Decl); ni != nj {</code></span>
<span class="codeline" id="line-869"><code>				return ni &lt; nj</code></span>
<span class="codeline" id="line-870"><code>			}</code></span>
<span class="codeline" id="line-871"><code>			return list[i].order &lt; list[j].order</code></span>
<span class="codeline" id="line-872"><code>		},</code></span>
<span class="codeline" id="line-873"><code>		func(i, j int) { list[i], list[j] = list[j], list[i] },</code></span>
<span class="codeline" id="line-874"><code>		len(list),</code></span>
<span class="codeline" id="line-875"><code>	)</code></span>
<span class="codeline" id="line-876"><code></code></span>
<span class="codeline" id="line-877"><code>	return list</code></span>
<span class="codeline" id="line-878"><code>}</code></span>
<span class="codeline" id="line-879"><code></code></span>
<span class="codeline" id="line-880"><code>func sortedTypes(m map[string]*namedType, allMethods bool) []*Type {</code></span>
<span class="codeline" id="line-881"><code>	list := make([]*Type, len(m))</code></span>
<span class="codeline" id="line-882"><code>	i := 0</code></span>
<span class="codeline" id="line-883"><code>	for _, t := range m {</code></span>
<span class="codeline" id="line-884"><code>		list[i] = &amp;Type{</code></span>
<span class="codeline" id="line-885"><code>			Doc:     t.doc,</code></span>
<span class="codeline" id="line-886"><code>			Name:    t.name,</code></span>
<span class="codeline" id="line-887"><code>			Decl:    t.decl,</code></span>
<span class="codeline" id="line-888"><code>			Consts:  sortedValues(t.values, token.CONST),</code></span>
<span class="codeline" id="line-889"><code>			Vars:    sortedValues(t.values, token.VAR),</code></span>
<span class="codeline" id="line-890"><code>			Funcs:   sortedFuncs(t.funcs, true),</code></span>
<span class="codeline" id="line-891"><code>			Methods: sortedFuncs(t.methods, allMethods),</code></span>
<span class="codeline" id="line-892"><code>		}</code></span>
<span class="codeline" id="line-893"><code>		i++</code></span>
<span class="codeline" id="line-894"><code>	}</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>	sortBy(</code></span>
<span class="codeline" id="line-897"><code>		func(i, j int) bool { return list[i].Name &lt; list[j].Name },</code></span>
<span class="codeline" id="line-898"><code>		func(i, j int) { list[i], list[j] = list[j], list[i] },</code></span>
<span class="codeline" id="line-899"><code>		len(list),</code></span>
<span class="codeline" id="line-900"><code>	)</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>	return list</code></span>
<span class="codeline" id="line-903"><code>}</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>func removeStar(s string) string {</code></span>
<span class="codeline" id="line-906"><code>	if len(s) &gt; 0 &amp;&amp; s[0] == '*' {</code></span>
<span class="codeline" id="line-907"><code>		return s[1:]</code></span>
<span class="codeline" id="line-908"><code>	}</code></span>
<span class="codeline" id="line-909"><code>	return s</code></span>
<span class="codeline" id="line-910"><code>}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>func sortedFuncs(m methodSet, allMethods bool) []*Func {</code></span>
<span class="codeline" id="line-913"><code>	list := make([]*Func, len(m))</code></span>
<span class="codeline" id="line-914"><code>	i := 0</code></span>
<span class="codeline" id="line-915"><code>	for _, m := range m {</code></span>
<span class="codeline" id="line-916"><code>		// determine which methods to include</code></span>
<span class="codeline" id="line-917"><code>		switch {</code></span>
<span class="codeline" id="line-918"><code>		case m.Decl == nil:</code></span>
<span class="codeline" id="line-919"><code>			// exclude conflict entry</code></span>
<span class="codeline" id="line-920"><code>		case allMethods, m.Level == 0, !token.IsExported(removeStar(m.Orig)):</code></span>
<span class="codeline" id="line-921"><code>			// forced inclusion, method not embedded, or method</code></span>
<span class="codeline" id="line-922"><code>			// embedded but original receiver type not exported</code></span>
<span class="codeline" id="line-923"><code>			list[i] = m</code></span>
<span class="codeline" id="line-924"><code>			i++</code></span>
<span class="codeline" id="line-925"><code>		}</code></span>
<span class="codeline" id="line-926"><code>	}</code></span>
<span class="codeline" id="line-927"><code>	list = list[0:i]</code></span>
<span class="codeline" id="line-928"><code>	sortBy(</code></span>
<span class="codeline" id="line-929"><code>		func(i, j int) bool { return list[i].Name &lt; list[j].Name },</code></span>
<span class="codeline" id="line-930"><code>		func(i, j int) { list[i], list[j] = list[j], list[i] },</code></span>
<span class="codeline" id="line-931"><code>		len(list),</code></span>
<span class="codeline" id="line-932"><code>	)</code></span>
<span class="codeline" id="line-933"><code>	return list</code></span>
<span class="codeline" id="line-934"><code>}</code></span>
<span class="codeline" id="line-935"><code></code></span>
<span class="codeline" id="line-936"><code>// noteBodies returns a list of note body strings given a list of notes.</code></span>
<span class="codeline" id="line-937"><code>// This is only used to populate the deprecated Package.Bugs field.</code></span>
<span class="codeline" id="line-938"><code>func noteBodies(notes []*Note) []string {</code></span>
<span class="codeline" id="line-939"><code>	var list []string</code></span>
<span class="codeline" id="line-940"><code>	for _, n := range notes {</code></span>
<span class="codeline" id="line-941"><code>		list = append(list, n.Body)</code></span>
<span class="codeline" id="line-942"><code>	}</code></span>
<span class="codeline" id="line-943"><code>	return list</code></span>
<span class="codeline" id="line-944"><code>}</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-947"><code>// Predeclared identifiers</code></span>
<span class="codeline" id="line-948"><code></code></span>
<span class="codeline" id="line-949"><code>// IsPredeclared reports whether s is a predeclared identifier.</code></span>
<span class="codeline" id="line-950"><code>func IsPredeclared(s string) bool {</code></span>
<span class="codeline" id="line-951"><code>	return predeclaredTypes[s] || predeclaredFuncs[s] || predeclaredConstants[s]</code></span>
<span class="codeline" id="line-952"><code>}</code></span>
<span class="codeline" id="line-953"><code></code></span>
<span class="codeline" id="line-954"><code>var predeclaredTypes = map[string]bool{</code></span>
<span class="codeline" id="line-955"><code>	"any":        true,</code></span>
<span class="codeline" id="line-956"><code>	"bool":       true,</code></span>
<span class="codeline" id="line-957"><code>	"byte":       true,</code></span>
<span class="codeline" id="line-958"><code>	"comparable": true,</code></span>
<span class="codeline" id="line-959"><code>	"complex64":  true,</code></span>
<span class="codeline" id="line-960"><code>	"complex128": true,</code></span>
<span class="codeline" id="line-961"><code>	"error":      true,</code></span>
<span class="codeline" id="line-962"><code>	"float32":    true,</code></span>
<span class="codeline" id="line-963"><code>	"float64":    true,</code></span>
<span class="codeline" id="line-964"><code>	"int":        true,</code></span>
<span class="codeline" id="line-965"><code>	"int8":       true,</code></span>
<span class="codeline" id="line-966"><code>	"int16":      true,</code></span>
<span class="codeline" id="line-967"><code>	"int32":      true,</code></span>
<span class="codeline" id="line-968"><code>	"int64":      true,</code></span>
<span class="codeline" id="line-969"><code>	"rune":       true,</code></span>
<span class="codeline" id="line-970"><code>	"string":     true,</code></span>
<span class="codeline" id="line-971"><code>	"uint":       true,</code></span>
<span class="codeline" id="line-972"><code>	"uint8":      true,</code></span>
<span class="codeline" id="line-973"><code>	"uint16":     true,</code></span>
<span class="codeline" id="line-974"><code>	"uint32":     true,</code></span>
<span class="codeline" id="line-975"><code>	"uint64":     true,</code></span>
<span class="codeline" id="line-976"><code>	"uintptr":    true,</code></span>
<span class="codeline" id="line-977"><code>}</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>var predeclaredFuncs = map[string]bool{</code></span>
<span class="codeline" id="line-980"><code>	"append":  true,</code></span>
<span class="codeline" id="line-981"><code>	"cap":     true,</code></span>
<span class="codeline" id="line-982"><code>	"close":   true,</code></span>
<span class="codeline" id="line-983"><code>	"complex": true,</code></span>
<span class="codeline" id="line-984"><code>	"copy":    true,</code></span>
<span class="codeline" id="line-985"><code>	"delete":  true,</code></span>
<span class="codeline" id="line-986"><code>	"imag":    true,</code></span>
<span class="codeline" id="line-987"><code>	"len":     true,</code></span>
<span class="codeline" id="line-988"><code>	"make":    true,</code></span>
<span class="codeline" id="line-989"><code>	"new":     true,</code></span>
<span class="codeline" id="line-990"><code>	"panic":   true,</code></span>
<span class="codeline" id="line-991"><code>	"print":   true,</code></span>
<span class="codeline" id="line-992"><code>	"println": true,</code></span>
<span class="codeline" id="line-993"><code>	"real":    true,</code></span>
<span class="codeline" id="line-994"><code>	"recover": true,</code></span>
<span class="codeline" id="line-995"><code>}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>var predeclaredConstants = map[string]bool{</code></span>
<span class="codeline" id="line-998"><code>	"false": true,</code></span>
<span class="codeline" id="line-999"><code>	"iota":  true,</code></span>
<span class="codeline" id="line-1000"><code>	"nil":   true,</code></span>
<span class="codeline" id="line-1001"><code>	"true":  true,</code></span>
<span class="codeline" id="line-1002"><code>}</code></span>
<span class="codeline" id="line-1003"><code></code></span>
<span class="codeline" id="line-1004"><code>// assumedPackageName returns the assumed package name</code></span>
<span class="codeline" id="line-1005"><code>// for a given import path. This is a copy of</code></span>
<span class="codeline" id="line-1006"><code>// golang.org/x/tools/internal/imports.ImportPathToAssumedName.</code></span>
<span class="codeline" id="line-1007"><code>func assumedPackageName(importPath string) string {</code></span>
<span class="codeline" id="line-1008"><code>	notIdentifier := func(ch rune) bool {</code></span>
<span class="codeline" id="line-1009"><code>		return !('a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' ||</code></span>
<span class="codeline" id="line-1010"><code>			'0' &lt;= ch &amp;&amp; ch &lt;= '9' ||</code></span>
<span class="codeline" id="line-1011"><code>			ch == '_' ||</code></span>
<span class="codeline" id="line-1012"><code>			ch &gt;= utf8.RuneSelf &amp;&amp; (unicode.IsLetter(ch) || unicode.IsDigit(ch)))</code></span>
<span class="codeline" id="line-1013"><code>	}</code></span>
<span class="codeline" id="line-1014"><code></code></span>
<span class="codeline" id="line-1015"><code>	base := path.Base(importPath)</code></span>
<span class="codeline" id="line-1016"><code>	if strings.HasPrefix(base, "v") {</code></span>
<span class="codeline" id="line-1017"><code>		if _, err := strconv.Atoi(base[1:]); err == nil {</code></span>
<span class="codeline" id="line-1018"><code>			dir := path.Dir(importPath)</code></span>
<span class="codeline" id="line-1019"><code>			if dir != "." {</code></span>
<span class="codeline" id="line-1020"><code>				base = path.Base(dir)</code></span>
<span class="codeline" id="line-1021"><code>			}</code></span>
<span class="codeline" id="line-1022"><code>		}</code></span>
<span class="codeline" id="line-1023"><code>	}</code></span>
<span class="codeline" id="line-1024"><code>	base = strings.TrimPrefix(base, "go-")</code></span>
<span class="codeline" id="line-1025"><code>	if i := strings.IndexFunc(base, notIdentifier); i &gt;= 0 {</code></span>
<span class="codeline" id="line-1026"><code>		base = base[:i]</code></span>
<span class="codeline" id="line-1027"><code>	}</code></span>
<span class="codeline" id="line-1028"><code>	return base</code></span>
<span class="codeline" id="line-1029"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>