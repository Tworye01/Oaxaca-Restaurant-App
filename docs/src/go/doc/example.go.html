<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: example.go in package go/doc</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	example.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/doc.html">go/doc</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Extract example functions from file ASTs.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package doc</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"go/ast"</code></span>
<span class="codeline" id="line-11"><code>	"go/token"</code></span>
<span class="codeline" id="line-12"><code>	"internal/lazyregexp"</code></span>
<span class="codeline" id="line-13"><code>	"path"</code></span>
<span class="codeline" id="line-14"><code>	"sort"</code></span>
<span class="codeline" id="line-15"><code>	"strconv"</code></span>
<span class="codeline" id="line-16"><code>	"strings"</code></span>
<span class="codeline" id="line-17"><code>	"unicode"</code></span>
<span class="codeline" id="line-18"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-19"><code>)</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>// An Example represents an example function found in a test source file.</code></span>
<span class="codeline" id="line-22"><code>type Example struct {</code></span>
<span class="codeline" id="line-23"><code>	Name        string // name of the item being exemplified (including optional suffix)</code></span>
<span class="codeline" id="line-24"><code>	Suffix      string // example suffix, without leading '_' (only populated by NewFromFiles)</code></span>
<span class="codeline" id="line-25"><code>	Doc         string // example function doc string</code></span>
<span class="codeline" id="line-26"><code>	Code        ast.Node</code></span>
<span class="codeline" id="line-27"><code>	Play        *ast.File // a whole program version of the example</code></span>
<span class="codeline" id="line-28"><code>	Comments    []*ast.CommentGroup</code></span>
<span class="codeline" id="line-29"><code>	Output      string // expected output</code></span>
<span class="codeline" id="line-30"><code>	Unordered   bool</code></span>
<span class="codeline" id="line-31"><code>	EmptyOutput bool // expect empty output</code></span>
<span class="codeline" id="line-32"><code>	Order       int  // original source code order</code></span>
<span class="codeline" id="line-33"><code>}</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>// Examples returns the examples found in testFiles, sorted by Name field.</code></span>
<span class="codeline" id="line-36"><code>// The Order fields record the order in which the examples were encountered.</code></span>
<span class="codeline" id="line-37"><code>// The Suffix field is not populated when Examples is called directly, it is</code></span>
<span class="codeline" id="line-38"><code>// only populated by [NewFromFiles] for examples it finds in _test.go files.</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// Playable Examples must be in a package whose name ends in "_test".</code></span>
<span class="codeline" id="line-41"><code>// An Example is "playable" (the Play field is non-nil) in either of these</code></span>
<span class="codeline" id="line-42"><code>// circumstances:</code></span>
<span class="codeline" id="line-43"><code>//   - The example function is self-contained: the function references only</code></span>
<span class="codeline" id="line-44"><code>//     identifiers from other packages (or predeclared identifiers, such as</code></span>
<span class="codeline" id="line-45"><code>//     "int") and the test file does not include a dot import.</code></span>
<span class="codeline" id="line-46"><code>//   - The entire test file is the example: the file contains exactly one</code></span>
<span class="codeline" id="line-47"><code>//     example function, zero test, fuzz test, or benchmark function, and at</code></span>
<span class="codeline" id="line-48"><code>//     least one top-level function, type, variable, or constant declaration</code></span>
<span class="codeline" id="line-49"><code>//     other than the example function.</code></span>
<span class="codeline" id="line-50"><code>func Examples(testFiles ...*ast.File) []*Example {</code></span>
<span class="codeline" id="line-51"><code>	var list []*Example</code></span>
<span class="codeline" id="line-52"><code>	for _, file := range testFiles {</code></span>
<span class="codeline" id="line-53"><code>		hasTests := false // file contains tests, fuzz test, or benchmarks</code></span>
<span class="codeline" id="line-54"><code>		numDecl := 0      // number of non-import declarations in the file</code></span>
<span class="codeline" id="line-55"><code>		var flist []*Example</code></span>
<span class="codeline" id="line-56"><code>		for _, decl := range file.Decls {</code></span>
<span class="codeline" id="line-57"><code>			if g, ok := decl.(*ast.GenDecl); ok &amp;&amp; g.Tok != token.IMPORT {</code></span>
<span class="codeline" id="line-58"><code>				numDecl++</code></span>
<span class="codeline" id="line-59"><code>				continue</code></span>
<span class="codeline" id="line-60"><code>			}</code></span>
<span class="codeline" id="line-61"><code>			f, ok := decl.(*ast.FuncDecl)</code></span>
<span class="codeline" id="line-62"><code>			if !ok || f.Recv != nil {</code></span>
<span class="codeline" id="line-63"><code>				continue</code></span>
<span class="codeline" id="line-64"><code>			}</code></span>
<span class="codeline" id="line-65"><code>			numDecl++</code></span>
<span class="codeline" id="line-66"><code>			name := f.Name.Name</code></span>
<span class="codeline" id="line-67"><code>			if isTest(name, "Test") || isTest(name, "Benchmark") || isTest(name, "Fuzz") {</code></span>
<span class="codeline" id="line-68"><code>				hasTests = true</code></span>
<span class="codeline" id="line-69"><code>				continue</code></span>
<span class="codeline" id="line-70"><code>			}</code></span>
<span class="codeline" id="line-71"><code>			if !isTest(name, "Example") {</code></span>
<span class="codeline" id="line-72"><code>				continue</code></span>
<span class="codeline" id="line-73"><code>			}</code></span>
<span class="codeline" id="line-74"><code>			if params := f.Type.Params; len(params.List) != 0 {</code></span>
<span class="codeline" id="line-75"><code>				continue // function has params; not a valid example</code></span>
<span class="codeline" id="line-76"><code>			}</code></span>
<span class="codeline" id="line-77"><code>			if f.Body == nil { // ast.File.Body nil dereference (see issue 28044)</code></span>
<span class="codeline" id="line-78"><code>				continue</code></span>
<span class="codeline" id="line-79"><code>			}</code></span>
<span class="codeline" id="line-80"><code>			var doc string</code></span>
<span class="codeline" id="line-81"><code>			if f.Doc != nil {</code></span>
<span class="codeline" id="line-82"><code>				doc = f.Doc.Text()</code></span>
<span class="codeline" id="line-83"><code>			}</code></span>
<span class="codeline" id="line-84"><code>			output, unordered, hasOutput := exampleOutput(f.Body, file.Comments)</code></span>
<span class="codeline" id="line-85"><code>			flist = append(flist, &amp;Example{</code></span>
<span class="codeline" id="line-86"><code>				Name:        name[len("Example"):],</code></span>
<span class="codeline" id="line-87"><code>				Doc:         doc,</code></span>
<span class="codeline" id="line-88"><code>				Code:        f.Body,</code></span>
<span class="codeline" id="line-89"><code>				Play:        playExample(file, f),</code></span>
<span class="codeline" id="line-90"><code>				Comments:    file.Comments,</code></span>
<span class="codeline" id="line-91"><code>				Output:      output,</code></span>
<span class="codeline" id="line-92"><code>				Unordered:   unordered,</code></span>
<span class="codeline" id="line-93"><code>				EmptyOutput: output == "" &amp;&amp; hasOutput,</code></span>
<span class="codeline" id="line-94"><code>				Order:       len(flist),</code></span>
<span class="codeline" id="line-95"><code>			})</code></span>
<span class="codeline" id="line-96"><code>		}</code></span>
<span class="codeline" id="line-97"><code>		if !hasTests &amp;&amp; numDecl &gt; 1 &amp;&amp; len(flist) == 1 {</code></span>
<span class="codeline" id="line-98"><code>			// If this file only has one example function, some</code></span>
<span class="codeline" id="line-99"><code>			// other top-level declarations, and no tests or</code></span>
<span class="codeline" id="line-100"><code>			// benchmarks, use the whole file as the example.</code></span>
<span class="codeline" id="line-101"><code>			flist[0].Code = file</code></span>
<span class="codeline" id="line-102"><code>			flist[0].Play = playExampleFile(file)</code></span>
<span class="codeline" id="line-103"><code>		}</code></span>
<span class="codeline" id="line-104"><code>		list = append(list, flist...)</code></span>
<span class="codeline" id="line-105"><code>	}</code></span>
<span class="codeline" id="line-106"><code>	// sort by name</code></span>
<span class="codeline" id="line-107"><code>	sort.Slice(list, func(i, j int) bool {</code></span>
<span class="codeline" id="line-108"><code>		return list[i].Name &lt; list[j].Name</code></span>
<span class="codeline" id="line-109"><code>	})</code></span>
<span class="codeline" id="line-110"><code>	return list</code></span>
<span class="codeline" id="line-111"><code>}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>var outputPrefix = lazyregexp.New(`(?i)^[[:space:]]*(unordered )?output:`)</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// Extracts the expected output and whether there was a valid output comment.</code></span>
<span class="codeline" id="line-116"><code>func exampleOutput(b *ast.BlockStmt, comments []*ast.CommentGroup) (output string, unordered, ok bool) {</code></span>
<span class="codeline" id="line-117"><code>	if _, last := lastComment(b, comments); last != nil {</code></span>
<span class="codeline" id="line-118"><code>		// test that it begins with the correct prefix</code></span>
<span class="codeline" id="line-119"><code>		text := last.Text()</code></span>
<span class="codeline" id="line-120"><code>		if loc := outputPrefix.FindStringSubmatchIndex(text); loc != nil {</code></span>
<span class="codeline" id="line-121"><code>			if loc[2] != -1 {</code></span>
<span class="codeline" id="line-122"><code>				unordered = true</code></span>
<span class="codeline" id="line-123"><code>			}</code></span>
<span class="codeline" id="line-124"><code>			text = text[loc[1]:]</code></span>
<span class="codeline" id="line-125"><code>			// Strip zero or more spaces followed by \n or a single space.</code></span>
<span class="codeline" id="line-126"><code>			text = strings.TrimLeft(text, " ")</code></span>
<span class="codeline" id="line-127"><code>			if len(text) &gt; 0 &amp;&amp; text[0] == '\n' {</code></span>
<span class="codeline" id="line-128"><code>				text = text[1:]</code></span>
<span class="codeline" id="line-129"><code>			}</code></span>
<span class="codeline" id="line-130"><code>			return text, unordered, true</code></span>
<span class="codeline" id="line-131"><code>		}</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	return "", false, false // no suitable comment found</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// isTest tells whether name looks like a test, example, fuzz test, or</code></span>
<span class="codeline" id="line-137"><code>// benchmark. It is a Test (say) if there is a character after Test that is not</code></span>
<span class="codeline" id="line-138"><code>// a lower-case letter. (We don't want Testiness.)</code></span>
<span class="codeline" id="line-139"><code>func isTest(name, prefix string) bool {</code></span>
<span class="codeline" id="line-140"><code>	if !strings.HasPrefix(name, prefix) {</code></span>
<span class="codeline" id="line-141"><code>		return false</code></span>
<span class="codeline" id="line-142"><code>	}</code></span>
<span class="codeline" id="line-143"><code>	if len(name) == len(prefix) { // "Test" is ok</code></span>
<span class="codeline" id="line-144"><code>		return true</code></span>
<span class="codeline" id="line-145"><code>	}</code></span>
<span class="codeline" id="line-146"><code>	rune, _ := utf8.DecodeRuneInString(name[len(prefix):])</code></span>
<span class="codeline" id="line-147"><code>	return !unicode.IsLower(rune)</code></span>
<span class="codeline" id="line-148"><code>}</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>// playExample synthesizes a new *ast.File based on the provided</code></span>
<span class="codeline" id="line-151"><code>// file with the provided function body as the body of main.</code></span>
<span class="codeline" id="line-152"><code>func playExample(file *ast.File, f *ast.FuncDecl) *ast.File {</code></span>
<span class="codeline" id="line-153"><code>	body := f.Body</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	if !strings.HasSuffix(file.Name.Name, "_test") {</code></span>
<span class="codeline" id="line-156"><code>		// We don't support examples that are part of the</code></span>
<span class="codeline" id="line-157"><code>		// greater package (yet).</code></span>
<span class="codeline" id="line-158"><code>		return nil</code></span>
<span class="codeline" id="line-159"><code>	}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	// Collect top-level declarations in the file.</code></span>
<span class="codeline" id="line-162"><code>	topDecls := make(map[*ast.Object]ast.Decl)</code></span>
<span class="codeline" id="line-163"><code>	typMethods := make(map[string][]ast.Decl)</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>	for _, decl := range file.Decls {</code></span>
<span class="codeline" id="line-166"><code>		switch d := decl.(type) {</code></span>
<span class="codeline" id="line-167"><code>		case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-168"><code>			if d.Recv == nil {</code></span>
<span class="codeline" id="line-169"><code>				topDecls[d.Name.Obj] = d</code></span>
<span class="codeline" id="line-170"><code>			} else {</code></span>
<span class="codeline" id="line-171"><code>				if len(d.Recv.List) == 1 {</code></span>
<span class="codeline" id="line-172"><code>					t := d.Recv.List[0].Type</code></span>
<span class="codeline" id="line-173"><code>					tname, _ := baseTypeName(t)</code></span>
<span class="codeline" id="line-174"><code>					typMethods[tname] = append(typMethods[tname], d)</code></span>
<span class="codeline" id="line-175"><code>				}</code></span>
<span class="codeline" id="line-176"><code>			}</code></span>
<span class="codeline" id="line-177"><code>		case *ast.GenDecl:</code></span>
<span class="codeline" id="line-178"><code>			for _, spec := range d.Specs {</code></span>
<span class="codeline" id="line-179"><code>				switch s := spec.(type) {</code></span>
<span class="codeline" id="line-180"><code>				case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-181"><code>					topDecls[s.Name.Obj] = d</code></span>
<span class="codeline" id="line-182"><code>				case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-183"><code>					for _, name := range s.Names {</code></span>
<span class="codeline" id="line-184"><code>						topDecls[name.Obj] = d</code></span>
<span class="codeline" id="line-185"><code>					}</code></span>
<span class="codeline" id="line-186"><code>				}</code></span>
<span class="codeline" id="line-187"><code>			}</code></span>
<span class="codeline" id="line-188"><code>		}</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>	// Find unresolved identifiers and uses of top-level declarations.</code></span>
<span class="codeline" id="line-192"><code>	depDecls, unresolved := findDeclsAndUnresolved(body, topDecls, typMethods)</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>	// Remove predeclared identifiers from unresolved list.</code></span>
<span class="codeline" id="line-195"><code>	for n := range unresolved {</code></span>
<span class="codeline" id="line-196"><code>		if predeclaredTypes[n] || predeclaredConstants[n] || predeclaredFuncs[n] {</code></span>
<span class="codeline" id="line-197"><code>			delete(unresolved, n)</code></span>
<span class="codeline" id="line-198"><code>		}</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>	// Use unresolved identifiers to determine the imports used by this</code></span>
<span class="codeline" id="line-202"><code>	// example. The heuristic assumes package names match base import</code></span>
<span class="codeline" id="line-203"><code>	// paths for imports w/o renames (should be good enough most of the time).</code></span>
<span class="codeline" id="line-204"><code>	var namedImports []ast.Spec</code></span>
<span class="codeline" id="line-205"><code>	var blankImports []ast.Spec // _ imports</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>	// To preserve the blank lines between groups of imports, find the</code></span>
<span class="codeline" id="line-208"><code>	// start position of each group, and assign that position to all</code></span>
<span class="codeline" id="line-209"><code>	// imports from that group.</code></span>
<span class="codeline" id="line-210"><code>	groupStarts := findImportGroupStarts(file.Imports)</code></span>
<span class="codeline" id="line-211"><code>	groupStart := func(s *ast.ImportSpec) token.Pos {</code></span>
<span class="codeline" id="line-212"><code>		for i, start := range groupStarts {</code></span>
<span class="codeline" id="line-213"><code>			if s.Path.ValuePos &lt; start {</code></span>
<span class="codeline" id="line-214"><code>				return groupStarts[i-1]</code></span>
<span class="codeline" id="line-215"><code>			}</code></span>
<span class="codeline" id="line-216"><code>		}</code></span>
<span class="codeline" id="line-217"><code>		return groupStarts[len(groupStarts)-1]</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>	for _, s := range file.Imports {</code></span>
<span class="codeline" id="line-221"><code>		p, err := strconv.Unquote(s.Path.Value)</code></span>
<span class="codeline" id="line-222"><code>		if err != nil {</code></span>
<span class="codeline" id="line-223"><code>			continue</code></span>
<span class="codeline" id="line-224"><code>		}</code></span>
<span class="codeline" id="line-225"><code>		if p == "syscall/js" {</code></span>
<span class="codeline" id="line-226"><code>			// We don't support examples that import syscall/js,</code></span>
<span class="codeline" id="line-227"><code>			// because the package syscall/js is not available in the playground.</code></span>
<span class="codeline" id="line-228"><code>			return nil</code></span>
<span class="codeline" id="line-229"><code>		}</code></span>
<span class="codeline" id="line-230"><code>		n := path.Base(p)</code></span>
<span class="codeline" id="line-231"><code>		if s.Name != nil {</code></span>
<span class="codeline" id="line-232"><code>			n = s.Name.Name</code></span>
<span class="codeline" id="line-233"><code>			switch n {</code></span>
<span class="codeline" id="line-234"><code>			case "_":</code></span>
<span class="codeline" id="line-235"><code>				blankImports = append(blankImports, s)</code></span>
<span class="codeline" id="line-236"><code>				continue</code></span>
<span class="codeline" id="line-237"><code>			case ".":</code></span>
<span class="codeline" id="line-238"><code>				// We can't resolve dot imports (yet).</code></span>
<span class="codeline" id="line-239"><code>				return nil</code></span>
<span class="codeline" id="line-240"><code>			}</code></span>
<span class="codeline" id="line-241"><code>		}</code></span>
<span class="codeline" id="line-242"><code>		if unresolved[n] {</code></span>
<span class="codeline" id="line-243"><code>			// Copy the spec and its path to avoid modifying the original.</code></span>
<span class="codeline" id="line-244"><code>			spec := *s</code></span>
<span class="codeline" id="line-245"><code>			path := *s.Path</code></span>
<span class="codeline" id="line-246"><code>			spec.Path = &amp;path</code></span>
<span class="codeline" id="line-247"><code>			spec.Path.ValuePos = groupStart(&amp;spec)</code></span>
<span class="codeline" id="line-248"><code>			namedImports = append(namedImports, &amp;spec)</code></span>
<span class="codeline" id="line-249"><code>			delete(unresolved, n)</code></span>
<span class="codeline" id="line-250"><code>		}</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>	// If there are other unresolved identifiers, give up because this</code></span>
<span class="codeline" id="line-254"><code>	// synthesized file is not going to build.</code></span>
<span class="codeline" id="line-255"><code>	if len(unresolved) &gt; 0 {</code></span>
<span class="codeline" id="line-256"><code>		return nil</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>	// Include documentation belonging to blank imports.</code></span>
<span class="codeline" id="line-260"><code>	var comments []*ast.CommentGroup</code></span>
<span class="codeline" id="line-261"><code>	for _, s := range blankImports {</code></span>
<span class="codeline" id="line-262"><code>		if c := s.(*ast.ImportSpec).Doc; c != nil {</code></span>
<span class="codeline" id="line-263"><code>			comments = append(comments, c)</code></span>
<span class="codeline" id="line-264"><code>		}</code></span>
<span class="codeline" id="line-265"><code>	}</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>	// Include comments that are inside the function body.</code></span>
<span class="codeline" id="line-268"><code>	for _, c := range file.Comments {</code></span>
<span class="codeline" id="line-269"><code>		if body.Pos() &lt;= c.Pos() &amp;&amp; c.End() &lt;= body.End() {</code></span>
<span class="codeline" id="line-270"><code>			comments = append(comments, c)</code></span>
<span class="codeline" id="line-271"><code>		}</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>	// Strip the "Output:" or "Unordered output:" comment and adjust body</code></span>
<span class="codeline" id="line-275"><code>	// end position.</code></span>
<span class="codeline" id="line-276"><code>	body, comments = stripOutputComment(body, comments)</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>	// Include documentation belonging to dependent declarations.</code></span>
<span class="codeline" id="line-279"><code>	for _, d := range depDecls {</code></span>
<span class="codeline" id="line-280"><code>		switch d := d.(type) {</code></span>
<span class="codeline" id="line-281"><code>		case *ast.GenDecl:</code></span>
<span class="codeline" id="line-282"><code>			if d.Doc != nil {</code></span>
<span class="codeline" id="line-283"><code>				comments = append(comments, d.Doc)</code></span>
<span class="codeline" id="line-284"><code>			}</code></span>
<span class="codeline" id="line-285"><code>		case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-286"><code>			if d.Doc != nil {</code></span>
<span class="codeline" id="line-287"><code>				comments = append(comments, d.Doc)</code></span>
<span class="codeline" id="line-288"><code>			}</code></span>
<span class="codeline" id="line-289"><code>		}</code></span>
<span class="codeline" id="line-290"><code>	}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>	// Synthesize import declaration.</code></span>
<span class="codeline" id="line-293"><code>	importDecl := &amp;ast.GenDecl{</code></span>
<span class="codeline" id="line-294"><code>		Tok:    token.IMPORT,</code></span>
<span class="codeline" id="line-295"><code>		Lparen: 1, // Need non-zero Lparen and Rparen so that printer</code></span>
<span class="codeline" id="line-296"><code>		Rparen: 1, // treats this as a factored import.</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>	importDecl.Specs = append(namedImports, blankImports...)</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>	// Synthesize main function.</code></span>
<span class="codeline" id="line-301"><code>	funcDecl := &amp;ast.FuncDecl{</code></span>
<span class="codeline" id="line-302"><code>		Name: ast.NewIdent("main"),</code></span>
<span class="codeline" id="line-303"><code>		Type: f.Type,</code></span>
<span class="codeline" id="line-304"><code>		Body: body,</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>	decls := make([]ast.Decl, 0, 2+len(depDecls))</code></span>
<span class="codeline" id="line-308"><code>	decls = append(decls, importDecl)</code></span>
<span class="codeline" id="line-309"><code>	decls = append(decls, depDecls...)</code></span>
<span class="codeline" id="line-310"><code>	decls = append(decls, funcDecl)</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>	sort.Slice(decls, func(i, j int) bool {</code></span>
<span class="codeline" id="line-313"><code>		return decls[i].Pos() &lt; decls[j].Pos()</code></span>
<span class="codeline" id="line-314"><code>	})</code></span>
<span class="codeline" id="line-315"><code>	sort.Slice(comments, func(i, j int) bool {</code></span>
<span class="codeline" id="line-316"><code>		return comments[i].Pos() &lt; comments[j].Pos()</code></span>
<span class="codeline" id="line-317"><code>	})</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>	// Synthesize file.</code></span>
<span class="codeline" id="line-320"><code>	return &amp;ast.File{</code></span>
<span class="codeline" id="line-321"><code>		Name:     ast.NewIdent("main"),</code></span>
<span class="codeline" id="line-322"><code>		Decls:    decls,</code></span>
<span class="codeline" id="line-323"><code>		Comments: comments,</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code>}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>// findDeclsAndUnresolved returns all the top-level declarations mentioned in</code></span>
<span class="codeline" id="line-328"><code>// the body, and a set of unresolved symbols (those that appear in the body but</code></span>
<span class="codeline" id="line-329"><code>// have no declaration in the program).</code></span>
<span class="codeline" id="line-330"><code>//</code></span>
<span class="codeline" id="line-331"><code>// topDecls maps objects to the top-level declaration declaring them (not</code></span>
<span class="codeline" id="line-332"><code>// necessarily obj.Decl, as obj.Decl will be a Spec for GenDecls, but</code></span>
<span class="codeline" id="line-333"><code>// topDecls[obj] will be the GenDecl itself).</code></span>
<span class="codeline" id="line-334"><code>func findDeclsAndUnresolved(body ast.Node, topDecls map[*ast.Object]ast.Decl, typMethods map[string][]ast.Decl) ([]ast.Decl, map[string]bool) {</code></span>
<span class="codeline" id="line-335"><code>	// This function recursively finds every top-level declaration used</code></span>
<span class="codeline" id="line-336"><code>	// transitively by the body, populating usedDecls and usedObjs. Then it</code></span>
<span class="codeline" id="line-337"><code>	// trims down the declarations to include only the symbols actually</code></span>
<span class="codeline" id="line-338"><code>	// referenced by the body.</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>	unresolved := make(map[string]bool)</code></span>
<span class="codeline" id="line-341"><code>	var depDecls []ast.Decl</code></span>
<span class="codeline" id="line-342"><code>	usedDecls := make(map[ast.Decl]bool)   // set of top-level decls reachable from the body</code></span>
<span class="codeline" id="line-343"><code>	usedObjs := make(map[*ast.Object]bool) // set of objects reachable from the body (each declared by a usedDecl)</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>	var inspectFunc func(ast.Node) bool</code></span>
<span class="codeline" id="line-346"><code>	inspectFunc = func(n ast.Node) bool {</code></span>
<span class="codeline" id="line-347"><code>		switch e := n.(type) {</code></span>
<span class="codeline" id="line-348"><code>		case *ast.Ident:</code></span>
<span class="codeline" id="line-349"><code>			if e.Obj == nil &amp;&amp; e.Name != "_" {</code></span>
<span class="codeline" id="line-350"><code>				unresolved[e.Name] = true</code></span>
<span class="codeline" id="line-351"><code>			} else if d := topDecls[e.Obj]; d != nil {</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>				usedObjs[e.Obj] = true</code></span>
<span class="codeline" id="line-354"><code>				if !usedDecls[d] {</code></span>
<span class="codeline" id="line-355"><code>					usedDecls[d] = true</code></span>
<span class="codeline" id="line-356"><code>					depDecls = append(depDecls, d)</code></span>
<span class="codeline" id="line-357"><code>				}</code></span>
<span class="codeline" id="line-358"><code>			}</code></span>
<span class="codeline" id="line-359"><code>			return true</code></span>
<span class="codeline" id="line-360"><code>		case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-361"><code>			// For selector expressions, only inspect the left hand side.</code></span>
<span class="codeline" id="line-362"><code>			// (For an expression like fmt.Println, only add "fmt" to the</code></span>
<span class="codeline" id="line-363"><code>			// set of unresolved names, not "Println".)</code></span>
<span class="codeline" id="line-364"><code>			ast.Inspect(e.X, inspectFunc)</code></span>
<span class="codeline" id="line-365"><code>			return false</code></span>
<span class="codeline" id="line-366"><code>		case *ast.KeyValueExpr:</code></span>
<span class="codeline" id="line-367"><code>			// For key value expressions, only inspect the value</code></span>
<span class="codeline" id="line-368"><code>			// as the key should be resolved by the type of the</code></span>
<span class="codeline" id="line-369"><code>			// composite literal.</code></span>
<span class="codeline" id="line-370"><code>			ast.Inspect(e.Value, inspectFunc)</code></span>
<span class="codeline" id="line-371"><code>			return false</code></span>
<span class="codeline" id="line-372"><code>		}</code></span>
<span class="codeline" id="line-373"><code>		return true</code></span>
<span class="codeline" id="line-374"><code>	}</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>	inspectFieldList := func(fl *ast.FieldList) {</code></span>
<span class="codeline" id="line-377"><code>		if fl != nil {</code></span>
<span class="codeline" id="line-378"><code>			for _, f := range fl.List {</code></span>
<span class="codeline" id="line-379"><code>				ast.Inspect(f.Type, inspectFunc)</code></span>
<span class="codeline" id="line-380"><code>			}</code></span>
<span class="codeline" id="line-381"><code>		}</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	// Find the decls immediately referenced by body.</code></span>
<span class="codeline" id="line-385"><code>	ast.Inspect(body, inspectFunc)</code></span>
<span class="codeline" id="line-386"><code>	// Now loop over them, adding to the list when we find a new decl that the</code></span>
<span class="codeline" id="line-387"><code>	// body depends on. Keep going until we don't find anything new.</code></span>
<span class="codeline" id="line-388"><code>	for i := 0; i &lt; len(depDecls); i++ {</code></span>
<span class="codeline" id="line-389"><code>		switch d := depDecls[i].(type) {</code></span>
<span class="codeline" id="line-390"><code>		case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-391"><code>			// Inpect type parameters.</code></span>
<span class="codeline" id="line-392"><code>			inspectFieldList(d.Type.TypeParams)</code></span>
<span class="codeline" id="line-393"><code>			// Inspect types of parameters and results. See #28492.</code></span>
<span class="codeline" id="line-394"><code>			inspectFieldList(d.Type.Params)</code></span>
<span class="codeline" id="line-395"><code>			inspectFieldList(d.Type.Results)</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>			// Functions might not have a body. See #42706.</code></span>
<span class="codeline" id="line-398"><code>			if d.Body != nil {</code></span>
<span class="codeline" id="line-399"><code>				ast.Inspect(d.Body, inspectFunc)</code></span>
<span class="codeline" id="line-400"><code>			}</code></span>
<span class="codeline" id="line-401"><code>		case *ast.GenDecl:</code></span>
<span class="codeline" id="line-402"><code>			for _, spec := range d.Specs {</code></span>
<span class="codeline" id="line-403"><code>				switch s := spec.(type) {</code></span>
<span class="codeline" id="line-404"><code>				case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-405"><code>					inspectFieldList(s.TypeParams)</code></span>
<span class="codeline" id="line-406"><code>					ast.Inspect(s.Type, inspectFunc)</code></span>
<span class="codeline" id="line-407"><code>					depDecls = append(depDecls, typMethods[s.Name.Name]...)</code></span>
<span class="codeline" id="line-408"><code>				case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-409"><code>					if s.Type != nil {</code></span>
<span class="codeline" id="line-410"><code>						ast.Inspect(s.Type, inspectFunc)</code></span>
<span class="codeline" id="line-411"><code>					}</code></span>
<span class="codeline" id="line-412"><code>					for _, val := range s.Values {</code></span>
<span class="codeline" id="line-413"><code>						ast.Inspect(val, inspectFunc)</code></span>
<span class="codeline" id="line-414"><code>					}</code></span>
<span class="codeline" id="line-415"><code>				}</code></span>
<span class="codeline" id="line-416"><code>			}</code></span>
<span class="codeline" id="line-417"><code>		}</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	// Some decls include multiple specs, such as a variable declaration with</code></span>
<span class="codeline" id="line-421"><code>	// multiple variables on the same line, or a parenthesized declaration. Trim</code></span>
<span class="codeline" id="line-422"><code>	// the declarations to include only the specs that are actually mentioned.</code></span>
<span class="codeline" id="line-423"><code>	// However, if there is a constant group with iota, leave it all: later</code></span>
<span class="codeline" id="line-424"><code>	// constant declarations in the group may have no value and so cannot stand</code></span>
<span class="codeline" id="line-425"><code>	// on their own, and removing any constant from the group could change the</code></span>
<span class="codeline" id="line-426"><code>	// values of subsequent ones.</code></span>
<span class="codeline" id="line-427"><code>	// See testdata/examples/iota.go for a minimal example.</code></span>
<span class="codeline" id="line-428"><code>	var ds []ast.Decl</code></span>
<span class="codeline" id="line-429"><code>	for _, d := range depDecls {</code></span>
<span class="codeline" id="line-430"><code>		switch d := d.(type) {</code></span>
<span class="codeline" id="line-431"><code>		case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-432"><code>			ds = append(ds, d)</code></span>
<span class="codeline" id="line-433"><code>		case *ast.GenDecl:</code></span>
<span class="codeline" id="line-434"><code>			containsIota := false // does any spec have iota?</code></span>
<span class="codeline" id="line-435"><code>			// Collect all Specs that were mentioned in the example.</code></span>
<span class="codeline" id="line-436"><code>			var specs []ast.Spec</code></span>
<span class="codeline" id="line-437"><code>			for _, s := range d.Specs {</code></span>
<span class="codeline" id="line-438"><code>				switch s := s.(type) {</code></span>
<span class="codeline" id="line-439"><code>				case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-440"><code>					if usedObjs[s.Name.Obj] {</code></span>
<span class="codeline" id="line-441"><code>						specs = append(specs, s)</code></span>
<span class="codeline" id="line-442"><code>					}</code></span>
<span class="codeline" id="line-443"><code>				case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-444"><code>					if !containsIota {</code></span>
<span class="codeline" id="line-445"><code>						containsIota = hasIota(s)</code></span>
<span class="codeline" id="line-446"><code>					}</code></span>
<span class="codeline" id="line-447"><code>					// A ValueSpec may have multiple names (e.g. "var a, b int").</code></span>
<span class="codeline" id="line-448"><code>					// Keep only the names that were mentioned in the example.</code></span>
<span class="codeline" id="line-449"><code>					// Exception: the multiple names have a single initializer (which</code></span>
<span class="codeline" id="line-450"><code>					// would be a function call with multiple return values). In that</code></span>
<span class="codeline" id="line-451"><code>					// case, keep everything.</code></span>
<span class="codeline" id="line-452"><code>					if len(s.Names) &gt; 1 &amp;&amp; len(s.Values) == 1 {</code></span>
<span class="codeline" id="line-453"><code>						specs = append(specs, s)</code></span>
<span class="codeline" id="line-454"><code>						continue</code></span>
<span class="codeline" id="line-455"><code>					}</code></span>
<span class="codeline" id="line-456"><code>					ns := *s</code></span>
<span class="codeline" id="line-457"><code>					ns.Names = nil</code></span>
<span class="codeline" id="line-458"><code>					ns.Values = nil</code></span>
<span class="codeline" id="line-459"><code>					for i, n := range s.Names {</code></span>
<span class="codeline" id="line-460"><code>						if usedObjs[n.Obj] {</code></span>
<span class="codeline" id="line-461"><code>							ns.Names = append(ns.Names, n)</code></span>
<span class="codeline" id="line-462"><code>							if s.Values != nil {</code></span>
<span class="codeline" id="line-463"><code>								ns.Values = append(ns.Values, s.Values[i])</code></span>
<span class="codeline" id="line-464"><code>							}</code></span>
<span class="codeline" id="line-465"><code>						}</code></span>
<span class="codeline" id="line-466"><code>					}</code></span>
<span class="codeline" id="line-467"><code>					if len(ns.Names) &gt; 0 {</code></span>
<span class="codeline" id="line-468"><code>						specs = append(specs, &amp;ns)</code></span>
<span class="codeline" id="line-469"><code>					}</code></span>
<span class="codeline" id="line-470"><code>				}</code></span>
<span class="codeline" id="line-471"><code>			}</code></span>
<span class="codeline" id="line-472"><code>			if len(specs) &gt; 0 {</code></span>
<span class="codeline" id="line-473"><code>				// Constant with iota? Keep it all.</code></span>
<span class="codeline" id="line-474"><code>				if d.Tok == token.CONST &amp;&amp; containsIota {</code></span>
<span class="codeline" id="line-475"><code>					ds = append(ds, d)</code></span>
<span class="codeline" id="line-476"><code>				} else {</code></span>
<span class="codeline" id="line-477"><code>					// Synthesize a GenDecl with just the Specs we need.</code></span>
<span class="codeline" id="line-478"><code>					nd := *d // copy the GenDecl</code></span>
<span class="codeline" id="line-479"><code>					nd.Specs = specs</code></span>
<span class="codeline" id="line-480"><code>					if len(specs) == 1 {</code></span>
<span class="codeline" id="line-481"><code>						// Remove grouping parens if there is only one spec.</code></span>
<span class="codeline" id="line-482"><code>						nd.Lparen = 0</code></span>
<span class="codeline" id="line-483"><code>					}</code></span>
<span class="codeline" id="line-484"><code>					ds = append(ds, &amp;nd)</code></span>
<span class="codeline" id="line-485"><code>				}</code></span>
<span class="codeline" id="line-486"><code>			}</code></span>
<span class="codeline" id="line-487"><code>		}</code></span>
<span class="codeline" id="line-488"><code>	}</code></span>
<span class="codeline" id="line-489"><code>	return ds, unresolved</code></span>
<span class="codeline" id="line-490"><code>}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>func hasIota(s ast.Spec) bool {</code></span>
<span class="codeline" id="line-493"><code>	has := false</code></span>
<span class="codeline" id="line-494"><code>	ast.Inspect(s, func(n ast.Node) bool {</code></span>
<span class="codeline" id="line-495"><code>		// Check that this is the special built-in "iota" identifier, not</code></span>
<span class="codeline" id="line-496"><code>		// a user-defined shadow.</code></span>
<span class="codeline" id="line-497"><code>		if id, ok := n.(*ast.Ident); ok &amp;&amp; id.Name == "iota" &amp;&amp; id.Obj == nil {</code></span>
<span class="codeline" id="line-498"><code>			has = true</code></span>
<span class="codeline" id="line-499"><code>			return false</code></span>
<span class="codeline" id="line-500"><code>		}</code></span>
<span class="codeline" id="line-501"><code>		return true</code></span>
<span class="codeline" id="line-502"><code>	})</code></span>
<span class="codeline" id="line-503"><code>	return has</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>// findImportGroupStarts finds the start positions of each sequence of import</code></span>
<span class="codeline" id="line-507"><code>// specs that are not separated by a blank line.</code></span>
<span class="codeline" id="line-508"><code>func findImportGroupStarts(imps []*ast.ImportSpec) []token.Pos {</code></span>
<span class="codeline" id="line-509"><code>	startImps := findImportGroupStarts1(imps)</code></span>
<span class="codeline" id="line-510"><code>	groupStarts := make([]token.Pos, len(startImps))</code></span>
<span class="codeline" id="line-511"><code>	for i, imp := range startImps {</code></span>
<span class="codeline" id="line-512"><code>		groupStarts[i] = imp.Pos()</code></span>
<span class="codeline" id="line-513"><code>	}</code></span>
<span class="codeline" id="line-514"><code>	return groupStarts</code></span>
<span class="codeline" id="line-515"><code>}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>// Helper for findImportGroupStarts to ease testing.</code></span>
<span class="codeline" id="line-518"><code>func findImportGroupStarts1(origImps []*ast.ImportSpec) []*ast.ImportSpec {</code></span>
<span class="codeline" id="line-519"><code>	// Copy to avoid mutation.</code></span>
<span class="codeline" id="line-520"><code>	imps := make([]*ast.ImportSpec, len(origImps))</code></span>
<span class="codeline" id="line-521"><code>	copy(imps, origImps)</code></span>
<span class="codeline" id="line-522"><code>	// Assume the imports are sorted by position.</code></span>
<span class="codeline" id="line-523"><code>	sort.Slice(imps, func(i, j int) bool { return imps[i].Pos() &lt; imps[j].Pos() })</code></span>
<span class="codeline" id="line-524"><code>	// Assume gofmt has been applied, so there is a blank line between adjacent imps</code></span>
<span class="codeline" id="line-525"><code>	// if and only if they are more than 2 positions apart (newline, tab).</code></span>
<span class="codeline" id="line-526"><code>	var groupStarts []*ast.ImportSpec</code></span>
<span class="codeline" id="line-527"><code>	prevEnd := token.Pos(-2)</code></span>
<span class="codeline" id="line-528"><code>	for _, imp := range imps {</code></span>
<span class="codeline" id="line-529"><code>		if imp.Pos()-prevEnd &gt; 2 {</code></span>
<span class="codeline" id="line-530"><code>			groupStarts = append(groupStarts, imp)</code></span>
<span class="codeline" id="line-531"><code>		}</code></span>
<span class="codeline" id="line-532"><code>		prevEnd = imp.End()</code></span>
<span class="codeline" id="line-533"><code>		// Account for end-of-line comments.</code></span>
<span class="codeline" id="line-534"><code>		if imp.Comment != nil {</code></span>
<span class="codeline" id="line-535"><code>			prevEnd = imp.Comment.End()</code></span>
<span class="codeline" id="line-536"><code>		}</code></span>
<span class="codeline" id="line-537"><code>	}</code></span>
<span class="codeline" id="line-538"><code>	return groupStarts</code></span>
<span class="codeline" id="line-539"><code>}</code></span>
<span class="codeline" id="line-540"><code></code></span>
<span class="codeline" id="line-541"><code>// playExampleFile takes a whole file example and synthesizes a new *ast.File</code></span>
<span class="codeline" id="line-542"><code>// such that the example is function main in package main.</code></span>
<span class="codeline" id="line-543"><code>func playExampleFile(file *ast.File) *ast.File {</code></span>
<span class="codeline" id="line-544"><code>	// Strip copyright comment if present.</code></span>
<span class="codeline" id="line-545"><code>	comments := file.Comments</code></span>
<span class="codeline" id="line-546"><code>	if len(comments) &gt; 0 &amp;&amp; strings.HasPrefix(comments[0].Text(), "Copyright") {</code></span>
<span class="codeline" id="line-547"><code>		comments = comments[1:]</code></span>
<span class="codeline" id="line-548"><code>	}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>	// Copy declaration slice, rewriting the ExampleX function to main.</code></span>
<span class="codeline" id="line-551"><code>	var decls []ast.Decl</code></span>
<span class="codeline" id="line-552"><code>	for _, d := range file.Decls {</code></span>
<span class="codeline" id="line-553"><code>		if f, ok := d.(*ast.FuncDecl); ok &amp;&amp; isTest(f.Name.Name, "Example") {</code></span>
<span class="codeline" id="line-554"><code>			// Copy the FuncDecl, as it may be used elsewhere.</code></span>
<span class="codeline" id="line-555"><code>			newF := *f</code></span>
<span class="codeline" id="line-556"><code>			newF.Name = ast.NewIdent("main")</code></span>
<span class="codeline" id="line-557"><code>			newF.Body, comments = stripOutputComment(f.Body, comments)</code></span>
<span class="codeline" id="line-558"><code>			d = &amp;newF</code></span>
<span class="codeline" id="line-559"><code>		}</code></span>
<span class="codeline" id="line-560"><code>		decls = append(decls, d)</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>	// Copy the File, as it may be used elsewhere.</code></span>
<span class="codeline" id="line-564"><code>	f := *file</code></span>
<span class="codeline" id="line-565"><code>	f.Name = ast.NewIdent("main")</code></span>
<span class="codeline" id="line-566"><code>	f.Decls = decls</code></span>
<span class="codeline" id="line-567"><code>	f.Comments = comments</code></span>
<span class="codeline" id="line-568"><code>	return &amp;f</code></span>
<span class="codeline" id="line-569"><code>}</code></span>
<span class="codeline" id="line-570"><code></code></span>
<span class="codeline" id="line-571"><code>// stripOutputComment finds and removes the "Output:" or "Unordered output:"</code></span>
<span class="codeline" id="line-572"><code>// comment from body and comments, and adjusts the body block's end position.</code></span>
<span class="codeline" id="line-573"><code>func stripOutputComment(body *ast.BlockStmt, comments []*ast.CommentGroup) (*ast.BlockStmt, []*ast.CommentGroup) {</code></span>
<span class="codeline" id="line-574"><code>	// Do nothing if there is no "Output:" or "Unordered output:" comment.</code></span>
<span class="codeline" id="line-575"><code>	i, last := lastComment(body, comments)</code></span>
<span class="codeline" id="line-576"><code>	if last == nil || !outputPrefix.MatchString(last.Text()) {</code></span>
<span class="codeline" id="line-577"><code>		return body, comments</code></span>
<span class="codeline" id="line-578"><code>	}</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>	// Copy body and comments, as the originals may be used elsewhere.</code></span>
<span class="codeline" id="line-581"><code>	newBody := &amp;ast.BlockStmt{</code></span>
<span class="codeline" id="line-582"><code>		Lbrace: body.Lbrace,</code></span>
<span class="codeline" id="line-583"><code>		List:   body.List,</code></span>
<span class="codeline" id="line-584"><code>		Rbrace: last.Pos(),</code></span>
<span class="codeline" id="line-585"><code>	}</code></span>
<span class="codeline" id="line-586"><code>	newComments := make([]*ast.CommentGroup, len(comments)-1)</code></span>
<span class="codeline" id="line-587"><code>	copy(newComments, comments[:i])</code></span>
<span class="codeline" id="line-588"><code>	copy(newComments[i:], comments[i+1:])</code></span>
<span class="codeline" id="line-589"><code>	return newBody, newComments</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>// lastComment returns the last comment inside the provided block.</code></span>
<span class="codeline" id="line-593"><code>func lastComment(b *ast.BlockStmt, c []*ast.CommentGroup) (i int, last *ast.CommentGroup) {</code></span>
<span class="codeline" id="line-594"><code>	if b == nil {</code></span>
<span class="codeline" id="line-595"><code>		return</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code>	pos, end := b.Pos(), b.End()</code></span>
<span class="codeline" id="line-598"><code>	for j, cg := range c {</code></span>
<span class="codeline" id="line-599"><code>		if cg.Pos() &lt; pos {</code></span>
<span class="codeline" id="line-600"><code>			continue</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code>		if cg.End() &gt; end {</code></span>
<span class="codeline" id="line-603"><code>			break</code></span>
<span class="codeline" id="line-604"><code>		}</code></span>
<span class="codeline" id="line-605"><code>		i, last = j, cg</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	return</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// classifyExamples classifies examples and assigns them to the Examples field</code></span>
<span class="codeline" id="line-611"><code>// of the relevant Func, Type, or Package that the example is associated with.</code></span>
<span class="codeline" id="line-612"><code>//</code></span>
<span class="codeline" id="line-613"><code>// The classification process is ambiguous in some cases:</code></span>
<span class="codeline" id="line-614"><code>//</code></span>
<span class="codeline" id="line-615"><code>//   - ExampleFoo_Bar matches a type named Foo_Bar</code></span>
<span class="codeline" id="line-616"><code>//     or a method named Foo.Bar.</code></span>
<span class="codeline" id="line-617"><code>//   - ExampleFoo_bar matches a type named Foo_bar</code></span>
<span class="codeline" id="line-618"><code>//     or Foo (with a "bar" suffix).</code></span>
<span class="codeline" id="line-619"><code>//</code></span>
<span class="codeline" id="line-620"><code>// Examples with malformed names are not associated with anything.</code></span>
<span class="codeline" id="line-621"><code>func classifyExamples(p *Package, examples []*Example) {</code></span>
<span class="codeline" id="line-622"><code>	if len(examples) == 0 {</code></span>
<span class="codeline" id="line-623"><code>		return</code></span>
<span class="codeline" id="line-624"><code>	}</code></span>
<span class="codeline" id="line-625"><code>	// Mapping of names for funcs, types, and methods to the example listing.</code></span>
<span class="codeline" id="line-626"><code>	ids := make(map[string]*[]*Example)</code></span>
<span class="codeline" id="line-627"><code>	ids[""] = &amp;p.Examples // package-level examples have an empty name</code></span>
<span class="codeline" id="line-628"><code>	for _, f := range p.Funcs {</code></span>
<span class="codeline" id="line-629"><code>		if !token.IsExported(f.Name) {</code></span>
<span class="codeline" id="line-630"><code>			continue</code></span>
<span class="codeline" id="line-631"><code>		}</code></span>
<span class="codeline" id="line-632"><code>		ids[f.Name] = &amp;f.Examples</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	for _, t := range p.Types {</code></span>
<span class="codeline" id="line-635"><code>		if !token.IsExported(t.Name) {</code></span>
<span class="codeline" id="line-636"><code>			continue</code></span>
<span class="codeline" id="line-637"><code>		}</code></span>
<span class="codeline" id="line-638"><code>		ids[t.Name] = &amp;t.Examples</code></span>
<span class="codeline" id="line-639"><code>		for _, f := range t.Funcs {</code></span>
<span class="codeline" id="line-640"><code>			if !token.IsExported(f.Name) {</code></span>
<span class="codeline" id="line-641"><code>				continue</code></span>
<span class="codeline" id="line-642"><code>			}</code></span>
<span class="codeline" id="line-643"><code>			ids[f.Name] = &amp;f.Examples</code></span>
<span class="codeline" id="line-644"><code>		}</code></span>
<span class="codeline" id="line-645"><code>		for _, m := range t.Methods {</code></span>
<span class="codeline" id="line-646"><code>			if !token.IsExported(m.Name) {</code></span>
<span class="codeline" id="line-647"><code>				continue</code></span>
<span class="codeline" id="line-648"><code>			}</code></span>
<span class="codeline" id="line-649"><code>			ids[strings.TrimPrefix(nameWithoutInst(m.Recv), "*")+"_"+m.Name] = &amp;m.Examples</code></span>
<span class="codeline" id="line-650"><code>		}</code></span>
<span class="codeline" id="line-651"><code>	}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>	// Group each example with the associated func, type, or method.</code></span>
<span class="codeline" id="line-654"><code>	for _, ex := range examples {</code></span>
<span class="codeline" id="line-655"><code>		// Consider all possible split points for the suffix</code></span>
<span class="codeline" id="line-656"><code>		// by starting at the end of string (no suffix case),</code></span>
<span class="codeline" id="line-657"><code>		// then trying all positions that contain a '_' character.</code></span>
<span class="codeline" id="line-658"><code>		//</code></span>
<span class="codeline" id="line-659"><code>		// An association is made on the first successful match.</code></span>
<span class="codeline" id="line-660"><code>		// Examples with malformed names that match nothing are skipped.</code></span>
<span class="codeline" id="line-661"><code>		for i := len(ex.Name); i &gt;= 0; i = strings.LastIndexByte(ex.Name[:i], '_') {</code></span>
<span class="codeline" id="line-662"><code>			prefix, suffix, ok := splitExampleName(ex.Name, i)</code></span>
<span class="codeline" id="line-663"><code>			if !ok {</code></span>
<span class="codeline" id="line-664"><code>				continue</code></span>
<span class="codeline" id="line-665"><code>			}</code></span>
<span class="codeline" id="line-666"><code>			exs, ok := ids[prefix]</code></span>
<span class="codeline" id="line-667"><code>			if !ok {</code></span>
<span class="codeline" id="line-668"><code>				continue</code></span>
<span class="codeline" id="line-669"><code>			}</code></span>
<span class="codeline" id="line-670"><code>			ex.Suffix = suffix</code></span>
<span class="codeline" id="line-671"><code>			*exs = append(*exs, ex)</code></span>
<span class="codeline" id="line-672"><code>			break</code></span>
<span class="codeline" id="line-673"><code>		}</code></span>
<span class="codeline" id="line-674"><code>	}</code></span>
<span class="codeline" id="line-675"><code></code></span>
<span class="codeline" id="line-676"><code>	// Sort list of example according to the user-specified suffix name.</code></span>
<span class="codeline" id="line-677"><code>	for _, exs := range ids {</code></span>
<span class="codeline" id="line-678"><code>		sort.Slice((*exs), func(i, j int) bool {</code></span>
<span class="codeline" id="line-679"><code>			return (*exs)[i].Suffix &lt; (*exs)[j].Suffix</code></span>
<span class="codeline" id="line-680"><code>		})</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>// nameWithoutInst returns name if name has no brackets. If name contains</code></span>
<span class="codeline" id="line-685"><code>// brackets, then it returns name with all the contents between (and including)</code></span>
<span class="codeline" id="line-686"><code>// the outermost left and right bracket removed.</code></span>
<span class="codeline" id="line-687"><code>//</code></span>
<span class="codeline" id="line-688"><code>// Adapted from debug/gosym/symtab.go:Sym.nameWithoutInst.</code></span>
<span class="codeline" id="line-689"><code>func nameWithoutInst(name string) string {</code></span>
<span class="codeline" id="line-690"><code>	start := strings.Index(name, "[")</code></span>
<span class="codeline" id="line-691"><code>	if start &lt; 0 {</code></span>
<span class="codeline" id="line-692"><code>		return name</code></span>
<span class="codeline" id="line-693"><code>	}</code></span>
<span class="codeline" id="line-694"><code>	end := strings.LastIndex(name, "]")</code></span>
<span class="codeline" id="line-695"><code>	if end &lt; 0 {</code></span>
<span class="codeline" id="line-696"><code>		// Malformed name, should contain closing bracket too.</code></span>
<span class="codeline" id="line-697"><code>		return name</code></span>
<span class="codeline" id="line-698"><code>	}</code></span>
<span class="codeline" id="line-699"><code>	return name[0:start] + name[end+1:]</code></span>
<span class="codeline" id="line-700"><code>}</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>// splitExampleName attempts to split example name s at index i,</code></span>
<span class="codeline" id="line-703"><code>// and reports if that produces a valid split. The suffix may be</code></span>
<span class="codeline" id="line-704"><code>// absent. Otherwise, it must start with a lower-case letter and</code></span>
<span class="codeline" id="line-705"><code>// be preceded by '_'.</code></span>
<span class="codeline" id="line-706"><code>//</code></span>
<span class="codeline" id="line-707"><code>// One of i == len(s) or s[i] == '_' must be true.</code></span>
<span class="codeline" id="line-708"><code>func splitExampleName(s string, i int) (prefix, suffix string, ok bool) {</code></span>
<span class="codeline" id="line-709"><code>	if i == len(s) {</code></span>
<span class="codeline" id="line-710"><code>		return s, "", true</code></span>
<span class="codeline" id="line-711"><code>	}</code></span>
<span class="codeline" id="line-712"><code>	if i == len(s)-1 {</code></span>
<span class="codeline" id="line-713"><code>		return "", "", false</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>	prefix, suffix = s[:i], s[i+1:]</code></span>
<span class="codeline" id="line-716"><code>	return prefix, suffix, isExampleSuffix(suffix)</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>func isExampleSuffix(s string) bool {</code></span>
<span class="codeline" id="line-720"><code>	r, size := utf8.DecodeRuneInString(s)</code></span>
<span class="codeline" id="line-721"><code>	return size &gt; 0 &amp;&amp; unicode.IsLower(r)</code></span>
<span class="codeline" id="line-722"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>