<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: universe.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	universe.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// This file sets up the universe scope and the unsafe package.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>package types</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"go/constant"</code></span>
<span class="codeline" id="line-13"><code>	"strings"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// The Universe scope contains all predeclared objects of Go.</code></span>
<span class="codeline" id="line-17"><code>// It is the outermost scope of any chain of nested scopes.</code></span>
<span class="codeline" id="line-18"><code>var Universe *Scope</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>// The Unsafe package is the package returned by an importer</code></span>
<span class="codeline" id="line-21"><code>// for the import path "unsafe".</code></span>
<span class="codeline" id="line-22"><code>var Unsafe *Package</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>var (</code></span>
<span class="codeline" id="line-25"><code>	universeIota       Object</code></span>
<span class="codeline" id="line-26"><code>	universeByte       Type // uint8 alias, but has name "byte"</code></span>
<span class="codeline" id="line-27"><code>	universeRune       Type // int32 alias, but has name "rune"</code></span>
<span class="codeline" id="line-28"><code>	universeAny        Object</code></span>
<span class="codeline" id="line-29"><code>	universeError      Type</code></span>
<span class="codeline" id="line-30"><code>	universeComparable Object</code></span>
<span class="codeline" id="line-31"><code>)</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>// Typ contains the predeclared *Basic types indexed by their</code></span>
<span class="codeline" id="line-34"><code>// corresponding BasicKind.</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>// The *Basic type for Typ[Byte] will have the name "uint8".</code></span>
<span class="codeline" id="line-37"><code>// Use Universe.Lookup("byte").Type() to obtain the specific</code></span>
<span class="codeline" id="line-38"><code>// alias basic type named "byte" (and analogous for "rune").</code></span>
<span class="codeline" id="line-39"><code>var Typ = []*Basic{</code></span>
<span class="codeline" id="line-40"><code>	Invalid: {Invalid, 0, "invalid type"},</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>	Bool:          {Bool, IsBoolean, "bool"},</code></span>
<span class="codeline" id="line-43"><code>	Int:           {Int, IsInteger, "int"},</code></span>
<span class="codeline" id="line-44"><code>	Int8:          {Int8, IsInteger, "int8"},</code></span>
<span class="codeline" id="line-45"><code>	Int16:         {Int16, IsInteger, "int16"},</code></span>
<span class="codeline" id="line-46"><code>	Int32:         {Int32, IsInteger, "int32"},</code></span>
<span class="codeline" id="line-47"><code>	Int64:         {Int64, IsInteger, "int64"},</code></span>
<span class="codeline" id="line-48"><code>	Uint:          {Uint, IsInteger | IsUnsigned, "uint"},</code></span>
<span class="codeline" id="line-49"><code>	Uint8:         {Uint8, IsInteger | IsUnsigned, "uint8"},</code></span>
<span class="codeline" id="line-50"><code>	Uint16:        {Uint16, IsInteger | IsUnsigned, "uint16"},</code></span>
<span class="codeline" id="line-51"><code>	Uint32:        {Uint32, IsInteger | IsUnsigned, "uint32"},</code></span>
<span class="codeline" id="line-52"><code>	Uint64:        {Uint64, IsInteger | IsUnsigned, "uint64"},</code></span>
<span class="codeline" id="line-53"><code>	Uintptr:       {Uintptr, IsInteger | IsUnsigned, "uintptr"},</code></span>
<span class="codeline" id="line-54"><code>	Float32:       {Float32, IsFloat, "float32"},</code></span>
<span class="codeline" id="line-55"><code>	Float64:       {Float64, IsFloat, "float64"},</code></span>
<span class="codeline" id="line-56"><code>	Complex64:     {Complex64, IsComplex, "complex64"},</code></span>
<span class="codeline" id="line-57"><code>	Complex128:    {Complex128, IsComplex, "complex128"},</code></span>
<span class="codeline" id="line-58"><code>	String:        {String, IsString, "string"},</code></span>
<span class="codeline" id="line-59"><code>	UnsafePointer: {UnsafePointer, 0, "Pointer"},</code></span>
<span class="codeline" id="line-60"><code></code></span>
<span class="codeline" id="line-61"><code>	UntypedBool:    {UntypedBool, IsBoolean | IsUntyped, "untyped bool"},</code></span>
<span class="codeline" id="line-62"><code>	UntypedInt:     {UntypedInt, IsInteger | IsUntyped, "untyped int"},</code></span>
<span class="codeline" id="line-63"><code>	UntypedRune:    {UntypedRune, IsInteger | IsUntyped, "untyped rune"},</code></span>
<span class="codeline" id="line-64"><code>	UntypedFloat:   {UntypedFloat, IsFloat | IsUntyped, "untyped float"},</code></span>
<span class="codeline" id="line-65"><code>	UntypedComplex: {UntypedComplex, IsComplex | IsUntyped, "untyped complex"},</code></span>
<span class="codeline" id="line-66"><code>	UntypedString:  {UntypedString, IsString | IsUntyped, "untyped string"},</code></span>
<span class="codeline" id="line-67"><code>	UntypedNil:     {UntypedNil, IsUntyped, "untyped nil"},</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>var aliases = [...]*Basic{</code></span>
<span class="codeline" id="line-71"><code>	{Byte, IsInteger | IsUnsigned, "byte"},</code></span>
<span class="codeline" id="line-72"><code>	{Rune, IsInteger, "rune"},</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>func defPredeclaredTypes() {</code></span>
<span class="codeline" id="line-76"><code>	for _, t := range Typ {</code></span>
<span class="codeline" id="line-77"><code>		def(NewTypeName(nopos, nil, t.name, t))</code></span>
<span class="codeline" id="line-78"><code>	}</code></span>
<span class="codeline" id="line-79"><code>	for _, t := range aliases {</code></span>
<span class="codeline" id="line-80"><code>		def(NewTypeName(nopos, nil, t.name, t))</code></span>
<span class="codeline" id="line-81"><code>	}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>	// type any = interface{}</code></span>
<span class="codeline" id="line-84"><code>	// Note: don't use &amp;emptyInterface for the type of any. Using a unique</code></span>
<span class="codeline" id="line-85"><code>	// pointer allows us to detect any and format it as "any" rather than</code></span>
<span class="codeline" id="line-86"><code>	// interface{}, which clarifies user-facing error messages significantly.</code></span>
<span class="codeline" id="line-87"><code>	def(NewTypeName(nopos, nil, "any", &amp;Interface{complete: true, tset: &amp;topTypeSet}))</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>	// type error interface{ Error() string }</code></span>
<span class="codeline" id="line-90"><code>	{</code></span>
<span class="codeline" id="line-91"><code>		obj := NewTypeName(nopos, nil, "error", nil)</code></span>
<span class="codeline" id="line-92"><code>		obj.setColor(black)</code></span>
<span class="codeline" id="line-93"><code>		typ := NewNamed(obj, nil, nil)</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>		// error.Error() string</code></span>
<span class="codeline" id="line-96"><code>		recv := NewVar(nopos, nil, "", typ)</code></span>
<span class="codeline" id="line-97"><code>		res := NewVar(nopos, nil, "", Typ[String])</code></span>
<span class="codeline" id="line-98"><code>		sig := NewSignatureType(recv, nil, nil, nil, NewTuple(res), false)</code></span>
<span class="codeline" id="line-99"><code>		err := NewFunc(nopos, nil, "Error", sig)</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>		// interface{ Error() string }</code></span>
<span class="codeline" id="line-102"><code>		ityp := &amp;Interface{methods: []*Func{err}, complete: true}</code></span>
<span class="codeline" id="line-103"><code>		computeInterfaceTypeSet(nil, nopos, ityp) // prevent races due to lazy computation of tset</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>		typ.SetUnderlying(ityp)</code></span>
<span class="codeline" id="line-106"><code>		def(obj)</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>	// type comparable interface{} // marked as comparable</code></span>
<span class="codeline" id="line-110"><code>	{</code></span>
<span class="codeline" id="line-111"><code>		obj := NewTypeName(nopos, nil, "comparable", nil)</code></span>
<span class="codeline" id="line-112"><code>		obj.setColor(black)</code></span>
<span class="codeline" id="line-113"><code>		typ := NewNamed(obj, nil, nil)</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>		// interface{} // marked as comparable</code></span>
<span class="codeline" id="line-116"><code>		ityp := &amp;Interface{complete: true, tset: &amp;_TypeSet{nil, allTermlist, true}}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>		typ.SetUnderlying(ityp)</code></span>
<span class="codeline" id="line-119"><code>		def(obj)</code></span>
<span class="codeline" id="line-120"><code>	}</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>var predeclaredConsts = [...]struct {</code></span>
<span class="codeline" id="line-124"><code>	name string</code></span>
<span class="codeline" id="line-125"><code>	kind BasicKind</code></span>
<span class="codeline" id="line-126"><code>	val  constant.Value</code></span>
<span class="codeline" id="line-127"><code>}{</code></span>
<span class="codeline" id="line-128"><code>	{"true", UntypedBool, constant.MakeBool(true)},</code></span>
<span class="codeline" id="line-129"><code>	{"false", UntypedBool, constant.MakeBool(false)},</code></span>
<span class="codeline" id="line-130"><code>	{"iota", UntypedInt, constant.MakeInt64(0)},</code></span>
<span class="codeline" id="line-131"><code>}</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>func defPredeclaredConsts() {</code></span>
<span class="codeline" id="line-134"><code>	for _, c := range predeclaredConsts {</code></span>
<span class="codeline" id="line-135"><code>		def(NewConst(nopos, nil, c.name, Typ[c.kind], c.val))</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>func defPredeclaredNil() {</code></span>
<span class="codeline" id="line-140"><code>	def(&amp;Nil{object{name: "nil", typ: Typ[UntypedNil], color_: black}})</code></span>
<span class="codeline" id="line-141"><code>}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// A builtinId is the id of a builtin function.</code></span>
<span class="codeline" id="line-144"><code>type builtinId int</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>const (</code></span>
<span class="codeline" id="line-147"><code>	// universe scope</code></span>
<span class="codeline" id="line-148"><code>	_Append builtinId = iota</code></span>
<span class="codeline" id="line-149"><code>	_Cap</code></span>
<span class="codeline" id="line-150"><code>	_Clear</code></span>
<span class="codeline" id="line-151"><code>	_Close</code></span>
<span class="codeline" id="line-152"><code>	_Complex</code></span>
<span class="codeline" id="line-153"><code>	_Copy</code></span>
<span class="codeline" id="line-154"><code>	_Delete</code></span>
<span class="codeline" id="line-155"><code>	_Imag</code></span>
<span class="codeline" id="line-156"><code>	_Len</code></span>
<span class="codeline" id="line-157"><code>	_Make</code></span>
<span class="codeline" id="line-158"><code>	_Max</code></span>
<span class="codeline" id="line-159"><code>	_Min</code></span>
<span class="codeline" id="line-160"><code>	_New</code></span>
<span class="codeline" id="line-161"><code>	_Panic</code></span>
<span class="codeline" id="line-162"><code>	_Print</code></span>
<span class="codeline" id="line-163"><code>	_Println</code></span>
<span class="codeline" id="line-164"><code>	_Real</code></span>
<span class="codeline" id="line-165"><code>	_Recover</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	// package unsafe</code></span>
<span class="codeline" id="line-168"><code>	_Add</code></span>
<span class="codeline" id="line-169"><code>	_Alignof</code></span>
<span class="codeline" id="line-170"><code>	_Offsetof</code></span>
<span class="codeline" id="line-171"><code>	_Sizeof</code></span>
<span class="codeline" id="line-172"><code>	_Slice</code></span>
<span class="codeline" id="line-173"><code>	_SliceData</code></span>
<span class="codeline" id="line-174"><code>	_String</code></span>
<span class="codeline" id="line-175"><code>	_StringData</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// testing support</code></span>
<span class="codeline" id="line-178"><code>	_Assert</code></span>
<span class="codeline" id="line-179"><code>	_Trace</code></span>
<span class="codeline" id="line-180"><code>)</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>var predeclaredFuncs = [...]struct {</code></span>
<span class="codeline" id="line-183"><code>	name     string</code></span>
<span class="codeline" id="line-184"><code>	nargs    int</code></span>
<span class="codeline" id="line-185"><code>	variadic bool</code></span>
<span class="codeline" id="line-186"><code>	kind     exprKind</code></span>
<span class="codeline" id="line-187"><code>}{</code></span>
<span class="codeline" id="line-188"><code>	_Append:  {"append", 1, true, expression},</code></span>
<span class="codeline" id="line-189"><code>	_Cap:     {"cap", 1, false, expression},</code></span>
<span class="codeline" id="line-190"><code>	_Clear:   {"clear", 1, false, statement},</code></span>
<span class="codeline" id="line-191"><code>	_Close:   {"close", 1, false, statement},</code></span>
<span class="codeline" id="line-192"><code>	_Complex: {"complex", 2, false, expression},</code></span>
<span class="codeline" id="line-193"><code>	_Copy:    {"copy", 2, false, statement},</code></span>
<span class="codeline" id="line-194"><code>	_Delete:  {"delete", 2, false, statement},</code></span>
<span class="codeline" id="line-195"><code>	_Imag:    {"imag", 1, false, expression},</code></span>
<span class="codeline" id="line-196"><code>	_Len:     {"len", 1, false, expression},</code></span>
<span class="codeline" id="line-197"><code>	_Make:    {"make", 1, true, expression},</code></span>
<span class="codeline" id="line-198"><code>	// To disable max/min, remove the next two lines.</code></span>
<span class="codeline" id="line-199"><code>	_Max:     {"max", 1, true, expression},</code></span>
<span class="codeline" id="line-200"><code>	_Min:     {"min", 1, true, expression},</code></span>
<span class="codeline" id="line-201"><code>	_New:     {"new", 1, false, expression},</code></span>
<span class="codeline" id="line-202"><code>	_Panic:   {"panic", 1, false, statement},</code></span>
<span class="codeline" id="line-203"><code>	_Print:   {"print", 0, true, statement},</code></span>
<span class="codeline" id="line-204"><code>	_Println: {"println", 0, true, statement},</code></span>
<span class="codeline" id="line-205"><code>	_Real:    {"real", 1, false, expression},</code></span>
<span class="codeline" id="line-206"><code>	_Recover: {"recover", 0, false, statement},</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	_Add:        {"Add", 2, false, expression},</code></span>
<span class="codeline" id="line-209"><code>	_Alignof:    {"Alignof", 1, false, expression},</code></span>
<span class="codeline" id="line-210"><code>	_Offsetof:   {"Offsetof", 1, false, expression},</code></span>
<span class="codeline" id="line-211"><code>	_Sizeof:     {"Sizeof", 1, false, expression},</code></span>
<span class="codeline" id="line-212"><code>	_Slice:      {"Slice", 2, false, expression},</code></span>
<span class="codeline" id="line-213"><code>	_SliceData:  {"SliceData", 1, false, expression},</code></span>
<span class="codeline" id="line-214"><code>	_String:     {"String", 2, false, expression},</code></span>
<span class="codeline" id="line-215"><code>	_StringData: {"StringData", 1, false, expression},</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>	_Assert: {"assert", 1, false, statement},</code></span>
<span class="codeline" id="line-218"><code>	_Trace:  {"trace", 0, true, statement},</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>func defPredeclaredFuncs() {</code></span>
<span class="codeline" id="line-222"><code>	for i := range predeclaredFuncs {</code></span>
<span class="codeline" id="line-223"><code>		id := builtinId(i)</code></span>
<span class="codeline" id="line-224"><code>		if id == _Assert || id == _Trace {</code></span>
<span class="codeline" id="line-225"><code>			continue // only define these in testing environment</code></span>
<span class="codeline" id="line-226"><code>		}</code></span>
<span class="codeline" id="line-227"><code>		def(newBuiltin(id))</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>}</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>// DefPredeclaredTestFuncs defines the assert and trace built-ins.</code></span>
<span class="codeline" id="line-232"><code>// These built-ins are intended for debugging and testing of this</code></span>
<span class="codeline" id="line-233"><code>// package only.</code></span>
<span class="codeline" id="line-234"><code>func DefPredeclaredTestFuncs() {</code></span>
<span class="codeline" id="line-235"><code>	if Universe.Lookup("assert") != nil {</code></span>
<span class="codeline" id="line-236"><code>		return // already defined</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code>	def(newBuiltin(_Assert))</code></span>
<span class="codeline" id="line-239"><code>	def(newBuiltin(_Trace))</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>func init() {</code></span>
<span class="codeline" id="line-243"><code>	Universe = NewScope(nil, nopos, nopos, "universe")</code></span>
<span class="codeline" id="line-244"><code>	Unsafe = NewPackage("unsafe", "unsafe")</code></span>
<span class="codeline" id="line-245"><code>	Unsafe.complete = true</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>	defPredeclaredTypes()</code></span>
<span class="codeline" id="line-248"><code>	defPredeclaredConsts()</code></span>
<span class="codeline" id="line-249"><code>	defPredeclaredNil()</code></span>
<span class="codeline" id="line-250"><code>	defPredeclaredFuncs()</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>	universeIota = Universe.Lookup("iota")</code></span>
<span class="codeline" id="line-253"><code>	universeByte = Universe.Lookup("byte").Type()</code></span>
<span class="codeline" id="line-254"><code>	universeRune = Universe.Lookup("rune").Type()</code></span>
<span class="codeline" id="line-255"><code>	universeAny = Universe.Lookup("any")</code></span>
<span class="codeline" id="line-256"><code>	universeError = Universe.Lookup("error").Type()</code></span>
<span class="codeline" id="line-257"><code>	universeComparable = Universe.Lookup("comparable")</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// Objects with names containing blanks are internal and not entered into</code></span>
<span class="codeline" id="line-261"><code>// a scope. Objects with exported names are inserted in the unsafe package</code></span>
<span class="codeline" id="line-262"><code>// scope; other objects are inserted in the universe scope.</code></span>
<span class="codeline" id="line-263"><code>func def(obj Object) {</code></span>
<span class="codeline" id="line-264"><code>	assert(obj.color() == black)</code></span>
<span class="codeline" id="line-265"><code>	name := obj.Name()</code></span>
<span class="codeline" id="line-266"><code>	if strings.Contains(name, " ") {</code></span>
<span class="codeline" id="line-267"><code>		return // nothing to do</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	// fix Obj link for named types</code></span>
<span class="codeline" id="line-270"><code>	if typ := asNamed(obj.Type()); typ != nil {</code></span>
<span class="codeline" id="line-271"><code>		typ.obj = obj.(*TypeName)</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code>	// exported identifiers go into package unsafe</code></span>
<span class="codeline" id="line-274"><code>	scope := Universe</code></span>
<span class="codeline" id="line-275"><code>	if obj.Exported() {</code></span>
<span class="codeline" id="line-276"><code>		scope = Unsafe.scope</code></span>
<span class="codeline" id="line-277"><code>		// set Pkg field</code></span>
<span class="codeline" id="line-278"><code>		switch obj := obj.(type) {</code></span>
<span class="codeline" id="line-279"><code>		case *TypeName:</code></span>
<span class="codeline" id="line-280"><code>			obj.pkg = Unsafe</code></span>
<span class="codeline" id="line-281"><code>		case *Builtin:</code></span>
<span class="codeline" id="line-282"><code>			obj.pkg = Unsafe</code></span>
<span class="codeline" id="line-283"><code>		default:</code></span>
<span class="codeline" id="line-284"><code>			unreachable()</code></span>
<span class="codeline" id="line-285"><code>		}</code></span>
<span class="codeline" id="line-286"><code>	}</code></span>
<span class="codeline" id="line-287"><code>	if scope.Insert(obj) != nil {</code></span>
<span class="codeline" id="line-288"><code>		panic("double declaration of predeclared identifier")</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>