<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: subst.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	subst.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2018 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// This file implements type parameter substitution.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>package types</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"go/token"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>type substMap map[*TypeParam]Type</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>// makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].</code></span>
<span class="codeline" id="line-18"><code>// If targs[i] is nil, tpars[i] is not substituted.</code></span>
<span class="codeline" id="line-19"><code>func makeSubstMap(tpars []*TypeParam, targs []Type) substMap {</code></span>
<span class="codeline" id="line-20"><code>	assert(len(tpars) == len(targs))</code></span>
<span class="codeline" id="line-21"><code>	proj := make(substMap, len(tpars))</code></span>
<span class="codeline" id="line-22"><code>	for i, tpar := range tpars {</code></span>
<span class="codeline" id="line-23"><code>		proj[tpar] = targs[i]</code></span>
<span class="codeline" id="line-24"><code>	}</code></span>
<span class="codeline" id="line-25"><code>	return proj</code></span>
<span class="codeline" id="line-26"><code>}</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>// makeRenameMap is like makeSubstMap, but creates a map used to rename type</code></span>
<span class="codeline" id="line-29"><code>// parameters in from with the type parameters in to.</code></span>
<span class="codeline" id="line-30"><code>func makeRenameMap(from, to []*TypeParam) substMap {</code></span>
<span class="codeline" id="line-31"><code>	assert(len(from) == len(to))</code></span>
<span class="codeline" id="line-32"><code>	proj := make(substMap, len(from))</code></span>
<span class="codeline" id="line-33"><code>	for i, tpar := range from {</code></span>
<span class="codeline" id="line-34"><code>		proj[tpar] = to[i]</code></span>
<span class="codeline" id="line-35"><code>	}</code></span>
<span class="codeline" id="line-36"><code>	return proj</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>func (m substMap) empty() bool {</code></span>
<span class="codeline" id="line-40"><code>	return len(m) == 0</code></span>
<span class="codeline" id="line-41"><code>}</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>func (m substMap) lookup(tpar *TypeParam) Type {</code></span>
<span class="codeline" id="line-44"><code>	if t := m[tpar]; t != nil {</code></span>
<span class="codeline" id="line-45"><code>		return t</code></span>
<span class="codeline" id="line-46"><code>	}</code></span>
<span class="codeline" id="line-47"><code>	return tpar</code></span>
<span class="codeline" id="line-48"><code>}</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>// subst returns the type typ with its type parameters tpars replaced by the</code></span>
<span class="codeline" id="line-51"><code>// corresponding type arguments targs, recursively. subst doesn't modify the</code></span>
<span class="codeline" id="line-52"><code>// incoming type. If a substitution took place, the result type is different</code></span>
<span class="codeline" id="line-53"><code>// from the incoming type.</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// If expanding is non-nil, it is the instance type currently being expanded.</code></span>
<span class="codeline" id="line-56"><code>// One of expanding or ctxt must be non-nil.</code></span>
<span class="codeline" id="line-57"><code>func (check *Checker) subst(pos token.Pos, typ Type, smap substMap, expanding *Named, ctxt *Context) Type {</code></span>
<span class="codeline" id="line-58"><code>	assert(expanding != nil || ctxt != nil)</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	if smap.empty() {</code></span>
<span class="codeline" id="line-61"><code>		return typ</code></span>
<span class="codeline" id="line-62"><code>	}</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>	// common cases</code></span>
<span class="codeline" id="line-65"><code>	switch t := typ.(type) {</code></span>
<span class="codeline" id="line-66"><code>	case *Basic:</code></span>
<span class="codeline" id="line-67"><code>		return typ // nothing to do</code></span>
<span class="codeline" id="line-68"><code>	case *TypeParam:</code></span>
<span class="codeline" id="line-69"><code>		return smap.lookup(t)</code></span>
<span class="codeline" id="line-70"><code>	}</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>	// general case</code></span>
<span class="codeline" id="line-73"><code>	subst := subster{</code></span>
<span class="codeline" id="line-74"><code>		pos:       pos,</code></span>
<span class="codeline" id="line-75"><code>		smap:      smap,</code></span>
<span class="codeline" id="line-76"><code>		check:     check,</code></span>
<span class="codeline" id="line-77"><code>		expanding: expanding,</code></span>
<span class="codeline" id="line-78"><code>		ctxt:      ctxt,</code></span>
<span class="codeline" id="line-79"><code>	}</code></span>
<span class="codeline" id="line-80"><code>	return subst.typ(typ)</code></span>
<span class="codeline" id="line-81"><code>}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>type subster struct {</code></span>
<span class="codeline" id="line-84"><code>	pos       token.Pos</code></span>
<span class="codeline" id="line-85"><code>	smap      substMap</code></span>
<span class="codeline" id="line-86"><code>	check     *Checker // nil if called via Instantiate</code></span>
<span class="codeline" id="line-87"><code>	expanding *Named   // if non-nil, the instance that is being expanded</code></span>
<span class="codeline" id="line-88"><code>	ctxt      *Context</code></span>
<span class="codeline" id="line-89"><code>}</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>func (subst *subster) typ(typ Type) Type {</code></span>
<span class="codeline" id="line-92"><code>	switch t := typ.(type) {</code></span>
<span class="codeline" id="line-93"><code>	case nil:</code></span>
<span class="codeline" id="line-94"><code>		// Call typOrNil if it's possible that typ is nil.</code></span>
<span class="codeline" id="line-95"><code>		panic("nil typ")</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>	case *Basic:</code></span>
<span class="codeline" id="line-98"><code>		// nothing to do</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>	case *Alias:</code></span>
<span class="codeline" id="line-101"><code>		rhs := subst.typ(t.fromRHS)</code></span>
<span class="codeline" id="line-102"><code>		if rhs != t.fromRHS {</code></span>
<span class="codeline" id="line-103"><code>			// This branch cannot be reached because the RHS of an alias</code></span>
<span class="codeline" id="line-104"><code>			// may only contain type parameters of an enclosing function.</code></span>
<span class="codeline" id="line-105"><code>			// Such function bodies are never "instantiated" and thus</code></span>
<span class="codeline" id="line-106"><code>			// substitution is not called on locally declared alias types.</code></span>
<span class="codeline" id="line-107"><code>			// TODO(gri) adjust once parameterized aliases are supported</code></span>
<span class="codeline" id="line-108"><code>			panic("unreachable for unparameterized aliases")</code></span>
<span class="codeline" id="line-109"><code>			// return subst.check.newAlias(t.obj, rhs)</code></span>
<span class="codeline" id="line-110"><code>		}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	case *Array:</code></span>
<span class="codeline" id="line-113"><code>		elem := subst.typOrNil(t.elem)</code></span>
<span class="codeline" id="line-114"><code>		if elem != t.elem {</code></span>
<span class="codeline" id="line-115"><code>			return &amp;Array{len: t.len, elem: elem}</code></span>
<span class="codeline" id="line-116"><code>		}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>	case *Slice:</code></span>
<span class="codeline" id="line-119"><code>		elem := subst.typOrNil(t.elem)</code></span>
<span class="codeline" id="line-120"><code>		if elem != t.elem {</code></span>
<span class="codeline" id="line-121"><code>			return &amp;Slice{elem: elem}</code></span>
<span class="codeline" id="line-122"><code>		}</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>	case *Struct:</code></span>
<span class="codeline" id="line-125"><code>		if fields, copied := subst.varList(t.fields); copied {</code></span>
<span class="codeline" id="line-126"><code>			s := &amp;Struct{fields: fields, tags: t.tags}</code></span>
<span class="codeline" id="line-127"><code>			s.markComplete()</code></span>
<span class="codeline" id="line-128"><code>			return s</code></span>
<span class="codeline" id="line-129"><code>		}</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>	case *Pointer:</code></span>
<span class="codeline" id="line-132"><code>		base := subst.typ(t.base)</code></span>
<span class="codeline" id="line-133"><code>		if base != t.base {</code></span>
<span class="codeline" id="line-134"><code>			return &amp;Pointer{base: base}</code></span>
<span class="codeline" id="line-135"><code>		}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	case *Tuple:</code></span>
<span class="codeline" id="line-138"><code>		return subst.tuple(t)</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	case *Signature:</code></span>
<span class="codeline" id="line-141"><code>		// Preserve the receiver: it is handled during *Interface and *Named type</code></span>
<span class="codeline" id="line-142"><code>		// substitution.</code></span>
<span class="codeline" id="line-143"><code>		//</code></span>
<span class="codeline" id="line-144"><code>		// Naively doing the substitution here can lead to an infinite recursion in</code></span>
<span class="codeline" id="line-145"><code>		// the case where the receiver is an interface. For example, consider the</code></span>
<span class="codeline" id="line-146"><code>		// following declaration:</code></span>
<span class="codeline" id="line-147"><code>		//</code></span>
<span class="codeline" id="line-148"><code>		//  type T[A any] struct { f interface{ m() } }</code></span>
<span class="codeline" id="line-149"><code>		//</code></span>
<span class="codeline" id="line-150"><code>		// In this case, the type of f is an interface that is itself the receiver</code></span>
<span class="codeline" id="line-151"><code>		// type of all of its methods. Because we have no type name to break</code></span>
<span class="codeline" id="line-152"><code>		// cycles, substituting in the recv results in an infinite loop of</code></span>
<span class="codeline" id="line-153"><code>		// recv-&gt;interface-&gt;recv-&gt;interface-&gt;...</code></span>
<span class="codeline" id="line-154"><code>		recv := t.recv</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>		params := subst.tuple(t.params)</code></span>
<span class="codeline" id="line-157"><code>		results := subst.tuple(t.results)</code></span>
<span class="codeline" id="line-158"><code>		if params != t.params || results != t.results {</code></span>
<span class="codeline" id="line-159"><code>			return &amp;Signature{</code></span>
<span class="codeline" id="line-160"><code>				rparams: t.rparams,</code></span>
<span class="codeline" id="line-161"><code>				// TODO(gri) why can't we nil out tparams here, rather than in instantiate?</code></span>
<span class="codeline" id="line-162"><code>				tparams: t.tparams,</code></span>
<span class="codeline" id="line-163"><code>				// instantiated signatures have a nil scope</code></span>
<span class="codeline" id="line-164"><code>				recv:     recv,</code></span>
<span class="codeline" id="line-165"><code>				params:   params,</code></span>
<span class="codeline" id="line-166"><code>				results:  results,</code></span>
<span class="codeline" id="line-167"><code>				variadic: t.variadic,</code></span>
<span class="codeline" id="line-168"><code>			}</code></span>
<span class="codeline" id="line-169"><code>		}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>	case *Union:</code></span>
<span class="codeline" id="line-172"><code>		terms, copied := subst.termlist(t.terms)</code></span>
<span class="codeline" id="line-173"><code>		if copied {</code></span>
<span class="codeline" id="line-174"><code>			// term list substitution may introduce duplicate terms (unlikely but possible).</code></span>
<span class="codeline" id="line-175"><code>			// This is ok; lazy type set computation will determine the actual type set</code></span>
<span class="codeline" id="line-176"><code>			// in normal form.</code></span>
<span class="codeline" id="line-177"><code>			return &amp;Union{terms}</code></span>
<span class="codeline" id="line-178"><code>		}</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	case *Interface:</code></span>
<span class="codeline" id="line-181"><code>		methods, mcopied := subst.funcList(t.methods)</code></span>
<span class="codeline" id="line-182"><code>		embeddeds, ecopied := subst.typeList(t.embeddeds)</code></span>
<span class="codeline" id="line-183"><code>		if mcopied || ecopied {</code></span>
<span class="codeline" id="line-184"><code>			iface := subst.check.newInterface()</code></span>
<span class="codeline" id="line-185"><code>			iface.embeddeds = embeddeds</code></span>
<span class="codeline" id="line-186"><code>			iface.embedPos = t.embedPos</code></span>
<span class="codeline" id="line-187"><code>			iface.implicit = t.implicit</code></span>
<span class="codeline" id="line-188"><code>			assert(t.complete) // otherwise we are copying incomplete data</code></span>
<span class="codeline" id="line-189"><code>			iface.complete = t.complete</code></span>
<span class="codeline" id="line-190"><code>			// If we've changed the interface type, we may need to replace its</code></span>
<span class="codeline" id="line-191"><code>			// receiver if the receiver type is the original interface. Receivers of</code></span>
<span class="codeline" id="line-192"><code>			// *Named type are replaced during named type expansion.</code></span>
<span class="codeline" id="line-193"><code>			//</code></span>
<span class="codeline" id="line-194"><code>			// Notably, it's possible to reach here and not create a new *Interface,</code></span>
<span class="codeline" id="line-195"><code>			// even though the receiver type may be parameterized. For example:</code></span>
<span class="codeline" id="line-196"><code>			//</code></span>
<span class="codeline" id="line-197"><code>			//  type T[P any] interface{ m() }</code></span>
<span class="codeline" id="line-198"><code>			//</code></span>
<span class="codeline" id="line-199"><code>			// In this case the interface will not be substituted here, because its</code></span>
<span class="codeline" id="line-200"><code>			// method signatures do not depend on the type parameter P, but we still</code></span>
<span class="codeline" id="line-201"><code>			// need to create new interface methods to hold the instantiated</code></span>
<span class="codeline" id="line-202"><code>			// receiver. This is handled by Named.expandUnderlying.</code></span>
<span class="codeline" id="line-203"><code>			iface.methods, _ = replaceRecvType(methods, t, iface)</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>			// If check != nil, check.newInterface will have saved the interface for later completion.</code></span>
<span class="codeline" id="line-206"><code>			if subst.check == nil { // golang/go#61561: all newly created interfaces must be completed</code></span>
<span class="codeline" id="line-207"><code>				iface.typeSet()</code></span>
<span class="codeline" id="line-208"><code>			}</code></span>
<span class="codeline" id="line-209"><code>			return iface</code></span>
<span class="codeline" id="line-210"><code>		}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	case *Map:</code></span>
<span class="codeline" id="line-213"><code>		key := subst.typ(t.key)</code></span>
<span class="codeline" id="line-214"><code>		elem := subst.typ(t.elem)</code></span>
<span class="codeline" id="line-215"><code>		if key != t.key || elem != t.elem {</code></span>
<span class="codeline" id="line-216"><code>			return &amp;Map{key: key, elem: elem}</code></span>
<span class="codeline" id="line-217"><code>		}</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>	case *Chan:</code></span>
<span class="codeline" id="line-220"><code>		elem := subst.typ(t.elem)</code></span>
<span class="codeline" id="line-221"><code>		if elem != t.elem {</code></span>
<span class="codeline" id="line-222"><code>			return &amp;Chan{dir: t.dir, elem: elem}</code></span>
<span class="codeline" id="line-223"><code>		}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>	case *Named:</code></span>
<span class="codeline" id="line-226"><code>		// dump is for debugging</code></span>
<span class="codeline" id="line-227"><code>		dump := func(string, ...interface{}) {}</code></span>
<span class="codeline" id="line-228"><code>		if subst.check != nil &amp;&amp; subst.check.conf._Trace {</code></span>
<span class="codeline" id="line-229"><code>			subst.check.indent++</code></span>
<span class="codeline" id="line-230"><code>			defer func() {</code></span>
<span class="codeline" id="line-231"><code>				subst.check.indent--</code></span>
<span class="codeline" id="line-232"><code>			}()</code></span>
<span class="codeline" id="line-233"><code>			dump = func(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-234"><code>				subst.check.trace(subst.pos, format, args...)</code></span>
<span class="codeline" id="line-235"><code>			}</code></span>
<span class="codeline" id="line-236"><code>		}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>		// subst is called during expansion, so in this function we need to be</code></span>
<span class="codeline" id="line-239"><code>		// careful not to call any methods that would cause t to be expanded: doing</code></span>
<span class="codeline" id="line-240"><code>		// so would result in deadlock.</code></span>
<span class="codeline" id="line-241"><code>		//</code></span>
<span class="codeline" id="line-242"><code>		// So we call t.Origin().TypeParams() rather than t.TypeParams().</code></span>
<span class="codeline" id="line-243"><code>		orig := t.Origin()</code></span>
<span class="codeline" id="line-244"><code>		n := orig.TypeParams().Len()</code></span>
<span class="codeline" id="line-245"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-246"><code>			dump("&gt;&gt;&gt; %s is not parameterized", t)</code></span>
<span class="codeline" id="line-247"><code>			return t // type is not parameterized</code></span>
<span class="codeline" id="line-248"><code>		}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>		var newTArgs []Type</code></span>
<span class="codeline" id="line-251"><code>		if t.TypeArgs().Len() != n {</code></span>
<span class="codeline" id="line-252"><code>			return Typ[Invalid] // error reported elsewhere</code></span>
<span class="codeline" id="line-253"><code>		}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>		// already instantiated</code></span>
<span class="codeline" id="line-256"><code>		dump("&gt;&gt;&gt; %s already instantiated", t)</code></span>
<span class="codeline" id="line-257"><code>		// For each (existing) type argument targ, determine if it needs</code></span>
<span class="codeline" id="line-258"><code>		// to be substituted; i.e., if it is or contains a type parameter</code></span>
<span class="codeline" id="line-259"><code>		// that has a type argument for it.</code></span>
<span class="codeline" id="line-260"><code>		for i, targ := range t.TypeArgs().list() {</code></span>
<span class="codeline" id="line-261"><code>			dump("&gt;&gt;&gt; %d targ = %s", i, targ)</code></span>
<span class="codeline" id="line-262"><code>			new_targ := subst.typ(targ)</code></span>
<span class="codeline" id="line-263"><code>			if new_targ != targ {</code></span>
<span class="codeline" id="line-264"><code>				dump("&gt;&gt;&gt; substituted %d targ %s =&gt; %s", i, targ, new_targ)</code></span>
<span class="codeline" id="line-265"><code>				if newTArgs == nil {</code></span>
<span class="codeline" id="line-266"><code>					newTArgs = make([]Type, n)</code></span>
<span class="codeline" id="line-267"><code>					copy(newTArgs, t.TypeArgs().list())</code></span>
<span class="codeline" id="line-268"><code>				}</code></span>
<span class="codeline" id="line-269"><code>				newTArgs[i] = new_targ</code></span>
<span class="codeline" id="line-270"><code>			}</code></span>
<span class="codeline" id="line-271"><code>		}</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>		if newTArgs == nil {</code></span>
<span class="codeline" id="line-274"><code>			dump("&gt;&gt;&gt; nothing to substitute in %s", t)</code></span>
<span class="codeline" id="line-275"><code>			return t // nothing to substitute</code></span>
<span class="codeline" id="line-276"><code>		}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>		// Create a new instance and populate the context to avoid endless</code></span>
<span class="codeline" id="line-279"><code>		// recursion. The position used here is irrelevant because validation only</code></span>
<span class="codeline" id="line-280"><code>		// occurs on t (we don't call validType on named), but we use subst.pos to</code></span>
<span class="codeline" id="line-281"><code>		// help with debugging.</code></span>
<span class="codeline" id="line-282"><code>		return subst.check.instance(subst.pos, orig, newTArgs, subst.expanding, subst.ctxt)</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>	case *TypeParam:</code></span>
<span class="codeline" id="line-285"><code>		return subst.smap.lookup(t)</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	default:</code></span>
<span class="codeline" id="line-288"><code>		unreachable()</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	return typ</code></span>
<span class="codeline" id="line-292"><code>}</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>// typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].</code></span>
<span class="codeline" id="line-295"><code>// A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))</code></span>
<span class="codeline" id="line-296"><code>// where an array/slice element is accessed before it is set up.</code></span>
<span class="codeline" id="line-297"><code>func (subst *subster) typOrNil(typ Type) Type {</code></span>
<span class="codeline" id="line-298"><code>	if typ == nil {</code></span>
<span class="codeline" id="line-299"><code>		return Typ[Invalid]</code></span>
<span class="codeline" id="line-300"><code>	}</code></span>
<span class="codeline" id="line-301"><code>	return subst.typ(typ)</code></span>
<span class="codeline" id="line-302"><code>}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>func (subst *subster) var_(v *Var) *Var {</code></span>
<span class="codeline" id="line-305"><code>	if v != nil {</code></span>
<span class="codeline" id="line-306"><code>		if typ := subst.typ(v.typ); typ != v.typ {</code></span>
<span class="codeline" id="line-307"><code>			return substVar(v, typ)</code></span>
<span class="codeline" id="line-308"><code>		}</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	return v</code></span>
<span class="codeline" id="line-311"><code>}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>func substVar(v *Var, typ Type) *Var {</code></span>
<span class="codeline" id="line-314"><code>	copy := *v</code></span>
<span class="codeline" id="line-315"><code>	copy.typ = typ</code></span>
<span class="codeline" id="line-316"><code>	copy.origin = v.Origin()</code></span>
<span class="codeline" id="line-317"><code>	return &amp;copy</code></span>
<span class="codeline" id="line-318"><code>}</code></span>
<span class="codeline" id="line-319"><code></code></span>
<span class="codeline" id="line-320"><code>func (subst *subster) tuple(t *Tuple) *Tuple {</code></span>
<span class="codeline" id="line-321"><code>	if t != nil {</code></span>
<span class="codeline" id="line-322"><code>		if vars, copied := subst.varList(t.vars); copied {</code></span>
<span class="codeline" id="line-323"><code>			return &amp;Tuple{vars: vars}</code></span>
<span class="codeline" id="line-324"><code>		}</code></span>
<span class="codeline" id="line-325"><code>	}</code></span>
<span class="codeline" id="line-326"><code>	return t</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>func (subst *subster) varList(in []*Var) (out []*Var, copied bool) {</code></span>
<span class="codeline" id="line-330"><code>	out = in</code></span>
<span class="codeline" id="line-331"><code>	for i, v := range in {</code></span>
<span class="codeline" id="line-332"><code>		if w := subst.var_(v); w != v {</code></span>
<span class="codeline" id="line-333"><code>			if !copied {</code></span>
<span class="codeline" id="line-334"><code>				// first variable that got substituted =&gt; allocate new out slice</code></span>
<span class="codeline" id="line-335"><code>				// and copy all variables</code></span>
<span class="codeline" id="line-336"><code>				new := make([]*Var, len(in))</code></span>
<span class="codeline" id="line-337"><code>				copy(new, out)</code></span>
<span class="codeline" id="line-338"><code>				out = new</code></span>
<span class="codeline" id="line-339"><code>				copied = true</code></span>
<span class="codeline" id="line-340"><code>			}</code></span>
<span class="codeline" id="line-341"><code>			out[i] = w</code></span>
<span class="codeline" id="line-342"><code>		}</code></span>
<span class="codeline" id="line-343"><code>	}</code></span>
<span class="codeline" id="line-344"><code>	return</code></span>
<span class="codeline" id="line-345"><code>}</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>func (subst *subster) func_(f *Func) *Func {</code></span>
<span class="codeline" id="line-348"><code>	if f != nil {</code></span>
<span class="codeline" id="line-349"><code>		if typ := subst.typ(f.typ); typ != f.typ {</code></span>
<span class="codeline" id="line-350"><code>			return substFunc(f, typ)</code></span>
<span class="codeline" id="line-351"><code>		}</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code>	return f</code></span>
<span class="codeline" id="line-354"><code>}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>func substFunc(f *Func, typ Type) *Func {</code></span>
<span class="codeline" id="line-357"><code>	copy := *f</code></span>
<span class="codeline" id="line-358"><code>	copy.typ = typ</code></span>
<span class="codeline" id="line-359"><code>	copy.origin = f.Origin()</code></span>
<span class="codeline" id="line-360"><code>	return &amp;copy</code></span>
<span class="codeline" id="line-361"><code>}</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>func (subst *subster) funcList(in []*Func) (out []*Func, copied bool) {</code></span>
<span class="codeline" id="line-364"><code>	out = in</code></span>
<span class="codeline" id="line-365"><code>	for i, f := range in {</code></span>
<span class="codeline" id="line-366"><code>		if g := subst.func_(f); g != f {</code></span>
<span class="codeline" id="line-367"><code>			if !copied {</code></span>
<span class="codeline" id="line-368"><code>				// first function that got substituted =&gt; allocate new out slice</code></span>
<span class="codeline" id="line-369"><code>				// and copy all functions</code></span>
<span class="codeline" id="line-370"><code>				new := make([]*Func, len(in))</code></span>
<span class="codeline" id="line-371"><code>				copy(new, out)</code></span>
<span class="codeline" id="line-372"><code>				out = new</code></span>
<span class="codeline" id="line-373"><code>				copied = true</code></span>
<span class="codeline" id="line-374"><code>			}</code></span>
<span class="codeline" id="line-375"><code>			out[i] = g</code></span>
<span class="codeline" id="line-376"><code>		}</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	return</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>func (subst *subster) typeList(in []Type) (out []Type, copied bool) {</code></span>
<span class="codeline" id="line-382"><code>	out = in</code></span>
<span class="codeline" id="line-383"><code>	for i, t := range in {</code></span>
<span class="codeline" id="line-384"><code>		if u := subst.typ(t); u != t {</code></span>
<span class="codeline" id="line-385"><code>			if !copied {</code></span>
<span class="codeline" id="line-386"><code>				// first function that got substituted =&gt; allocate new out slice</code></span>
<span class="codeline" id="line-387"><code>				// and copy all functions</code></span>
<span class="codeline" id="line-388"><code>				new := make([]Type, len(in))</code></span>
<span class="codeline" id="line-389"><code>				copy(new, out)</code></span>
<span class="codeline" id="line-390"><code>				out = new</code></span>
<span class="codeline" id="line-391"><code>				copied = true</code></span>
<span class="codeline" id="line-392"><code>			}</code></span>
<span class="codeline" id="line-393"><code>			out[i] = u</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code>	return</code></span>
<span class="codeline" id="line-397"><code>}</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>func (subst *subster) termlist(in []*Term) (out []*Term, copied bool) {</code></span>
<span class="codeline" id="line-400"><code>	out = in</code></span>
<span class="codeline" id="line-401"><code>	for i, t := range in {</code></span>
<span class="codeline" id="line-402"><code>		if u := subst.typ(t.typ); u != t.typ {</code></span>
<span class="codeline" id="line-403"><code>			if !copied {</code></span>
<span class="codeline" id="line-404"><code>				// first function that got substituted =&gt; allocate new out slice</code></span>
<span class="codeline" id="line-405"><code>				// and copy all functions</code></span>
<span class="codeline" id="line-406"><code>				new := make([]*Term, len(in))</code></span>
<span class="codeline" id="line-407"><code>				copy(new, out)</code></span>
<span class="codeline" id="line-408"><code>				out = new</code></span>
<span class="codeline" id="line-409"><code>				copied = true</code></span>
<span class="codeline" id="line-410"><code>			}</code></span>
<span class="codeline" id="line-411"><code>			out[i] = NewTerm(t.tilde, u)</code></span>
<span class="codeline" id="line-412"><code>		}</code></span>
<span class="codeline" id="line-413"><code>	}</code></span>
<span class="codeline" id="line-414"><code>	return</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>// replaceRecvType updates any function receivers that have type old to have</code></span>
<span class="codeline" id="line-418"><code>// type new. It does not modify the input slice; if modifications are required,</code></span>
<span class="codeline" id="line-419"><code>// the input slice and any affected signatures will be copied before mutating.</code></span>
<span class="codeline" id="line-420"><code>//</code></span>
<span class="codeline" id="line-421"><code>// The resulting out slice contains the updated functions, and copied reports</code></span>
<span class="codeline" id="line-422"><code>// if anything was modified.</code></span>
<span class="codeline" id="line-423"><code>func replaceRecvType(in []*Func, old, new Type) (out []*Func, copied bool) {</code></span>
<span class="codeline" id="line-424"><code>	out = in</code></span>
<span class="codeline" id="line-425"><code>	for i, method := range in {</code></span>
<span class="codeline" id="line-426"><code>		sig := method.Type().(*Signature)</code></span>
<span class="codeline" id="line-427"><code>		if sig.recv != nil &amp;&amp; sig.recv.Type() == old {</code></span>
<span class="codeline" id="line-428"><code>			if !copied {</code></span>
<span class="codeline" id="line-429"><code>				// Allocate a new methods slice before mutating for the first time.</code></span>
<span class="codeline" id="line-430"><code>				// This is defensive, as we may share methods across instantiations of</code></span>
<span class="codeline" id="line-431"><code>				// a given interface type if they do not get substituted.</code></span>
<span class="codeline" id="line-432"><code>				out = make([]*Func, len(in))</code></span>
<span class="codeline" id="line-433"><code>				copy(out, in)</code></span>
<span class="codeline" id="line-434"><code>				copied = true</code></span>
<span class="codeline" id="line-435"><code>			}</code></span>
<span class="codeline" id="line-436"><code>			newsig := *sig</code></span>
<span class="codeline" id="line-437"><code>			newsig.recv = substVar(sig.recv, new)</code></span>
<span class="codeline" id="line-438"><code>			out[i] = substFunc(method, &amp;newsig)</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>	}</code></span>
<span class="codeline" id="line-441"><code>	return</code></span>
<span class="codeline" id="line-442"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>