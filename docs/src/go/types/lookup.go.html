<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: lookup.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	lookup.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// This file implements various field and method lookup functions.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>package types</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"bytes"</code></span>
<span class="codeline" id="line-13"><code>	"go/token"</code></span>
<span class="codeline" id="line-14"><code>	"strings"</code></span>
<span class="codeline" id="line-15"><code>)</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>// Internal use of LookupFieldOrMethod: If the obj result is a method</code></span>
<span class="codeline" id="line-18"><code>// associated with a concrete (non-interface) type, the method's signature</code></span>
<span class="codeline" id="line-19"><code>// may not be fully set up. Call Checker.objDecl(obj, nil) before accessing</code></span>
<span class="codeline" id="line-20"><code>// the method's type.</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// LookupFieldOrMethod looks up a field or method with given package and name</code></span>
<span class="codeline" id="line-23"><code>// in T and returns the corresponding *Var or *Func, an index sequence, and a</code></span>
<span class="codeline" id="line-24"><code>// bool indicating if there were any pointer indirections on the path to the</code></span>
<span class="codeline" id="line-25"><code>// field or method. If addressable is set, T is the type of an addressable</code></span>
<span class="codeline" id="line-26"><code>// variable (only matters for method lookups). T must not be nil.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>// The last index entry is the field or method index in the (possibly embedded)</code></span>
<span class="codeline" id="line-29"><code>// type where the entry was found, either:</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>//  1. the list of declared methods of a named type; or</code></span>
<span class="codeline" id="line-32"><code>//  2. the list of all methods (method set) of an interface type; or</code></span>
<span class="codeline" id="line-33"><code>//  3. the list of fields of a struct type.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// The earlier index entries are the indices of the embedded struct fields</code></span>
<span class="codeline" id="line-36"><code>// traversed to get to the found entry, starting at depth 0.</code></span>
<span class="codeline" id="line-37"><code>//</code></span>
<span class="codeline" id="line-38"><code>// If no entry is found, a nil object is returned. In this case, the returned</code></span>
<span class="codeline" id="line-39"><code>// index and indirect values have the following meaning:</code></span>
<span class="codeline" id="line-40"><code>//</code></span>
<span class="codeline" id="line-41"><code>//   - If index != nil, the index sequence points to an ambiguous entry</code></span>
<span class="codeline" id="line-42"><code>//     (the same name appeared more than once at the same embedding level).</code></span>
<span class="codeline" id="line-43"><code>//</code></span>
<span class="codeline" id="line-44"><code>//   - If indirect is set, a method with a pointer receiver type was found</code></span>
<span class="codeline" id="line-45"><code>//     but there was no pointer on the path from the actual receiver type to</code></span>
<span class="codeline" id="line-46"><code>//     the method's formal receiver base type, nor was the receiver addressable.</code></span>
<span class="codeline" id="line-47"><code>func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {</code></span>
<span class="codeline" id="line-48"><code>	if T == nil {</code></span>
<span class="codeline" id="line-49"><code>		panic("LookupFieldOrMethod on nil type")</code></span>
<span class="codeline" id="line-50"><code>	}</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>	// Methods cannot be associated to a named pointer type.</code></span>
<span class="codeline" id="line-53"><code>	// (spec: "The type denoted by T is called the receiver base type;</code></span>
<span class="codeline" id="line-54"><code>	// it must not be a pointer or interface type and it must be declared</code></span>
<span class="codeline" id="line-55"><code>	// in the same package as the method.").</code></span>
<span class="codeline" id="line-56"><code>	// Thus, if we have a named pointer type, proceed with the underlying</code></span>
<span class="codeline" id="line-57"><code>	// pointer type but discard the result if it is a method since we would</code></span>
<span class="codeline" id="line-58"><code>	// not have found it for T (see also go.dev/issue/8590).</code></span>
<span class="codeline" id="line-59"><code>	if t := asNamed(T); t != nil {</code></span>
<span class="codeline" id="line-60"><code>		if p, _ := t.Underlying().(*Pointer); p != nil {</code></span>
<span class="codeline" id="line-61"><code>			obj, index, indirect = lookupFieldOrMethodImpl(p, false, pkg, name, false)</code></span>
<span class="codeline" id="line-62"><code>			if _, ok := obj.(*Func); ok {</code></span>
<span class="codeline" id="line-63"><code>				return nil, nil, false</code></span>
<span class="codeline" id="line-64"><code>			}</code></span>
<span class="codeline" id="line-65"><code>			return</code></span>
<span class="codeline" id="line-66"><code>		}</code></span>
<span class="codeline" id="line-67"><code>	}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>	obj, index, indirect = lookupFieldOrMethodImpl(T, addressable, pkg, name, false)</code></span>
<span class="codeline" id="line-70"><code></code></span>
<span class="codeline" id="line-71"><code>	// If we didn't find anything and if we have a type parameter with a core type,</code></span>
<span class="codeline" id="line-72"><code>	// see if there is a matching field (but not a method, those need to be declared</code></span>
<span class="codeline" id="line-73"><code>	// explicitly in the constraint). If the constraint is a named pointer type (see</code></span>
<span class="codeline" id="line-74"><code>	// above), we are ok here because only fields are accepted as results.</code></span>
<span class="codeline" id="line-75"><code>	const enableTParamFieldLookup = false // see go.dev/issue/51576</code></span>
<span class="codeline" id="line-76"><code>	if enableTParamFieldLookup &amp;&amp; obj == nil &amp;&amp; isTypeParam(T) {</code></span>
<span class="codeline" id="line-77"><code>		if t := coreType(T); t != nil {</code></span>
<span class="codeline" id="line-78"><code>			obj, index, indirect = lookupFieldOrMethodImpl(t, addressable, pkg, name, false)</code></span>
<span class="codeline" id="line-79"><code>			if _, ok := obj.(*Var); !ok {</code></span>
<span class="codeline" id="line-80"><code>				obj, index, indirect = nil, nil, false // accept fields (variables) only</code></span>
<span class="codeline" id="line-81"><code>			}</code></span>
<span class="codeline" id="line-82"><code>		}</code></span>
<span class="codeline" id="line-83"><code>	}</code></span>
<span class="codeline" id="line-84"><code>	return</code></span>
<span class="codeline" id="line-85"><code>}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>// lookupFieldOrMethodImpl is the implementation of LookupFieldOrMethod.</code></span>
<span class="codeline" id="line-88"><code>// Notably, in contrast to LookupFieldOrMethod, it won't find struct fields</code></span>
<span class="codeline" id="line-89"><code>// in base types of defined (*Named) pointer types T. For instance, given</code></span>
<span class="codeline" id="line-90"><code>// the declaration:</code></span>
<span class="codeline" id="line-91"><code>//</code></span>
<span class="codeline" id="line-92"><code>//	type T *struct{f int}</code></span>
<span class="codeline" id="line-93"><code>//</code></span>
<span class="codeline" id="line-94"><code>// lookupFieldOrMethodImpl won't find the field f in the defined (*Named) type T</code></span>
<span class="codeline" id="line-95"><code>// (methods on T are not permitted in the first place).</code></span>
<span class="codeline" id="line-96"><code>//</code></span>
<span class="codeline" id="line-97"><code>// Thus, lookupFieldOrMethodImpl should only be called by LookupFieldOrMethod</code></span>
<span class="codeline" id="line-98"><code>// and missingMethod (the latter doesn't care about struct fields).</code></span>
<span class="codeline" id="line-99"><code>//</code></span>
<span class="codeline" id="line-100"><code>// If foldCase is true, method names are considered equal if they are equal</code></span>
<span class="codeline" id="line-101"><code>// with case folding, irrespective of which package they are in.</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>// The resulting object may not be fully type-checked.</code></span>
<span class="codeline" id="line-104"><code>func lookupFieldOrMethodImpl(T Type, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool) {</code></span>
<span class="codeline" id="line-105"><code>	// WARNING: The code in this function is extremely subtle - do not modify casually!</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	if name == "_" {</code></span>
<span class="codeline" id="line-108"><code>		return // blank fields/methods are never found</code></span>
<span class="codeline" id="line-109"><code>	}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>	// Importantly, we must not call under before the call to deref below (nor</code></span>
<span class="codeline" id="line-112"><code>	// does deref call under), as doing so could incorrectly result in finding</code></span>
<span class="codeline" id="line-113"><code>	// methods of the pointer base type when T is a (*Named) pointer type.</code></span>
<span class="codeline" id="line-114"><code>	typ, isPtr := deref(T)</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>	// *typ where typ is an interface (incl. a type parameter) has no methods.</code></span>
<span class="codeline" id="line-117"><code>	if isPtr {</code></span>
<span class="codeline" id="line-118"><code>		if _, ok := under(typ).(*Interface); ok {</code></span>
<span class="codeline" id="line-119"><code>			return</code></span>
<span class="codeline" id="line-120"><code>		}</code></span>
<span class="codeline" id="line-121"><code>	}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>	// Start with typ as single entry at shallowest depth.</code></span>
<span class="codeline" id="line-124"><code>	current := []embeddedType{{typ, nil, isPtr, false}}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>	// seen tracks named types that we have seen already, allocated lazily.</code></span>
<span class="codeline" id="line-127"><code>	// Used to avoid endless searches in case of recursive types.</code></span>
<span class="codeline" id="line-128"><code>	//</code></span>
<span class="codeline" id="line-129"><code>	// We must use a lookup on identity rather than a simple map[*Named]bool as</code></span>
<span class="codeline" id="line-130"><code>	// instantiated types may be identical but not equal.</code></span>
<span class="codeline" id="line-131"><code>	var seen instanceLookup</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>	// search current depth</code></span>
<span class="codeline" id="line-134"><code>	for len(current) &gt; 0 {</code></span>
<span class="codeline" id="line-135"><code>		var next []embeddedType // embedded types found at current depth</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>		// look for (pkg, name) in all types at current depth</code></span>
<span class="codeline" id="line-138"><code>		for _, e := range current {</code></span>
<span class="codeline" id="line-139"><code>			typ := e.typ</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>			// If we have a named type, we may have associated methods.</code></span>
<span class="codeline" id="line-142"><code>			// Look for those first.</code></span>
<span class="codeline" id="line-143"><code>			if named := asNamed(typ); named != nil {</code></span>
<span class="codeline" id="line-144"><code>				if alt := seen.lookup(named); alt != nil {</code></span>
<span class="codeline" id="line-145"><code>					// We have seen this type before, at a more shallow depth</code></span>
<span class="codeline" id="line-146"><code>					// (note that multiples of this type at the current depth</code></span>
<span class="codeline" id="line-147"><code>					// were consolidated before). The type at that depth shadows</code></span>
<span class="codeline" id="line-148"><code>					// this same type at the current depth, so we can ignore</code></span>
<span class="codeline" id="line-149"><code>					// this one.</code></span>
<span class="codeline" id="line-150"><code>					continue</code></span>
<span class="codeline" id="line-151"><code>				}</code></span>
<span class="codeline" id="line-152"><code>				seen.add(named)</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>				// look for a matching attached method</code></span>
<span class="codeline" id="line-155"><code>				if i, m := named.lookupMethod(pkg, name, foldCase); m != nil {</code></span>
<span class="codeline" id="line-156"><code>					// potential match</code></span>
<span class="codeline" id="line-157"><code>					// caution: method may not have a proper signature yet</code></span>
<span class="codeline" id="line-158"><code>					index = concat(e.index, i)</code></span>
<span class="codeline" id="line-159"><code>					if obj != nil || e.multiples {</code></span>
<span class="codeline" id="line-160"><code>						return nil, index, false // collision</code></span>
<span class="codeline" id="line-161"><code>					}</code></span>
<span class="codeline" id="line-162"><code>					obj = m</code></span>
<span class="codeline" id="line-163"><code>					indirect = e.indirect</code></span>
<span class="codeline" id="line-164"><code>					continue // we can't have a matching field or interface method</code></span>
<span class="codeline" id="line-165"><code>				}</code></span>
<span class="codeline" id="line-166"><code>			}</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>			switch t := under(typ).(type) {</code></span>
<span class="codeline" id="line-169"><code>			case *Struct:</code></span>
<span class="codeline" id="line-170"><code>				// look for a matching field and collect embedded types</code></span>
<span class="codeline" id="line-171"><code>				for i, f := range t.fields {</code></span>
<span class="codeline" id="line-172"><code>					if f.sameId(pkg, name) {</code></span>
<span class="codeline" id="line-173"><code>						assert(f.typ != nil)</code></span>
<span class="codeline" id="line-174"><code>						index = concat(e.index, i)</code></span>
<span class="codeline" id="line-175"><code>						if obj != nil || e.multiples {</code></span>
<span class="codeline" id="line-176"><code>							return nil, index, false // collision</code></span>
<span class="codeline" id="line-177"><code>						}</code></span>
<span class="codeline" id="line-178"><code>						obj = f</code></span>
<span class="codeline" id="line-179"><code>						indirect = e.indirect</code></span>
<span class="codeline" id="line-180"><code>						continue // we can't have a matching interface method</code></span>
<span class="codeline" id="line-181"><code>					}</code></span>
<span class="codeline" id="line-182"><code>					// Collect embedded struct fields for searching the next</code></span>
<span class="codeline" id="line-183"><code>					// lower depth, but only if we have not seen a match yet</code></span>
<span class="codeline" id="line-184"><code>					// (if we have a match it is either the desired field or</code></span>
<span class="codeline" id="line-185"><code>					// we have a name collision on the same depth; in either</code></span>
<span class="codeline" id="line-186"><code>					// case we don't need to look further).</code></span>
<span class="codeline" id="line-187"><code>					// Embedded fields are always of the form T or *T where</code></span>
<span class="codeline" id="line-188"><code>					// T is a type name. If e.typ appeared multiple times at</code></span>
<span class="codeline" id="line-189"><code>					// this depth, f.typ appears multiple times at the next</code></span>
<span class="codeline" id="line-190"><code>					// depth.</code></span>
<span class="codeline" id="line-191"><code>					if obj == nil &amp;&amp; f.embedded {</code></span>
<span class="codeline" id="line-192"><code>						typ, isPtr := deref(f.typ)</code></span>
<span class="codeline" id="line-193"><code>						// TODO(gri) optimization: ignore types that can't</code></span>
<span class="codeline" id="line-194"><code>						// have fields or methods (only Named, Struct, and</code></span>
<span class="codeline" id="line-195"><code>						// Interface types need to be considered).</code></span>
<span class="codeline" id="line-196"><code>						next = append(next, embeddedType{typ, concat(e.index, i), e.indirect || isPtr, e.multiples})</code></span>
<span class="codeline" id="line-197"><code>					}</code></span>
<span class="codeline" id="line-198"><code>				}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>			case *Interface:</code></span>
<span class="codeline" id="line-201"><code>				// look for a matching method (interface may be a type parameter)</code></span>
<span class="codeline" id="line-202"><code>				if i, m := t.typeSet().LookupMethod(pkg, name, foldCase); m != nil {</code></span>
<span class="codeline" id="line-203"><code>					assert(m.typ != nil)</code></span>
<span class="codeline" id="line-204"><code>					index = concat(e.index, i)</code></span>
<span class="codeline" id="line-205"><code>					if obj != nil || e.multiples {</code></span>
<span class="codeline" id="line-206"><code>						return nil, index, false // collision</code></span>
<span class="codeline" id="line-207"><code>					}</code></span>
<span class="codeline" id="line-208"><code>					obj = m</code></span>
<span class="codeline" id="line-209"><code>					indirect = e.indirect</code></span>
<span class="codeline" id="line-210"><code>				}</code></span>
<span class="codeline" id="line-211"><code>			}</code></span>
<span class="codeline" id="line-212"><code>		}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>		if obj != nil {</code></span>
<span class="codeline" id="line-215"><code>			// found a potential match</code></span>
<span class="codeline" id="line-216"><code>			// spec: "A method call x.m() is valid if the method set of (the type of) x</code></span>
<span class="codeline" id="line-217"><code>			//        contains m and the argument list can be assigned to the parameter</code></span>
<span class="codeline" id="line-218"><code>			//        list of m. If x is addressable and &amp;x's method set contains m, x.m()</code></span>
<span class="codeline" id="line-219"><code>			//        is shorthand for (&amp;x).m()".</code></span>
<span class="codeline" id="line-220"><code>			if f, _ := obj.(*Func); f != nil {</code></span>
<span class="codeline" id="line-221"><code>				// determine if method has a pointer receiver</code></span>
<span class="codeline" id="line-222"><code>				if f.hasPtrRecv() &amp;&amp; !indirect &amp;&amp; !addressable {</code></span>
<span class="codeline" id="line-223"><code>					return nil, nil, true // pointer/addressable receiver required</code></span>
<span class="codeline" id="line-224"><code>				}</code></span>
<span class="codeline" id="line-225"><code>			}</code></span>
<span class="codeline" id="line-226"><code>			return</code></span>
<span class="codeline" id="line-227"><code>		}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>		current = consolidateMultiples(next)</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>	return nil, nil, false // not found</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>// embeddedType represents an embedded type</code></span>
<span class="codeline" id="line-236"><code>type embeddedType struct {</code></span>
<span class="codeline" id="line-237"><code>	typ       Type</code></span>
<span class="codeline" id="line-238"><code>	index     []int // embedded field indices, starting with index at depth 0</code></span>
<span class="codeline" id="line-239"><code>	indirect  bool  // if set, there was a pointer indirection on the path to this field</code></span>
<span class="codeline" id="line-240"><code>	multiples bool  // if set, typ appears multiple times at this depth</code></span>
<span class="codeline" id="line-241"><code>}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>// consolidateMultiples collects multiple list entries with the same type</code></span>
<span class="codeline" id="line-244"><code>// into a single entry marked as containing multiples. The result is the</code></span>
<span class="codeline" id="line-245"><code>// consolidated list.</code></span>
<span class="codeline" id="line-246"><code>func consolidateMultiples(list []embeddedType) []embeddedType {</code></span>
<span class="codeline" id="line-247"><code>	if len(list) &lt;= 1 {</code></span>
<span class="codeline" id="line-248"><code>		return list // at most one entry - nothing to do</code></span>
<span class="codeline" id="line-249"><code>	}</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>	n := 0                     // number of entries w/ unique type</code></span>
<span class="codeline" id="line-252"><code>	prev := make(map[Type]int) // index at which type was previously seen</code></span>
<span class="codeline" id="line-253"><code>	for _, e := range list {</code></span>
<span class="codeline" id="line-254"><code>		if i, found := lookupType(prev, e.typ); found {</code></span>
<span class="codeline" id="line-255"><code>			list[i].multiples = true</code></span>
<span class="codeline" id="line-256"><code>			// ignore this entry</code></span>
<span class="codeline" id="line-257"><code>		} else {</code></span>
<span class="codeline" id="line-258"><code>			prev[e.typ] = n</code></span>
<span class="codeline" id="line-259"><code>			list[n] = e</code></span>
<span class="codeline" id="line-260"><code>			n++</code></span>
<span class="codeline" id="line-261"><code>		}</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code>	return list[:n]</code></span>
<span class="codeline" id="line-264"><code>}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>func lookupType(m map[Type]int, typ Type) (int, bool) {</code></span>
<span class="codeline" id="line-267"><code>	// fast path: maybe the types are equal</code></span>
<span class="codeline" id="line-268"><code>	if i, found := m[typ]; found {</code></span>
<span class="codeline" id="line-269"><code>		return i, true</code></span>
<span class="codeline" id="line-270"><code>	}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>	for t, i := range m {</code></span>
<span class="codeline" id="line-273"><code>		if Identical(t, typ) {</code></span>
<span class="codeline" id="line-274"><code>			return i, true</code></span>
<span class="codeline" id="line-275"><code>		}</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>	return 0, false</code></span>
<span class="codeline" id="line-279"><code>}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>type instanceLookup struct {</code></span>
<span class="codeline" id="line-282"><code>	// buf is used to avoid allocating the map m in the common case of a small</code></span>
<span class="codeline" id="line-283"><code>	// number of instances.</code></span>
<span class="codeline" id="line-284"><code>	buf [3]*Named</code></span>
<span class="codeline" id="line-285"><code>	m   map[*Named][]*Named</code></span>
<span class="codeline" id="line-286"><code>}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>func (l *instanceLookup) lookup(inst *Named) *Named {</code></span>
<span class="codeline" id="line-289"><code>	for _, t := range l.buf {</code></span>
<span class="codeline" id="line-290"><code>		if t != nil &amp;&amp; Identical(inst, t) {</code></span>
<span class="codeline" id="line-291"><code>			return t</code></span>
<span class="codeline" id="line-292"><code>		}</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	for _, t := range l.m[inst.Origin()] {</code></span>
<span class="codeline" id="line-295"><code>		if Identical(inst, t) {</code></span>
<span class="codeline" id="line-296"><code>			return t</code></span>
<span class="codeline" id="line-297"><code>		}</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	return nil</code></span>
<span class="codeline" id="line-300"><code>}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>func (l *instanceLookup) add(inst *Named) {</code></span>
<span class="codeline" id="line-303"><code>	for i, t := range l.buf {</code></span>
<span class="codeline" id="line-304"><code>		if t == nil {</code></span>
<span class="codeline" id="line-305"><code>			l.buf[i] = inst</code></span>
<span class="codeline" id="line-306"><code>			return</code></span>
<span class="codeline" id="line-307"><code>		}</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>	if l.m == nil {</code></span>
<span class="codeline" id="line-310"><code>		l.m = make(map[*Named][]*Named)</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code>	insts := l.m[inst.Origin()]</code></span>
<span class="codeline" id="line-313"><code>	l.m[inst.Origin()] = append(insts, inst)</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>// MissingMethod returns (nil, false) if V implements T, otherwise it</code></span>
<span class="codeline" id="line-317"><code>// returns a missing method required by T and whether it is missing or</code></span>
<span class="codeline" id="line-318"><code>// just has the wrong type: either a pointer receiver or wrong signature.</code></span>
<span class="codeline" id="line-319"><code>//</code></span>
<span class="codeline" id="line-320"><code>// For non-interface types V, or if static is set, V implements T if all</code></span>
<span class="codeline" id="line-321"><code>// methods of T are present in V. Otherwise (V is an interface and static</code></span>
<span class="codeline" id="line-322"><code>// is not set), MissingMethod only checks that methods of T which are also</code></span>
<span class="codeline" id="line-323"><code>// present in V have matching types (e.g., for a type assertion x.(T) where</code></span>
<span class="codeline" id="line-324"><code>// x is of interface type V).</code></span>
<span class="codeline" id="line-325"><code>func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool) {</code></span>
<span class="codeline" id="line-326"><code>	return (*Checker)(nil).missingMethod(V, T, static, Identical, nil)</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>// missingMethod is like MissingMethod but accepts a *Checker as receiver,</code></span>
<span class="codeline" id="line-330"><code>// a comparator equivalent for type comparison, and a *string for error causes.</code></span>
<span class="codeline" id="line-331"><code>// The receiver may be nil if missingMethod is invoked through an exported</code></span>
<span class="codeline" id="line-332"><code>// API call (such as MissingMethod), i.e., when all methods have been type-</code></span>
<span class="codeline" id="line-333"><code>// checked.</code></span>
<span class="codeline" id="line-334"><code>// The underlying type of T must be an interface; T (rather than its under-</code></span>
<span class="codeline" id="line-335"><code>// lying type) is used for better error messages (reported through *cause).</code></span>
<span class="codeline" id="line-336"><code>// The comparator is used to compare signatures.</code></span>
<span class="codeline" id="line-337"><code>// If a method is missing and cause is not nil, *cause describes the error.</code></span>
<span class="codeline" id="line-338"><code>func (check *Checker) missingMethod(V, T Type, static bool, equivalent func(x, y Type) bool, cause *string) (method *Func, wrongType bool) {</code></span>
<span class="codeline" id="line-339"><code>	methods := under(T).(*Interface).typeSet().methods // T must be an interface</code></span>
<span class="codeline" id="line-340"><code>	if len(methods) == 0 {</code></span>
<span class="codeline" id="line-341"><code>		return nil, false</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>	const (</code></span>
<span class="codeline" id="line-345"><code>		ok = iota</code></span>
<span class="codeline" id="line-346"><code>		notFound</code></span>
<span class="codeline" id="line-347"><code>		wrongName</code></span>
<span class="codeline" id="line-348"><code>		unexported</code></span>
<span class="codeline" id="line-349"><code>		wrongSig</code></span>
<span class="codeline" id="line-350"><code>		ambigSel</code></span>
<span class="codeline" id="line-351"><code>		ptrRecv</code></span>
<span class="codeline" id="line-352"><code>		field</code></span>
<span class="codeline" id="line-353"><code>	)</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>	state := ok</code></span>
<span class="codeline" id="line-356"><code>	var m *Func // method on T we're trying to implement</code></span>
<span class="codeline" id="line-357"><code>	var f *Func // method on V, if found (state is one of ok, wrongName, wrongSig)</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>	if u, _ := under(V).(*Interface); u != nil {</code></span>
<span class="codeline" id="line-360"><code>		tset := u.typeSet()</code></span>
<span class="codeline" id="line-361"><code>		for _, m = range methods {</code></span>
<span class="codeline" id="line-362"><code>			_, f = tset.LookupMethod(m.pkg, m.name, false)</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>			if f == nil {</code></span>
<span class="codeline" id="line-365"><code>				if !static {</code></span>
<span class="codeline" id="line-366"><code>					continue</code></span>
<span class="codeline" id="line-367"><code>				}</code></span>
<span class="codeline" id="line-368"><code>				state = notFound</code></span>
<span class="codeline" id="line-369"><code>				break</code></span>
<span class="codeline" id="line-370"><code>			}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>			if !equivalent(f.typ, m.typ) {</code></span>
<span class="codeline" id="line-373"><code>				state = wrongSig</code></span>
<span class="codeline" id="line-374"><code>				break</code></span>
<span class="codeline" id="line-375"><code>			}</code></span>
<span class="codeline" id="line-376"><code>		}</code></span>
<span class="codeline" id="line-377"><code>	} else {</code></span>
<span class="codeline" id="line-378"><code>		for _, m = range methods {</code></span>
<span class="codeline" id="line-379"><code>			obj, index, indirect := lookupFieldOrMethodImpl(V, false, m.pkg, m.name, false)</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>			// check if m is ambiguous, on *V, or on V with case-folding</code></span>
<span class="codeline" id="line-382"><code>			if obj == nil {</code></span>
<span class="codeline" id="line-383"><code>				switch {</code></span>
<span class="codeline" id="line-384"><code>				case index != nil:</code></span>
<span class="codeline" id="line-385"><code>					state = ambigSel</code></span>
<span class="codeline" id="line-386"><code>				case indirect:</code></span>
<span class="codeline" id="line-387"><code>					state = ptrRecv</code></span>
<span class="codeline" id="line-388"><code>				default:</code></span>
<span class="codeline" id="line-389"><code>					state = notFound</code></span>
<span class="codeline" id="line-390"><code>					obj, _, _ = lookupFieldOrMethodImpl(V, false, m.pkg, m.name, true /* fold case */)</code></span>
<span class="codeline" id="line-391"><code>					f, _ = obj.(*Func)</code></span>
<span class="codeline" id="line-392"><code>					if f != nil {</code></span>
<span class="codeline" id="line-393"><code>						state = wrongName</code></span>
<span class="codeline" id="line-394"><code>						if f.name == m.name {</code></span>
<span class="codeline" id="line-395"><code>							// If the names are equal, f must be unexported</code></span>
<span class="codeline" id="line-396"><code>							// (otherwise the package wouldn't matter).</code></span>
<span class="codeline" id="line-397"><code>							state = unexported</code></span>
<span class="codeline" id="line-398"><code>						}</code></span>
<span class="codeline" id="line-399"><code>					}</code></span>
<span class="codeline" id="line-400"><code>				}</code></span>
<span class="codeline" id="line-401"><code>				break</code></span>
<span class="codeline" id="line-402"><code>			}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>			// we must have a method (not a struct field)</code></span>
<span class="codeline" id="line-405"><code>			f, _ = obj.(*Func)</code></span>
<span class="codeline" id="line-406"><code>			if f == nil {</code></span>
<span class="codeline" id="line-407"><code>				state = field</code></span>
<span class="codeline" id="line-408"><code>				break</code></span>
<span class="codeline" id="line-409"><code>			}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>			// methods may not have a fully set up signature yet</code></span>
<span class="codeline" id="line-412"><code>			if check != nil {</code></span>
<span class="codeline" id="line-413"><code>				check.objDecl(f, nil)</code></span>
<span class="codeline" id="line-414"><code>			}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>			if !equivalent(f.typ, m.typ) {</code></span>
<span class="codeline" id="line-417"><code>				state = wrongSig</code></span>
<span class="codeline" id="line-418"><code>				break</code></span>
<span class="codeline" id="line-419"><code>			}</code></span>
<span class="codeline" id="line-420"><code>		}</code></span>
<span class="codeline" id="line-421"><code>	}</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>	if state == ok {</code></span>
<span class="codeline" id="line-424"><code>		return nil, false</code></span>
<span class="codeline" id="line-425"><code>	}</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>	if cause != nil {</code></span>
<span class="codeline" id="line-428"><code>		if f != nil {</code></span>
<span class="codeline" id="line-429"><code>			// This method may be formatted in funcString below, so must have a fully</code></span>
<span class="codeline" id="line-430"><code>			// set up signature.</code></span>
<span class="codeline" id="line-431"><code>			if check != nil {</code></span>
<span class="codeline" id="line-432"><code>				check.objDecl(f, nil)</code></span>
<span class="codeline" id="line-433"><code>			}</code></span>
<span class="codeline" id="line-434"><code>		}</code></span>
<span class="codeline" id="line-435"><code>		switch state {</code></span>
<span class="codeline" id="line-436"><code>		case notFound:</code></span>
<span class="codeline" id="line-437"><code>			switch {</code></span>
<span class="codeline" id="line-438"><code>			case isInterfacePtr(V):</code></span>
<span class="codeline" id="line-439"><code>				*cause = "(" + check.interfacePtrError(V) + ")"</code></span>
<span class="codeline" id="line-440"><code>			case isInterfacePtr(T):</code></span>
<span class="codeline" id="line-441"><code>				*cause = "(" + check.interfacePtrError(T) + ")"</code></span>
<span class="codeline" id="line-442"><code>			default:</code></span>
<span class="codeline" id="line-443"><code>				*cause = check.sprintf("(missing method %s)", m.Name())</code></span>
<span class="codeline" id="line-444"><code>			}</code></span>
<span class="codeline" id="line-445"><code>		case wrongName:</code></span>
<span class="codeline" id="line-446"><code>			fs, ms := check.funcString(f, false), check.funcString(m, false)</code></span>
<span class="codeline" id="line-447"><code>			*cause = check.sprintf("(missing method %s)\n\t\thave %s\n\t\twant %s", m.Name(), fs, ms)</code></span>
<span class="codeline" id="line-448"><code>		case unexported:</code></span>
<span class="codeline" id="line-449"><code>			*cause = check.sprintf("(unexported method %s)", m.Name())</code></span>
<span class="codeline" id="line-450"><code>		case wrongSig:</code></span>
<span class="codeline" id="line-451"><code>			fs, ms := check.funcString(f, false), check.funcString(m, false)</code></span>
<span class="codeline" id="line-452"><code>			if fs == ms {</code></span>
<span class="codeline" id="line-453"><code>				// Don't report "want Foo, have Foo".</code></span>
<span class="codeline" id="line-454"><code>				// Add package information to disambiguate (go.dev/issue/54258).</code></span>
<span class="codeline" id="line-455"><code>				fs, ms = check.funcString(f, true), check.funcString(m, true)</code></span>
<span class="codeline" id="line-456"><code>			}</code></span>
<span class="codeline" id="line-457"><code>			if fs == ms {</code></span>
<span class="codeline" id="line-458"><code>				// We still have "want Foo, have Foo".</code></span>
<span class="codeline" id="line-459"><code>				// This is most likely due to different type parameters with</code></span>
<span class="codeline" id="line-460"><code>				// the same name appearing in the instantiated signatures</code></span>
<span class="codeline" id="line-461"><code>				// (go.dev/issue/61685).</code></span>
<span class="codeline" id="line-462"><code>				// Rather than reporting this misleading error cause, for now</code></span>
<span class="codeline" id="line-463"><code>				// just point out that the method signature is incorrect.</code></span>
<span class="codeline" id="line-464"><code>				// TODO(gri) should find a good way to report the root cause</code></span>
<span class="codeline" id="line-465"><code>				*cause = check.sprintf("(wrong type for method %s)", m.Name())</code></span>
<span class="codeline" id="line-466"><code>				break</code></span>
<span class="codeline" id="line-467"><code>			}</code></span>
<span class="codeline" id="line-468"><code>			*cause = check.sprintf("(wrong type for method %s)\n\t\thave %s\n\t\twant %s", m.Name(), fs, ms)</code></span>
<span class="codeline" id="line-469"><code>		case ambigSel:</code></span>
<span class="codeline" id="line-470"><code>			*cause = check.sprintf("(ambiguous selector %s.%s)", V, m.Name())</code></span>
<span class="codeline" id="line-471"><code>		case ptrRecv:</code></span>
<span class="codeline" id="line-472"><code>			*cause = check.sprintf("(method %s has pointer receiver)", m.Name())</code></span>
<span class="codeline" id="line-473"><code>		case field:</code></span>
<span class="codeline" id="line-474"><code>			*cause = check.sprintf("(%s.%s is a field, not a method)", V, m.Name())</code></span>
<span class="codeline" id="line-475"><code>		default:</code></span>
<span class="codeline" id="line-476"><code>			unreachable()</code></span>
<span class="codeline" id="line-477"><code>		}</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	return m, state == wrongSig || state == ptrRecv</code></span>
<span class="codeline" id="line-481"><code>}</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>func isInterfacePtr(T Type) bool {</code></span>
<span class="codeline" id="line-484"><code>	p, _ := under(T).(*Pointer)</code></span>
<span class="codeline" id="line-485"><code>	return p != nil &amp;&amp; IsInterface(p.base)</code></span>
<span class="codeline" id="line-486"><code>}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>// check may be nil.</code></span>
<span class="codeline" id="line-489"><code>func (check *Checker) interfacePtrError(T Type) string {</code></span>
<span class="codeline" id="line-490"><code>	assert(isInterfacePtr(T))</code></span>
<span class="codeline" id="line-491"><code>	if p, _ := under(T).(*Pointer); isTypeParam(p.base) {</code></span>
<span class="codeline" id="line-492"><code>		return check.sprintf("type %s is pointer to type parameter, not type parameter", T)</code></span>
<span class="codeline" id="line-493"><code>	}</code></span>
<span class="codeline" id="line-494"><code>	return check.sprintf("type %s is pointer to interface, not interface", T)</code></span>
<span class="codeline" id="line-495"><code>}</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>// funcString returns a string of the form name + signature for f.</code></span>
<span class="codeline" id="line-498"><code>// check may be nil.</code></span>
<span class="codeline" id="line-499"><code>func (check *Checker) funcString(f *Func, pkgInfo bool) string {</code></span>
<span class="codeline" id="line-500"><code>	buf := bytes.NewBufferString(f.name)</code></span>
<span class="codeline" id="line-501"><code>	var qf Qualifier</code></span>
<span class="codeline" id="line-502"><code>	if check != nil &amp;&amp; !pkgInfo {</code></span>
<span class="codeline" id="line-503"><code>		qf = check.qualifier</code></span>
<span class="codeline" id="line-504"><code>	}</code></span>
<span class="codeline" id="line-505"><code>	w := newTypeWriter(buf, qf)</code></span>
<span class="codeline" id="line-506"><code>	w.pkgInfo = pkgInfo</code></span>
<span class="codeline" id="line-507"><code>	w.paramNames = false</code></span>
<span class="codeline" id="line-508"><code>	w.signature(f.typ.(*Signature))</code></span>
<span class="codeline" id="line-509"><code>	return buf.String()</code></span>
<span class="codeline" id="line-510"><code>}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>// assertableTo reports whether a value of type V can be asserted to have type T.</code></span>
<span class="codeline" id="line-513"><code>// The receiver may be nil if assertableTo is invoked through an exported API call</code></span>
<span class="codeline" id="line-514"><code>// (such as AssertableTo), i.e., when all methods have been type-checked.</code></span>
<span class="codeline" id="line-515"><code>// The underlying type of V must be an interface.</code></span>
<span class="codeline" id="line-516"><code>// If the result is false and cause is not nil, *cause describes the error.</code></span>
<span class="codeline" id="line-517"><code>// TODO(gri) replace calls to this function with calls to newAssertableTo.</code></span>
<span class="codeline" id="line-518"><code>func (check *Checker) assertableTo(V, T Type, cause *string) bool {</code></span>
<span class="codeline" id="line-519"><code>	// no static check is required if T is an interface</code></span>
<span class="codeline" id="line-520"><code>	// spec: "If T is an interface type, x.(T) asserts that the</code></span>
<span class="codeline" id="line-521"><code>	//        dynamic type of x implements the interface T."</code></span>
<span class="codeline" id="line-522"><code>	if IsInterface(T) {</code></span>
<span class="codeline" id="line-523"><code>		return true</code></span>
<span class="codeline" id="line-524"><code>	}</code></span>
<span class="codeline" id="line-525"><code>	// TODO(gri) fix this for generalized interfaces</code></span>
<span class="codeline" id="line-526"><code>	m, _ := check.missingMethod(T, V, false, Identical, cause)</code></span>
<span class="codeline" id="line-527"><code>	return m == nil</code></span>
<span class="codeline" id="line-528"><code>}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>// newAssertableTo reports whether a value of type V can be asserted to have type T.</code></span>
<span class="codeline" id="line-531"><code>// It also implements behavior for interfaces that currently are only permitted</code></span>
<span class="codeline" id="line-532"><code>// in constraint position (we have not yet defined that behavior in the spec).</code></span>
<span class="codeline" id="line-533"><code>// The underlying type of V must be an interface.</code></span>
<span class="codeline" id="line-534"><code>// If the result is false and cause is not nil, *cause is set to the error cause.</code></span>
<span class="codeline" id="line-535"><code>func (check *Checker) newAssertableTo(pos token.Pos, V, T Type, cause *string) bool {</code></span>
<span class="codeline" id="line-536"><code>	// no static check is required if T is an interface</code></span>
<span class="codeline" id="line-537"><code>	// spec: "If T is an interface type, x.(T) asserts that the</code></span>
<span class="codeline" id="line-538"><code>	//        dynamic type of x implements the interface T."</code></span>
<span class="codeline" id="line-539"><code>	if IsInterface(T) {</code></span>
<span class="codeline" id="line-540"><code>		return true</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code>	return check.implements(pos, T, V, false, cause)</code></span>
<span class="codeline" id="line-543"><code>}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>// deref dereferences typ if it is a *Pointer (but not a *Named type</code></span>
<span class="codeline" id="line-546"><code>// with an underlying pointer type!) and returns its base and true.</code></span>
<span class="codeline" id="line-547"><code>// Otherwise it returns (typ, false).</code></span>
<span class="codeline" id="line-548"><code>func deref(typ Type) (Type, bool) {</code></span>
<span class="codeline" id="line-549"><code>	if p, _ := Unalias(typ).(*Pointer); p != nil {</code></span>
<span class="codeline" id="line-550"><code>		// p.base should never be nil, but be conservative</code></span>
<span class="codeline" id="line-551"><code>		if p.base == nil {</code></span>
<span class="codeline" id="line-552"><code>			if debug {</code></span>
<span class="codeline" id="line-553"><code>				panic("pointer with nil base type (possibly due to an invalid cyclic declaration)")</code></span>
<span class="codeline" id="line-554"><code>			}</code></span>
<span class="codeline" id="line-555"><code>			return Typ[Invalid], true</code></span>
<span class="codeline" id="line-556"><code>		}</code></span>
<span class="codeline" id="line-557"><code>		return p.base, true</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code>	return typ, false</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a</code></span>
<span class="codeline" id="line-563"><code>// (named or unnamed) struct and returns its base. Otherwise it returns typ.</code></span>
<span class="codeline" id="line-564"><code>func derefStructPtr(typ Type) Type {</code></span>
<span class="codeline" id="line-565"><code>	if p, _ := under(typ).(*Pointer); p != nil {</code></span>
<span class="codeline" id="line-566"><code>		if _, ok := under(p.base).(*Struct); ok {</code></span>
<span class="codeline" id="line-567"><code>			return p.base</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>	return typ</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// concat returns the result of concatenating list and i.</code></span>
<span class="codeline" id="line-574"><code>// The result does not share its underlying array with list.</code></span>
<span class="codeline" id="line-575"><code>func concat(list []int, i int) []int {</code></span>
<span class="codeline" id="line-576"><code>	var t []int</code></span>
<span class="codeline" id="line-577"><code>	t = append(t, list...)</code></span>
<span class="codeline" id="line-578"><code>	return append(t, i)</code></span>
<span class="codeline" id="line-579"><code>}</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>// fieldIndex returns the index for the field with matching package and name, or a value &lt; 0.</code></span>
<span class="codeline" id="line-582"><code>func fieldIndex(fields []*Var, pkg *Package, name string) int {</code></span>
<span class="codeline" id="line-583"><code>	if name != "_" {</code></span>
<span class="codeline" id="line-584"><code>		for i, f := range fields {</code></span>
<span class="codeline" id="line-585"><code>			if f.sameId(pkg, name) {</code></span>
<span class="codeline" id="line-586"><code>				return i</code></span>
<span class="codeline" id="line-587"><code>			}</code></span>
<span class="codeline" id="line-588"><code>		}</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code>	return -1</code></span>
<span class="codeline" id="line-591"><code>}</code></span>
<span class="codeline" id="line-592"><code></code></span>
<span class="codeline" id="line-593"><code>// lookupMethod returns the index of and method with matching package and name, or (-1, nil).</code></span>
<span class="codeline" id="line-594"><code>// If foldCase is true, method names are considered equal if they are equal with case folding</code></span>
<span class="codeline" id="line-595"><code>// and their packages are ignored (e.g., pkg1.m, pkg1.M, pkg2.m, and pkg2.M are all equal).</code></span>
<span class="codeline" id="line-596"><code>func lookupMethod(methods []*Func, pkg *Package, name string, foldCase bool) (int, *Func) {</code></span>
<span class="codeline" id="line-597"><code>	if name != "_" {</code></span>
<span class="codeline" id="line-598"><code>		for i, m := range methods {</code></span>
<span class="codeline" id="line-599"><code>			if m.sameId(pkg, name) || foldCase &amp;&amp; strings.EqualFold(m.name, name) {</code></span>
<span class="codeline" id="line-600"><code>				return i, m</code></span>
<span class="codeline" id="line-601"><code>			}</code></span>
<span class="codeline" id="line-602"><code>		}</code></span>
<span class="codeline" id="line-603"><code>	}</code></span>
<span class="codeline" id="line-604"><code>	return -1, nil</code></span>
<span class="codeline" id="line-605"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>