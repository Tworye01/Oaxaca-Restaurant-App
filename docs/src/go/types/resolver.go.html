<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: resolver.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	resolver.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package types</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"go/ast"</code></span>
<span class="codeline" id="line-10"><code>	"go/constant"</code></span>
<span class="codeline" id="line-11"><code>	"go/internal/typeparams"</code></span>
<span class="codeline" id="line-12"><code>	"go/token"</code></span>
<span class="codeline" id="line-13"><code>	. "internal/types/errors"</code></span>
<span class="codeline" id="line-14"><code>	"sort"</code></span>
<span class="codeline" id="line-15"><code>	"strconv"</code></span>
<span class="codeline" id="line-16"><code>	"strings"</code></span>
<span class="codeline" id="line-17"><code>	"unicode"</code></span>
<span class="codeline" id="line-18"><code>)</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>// A declInfo describes a package-level const, type, var, or func declaration.</code></span>
<span class="codeline" id="line-21"><code>type declInfo struct {</code></span>
<span class="codeline" id="line-22"><code>	file      *Scope        // scope of file containing this declaration</code></span>
<span class="codeline" id="line-23"><code>	lhs       []*Var        // lhs of n:1 variable declarations, or nil</code></span>
<span class="codeline" id="line-24"><code>	vtyp      ast.Expr      // type, or nil (for const and var declarations only)</code></span>
<span class="codeline" id="line-25"><code>	init      ast.Expr      // init/orig expression, or nil (for const and var declarations only)</code></span>
<span class="codeline" id="line-26"><code>	inherited bool          // if set, the init expression is inherited from a previous constant declaration</code></span>
<span class="codeline" id="line-27"><code>	tdecl     *ast.TypeSpec // type declaration, or nil</code></span>
<span class="codeline" id="line-28"><code>	fdecl     *ast.FuncDecl // func declaration, or nil</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>	// The deps field tracks initialization expression dependencies.</code></span>
<span class="codeline" id="line-31"><code>	deps map[Object]bool // lazily initialized</code></span>
<span class="codeline" id="line-32"><code>}</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// hasInitializer reports whether the declared object has an initialization</code></span>
<span class="codeline" id="line-35"><code>// expression or function body.</code></span>
<span class="codeline" id="line-36"><code>func (d *declInfo) hasInitializer() bool {</code></span>
<span class="codeline" id="line-37"><code>	return d.init != nil || d.fdecl != nil &amp;&amp; d.fdecl.Body != nil</code></span>
<span class="codeline" id="line-38"><code>}</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>// addDep adds obj to the set of objects d's init expression depends on.</code></span>
<span class="codeline" id="line-41"><code>func (d *declInfo) addDep(obj Object) {</code></span>
<span class="codeline" id="line-42"><code>	m := d.deps</code></span>
<span class="codeline" id="line-43"><code>	if m == nil {</code></span>
<span class="codeline" id="line-44"><code>		m = make(map[Object]bool)</code></span>
<span class="codeline" id="line-45"><code>		d.deps = m</code></span>
<span class="codeline" id="line-46"><code>	}</code></span>
<span class="codeline" id="line-47"><code>	m[obj] = true</code></span>
<span class="codeline" id="line-48"><code>}</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>// arityMatch checks that the lhs and rhs of a const or var decl</code></span>
<span class="codeline" id="line-51"><code>// have the appropriate number of names and init exprs. For const</code></span>
<span class="codeline" id="line-52"><code>// decls, init is the value spec providing the init exprs; for</code></span>
<span class="codeline" id="line-53"><code>// var decls, init is nil (the init exprs are in s in this case).</code></span>
<span class="codeline" id="line-54"><code>func (check *Checker) arityMatch(s, init *ast.ValueSpec) {</code></span>
<span class="codeline" id="line-55"><code>	l := len(s.Names)</code></span>
<span class="codeline" id="line-56"><code>	r := len(s.Values)</code></span>
<span class="codeline" id="line-57"><code>	if init != nil {</code></span>
<span class="codeline" id="line-58"><code>		r = len(init.Values)</code></span>
<span class="codeline" id="line-59"><code>	}</code></span>
<span class="codeline" id="line-60"><code></code></span>
<span class="codeline" id="line-61"><code>	const code = WrongAssignCount</code></span>
<span class="codeline" id="line-62"><code>	switch {</code></span>
<span class="codeline" id="line-63"><code>	case init == nil &amp;&amp; r == 0:</code></span>
<span class="codeline" id="line-64"><code>		// var decl w/o init expr</code></span>
<span class="codeline" id="line-65"><code>		if s.Type == nil {</code></span>
<span class="codeline" id="line-66"><code>			check.error(s, code, "missing type or init expr")</code></span>
<span class="codeline" id="line-67"><code>		}</code></span>
<span class="codeline" id="line-68"><code>	case l &lt; r:</code></span>
<span class="codeline" id="line-69"><code>		if l &lt; len(s.Values) {</code></span>
<span class="codeline" id="line-70"><code>			// init exprs from s</code></span>
<span class="codeline" id="line-71"><code>			n := s.Values[l]</code></span>
<span class="codeline" id="line-72"><code>			check.errorf(n, code, "extra init expr %s", n)</code></span>
<span class="codeline" id="line-73"><code>			// TODO(gri) avoid declared and not used error here</code></span>
<span class="codeline" id="line-74"><code>		} else {</code></span>
<span class="codeline" id="line-75"><code>			// init exprs "inherited"</code></span>
<span class="codeline" id="line-76"><code>			check.errorf(s, code, "extra init expr at %s", check.fset.Position(init.Pos()))</code></span>
<span class="codeline" id="line-77"><code>			// TODO(gri) avoid declared and not used error here</code></span>
<span class="codeline" id="line-78"><code>		}</code></span>
<span class="codeline" id="line-79"><code>	case l &gt; r &amp;&amp; (init != nil || r != 1):</code></span>
<span class="codeline" id="line-80"><code>		n := s.Names[r]</code></span>
<span class="codeline" id="line-81"><code>		check.errorf(n, code, "missing init expr for %s", n)</code></span>
<span class="codeline" id="line-82"><code>	}</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>func validatedImportPath(path string) (string, error) {</code></span>
<span class="codeline" id="line-86"><code>	s, err := strconv.Unquote(path)</code></span>
<span class="codeline" id="line-87"><code>	if err != nil {</code></span>
<span class="codeline" id="line-88"><code>		return "", err</code></span>
<span class="codeline" id="line-89"><code>	}</code></span>
<span class="codeline" id="line-90"><code>	if s == "" {</code></span>
<span class="codeline" id="line-91"><code>		return "", fmt.Errorf("empty string")</code></span>
<span class="codeline" id="line-92"><code>	}</code></span>
<span class="codeline" id="line-93"><code>	const illegalChars = `!"#$%&amp;'()*,:;&lt;=&gt;?[\]^{|}` + "`\uFFFD"</code></span>
<span class="codeline" id="line-94"><code>	for _, r := range s {</code></span>
<span class="codeline" id="line-95"><code>		if !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {</code></span>
<span class="codeline" id="line-96"><code>			return s, fmt.Errorf("invalid character %#U", r)</code></span>
<span class="codeline" id="line-97"><code>		}</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>	return s, nil</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>// declarePkgObj declares obj in the package scope, records its ident -&gt; obj mapping,</code></span>
<span class="codeline" id="line-103"><code>// and updates check.objMap. The object must not be a function or method.</code></span>
<span class="codeline" id="line-104"><code>func (check *Checker) declarePkgObj(ident *ast.Ident, obj Object, d *declInfo) {</code></span>
<span class="codeline" id="line-105"><code>	assert(ident.Name == obj.Name())</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	// spec: "A package-scope or file-scope identifier with name init</code></span>
<span class="codeline" id="line-108"><code>	// may only be declared to be a function with this (func()) signature."</code></span>
<span class="codeline" id="line-109"><code>	if ident.Name == "init" {</code></span>
<span class="codeline" id="line-110"><code>		check.error(ident, InvalidInitDecl, "cannot declare init - must be func")</code></span>
<span class="codeline" id="line-111"><code>		return</code></span>
<span class="codeline" id="line-112"><code>	}</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>	// spec: "The main package must have package name main and declare</code></span>
<span class="codeline" id="line-115"><code>	// a function main that takes no arguments and returns no value."</code></span>
<span class="codeline" id="line-116"><code>	if ident.Name == "main" &amp;&amp; check.pkg.name == "main" {</code></span>
<span class="codeline" id="line-117"><code>		check.error(ident, InvalidMainDecl, "cannot declare main - must be func")</code></span>
<span class="codeline" id="line-118"><code>		return</code></span>
<span class="codeline" id="line-119"><code>	}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	check.declare(check.pkg.scope, ident, obj, nopos)</code></span>
<span class="codeline" id="line-122"><code>	check.objMap[obj] = d</code></span>
<span class="codeline" id="line-123"><code>	obj.setOrder(uint32(len(check.objMap)))</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>// filename returns a filename suitable for debugging output.</code></span>
<span class="codeline" id="line-127"><code>func (check *Checker) filename(fileNo int) string {</code></span>
<span class="codeline" id="line-128"><code>	file := check.files[fileNo]</code></span>
<span class="codeline" id="line-129"><code>	if pos := file.Pos(); pos.IsValid() {</code></span>
<span class="codeline" id="line-130"><code>		return check.fset.File(pos).Name()</code></span>
<span class="codeline" id="line-131"><code>	}</code></span>
<span class="codeline" id="line-132"><code>	return fmt.Sprintf("file[%d]", fileNo)</code></span>
<span class="codeline" id="line-133"><code>}</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>func (check *Checker) importPackage(at positioner, path, dir string) *Package {</code></span>
<span class="codeline" id="line-136"><code>	// If we already have a package for the given (path, dir)</code></span>
<span class="codeline" id="line-137"><code>	// pair, use it instead of doing a full import.</code></span>
<span class="codeline" id="line-138"><code>	// Checker.impMap only caches packages that are marked Complete</code></span>
<span class="codeline" id="line-139"><code>	// or fake (dummy packages for failed imports). Incomplete but</code></span>
<span class="codeline" id="line-140"><code>	// non-fake packages do require an import to complete them.</code></span>
<span class="codeline" id="line-141"><code>	key := importKey{path, dir}</code></span>
<span class="codeline" id="line-142"><code>	imp := check.impMap[key]</code></span>
<span class="codeline" id="line-143"><code>	if imp != nil {</code></span>
<span class="codeline" id="line-144"><code>		return imp</code></span>
<span class="codeline" id="line-145"><code>	}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	// no package yet =&gt; import it</code></span>
<span class="codeline" id="line-148"><code>	if path == "C" &amp;&amp; (check.conf.FakeImportC || check.conf.go115UsesCgo) {</code></span>
<span class="codeline" id="line-149"><code>		imp = NewPackage("C", "C")</code></span>
<span class="codeline" id="line-150"><code>		imp.fake = true // package scope is not populated</code></span>
<span class="codeline" id="line-151"><code>		imp.cgo = check.conf.go115UsesCgo</code></span>
<span class="codeline" id="line-152"><code>	} else {</code></span>
<span class="codeline" id="line-153"><code>		// ordinary import</code></span>
<span class="codeline" id="line-154"><code>		var err error</code></span>
<span class="codeline" id="line-155"><code>		if importer := check.conf.Importer; importer == nil {</code></span>
<span class="codeline" id="line-156"><code>			err = fmt.Errorf("Config.Importer not installed")</code></span>
<span class="codeline" id="line-157"><code>		} else if importerFrom, ok := importer.(ImporterFrom); ok {</code></span>
<span class="codeline" id="line-158"><code>			imp, err = importerFrom.ImportFrom(path, dir, 0)</code></span>
<span class="codeline" id="line-159"><code>			if imp == nil &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-160"><code>				err = fmt.Errorf("Config.Importer.ImportFrom(%s, %s, 0) returned nil but no error", path, dir)</code></span>
<span class="codeline" id="line-161"><code>			}</code></span>
<span class="codeline" id="line-162"><code>		} else {</code></span>
<span class="codeline" id="line-163"><code>			imp, err = importer.Import(path)</code></span>
<span class="codeline" id="line-164"><code>			if imp == nil &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-165"><code>				err = fmt.Errorf("Config.Importer.Import(%s) returned nil but no error", path)</code></span>
<span class="codeline" id="line-166"><code>			}</code></span>
<span class="codeline" id="line-167"><code>		}</code></span>
<span class="codeline" id="line-168"><code>		// make sure we have a valid package name</code></span>
<span class="codeline" id="line-169"><code>		// (errors here can only happen through manipulation of packages after creation)</code></span>
<span class="codeline" id="line-170"><code>		if err == nil &amp;&amp; imp != nil &amp;&amp; (imp.name == "_" || imp.name == "") {</code></span>
<span class="codeline" id="line-171"><code>			err = fmt.Errorf("invalid package name: %q", imp.name)</code></span>
<span class="codeline" id="line-172"><code>			imp = nil // create fake package below</code></span>
<span class="codeline" id="line-173"><code>		}</code></span>
<span class="codeline" id="line-174"><code>		if err != nil {</code></span>
<span class="codeline" id="line-175"><code>			check.errorf(at, BrokenImport, "could not import %s (%s)", path, err)</code></span>
<span class="codeline" id="line-176"><code>			if imp == nil {</code></span>
<span class="codeline" id="line-177"><code>				// create a new fake package</code></span>
<span class="codeline" id="line-178"><code>				// come up with a sensible package name (heuristic)</code></span>
<span class="codeline" id="line-179"><code>				name := path</code></span>
<span class="codeline" id="line-180"><code>				if i := len(name); i &gt; 0 &amp;&amp; name[i-1] == '/' {</code></span>
<span class="codeline" id="line-181"><code>					name = name[:i-1]</code></span>
<span class="codeline" id="line-182"><code>				}</code></span>
<span class="codeline" id="line-183"><code>				if i := strings.LastIndex(name, "/"); i &gt;= 0 {</code></span>
<span class="codeline" id="line-184"><code>					name = name[i+1:]</code></span>
<span class="codeline" id="line-185"><code>				}</code></span>
<span class="codeline" id="line-186"><code>				imp = NewPackage(path, name)</code></span>
<span class="codeline" id="line-187"><code>			}</code></span>
<span class="codeline" id="line-188"><code>			// continue to use the package as best as we can</code></span>
<span class="codeline" id="line-189"><code>			imp.fake = true // avoid follow-up lookup failures</code></span>
<span class="codeline" id="line-190"><code>		}</code></span>
<span class="codeline" id="line-191"><code>	}</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>	// package should be complete or marked fake, but be cautious</code></span>
<span class="codeline" id="line-194"><code>	if imp.complete || imp.fake {</code></span>
<span class="codeline" id="line-195"><code>		check.impMap[key] = imp</code></span>
<span class="codeline" id="line-196"><code>		// Once we've formatted an error message, keep the pkgPathMap</code></span>
<span class="codeline" id="line-197"><code>		// up-to-date on subsequent imports. It is used for package</code></span>
<span class="codeline" id="line-198"><code>		// qualification in error messages.</code></span>
<span class="codeline" id="line-199"><code>		if check.pkgPathMap != nil {</code></span>
<span class="codeline" id="line-200"><code>			check.markImports(imp)</code></span>
<span class="codeline" id="line-201"><code>		}</code></span>
<span class="codeline" id="line-202"><code>		return imp</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>	// something went wrong (importer may have returned incomplete package without error)</code></span>
<span class="codeline" id="line-206"><code>	return nil</code></span>
<span class="codeline" id="line-207"><code>}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>// collectObjects collects all file and package objects and inserts them</code></span>
<span class="codeline" id="line-210"><code>// into their respective scopes. It also performs imports and associates</code></span>
<span class="codeline" id="line-211"><code>// methods with receiver base type names.</code></span>
<span class="codeline" id="line-212"><code>func (check *Checker) collectObjects() {</code></span>
<span class="codeline" id="line-213"><code>	pkg := check.pkg</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>	// pkgImports is the set of packages already imported by any package file seen</code></span>
<span class="codeline" id="line-216"><code>	// so far. Used to avoid duplicate entries in pkg.imports. Allocate and populate</code></span>
<span class="codeline" id="line-217"><code>	// it (pkg.imports may not be empty if we are checking test files incrementally).</code></span>
<span class="codeline" id="line-218"><code>	// Note that pkgImports is keyed by package (and thus package path), not by an</code></span>
<span class="codeline" id="line-219"><code>	// importKey value. Two different importKey values may map to the same package</code></span>
<span class="codeline" id="line-220"><code>	// which is why we cannot use the check.impMap here.</code></span>
<span class="codeline" id="line-221"><code>	var pkgImports = make(map[*Package]bool)</code></span>
<span class="codeline" id="line-222"><code>	for _, imp := range pkg.imports {</code></span>
<span class="codeline" id="line-223"><code>		pkgImports[imp] = true</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	type methodInfo struct {</code></span>
<span class="codeline" id="line-227"><code>		obj  *Func      // method</code></span>
<span class="codeline" id="line-228"><code>		ptr  bool       // true if pointer receiver</code></span>
<span class="codeline" id="line-229"><code>		recv *ast.Ident // receiver type name</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	var methods []methodInfo // collected methods with valid receivers and non-blank _ names</code></span>
<span class="codeline" id="line-232"><code>	var fileScopes []*Scope</code></span>
<span class="codeline" id="line-233"><code>	for fileNo, file := range check.files {</code></span>
<span class="codeline" id="line-234"><code>		// The package identifier denotes the current package,</code></span>
<span class="codeline" id="line-235"><code>		// but there is no corresponding package object.</code></span>
<span class="codeline" id="line-236"><code>		check.recordDef(file.Name, nil)</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>		// Use the actual source file extent rather than *ast.File extent since the</code></span>
<span class="codeline" id="line-239"><code>		// latter doesn't include comments which appear at the start or end of the file.</code></span>
<span class="codeline" id="line-240"><code>		// Be conservative and use the *ast.File extent if we don't have a *token.File.</code></span>
<span class="codeline" id="line-241"><code>		pos, end := file.Pos(), file.End()</code></span>
<span class="codeline" id="line-242"><code>		if f := check.fset.File(file.Pos()); f != nil {</code></span>
<span class="codeline" id="line-243"><code>			pos, end = token.Pos(f.Base()), token.Pos(f.Base()+f.Size())</code></span>
<span class="codeline" id="line-244"><code>		}</code></span>
<span class="codeline" id="line-245"><code>		fileScope := NewScope(pkg.scope, pos, end, check.filename(fileNo))</code></span>
<span class="codeline" id="line-246"><code>		fileScopes = append(fileScopes, fileScope)</code></span>
<span class="codeline" id="line-247"><code>		check.recordScope(file, fileScope)</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>		// determine file directory, necessary to resolve imports</code></span>
<span class="codeline" id="line-250"><code>		// FileName may be "" (typically for tests) in which case</code></span>
<span class="codeline" id="line-251"><code>		// we get "." as the directory which is what we would want.</code></span>
<span class="codeline" id="line-252"><code>		fileDir := dir(check.fset.Position(file.Name.Pos()).Filename)</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>		check.walkDecls(file.Decls, func(d decl) {</code></span>
<span class="codeline" id="line-255"><code>			switch d := d.(type) {</code></span>
<span class="codeline" id="line-256"><code>			case importDecl:</code></span>
<span class="codeline" id="line-257"><code>				// import package</code></span>
<span class="codeline" id="line-258"><code>				if d.spec.Path.Value == "" {</code></span>
<span class="codeline" id="line-259"><code>					return // error reported by parser</code></span>
<span class="codeline" id="line-260"><code>				}</code></span>
<span class="codeline" id="line-261"><code>				path, err := validatedImportPath(d.spec.Path.Value)</code></span>
<span class="codeline" id="line-262"><code>				if err != nil {</code></span>
<span class="codeline" id="line-263"><code>					check.errorf(d.spec.Path, BadImportPath, "invalid import path (%s)", err)</code></span>
<span class="codeline" id="line-264"><code>					return</code></span>
<span class="codeline" id="line-265"><code>				}</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>				imp := check.importPackage(d.spec.Path, path, fileDir)</code></span>
<span class="codeline" id="line-268"><code>				if imp == nil {</code></span>
<span class="codeline" id="line-269"><code>					return</code></span>
<span class="codeline" id="line-270"><code>				}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>				// local name overrides imported package name</code></span>
<span class="codeline" id="line-273"><code>				name := imp.name</code></span>
<span class="codeline" id="line-274"><code>				if d.spec.Name != nil {</code></span>
<span class="codeline" id="line-275"><code>					name = d.spec.Name.Name</code></span>
<span class="codeline" id="line-276"><code>					if path == "C" {</code></span>
<span class="codeline" id="line-277"><code>						// match 1.17 cmd/compile (not prescribed by spec)</code></span>
<span class="codeline" id="line-278"><code>						check.error(d.spec.Name, ImportCRenamed, `cannot rename import "C"`)</code></span>
<span class="codeline" id="line-279"><code>						return</code></span>
<span class="codeline" id="line-280"><code>					}</code></span>
<span class="codeline" id="line-281"><code>				}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>				if name == "init" {</code></span>
<span class="codeline" id="line-284"><code>					check.error(d.spec, InvalidInitDecl, "cannot import package as init - init must be a func")</code></span>
<span class="codeline" id="line-285"><code>					return</code></span>
<span class="codeline" id="line-286"><code>				}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>				// add package to list of explicit imports</code></span>
<span class="codeline" id="line-289"><code>				// (this functionality is provided as a convenience</code></span>
<span class="codeline" id="line-290"><code>				// for clients; it is not needed for type-checking)</code></span>
<span class="codeline" id="line-291"><code>				if !pkgImports[imp] {</code></span>
<span class="codeline" id="line-292"><code>					pkgImports[imp] = true</code></span>
<span class="codeline" id="line-293"><code>					pkg.imports = append(pkg.imports, imp)</code></span>
<span class="codeline" id="line-294"><code>				}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>				pkgName := NewPkgName(d.spec.Pos(), pkg, name, imp)</code></span>
<span class="codeline" id="line-297"><code>				if d.spec.Name != nil {</code></span>
<span class="codeline" id="line-298"><code>					// in a dot-import, the dot represents the package</code></span>
<span class="codeline" id="line-299"><code>					check.recordDef(d.spec.Name, pkgName)</code></span>
<span class="codeline" id="line-300"><code>				} else {</code></span>
<span class="codeline" id="line-301"><code>					check.recordImplicit(d.spec, pkgName)</code></span>
<span class="codeline" id="line-302"><code>				}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>				if imp.fake {</code></span>
<span class="codeline" id="line-305"><code>					// match 1.17 cmd/compile (not prescribed by spec)</code></span>
<span class="codeline" id="line-306"><code>					pkgName.used = true</code></span>
<span class="codeline" id="line-307"><code>				}</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>				// add import to file scope</code></span>
<span class="codeline" id="line-310"><code>				check.imports = append(check.imports, pkgName)</code></span>
<span class="codeline" id="line-311"><code>				if name == "." {</code></span>
<span class="codeline" id="line-312"><code>					// dot-import</code></span>
<span class="codeline" id="line-313"><code>					if check.dotImportMap == nil {</code></span>
<span class="codeline" id="line-314"><code>						check.dotImportMap = make(map[dotImportKey]*PkgName)</code></span>
<span class="codeline" id="line-315"><code>					}</code></span>
<span class="codeline" id="line-316"><code>					// merge imported scope with file scope</code></span>
<span class="codeline" id="line-317"><code>					for name, obj := range imp.scope.elems {</code></span>
<span class="codeline" id="line-318"><code>						// Note: Avoid eager resolve(name, obj) here, so we only</code></span>
<span class="codeline" id="line-319"><code>						// resolve dot-imported objects as needed.</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>						// A package scope may contain non-exported objects,</code></span>
<span class="codeline" id="line-322"><code>						// do not import them!</code></span>
<span class="codeline" id="line-323"><code>						if token.IsExported(name) {</code></span>
<span class="codeline" id="line-324"><code>							// declare dot-imported object</code></span>
<span class="codeline" id="line-325"><code>							// (Do not use check.declare because it modifies the object</code></span>
<span class="codeline" id="line-326"><code>							// via Object.setScopePos, which leads to a race condition;</code></span>
<span class="codeline" id="line-327"><code>							// the object may be imported into more than one file scope</code></span>
<span class="codeline" id="line-328"><code>							// concurrently. See go.dev/issue/32154.)</code></span>
<span class="codeline" id="line-329"><code>							if alt := fileScope.Lookup(name); alt != nil {</code></span>
<span class="codeline" id="line-330"><code>								check.errorf(d.spec.Name, DuplicateDecl, "%s redeclared in this block", alt.Name())</code></span>
<span class="codeline" id="line-331"><code>								check.reportAltDecl(alt)</code></span>
<span class="codeline" id="line-332"><code>							} else {</code></span>
<span class="codeline" id="line-333"><code>								fileScope.insert(name, obj)</code></span>
<span class="codeline" id="line-334"><code>								check.dotImportMap[dotImportKey{fileScope, name}] = pkgName</code></span>
<span class="codeline" id="line-335"><code>							}</code></span>
<span class="codeline" id="line-336"><code>						}</code></span>
<span class="codeline" id="line-337"><code>					}</code></span>
<span class="codeline" id="line-338"><code>				} else {</code></span>
<span class="codeline" id="line-339"><code>					// declare imported package object in file scope</code></span>
<span class="codeline" id="line-340"><code>					// (no need to provide s.Name since we called check.recordDef earlier)</code></span>
<span class="codeline" id="line-341"><code>					check.declare(fileScope, nil, pkgName, nopos)</code></span>
<span class="codeline" id="line-342"><code>				}</code></span>
<span class="codeline" id="line-343"><code>			case constDecl:</code></span>
<span class="codeline" id="line-344"><code>				// declare all constants</code></span>
<span class="codeline" id="line-345"><code>				for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-346"><code>					obj := NewConst(name.Pos(), pkg, name.Name, nil, constant.MakeInt64(int64(d.iota)))</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>					var init ast.Expr</code></span>
<span class="codeline" id="line-349"><code>					if i &lt; len(d.init) {</code></span>
<span class="codeline" id="line-350"><code>						init = d.init[i]</code></span>
<span class="codeline" id="line-351"><code>					}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>					d := &amp;declInfo{file: fileScope, vtyp: d.typ, init: init, inherited: d.inherited}</code></span>
<span class="codeline" id="line-354"><code>					check.declarePkgObj(name, obj, d)</code></span>
<span class="codeline" id="line-355"><code>				}</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>			case varDecl:</code></span>
<span class="codeline" id="line-358"><code>				lhs := make([]*Var, len(d.spec.Names))</code></span>
<span class="codeline" id="line-359"><code>				// If there's exactly one rhs initializer, use</code></span>
<span class="codeline" id="line-360"><code>				// the same declInfo d1 for all lhs variables</code></span>
<span class="codeline" id="line-361"><code>				// so that each lhs variable depends on the same</code></span>
<span class="codeline" id="line-362"><code>				// rhs initializer (n:1 var declaration).</code></span>
<span class="codeline" id="line-363"><code>				var d1 *declInfo</code></span>
<span class="codeline" id="line-364"><code>				if len(d.spec.Values) == 1 {</code></span>
<span class="codeline" id="line-365"><code>					// The lhs elements are only set up after the for loop below,</code></span>
<span class="codeline" id="line-366"><code>					// but that's ok because declareVar only collects the declInfo</code></span>
<span class="codeline" id="line-367"><code>					// for a later phase.</code></span>
<span class="codeline" id="line-368"><code>					d1 = &amp;declInfo{file: fileScope, lhs: lhs, vtyp: d.spec.Type, init: d.spec.Values[0]}</code></span>
<span class="codeline" id="line-369"><code>				}</code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code>				// declare all variables</code></span>
<span class="codeline" id="line-372"><code>				for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-373"><code>					obj := NewVar(name.Pos(), pkg, name.Name, nil)</code></span>
<span class="codeline" id="line-374"><code>					lhs[i] = obj</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>					di := d1</code></span>
<span class="codeline" id="line-377"><code>					if di == nil {</code></span>
<span class="codeline" id="line-378"><code>						// individual assignments</code></span>
<span class="codeline" id="line-379"><code>						var init ast.Expr</code></span>
<span class="codeline" id="line-380"><code>						if i &lt; len(d.spec.Values) {</code></span>
<span class="codeline" id="line-381"><code>							init = d.spec.Values[i]</code></span>
<span class="codeline" id="line-382"><code>						}</code></span>
<span class="codeline" id="line-383"><code>						di = &amp;declInfo{file: fileScope, vtyp: d.spec.Type, init: init}</code></span>
<span class="codeline" id="line-384"><code>					}</code></span>
<span class="codeline" id="line-385"><code></code></span>
<span class="codeline" id="line-386"><code>					check.declarePkgObj(name, obj, di)</code></span>
<span class="codeline" id="line-387"><code>				}</code></span>
<span class="codeline" id="line-388"><code>			case typeDecl:</code></span>
<span class="codeline" id="line-389"><code>				_ = d.spec.TypeParams.NumFields() != 0 &amp;&amp; check.verifyVersionf(d.spec.TypeParams.List[0], go1_18, "type parameter")</code></span>
<span class="codeline" id="line-390"><code>				obj := NewTypeName(d.spec.Name.Pos(), pkg, d.spec.Name.Name, nil)</code></span>
<span class="codeline" id="line-391"><code>				check.declarePkgObj(d.spec.Name, obj, &amp;declInfo{file: fileScope, tdecl: d.spec})</code></span>
<span class="codeline" id="line-392"><code>			case funcDecl:</code></span>
<span class="codeline" id="line-393"><code>				name := d.decl.Name.Name</code></span>
<span class="codeline" id="line-394"><code>				obj := NewFunc(d.decl.Name.Pos(), pkg, name, nil)</code></span>
<span class="codeline" id="line-395"><code>				hasTParamError := false // avoid duplicate type parameter errors</code></span>
<span class="codeline" id="line-396"><code>				if d.decl.Recv.NumFields() == 0 {</code></span>
<span class="codeline" id="line-397"><code>					// regular function</code></span>
<span class="codeline" id="line-398"><code>					if d.decl.Recv != nil {</code></span>
<span class="codeline" id="line-399"><code>						check.error(d.decl.Recv, BadRecv, "method has no receiver")</code></span>
<span class="codeline" id="line-400"><code>						// treat as function</code></span>
<span class="codeline" id="line-401"><code>					}</code></span>
<span class="codeline" id="line-402"><code>					if name == "init" || (name == "main" &amp;&amp; check.pkg.name == "main") {</code></span>
<span class="codeline" id="line-403"><code>						code := InvalidInitDecl</code></span>
<span class="codeline" id="line-404"><code>						if name == "main" {</code></span>
<span class="codeline" id="line-405"><code>							code = InvalidMainDecl</code></span>
<span class="codeline" id="line-406"><code>						}</code></span>
<span class="codeline" id="line-407"><code>						if d.decl.Type.TypeParams.NumFields() != 0 {</code></span>
<span class="codeline" id="line-408"><code>							check.softErrorf(d.decl.Type.TypeParams.List[0], code, "func %s must have no type parameters", name)</code></span>
<span class="codeline" id="line-409"><code>							hasTParamError = true</code></span>
<span class="codeline" id="line-410"><code>						}</code></span>
<span class="codeline" id="line-411"><code>						if t := d.decl.Type; t.Params.NumFields() != 0 || t.Results != nil {</code></span>
<span class="codeline" id="line-412"><code>							// TODO(rFindley) Should this be a hard error?</code></span>
<span class="codeline" id="line-413"><code>							check.softErrorf(d.decl.Name, code, "func %s must have no arguments and no return values", name)</code></span>
<span class="codeline" id="line-414"><code>						}</code></span>
<span class="codeline" id="line-415"><code>					}</code></span>
<span class="codeline" id="line-416"><code>					if name == "init" {</code></span>
<span class="codeline" id="line-417"><code>						// don't declare init functions in the package scope - they are invisible</code></span>
<span class="codeline" id="line-418"><code>						obj.parent = pkg.scope</code></span>
<span class="codeline" id="line-419"><code>						check.recordDef(d.decl.Name, obj)</code></span>
<span class="codeline" id="line-420"><code>						// init functions must have a body</code></span>
<span class="codeline" id="line-421"><code>						if d.decl.Body == nil {</code></span>
<span class="codeline" id="line-422"><code>							// TODO(gri) make this error message consistent with the others above</code></span>
<span class="codeline" id="line-423"><code>							check.softErrorf(obj, MissingInitBody, "missing function body")</code></span>
<span class="codeline" id="line-424"><code>						}</code></span>
<span class="codeline" id="line-425"><code>					} else {</code></span>
<span class="codeline" id="line-426"><code>						check.declare(pkg.scope, d.decl.Name, obj, nopos)</code></span>
<span class="codeline" id="line-427"><code>					}</code></span>
<span class="codeline" id="line-428"><code>				} else {</code></span>
<span class="codeline" id="line-429"><code>					// method</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>					// TODO(rFindley) earlier versions of this code checked that methods</code></span>
<span class="codeline" id="line-432"><code>					//                have no type parameters, but this is checked later</code></span>
<span class="codeline" id="line-433"><code>					//                when type checking the function type. Confirm that</code></span>
<span class="codeline" id="line-434"><code>					//                we don't need to check tparams here.</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>					ptr, recv, _ := check.unpackRecv(d.decl.Recv.List[0].Type, false)</code></span>
<span class="codeline" id="line-437"><code>					// (Methods with invalid receiver cannot be associated to a type, and</code></span>
<span class="codeline" id="line-438"><code>					// methods with blank _ names are never found; no need to collect any</code></span>
<span class="codeline" id="line-439"><code>					// of them. They will still be type-checked with all the other functions.)</code></span>
<span class="codeline" id="line-440"><code>					if recv != nil &amp;&amp; name != "_" {</code></span>
<span class="codeline" id="line-441"><code>						methods = append(methods, methodInfo{obj, ptr, recv})</code></span>
<span class="codeline" id="line-442"><code>					}</code></span>
<span class="codeline" id="line-443"><code>					check.recordDef(d.decl.Name, obj)</code></span>
<span class="codeline" id="line-444"><code>				}</code></span>
<span class="codeline" id="line-445"><code>				_ = d.decl.Type.TypeParams.NumFields() != 0 &amp;&amp; !hasTParamError &amp;&amp; check.verifyVersionf(d.decl.Type.TypeParams.List[0], go1_18, "type parameter")</code></span>
<span class="codeline" id="line-446"><code>				info := &amp;declInfo{file: fileScope, fdecl: d.decl}</code></span>
<span class="codeline" id="line-447"><code>				// Methods are not package-level objects but we still track them in the</code></span>
<span class="codeline" id="line-448"><code>				// object map so that we can handle them like regular functions (if the</code></span>
<span class="codeline" id="line-449"><code>				// receiver is invalid); also we need their fdecl info when associating</code></span>
<span class="codeline" id="line-450"><code>				// them with their receiver base type, below.</code></span>
<span class="codeline" id="line-451"><code>				check.objMap[obj] = info</code></span>
<span class="codeline" id="line-452"><code>				obj.setOrder(uint32(len(check.objMap)))</code></span>
<span class="codeline" id="line-453"><code>			}</code></span>
<span class="codeline" id="line-454"><code>		})</code></span>
<span class="codeline" id="line-455"><code>	}</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>	// verify that objects in package and file scopes have different names</code></span>
<span class="codeline" id="line-458"><code>	for _, scope := range fileScopes {</code></span>
<span class="codeline" id="line-459"><code>		for name, obj := range scope.elems {</code></span>
<span class="codeline" id="line-460"><code>			if alt := pkg.scope.Lookup(name); alt != nil {</code></span>
<span class="codeline" id="line-461"><code>				obj = resolve(name, obj)</code></span>
<span class="codeline" id="line-462"><code>				if pkg, ok := obj.(*PkgName); ok {</code></span>
<span class="codeline" id="line-463"><code>					check.errorf(alt, DuplicateDecl, "%s already declared through import of %s", alt.Name(), pkg.Imported())</code></span>
<span class="codeline" id="line-464"><code>					check.reportAltDecl(pkg)</code></span>
<span class="codeline" id="line-465"><code>				} else {</code></span>
<span class="codeline" id="line-466"><code>					check.errorf(alt, DuplicateDecl, "%s already declared through dot-import of %s", alt.Name(), obj.Pkg())</code></span>
<span class="codeline" id="line-467"><code>					// TODO(gri) dot-imported objects don't have a position; reportAltDecl won't print anything</code></span>
<span class="codeline" id="line-468"><code>					check.reportAltDecl(obj)</code></span>
<span class="codeline" id="line-469"><code>				}</code></span>
<span class="codeline" id="line-470"><code>			}</code></span>
<span class="codeline" id="line-471"><code>		}</code></span>
<span class="codeline" id="line-472"><code>	}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>	// Now that we have all package scope objects and all methods,</code></span>
<span class="codeline" id="line-475"><code>	// associate methods with receiver base type name where possible.</code></span>
<span class="codeline" id="line-476"><code>	// Ignore methods that have an invalid receiver. They will be</code></span>
<span class="codeline" id="line-477"><code>	// type-checked later, with regular functions.</code></span>
<span class="codeline" id="line-478"><code>	if methods == nil {</code></span>
<span class="codeline" id="line-479"><code>		return // nothing to do</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code>	check.methods = make(map[*TypeName][]*Func)</code></span>
<span class="codeline" id="line-482"><code>	for i := range methods {</code></span>
<span class="codeline" id="line-483"><code>		m := &amp;methods[i]</code></span>
<span class="codeline" id="line-484"><code>		// Determine the receiver base type and associate m with it.</code></span>
<span class="codeline" id="line-485"><code>		ptr, base := check.resolveBaseTypeName(m.ptr, m.recv, fileScopes)</code></span>
<span class="codeline" id="line-486"><code>		if base != nil {</code></span>
<span class="codeline" id="line-487"><code>			m.obj.hasPtrRecv_ = ptr</code></span>
<span class="codeline" id="line-488"><code>			check.methods[base] = append(check.methods[base], m.obj)</code></span>
<span class="codeline" id="line-489"><code>		}</code></span>
<span class="codeline" id="line-490"><code>	}</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// unpackRecv unpacks a receiver type and returns its components: ptr indicates whether</code></span>
<span class="codeline" id="line-494"><code>// rtyp is a pointer receiver, rname is the receiver type name, and tparams are its</code></span>
<span class="codeline" id="line-495"><code>// type parameters, if any. The type parameters are only unpacked if unpackParams is</code></span>
<span class="codeline" id="line-496"><code>// set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we</code></span>
<span class="codeline" id="line-497"><code>// cannot easily work around).</code></span>
<span class="codeline" id="line-498"><code>func (check *Checker) unpackRecv(rtyp ast.Expr, unpackParams bool) (ptr bool, rname *ast.Ident, tparams []*ast.Ident) {</code></span>
<span class="codeline" id="line-499"><code>L: // unpack receiver type</code></span>
<span class="codeline" id="line-500"><code>	// This accepts invalid receivers such as ***T and does not</code></span>
<span class="codeline" id="line-501"><code>	// work for other invalid receivers, but we don't care. The</code></span>
<span class="codeline" id="line-502"><code>	// validity of receiver expressions is checked elsewhere.</code></span>
<span class="codeline" id="line-503"><code>	for {</code></span>
<span class="codeline" id="line-504"><code>		switch t := rtyp.(type) {</code></span>
<span class="codeline" id="line-505"><code>		case *ast.ParenExpr:</code></span>
<span class="codeline" id="line-506"><code>			rtyp = t.X</code></span>
<span class="codeline" id="line-507"><code>		case *ast.StarExpr:</code></span>
<span class="codeline" id="line-508"><code>			ptr = true</code></span>
<span class="codeline" id="line-509"><code>			rtyp = t.X</code></span>
<span class="codeline" id="line-510"><code>		default:</code></span>
<span class="codeline" id="line-511"><code>			break L</code></span>
<span class="codeline" id="line-512"><code>		}</code></span>
<span class="codeline" id="line-513"><code>	}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>	// unpack type parameters, if any</code></span>
<span class="codeline" id="line-516"><code>	switch rtyp.(type) {</code></span>
<span class="codeline" id="line-517"><code>	case *ast.IndexExpr, *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-518"><code>		ix := typeparams.UnpackIndexExpr(rtyp)</code></span>
<span class="codeline" id="line-519"><code>		rtyp = ix.X</code></span>
<span class="codeline" id="line-520"><code>		if unpackParams {</code></span>
<span class="codeline" id="line-521"><code>			for _, arg := range ix.Indices {</code></span>
<span class="codeline" id="line-522"><code>				var par *ast.Ident</code></span>
<span class="codeline" id="line-523"><code>				switch arg := arg.(type) {</code></span>
<span class="codeline" id="line-524"><code>				case *ast.Ident:</code></span>
<span class="codeline" id="line-525"><code>					par = arg</code></span>
<span class="codeline" id="line-526"><code>				case *ast.BadExpr:</code></span>
<span class="codeline" id="line-527"><code>					// ignore - error already reported by parser</code></span>
<span class="codeline" id="line-528"><code>				case nil:</code></span>
<span class="codeline" id="line-529"><code>					check.error(ix.Orig, InvalidSyntaxTree, "parameterized receiver contains nil parameters")</code></span>
<span class="codeline" id="line-530"><code>				default:</code></span>
<span class="codeline" id="line-531"><code>					check.errorf(arg, BadDecl, "receiver type parameter %s must be an identifier", arg)</code></span>
<span class="codeline" id="line-532"><code>				}</code></span>
<span class="codeline" id="line-533"><code>				if par == nil {</code></span>
<span class="codeline" id="line-534"><code>					par = &amp;ast.Ident{NamePos: arg.Pos(), Name: "_"}</code></span>
<span class="codeline" id="line-535"><code>				}</code></span>
<span class="codeline" id="line-536"><code>				tparams = append(tparams, par)</code></span>
<span class="codeline" id="line-537"><code>			}</code></span>
<span class="codeline" id="line-538"><code>		}</code></span>
<span class="codeline" id="line-539"><code>	}</code></span>
<span class="codeline" id="line-540"><code></code></span>
<span class="codeline" id="line-541"><code>	// unpack receiver name</code></span>
<span class="codeline" id="line-542"><code>	if name, _ := rtyp.(*ast.Ident); name != nil {</code></span>
<span class="codeline" id="line-543"><code>		rname = name</code></span>
<span class="codeline" id="line-544"><code>	}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>	return</code></span>
<span class="codeline" id="line-547"><code>}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>// resolveBaseTypeName returns the non-alias base type name for typ, and whether</code></span>
<span class="codeline" id="line-550"><code>// there was a pointer indirection to get to it. The base type name must be declared</code></span>
<span class="codeline" id="line-551"><code>// in package scope, and there can be at most one pointer indirection. If no such type</code></span>
<span class="codeline" id="line-552"><code>// name exists, the returned base is nil.</code></span>
<span class="codeline" id="line-553"><code>func (check *Checker) resolveBaseTypeName(seenPtr bool, typ ast.Expr, fileScopes []*Scope) (ptr bool, base *TypeName) {</code></span>
<span class="codeline" id="line-554"><code>	// Algorithm: Starting from a type expression, which may be a name,</code></span>
<span class="codeline" id="line-555"><code>	// we follow that type through alias declarations until we reach a</code></span>
<span class="codeline" id="line-556"><code>	// non-alias type name. If we encounter anything but pointer types or</code></span>
<span class="codeline" id="line-557"><code>	// parentheses we're done. If we encounter more than one pointer type</code></span>
<span class="codeline" id="line-558"><code>	// we're done.</code></span>
<span class="codeline" id="line-559"><code>	ptr = seenPtr</code></span>
<span class="codeline" id="line-560"><code>	var seen map[*TypeName]bool</code></span>
<span class="codeline" id="line-561"><code>	for {</code></span>
<span class="codeline" id="line-562"><code>		// Note: this differs from types2, but is necessary. The syntax parser</code></span>
<span class="codeline" id="line-563"><code>		// strips unnecessary parens.</code></span>
<span class="codeline" id="line-564"><code>		typ = unparen(typ)</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>		// check if we have a pointer type</code></span>
<span class="codeline" id="line-567"><code>		if pexpr, _ := typ.(*ast.StarExpr); pexpr != nil {</code></span>
<span class="codeline" id="line-568"><code>			// if we've already seen a pointer, we're done</code></span>
<span class="codeline" id="line-569"><code>			if ptr {</code></span>
<span class="codeline" id="line-570"><code>				return false, nil</code></span>
<span class="codeline" id="line-571"><code>			}</code></span>
<span class="codeline" id="line-572"><code>			ptr = true</code></span>
<span class="codeline" id="line-573"><code>			typ = unparen(pexpr.X) // continue with pointer base type</code></span>
<span class="codeline" id="line-574"><code>		}</code></span>
<span class="codeline" id="line-575"><code></code></span>
<span class="codeline" id="line-576"><code>		// typ must be a name, or a C.name cgo selector.</code></span>
<span class="codeline" id="line-577"><code>		var name string</code></span>
<span class="codeline" id="line-578"><code>		switch typ := typ.(type) {</code></span>
<span class="codeline" id="line-579"><code>		case *ast.Ident:</code></span>
<span class="codeline" id="line-580"><code>			name = typ.Name</code></span>
<span class="codeline" id="line-581"><code>		case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-582"><code>			// C.struct_foo is a valid type name for packages using cgo.</code></span>
<span class="codeline" id="line-583"><code>			//</code></span>
<span class="codeline" id="line-584"><code>			// Detect this case, and adjust name so that the correct TypeName is</code></span>
<span class="codeline" id="line-585"><code>			// resolved below.</code></span>
<span class="codeline" id="line-586"><code>			if ident, _ := typ.X.(*ast.Ident); ident != nil &amp;&amp; ident.Name == "C" {</code></span>
<span class="codeline" id="line-587"><code>				// Check whether "C" actually resolves to an import of "C", by looking</code></span>
<span class="codeline" id="line-588"><code>				// in the appropriate file scope.</code></span>
<span class="codeline" id="line-589"><code>				var obj Object</code></span>
<span class="codeline" id="line-590"><code>				for _, scope := range fileScopes {</code></span>
<span class="codeline" id="line-591"><code>					if scope.Contains(ident.Pos()) {</code></span>
<span class="codeline" id="line-592"><code>						obj = scope.Lookup(ident.Name)</code></span>
<span class="codeline" id="line-593"><code>					}</code></span>
<span class="codeline" id="line-594"><code>				}</code></span>
<span class="codeline" id="line-595"><code>				// If Config.go115UsesCgo is set, the typechecker will resolve Cgo</code></span>
<span class="codeline" id="line-596"><code>				// selectors to their cgo name. We must do the same here.</code></span>
<span class="codeline" id="line-597"><code>				if pname, _ := obj.(*PkgName); pname != nil {</code></span>
<span class="codeline" id="line-598"><code>					if pname.imported.cgo { // only set if Config.go115UsesCgo is set</code></span>
<span class="codeline" id="line-599"><code>						name = "_Ctype_" + typ.Sel.Name</code></span>
<span class="codeline" id="line-600"><code>					}</code></span>
<span class="codeline" id="line-601"><code>				}</code></span>
<span class="codeline" id="line-602"><code>			}</code></span>
<span class="codeline" id="line-603"><code>			if name == "" {</code></span>
<span class="codeline" id="line-604"><code>				return false, nil</code></span>
<span class="codeline" id="line-605"><code>			}</code></span>
<span class="codeline" id="line-606"><code>		default:</code></span>
<span class="codeline" id="line-607"><code>			return false, nil</code></span>
<span class="codeline" id="line-608"><code>		}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>		// name must denote an object found in the current package scope</code></span>
<span class="codeline" id="line-611"><code>		// (note that dot-imported objects are not in the package scope!)</code></span>
<span class="codeline" id="line-612"><code>		obj := check.pkg.scope.Lookup(name)</code></span>
<span class="codeline" id="line-613"><code>		if obj == nil {</code></span>
<span class="codeline" id="line-614"><code>			return false, nil</code></span>
<span class="codeline" id="line-615"><code>		}</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>		// the object must be a type name...</code></span>
<span class="codeline" id="line-618"><code>		tname, _ := obj.(*TypeName)</code></span>
<span class="codeline" id="line-619"><code>		if tname == nil {</code></span>
<span class="codeline" id="line-620"><code>			return false, nil</code></span>
<span class="codeline" id="line-621"><code>		}</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>		// ... which we have not seen before</code></span>
<span class="codeline" id="line-624"><code>		if seen[tname] {</code></span>
<span class="codeline" id="line-625"><code>			return false, nil</code></span>
<span class="codeline" id="line-626"><code>		}</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>		// we're done if tdecl defined tname as a new type</code></span>
<span class="codeline" id="line-629"><code>		// (rather than an alias)</code></span>
<span class="codeline" id="line-630"><code>		tdecl := check.objMap[tname].tdecl // must exist for objects in package scope</code></span>
<span class="codeline" id="line-631"><code>		if !tdecl.Assign.IsValid() {</code></span>
<span class="codeline" id="line-632"><code>			return ptr, tname</code></span>
<span class="codeline" id="line-633"><code>		}</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>		// otherwise, continue resolving</code></span>
<span class="codeline" id="line-636"><code>		typ = tdecl.Type</code></span>
<span class="codeline" id="line-637"><code>		if seen == nil {</code></span>
<span class="codeline" id="line-638"><code>			seen = make(map[*TypeName]bool)</code></span>
<span class="codeline" id="line-639"><code>		}</code></span>
<span class="codeline" id="line-640"><code>		seen[tname] = true</code></span>
<span class="codeline" id="line-641"><code>	}</code></span>
<span class="codeline" id="line-642"><code>}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>// packageObjects typechecks all package objects, but not function bodies.</code></span>
<span class="codeline" id="line-645"><code>func (check *Checker) packageObjects() {</code></span>
<span class="codeline" id="line-646"><code>	// process package objects in source order for reproducible results</code></span>
<span class="codeline" id="line-647"><code>	objList := make([]Object, len(check.objMap))</code></span>
<span class="codeline" id="line-648"><code>	i := 0</code></span>
<span class="codeline" id="line-649"><code>	for obj := range check.objMap {</code></span>
<span class="codeline" id="line-650"><code>		objList[i] = obj</code></span>
<span class="codeline" id="line-651"><code>		i++</code></span>
<span class="codeline" id="line-652"><code>	}</code></span>
<span class="codeline" id="line-653"><code>	sort.Sort(inSourceOrder(objList))</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>	// add new methods to already type-checked types (from a prior Checker.Files call)</code></span>
<span class="codeline" id="line-656"><code>	for _, obj := range objList {</code></span>
<span class="codeline" id="line-657"><code>		if obj, _ := obj.(*TypeName); obj != nil &amp;&amp; obj.typ != nil {</code></span>
<span class="codeline" id="line-658"><code>			check.collectMethods(obj)</code></span>
<span class="codeline" id="line-659"><code>		}</code></span>
<span class="codeline" id="line-660"><code>	}</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>	if check.enableAlias {</code></span>
<span class="codeline" id="line-663"><code>		// With Alias nodes we can process declarations in any order.</code></span>
<span class="codeline" id="line-664"><code>		for _, obj := range objList {</code></span>
<span class="codeline" id="line-665"><code>			check.objDecl(obj, nil)</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code>	} else {</code></span>
<span class="codeline" id="line-668"><code>		// Without Alias nodes, we process non-alias type declarations first, followed by</code></span>
<span class="codeline" id="line-669"><code>		// alias declarations, and then everything else. This appears to avoid most situations</code></span>
<span class="codeline" id="line-670"><code>		// where the type of an alias is needed before it is available.</code></span>
<span class="codeline" id="line-671"><code>		// There may still be cases where this is not good enough (see also go.dev/issue/25838).</code></span>
<span class="codeline" id="line-672"><code>		// In those cases Checker.ident will report an error ("invalid use of type alias").</code></span>
<span class="codeline" id="line-673"><code>		var aliasList []*TypeName</code></span>
<span class="codeline" id="line-674"><code>		var othersList []Object // everything that's not a type</code></span>
<span class="codeline" id="line-675"><code>		// phase 1: non-alias type declarations</code></span>
<span class="codeline" id="line-676"><code>		for _, obj := range objList {</code></span>
<span class="codeline" id="line-677"><code>			if tname, _ := obj.(*TypeName); tname != nil {</code></span>
<span class="codeline" id="line-678"><code>				if check.objMap[tname].tdecl.Assign.IsValid() {</code></span>
<span class="codeline" id="line-679"><code>					aliasList = append(aliasList, tname)</code></span>
<span class="codeline" id="line-680"><code>				} else {</code></span>
<span class="codeline" id="line-681"><code>					check.objDecl(obj, nil)</code></span>
<span class="codeline" id="line-682"><code>				}</code></span>
<span class="codeline" id="line-683"><code>			} else {</code></span>
<span class="codeline" id="line-684"><code>				othersList = append(othersList, obj)</code></span>
<span class="codeline" id="line-685"><code>			}</code></span>
<span class="codeline" id="line-686"><code>		}</code></span>
<span class="codeline" id="line-687"><code>		// phase 2: alias type declarations</code></span>
<span class="codeline" id="line-688"><code>		for _, obj := range aliasList {</code></span>
<span class="codeline" id="line-689"><code>			check.objDecl(obj, nil)</code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>		// phase 3: all other declarations</code></span>
<span class="codeline" id="line-692"><code>		for _, obj := range othersList {</code></span>
<span class="codeline" id="line-693"><code>			check.objDecl(obj, nil)</code></span>
<span class="codeline" id="line-694"><code>		}</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	// At this point we may have a non-empty check.methods map; this means that not all</code></span>
<span class="codeline" id="line-698"><code>	// entries were deleted at the end of typeDecl because the respective receiver base</code></span>
<span class="codeline" id="line-699"><code>	// types were not found. In that case, an error was reported when declaring those</code></span>
<span class="codeline" id="line-700"><code>	// methods. We can now safely discard this map.</code></span>
<span class="codeline" id="line-701"><code>	check.methods = nil</code></span>
<span class="codeline" id="line-702"><code>}</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>// inSourceOrder implements the sort.Sort interface.</code></span>
<span class="codeline" id="line-705"><code>type inSourceOrder []Object</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>func (a inSourceOrder) Len() int           { return len(a) }</code></span>
<span class="codeline" id="line-708"><code>func (a inSourceOrder) Less(i, j int) bool { return a[i].order() &lt; a[j].order() }</code></span>
<span class="codeline" id="line-709"><code>func (a inSourceOrder) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>// unusedImports checks for unused imports.</code></span>
<span class="codeline" id="line-712"><code>func (check *Checker) unusedImports() {</code></span>
<span class="codeline" id="line-713"><code>	// If function bodies are not checked, packages' uses are likely missing - don't check.</code></span>
<span class="codeline" id="line-714"><code>	if check.conf.IgnoreFuncBodies {</code></span>
<span class="codeline" id="line-715"><code>		return</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>	// spec: "It is illegal (...) to directly import a package without referring to</code></span>
<span class="codeline" id="line-719"><code>	// any of its exported identifiers. To import a package solely for its side-effects</code></span>
<span class="codeline" id="line-720"><code>	// (initialization), use the blank identifier as explicit package name."</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>	for _, obj := range check.imports {</code></span>
<span class="codeline" id="line-723"><code>		if !obj.used &amp;&amp; obj.name != "_" {</code></span>
<span class="codeline" id="line-724"><code>			check.errorUnusedPkg(obj)</code></span>
<span class="codeline" id="line-725"><code>		}</code></span>
<span class="codeline" id="line-726"><code>	}</code></span>
<span class="codeline" id="line-727"><code>}</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>func (check *Checker) errorUnusedPkg(obj *PkgName) {</code></span>
<span class="codeline" id="line-730"><code>	// If the package was imported with a name other than the final</code></span>
<span class="codeline" id="line-731"><code>	// import path element, show it explicitly in the error message.</code></span>
<span class="codeline" id="line-732"><code>	// Note that this handles both renamed imports and imports of</code></span>
<span class="codeline" id="line-733"><code>	// packages containing unconventional package declarations.</code></span>
<span class="codeline" id="line-734"><code>	// Note that this uses / always, even on Windows, because Go import</code></span>
<span class="codeline" id="line-735"><code>	// paths always use forward slashes.</code></span>
<span class="codeline" id="line-736"><code>	path := obj.imported.path</code></span>
<span class="codeline" id="line-737"><code>	elem := path</code></span>
<span class="codeline" id="line-738"><code>	if i := strings.LastIndex(elem, "/"); i &gt;= 0 {</code></span>
<span class="codeline" id="line-739"><code>		elem = elem[i+1:]</code></span>
<span class="codeline" id="line-740"><code>	}</code></span>
<span class="codeline" id="line-741"><code>	if obj.name == "" || obj.name == "." || obj.name == elem {</code></span>
<span class="codeline" id="line-742"><code>		check.softErrorf(obj, UnusedImport, "%q imported and not used", path)</code></span>
<span class="codeline" id="line-743"><code>	} else {</code></span>
<span class="codeline" id="line-744"><code>		check.softErrorf(obj, UnusedImport, "%q imported as %s and not used", path, obj.name)</code></span>
<span class="codeline" id="line-745"><code>	}</code></span>
<span class="codeline" id="line-746"><code>}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>// dir makes a good-faith attempt to return the directory</code></span>
<span class="codeline" id="line-749"><code>// portion of path. If path is empty, the result is ".".</code></span>
<span class="codeline" id="line-750"><code>// (Per the go/build package dependency tests, we cannot import</code></span>
<span class="codeline" id="line-751"><code>// path/filepath and simply use filepath.Dir.)</code></span>
<span class="codeline" id="line-752"><code>func dir(path string) string {</code></span>
<span class="codeline" id="line-753"><code>	if i := strings.LastIndexAny(path, `/\`); i &gt; 0 {</code></span>
<span class="codeline" id="line-754"><code>		return path[:i]</code></span>
<span class="codeline" id="line-755"><code>	}</code></span>
<span class="codeline" id="line-756"><code>	// i &lt;= 0</code></span>
<span class="codeline" id="line-757"><code>	return "."</code></span>
<span class="codeline" id="line-758"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>