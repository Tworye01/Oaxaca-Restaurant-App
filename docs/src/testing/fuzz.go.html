<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: fuzz.go in package testing</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	fuzz.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/testing.html">testing</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2020 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package testing</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"errors"</code></span>
<span class="codeline" id="line-9"><code>	"flag"</code></span>
<span class="codeline" id="line-10"><code>	"fmt"</code></span>
<span class="codeline" id="line-11"><code>	"io"</code></span>
<span class="codeline" id="line-12"><code>	"os"</code></span>
<span class="codeline" id="line-13"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-14"><code>	"reflect"</code></span>
<span class="codeline" id="line-15"><code>	"runtime"</code></span>
<span class="codeline" id="line-16"><code>	"strings"</code></span>
<span class="codeline" id="line-17"><code>	"time"</code></span>
<span class="codeline" id="line-18"><code>)</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>func initFuzzFlags() {</code></span>
<span class="codeline" id="line-21"><code>	matchFuzz = flag.String("test.fuzz", "", "run the fuzz test matching `regexp`")</code></span>
<span class="codeline" id="line-22"><code>	flag.Var(&amp;fuzzDuration, "test.fuzztime", "time to spend fuzzing; default is to run indefinitely")</code></span>
<span class="codeline" id="line-23"><code>	flag.Var(&amp;minimizeDuration, "test.fuzzminimizetime", "time to spend minimizing a value after finding a failing input")</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>	fuzzCacheDir = flag.String("test.fuzzcachedir", "", "directory where interesting fuzzing inputs are stored (for use only by cmd/go)")</code></span>
<span class="codeline" id="line-26"><code>	isFuzzWorker = flag.Bool("test.fuzzworker", false, "coordinate with the parent process to fuzz random values (for use only by cmd/go)")</code></span>
<span class="codeline" id="line-27"><code>}</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>var (</code></span>
<span class="codeline" id="line-30"><code>	matchFuzz        *string</code></span>
<span class="codeline" id="line-31"><code>	fuzzDuration     durationOrCountFlag</code></span>
<span class="codeline" id="line-32"><code>	minimizeDuration = durationOrCountFlag{d: 60 * time.Second, allowZero: true}</code></span>
<span class="codeline" id="line-33"><code>	fuzzCacheDir     *string</code></span>
<span class="codeline" id="line-34"><code>	isFuzzWorker     *bool</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>	// corpusDir is the parent directory of the fuzz test's seed corpus within</code></span>
<span class="codeline" id="line-37"><code>	// the package.</code></span>
<span class="codeline" id="line-38"><code>	corpusDir = "testdata/fuzz"</code></span>
<span class="codeline" id="line-39"><code>)</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>// fuzzWorkerExitCode is used as an exit code by fuzz worker processes after an</code></span>
<span class="codeline" id="line-42"><code>// internal error. This distinguishes internal errors from uncontrolled panics</code></span>
<span class="codeline" id="line-43"><code>// and other failures. Keep in sync with internal/fuzz.workerExitCode.</code></span>
<span class="codeline" id="line-44"><code>const fuzzWorkerExitCode = 70</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>// InternalFuzzTarget is an internal type but exported because it is</code></span>
<span class="codeline" id="line-47"><code>// cross-package; it is part of the implementation of the "go test" command.</code></span>
<span class="codeline" id="line-48"><code>type InternalFuzzTarget struct {</code></span>
<span class="codeline" id="line-49"><code>	Name string</code></span>
<span class="codeline" id="line-50"><code>	Fn   func(f *F)</code></span>
<span class="codeline" id="line-51"><code>}</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>// F is a type passed to fuzz tests.</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// Fuzz tests run generated inputs against a provided fuzz target, which can</code></span>
<span class="codeline" id="line-56"><code>// find and report potential bugs in the code being tested.</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// A fuzz test runs the seed corpus by default, which includes entries provided</code></span>
<span class="codeline" id="line-59"><code>// by (*F).Add and entries in the testdata/fuzz/&lt;FuzzTestName&gt; directory. After</code></span>
<span class="codeline" id="line-60"><code>// any necessary setup and calls to (*F).Add, the fuzz test must then call</code></span>
<span class="codeline" id="line-61"><code>// (*F).Fuzz to provide the fuzz target. See the testing package documentation</code></span>
<span class="codeline" id="line-62"><code>// for an example, and see the [F.Fuzz] and [F.Add] method documentation for</code></span>
<span class="codeline" id="line-63"><code>// details.</code></span>
<span class="codeline" id="line-64"><code>//</code></span>
<span class="codeline" id="line-65"><code>// *F methods can only be called before (*F).Fuzz. Once the test is</code></span>
<span class="codeline" id="line-66"><code>// executing the fuzz target, only (*T) methods can be used. The only *F methods</code></span>
<span class="codeline" id="line-67"><code>// that are allowed in the (*F).Fuzz function are (*F).Failed and (*F).Name.</code></span>
<span class="codeline" id="line-68"><code>type F struct {</code></span>
<span class="codeline" id="line-69"><code>	common</code></span>
<span class="codeline" id="line-70"><code>	fuzzContext *fuzzContext</code></span>
<span class="codeline" id="line-71"><code>	testContext *testContext</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>	// inFuzzFn is true when the fuzz function is running. Most F methods cannot</code></span>
<span class="codeline" id="line-74"><code>	// be called when inFuzzFn is true.</code></span>
<span class="codeline" id="line-75"><code>	inFuzzFn bool</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>	// corpus is a set of seed corpus entries, added with F.Add and loaded</code></span>
<span class="codeline" id="line-78"><code>	// from testdata.</code></span>
<span class="codeline" id="line-79"><code>	corpus []corpusEntry</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>	result     fuzzResult</code></span>
<span class="codeline" id="line-82"><code>	fuzzCalled bool</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>var _ TB = (*F)(nil)</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>// corpusEntry is an alias to the same type as internal/fuzz.CorpusEntry.</code></span>
<span class="codeline" id="line-88"><code>// We use a type alias because we don't want to export this type, and we can't</code></span>
<span class="codeline" id="line-89"><code>// import internal/fuzz from testing.</code></span>
<span class="codeline" id="line-90"><code>type corpusEntry = struct {</code></span>
<span class="codeline" id="line-91"><code>	Parent     string</code></span>
<span class="codeline" id="line-92"><code>	Path       string</code></span>
<span class="codeline" id="line-93"><code>	Data       []byte</code></span>
<span class="codeline" id="line-94"><code>	Values     []any</code></span>
<span class="codeline" id="line-95"><code>	Generation int</code></span>
<span class="codeline" id="line-96"><code>	IsSeed     bool</code></span>
<span class="codeline" id="line-97"><code>}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>// Helper marks the calling function as a test helper function.</code></span>
<span class="codeline" id="line-100"><code>// When printing file and line information, that function will be skipped.</code></span>
<span class="codeline" id="line-101"><code>// Helper may be called simultaneously from multiple goroutines.</code></span>
<span class="codeline" id="line-102"><code>func (f *F) Helper() {</code></span>
<span class="codeline" id="line-103"><code>	if f.inFuzzFn {</code></span>
<span class="codeline" id="line-104"><code>		panic("testing: f.Helper was called inside the fuzz target, use t.Helper instead")</code></span>
<span class="codeline" id="line-105"><code>	}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	// common.Helper is inlined here.</code></span>
<span class="codeline" id="line-108"><code>	// If we called it, it would mark F.Helper as the helper</code></span>
<span class="codeline" id="line-109"><code>	// instead of the caller.</code></span>
<span class="codeline" id="line-110"><code>	f.mu.Lock()</code></span>
<span class="codeline" id="line-111"><code>	defer f.mu.Unlock()</code></span>
<span class="codeline" id="line-112"><code>	if f.helperPCs == nil {</code></span>
<span class="codeline" id="line-113"><code>		f.helperPCs = make(map[uintptr]struct{})</code></span>
<span class="codeline" id="line-114"><code>	}</code></span>
<span class="codeline" id="line-115"><code>	// repeating code from callerName here to save walking a stack frame</code></span>
<span class="codeline" id="line-116"><code>	var pc [1]uintptr</code></span>
<span class="codeline" id="line-117"><code>	n := runtime.Callers(2, pc[:]) // skip runtime.Callers + Helper</code></span>
<span class="codeline" id="line-118"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-119"><code>		panic("testing: zero callers found")</code></span>
<span class="codeline" id="line-120"><code>	}</code></span>
<span class="codeline" id="line-121"><code>	if _, found := f.helperPCs[pc[0]]; !found {</code></span>
<span class="codeline" id="line-122"><code>		f.helperPCs[pc[0]] = struct{}{}</code></span>
<span class="codeline" id="line-123"><code>		f.helperNames = nil // map will be recreated next time it is needed</code></span>
<span class="codeline" id="line-124"><code>	}</code></span>
<span class="codeline" id="line-125"><code>}</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// Fail marks the function as having failed but continues execution.</code></span>
<span class="codeline" id="line-128"><code>func (f *F) Fail() {</code></span>
<span class="codeline" id="line-129"><code>	// (*F).Fail may be called by (*T).Fail, which we should allow. However, we</code></span>
<span class="codeline" id="line-130"><code>	// shouldn't allow direct (*F).Fail calls from inside the (*F).Fuzz function.</code></span>
<span class="codeline" id="line-131"><code>	if f.inFuzzFn {</code></span>
<span class="codeline" id="line-132"><code>		panic("testing: f.Fail was called inside the fuzz target, use t.Fail instead")</code></span>
<span class="codeline" id="line-133"><code>	}</code></span>
<span class="codeline" id="line-134"><code>	f.common.Helper()</code></span>
<span class="codeline" id="line-135"><code>	f.common.Fail()</code></span>
<span class="codeline" id="line-136"><code>}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>// Skipped reports whether the test was skipped.</code></span>
<span class="codeline" id="line-139"><code>func (f *F) Skipped() bool {</code></span>
<span class="codeline" id="line-140"><code>	// (*F).Skipped may be called by tRunner, which we should allow. However, we</code></span>
<span class="codeline" id="line-141"><code>	// shouldn't allow direct (*F).Skipped calls from inside the (*F).Fuzz function.</code></span>
<span class="codeline" id="line-142"><code>	if f.inFuzzFn {</code></span>
<span class="codeline" id="line-143"><code>		panic("testing: f.Skipped was called inside the fuzz target, use t.Skipped instead")</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code>	f.common.Helper()</code></span>
<span class="codeline" id="line-146"><code>	return f.common.Skipped()</code></span>
<span class="codeline" id="line-147"><code>}</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>// Add will add the arguments to the seed corpus for the fuzz test. This will be</code></span>
<span class="codeline" id="line-150"><code>// a no-op if called after or within the fuzz target, and args must match the</code></span>
<span class="codeline" id="line-151"><code>// arguments for the fuzz target.</code></span>
<span class="codeline" id="line-152"><code>func (f *F) Add(args ...any) {</code></span>
<span class="codeline" id="line-153"><code>	var values []any</code></span>
<span class="codeline" id="line-154"><code>	for i := range args {</code></span>
<span class="codeline" id="line-155"><code>		if t := reflect.TypeOf(args[i]); !supportedTypes[t] {</code></span>
<span class="codeline" id="line-156"><code>			panic(fmt.Sprintf("testing: unsupported type to Add %v", t))</code></span>
<span class="codeline" id="line-157"><code>		}</code></span>
<span class="codeline" id="line-158"><code>		values = append(values, args[i])</code></span>
<span class="codeline" id="line-159"><code>	}</code></span>
<span class="codeline" id="line-160"><code>	f.corpus = append(f.corpus, corpusEntry{Values: values, IsSeed: true, Path: fmt.Sprintf("seed#%d", len(f.corpus))})</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// supportedTypes represents all of the supported types which can be fuzzed.</code></span>
<span class="codeline" id="line-164"><code>var supportedTypes = map[reflect.Type]bool{</code></span>
<span class="codeline" id="line-165"><code>	reflect.TypeOf(([]byte)("")):  true,</code></span>
<span class="codeline" id="line-166"><code>	reflect.TypeOf((string)("")):  true,</code></span>
<span class="codeline" id="line-167"><code>	reflect.TypeOf((bool)(false)): true,</code></span>
<span class="codeline" id="line-168"><code>	reflect.TypeOf((byte)(0)):     true,</code></span>
<span class="codeline" id="line-169"><code>	reflect.TypeOf((rune)(0)):     true,</code></span>
<span class="codeline" id="line-170"><code>	reflect.TypeOf((float32)(0)):  true,</code></span>
<span class="codeline" id="line-171"><code>	reflect.TypeOf((float64)(0)):  true,</code></span>
<span class="codeline" id="line-172"><code>	reflect.TypeOf((int)(0)):      true,</code></span>
<span class="codeline" id="line-173"><code>	reflect.TypeOf((int8)(0)):     true,</code></span>
<span class="codeline" id="line-174"><code>	reflect.TypeOf((int16)(0)):    true,</code></span>
<span class="codeline" id="line-175"><code>	reflect.TypeOf((int32)(0)):    true,</code></span>
<span class="codeline" id="line-176"><code>	reflect.TypeOf((int64)(0)):    true,</code></span>
<span class="codeline" id="line-177"><code>	reflect.TypeOf((uint)(0)):     true,</code></span>
<span class="codeline" id="line-178"><code>	reflect.TypeOf((uint8)(0)):    true,</code></span>
<span class="codeline" id="line-179"><code>	reflect.TypeOf((uint16)(0)):   true,</code></span>
<span class="codeline" id="line-180"><code>	reflect.TypeOf((uint32)(0)):   true,</code></span>
<span class="codeline" id="line-181"><code>	reflect.TypeOf((uint64)(0)):   true,</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>// Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of</code></span>
<span class="codeline" id="line-185"><code>// arguments, those arguments will be added to the seed corpus.</code></span>
<span class="codeline" id="line-186"><code>//</code></span>
<span class="codeline" id="line-187"><code>// ff must be a function with no return value whose first argument is *T and</code></span>
<span class="codeline" id="line-188"><code>// whose remaining arguments are the types to be fuzzed.</code></span>
<span class="codeline" id="line-189"><code>// For example:</code></span>
<span class="codeline" id="line-190"><code>//</code></span>
<span class="codeline" id="line-191"><code>//	f.Fuzz(func(t *testing.T, b []byte, i int) { ... })</code></span>
<span class="codeline" id="line-192"><code>//</code></span>
<span class="codeline" id="line-193"><code>// The following types are allowed: []byte, string, bool, byte, rune, float32,</code></span>
<span class="codeline" id="line-194"><code>// float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64.</code></span>
<span class="codeline" id="line-195"><code>// More types may be supported in the future.</code></span>
<span class="codeline" id="line-196"><code>//</code></span>
<span class="codeline" id="line-197"><code>// ff must not call any *F methods, e.g. (*F).Log, (*F).Error, (*F).Skip. Use</code></span>
<span class="codeline" id="line-198"><code>// the corresponding *T method instead. The only *F methods that are allowed in</code></span>
<span class="codeline" id="line-199"><code>// the (*F).Fuzz function are (*F).Failed and (*F).Name.</code></span>
<span class="codeline" id="line-200"><code>//</code></span>
<span class="codeline" id="line-201"><code>// This function should be fast and deterministic, and its behavior should not</code></span>
<span class="codeline" id="line-202"><code>// depend on shared state. No mutatable input arguments, or pointers to them,</code></span>
<span class="codeline" id="line-203"><code>// should be retained between executions of the fuzz function, as the memory</code></span>
<span class="codeline" id="line-204"><code>// backing them may be mutated during a subsequent invocation. ff must not</code></span>
<span class="codeline" id="line-205"><code>// modify the underlying data of the arguments provided by the fuzzing engine.</code></span>
<span class="codeline" id="line-206"><code>//</code></span>
<span class="codeline" id="line-207"><code>// When fuzzing, F.Fuzz does not return until a problem is found, time runs out</code></span>
<span class="codeline" id="line-208"><code>// (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz</code></span>
<span class="codeline" id="line-209"><code>// should be called exactly once, unless F.Skip or [F.Fail] is called beforehand.</code></span>
<span class="codeline" id="line-210"><code>func (f *F) Fuzz(ff any) {</code></span>
<span class="codeline" id="line-211"><code>	if f.fuzzCalled {</code></span>
<span class="codeline" id="line-212"><code>		panic("testing: F.Fuzz called more than once")</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code>	f.fuzzCalled = true</code></span>
<span class="codeline" id="line-215"><code>	if f.failed {</code></span>
<span class="codeline" id="line-216"><code>		return</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	f.Helper()</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>	// ff should be in the form func(*testing.T, ...interface{})</code></span>
<span class="codeline" id="line-221"><code>	fn := reflect.ValueOf(ff)</code></span>
<span class="codeline" id="line-222"><code>	fnType := fn.Type()</code></span>
<span class="codeline" id="line-223"><code>	if fnType.Kind() != reflect.Func {</code></span>
<span class="codeline" id="line-224"><code>		panic("testing: F.Fuzz must receive a function")</code></span>
<span class="codeline" id="line-225"><code>	}</code></span>
<span class="codeline" id="line-226"><code>	if fnType.NumIn() &lt; 2 || fnType.In(0) != reflect.TypeOf((*T)(nil)) {</code></span>
<span class="codeline" id="line-227"><code>		panic("testing: fuzz target must receive at least two arguments, where the first argument is a *T")</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	if fnType.NumOut() != 0 {</code></span>
<span class="codeline" id="line-230"><code>		panic("testing: fuzz target must not return a value")</code></span>
<span class="codeline" id="line-231"><code>	}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>	// Save the types of the function to compare against the corpus.</code></span>
<span class="codeline" id="line-234"><code>	var types []reflect.Type</code></span>
<span class="codeline" id="line-235"><code>	for i := 1; i &lt; fnType.NumIn(); i++ {</code></span>
<span class="codeline" id="line-236"><code>		t := fnType.In(i)</code></span>
<span class="codeline" id="line-237"><code>		if !supportedTypes[t] {</code></span>
<span class="codeline" id="line-238"><code>			panic(fmt.Sprintf("testing: unsupported type for fuzzing %v", t))</code></span>
<span class="codeline" id="line-239"><code>		}</code></span>
<span class="codeline" id="line-240"><code>		types = append(types, t)</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>	// Load the testdata seed corpus. Check types of entries in the testdata</code></span>
<span class="codeline" id="line-244"><code>	// corpus and entries declared with F.Add.</code></span>
<span class="codeline" id="line-245"><code>	//</code></span>
<span class="codeline" id="line-246"><code>	// Don't load the seed corpus if this is a worker process; we won't use it.</code></span>
<span class="codeline" id="line-247"><code>	if f.fuzzContext.mode != fuzzWorker {</code></span>
<span class="codeline" id="line-248"><code>		for _, c := range f.corpus {</code></span>
<span class="codeline" id="line-249"><code>			if err := f.fuzzContext.deps.CheckCorpus(c.Values, types); err != nil {</code></span>
<span class="codeline" id="line-250"><code>				// TODO(#48302): Report the source location of the F.Add call.</code></span>
<span class="codeline" id="line-251"><code>				f.Fatal(err)</code></span>
<span class="codeline" id="line-252"><code>			}</code></span>
<span class="codeline" id="line-253"><code>		}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>		// Load seed corpus</code></span>
<span class="codeline" id="line-256"><code>		c, err := f.fuzzContext.deps.ReadCorpus(filepath.Join(corpusDir, f.name), types)</code></span>
<span class="codeline" id="line-257"><code>		if err != nil {</code></span>
<span class="codeline" id="line-258"><code>			f.Fatal(err)</code></span>
<span class="codeline" id="line-259"><code>		}</code></span>
<span class="codeline" id="line-260"><code>		for i := range c {</code></span>
<span class="codeline" id="line-261"><code>			c[i].IsSeed = true // these are all seed corpus values</code></span>
<span class="codeline" id="line-262"><code>			if f.fuzzContext.mode == fuzzCoordinator {</code></span>
<span class="codeline" id="line-263"><code>				// If this is the coordinator process, zero the values, since we don't need</code></span>
<span class="codeline" id="line-264"><code>				// to hold onto them.</code></span>
<span class="codeline" id="line-265"><code>				c[i].Values = nil</code></span>
<span class="codeline" id="line-266"><code>			}</code></span>
<span class="codeline" id="line-267"><code>		}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>		f.corpus = append(f.corpus, c...)</code></span>
<span class="codeline" id="line-270"><code>	}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>	// run calls fn on a given input, as a subtest with its own T.</code></span>
<span class="codeline" id="line-273"><code>	// run is analogous to T.Run. The test filtering and cleanup works similarly.</code></span>
<span class="codeline" id="line-274"><code>	// fn is called in its own goroutine.</code></span>
<span class="codeline" id="line-275"><code>	run := func(captureOut io.Writer, e corpusEntry) (ok bool) {</code></span>
<span class="codeline" id="line-276"><code>		if e.Values == nil {</code></span>
<span class="codeline" id="line-277"><code>			// The corpusEntry must have non-nil Values in order to run the</code></span>
<span class="codeline" id="line-278"><code>			// test. If Values is nil, it is a bug in our code.</code></span>
<span class="codeline" id="line-279"><code>			panic(fmt.Sprintf("corpus file %q was not unmarshaled", e.Path))</code></span>
<span class="codeline" id="line-280"><code>		}</code></span>
<span class="codeline" id="line-281"><code>		if shouldFailFast() {</code></span>
<span class="codeline" id="line-282"><code>			return true</code></span>
<span class="codeline" id="line-283"><code>		}</code></span>
<span class="codeline" id="line-284"><code>		testName := f.name</code></span>
<span class="codeline" id="line-285"><code>		if e.Path != "" {</code></span>
<span class="codeline" id="line-286"><code>			testName = fmt.Sprintf("%s/%s", testName, filepath.Base(e.Path))</code></span>
<span class="codeline" id="line-287"><code>		}</code></span>
<span class="codeline" id="line-288"><code>		if f.testContext.isFuzzing {</code></span>
<span class="codeline" id="line-289"><code>			// Don't preserve subtest names while fuzzing. If fn calls T.Run,</code></span>
<span class="codeline" id="line-290"><code>			// there will be a very large number of subtests with duplicate names,</code></span>
<span class="codeline" id="line-291"><code>			// which will use a large amount of memory. The subtest names aren't</code></span>
<span class="codeline" id="line-292"><code>			// useful since there's no way to re-run them deterministically.</code></span>
<span class="codeline" id="line-293"><code>			f.testContext.match.clearSubNames()</code></span>
<span class="codeline" id="line-294"><code>		}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>		// Record the stack trace at the point of this call so that if the subtest</code></span>
<span class="codeline" id="line-297"><code>		// function - which runs in a separate stack - is marked as a helper, we can</code></span>
<span class="codeline" id="line-298"><code>		// continue walking the stack into the parent test.</code></span>
<span class="codeline" id="line-299"><code>		var pc [maxStackLen]uintptr</code></span>
<span class="codeline" id="line-300"><code>		n := runtime.Callers(2, pc[:])</code></span>
<span class="codeline" id="line-301"><code>		t := &amp;T{</code></span>
<span class="codeline" id="line-302"><code>			common: common{</code></span>
<span class="codeline" id="line-303"><code>				barrier: make(chan bool),</code></span>
<span class="codeline" id="line-304"><code>				signal:  make(chan bool),</code></span>
<span class="codeline" id="line-305"><code>				name:    testName,</code></span>
<span class="codeline" id="line-306"><code>				parent:  &amp;f.common,</code></span>
<span class="codeline" id="line-307"><code>				level:   f.level + 1,</code></span>
<span class="codeline" id="line-308"><code>				creator: pc[:n],</code></span>
<span class="codeline" id="line-309"><code>				chatty:  f.chatty,</code></span>
<span class="codeline" id="line-310"><code>			},</code></span>
<span class="codeline" id="line-311"><code>			context: f.testContext,</code></span>
<span class="codeline" id="line-312"><code>		}</code></span>
<span class="codeline" id="line-313"><code>		if captureOut != nil {</code></span>
<span class="codeline" id="line-314"><code>			// t.parent aliases f.common.</code></span>
<span class="codeline" id="line-315"><code>			t.parent.w = captureOut</code></span>
<span class="codeline" id="line-316"><code>		}</code></span>
<span class="codeline" id="line-317"><code>		t.w = indenter{&amp;t.common}</code></span>
<span class="codeline" id="line-318"><code>		if t.chatty != nil {</code></span>
<span class="codeline" id="line-319"><code>			t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)</code></span>
<span class="codeline" id="line-320"><code>		}</code></span>
<span class="codeline" id="line-321"><code>		f.common.inFuzzFn, f.inFuzzFn = true, true</code></span>
<span class="codeline" id="line-322"><code>		go tRunner(t, func(t *T) {</code></span>
<span class="codeline" id="line-323"><code>			args := []reflect.Value{reflect.ValueOf(t)}</code></span>
<span class="codeline" id="line-324"><code>			for _, v := range e.Values {</code></span>
<span class="codeline" id="line-325"><code>				args = append(args, reflect.ValueOf(v))</code></span>
<span class="codeline" id="line-326"><code>			}</code></span>
<span class="codeline" id="line-327"><code>			// Before resetting the current coverage, defer the snapshot so that</code></span>
<span class="codeline" id="line-328"><code>			// we make sure it is called right before the tRunner function</code></span>
<span class="codeline" id="line-329"><code>			// exits, regardless of whether it was executed cleanly, panicked,</code></span>
<span class="codeline" id="line-330"><code>			// or if the fuzzFn called t.Fatal.</code></span>
<span class="codeline" id="line-331"><code>			if f.testContext.isFuzzing {</code></span>
<span class="codeline" id="line-332"><code>				defer f.fuzzContext.deps.SnapshotCoverage()</code></span>
<span class="codeline" id="line-333"><code>				f.fuzzContext.deps.ResetCoverage()</code></span>
<span class="codeline" id="line-334"><code>			}</code></span>
<span class="codeline" id="line-335"><code>			fn.Call(args)</code></span>
<span class="codeline" id="line-336"><code>		})</code></span>
<span class="codeline" id="line-337"><code>		&lt;-t.signal</code></span>
<span class="codeline" id="line-338"><code>		if t.chatty != nil &amp;&amp; t.chatty.json {</code></span>
<span class="codeline" id="line-339"><code>			t.chatty.Updatef(t.parent.name, "=== NAME  %s\n", t.parent.name)</code></span>
<span class="codeline" id="line-340"><code>		}</code></span>
<span class="codeline" id="line-341"><code>		f.common.inFuzzFn, f.inFuzzFn = false, false</code></span>
<span class="codeline" id="line-342"><code>		return !t.Failed()</code></span>
<span class="codeline" id="line-343"><code>	}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>	switch f.fuzzContext.mode {</code></span>
<span class="codeline" id="line-346"><code>	case fuzzCoordinator:</code></span>
<span class="codeline" id="line-347"><code>		// Fuzzing is enabled, and this is the test process started by 'go test'.</code></span>
<span class="codeline" id="line-348"><code>		// Act as the coordinator process, and coordinate workers to perform the</code></span>
<span class="codeline" id="line-349"><code>		// actual fuzzing.</code></span>
<span class="codeline" id="line-350"><code>		corpusTargetDir := filepath.Join(corpusDir, f.name)</code></span>
<span class="codeline" id="line-351"><code>		cacheTargetDir := filepath.Join(*fuzzCacheDir, f.name)</code></span>
<span class="codeline" id="line-352"><code>		err := f.fuzzContext.deps.CoordinateFuzzing(</code></span>
<span class="codeline" id="line-353"><code>			fuzzDuration.d,</code></span>
<span class="codeline" id="line-354"><code>			int64(fuzzDuration.n),</code></span>
<span class="codeline" id="line-355"><code>			minimizeDuration.d,</code></span>
<span class="codeline" id="line-356"><code>			int64(minimizeDuration.n),</code></span>
<span class="codeline" id="line-357"><code>			*parallel,</code></span>
<span class="codeline" id="line-358"><code>			f.corpus,</code></span>
<span class="codeline" id="line-359"><code>			types,</code></span>
<span class="codeline" id="line-360"><code>			corpusTargetDir,</code></span>
<span class="codeline" id="line-361"><code>			cacheTargetDir)</code></span>
<span class="codeline" id="line-362"><code>		if err != nil {</code></span>
<span class="codeline" id="line-363"><code>			f.result = fuzzResult{Error: err}</code></span>
<span class="codeline" id="line-364"><code>			f.Fail()</code></span>
<span class="codeline" id="line-365"><code>			fmt.Fprintf(f.w, "%v\n", err)</code></span>
<span class="codeline" id="line-366"><code>			if crashErr, ok := err.(fuzzCrashError); ok {</code></span>
<span class="codeline" id="line-367"><code>				crashPath := crashErr.CrashPath()</code></span>
<span class="codeline" id="line-368"><code>				fmt.Fprintf(f.w, "Failing input written to %s\n", crashPath)</code></span>
<span class="codeline" id="line-369"><code>				testName := filepath.Base(crashPath)</code></span>
<span class="codeline" id="line-370"><code>				fmt.Fprintf(f.w, "To re-run:\ngo test -run=%s/%s\n", f.name, testName)</code></span>
<span class="codeline" id="line-371"><code>			}</code></span>
<span class="codeline" id="line-372"><code>		}</code></span>
<span class="codeline" id="line-373"><code>		// TODO(jayconrod,katiehockman): Aggregate statistics across workers</code></span>
<span class="codeline" id="line-374"><code>		// and add to FuzzResult (ie. time taken, num iterations)</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>	case fuzzWorker:</code></span>
<span class="codeline" id="line-377"><code>		// Fuzzing is enabled, and this is a worker process. Follow instructions</code></span>
<span class="codeline" id="line-378"><code>		// from the coordinator.</code></span>
<span class="codeline" id="line-379"><code>		if err := f.fuzzContext.deps.RunFuzzWorker(func(e corpusEntry) error {</code></span>
<span class="codeline" id="line-380"><code>			// Don't write to f.w (which points to Stdout) if running from a</code></span>
<span class="codeline" id="line-381"><code>			// fuzz worker. This would become very verbose, particularly during</code></span>
<span class="codeline" id="line-382"><code>			// minimization. Return the error instead, and let the caller deal</code></span>
<span class="codeline" id="line-383"><code>			// with the output.</code></span>
<span class="codeline" id="line-384"><code>			var buf strings.Builder</code></span>
<span class="codeline" id="line-385"><code>			if ok := run(&amp;buf, e); !ok {</code></span>
<span class="codeline" id="line-386"><code>				return errors.New(buf.String())</code></span>
<span class="codeline" id="line-387"><code>			}</code></span>
<span class="codeline" id="line-388"><code>			return nil</code></span>
<span class="codeline" id="line-389"><code>		}); err != nil {</code></span>
<span class="codeline" id="line-390"><code>			// Internal errors are marked with f.Fail; user code may call this too, before F.Fuzz.</code></span>
<span class="codeline" id="line-391"><code>			// The worker will exit with fuzzWorkerExitCode, indicating this is a failure</code></span>
<span class="codeline" id="line-392"><code>			// (and 'go test' should exit non-zero) but a failing input should not be recorded.</code></span>
<span class="codeline" id="line-393"><code>			f.Errorf("communicating with fuzzing coordinator: %v", err)</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	default:</code></span>
<span class="codeline" id="line-397"><code>		// Fuzzing is not enabled, or will be done later. Only run the seed</code></span>
<span class="codeline" id="line-398"><code>		// corpus now.</code></span>
<span class="codeline" id="line-399"><code>		for _, e := range f.corpus {</code></span>
<span class="codeline" id="line-400"><code>			name := fmt.Sprintf("%s/%s", f.name, filepath.Base(e.Path))</code></span>
<span class="codeline" id="line-401"><code>			if _, ok, _ := f.testContext.match.fullName(nil, name); ok {</code></span>
<span class="codeline" id="line-402"><code>				run(f.w, e)</code></span>
<span class="codeline" id="line-403"><code>			}</code></span>
<span class="codeline" id="line-404"><code>		}</code></span>
<span class="codeline" id="line-405"><code>	}</code></span>
<span class="codeline" id="line-406"><code>}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>func (f *F) report() {</code></span>
<span class="codeline" id="line-409"><code>	if *isFuzzWorker || f.parent == nil {</code></span>
<span class="codeline" id="line-410"><code>		return</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code>	dstr := fmtDuration(f.duration)</code></span>
<span class="codeline" id="line-413"><code>	format := "--- %s: %s (%s)\n"</code></span>
<span class="codeline" id="line-414"><code>	if f.Failed() {</code></span>
<span class="codeline" id="line-415"><code>		f.flushToParent(f.name, format, "FAIL", f.name, dstr)</code></span>
<span class="codeline" id="line-416"><code>	} else if f.chatty != nil {</code></span>
<span class="codeline" id="line-417"><code>		if f.Skipped() {</code></span>
<span class="codeline" id="line-418"><code>			f.flushToParent(f.name, format, "SKIP", f.name, dstr)</code></span>
<span class="codeline" id="line-419"><code>		} else {</code></span>
<span class="codeline" id="line-420"><code>			f.flushToParent(f.name, format, "PASS", f.name, dstr)</code></span>
<span class="codeline" id="line-421"><code>		}</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code>}</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>// fuzzResult contains the results of a fuzz run.</code></span>
<span class="codeline" id="line-426"><code>type fuzzResult struct {</code></span>
<span class="codeline" id="line-427"><code>	N     int           // The number of iterations.</code></span>
<span class="codeline" id="line-428"><code>	T     time.Duration // The total time taken.</code></span>
<span class="codeline" id="line-429"><code>	Error error         // Error is the error from the failing input</code></span>
<span class="codeline" id="line-430"><code>}</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>func (r fuzzResult) String() string {</code></span>
<span class="codeline" id="line-433"><code>	if r.Error == nil {</code></span>
<span class="codeline" id="line-434"><code>		return ""</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code>	return r.Error.Error()</code></span>
<span class="codeline" id="line-437"><code>}</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>// fuzzCrashError is satisfied by a failing input detected while fuzzing.</code></span>
<span class="codeline" id="line-440"><code>// These errors are written to the seed corpus and can be re-run with 'go test'.</code></span>
<span class="codeline" id="line-441"><code>// Errors within the fuzzing framework (like I/O errors between coordinator</code></span>
<span class="codeline" id="line-442"><code>// and worker processes) don't satisfy this interface.</code></span>
<span class="codeline" id="line-443"><code>type fuzzCrashError interface {</code></span>
<span class="codeline" id="line-444"><code>	error</code></span>
<span class="codeline" id="line-445"><code>	Unwrap() error</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	// CrashPath returns the path of the subtest that corresponds to the saved</code></span>
<span class="codeline" id="line-448"><code>	// crash input file in the seed corpus. The test can be re-run with go test</code></span>
<span class="codeline" id="line-449"><code>	// -run=$test/$name $test is the fuzz test name, and $name is the</code></span>
<span class="codeline" id="line-450"><code>	// filepath.Base of the string returned here.</code></span>
<span class="codeline" id="line-451"><code>	CrashPath() string</code></span>
<span class="codeline" id="line-452"><code>}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>// fuzzContext holds fields common to all fuzz tests.</code></span>
<span class="codeline" id="line-455"><code>type fuzzContext struct {</code></span>
<span class="codeline" id="line-456"><code>	deps testDeps</code></span>
<span class="codeline" id="line-457"><code>	mode fuzzMode</code></span>
<span class="codeline" id="line-458"><code>}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>type fuzzMode uint8</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>const (</code></span>
<span class="codeline" id="line-463"><code>	seedCorpusOnly fuzzMode = iota</code></span>
<span class="codeline" id="line-464"><code>	fuzzCoordinator</code></span>
<span class="codeline" id="line-465"><code>	fuzzWorker</code></span>
<span class="codeline" id="line-466"><code>)</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>// runFuzzTests runs the fuzz tests matching the pattern for -run. This will</code></span>
<span class="codeline" id="line-469"><code>// only run the (*F).Fuzz function for each seed corpus without using the</code></span>
<span class="codeline" id="line-470"><code>// fuzzing engine to generate or mutate inputs.</code></span>
<span class="codeline" id="line-471"><code>func runFuzzTests(deps testDeps, fuzzTests []InternalFuzzTarget, deadline time.Time) (ran, ok bool) {</code></span>
<span class="codeline" id="line-472"><code>	ok = true</code></span>
<span class="codeline" id="line-473"><code>	if len(fuzzTests) == 0 || *isFuzzWorker {</code></span>
<span class="codeline" id="line-474"><code>		return ran, ok</code></span>
<span class="codeline" id="line-475"><code>	}</code></span>
<span class="codeline" id="line-476"><code>	m := newMatcher(deps.MatchString, *match, "-test.run", *skip)</code></span>
<span class="codeline" id="line-477"><code>	var mFuzz *matcher</code></span>
<span class="codeline" id="line-478"><code>	if *matchFuzz != "" {</code></span>
<span class="codeline" id="line-479"><code>		mFuzz = newMatcher(deps.MatchString, *matchFuzz, "-test.fuzz", *skip)</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>	for _, procs := range cpuList {</code></span>
<span class="codeline" id="line-483"><code>		runtime.GOMAXPROCS(procs)</code></span>
<span class="codeline" id="line-484"><code>		for i := uint(0); i &lt; *count; i++ {</code></span>
<span class="codeline" id="line-485"><code>			if shouldFailFast() {</code></span>
<span class="codeline" id="line-486"><code>				break</code></span>
<span class="codeline" id="line-487"><code>			}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>			tctx := newTestContext(*parallel, m)</code></span>
<span class="codeline" id="line-490"><code>			tctx.deadline = deadline</code></span>
<span class="codeline" id="line-491"><code>			fctx := &amp;fuzzContext{deps: deps, mode: seedCorpusOnly}</code></span>
<span class="codeline" id="line-492"><code>			root := common{w: os.Stdout} // gather output in one place</code></span>
<span class="codeline" id="line-493"><code>			if Verbose() {</code></span>
<span class="codeline" id="line-494"><code>				root.chatty = newChattyPrinter(root.w)</code></span>
<span class="codeline" id="line-495"><code>			}</code></span>
<span class="codeline" id="line-496"><code>			for _, ft := range fuzzTests {</code></span>
<span class="codeline" id="line-497"><code>				if shouldFailFast() {</code></span>
<span class="codeline" id="line-498"><code>					break</code></span>
<span class="codeline" id="line-499"><code>				}</code></span>
<span class="codeline" id="line-500"><code>				testName, matched, _ := tctx.match.fullName(nil, ft.Name)</code></span>
<span class="codeline" id="line-501"><code>				if !matched {</code></span>
<span class="codeline" id="line-502"><code>					continue</code></span>
<span class="codeline" id="line-503"><code>				}</code></span>
<span class="codeline" id="line-504"><code>				if mFuzz != nil {</code></span>
<span class="codeline" id="line-505"><code>					if _, fuzzMatched, _ := mFuzz.fullName(nil, ft.Name); fuzzMatched {</code></span>
<span class="codeline" id="line-506"><code>						// If this will be fuzzed, then don't run the seed corpus</code></span>
<span class="codeline" id="line-507"><code>						// right now. That will happen later.</code></span>
<span class="codeline" id="line-508"><code>						continue</code></span>
<span class="codeline" id="line-509"><code>					}</code></span>
<span class="codeline" id="line-510"><code>				}</code></span>
<span class="codeline" id="line-511"><code>				f := &amp;F{</code></span>
<span class="codeline" id="line-512"><code>					common: common{</code></span>
<span class="codeline" id="line-513"><code>						signal:  make(chan bool),</code></span>
<span class="codeline" id="line-514"><code>						barrier: make(chan bool),</code></span>
<span class="codeline" id="line-515"><code>						name:    testName,</code></span>
<span class="codeline" id="line-516"><code>						parent:  &amp;root,</code></span>
<span class="codeline" id="line-517"><code>						level:   root.level + 1,</code></span>
<span class="codeline" id="line-518"><code>						chatty:  root.chatty,</code></span>
<span class="codeline" id="line-519"><code>					},</code></span>
<span class="codeline" id="line-520"><code>					testContext: tctx,</code></span>
<span class="codeline" id="line-521"><code>					fuzzContext: fctx,</code></span>
<span class="codeline" id="line-522"><code>				}</code></span>
<span class="codeline" id="line-523"><code>				f.w = indenter{&amp;f.common}</code></span>
<span class="codeline" id="line-524"><code>				if f.chatty != nil {</code></span>
<span class="codeline" id="line-525"><code>					f.chatty.Updatef(f.name, "=== RUN   %s\n", f.name)</code></span>
<span class="codeline" id="line-526"><code>				}</code></span>
<span class="codeline" id="line-527"><code>				go fRunner(f, ft.Fn)</code></span>
<span class="codeline" id="line-528"><code>				&lt;-f.signal</code></span>
<span class="codeline" id="line-529"><code>				if f.chatty != nil &amp;&amp; f.chatty.json {</code></span>
<span class="codeline" id="line-530"><code>					f.chatty.Updatef(f.parent.name, "=== NAME  %s\n", f.parent.name)</code></span>
<span class="codeline" id="line-531"><code>				}</code></span>
<span class="codeline" id="line-532"><code>				ok = ok &amp;&amp; !f.Failed()</code></span>
<span class="codeline" id="line-533"><code>				ran = ran || f.ran</code></span>
<span class="codeline" id="line-534"><code>			}</code></span>
<span class="codeline" id="line-535"><code>			if !ran {</code></span>
<span class="codeline" id="line-536"><code>				// There were no tests to run on this iteration.</code></span>
<span class="codeline" id="line-537"><code>				// This won't change, so no reason to keep trying.</code></span>
<span class="codeline" id="line-538"><code>				break</code></span>
<span class="codeline" id="line-539"><code>			}</code></span>
<span class="codeline" id="line-540"><code>		}</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>	return ran, ok</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>// runFuzzing runs the fuzz test matching the pattern for -fuzz. Only one such</code></span>
<span class="codeline" id="line-547"><code>// fuzz test must match. This will run the fuzzing engine to generate and</code></span>
<span class="codeline" id="line-548"><code>// mutate new inputs against the fuzz target.</code></span>
<span class="codeline" id="line-549"><code>//</code></span>
<span class="codeline" id="line-550"><code>// If fuzzing is disabled (-test.fuzz is not set), runFuzzing</code></span>
<span class="codeline" id="line-551"><code>// returns immediately.</code></span>
<span class="codeline" id="line-552"><code>func runFuzzing(deps testDeps, fuzzTests []InternalFuzzTarget) (ok bool) {</code></span>
<span class="codeline" id="line-553"><code>	if len(fuzzTests) == 0 || *matchFuzz == "" {</code></span>
<span class="codeline" id="line-554"><code>		return true</code></span>
<span class="codeline" id="line-555"><code>	}</code></span>
<span class="codeline" id="line-556"><code>	m := newMatcher(deps.MatchString, *matchFuzz, "-test.fuzz", *skip)</code></span>
<span class="codeline" id="line-557"><code>	tctx := newTestContext(1, m)</code></span>
<span class="codeline" id="line-558"><code>	tctx.isFuzzing = true</code></span>
<span class="codeline" id="line-559"><code>	fctx := &amp;fuzzContext{</code></span>
<span class="codeline" id="line-560"><code>		deps: deps,</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code>	root := common{w: os.Stdout}</code></span>
<span class="codeline" id="line-563"><code>	if *isFuzzWorker {</code></span>
<span class="codeline" id="line-564"><code>		root.w = io.Discard</code></span>
<span class="codeline" id="line-565"><code>		fctx.mode = fuzzWorker</code></span>
<span class="codeline" id="line-566"><code>	} else {</code></span>
<span class="codeline" id="line-567"><code>		fctx.mode = fuzzCoordinator</code></span>
<span class="codeline" id="line-568"><code>	}</code></span>
<span class="codeline" id="line-569"><code>	if Verbose() &amp;&amp; !*isFuzzWorker {</code></span>
<span class="codeline" id="line-570"><code>		root.chatty = newChattyPrinter(root.w)</code></span>
<span class="codeline" id="line-571"><code>	}</code></span>
<span class="codeline" id="line-572"><code>	var fuzzTest *InternalFuzzTarget</code></span>
<span class="codeline" id="line-573"><code>	var testName string</code></span>
<span class="codeline" id="line-574"><code>	var matched []string</code></span>
<span class="codeline" id="line-575"><code>	for i := range fuzzTests {</code></span>
<span class="codeline" id="line-576"><code>		name, ok, _ := tctx.match.fullName(nil, fuzzTests[i].Name)</code></span>
<span class="codeline" id="line-577"><code>		if !ok {</code></span>
<span class="codeline" id="line-578"><code>			continue</code></span>
<span class="codeline" id="line-579"><code>		}</code></span>
<span class="codeline" id="line-580"><code>		matched = append(matched, name)</code></span>
<span class="codeline" id="line-581"><code>		fuzzTest = &amp;fuzzTests[i]</code></span>
<span class="codeline" id="line-582"><code>		testName = name</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code>	if len(matched) == 0 {</code></span>
<span class="codeline" id="line-585"><code>		fmt.Fprintln(os.Stderr, "testing: warning: no fuzz tests to fuzz")</code></span>
<span class="codeline" id="line-586"><code>		return true</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code>	if len(matched) &gt; 1 {</code></span>
<span class="codeline" id="line-589"><code>		fmt.Fprintf(os.Stderr, "testing: will not fuzz, -fuzz matches more than one fuzz test: %v\n", matched)</code></span>
<span class="codeline" id="line-590"><code>		return false</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code></code></span>
<span class="codeline" id="line-593"><code>	f := &amp;F{</code></span>
<span class="codeline" id="line-594"><code>		common: common{</code></span>
<span class="codeline" id="line-595"><code>			signal:  make(chan bool),</code></span>
<span class="codeline" id="line-596"><code>			barrier: nil, // T.Parallel has no effect when fuzzing.</code></span>
<span class="codeline" id="line-597"><code>			name:    testName,</code></span>
<span class="codeline" id="line-598"><code>			parent:  &amp;root,</code></span>
<span class="codeline" id="line-599"><code>			level:   root.level + 1,</code></span>
<span class="codeline" id="line-600"><code>			chatty:  root.chatty,</code></span>
<span class="codeline" id="line-601"><code>		},</code></span>
<span class="codeline" id="line-602"><code>		fuzzContext: fctx,</code></span>
<span class="codeline" id="line-603"><code>		testContext: tctx,</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code>	f.w = indenter{&amp;f.common}</code></span>
<span class="codeline" id="line-606"><code>	if f.chatty != nil {</code></span>
<span class="codeline" id="line-607"><code>		f.chatty.Updatef(f.name, "=== RUN   %s\n", f.name)</code></span>
<span class="codeline" id="line-608"><code>	}</code></span>
<span class="codeline" id="line-609"><code>	go fRunner(f, fuzzTest.Fn)</code></span>
<span class="codeline" id="line-610"><code>	&lt;-f.signal</code></span>
<span class="codeline" id="line-611"><code>	if f.chatty != nil {</code></span>
<span class="codeline" id="line-612"><code>		f.chatty.Updatef(f.parent.name, "=== NAME  %s\n", f.parent.name)</code></span>
<span class="codeline" id="line-613"><code>	}</code></span>
<span class="codeline" id="line-614"><code>	return !f.failed</code></span>
<span class="codeline" id="line-615"><code>}</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>// fRunner wraps a call to a fuzz test and ensures that cleanup functions are</code></span>
<span class="codeline" id="line-618"><code>// called and status flags are set. fRunner should be called in its own</code></span>
<span class="codeline" id="line-619"><code>// goroutine. To wait for its completion, receive from f.signal.</code></span>
<span class="codeline" id="line-620"><code>//</code></span>
<span class="codeline" id="line-621"><code>// fRunner is analogous to tRunner, which wraps subtests started with T.Run.</code></span>
<span class="codeline" id="line-622"><code>// Unit tests and fuzz tests work a little differently, so for now, these</code></span>
<span class="codeline" id="line-623"><code>// functions aren't consolidated. In particular, because there are no F.Run and</code></span>
<span class="codeline" id="line-624"><code>// F.Parallel methods, i.e., no fuzz sub-tests or parallel fuzz tests, a few</code></span>
<span class="codeline" id="line-625"><code>// simplifications are made. We also require that F.Fuzz, F.Skip, or F.Fail is</code></span>
<span class="codeline" id="line-626"><code>// called.</code></span>
<span class="codeline" id="line-627"><code>func fRunner(f *F, fn func(*F)) {</code></span>
<span class="codeline" id="line-628"><code>	// When this goroutine is done, either because runtime.Goexit was called, a</code></span>
<span class="codeline" id="line-629"><code>	// panic started, or fn returned normally, record the duration and send</code></span>
<span class="codeline" id="line-630"><code>	// t.signal, indicating the fuzz test is done.</code></span>
<span class="codeline" id="line-631"><code>	defer func() {</code></span>
<span class="codeline" id="line-632"><code>		// Detect whether the fuzz test panicked or called runtime.Goexit</code></span>
<span class="codeline" id="line-633"><code>		// without calling F.Fuzz, F.Fail, or F.Skip. If it did, panic (possibly</code></span>
<span class="codeline" id="line-634"><code>		// replacing a nil panic value). Nothing should recover after fRunner</code></span>
<span class="codeline" id="line-635"><code>		// unwinds, so this should crash the process and print stack.</code></span>
<span class="codeline" id="line-636"><code>		// Unfortunately, recovering here adds stack frames, but the location of</code></span>
<span class="codeline" id="line-637"><code>		// the original panic should still be</code></span>
<span class="codeline" id="line-638"><code>		// clear.</code></span>
<span class="codeline" id="line-639"><code>		f.checkRaces()</code></span>
<span class="codeline" id="line-640"><code>		if f.Failed() {</code></span>
<span class="codeline" id="line-641"><code>			numFailed.Add(1)</code></span>
<span class="codeline" id="line-642"><code>		}</code></span>
<span class="codeline" id="line-643"><code>		err := recover()</code></span>
<span class="codeline" id="line-644"><code>		if err == nil {</code></span>
<span class="codeline" id="line-645"><code>			f.mu.RLock()</code></span>
<span class="codeline" id="line-646"><code>			fuzzNotCalled := !f.fuzzCalled &amp;&amp; !f.skipped &amp;&amp; !f.failed</code></span>
<span class="codeline" id="line-647"><code>			if !f.finished &amp;&amp; !f.skipped &amp;&amp; !f.failed {</code></span>
<span class="codeline" id="line-648"><code>				err = errNilPanicOrGoexit</code></span>
<span class="codeline" id="line-649"><code>			}</code></span>
<span class="codeline" id="line-650"><code>			f.mu.RUnlock()</code></span>
<span class="codeline" id="line-651"><code>			if fuzzNotCalled &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-652"><code>				f.Error("returned without calling F.Fuzz, F.Fail, or F.Skip")</code></span>
<span class="codeline" id="line-653"><code>			}</code></span>
<span class="codeline" id="line-654"><code>		}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>		// Use a deferred call to ensure that we report that the test is</code></span>
<span class="codeline" id="line-657"><code>		// complete even if a cleanup function calls F.FailNow. See issue 41355.</code></span>
<span class="codeline" id="line-658"><code>		didPanic := false</code></span>
<span class="codeline" id="line-659"><code>		defer func() {</code></span>
<span class="codeline" id="line-660"><code>			if !didPanic {</code></span>
<span class="codeline" id="line-661"><code>				// Only report that the test is complete if it doesn't panic,</code></span>
<span class="codeline" id="line-662"><code>				// as otherwise the test binary can exit before the panic is</code></span>
<span class="codeline" id="line-663"><code>				// reported to the user. See issue 41479.</code></span>
<span class="codeline" id="line-664"><code>				f.signal &lt;- true</code></span>
<span class="codeline" id="line-665"><code>			}</code></span>
<span class="codeline" id="line-666"><code>		}()</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>		// If we recovered a panic or inappropriate runtime.Goexit, fail the test,</code></span>
<span class="codeline" id="line-669"><code>		// flush the output log up to the root, then panic.</code></span>
<span class="codeline" id="line-670"><code>		doPanic := func(err any) {</code></span>
<span class="codeline" id="line-671"><code>			f.Fail()</code></span>
<span class="codeline" id="line-672"><code>			if r := f.runCleanup(recoverAndReturnPanic); r != nil {</code></span>
<span class="codeline" id="line-673"><code>				f.Logf("cleanup panicked with %v", r)</code></span>
<span class="codeline" id="line-674"><code>			}</code></span>
<span class="codeline" id="line-675"><code>			for root := &amp;f.common; root.parent != nil; root = root.parent {</code></span>
<span class="codeline" id="line-676"><code>				root.mu.Lock()</code></span>
<span class="codeline" id="line-677"><code>				root.duration += time.Since(root.start)</code></span>
<span class="codeline" id="line-678"><code>				d := root.duration</code></span>
<span class="codeline" id="line-679"><code>				root.mu.Unlock()</code></span>
<span class="codeline" id="line-680"><code>				root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))</code></span>
<span class="codeline" id="line-681"><code>			}</code></span>
<span class="codeline" id="line-682"><code>			didPanic = true</code></span>
<span class="codeline" id="line-683"><code>			panic(err)</code></span>
<span class="codeline" id="line-684"><code>		}</code></span>
<span class="codeline" id="line-685"><code>		if err != nil {</code></span>
<span class="codeline" id="line-686"><code>			doPanic(err)</code></span>
<span class="codeline" id="line-687"><code>		}</code></span>
<span class="codeline" id="line-688"><code></code></span>
<span class="codeline" id="line-689"><code>		// No panic or inappropriate Goexit.</code></span>
<span class="codeline" id="line-690"><code>		f.duration += time.Since(f.start)</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>		if len(f.sub) &gt; 0 {</code></span>
<span class="codeline" id="line-693"><code>			// Unblock inputs that called T.Parallel while running the seed corpus.</code></span>
<span class="codeline" id="line-694"><code>			// This only affects fuzz tests run as normal tests.</code></span>
<span class="codeline" id="line-695"><code>			// While fuzzing, T.Parallel has no effect, so f.sub is empty, and this</code></span>
<span class="codeline" id="line-696"><code>			// branch is not taken. f.barrier is nil in that case.</code></span>
<span class="codeline" id="line-697"><code>			f.testContext.release()</code></span>
<span class="codeline" id="line-698"><code>			close(f.barrier)</code></span>
<span class="codeline" id="line-699"><code>			// Wait for the subtests to complete.</code></span>
<span class="codeline" id="line-700"><code>			for _, sub := range f.sub {</code></span>
<span class="codeline" id="line-701"><code>				&lt;-sub.signal</code></span>
<span class="codeline" id="line-702"><code>			}</code></span>
<span class="codeline" id="line-703"><code>			cleanupStart := time.Now()</code></span>
<span class="codeline" id="line-704"><code>			err := f.runCleanup(recoverAndReturnPanic)</code></span>
<span class="codeline" id="line-705"><code>			f.duration += time.Since(cleanupStart)</code></span>
<span class="codeline" id="line-706"><code>			if err != nil {</code></span>
<span class="codeline" id="line-707"><code>				doPanic(err)</code></span>
<span class="codeline" id="line-708"><code>			}</code></span>
<span class="codeline" id="line-709"><code>		}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>		// Report after all subtests have finished.</code></span>
<span class="codeline" id="line-712"><code>		f.report()</code></span>
<span class="codeline" id="line-713"><code>		f.done = true</code></span>
<span class="codeline" id="line-714"><code>		f.setRan()</code></span>
<span class="codeline" id="line-715"><code>	}()</code></span>
<span class="codeline" id="line-716"><code>	defer func() {</code></span>
<span class="codeline" id="line-717"><code>		if len(f.sub) == 0 {</code></span>
<span class="codeline" id="line-718"><code>			f.runCleanup(normalPanic)</code></span>
<span class="codeline" id="line-719"><code>		}</code></span>
<span class="codeline" id="line-720"><code>	}()</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>	f.start = time.Now()</code></span>
<span class="codeline" id="line-723"><code>	f.resetRaces()</code></span>
<span class="codeline" id="line-724"><code>	fn(f)</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>	// Code beyond this point will not be executed when FailNow or SkipNow</code></span>
<span class="codeline" id="line-727"><code>	// is invoked.</code></span>
<span class="codeline" id="line-728"><code>	f.mu.Lock()</code></span>
<span class="codeline" id="line-729"><code>	f.finished = true</code></span>
<span class="codeline" id="line-730"><code>	f.mu.Unlock()</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>