<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: enclosing.go in package golang.org/x/tools/go/ast/astutil</title>
<link href="../../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	enclosing.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../../pkg/golang.org/x/tools/go/ast/astutil.html">golang.org/x/tools/go/ast/astutil</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package astutil</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// This file defines utilities for working with source positions.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"fmt"</code></span>
<span class="codeline" id="line-11"><code>	"go/ast"</code></span>
<span class="codeline" id="line-12"><code>	"go/token"</code></span>
<span class="codeline" id="line-13"><code>	"sort"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// PathEnclosingInterval returns the node that encloses the source</code></span>
<span class="codeline" id="line-17"><code>// interval [start, end), and all its ancestors up to the AST root.</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// The definition of "enclosing" used by this function considers</code></span>
<span class="codeline" id="line-20"><code>// additional whitespace abutting a node to be enclosed by it.</code></span>
<span class="codeline" id="line-21"><code>// In this example:</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>//	z := x + y // add them</code></span>
<span class="codeline" id="line-24"><code>//	     &lt;-A-&gt;</code></span>
<span class="codeline" id="line-25"><code>//	    &lt;----B-----&gt;</code></span>
<span class="codeline" id="line-26"><code>//</code></span>
<span class="codeline" id="line-27"><code>// the ast.BinaryExpr(+) node is considered to enclose interval B</code></span>
<span class="codeline" id="line-28"><code>// even though its [Pos()..End()) is actually only interval A.</code></span>
<span class="codeline" id="line-29"><code>// This behaviour makes user interfaces more tolerant of imperfect</code></span>
<span class="codeline" id="line-30"><code>// input.</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>// This function treats tokens as nodes, though they are not included</code></span>
<span class="codeline" id="line-33"><code>// in the result. e.g. PathEnclosingInterval("+") returns the</code></span>
<span class="codeline" id="line-34"><code>// enclosing ast.BinaryExpr("x + y").</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>// If start==end, the 1-char interval following start is used instead.</code></span>
<span class="codeline" id="line-37"><code>//</code></span>
<span class="codeline" id="line-38"><code>// The 'exact' result is true if the interval contains only path[0]</code></span>
<span class="codeline" id="line-39"><code>// and perhaps some adjacent whitespace.  It is false if the interval</code></span>
<span class="codeline" id="line-40"><code>// overlaps multiple children of path[0], or if it contains only</code></span>
<span class="codeline" id="line-41"><code>// interior whitespace of path[0].</code></span>
<span class="codeline" id="line-42"><code>// In this example:</code></span>
<span class="codeline" id="line-43"><code>//</code></span>
<span class="codeline" id="line-44"><code>//	z := x + y // add them</code></span>
<span class="codeline" id="line-45"><code>//	  &lt;--C--&gt;     &lt;---E--&gt;</code></span>
<span class="codeline" id="line-46"><code>//	    ^</code></span>
<span class="codeline" id="line-47"><code>//	    D</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// intervals C, D and E are inexact.  C is contained by the</code></span>
<span class="codeline" id="line-50"><code>// z-assignment statement, because it spans three of its children (:=,</code></span>
<span class="codeline" id="line-51"><code>// x, +).  So too is the 1-char interval D, because it contains only</code></span>
<span class="codeline" id="line-52"><code>// interior whitespace of the assignment.  E is considered interior</code></span>
<span class="codeline" id="line-53"><code>// whitespace of the BlockStmt containing the assignment.</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// The resulting path is never empty; it always contains at least the</code></span>
<span class="codeline" id="line-56"><code>// 'root' *ast.File.  Ideally PathEnclosingInterval would reject</code></span>
<span class="codeline" id="line-57"><code>// intervals that lie wholly or partially outside the range of the</code></span>
<span class="codeline" id="line-58"><code>// file, but unfortunately ast.File records only the token.Pos of</code></span>
<span class="codeline" id="line-59"><code>// the 'package' keyword, but not of the start of the file itself.</code></span>
<span class="codeline" id="line-60"><code>func PathEnclosingInterval(root *ast.File, start, end token.Pos) (path []ast.Node, exact bool) {</code></span>
<span class="codeline" id="line-61"><code>	// fmt.Printf("EnclosingInterval %d %d\n", start, end) // debugging</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>	// Precondition: node.[Pos..End) and adjoining whitespace contain [start, end).</code></span>
<span class="codeline" id="line-64"><code>	var visit func(node ast.Node) bool</code></span>
<span class="codeline" id="line-65"><code>	visit = func(node ast.Node) bool {</code></span>
<span class="codeline" id="line-66"><code>		path = append(path, node)</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>		nodePos := node.Pos()</code></span>
<span class="codeline" id="line-69"><code>		nodeEnd := node.End()</code></span>
<span class="codeline" id="line-70"><code></code></span>
<span class="codeline" id="line-71"><code>		// fmt.Printf("visit(%T, %d, %d)\n", node, nodePos, nodeEnd) // debugging</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>		// Intersect [start, end) with interval of node.</code></span>
<span class="codeline" id="line-74"><code>		if start &lt; nodePos {</code></span>
<span class="codeline" id="line-75"><code>			start = nodePos</code></span>
<span class="codeline" id="line-76"><code>		}</code></span>
<span class="codeline" id="line-77"><code>		if end &gt; nodeEnd {</code></span>
<span class="codeline" id="line-78"><code>			end = nodeEnd</code></span>
<span class="codeline" id="line-79"><code>		}</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>		// Find sole child that contains [start, end).</code></span>
<span class="codeline" id="line-82"><code>		children := childrenOf(node)</code></span>
<span class="codeline" id="line-83"><code>		l := len(children)</code></span>
<span class="codeline" id="line-84"><code>		for i, child := range children {</code></span>
<span class="codeline" id="line-85"><code>			// [childPos, childEnd) is unaugmented interval of child.</code></span>
<span class="codeline" id="line-86"><code>			childPos := child.Pos()</code></span>
<span class="codeline" id="line-87"><code>			childEnd := child.End()</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>			// [augPos, augEnd) is whitespace-augmented interval of child.</code></span>
<span class="codeline" id="line-90"><code>			augPos := childPos</code></span>
<span class="codeline" id="line-91"><code>			augEnd := childEnd</code></span>
<span class="codeline" id="line-92"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-93"><code>				augPos = children[i-1].End() // start of preceding whitespace</code></span>
<span class="codeline" id="line-94"><code>			}</code></span>
<span class="codeline" id="line-95"><code>			if i &lt; l-1 {</code></span>
<span class="codeline" id="line-96"><code>				nextChildPos := children[i+1].Pos()</code></span>
<span class="codeline" id="line-97"><code>				// Does [start, end) lie between child and next child?</code></span>
<span class="codeline" id="line-98"><code>				if start &gt;= augEnd &amp;&amp; end &lt;= nextChildPos {</code></span>
<span class="codeline" id="line-99"><code>					return false // inexact match</code></span>
<span class="codeline" id="line-100"><code>				}</code></span>
<span class="codeline" id="line-101"><code>				augEnd = nextChildPos // end of following whitespace</code></span>
<span class="codeline" id="line-102"><code>			}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>			// fmt.Printf("\tchild %d: [%d..%d)\tcontains interval [%d..%d)?\n",</code></span>
<span class="codeline" id="line-105"><code>			// 	i, augPos, augEnd, start, end) // debugging</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>			// Does augmented child strictly contain [start, end)?</code></span>
<span class="codeline" id="line-108"><code>			if augPos &lt;= start &amp;&amp; end &lt;= augEnd {</code></span>
<span class="codeline" id="line-109"><code>				_, isToken := child.(tokenNode)</code></span>
<span class="codeline" id="line-110"><code>				return isToken || visit(child)</code></span>
<span class="codeline" id="line-111"><code>			}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>			// Does [start, end) overlap multiple children?</code></span>
<span class="codeline" id="line-114"><code>			// i.e. left-augmented child contains start</code></span>
<span class="codeline" id="line-115"><code>			// but LR-augmented child does not contain end.</code></span>
<span class="codeline" id="line-116"><code>			if start &lt; childEnd &amp;&amp; end &gt; augEnd {</code></span>
<span class="codeline" id="line-117"><code>				break</code></span>
<span class="codeline" id="line-118"><code>			}</code></span>
<span class="codeline" id="line-119"><code>		}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>		// No single child contained [start, end),</code></span>
<span class="codeline" id="line-122"><code>		// so node is the result.  Is it exact?</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>		// (It's tempting to put this condition before the</code></span>
<span class="codeline" id="line-125"><code>		// child loop, but it gives the wrong result in the</code></span>
<span class="codeline" id="line-126"><code>		// case where a node (e.g. ExprStmt) and its sole</code></span>
<span class="codeline" id="line-127"><code>		// child have equal intervals.)</code></span>
<span class="codeline" id="line-128"><code>		if start == nodePos &amp;&amp; end == nodeEnd {</code></span>
<span class="codeline" id="line-129"><code>			return true // exact match</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>		return false // inexact: overlaps multiple children</code></span>
<span class="codeline" id="line-133"><code>	}</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>	// Ensure [start,end) is nondecreasing.</code></span>
<span class="codeline" id="line-136"><code>	if start &gt; end {</code></span>
<span class="codeline" id="line-137"><code>		start, end = end, start</code></span>
<span class="codeline" id="line-138"><code>	}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	if start &lt; root.End() &amp;&amp; end &gt; root.Pos() {</code></span>
<span class="codeline" id="line-141"><code>		if start == end {</code></span>
<span class="codeline" id="line-142"><code>			end = start + 1 // empty interval =&gt; interval of size 1</code></span>
<span class="codeline" id="line-143"><code>		}</code></span>
<span class="codeline" id="line-144"><code>		exact = visit(root)</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>		// Reverse the path:</code></span>
<span class="codeline" id="line-147"><code>		for i, l := 0, len(path); i &lt; l/2; i++ {</code></span>
<span class="codeline" id="line-148"><code>			path[i], path[l-1-i] = path[l-1-i], path[i]</code></span>
<span class="codeline" id="line-149"><code>		}</code></span>
<span class="codeline" id="line-150"><code>	} else {</code></span>
<span class="codeline" id="line-151"><code>		// Selection lies within whitespace preceding the</code></span>
<span class="codeline" id="line-152"><code>		// first (or following the last) declaration in the file.</code></span>
<span class="codeline" id="line-153"><code>		// The result nonetheless always includes the ast.File.</code></span>
<span class="codeline" id="line-154"><code>		path = append(path, root)</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>	return</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// tokenNode is a dummy implementation of ast.Node for a single token.</code></span>
<span class="codeline" id="line-161"><code>// They are used transiently by PathEnclosingInterval but never escape</code></span>
<span class="codeline" id="line-162"><code>// this package.</code></span>
<span class="codeline" id="line-163"><code>type tokenNode struct {</code></span>
<span class="codeline" id="line-164"><code>	pos token.Pos</code></span>
<span class="codeline" id="line-165"><code>	end token.Pos</code></span>
<span class="codeline" id="line-166"><code>}</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>func (n tokenNode) Pos() token.Pos {</code></span>
<span class="codeline" id="line-169"><code>	return n.pos</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>func (n tokenNode) End() token.Pos {</code></span>
<span class="codeline" id="line-173"><code>	return n.end</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>func tok(pos token.Pos, len int) ast.Node {</code></span>
<span class="codeline" id="line-177"><code>	return tokenNode{pos, pos + token.Pos(len)}</code></span>
<span class="codeline" id="line-178"><code>}</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>// childrenOf returns the direct non-nil children of ast.Node n.</code></span>
<span class="codeline" id="line-181"><code>// It may include fake ast.Node implementations for bare tokens.</code></span>
<span class="codeline" id="line-182"><code>// it is not safe to call (e.g.) ast.Walk on such nodes.</code></span>
<span class="codeline" id="line-183"><code>func childrenOf(n ast.Node) []ast.Node {</code></span>
<span class="codeline" id="line-184"><code>	var children []ast.Node</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// First add nodes for all true subtrees.</code></span>
<span class="codeline" id="line-187"><code>	ast.Inspect(n, func(node ast.Node) bool {</code></span>
<span class="codeline" id="line-188"><code>		if node == n { // push n</code></span>
<span class="codeline" id="line-189"><code>			return true // recur</code></span>
<span class="codeline" id="line-190"><code>		}</code></span>
<span class="codeline" id="line-191"><code>		if node != nil { // push child</code></span>
<span class="codeline" id="line-192"><code>			children = append(children, node)</code></span>
<span class="codeline" id="line-193"><code>		}</code></span>
<span class="codeline" id="line-194"><code>		return false // no recursion</code></span>
<span class="codeline" id="line-195"><code>	})</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>	// Then add fake Nodes for bare tokens.</code></span>
<span class="codeline" id="line-198"><code>	switch n := n.(type) {</code></span>
<span class="codeline" id="line-199"><code>	case *ast.ArrayType:</code></span>
<span class="codeline" id="line-200"><code>		children = append(children,</code></span>
<span class="codeline" id="line-201"><code>			tok(n.Lbrack, len("[")),</code></span>
<span class="codeline" id="line-202"><code>			tok(n.Elt.End(), len("]")))</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	case *ast.AssignStmt:</code></span>
<span class="codeline" id="line-205"><code>		children = append(children,</code></span>
<span class="codeline" id="line-206"><code>			tok(n.TokPos, len(n.Tok.String())))</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	case *ast.BasicLit:</code></span>
<span class="codeline" id="line-209"><code>		children = append(children,</code></span>
<span class="codeline" id="line-210"><code>			tok(n.ValuePos, len(n.Value)))</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	case *ast.BinaryExpr:</code></span>
<span class="codeline" id="line-213"><code>		children = append(children, tok(n.OpPos, len(n.Op.String())))</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>	case *ast.BlockStmt:</code></span>
<span class="codeline" id="line-216"><code>		children = append(children,</code></span>
<span class="codeline" id="line-217"><code>			tok(n.Lbrace, len("{")),</code></span>
<span class="codeline" id="line-218"><code>			tok(n.Rbrace, len("}")))</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>	case *ast.BranchStmt:</code></span>
<span class="codeline" id="line-221"><code>		children = append(children,</code></span>
<span class="codeline" id="line-222"><code>			tok(n.TokPos, len(n.Tok.String())))</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>	case *ast.CallExpr:</code></span>
<span class="codeline" id="line-225"><code>		children = append(children,</code></span>
<span class="codeline" id="line-226"><code>			tok(n.Lparen, len("(")),</code></span>
<span class="codeline" id="line-227"><code>			tok(n.Rparen, len(")")))</code></span>
<span class="codeline" id="line-228"><code>		if n.Ellipsis != 0 {</code></span>
<span class="codeline" id="line-229"><code>			children = append(children, tok(n.Ellipsis, len("...")))</code></span>
<span class="codeline" id="line-230"><code>		}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>	case *ast.CaseClause:</code></span>
<span class="codeline" id="line-233"><code>		if n.List == nil {</code></span>
<span class="codeline" id="line-234"><code>			children = append(children,</code></span>
<span class="codeline" id="line-235"><code>				tok(n.Case, len("default")))</code></span>
<span class="codeline" id="line-236"><code>		} else {</code></span>
<span class="codeline" id="line-237"><code>			children = append(children,</code></span>
<span class="codeline" id="line-238"><code>				tok(n.Case, len("case")))</code></span>
<span class="codeline" id="line-239"><code>		}</code></span>
<span class="codeline" id="line-240"><code>		children = append(children, tok(n.Colon, len(":")))</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>	case *ast.ChanType:</code></span>
<span class="codeline" id="line-243"><code>		switch n.Dir {</code></span>
<span class="codeline" id="line-244"><code>		case ast.RECV:</code></span>
<span class="codeline" id="line-245"><code>			children = append(children, tok(n.Begin, len("&lt;-chan")))</code></span>
<span class="codeline" id="line-246"><code>		case ast.SEND:</code></span>
<span class="codeline" id="line-247"><code>			children = append(children, tok(n.Begin, len("chan&lt;-")))</code></span>
<span class="codeline" id="line-248"><code>		case ast.RECV | ast.SEND:</code></span>
<span class="codeline" id="line-249"><code>			children = append(children, tok(n.Begin, len("chan")))</code></span>
<span class="codeline" id="line-250"><code>		}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>	case *ast.CommClause:</code></span>
<span class="codeline" id="line-253"><code>		if n.Comm == nil {</code></span>
<span class="codeline" id="line-254"><code>			children = append(children,</code></span>
<span class="codeline" id="line-255"><code>				tok(n.Case, len("default")))</code></span>
<span class="codeline" id="line-256"><code>		} else {</code></span>
<span class="codeline" id="line-257"><code>			children = append(children,</code></span>
<span class="codeline" id="line-258"><code>				tok(n.Case, len("case")))</code></span>
<span class="codeline" id="line-259"><code>		}</code></span>
<span class="codeline" id="line-260"><code>		children = append(children, tok(n.Colon, len(":")))</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	case *ast.Comment:</code></span>
<span class="codeline" id="line-263"><code>		// nop</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>	case *ast.CommentGroup:</code></span>
<span class="codeline" id="line-266"><code>		// nop</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>	case *ast.CompositeLit:</code></span>
<span class="codeline" id="line-269"><code>		children = append(children,</code></span>
<span class="codeline" id="line-270"><code>			tok(n.Lbrace, len("{")),</code></span>
<span class="codeline" id="line-271"><code>			tok(n.Rbrace, len("{")))</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	case *ast.DeclStmt:</code></span>
<span class="codeline" id="line-274"><code>		// nop</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	case *ast.DeferStmt:</code></span>
<span class="codeline" id="line-277"><code>		children = append(children,</code></span>
<span class="codeline" id="line-278"><code>			tok(n.Defer, len("defer")))</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	case *ast.Ellipsis:</code></span>
<span class="codeline" id="line-281"><code>		children = append(children,</code></span>
<span class="codeline" id="line-282"><code>			tok(n.Ellipsis, len("...")))</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>	case *ast.EmptyStmt:</code></span>
<span class="codeline" id="line-285"><code>		// nop</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	case *ast.ExprStmt:</code></span>
<span class="codeline" id="line-288"><code>		// nop</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>	case *ast.Field:</code></span>
<span class="codeline" id="line-291"><code>		// TODO(adonovan): Field.{Doc,Comment,Tag}?</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>	case *ast.FieldList:</code></span>
<span class="codeline" id="line-294"><code>		children = append(children,</code></span>
<span class="codeline" id="line-295"><code>			tok(n.Opening, len("(")), // or len("[")</code></span>
<span class="codeline" id="line-296"><code>			tok(n.Closing, len(")"))) // or len("]")</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	case *ast.File:</code></span>
<span class="codeline" id="line-299"><code>		// TODO test: Doc</code></span>
<span class="codeline" id="line-300"><code>		children = append(children,</code></span>
<span class="codeline" id="line-301"><code>			tok(n.Package, len("package")))</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>	case *ast.ForStmt:</code></span>
<span class="codeline" id="line-304"><code>		children = append(children,</code></span>
<span class="codeline" id="line-305"><code>			tok(n.For, len("for")))</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>	case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-308"><code>		// TODO(adonovan): FuncDecl.Comment?</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>		// Uniquely, FuncDecl breaks the invariant that</code></span>
<span class="codeline" id="line-311"><code>		// preorder traversal yields tokens in lexical order:</code></span>
<span class="codeline" id="line-312"><code>		// in fact, FuncDecl.Recv precedes FuncDecl.Type.Func.</code></span>
<span class="codeline" id="line-313"><code>		//</code></span>
<span class="codeline" id="line-314"><code>		// As a workaround, we inline the case for FuncType</code></span>
<span class="codeline" id="line-315"><code>		// here and order things correctly.</code></span>
<span class="codeline" id="line-316"><code>		//</code></span>
<span class="codeline" id="line-317"><code>		children = nil // discard ast.Walk(FuncDecl) info subtrees</code></span>
<span class="codeline" id="line-318"><code>		children = append(children, tok(n.Type.Func, len("func")))</code></span>
<span class="codeline" id="line-319"><code>		if n.Recv != nil {</code></span>
<span class="codeline" id="line-320"><code>			children = append(children, n.Recv)</code></span>
<span class="codeline" id="line-321"><code>		}</code></span>
<span class="codeline" id="line-322"><code>		children = append(children, n.Name)</code></span>
<span class="codeline" id="line-323"><code>		if tparams := n.Type.TypeParams; tparams != nil {</code></span>
<span class="codeline" id="line-324"><code>			children = append(children, tparams)</code></span>
<span class="codeline" id="line-325"><code>		}</code></span>
<span class="codeline" id="line-326"><code>		if n.Type.Params != nil {</code></span>
<span class="codeline" id="line-327"><code>			children = append(children, n.Type.Params)</code></span>
<span class="codeline" id="line-328"><code>		}</code></span>
<span class="codeline" id="line-329"><code>		if n.Type.Results != nil {</code></span>
<span class="codeline" id="line-330"><code>			children = append(children, n.Type.Results)</code></span>
<span class="codeline" id="line-331"><code>		}</code></span>
<span class="codeline" id="line-332"><code>		if n.Body != nil {</code></span>
<span class="codeline" id="line-333"><code>			children = append(children, n.Body)</code></span>
<span class="codeline" id="line-334"><code>		}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>	case *ast.FuncLit:</code></span>
<span class="codeline" id="line-337"><code>		// nop</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>	case *ast.FuncType:</code></span>
<span class="codeline" id="line-340"><code>		if n.Func != 0 {</code></span>
<span class="codeline" id="line-341"><code>			children = append(children,</code></span>
<span class="codeline" id="line-342"><code>				tok(n.Func, len("func")))</code></span>
<span class="codeline" id="line-343"><code>		}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>	case *ast.GenDecl:</code></span>
<span class="codeline" id="line-346"><code>		children = append(children,</code></span>
<span class="codeline" id="line-347"><code>			tok(n.TokPos, len(n.Tok.String())))</code></span>
<span class="codeline" id="line-348"><code>		if n.Lparen != 0 {</code></span>
<span class="codeline" id="line-349"><code>			children = append(children,</code></span>
<span class="codeline" id="line-350"><code>				tok(n.Lparen, len("(")),</code></span>
<span class="codeline" id="line-351"><code>				tok(n.Rparen, len(")")))</code></span>
<span class="codeline" id="line-352"><code>		}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>	case *ast.GoStmt:</code></span>
<span class="codeline" id="line-355"><code>		children = append(children,</code></span>
<span class="codeline" id="line-356"><code>			tok(n.Go, len("go")))</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-359"><code>		children = append(children,</code></span>
<span class="codeline" id="line-360"><code>			tok(n.NamePos, len(n.Name)))</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>	case *ast.IfStmt:</code></span>
<span class="codeline" id="line-363"><code>		children = append(children,</code></span>
<span class="codeline" id="line-364"><code>			tok(n.If, len("if")))</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>	case *ast.ImportSpec:</code></span>
<span class="codeline" id="line-367"><code>		// TODO(adonovan): ImportSpec.{Doc,EndPos}?</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>	case *ast.IncDecStmt:</code></span>
<span class="codeline" id="line-370"><code>		children = append(children,</code></span>
<span class="codeline" id="line-371"><code>			tok(n.TokPos, len(n.Tok.String())))</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>	case *ast.IndexExpr:</code></span>
<span class="codeline" id="line-374"><code>		children = append(children,</code></span>
<span class="codeline" id="line-375"><code>			tok(n.Lbrack, len("[")),</code></span>
<span class="codeline" id="line-376"><code>			tok(n.Rbrack, len("]")))</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>	case *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-379"><code>		children = append(children,</code></span>
<span class="codeline" id="line-380"><code>			tok(n.Lbrack, len("[")),</code></span>
<span class="codeline" id="line-381"><code>			tok(n.Rbrack, len("]")))</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>	case *ast.InterfaceType:</code></span>
<span class="codeline" id="line-384"><code>		children = append(children,</code></span>
<span class="codeline" id="line-385"><code>			tok(n.Interface, len("interface")))</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>	case *ast.KeyValueExpr:</code></span>
<span class="codeline" id="line-388"><code>		children = append(children,</code></span>
<span class="codeline" id="line-389"><code>			tok(n.Colon, len(":")))</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>	case *ast.LabeledStmt:</code></span>
<span class="codeline" id="line-392"><code>		children = append(children,</code></span>
<span class="codeline" id="line-393"><code>			tok(n.Colon, len(":")))</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>	case *ast.MapType:</code></span>
<span class="codeline" id="line-396"><code>		children = append(children,</code></span>
<span class="codeline" id="line-397"><code>			tok(n.Map, len("map")))</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>	case *ast.ParenExpr:</code></span>
<span class="codeline" id="line-400"><code>		children = append(children,</code></span>
<span class="codeline" id="line-401"><code>			tok(n.Lparen, len("(")),</code></span>
<span class="codeline" id="line-402"><code>			tok(n.Rparen, len(")")))</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>	case *ast.RangeStmt:</code></span>
<span class="codeline" id="line-405"><code>		children = append(children,</code></span>
<span class="codeline" id="line-406"><code>			tok(n.For, len("for")),</code></span>
<span class="codeline" id="line-407"><code>			tok(n.TokPos, len(n.Tok.String())))</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>	case *ast.ReturnStmt:</code></span>
<span class="codeline" id="line-410"><code>		children = append(children,</code></span>
<span class="codeline" id="line-411"><code>			tok(n.Return, len("return")))</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	case *ast.SelectStmt:</code></span>
<span class="codeline" id="line-414"><code>		children = append(children,</code></span>
<span class="codeline" id="line-415"><code>			tok(n.Select, len("select")))</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-418"><code>		// nop</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	case *ast.SendStmt:</code></span>
<span class="codeline" id="line-421"><code>		children = append(children,</code></span>
<span class="codeline" id="line-422"><code>			tok(n.Arrow, len("&lt;-")))</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>	case *ast.SliceExpr:</code></span>
<span class="codeline" id="line-425"><code>		children = append(children,</code></span>
<span class="codeline" id="line-426"><code>			tok(n.Lbrack, len("[")),</code></span>
<span class="codeline" id="line-427"><code>			tok(n.Rbrack, len("]")))</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-430"><code>		children = append(children, tok(n.Star, len("*")))</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>	case *ast.StructType:</code></span>
<span class="codeline" id="line-433"><code>		children = append(children, tok(n.Struct, len("struct")))</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>	case *ast.SwitchStmt:</code></span>
<span class="codeline" id="line-436"><code>		children = append(children, tok(n.Switch, len("switch")))</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>	case *ast.TypeAssertExpr:</code></span>
<span class="codeline" id="line-439"><code>		children = append(children,</code></span>
<span class="codeline" id="line-440"><code>			tok(n.Lparen-1, len(".")),</code></span>
<span class="codeline" id="line-441"><code>			tok(n.Lparen, len("(")),</code></span>
<span class="codeline" id="line-442"><code>			tok(n.Rparen, len(")")))</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>	case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-445"><code>		// TODO(adonovan): TypeSpec.{Doc,Comment}?</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	case *ast.TypeSwitchStmt:</code></span>
<span class="codeline" id="line-448"><code>		children = append(children, tok(n.Switch, len("switch")))</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>	case *ast.UnaryExpr:</code></span>
<span class="codeline" id="line-451"><code>		children = append(children, tok(n.OpPos, len(n.Op.String())))</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>	case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-454"><code>		// TODO(adonovan): ValueSpec.{Doc,Comment}?</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	case *ast.BadDecl, *ast.BadExpr, *ast.BadStmt:</code></span>
<span class="codeline" id="line-457"><code>		// nop</code></span>
<span class="codeline" id="line-458"><code>	}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>	// TODO(adonovan): opt: merge the logic of ast.Inspect() into</code></span>
<span class="codeline" id="line-461"><code>	// the switch above so we can make interleaved callbacks for</code></span>
<span class="codeline" id="line-462"><code>	// both Nodes and Tokens in the right order and avoid the need</code></span>
<span class="codeline" id="line-463"><code>	// to sort.</code></span>
<span class="codeline" id="line-464"><code>	sort.Sort(byPos(children))</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>	return children</code></span>
<span class="codeline" id="line-467"><code>}</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>type byPos []ast.Node</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>func (sl byPos) Len() int {</code></span>
<span class="codeline" id="line-472"><code>	return len(sl)</code></span>
<span class="codeline" id="line-473"><code>}</code></span>
<span class="codeline" id="line-474"><code>func (sl byPos) Less(i, j int) bool {</code></span>
<span class="codeline" id="line-475"><code>	return sl[i].Pos() &lt; sl[j].Pos()</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code>func (sl byPos) Swap(i, j int) {</code></span>
<span class="codeline" id="line-478"><code>	sl[i], sl[j] = sl[j], sl[i]</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// NodeDescription returns a description of the concrete type of n suitable</code></span>
<span class="codeline" id="line-482"><code>// for a user interface.</code></span>
<span class="codeline" id="line-483"><code>//</code></span>
<span class="codeline" id="line-484"><code>// TODO(adonovan): in some cases (e.g. Field, FieldList, Ident,</code></span>
<span class="codeline" id="line-485"><code>// StarExpr) we could be much more specific given the path to the AST</code></span>
<span class="codeline" id="line-486"><code>// root.  Perhaps we should do that.</code></span>
<span class="codeline" id="line-487"><code>func NodeDescription(n ast.Node) string {</code></span>
<span class="codeline" id="line-488"><code>	switch n := n.(type) {</code></span>
<span class="codeline" id="line-489"><code>	case *ast.ArrayType:</code></span>
<span class="codeline" id="line-490"><code>		return "array type"</code></span>
<span class="codeline" id="line-491"><code>	case *ast.AssignStmt:</code></span>
<span class="codeline" id="line-492"><code>		return "assignment"</code></span>
<span class="codeline" id="line-493"><code>	case *ast.BadDecl:</code></span>
<span class="codeline" id="line-494"><code>		return "bad declaration"</code></span>
<span class="codeline" id="line-495"><code>	case *ast.BadExpr:</code></span>
<span class="codeline" id="line-496"><code>		return "bad expression"</code></span>
<span class="codeline" id="line-497"><code>	case *ast.BadStmt:</code></span>
<span class="codeline" id="line-498"><code>		return "bad statement"</code></span>
<span class="codeline" id="line-499"><code>	case *ast.BasicLit:</code></span>
<span class="codeline" id="line-500"><code>		return "basic literal"</code></span>
<span class="codeline" id="line-501"><code>	case *ast.BinaryExpr:</code></span>
<span class="codeline" id="line-502"><code>		return fmt.Sprintf("binary %s operation", n.Op)</code></span>
<span class="codeline" id="line-503"><code>	case *ast.BlockStmt:</code></span>
<span class="codeline" id="line-504"><code>		return "block"</code></span>
<span class="codeline" id="line-505"><code>	case *ast.BranchStmt:</code></span>
<span class="codeline" id="line-506"><code>		switch n.Tok {</code></span>
<span class="codeline" id="line-507"><code>		case token.BREAK:</code></span>
<span class="codeline" id="line-508"><code>			return "break statement"</code></span>
<span class="codeline" id="line-509"><code>		case token.CONTINUE:</code></span>
<span class="codeline" id="line-510"><code>			return "continue statement"</code></span>
<span class="codeline" id="line-511"><code>		case token.GOTO:</code></span>
<span class="codeline" id="line-512"><code>			return "goto statement"</code></span>
<span class="codeline" id="line-513"><code>		case token.FALLTHROUGH:</code></span>
<span class="codeline" id="line-514"><code>			return "fall-through statement"</code></span>
<span class="codeline" id="line-515"><code>		}</code></span>
<span class="codeline" id="line-516"><code>	case *ast.CallExpr:</code></span>
<span class="codeline" id="line-517"><code>		if len(n.Args) == 1 &amp;&amp; !n.Ellipsis.IsValid() {</code></span>
<span class="codeline" id="line-518"><code>			return "function call (or conversion)"</code></span>
<span class="codeline" id="line-519"><code>		}</code></span>
<span class="codeline" id="line-520"><code>		return "function call"</code></span>
<span class="codeline" id="line-521"><code>	case *ast.CaseClause:</code></span>
<span class="codeline" id="line-522"><code>		return "case clause"</code></span>
<span class="codeline" id="line-523"><code>	case *ast.ChanType:</code></span>
<span class="codeline" id="line-524"><code>		return "channel type"</code></span>
<span class="codeline" id="line-525"><code>	case *ast.CommClause:</code></span>
<span class="codeline" id="line-526"><code>		return "communication clause"</code></span>
<span class="codeline" id="line-527"><code>	case *ast.Comment:</code></span>
<span class="codeline" id="line-528"><code>		return "comment"</code></span>
<span class="codeline" id="line-529"><code>	case *ast.CommentGroup:</code></span>
<span class="codeline" id="line-530"><code>		return "comment group"</code></span>
<span class="codeline" id="line-531"><code>	case *ast.CompositeLit:</code></span>
<span class="codeline" id="line-532"><code>		return "composite literal"</code></span>
<span class="codeline" id="line-533"><code>	case *ast.DeclStmt:</code></span>
<span class="codeline" id="line-534"><code>		return NodeDescription(n.Decl) + " statement"</code></span>
<span class="codeline" id="line-535"><code>	case *ast.DeferStmt:</code></span>
<span class="codeline" id="line-536"><code>		return "defer statement"</code></span>
<span class="codeline" id="line-537"><code>	case *ast.Ellipsis:</code></span>
<span class="codeline" id="line-538"><code>		return "ellipsis"</code></span>
<span class="codeline" id="line-539"><code>	case *ast.EmptyStmt:</code></span>
<span class="codeline" id="line-540"><code>		return "empty statement"</code></span>
<span class="codeline" id="line-541"><code>	case *ast.ExprStmt:</code></span>
<span class="codeline" id="line-542"><code>		return "expression statement"</code></span>
<span class="codeline" id="line-543"><code>	case *ast.Field:</code></span>
<span class="codeline" id="line-544"><code>		// Can be any of these:</code></span>
<span class="codeline" id="line-545"><code>		// struct {x, y int}  -- struct field(s)</code></span>
<span class="codeline" id="line-546"><code>		// struct {T}         -- anon struct field</code></span>
<span class="codeline" id="line-547"><code>		// interface {I}      -- interface embedding</code></span>
<span class="codeline" id="line-548"><code>		// interface {f()}    -- interface method</code></span>
<span class="codeline" id="line-549"><code>		// func (A) func(B) C -- receiver, param(s), result(s)</code></span>
<span class="codeline" id="line-550"><code>		return "field/method/parameter"</code></span>
<span class="codeline" id="line-551"><code>	case *ast.FieldList:</code></span>
<span class="codeline" id="line-552"><code>		return "field/method/parameter list"</code></span>
<span class="codeline" id="line-553"><code>	case *ast.File:</code></span>
<span class="codeline" id="line-554"><code>		return "source file"</code></span>
<span class="codeline" id="line-555"><code>	case *ast.ForStmt:</code></span>
<span class="codeline" id="line-556"><code>		return "for loop"</code></span>
<span class="codeline" id="line-557"><code>	case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-558"><code>		return "function declaration"</code></span>
<span class="codeline" id="line-559"><code>	case *ast.FuncLit:</code></span>
<span class="codeline" id="line-560"><code>		return "function literal"</code></span>
<span class="codeline" id="line-561"><code>	case *ast.FuncType:</code></span>
<span class="codeline" id="line-562"><code>		return "function type"</code></span>
<span class="codeline" id="line-563"><code>	case *ast.GenDecl:</code></span>
<span class="codeline" id="line-564"><code>		switch n.Tok {</code></span>
<span class="codeline" id="line-565"><code>		case token.IMPORT:</code></span>
<span class="codeline" id="line-566"><code>			return "import declaration"</code></span>
<span class="codeline" id="line-567"><code>		case token.CONST:</code></span>
<span class="codeline" id="line-568"><code>			return "constant declaration"</code></span>
<span class="codeline" id="line-569"><code>		case token.TYPE:</code></span>
<span class="codeline" id="line-570"><code>			return "type declaration"</code></span>
<span class="codeline" id="line-571"><code>		case token.VAR:</code></span>
<span class="codeline" id="line-572"><code>			return "variable declaration"</code></span>
<span class="codeline" id="line-573"><code>		}</code></span>
<span class="codeline" id="line-574"><code>	case *ast.GoStmt:</code></span>
<span class="codeline" id="line-575"><code>		return "go statement"</code></span>
<span class="codeline" id="line-576"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-577"><code>		return "identifier"</code></span>
<span class="codeline" id="line-578"><code>	case *ast.IfStmt:</code></span>
<span class="codeline" id="line-579"><code>		return "if statement"</code></span>
<span class="codeline" id="line-580"><code>	case *ast.ImportSpec:</code></span>
<span class="codeline" id="line-581"><code>		return "import specification"</code></span>
<span class="codeline" id="line-582"><code>	case *ast.IncDecStmt:</code></span>
<span class="codeline" id="line-583"><code>		if n.Tok == token.INC {</code></span>
<span class="codeline" id="line-584"><code>			return "increment statement"</code></span>
<span class="codeline" id="line-585"><code>		}</code></span>
<span class="codeline" id="line-586"><code>		return "decrement statement"</code></span>
<span class="codeline" id="line-587"><code>	case *ast.IndexExpr:</code></span>
<span class="codeline" id="line-588"><code>		return "index expression"</code></span>
<span class="codeline" id="line-589"><code>	case *ast.IndexListExpr:</code></span>
<span class="codeline" id="line-590"><code>		return "index list expression"</code></span>
<span class="codeline" id="line-591"><code>	case *ast.InterfaceType:</code></span>
<span class="codeline" id="line-592"><code>		return "interface type"</code></span>
<span class="codeline" id="line-593"><code>	case *ast.KeyValueExpr:</code></span>
<span class="codeline" id="line-594"><code>		return "key/value association"</code></span>
<span class="codeline" id="line-595"><code>	case *ast.LabeledStmt:</code></span>
<span class="codeline" id="line-596"><code>		return "statement label"</code></span>
<span class="codeline" id="line-597"><code>	case *ast.MapType:</code></span>
<span class="codeline" id="line-598"><code>		return "map type"</code></span>
<span class="codeline" id="line-599"><code>	case *ast.Package:</code></span>
<span class="codeline" id="line-600"><code>		return "package"</code></span>
<span class="codeline" id="line-601"><code>	case *ast.ParenExpr:</code></span>
<span class="codeline" id="line-602"><code>		return "parenthesized " + NodeDescription(n.X)</code></span>
<span class="codeline" id="line-603"><code>	case *ast.RangeStmt:</code></span>
<span class="codeline" id="line-604"><code>		return "range loop"</code></span>
<span class="codeline" id="line-605"><code>	case *ast.ReturnStmt:</code></span>
<span class="codeline" id="line-606"><code>		return "return statement"</code></span>
<span class="codeline" id="line-607"><code>	case *ast.SelectStmt:</code></span>
<span class="codeline" id="line-608"><code>		return "select statement"</code></span>
<span class="codeline" id="line-609"><code>	case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-610"><code>		return "selector"</code></span>
<span class="codeline" id="line-611"><code>	case *ast.SendStmt:</code></span>
<span class="codeline" id="line-612"><code>		return "channel send"</code></span>
<span class="codeline" id="line-613"><code>	case *ast.SliceExpr:</code></span>
<span class="codeline" id="line-614"><code>		return "slice expression"</code></span>
<span class="codeline" id="line-615"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-616"><code>		return "*-operation" // load/store expr or pointer type</code></span>
<span class="codeline" id="line-617"><code>	case *ast.StructType:</code></span>
<span class="codeline" id="line-618"><code>		return "struct type"</code></span>
<span class="codeline" id="line-619"><code>	case *ast.SwitchStmt:</code></span>
<span class="codeline" id="line-620"><code>		return "switch statement"</code></span>
<span class="codeline" id="line-621"><code>	case *ast.TypeAssertExpr:</code></span>
<span class="codeline" id="line-622"><code>		return "type assertion"</code></span>
<span class="codeline" id="line-623"><code>	case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-624"><code>		return "type specification"</code></span>
<span class="codeline" id="line-625"><code>	case *ast.TypeSwitchStmt:</code></span>
<span class="codeline" id="line-626"><code>		return "type switch"</code></span>
<span class="codeline" id="line-627"><code>	case *ast.UnaryExpr:</code></span>
<span class="codeline" id="line-628"><code>		return fmt.Sprintf("unary %s operation", n.Op)</code></span>
<span class="codeline" id="line-629"><code>	case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-630"><code>		return "value specification"</code></span>
<span class="codeline" id="line-631"><code></code></span>
<span class="codeline" id="line-632"><code>	}</code></span>
<span class="codeline" id="line-633"><code>	panic(fmt.Sprintf("unexpected node type: %T", n))</code></span>
<span class="codeline" id="line-634"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>