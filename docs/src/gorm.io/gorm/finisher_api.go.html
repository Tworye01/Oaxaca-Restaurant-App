<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: finisher_api.go in package gorm.io/gorm</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	finisher_api.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/gorm.io/gorm.html">gorm.io/gorm</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package gorm</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"database/sql"</code></span>
<span class="codeline" id="line-5"><code>	"errors"</code></span>
<span class="codeline" id="line-6"><code>	"fmt"</code></span>
<span class="codeline" id="line-7"><code>	"reflect"</code></span>
<span class="codeline" id="line-8"><code>	"strings"</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>	"gorm.io/gorm/clause"</code></span>
<span class="codeline" id="line-11"><code>	"gorm.io/gorm/logger"</code></span>
<span class="codeline" id="line-12"><code>	"gorm.io/gorm/schema"</code></span>
<span class="codeline" id="line-13"><code>	"gorm.io/gorm/utils"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// Create inserts value, returning the inserted data's primary key in value's id</code></span>
<span class="codeline" id="line-17"><code>func (db *DB) Create(value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-18"><code>	if db.CreateBatchSize &gt; 0 {</code></span>
<span class="codeline" id="line-19"><code>		return db.CreateInBatches(value, db.CreateBatchSize)</code></span>
<span class="codeline" id="line-20"><code>	}</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-23"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-24"><code>	return tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-25"><code>}</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>// CreateInBatches inserts value in batches of batchSize</code></span>
<span class="codeline" id="line-28"><code>func (db *DB) CreateInBatches(value interface{}, batchSize int) (tx *DB) {</code></span>
<span class="codeline" id="line-29"><code>	reflectValue := reflect.Indirect(reflect.ValueOf(value))</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>	switch reflectValue.Kind() {</code></span>
<span class="codeline" id="line-32"><code>	case reflect.Slice, reflect.Array:</code></span>
<span class="codeline" id="line-33"><code>		var rowsAffected int64</code></span>
<span class="codeline" id="line-34"><code>		tx = db.getInstance()</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>		// the reflection length judgment of the optimized value</code></span>
<span class="codeline" id="line-37"><code>		reflectLen := reflectValue.Len()</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>		callFc := func(tx *DB) error {</code></span>
<span class="codeline" id="line-40"><code>			for i := 0; i &lt; reflectLen; i += batchSize {</code></span>
<span class="codeline" id="line-41"><code>				ends := i + batchSize</code></span>
<span class="codeline" id="line-42"><code>				if ends &gt; reflectLen {</code></span>
<span class="codeline" id="line-43"><code>					ends = reflectLen</code></span>
<span class="codeline" id="line-44"><code>				}</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>				subtx := tx.getInstance()</code></span>
<span class="codeline" id="line-47"><code>				subtx.Statement.Dest = reflectValue.Slice(i, ends).Interface()</code></span>
<span class="codeline" id="line-48"><code>				subtx.callbacks.Create().Execute(subtx)</code></span>
<span class="codeline" id="line-49"><code>				if subtx.Error != nil {</code></span>
<span class="codeline" id="line-50"><code>					return subtx.Error</code></span>
<span class="codeline" id="line-51"><code>				}</code></span>
<span class="codeline" id="line-52"><code>				rowsAffected += subtx.RowsAffected</code></span>
<span class="codeline" id="line-53"><code>			}</code></span>
<span class="codeline" id="line-54"><code>			return nil</code></span>
<span class="codeline" id="line-55"><code>		}</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>		if tx.SkipDefaultTransaction || reflectLen &lt;= batchSize {</code></span>
<span class="codeline" id="line-58"><code>			tx.AddError(callFc(tx.Session(&amp;Session{})))</code></span>
<span class="codeline" id="line-59"><code>		} else {</code></span>
<span class="codeline" id="line-60"><code>			tx.AddError(tx.Transaction(callFc))</code></span>
<span class="codeline" id="line-61"><code>		}</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>		tx.RowsAffected = rowsAffected</code></span>
<span class="codeline" id="line-64"><code>	default:</code></span>
<span class="codeline" id="line-65"><code>		tx = db.getInstance()</code></span>
<span class="codeline" id="line-66"><code>		tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-67"><code>		tx = tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-68"><code>	}</code></span>
<span class="codeline" id="line-69"><code>	return</code></span>
<span class="codeline" id="line-70"><code>}</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>// Save updates value in database. If value doesn't contain a matching primary key, value is inserted.</code></span>
<span class="codeline" id="line-73"><code>func (db *DB) Save(value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-74"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-75"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>	reflectValue := reflect.Indirect(reflect.ValueOf(value))</code></span>
<span class="codeline" id="line-78"><code>	for reflectValue.Kind() == reflect.Ptr || reflectValue.Kind() == reflect.Interface {</code></span>
<span class="codeline" id="line-79"><code>		reflectValue = reflect.Indirect(reflectValue)</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>	switch reflectValue.Kind() {</code></span>
<span class="codeline" id="line-83"><code>	case reflect.Slice, reflect.Array:</code></span>
<span class="codeline" id="line-84"><code>		if _, ok := tx.Statement.Clauses["ON CONFLICT"]; !ok {</code></span>
<span class="codeline" id="line-85"><code>			tx = tx.Clauses(clause.OnConflict{UpdateAll: true})</code></span>
<span class="codeline" id="line-86"><code>		}</code></span>
<span class="codeline" id="line-87"><code>		tx = tx.callbacks.Create().Execute(tx.Set("gorm:update_track_time", true))</code></span>
<span class="codeline" id="line-88"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-89"><code>		if err := tx.Statement.Parse(value); err == nil &amp;&amp; tx.Statement.Schema != nil {</code></span>
<span class="codeline" id="line-90"><code>			for _, pf := range tx.Statement.Schema.PrimaryFields {</code></span>
<span class="codeline" id="line-91"><code>				if _, isZero := pf.ValueOf(tx.Statement.Context, reflectValue); isZero {</code></span>
<span class="codeline" id="line-92"><code>					return tx.callbacks.Create().Execute(tx)</code></span>
<span class="codeline" id="line-93"><code>				}</code></span>
<span class="codeline" id="line-94"><code>			}</code></span>
<span class="codeline" id="line-95"><code>		}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>		fallthrough</code></span>
<span class="codeline" id="line-98"><code>	default:</code></span>
<span class="codeline" id="line-99"><code>		selectedUpdate := len(tx.Statement.Selects) != 0</code></span>
<span class="codeline" id="line-100"><code>		// when updating, use all fields including those zero-value fields</code></span>
<span class="codeline" id="line-101"><code>		if !selectedUpdate {</code></span>
<span class="codeline" id="line-102"><code>			tx.Statement.Selects = append(tx.Statement.Selects, "*")</code></span>
<span class="codeline" id="line-103"><code>		}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>		updateTx := tx.callbacks.Update().Execute(tx.Session(&amp;Session{Initialized: true}))</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>		if updateTx.Error == nil &amp;&amp; updateTx.RowsAffected == 0 &amp;&amp; !updateTx.DryRun &amp;&amp; !selectedUpdate {</code></span>
<span class="codeline" id="line-108"><code>			return tx.Session(&amp;Session{SkipHooks: true}).Clauses(clause.OnConflict{UpdateAll: true}).Create(value)</code></span>
<span class="codeline" id="line-109"><code>		}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>		return updateTx</code></span>
<span class="codeline" id="line-112"><code>	}</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>	return</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// First finds the first record ordered by primary key, matching given conditions conds</code></span>
<span class="codeline" id="line-118"><code>func (db *DB) First(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-119"><code>	tx = db.Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-120"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-121"><code>	})</code></span>
<span class="codeline" id="line-122"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-123"><code>		if exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-124"><code>			tx.Statement.AddClause(clause.Where{Exprs: exprs})</code></span>
<span class="codeline" id="line-125"><code>		}</code></span>
<span class="codeline" id="line-126"><code>	}</code></span>
<span class="codeline" id="line-127"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-128"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-129"><code>	return tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-130"><code>}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>// Take finds the first record returned by the database in no specified order, matching given conditions conds</code></span>
<span class="codeline" id="line-133"><code>func (db *DB) Take(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-134"><code>	tx = db.Limit(1)</code></span>
<span class="codeline" id="line-135"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-136"><code>		if exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-137"><code>			tx.Statement.AddClause(clause.Where{Exprs: exprs})</code></span>
<span class="codeline" id="line-138"><code>		}</code></span>
<span class="codeline" id="line-139"><code>	}</code></span>
<span class="codeline" id="line-140"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-141"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-142"><code>	return tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-143"><code>}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// Last finds the last record ordered by primary key, matching given conditions conds</code></span>
<span class="codeline" id="line-146"><code>func (db *DB) Last(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-147"><code>	tx = db.Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-148"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-149"><code>		Desc:   true,</code></span>
<span class="codeline" id="line-150"><code>	})</code></span>
<span class="codeline" id="line-151"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-152"><code>		if exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-153"><code>			tx.Statement.AddClause(clause.Where{Exprs: exprs})</code></span>
<span class="codeline" id="line-154"><code>		}</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>	tx.Statement.RaiseErrorOnNotFound = true</code></span>
<span class="codeline" id="line-157"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-158"><code>	return tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>// Find finds all records matching given conditions conds</code></span>
<span class="codeline" id="line-162"><code>func (db *DB) Find(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-163"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-164"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-165"><code>		if exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-166"><code>			tx.Statement.AddClause(clause.Where{Exprs: exprs})</code></span>
<span class="codeline" id="line-167"><code>		}</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-170"><code>	return tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>// FindInBatches finds all records in batches of batchSize</code></span>
<span class="codeline" id="line-174"><code>func (db *DB) FindInBatches(dest interface{}, batchSize int, fc func(tx *DB, batch int) error) *DB {</code></span>
<span class="codeline" id="line-175"><code>	var (</code></span>
<span class="codeline" id="line-176"><code>		tx = db.Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-177"><code>			Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-178"><code>		}).Session(&amp;Session{})</code></span>
<span class="codeline" id="line-179"><code>		queryDB      = tx</code></span>
<span class="codeline" id="line-180"><code>		rowsAffected int64</code></span>
<span class="codeline" id="line-181"><code>		batch        int</code></span>
<span class="codeline" id="line-182"><code>	)</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	// user specified offset or limit</code></span>
<span class="codeline" id="line-185"><code>	var totalSize int</code></span>
<span class="codeline" id="line-186"><code>	if c, ok := tx.Statement.Clauses["LIMIT"]; ok {</code></span>
<span class="codeline" id="line-187"><code>		if limit, ok := c.Expression.(clause.Limit); ok {</code></span>
<span class="codeline" id="line-188"><code>			if limit.Limit != nil {</code></span>
<span class="codeline" id="line-189"><code>				totalSize = *limit.Limit</code></span>
<span class="codeline" id="line-190"><code>			}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>			if totalSize &gt; 0 &amp;&amp; batchSize &gt; totalSize {</code></span>
<span class="codeline" id="line-193"><code>				batchSize = totalSize</code></span>
<span class="codeline" id="line-194"><code>			}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>			// reset to offset to 0 in next batch</code></span>
<span class="codeline" id="line-197"><code>			tx = tx.Offset(-1).Session(&amp;Session{})</code></span>
<span class="codeline" id="line-198"><code>		}</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>	for {</code></span>
<span class="codeline" id="line-202"><code>		result := queryDB.Limit(batchSize).Find(dest)</code></span>
<span class="codeline" id="line-203"><code>		rowsAffected += result.RowsAffected</code></span>
<span class="codeline" id="line-204"><code>		batch++</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>		if result.Error == nil &amp;&amp; result.RowsAffected != 0 {</code></span>
<span class="codeline" id="line-207"><code>			fcTx := result.Session(&amp;Session{NewDB: true})</code></span>
<span class="codeline" id="line-208"><code>			fcTx.RowsAffected = result.RowsAffected</code></span>
<span class="codeline" id="line-209"><code>			tx.AddError(fc(fcTx, batch))</code></span>
<span class="codeline" id="line-210"><code>		} else if result.Error != nil {</code></span>
<span class="codeline" id="line-211"><code>			tx.AddError(result.Error)</code></span>
<span class="codeline" id="line-212"><code>		}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>		if tx.Error != nil || int(result.RowsAffected) &lt; batchSize {</code></span>
<span class="codeline" id="line-215"><code>			break</code></span>
<span class="codeline" id="line-216"><code>		}</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>		if totalSize &gt; 0 {</code></span>
<span class="codeline" id="line-219"><code>			if totalSize &lt;= int(rowsAffected) {</code></span>
<span class="codeline" id="line-220"><code>				break</code></span>
<span class="codeline" id="line-221"><code>			}</code></span>
<span class="codeline" id="line-222"><code>			if totalSize/batchSize == batch {</code></span>
<span class="codeline" id="line-223"><code>				batchSize = totalSize % batchSize</code></span>
<span class="codeline" id="line-224"><code>			}</code></span>
<span class="codeline" id="line-225"><code>		}</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>		// Optimize for-break</code></span>
<span class="codeline" id="line-228"><code>		resultsValue := reflect.Indirect(reflect.ValueOf(dest))</code></span>
<span class="codeline" id="line-229"><code>		if result.Statement.Schema.PrioritizedPrimaryField == nil {</code></span>
<span class="codeline" id="line-230"><code>			tx.AddError(ErrPrimaryKeyRequired)</code></span>
<span class="codeline" id="line-231"><code>			break</code></span>
<span class="codeline" id="line-232"><code>		}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>		primaryValue, zero := result.Statement.Schema.PrioritizedPrimaryField.ValueOf(tx.Statement.Context, resultsValue.Index(resultsValue.Len()-1))</code></span>
<span class="codeline" id="line-235"><code>		if zero {</code></span>
<span class="codeline" id="line-236"><code>			tx.AddError(ErrPrimaryKeyRequired)</code></span>
<span class="codeline" id="line-237"><code>			break</code></span>
<span class="codeline" id="line-238"><code>		}</code></span>
<span class="codeline" id="line-239"><code>		queryDB = tx.Clauses(clause.Gt{Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey}, Value: primaryValue})</code></span>
<span class="codeline" id="line-240"><code>	}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>	tx.RowsAffected = rowsAffected</code></span>
<span class="codeline" id="line-243"><code>	return tx</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>func (db *DB) assignInterfacesToValue(values ...interface{}) {</code></span>
<span class="codeline" id="line-247"><code>	for _, value := range values {</code></span>
<span class="codeline" id="line-248"><code>		switch v := value.(type) {</code></span>
<span class="codeline" id="line-249"><code>		case []clause.Expression:</code></span>
<span class="codeline" id="line-250"><code>			for _, expr := range v {</code></span>
<span class="codeline" id="line-251"><code>				if eq, ok := expr.(clause.Eq); ok {</code></span>
<span class="codeline" id="line-252"><code>					switch column := eq.Column.(type) {</code></span>
<span class="codeline" id="line-253"><code>					case string:</code></span>
<span class="codeline" id="line-254"><code>						if field := db.Statement.Schema.LookUpField(column); field != nil {</code></span>
<span class="codeline" id="line-255"><code>							db.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, eq.Value))</code></span>
<span class="codeline" id="line-256"><code>						}</code></span>
<span class="codeline" id="line-257"><code>					case clause.Column:</code></span>
<span class="codeline" id="line-258"><code>						if field := db.Statement.Schema.LookUpField(column.Name); field != nil {</code></span>
<span class="codeline" id="line-259"><code>							db.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, eq.Value))</code></span>
<span class="codeline" id="line-260"><code>						}</code></span>
<span class="codeline" id="line-261"><code>					}</code></span>
<span class="codeline" id="line-262"><code>				} else if andCond, ok := expr.(clause.AndConditions); ok {</code></span>
<span class="codeline" id="line-263"><code>					db.assignInterfacesToValue(andCond.Exprs)</code></span>
<span class="codeline" id="line-264"><code>				}</code></span>
<span class="codeline" id="line-265"><code>			}</code></span>
<span class="codeline" id="line-266"><code>		case clause.Expression, map[string]string, map[interface{}]interface{}, map[string]interface{}:</code></span>
<span class="codeline" id="line-267"><code>			if exprs := db.Statement.BuildCondition(value); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-268"><code>				db.assignInterfacesToValue(exprs)</code></span>
<span class="codeline" id="line-269"><code>			}</code></span>
<span class="codeline" id="line-270"><code>		default:</code></span>
<span class="codeline" id="line-271"><code>			if s, err := schema.Parse(value, db.cacheStore, db.NamingStrategy); err == nil {</code></span>
<span class="codeline" id="line-272"><code>				reflectValue := reflect.Indirect(reflect.ValueOf(value))</code></span>
<span class="codeline" id="line-273"><code>				switch reflectValue.Kind() {</code></span>
<span class="codeline" id="line-274"><code>				case reflect.Struct:</code></span>
<span class="codeline" id="line-275"><code>					for _, f := range s.Fields {</code></span>
<span class="codeline" id="line-276"><code>						if f.Readable {</code></span>
<span class="codeline" id="line-277"><code>							if v, isZero := f.ValueOf(db.Statement.Context, reflectValue); !isZero {</code></span>
<span class="codeline" id="line-278"><code>								if field := db.Statement.Schema.LookUpField(f.Name); field != nil {</code></span>
<span class="codeline" id="line-279"><code>									db.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, v))</code></span>
<span class="codeline" id="line-280"><code>								}</code></span>
<span class="codeline" id="line-281"><code>							}</code></span>
<span class="codeline" id="line-282"><code>						}</code></span>
<span class="codeline" id="line-283"><code>					}</code></span>
<span class="codeline" id="line-284"><code>				}</code></span>
<span class="codeline" id="line-285"><code>			} else if len(values) &gt; 0 {</code></span>
<span class="codeline" id="line-286"><code>				if exprs := db.Statement.BuildCondition(values[0], values[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-287"><code>					db.assignInterfacesToValue(exprs)</code></span>
<span class="codeline" id="line-288"><code>				}</code></span>
<span class="codeline" id="line-289"><code>				return</code></span>
<span class="codeline" id="line-290"><code>			}</code></span>
<span class="codeline" id="line-291"><code>		}</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>// FirstOrInit finds the first matching record, otherwise if not found initializes a new instance with given conds.</code></span>
<span class="codeline" id="line-296"><code>// Each conds must be a struct or map.</code></span>
<span class="codeline" id="line-297"><code>//</code></span>
<span class="codeline" id="line-298"><code>// FirstOrInit never modifies the database. It is often used with Assign and Attrs.</code></span>
<span class="codeline" id="line-299"><code>//</code></span>
<span class="codeline" id="line-300"><code>//	// assign an email if the record is not found</code></span>
<span class="codeline" id="line-301"><code>//	db.Where(User{Name: "non_existing"}).Attrs(User{Email: "fake@fake.org"}).FirstOrInit(&amp;user)</code></span>
<span class="codeline" id="line-302"><code>//	// user -&gt; User{Name: "non_existing", Email: "fake@fake.org"}</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>//	// assign email regardless of if record is found</code></span>
<span class="codeline" id="line-305"><code>//	db.Where(User{Name: "jinzhu"}).Assign(User{Email: "fake@fake.org"}).FirstOrInit(&amp;user)</code></span>
<span class="codeline" id="line-306"><code>//	// user -&gt; User{Name: "jinzhu", Age: 20, Email: "fake@fake.org"}</code></span>
<span class="codeline" id="line-307"><code>func (db *DB) FirstOrInit(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-308"><code>	queryTx := db.Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-309"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-310"><code>	})</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>	if tx = queryTx.Find(dest, conds...); tx.RowsAffected == 0 {</code></span>
<span class="codeline" id="line-313"><code>		if c, ok := tx.Statement.Clauses["WHERE"]; ok {</code></span>
<span class="codeline" id="line-314"><code>			if where, ok := c.Expression.(clause.Where); ok {</code></span>
<span class="codeline" id="line-315"><code>				tx.assignInterfacesToValue(where.Exprs)</code></span>
<span class="codeline" id="line-316"><code>			}</code></span>
<span class="codeline" id="line-317"><code>		}</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-320"><code>		if len(tx.Statement.attrs) &gt; 0 {</code></span>
<span class="codeline" id="line-321"><code>			tx.assignInterfacesToValue(tx.Statement.attrs...)</code></span>
<span class="codeline" id="line-322"><code>		}</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	// initialize with attrs, conds</code></span>
<span class="codeline" id="line-326"><code>	if len(tx.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-327"><code>		tx.assignInterfacesToValue(tx.Statement.assigns...)</code></span>
<span class="codeline" id="line-328"><code>	}</code></span>
<span class="codeline" id="line-329"><code>	return</code></span>
<span class="codeline" id="line-330"><code>}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>// FirstOrCreate finds the first matching record, otherwise if not found creates a new instance with given conds.</code></span>
<span class="codeline" id="line-333"><code>// Each conds must be a struct or map.</code></span>
<span class="codeline" id="line-334"><code>//</code></span>
<span class="codeline" id="line-335"><code>// Using FirstOrCreate in conjunction with Assign will result in an update to the database even if the record exists.</code></span>
<span class="codeline" id="line-336"><code>//</code></span>
<span class="codeline" id="line-337"><code>//	// assign an email if the record is not found</code></span>
<span class="codeline" id="line-338"><code>//	result := db.Where(User{Name: "non_existing"}).Attrs(User{Email: "fake@fake.org"}).FirstOrCreate(&amp;user)</code></span>
<span class="codeline" id="line-339"><code>//	// user -&gt; User{Name: "non_existing", Email: "fake@fake.org"}</code></span>
<span class="codeline" id="line-340"><code>//	// result.RowsAffected -&gt; 1</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>//	// assign email regardless of if record is found</code></span>
<span class="codeline" id="line-343"><code>//	result := db.Where(User{Name: "jinzhu"}).Assign(User{Email: "fake@fake.org"}).FirstOrCreate(&amp;user)</code></span>
<span class="codeline" id="line-344"><code>//	// user -&gt; User{Name: "jinzhu", Age: 20, Email: "fake@fake.org"}</code></span>
<span class="codeline" id="line-345"><code>//	// result.RowsAffected -&gt; 1</code></span>
<span class="codeline" id="line-346"><code>func (db *DB) FirstOrCreate(dest interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-347"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-348"><code>	queryTx := db.Session(&amp;Session{}).Limit(1).Order(clause.OrderByColumn{</code></span>
<span class="codeline" id="line-349"><code>		Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},</code></span>
<span class="codeline" id="line-350"><code>	})</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>	result := queryTx.Find(dest, conds...)</code></span>
<span class="codeline" id="line-353"><code>	if result.Error != nil {</code></span>
<span class="codeline" id="line-354"><code>		tx.Error = result.Error</code></span>
<span class="codeline" id="line-355"><code>		return tx</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>	if result.RowsAffected == 0 {</code></span>
<span class="codeline" id="line-359"><code>		if c, ok := result.Statement.Clauses["WHERE"]; ok {</code></span>
<span class="codeline" id="line-360"><code>			if where, ok := c.Expression.(clause.Where); ok {</code></span>
<span class="codeline" id="line-361"><code>				result.assignInterfacesToValue(where.Exprs)</code></span>
<span class="codeline" id="line-362"><code>			}</code></span>
<span class="codeline" id="line-363"><code>		}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-366"><code>		if len(db.Statement.attrs) &gt; 0 {</code></span>
<span class="codeline" id="line-367"><code>			result.assignInterfacesToValue(db.Statement.attrs...)</code></span>
<span class="codeline" id="line-368"><code>		}</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>		// initialize with attrs, conds</code></span>
<span class="codeline" id="line-371"><code>		if len(db.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-372"><code>			result.assignInterfacesToValue(db.Statement.assigns...)</code></span>
<span class="codeline" id="line-373"><code>		}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>		return tx.Create(dest)</code></span>
<span class="codeline" id="line-376"><code>	} else if len(db.Statement.assigns) &gt; 0 {</code></span>
<span class="codeline" id="line-377"><code>		exprs := tx.Statement.BuildCondition(db.Statement.assigns[0], db.Statement.assigns[1:]...)</code></span>
<span class="codeline" id="line-378"><code>		assigns := map[string]interface{}{}</code></span>
<span class="codeline" id="line-379"><code>		for i := 0; i &lt; len(exprs); i++ {</code></span>
<span class="codeline" id="line-380"><code>			expr := exprs[i]</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>			if eq, ok := expr.(clause.AndConditions); ok {</code></span>
<span class="codeline" id="line-383"><code>				exprs = append(exprs, eq.Exprs...)</code></span>
<span class="codeline" id="line-384"><code>			} else if eq, ok := expr.(clause.Eq); ok {</code></span>
<span class="codeline" id="line-385"><code>				switch column := eq.Column.(type) {</code></span>
<span class="codeline" id="line-386"><code>				case string:</code></span>
<span class="codeline" id="line-387"><code>					assigns[column] = eq.Value</code></span>
<span class="codeline" id="line-388"><code>				case clause.Column:</code></span>
<span class="codeline" id="line-389"><code>					assigns[column.Name] = eq.Value</code></span>
<span class="codeline" id="line-390"><code>				}</code></span>
<span class="codeline" id="line-391"><code>			}</code></span>
<span class="codeline" id="line-392"><code>		}</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>		return tx.Model(dest).Updates(assigns)</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>	return tx</code></span>
<span class="codeline" id="line-398"><code>}</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>// Update updates column with value using callbacks. Reference: https://gorm.io/docs/update.html#Update-Changed-Fields</code></span>
<span class="codeline" id="line-401"><code>func (db *DB) Update(column string, value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-402"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-403"><code>	tx.Statement.Dest = map[string]interface{}{column: value}</code></span>
<span class="codeline" id="line-404"><code>	return tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-405"><code>}</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>// Updates updates attributes using callbacks. values must be a struct or map. Reference: https://gorm.io/docs/update.html#Update-Changed-Fields</code></span>
<span class="codeline" id="line-408"><code>func (db *DB) Updates(values interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-409"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-410"><code>	tx.Statement.Dest = values</code></span>
<span class="codeline" id="line-411"><code>	return tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-412"><code>}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>func (db *DB) UpdateColumn(column string, value interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-415"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-416"><code>	tx.Statement.Dest = map[string]interface{}{column: value}</code></span>
<span class="codeline" id="line-417"><code>	tx.Statement.SkipHooks = true</code></span>
<span class="codeline" id="line-418"><code>	return tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-419"><code>}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>func (db *DB) UpdateColumns(values interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-422"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-423"><code>	tx.Statement.Dest = values</code></span>
<span class="codeline" id="line-424"><code>	tx.Statement.SkipHooks = true</code></span>
<span class="codeline" id="line-425"><code>	return tx.callbacks.Update().Execute(tx)</code></span>
<span class="codeline" id="line-426"><code>}</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>// Delete deletes value matching given conditions. If value contains primary key it is included in the conditions. If</code></span>
<span class="codeline" id="line-429"><code>// value includes a deleted_at field, then Delete performs a soft delete instead by setting deleted_at with the current</code></span>
<span class="codeline" id="line-430"><code>// time if null.</code></span>
<span class="codeline" id="line-431"><code>func (db *DB) Delete(value interface{}, conds ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-432"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-433"><code>	if len(conds) &gt; 0 {</code></span>
<span class="codeline" id="line-434"><code>		if exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) &gt; 0 {</code></span>
<span class="codeline" id="line-435"><code>			tx.Statement.AddClause(clause.Where{Exprs: exprs})</code></span>
<span class="codeline" id="line-436"><code>		}</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>	tx.Statement.Dest = value</code></span>
<span class="codeline" id="line-439"><code>	return tx.callbacks.Delete().Execute(tx)</code></span>
<span class="codeline" id="line-440"><code>}</code></span>
<span class="codeline" id="line-441"><code></code></span>
<span class="codeline" id="line-442"><code>func (db *DB) Count(count *int64) (tx *DB) {</code></span>
<span class="codeline" id="line-443"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-444"><code>	if tx.Statement.Model == nil {</code></span>
<span class="codeline" id="line-445"><code>		tx.Statement.Model = tx.Statement.Dest</code></span>
<span class="codeline" id="line-446"><code>		defer func() {</code></span>
<span class="codeline" id="line-447"><code>			tx.Statement.Model = nil</code></span>
<span class="codeline" id="line-448"><code>		}()</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>	if selectClause, ok := db.Statement.Clauses["SELECT"]; ok {</code></span>
<span class="codeline" id="line-452"><code>		defer func() {</code></span>
<span class="codeline" id="line-453"><code>			tx.Statement.Clauses["SELECT"] = selectClause</code></span>
<span class="codeline" id="line-454"><code>		}()</code></span>
<span class="codeline" id="line-455"><code>	} else {</code></span>
<span class="codeline" id="line-456"><code>		defer delete(tx.Statement.Clauses, "SELECT")</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>	if len(tx.Statement.Selects) == 0 {</code></span>
<span class="codeline" id="line-460"><code>		tx.Statement.AddClause(clause.Select{Expression: clause.Expr{SQL: "count(*)"}})</code></span>
<span class="codeline" id="line-461"><code>	} else if !strings.HasPrefix(strings.TrimSpace(strings.ToLower(tx.Statement.Selects[0])), "count(") {</code></span>
<span class="codeline" id="line-462"><code>		expr := clause.Expr{SQL: "count(*)"}</code></span>
<span class="codeline" id="line-463"><code></code></span>
<span class="codeline" id="line-464"><code>		if len(tx.Statement.Selects) == 1 {</code></span>
<span class="codeline" id="line-465"><code>			dbName := tx.Statement.Selects[0]</code></span>
<span class="codeline" id="line-466"><code>			fields := strings.FieldsFunc(dbName, utils.IsValidDBNameChar)</code></span>
<span class="codeline" id="line-467"><code>			if len(fields) == 1 || (len(fields) == 3 &amp;&amp; (strings.ToUpper(fields[1]) == "AS" || fields[1] == ".")) {</code></span>
<span class="codeline" id="line-468"><code>				if tx.Statement.Parse(tx.Statement.Model) == nil {</code></span>
<span class="codeline" id="line-469"><code>					if f := tx.Statement.Schema.LookUpField(dbName); f != nil {</code></span>
<span class="codeline" id="line-470"><code>						dbName = f.DBName</code></span>
<span class="codeline" id="line-471"><code>					}</code></span>
<span class="codeline" id="line-472"><code>				}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>				if tx.Statement.Distinct {</code></span>
<span class="codeline" id="line-475"><code>					expr = clause.Expr{SQL: "COUNT(DISTINCT(?))", Vars: []interface{}{clause.Column{Name: dbName}}}</code></span>
<span class="codeline" id="line-476"><code>				} else if dbName != "*" {</code></span>
<span class="codeline" id="line-477"><code>					expr = clause.Expr{SQL: "COUNT(?)", Vars: []interface{}{clause.Column{Name: dbName}}}</code></span>
<span class="codeline" id="line-478"><code>				}</code></span>
<span class="codeline" id="line-479"><code>			}</code></span>
<span class="codeline" id="line-480"><code>		}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>		tx.Statement.AddClause(clause.Select{Expression: expr})</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>	if orderByClause, ok := db.Statement.Clauses["ORDER BY"]; ok {</code></span>
<span class="codeline" id="line-486"><code>		if _, ok := db.Statement.Clauses["GROUP BY"]; !ok {</code></span>
<span class="codeline" id="line-487"><code>			delete(tx.Statement.Clauses, "ORDER BY")</code></span>
<span class="codeline" id="line-488"><code>			defer func() {</code></span>
<span class="codeline" id="line-489"><code>				tx.Statement.Clauses["ORDER BY"] = orderByClause</code></span>
<span class="codeline" id="line-490"><code>			}()</code></span>
<span class="codeline" id="line-491"><code>		}</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	tx.Statement.Dest = count</code></span>
<span class="codeline" id="line-495"><code>	tx = tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>	if _, ok := db.Statement.Clauses["GROUP BY"]; ok || tx.RowsAffected != 1 {</code></span>
<span class="codeline" id="line-498"><code>		*count = tx.RowsAffected</code></span>
<span class="codeline" id="line-499"><code>	}</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>	return</code></span>
<span class="codeline" id="line-502"><code>}</code></span>
<span class="codeline" id="line-503"><code></code></span>
<span class="codeline" id="line-504"><code>func (db *DB) Row() *sql.Row {</code></span>
<span class="codeline" id="line-505"><code>	tx := db.getInstance().Set("rows", false)</code></span>
<span class="codeline" id="line-506"><code>	tx = tx.callbacks.Row().Execute(tx)</code></span>
<span class="codeline" id="line-507"><code>	row, ok := tx.Statement.Dest.(*sql.Row)</code></span>
<span class="codeline" id="line-508"><code>	if !ok &amp;&amp; tx.DryRun {</code></span>
<span class="codeline" id="line-509"><code>		db.Logger.Error(tx.Statement.Context, ErrDryRunModeUnsupported.Error())</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code>	return row</code></span>
<span class="codeline" id="line-512"><code>}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>func (db *DB) Rows() (*sql.Rows, error) {</code></span>
<span class="codeline" id="line-515"><code>	tx := db.getInstance().Set("rows", true)</code></span>
<span class="codeline" id="line-516"><code>	tx = tx.callbacks.Row().Execute(tx)</code></span>
<span class="codeline" id="line-517"><code>	rows, ok := tx.Statement.Dest.(*sql.Rows)</code></span>
<span class="codeline" id="line-518"><code>	if !ok &amp;&amp; tx.DryRun &amp;&amp; tx.Error == nil {</code></span>
<span class="codeline" id="line-519"><code>		tx.Error = ErrDryRunModeUnsupported</code></span>
<span class="codeline" id="line-520"><code>	}</code></span>
<span class="codeline" id="line-521"><code>	return rows, tx.Error</code></span>
<span class="codeline" id="line-522"><code>}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>// Scan scans selected value to the struct dest</code></span>
<span class="codeline" id="line-525"><code>func (db *DB) Scan(dest interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-526"><code>	config := *db.Config</code></span>
<span class="codeline" id="line-527"><code>	currentLogger, newLogger := config.Logger, logger.Recorder.New()</code></span>
<span class="codeline" id="line-528"><code>	config.Logger = newLogger</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-531"><code>	tx.Config = &amp;config</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>	if rows, err := tx.Rows(); err == nil {</code></span>
<span class="codeline" id="line-534"><code>		if rows.Next() {</code></span>
<span class="codeline" id="line-535"><code>			tx.ScanRows(rows, dest)</code></span>
<span class="codeline" id="line-536"><code>		} else {</code></span>
<span class="codeline" id="line-537"><code>			tx.RowsAffected = 0</code></span>
<span class="codeline" id="line-538"><code>			tx.AddError(rows.Err())</code></span>
<span class="codeline" id="line-539"><code>		}</code></span>
<span class="codeline" id="line-540"><code>		tx.AddError(rows.Close())</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>	currentLogger.Trace(tx.Statement.Context, newLogger.BeginAt, func() (string, int64) {</code></span>
<span class="codeline" id="line-544"><code>		return newLogger.SQL, tx.RowsAffected</code></span>
<span class="codeline" id="line-545"><code>	}, tx.Error)</code></span>
<span class="codeline" id="line-546"><code>	tx.Logger = currentLogger</code></span>
<span class="codeline" id="line-547"><code>	return</code></span>
<span class="codeline" id="line-548"><code>}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>// Pluck queries a single column from a model, returning in the slice dest. E.g.:</code></span>
<span class="codeline" id="line-551"><code>//</code></span>
<span class="codeline" id="line-552"><code>//	var ages []int64</code></span>
<span class="codeline" id="line-553"><code>//	db.Model(&amp;users).Pluck("age", &amp;ages)</code></span>
<span class="codeline" id="line-554"><code>func (db *DB) Pluck(column string, dest interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-555"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-556"><code>	if tx.Statement.Model != nil {</code></span>
<span class="codeline" id="line-557"><code>		if tx.Statement.Parse(tx.Statement.Model) == nil {</code></span>
<span class="codeline" id="line-558"><code>			if f := tx.Statement.Schema.LookUpField(column); f != nil {</code></span>
<span class="codeline" id="line-559"><code>				column = f.DBName</code></span>
<span class="codeline" id="line-560"><code>			}</code></span>
<span class="codeline" id="line-561"><code>		}</code></span>
<span class="codeline" id="line-562"><code>	}</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>	if len(tx.Statement.Selects) != 1 {</code></span>
<span class="codeline" id="line-565"><code>		fields := strings.FieldsFunc(column, utils.IsValidDBNameChar)</code></span>
<span class="codeline" id="line-566"><code>		tx.Statement.AddClauseIfNotExists(clause.Select{</code></span>
<span class="codeline" id="line-567"><code>			Distinct: tx.Statement.Distinct,</code></span>
<span class="codeline" id="line-568"><code>			Columns:  []clause.Column{{Name: column, Raw: len(fields) != 1}},</code></span>
<span class="codeline" id="line-569"><code>		})</code></span>
<span class="codeline" id="line-570"><code>	}</code></span>
<span class="codeline" id="line-571"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-572"><code>	return tx.callbacks.Query().Execute(tx)</code></span>
<span class="codeline" id="line-573"><code>}</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>func (db *DB) ScanRows(rows *sql.Rows, dest interface{}) error {</code></span>
<span class="codeline" id="line-576"><code>	tx := db.getInstance()</code></span>
<span class="codeline" id="line-577"><code>	if err := tx.Statement.Parse(dest); !errors.Is(err, schema.ErrUnsupportedDataType) {</code></span>
<span class="codeline" id="line-578"><code>		tx.AddError(err)</code></span>
<span class="codeline" id="line-579"><code>	}</code></span>
<span class="codeline" id="line-580"><code>	tx.Statement.Dest = dest</code></span>
<span class="codeline" id="line-581"><code>	tx.Statement.ReflectValue = reflect.ValueOf(dest)</code></span>
<span class="codeline" id="line-582"><code>	for tx.Statement.ReflectValue.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-583"><code>		elem := tx.Statement.ReflectValue.Elem()</code></span>
<span class="codeline" id="line-584"><code>		if !elem.IsValid() {</code></span>
<span class="codeline" id="line-585"><code>			elem = reflect.New(tx.Statement.ReflectValue.Type().Elem())</code></span>
<span class="codeline" id="line-586"><code>			tx.Statement.ReflectValue.Set(elem)</code></span>
<span class="codeline" id="line-587"><code>		}</code></span>
<span class="codeline" id="line-588"><code>		tx.Statement.ReflectValue = elem</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code>	Scan(rows, tx, ScanInitialized)</code></span>
<span class="codeline" id="line-591"><code>	return tx.Error</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>// Connection uses a db connection to execute an arbitrary number of commands in fc. When finished, the connection is</code></span>
<span class="codeline" id="line-595"><code>// returned to the connection pool.</code></span>
<span class="codeline" id="line-596"><code>func (db *DB) Connection(fc func(tx *DB) error) (err error) {</code></span>
<span class="codeline" id="line-597"><code>	if db.Error != nil {</code></span>
<span class="codeline" id="line-598"><code>		return db.Error</code></span>
<span class="codeline" id="line-599"><code>	}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>	tx := db.getInstance()</code></span>
<span class="codeline" id="line-602"><code>	sqlDB, err := tx.DB()</code></span>
<span class="codeline" id="line-603"><code>	if err != nil {</code></span>
<span class="codeline" id="line-604"><code>		return</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	conn, err := sqlDB.Conn(tx.Statement.Context)</code></span>
<span class="codeline" id="line-608"><code>	if err != nil {</code></span>
<span class="codeline" id="line-609"><code>		return</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>	defer conn.Close()</code></span>
<span class="codeline" id="line-613"><code>	tx.Statement.ConnPool = conn</code></span>
<span class="codeline" id="line-614"><code>	return fc(tx)</code></span>
<span class="codeline" id="line-615"><code>}</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>// Transaction start a transaction as a block, return error will rollback, otherwise to commit. Transaction executes an</code></span>
<span class="codeline" id="line-618"><code>// arbitrary number of commands in fc within a transaction. On success the changes are committed; if an error occurs</code></span>
<span class="codeline" id="line-619"><code>// they are rolled back.</code></span>
<span class="codeline" id="line-620"><code>func (db *DB) Transaction(fc func(tx *DB) error, opts ...*sql.TxOptions) (err error) {</code></span>
<span class="codeline" id="line-621"><code>	panicked := true</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil {</code></span>
<span class="codeline" id="line-624"><code>		// nested transaction</code></span>
<span class="codeline" id="line-625"><code>		if !db.DisableNestedTransaction {</code></span>
<span class="codeline" id="line-626"><code>			err = db.SavePoint(fmt.Sprintf("sp%p", fc)).Error</code></span>
<span class="codeline" id="line-627"><code>			if err != nil {</code></span>
<span class="codeline" id="line-628"><code>				return</code></span>
<span class="codeline" id="line-629"><code>			}</code></span>
<span class="codeline" id="line-630"><code>			defer func() {</code></span>
<span class="codeline" id="line-631"><code>				// Make sure to rollback when panic, Block error or Commit error</code></span>
<span class="codeline" id="line-632"><code>				if panicked || err != nil {</code></span>
<span class="codeline" id="line-633"><code>					db.RollbackTo(fmt.Sprintf("sp%p", fc))</code></span>
<span class="codeline" id="line-634"><code>				}</code></span>
<span class="codeline" id="line-635"><code>			}()</code></span>
<span class="codeline" id="line-636"><code>		}</code></span>
<span class="codeline" id="line-637"><code>		err = fc(db.Session(&amp;Session{NewDB: db.clone == 1}))</code></span>
<span class="codeline" id="line-638"><code>	} else {</code></span>
<span class="codeline" id="line-639"><code>		tx := db.Begin(opts...)</code></span>
<span class="codeline" id="line-640"><code>		if tx.Error != nil {</code></span>
<span class="codeline" id="line-641"><code>			return tx.Error</code></span>
<span class="codeline" id="line-642"><code>		}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>		defer func() {</code></span>
<span class="codeline" id="line-645"><code>			// Make sure to rollback when panic, Block error or Commit error</code></span>
<span class="codeline" id="line-646"><code>			if panicked || err != nil {</code></span>
<span class="codeline" id="line-647"><code>				tx.Rollback()</code></span>
<span class="codeline" id="line-648"><code>			}</code></span>
<span class="codeline" id="line-649"><code>		}()</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>		if err = fc(tx); err == nil {</code></span>
<span class="codeline" id="line-652"><code>			panicked = false</code></span>
<span class="codeline" id="line-653"><code>			return tx.Commit().Error</code></span>
<span class="codeline" id="line-654"><code>		}</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>	panicked = false</code></span>
<span class="codeline" id="line-658"><code>	return</code></span>
<span class="codeline" id="line-659"><code>}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>// Begin begins a transaction with any transaction options opts</code></span>
<span class="codeline" id="line-662"><code>func (db *DB) Begin(opts ...*sql.TxOptions) *DB {</code></span>
<span class="codeline" id="line-663"><code>	var (</code></span>
<span class="codeline" id="line-664"><code>		// clone statement</code></span>
<span class="codeline" id="line-665"><code>		tx  = db.getInstance().Session(&amp;Session{Context: db.Statement.Context, NewDB: db.clone == 1})</code></span>
<span class="codeline" id="line-666"><code>		opt *sql.TxOptions</code></span>
<span class="codeline" id="line-667"><code>		err error</code></span>
<span class="codeline" id="line-668"><code>	)</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>	if len(opts) &gt; 0 {</code></span>
<span class="codeline" id="line-671"><code>		opt = opts[0]</code></span>
<span class="codeline" id="line-672"><code>	}</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	switch beginner := tx.Statement.ConnPool.(type) {</code></span>
<span class="codeline" id="line-675"><code>	case TxBeginner:</code></span>
<span class="codeline" id="line-676"><code>		tx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)</code></span>
<span class="codeline" id="line-677"><code>	case ConnPoolBeginner:</code></span>
<span class="codeline" id="line-678"><code>		tx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)</code></span>
<span class="codeline" id="line-679"><code>	default:</code></span>
<span class="codeline" id="line-680"><code>		err = ErrInvalidTransaction</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code></code></span>
<span class="codeline" id="line-683"><code>	if err != nil {</code></span>
<span class="codeline" id="line-684"><code>		tx.AddError(err)</code></span>
<span class="codeline" id="line-685"><code>	}</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>	return tx</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// Commit commits the changes in a transaction</code></span>
<span class="codeline" id="line-691"><code>func (db *DB) Commit() *DB {</code></span>
<span class="codeline" id="line-692"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil &amp;&amp; !reflect.ValueOf(committer).IsNil() {</code></span>
<span class="codeline" id="line-693"><code>		db.AddError(committer.Commit())</code></span>
<span class="codeline" id="line-694"><code>	} else {</code></span>
<span class="codeline" id="line-695"><code>		db.AddError(ErrInvalidTransaction)</code></span>
<span class="codeline" id="line-696"><code>	}</code></span>
<span class="codeline" id="line-697"><code>	return db</code></span>
<span class="codeline" id="line-698"><code>}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>// Rollback rollbacks the changes in a transaction</code></span>
<span class="codeline" id="line-701"><code>func (db *DB) Rollback() *DB {</code></span>
<span class="codeline" id="line-702"><code>	if committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != nil {</code></span>
<span class="codeline" id="line-703"><code>		if !reflect.ValueOf(committer).IsNil() {</code></span>
<span class="codeline" id="line-704"><code>			db.AddError(committer.Rollback())</code></span>
<span class="codeline" id="line-705"><code>		}</code></span>
<span class="codeline" id="line-706"><code>	} else {</code></span>
<span class="codeline" id="line-707"><code>		db.AddError(ErrInvalidTransaction)</code></span>
<span class="codeline" id="line-708"><code>	}</code></span>
<span class="codeline" id="line-709"><code>	return db</code></span>
<span class="codeline" id="line-710"><code>}</code></span>
<span class="codeline" id="line-711"><code></code></span>
<span class="codeline" id="line-712"><code>func (db *DB) SavePoint(name string) *DB {</code></span>
<span class="codeline" id="line-713"><code>	if savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {</code></span>
<span class="codeline" id="line-714"><code>		// close prepared statement, because SavePoint not support prepared statement.</code></span>
<span class="codeline" id="line-715"><code>		// e.g. mysql8.0 doc: https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html</code></span>
<span class="codeline" id="line-716"><code>		var (</code></span>
<span class="codeline" id="line-717"><code>			preparedStmtTx   *PreparedStmtTX</code></span>
<span class="codeline" id="line-718"><code>			isPreparedStmtTx bool</code></span>
<span class="codeline" id="line-719"><code>		)</code></span>
<span class="codeline" id="line-720"><code>		// close prepared statement, because SavePoint not support prepared statement.</code></span>
<span class="codeline" id="line-721"><code>		if preparedStmtTx, isPreparedStmtTx = db.Statement.ConnPool.(*PreparedStmtTX); isPreparedStmtTx {</code></span>
<span class="codeline" id="line-722"><code>			db.Statement.ConnPool = preparedStmtTx.Tx</code></span>
<span class="codeline" id="line-723"><code>		}</code></span>
<span class="codeline" id="line-724"><code>		db.AddError(savePointer.SavePoint(db, name))</code></span>
<span class="codeline" id="line-725"><code>		// restore prepared statement</code></span>
<span class="codeline" id="line-726"><code>		if isPreparedStmtTx {</code></span>
<span class="codeline" id="line-727"><code>			db.Statement.ConnPool = preparedStmtTx</code></span>
<span class="codeline" id="line-728"><code>		}</code></span>
<span class="codeline" id="line-729"><code>	} else {</code></span>
<span class="codeline" id="line-730"><code>		db.AddError(ErrUnsupportedDriver)</code></span>
<span class="codeline" id="line-731"><code>	}</code></span>
<span class="codeline" id="line-732"><code>	return db</code></span>
<span class="codeline" id="line-733"><code>}</code></span>
<span class="codeline" id="line-734"><code></code></span>
<span class="codeline" id="line-735"><code>func (db *DB) RollbackTo(name string) *DB {</code></span>
<span class="codeline" id="line-736"><code>	if savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {</code></span>
<span class="codeline" id="line-737"><code>		// close prepared statement, because RollbackTo not support prepared statement.</code></span>
<span class="codeline" id="line-738"><code>		// e.g. mysql8.0 doc: https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html</code></span>
<span class="codeline" id="line-739"><code>		var (</code></span>
<span class="codeline" id="line-740"><code>			preparedStmtTx   *PreparedStmtTX</code></span>
<span class="codeline" id="line-741"><code>			isPreparedStmtTx bool</code></span>
<span class="codeline" id="line-742"><code>		)</code></span>
<span class="codeline" id="line-743"><code>		// close prepared statement, because SavePoint not support prepared statement.</code></span>
<span class="codeline" id="line-744"><code>		if preparedStmtTx, isPreparedStmtTx = db.Statement.ConnPool.(*PreparedStmtTX); isPreparedStmtTx {</code></span>
<span class="codeline" id="line-745"><code>			db.Statement.ConnPool = preparedStmtTx.Tx</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code>		db.AddError(savePointer.RollbackTo(db, name))</code></span>
<span class="codeline" id="line-748"><code>		// restore prepared statement</code></span>
<span class="codeline" id="line-749"><code>		if isPreparedStmtTx {</code></span>
<span class="codeline" id="line-750"><code>			db.Statement.ConnPool = preparedStmtTx</code></span>
<span class="codeline" id="line-751"><code>		}</code></span>
<span class="codeline" id="line-752"><code>	} else {</code></span>
<span class="codeline" id="line-753"><code>		db.AddError(ErrUnsupportedDriver)</code></span>
<span class="codeline" id="line-754"><code>	}</code></span>
<span class="codeline" id="line-755"><code>	return db</code></span>
<span class="codeline" id="line-756"><code>}</code></span>
<span class="codeline" id="line-757"><code></code></span>
<span class="codeline" id="line-758"><code>// Exec executes raw sql</code></span>
<span class="codeline" id="line-759"><code>func (db *DB) Exec(sql string, values ...interface{}) (tx *DB) {</code></span>
<span class="codeline" id="line-760"><code>	tx = db.getInstance()</code></span>
<span class="codeline" id="line-761"><code>	tx.Statement.SQL = strings.Builder{}</code></span>
<span class="codeline" id="line-762"><code></code></span>
<span class="codeline" id="line-763"><code>	if strings.Contains(sql, "@") {</code></span>
<span class="codeline" id="line-764"><code>		clause.NamedExpr{SQL: sql, Vars: values}.Build(tx.Statement)</code></span>
<span class="codeline" id="line-765"><code>	} else {</code></span>
<span class="codeline" id="line-766"><code>		clause.Expr{SQL: sql, Vars: values}.Build(tx.Statement)</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code></code></span>
<span class="codeline" id="line-769"><code>	return tx.callbacks.Raw().Execute(tx)</code></span>
<span class="codeline" id="line-770"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>