<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: backward_references_hq.go in package github.com/andybalholm/brotli</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	backward_references_hq.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/andybalholm/brotli.html">github.com/andybalholm/brotli</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package brotli</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import "math"</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>type zopfliNode struct {</code></span>
<span class="codeline" id="line-6"><code>	length              uint32</code></span>
<span class="codeline" id="line-7"><code>	distance            uint32</code></span>
<span class="codeline" id="line-8"><code>	dcode_insert_length uint32</code></span>
<span class="codeline" id="line-9"><code>	u                   struct {</code></span>
<span class="codeline" id="line-10"><code>		cost     float32</code></span>
<span class="codeline" id="line-11"><code>		next     uint32</code></span>
<span class="codeline" id="line-12"><code>		shortcut uint32</code></span>
<span class="codeline" id="line-13"><code>	}</code></span>
<span class="codeline" id="line-14"><code>}</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>const maxEffectiveDistanceAlphabetSize = 544</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>const kInfinity float32 = 1.7e38 /* ~= 2 ^ 127 */</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>var kDistanceCacheIndex = []uint32{0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1}</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>var kDistanceCacheOffset = []int{0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>func initZopfliNodes(array []zopfliNode, length uint) {</code></span>
<span class="codeline" id="line-25"><code>	var stub zopfliNode</code></span>
<span class="codeline" id="line-26"><code>	var i uint</code></span>
<span class="codeline" id="line-27"><code>	stub.length = 1</code></span>
<span class="codeline" id="line-28"><code>	stub.distance = 0</code></span>
<span class="codeline" id="line-29"><code>	stub.dcode_insert_length = 0</code></span>
<span class="codeline" id="line-30"><code>	stub.u.cost = kInfinity</code></span>
<span class="codeline" id="line-31"><code>	for i = 0; i &lt; length; i++ {</code></span>
<span class="codeline" id="line-32"><code>		array[i] = stub</code></span>
<span class="codeline" id="line-33"><code>	}</code></span>
<span class="codeline" id="line-34"><code>}</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>func zopfliNodeCopyLength(self *zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-37"><code>	return self.length &amp; 0x1FFFFFF</code></span>
<span class="codeline" id="line-38"><code>}</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>func zopfliNodeLengthCode(self *zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-41"><code>	var modifier uint32 = self.length &gt;&gt; 25</code></span>
<span class="codeline" id="line-42"><code>	return zopfliNodeCopyLength(self) + 9 - modifier</code></span>
<span class="codeline" id="line-43"><code>}</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>func zopfliNodeCopyDistance(self *zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-46"><code>	return self.distance</code></span>
<span class="codeline" id="line-47"><code>}</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>func zopfliNodeDistanceCode(self *zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-50"><code>	var short_code uint32 = self.dcode_insert_length &gt;&gt; 27</code></span>
<span class="codeline" id="line-51"><code>	if short_code == 0 {</code></span>
<span class="codeline" id="line-52"><code>		return zopfliNodeCopyDistance(self) + numDistanceShortCodes - 1</code></span>
<span class="codeline" id="line-53"><code>	} else {</code></span>
<span class="codeline" id="line-54"><code>		return short_code - 1</code></span>
<span class="codeline" id="line-55"><code>	}</code></span>
<span class="codeline" id="line-56"><code>}</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>func zopfliNodeCommandLength(self *zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-59"><code>	return zopfliNodeCopyLength(self) + (self.dcode_insert_length &amp; 0x7FFFFFF)</code></span>
<span class="codeline" id="line-60"><code>}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>/* Histogram based cost model for zopflification. */</code></span>
<span class="codeline" id="line-63"><code>type zopfliCostModel struct {</code></span>
<span class="codeline" id="line-64"><code>	cost_cmd_               [numCommandSymbols]float32</code></span>
<span class="codeline" id="line-65"><code>	cost_dist_              []float32</code></span>
<span class="codeline" id="line-66"><code>	distance_histogram_size uint32</code></span>
<span class="codeline" id="line-67"><code>	literal_costs_          []float32</code></span>
<span class="codeline" id="line-68"><code>	min_cost_cmd_           float32</code></span>
<span class="codeline" id="line-69"><code>	num_bytes_              uint</code></span>
<span class="codeline" id="line-70"><code>}</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>func initZopfliCostModel(self *zopfliCostModel, dist *distanceParams, num_bytes uint) {</code></span>
<span class="codeline" id="line-73"><code>	var distance_histogram_size uint32 = dist.alphabet_size</code></span>
<span class="codeline" id="line-74"><code>	if distance_histogram_size &gt; maxEffectiveDistanceAlphabetSize {</code></span>
<span class="codeline" id="line-75"><code>		distance_histogram_size = maxEffectiveDistanceAlphabetSize</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>	self.num_bytes_ = num_bytes</code></span>
<span class="codeline" id="line-79"><code>	self.literal_costs_ = make([]float32, (num_bytes + 2))</code></span>
<span class="codeline" id="line-80"><code>	self.cost_dist_ = make([]float32, (dist.alphabet_size))</code></span>
<span class="codeline" id="line-81"><code>	self.distance_histogram_size = distance_histogram_size</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>func cleanupZopfliCostModel(self *zopfliCostModel) {</code></span>
<span class="codeline" id="line-85"><code>	self.literal_costs_ = nil</code></span>
<span class="codeline" id="line-86"><code>	self.cost_dist_ = nil</code></span>
<span class="codeline" id="line-87"><code>}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>func setCost(histogram []uint32, histogram_size uint, literal_histogram bool, cost []float32) {</code></span>
<span class="codeline" id="line-90"><code>	var sum uint = 0</code></span>
<span class="codeline" id="line-91"><code>	var missing_symbol_sum uint</code></span>
<span class="codeline" id="line-92"><code>	var log2sum float32</code></span>
<span class="codeline" id="line-93"><code>	var missing_symbol_cost float32</code></span>
<span class="codeline" id="line-94"><code>	var i uint</code></span>
<span class="codeline" id="line-95"><code>	for i = 0; i &lt; histogram_size; i++ {</code></span>
<span class="codeline" id="line-96"><code>		sum += uint(histogram[i])</code></span>
<span class="codeline" id="line-97"><code>	}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>	log2sum = float32(fastLog2(sum))</code></span>
<span class="codeline" id="line-100"><code>	missing_symbol_sum = sum</code></span>
<span class="codeline" id="line-101"><code>	if !literal_histogram {</code></span>
<span class="codeline" id="line-102"><code>		for i = 0; i &lt; histogram_size; i++ {</code></span>
<span class="codeline" id="line-103"><code>			if histogram[i] == 0 {</code></span>
<span class="codeline" id="line-104"><code>				missing_symbol_sum++</code></span>
<span class="codeline" id="line-105"><code>			}</code></span>
<span class="codeline" id="line-106"><code>		}</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>	missing_symbol_cost = float32(fastLog2(missing_symbol_sum)) + 2</code></span>
<span class="codeline" id="line-110"><code>	for i = 0; i &lt; histogram_size; i++ {</code></span>
<span class="codeline" id="line-111"><code>		if histogram[i] == 0 {</code></span>
<span class="codeline" id="line-112"><code>			cost[i] = missing_symbol_cost</code></span>
<span class="codeline" id="line-113"><code>			continue</code></span>
<span class="codeline" id="line-114"><code>		}</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>		/* Shannon bits for this symbol. */</code></span>
<span class="codeline" id="line-117"><code>		cost[i] = log2sum - float32(fastLog2(uint(histogram[i])))</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>		/* Cannot be coded with less than 1 bit */</code></span>
<span class="codeline" id="line-120"><code>		if cost[i] &lt; 1 {</code></span>
<span class="codeline" id="line-121"><code>			cost[i] = 1</code></span>
<span class="codeline" id="line-122"><code>		}</code></span>
<span class="codeline" id="line-123"><code>	}</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>func zopfliCostModelSetFromCommands(self *zopfliCostModel, position uint, ringbuffer []byte, ringbuffer_mask uint, commands []command, last_insert_len uint) {</code></span>
<span class="codeline" id="line-127"><code>	var histogram_literal [numLiteralSymbols]uint32</code></span>
<span class="codeline" id="line-128"><code>	var histogram_cmd [numCommandSymbols]uint32</code></span>
<span class="codeline" id="line-129"><code>	var histogram_dist [maxEffectiveDistanceAlphabetSize]uint32</code></span>
<span class="codeline" id="line-130"><code>	var cost_literal [numLiteralSymbols]float32</code></span>
<span class="codeline" id="line-131"><code>	var pos uint = position - last_insert_len</code></span>
<span class="codeline" id="line-132"><code>	var min_cost_cmd float32 = kInfinity</code></span>
<span class="codeline" id="line-133"><code>	var cost_cmd []float32 = self.cost_cmd_[:]</code></span>
<span class="codeline" id="line-134"><code>	var literal_costs []float32</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>	histogram_literal = [numLiteralSymbols]uint32{}</code></span>
<span class="codeline" id="line-137"><code>	histogram_cmd = [numCommandSymbols]uint32{}</code></span>
<span class="codeline" id="line-138"><code>	histogram_dist = [maxEffectiveDistanceAlphabetSize]uint32{}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	for i := range commands {</code></span>
<span class="codeline" id="line-141"><code>		var inslength uint = uint(commands[i].insert_len_)</code></span>
<span class="codeline" id="line-142"><code>		var copylength uint = uint(commandCopyLen(&amp;commands[i]))</code></span>
<span class="codeline" id="line-143"><code>		var distcode uint = uint(commands[i].dist_prefix_) &amp; 0x3FF</code></span>
<span class="codeline" id="line-144"><code>		var cmdcode uint = uint(commands[i].cmd_prefix_)</code></span>
<span class="codeline" id="line-145"><code>		var j uint</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>		histogram_cmd[cmdcode]++</code></span>
<span class="codeline" id="line-148"><code>		if cmdcode &gt;= 128 {</code></span>
<span class="codeline" id="line-149"><code>			histogram_dist[distcode]++</code></span>
<span class="codeline" id="line-150"><code>		}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>		for j = 0; j &lt; inslength; j++ {</code></span>
<span class="codeline" id="line-153"><code>			histogram_literal[ringbuffer[(pos+j)&amp;ringbuffer_mask]]++</code></span>
<span class="codeline" id="line-154"><code>		}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>		pos += inslength + copylength</code></span>
<span class="codeline" id="line-157"><code>	}</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>	setCost(histogram_literal[:], numLiteralSymbols, true, cost_literal[:])</code></span>
<span class="codeline" id="line-160"><code>	setCost(histogram_cmd[:], numCommandSymbols, false, cost_cmd)</code></span>
<span class="codeline" id="line-161"><code>	setCost(histogram_dist[:], uint(self.distance_histogram_size), false, self.cost_dist_)</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>	for i := 0; i &lt; numCommandSymbols; i++ {</code></span>
<span class="codeline" id="line-164"><code>		min_cost_cmd = brotli_min_float(min_cost_cmd, cost_cmd[i])</code></span>
<span class="codeline" id="line-165"><code>	}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	self.min_cost_cmd_ = min_cost_cmd</code></span>
<span class="codeline" id="line-168"><code>	{</code></span>
<span class="codeline" id="line-169"><code>		literal_costs = self.literal_costs_</code></span>
<span class="codeline" id="line-170"><code>		var literal_carry float32 = 0.0</code></span>
<span class="codeline" id="line-171"><code>		num_bytes := int(self.num_bytes_)</code></span>
<span class="codeline" id="line-172"><code>		literal_costs[0] = 0.0</code></span>
<span class="codeline" id="line-173"><code>		for i := 0; i &lt; num_bytes; i++ {</code></span>
<span class="codeline" id="line-174"><code>			literal_carry += cost_literal[ringbuffer[(position+uint(i))&amp;ringbuffer_mask]]</code></span>
<span class="codeline" id="line-175"><code>			literal_costs[i+1] = literal_costs[i] + literal_carry</code></span>
<span class="codeline" id="line-176"><code>			literal_carry -= literal_costs[i+1] - literal_costs[i]</code></span>
<span class="codeline" id="line-177"><code>		}</code></span>
<span class="codeline" id="line-178"><code>	}</code></span>
<span class="codeline" id="line-179"><code>}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>func zopfliCostModelSetFromLiteralCosts(self *zopfliCostModel, position uint, ringbuffer []byte, ringbuffer_mask uint) {</code></span>
<span class="codeline" id="line-182"><code>	var literal_costs []float32 = self.literal_costs_</code></span>
<span class="codeline" id="line-183"><code>	var literal_carry float32 = 0.0</code></span>
<span class="codeline" id="line-184"><code>	var cost_dist []float32 = self.cost_dist_</code></span>
<span class="codeline" id="line-185"><code>	var cost_cmd []float32 = self.cost_cmd_[:]</code></span>
<span class="codeline" id="line-186"><code>	var num_bytes uint = self.num_bytes_</code></span>
<span class="codeline" id="line-187"><code>	var i uint</code></span>
<span class="codeline" id="line-188"><code>	estimateBitCostsForLiterals(position, num_bytes, ringbuffer_mask, ringbuffer, literal_costs[1:])</code></span>
<span class="codeline" id="line-189"><code>	literal_costs[0] = 0.0</code></span>
<span class="codeline" id="line-190"><code>	for i = 0; i &lt; num_bytes; i++ {</code></span>
<span class="codeline" id="line-191"><code>		literal_carry += literal_costs[i+1]</code></span>
<span class="codeline" id="line-192"><code>		literal_costs[i+1] = literal_costs[i] + literal_carry</code></span>
<span class="codeline" id="line-193"><code>		literal_carry -= literal_costs[i+1] - literal_costs[i]</code></span>
<span class="codeline" id="line-194"><code>	}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>	for i = 0; i &lt; numCommandSymbols; i++ {</code></span>
<span class="codeline" id="line-197"><code>		cost_cmd[i] = float32(fastLog2(uint(11 + uint32(i))))</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>	for i = 0; uint32(i) &lt; self.distance_histogram_size; i++ {</code></span>
<span class="codeline" id="line-201"><code>		cost_dist[i] = float32(fastLog2(uint(20 + uint32(i))))</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	self.min_cost_cmd_ = float32(fastLog2(11))</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>func zopfliCostModelGetCommandCost(self *zopfliCostModel, cmdcode uint16) float32 {</code></span>
<span class="codeline" id="line-208"><code>	return self.cost_cmd_[cmdcode]</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>func zopfliCostModelGetDistanceCost(self *zopfliCostModel, distcode uint) float32 {</code></span>
<span class="codeline" id="line-212"><code>	return self.cost_dist_[distcode]</code></span>
<span class="codeline" id="line-213"><code>}</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>func zopfliCostModelGetLiteralCosts(self *zopfliCostModel, from uint, to uint) float32 {</code></span>
<span class="codeline" id="line-216"><code>	return self.literal_costs_[to] - self.literal_costs_[from]</code></span>
<span class="codeline" id="line-217"><code>}</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>func zopfliCostModelGetMinCostCmd(self *zopfliCostModel) float32 {</code></span>
<span class="codeline" id="line-220"><code>	return self.min_cost_cmd_</code></span>
<span class="codeline" id="line-221"><code>}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>/* REQUIRES: len &gt;= 2, start_pos &lt;= pos */</code></span>
<span class="codeline" id="line-224"><code>/* REQUIRES: cost &lt; kInfinity, nodes[start_pos].cost &lt; kInfinity */</code></span>
<span class="codeline" id="line-225"><code>/* Maintains the "ZopfliNode array invariant". */</code></span>
<span class="codeline" id="line-226"><code>func updateZopfliNode(nodes []zopfliNode, pos uint, start_pos uint, len uint, len_code uint, dist uint, short_code uint, cost float32) {</code></span>
<span class="codeline" id="line-227"><code>	var next *zopfliNode = &amp;nodes[pos+len]</code></span>
<span class="codeline" id="line-228"><code>	next.length = uint32(len | (len+9-len_code)&lt;&lt;25)</code></span>
<span class="codeline" id="line-229"><code>	next.distance = uint32(dist)</code></span>
<span class="codeline" id="line-230"><code>	next.dcode_insert_length = uint32(short_code&lt;&lt;27 | (pos - start_pos))</code></span>
<span class="codeline" id="line-231"><code>	next.u.cost = cost</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>type posData struct {</code></span>
<span class="codeline" id="line-235"><code>	pos            uint</code></span>
<span class="codeline" id="line-236"><code>	distance_cache [4]int</code></span>
<span class="codeline" id="line-237"><code>	costdiff       float32</code></span>
<span class="codeline" id="line-238"><code>	cost           float32</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>/* Maintains the smallest 8 cost difference together with their positions */</code></span>
<span class="codeline" id="line-242"><code>type startPosQueue struct {</code></span>
<span class="codeline" id="line-243"><code>	q_   [8]posData</code></span>
<span class="codeline" id="line-244"><code>	idx_ uint</code></span>
<span class="codeline" id="line-245"><code>}</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>func initStartPosQueue(self *startPosQueue) {</code></span>
<span class="codeline" id="line-248"><code>	self.idx_ = 0</code></span>
<span class="codeline" id="line-249"><code>}</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>func startPosQueueSize(self *startPosQueue) uint {</code></span>
<span class="codeline" id="line-252"><code>	return brotli_min_size_t(self.idx_, 8)</code></span>
<span class="codeline" id="line-253"><code>}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>func startPosQueuePush(self *startPosQueue, posdata *posData) {</code></span>
<span class="codeline" id="line-256"><code>	var offset uint = ^(self.idx_) &amp; 7</code></span>
<span class="codeline" id="line-257"><code>	self.idx_++</code></span>
<span class="codeline" id="line-258"><code>	var len uint = startPosQueueSize(self)</code></span>
<span class="codeline" id="line-259"><code>	var i uint</code></span>
<span class="codeline" id="line-260"><code>	var q []posData = self.q_[:]</code></span>
<span class="codeline" id="line-261"><code>	q[offset] = *posdata</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	/* Restore the sorted order. In the list of |len| items at most |len - 1|</code></span>
<span class="codeline" id="line-264"><code>	   adjacent element comparisons / swaps are required. */</code></span>
<span class="codeline" id="line-265"><code>	for i = 1; i &lt; len; i++ {</code></span>
<span class="codeline" id="line-266"><code>		if q[offset&amp;7].costdiff &gt; q[(offset+1)&amp;7].costdiff {</code></span>
<span class="codeline" id="line-267"><code>			var tmp posData = q[offset&amp;7]</code></span>
<span class="codeline" id="line-268"><code>			q[offset&amp;7] = q[(offset+1)&amp;7]</code></span>
<span class="codeline" id="line-269"><code>			q[(offset+1)&amp;7] = tmp</code></span>
<span class="codeline" id="line-270"><code>		}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>		offset++</code></span>
<span class="codeline" id="line-273"><code>	}</code></span>
<span class="codeline" id="line-274"><code>}</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>func startPosQueueAt(self *startPosQueue, k uint) *posData {</code></span>
<span class="codeline" id="line-277"><code>	return &amp;self.q_[(k-self.idx_)&amp;7]</code></span>
<span class="codeline" id="line-278"><code>}</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>/* Returns the minimum possible copy length that can improve the cost of any */</code></span>
<span class="codeline" id="line-281"><code>/* future position. */</code></span>
<span class="codeline" id="line-282"><code>func computeMinimumCopyLength(start_cost float32, nodes []zopfliNode, num_bytes uint, pos uint) uint {</code></span>
<span class="codeline" id="line-283"><code>	var min_cost float32 = start_cost</code></span>
<span class="codeline" id="line-284"><code>	var len uint = 2</code></span>
<span class="codeline" id="line-285"><code>	var next_len_bucket uint = 4</code></span>
<span class="codeline" id="line-286"><code>	/* Compute the minimum possible cost of reaching any future position. */</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>	var next_len_offset uint = 10</code></span>
<span class="codeline" id="line-289"><code>	for pos+len &lt;= num_bytes &amp;&amp; nodes[pos+len].u.cost &lt;= min_cost {</code></span>
<span class="codeline" id="line-290"><code>		/* We already reached (pos + len) with no more cost than the minimum</code></span>
<span class="codeline" id="line-291"><code>		   possible cost of reaching anything from this pos, so there is no point in</code></span>
<span class="codeline" id="line-292"><code>		   looking for lengths &lt;= len. */</code></span>
<span class="codeline" id="line-293"><code>		len++</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>		if len == next_len_offset {</code></span>
<span class="codeline" id="line-296"><code>			/* We reached the next copy length code bucket, so we add one more</code></span>
<span class="codeline" id="line-297"><code>			   extra bit to the minimum cost. */</code></span>
<span class="codeline" id="line-298"><code>			min_cost += 1.0</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>			next_len_offset += next_len_bucket</code></span>
<span class="codeline" id="line-301"><code>			next_len_bucket *= 2</code></span>
<span class="codeline" id="line-302"><code>		}</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>	return uint(len)</code></span>
<span class="codeline" id="line-306"><code>}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>/* REQUIRES: nodes[pos].cost &lt; kInfinity</code></span>
<span class="codeline" id="line-309"><code>   REQUIRES: nodes[0..pos] satisfies that "ZopfliNode array invariant". */</code></span>
<span class="codeline" id="line-310"><code>func computeDistanceShortcut(block_start uint, pos uint, max_backward_limit uint, gap uint, nodes []zopfliNode) uint32 {</code></span>
<span class="codeline" id="line-311"><code>	var clen uint = uint(zopfliNodeCopyLength(&amp;nodes[pos]))</code></span>
<span class="codeline" id="line-312"><code>	var ilen uint = uint(nodes[pos].dcode_insert_length &amp; 0x7FFFFFF)</code></span>
<span class="codeline" id="line-313"><code>	var dist uint = uint(zopfliNodeCopyDistance(&amp;nodes[pos]))</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>	/* Since |block_start + pos| is the end position of the command, the copy part</code></span>
<span class="codeline" id="line-316"><code>	   starts from |block_start + pos - clen|. Distances that are greater than</code></span>
<span class="codeline" id="line-317"><code>	   this or greater than |max_backward_limit| + |gap| are static dictionary</code></span>
<span class="codeline" id="line-318"><code>	   references, and do not update the last distances.</code></span>
<span class="codeline" id="line-319"><code>	   Also distance code 0 (last distance) does not update the last distances. */</code></span>
<span class="codeline" id="line-320"><code>	if pos == 0 {</code></span>
<span class="codeline" id="line-321"><code>		return 0</code></span>
<span class="codeline" id="line-322"><code>	} else if dist+clen &lt;= block_start+pos+gap &amp;&amp; dist &lt;= max_backward_limit+gap &amp;&amp; zopfliNodeDistanceCode(&amp;nodes[pos]) &gt; 0 {</code></span>
<span class="codeline" id="line-323"><code>		return uint32(pos)</code></span>
<span class="codeline" id="line-324"><code>	} else {</code></span>
<span class="codeline" id="line-325"><code>		return nodes[pos-clen-ilen].u.shortcut</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>/* Fills in dist_cache[0..3] with the last four distances (as defined by</code></span>
<span class="codeline" id="line-330"><code>   Section 4. of the Spec) that would be used at (block_start + pos) if we</code></span>
<span class="codeline" id="line-331"><code>   used the shortest path of commands from block_start, computed from</code></span>
<span class="codeline" id="line-332"><code>   nodes[0..pos]. The last four distances at block_start are in</code></span>
<span class="codeline" id="line-333"><code>   starting_dist_cache[0..3].</code></span>
<span class="codeline" id="line-334"><code>   REQUIRES: nodes[pos].cost &lt; kInfinity</code></span>
<span class="codeline" id="line-335"><code>   REQUIRES: nodes[0..pos] satisfies that "ZopfliNode array invariant". */</code></span>
<span class="codeline" id="line-336"><code>func computeDistanceCache(pos uint, starting_dist_cache []int, nodes []zopfliNode, dist_cache []int) {</code></span>
<span class="codeline" id="line-337"><code>	var idx int = 0</code></span>
<span class="codeline" id="line-338"><code>	var p uint = uint(nodes[pos].u.shortcut)</code></span>
<span class="codeline" id="line-339"><code>	for idx &lt; 4 &amp;&amp; p &gt; 0 {</code></span>
<span class="codeline" id="line-340"><code>		var ilen uint = uint(nodes[p].dcode_insert_length &amp; 0x7FFFFFF)</code></span>
<span class="codeline" id="line-341"><code>		var clen uint = uint(zopfliNodeCopyLength(&amp;nodes[p]))</code></span>
<span class="codeline" id="line-342"><code>		var dist uint = uint(zopfliNodeCopyDistance(&amp;nodes[p]))</code></span>
<span class="codeline" id="line-343"><code>		dist_cache[idx] = int(dist)</code></span>
<span class="codeline" id="line-344"><code>		idx++</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>		/* Because of prerequisite, p &gt;= clen + ilen &gt;= 2. */</code></span>
<span class="codeline" id="line-347"><code>		p = uint(nodes[p-clen-ilen].u.shortcut)</code></span>
<span class="codeline" id="line-348"><code>	}</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>	for ; idx &lt; 4; idx++ {</code></span>
<span class="codeline" id="line-351"><code>		dist_cache[idx] = starting_dist_cache[0]</code></span>
<span class="codeline" id="line-352"><code>		starting_dist_cache = starting_dist_cache[1:]</code></span>
<span class="codeline" id="line-353"><code>	}</code></span>
<span class="codeline" id="line-354"><code>}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>/* Maintains "ZopfliNode array invariant" and pushes node to the queue, if it</code></span>
<span class="codeline" id="line-357"><code>   is eligible. */</code></span>
<span class="codeline" id="line-358"><code>func evaluateNode(block_start uint, pos uint, max_backward_limit uint, gap uint, starting_dist_cache []int, model *zopfliCostModel, queue *startPosQueue, nodes []zopfliNode) {</code></span>
<span class="codeline" id="line-359"><code>	/* Save cost, because ComputeDistanceCache invalidates it. */</code></span>
<span class="codeline" id="line-360"><code>	var node_cost float32 = nodes[pos].u.cost</code></span>
<span class="codeline" id="line-361"><code>	nodes[pos].u.shortcut = computeDistanceShortcut(block_start, pos, max_backward_limit, gap, nodes)</code></span>
<span class="codeline" id="line-362"><code>	if node_cost &lt;= zopfliCostModelGetLiteralCosts(model, 0, pos) {</code></span>
<span class="codeline" id="line-363"><code>		var posdata posData</code></span>
<span class="codeline" id="line-364"><code>		posdata.pos = pos</code></span>
<span class="codeline" id="line-365"><code>		posdata.cost = node_cost</code></span>
<span class="codeline" id="line-366"><code>		posdata.costdiff = node_cost - zopfliCostModelGetLiteralCosts(model, 0, pos)</code></span>
<span class="codeline" id="line-367"><code>		computeDistanceCache(pos, starting_dist_cache, nodes, posdata.distance_cache[:])</code></span>
<span class="codeline" id="line-368"><code>		startPosQueuePush(queue, &amp;posdata)</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>/* Returns longest copy length. */</code></span>
<span class="codeline" id="line-373"><code>func updateNodes(num_bytes uint, block_start uint, pos uint, ringbuffer []byte, ringbuffer_mask uint, params *encoderParams, max_backward_limit uint, starting_dist_cache []int, num_matches uint, matches []backwardMatch, model *zopfliCostModel, queue *startPosQueue, nodes []zopfliNode) uint {</code></span>
<span class="codeline" id="line-374"><code>	var cur_ix uint = block_start + pos</code></span>
<span class="codeline" id="line-375"><code>	var cur_ix_masked uint = cur_ix &amp; ringbuffer_mask</code></span>
<span class="codeline" id="line-376"><code>	var max_distance uint = brotli_min_size_t(cur_ix, max_backward_limit)</code></span>
<span class="codeline" id="line-377"><code>	var max_len uint = num_bytes - pos</code></span>
<span class="codeline" id="line-378"><code>	var max_zopfli_len uint = maxZopfliLen(params)</code></span>
<span class="codeline" id="line-379"><code>	var max_iters uint = maxZopfliCandidates(params)</code></span>
<span class="codeline" id="line-380"><code>	var min_len uint</code></span>
<span class="codeline" id="line-381"><code>	var result uint = 0</code></span>
<span class="codeline" id="line-382"><code>	var k uint</code></span>
<span class="codeline" id="line-383"><code>	var gap uint = 0</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	evaluateNode(block_start, pos, max_backward_limit, gap, starting_dist_cache, model, queue, nodes)</code></span>
<span class="codeline" id="line-386"><code>	{</code></span>
<span class="codeline" id="line-387"><code>		var posdata *posData = startPosQueueAt(queue, 0)</code></span>
<span class="codeline" id="line-388"><code>		var min_cost float32 = (posdata.cost + zopfliCostModelGetMinCostCmd(model) + zopfliCostModelGetLiteralCosts(model, posdata.pos, pos))</code></span>
<span class="codeline" id="line-389"><code>		min_len = computeMinimumCopyLength(min_cost, nodes, num_bytes, pos)</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code></code></span>
<span class="codeline" id="line-392"><code>	/* Go over the command starting positions in order of increasing cost</code></span>
<span class="codeline" id="line-393"><code>	   difference. */</code></span>
<span class="codeline" id="line-394"><code>	for k = 0; k &lt; max_iters &amp;&amp; k &lt; startPosQueueSize(queue); k++ {</code></span>
<span class="codeline" id="line-395"><code>		var posdata *posData = startPosQueueAt(queue, k)</code></span>
<span class="codeline" id="line-396"><code>		var start uint = posdata.pos</code></span>
<span class="codeline" id="line-397"><code>		var inscode uint16 = getInsertLengthCode(pos - start)</code></span>
<span class="codeline" id="line-398"><code>		var start_costdiff float32 = posdata.costdiff</code></span>
<span class="codeline" id="line-399"><code>		var base_cost float32 = start_costdiff + float32(getInsertExtra(inscode)) + zopfliCostModelGetLiteralCosts(model, 0, pos)</code></span>
<span class="codeline" id="line-400"><code>		var best_len uint = min_len - 1</code></span>
<span class="codeline" id="line-401"><code>		var j uint = 0</code></span>
<span class="codeline" id="line-402"><code>		/* Look for last distance matches using the distance cache from this</code></span>
<span class="codeline" id="line-403"><code>		   starting position. */</code></span>
<span class="codeline" id="line-404"><code>		for ; j &lt; numDistanceShortCodes &amp;&amp; best_len &lt; max_len; j++ {</code></span>
<span class="codeline" id="line-405"><code>			var idx uint = uint(kDistanceCacheIndex[j])</code></span>
<span class="codeline" id="line-406"><code>			var backward uint = uint(posdata.distance_cache[idx] + kDistanceCacheOffset[j])</code></span>
<span class="codeline" id="line-407"><code>			var prev_ix uint = cur_ix - backward</code></span>
<span class="codeline" id="line-408"><code>			var len uint = 0</code></span>
<span class="codeline" id="line-409"><code>			var continuation byte = ringbuffer[cur_ix_masked+best_len]</code></span>
<span class="codeline" id="line-410"><code>			if cur_ix_masked+best_len &gt; ringbuffer_mask {</code></span>
<span class="codeline" id="line-411"><code>				break</code></span>
<span class="codeline" id="line-412"><code>			}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>			if backward &gt; max_distance+gap {</code></span>
<span class="codeline" id="line-415"><code>				/* Word dictionary -&gt; ignore. */</code></span>
<span class="codeline" id="line-416"><code>				continue</code></span>
<span class="codeline" id="line-417"><code>			}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>			if backward &lt;= max_distance {</code></span>
<span class="codeline" id="line-420"><code>				/* Regular backward reference. */</code></span>
<span class="codeline" id="line-421"><code>				if prev_ix &gt;= cur_ix {</code></span>
<span class="codeline" id="line-422"><code>					continue</code></span>
<span class="codeline" id="line-423"><code>				}</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>				prev_ix &amp;= ringbuffer_mask</code></span>
<span class="codeline" id="line-426"><code>				if prev_ix+best_len &gt; ringbuffer_mask || continuation != ringbuffer[prev_ix+best_len] {</code></span>
<span class="codeline" id="line-427"><code>					continue</code></span>
<span class="codeline" id="line-428"><code>				}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>				len = findMatchLengthWithLimit(ringbuffer[prev_ix:], ringbuffer[cur_ix_masked:], max_len)</code></span>
<span class="codeline" id="line-431"><code>			} else {</code></span>
<span class="codeline" id="line-432"><code>				continue</code></span>
<span class="codeline" id="line-433"><code>			}</code></span>
<span class="codeline" id="line-434"><code>			{</code></span>
<span class="codeline" id="line-435"><code>				var dist_cost float32 = base_cost + zopfliCostModelGetDistanceCost(model, j)</code></span>
<span class="codeline" id="line-436"><code>				var l uint</code></span>
<span class="codeline" id="line-437"><code>				for l = best_len + 1; l &lt;= len; l++ {</code></span>
<span class="codeline" id="line-438"><code>					var copycode uint16 = getCopyLengthCode(l)</code></span>
<span class="codeline" id="line-439"><code>					var cmdcode uint16 = combineLengthCodes(inscode, copycode, j == 0)</code></span>
<span class="codeline" id="line-440"><code>					var tmp float32</code></span>
<span class="codeline" id="line-441"><code>					if cmdcode &lt; 128 {</code></span>
<span class="codeline" id="line-442"><code>						tmp = base_cost</code></span>
<span class="codeline" id="line-443"><code>					} else {</code></span>
<span class="codeline" id="line-444"><code>						tmp = dist_cost</code></span>
<span class="codeline" id="line-445"><code>					}</code></span>
<span class="codeline" id="line-446"><code>					var cost float32 = tmp + float32(getCopyExtra(copycode)) + zopfliCostModelGetCommandCost(model, cmdcode)</code></span>
<span class="codeline" id="line-447"><code>					if cost &lt; nodes[pos+l].u.cost {</code></span>
<span class="codeline" id="line-448"><code>						updateZopfliNode(nodes, pos, start, l, l, backward, j+1, cost)</code></span>
<span class="codeline" id="line-449"><code>						result = brotli_max_size_t(result, l)</code></span>
<span class="codeline" id="line-450"><code>					}</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>					best_len = l</code></span>
<span class="codeline" id="line-453"><code>				}</code></span>
<span class="codeline" id="line-454"><code>			}</code></span>
<span class="codeline" id="line-455"><code>		}</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>		/* At higher iterations look only for new last distance matches, since</code></span>
<span class="codeline" id="line-458"><code>		   looking only for new command start positions with the same distances</code></span>
<span class="codeline" id="line-459"><code>		   does not help much. */</code></span>
<span class="codeline" id="line-460"><code>		if k &gt;= 2 {</code></span>
<span class="codeline" id="line-461"><code>			continue</code></span>
<span class="codeline" id="line-462"><code>		}</code></span>
<span class="codeline" id="line-463"><code>		{</code></span>
<span class="codeline" id="line-464"><code>			/* Loop through all possible copy lengths at this position. */</code></span>
<span class="codeline" id="line-465"><code>			var len uint = min_len</code></span>
<span class="codeline" id="line-466"><code>			for j = 0; j &lt; num_matches; j++ {</code></span>
<span class="codeline" id="line-467"><code>				var match backwardMatch = matches[j]</code></span>
<span class="codeline" id="line-468"><code>				var dist uint = uint(match.distance)</code></span>
<span class="codeline" id="line-469"><code>				var is_dictionary_match bool = (dist &gt; max_distance+gap)</code></span>
<span class="codeline" id="line-470"><code>				var dist_code uint = dist + numDistanceShortCodes - 1</code></span>
<span class="codeline" id="line-471"><code>				var dist_symbol uint16</code></span>
<span class="codeline" id="line-472"><code>				var distextra uint32</code></span>
<span class="codeline" id="line-473"><code>				var distnumextra uint32</code></span>
<span class="codeline" id="line-474"><code>				var dist_cost float32</code></span>
<span class="codeline" id="line-475"><code>				var max_match_len uint</code></span>
<span class="codeline" id="line-476"><code>				/* We already tried all possible last distance matches, so we can use</code></span>
<span class="codeline" id="line-477"><code>				   normal distance code here. */</code></span>
<span class="codeline" id="line-478"><code>				prefixEncodeCopyDistance(dist_code, uint(params.dist.num_direct_distance_codes), uint(params.dist.distance_postfix_bits), &amp;dist_symbol, &amp;distextra)</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>				distnumextra = uint32(dist_symbol) &gt;&gt; 10</code></span>
<span class="codeline" id="line-481"><code>				dist_cost = base_cost + float32(distnumextra) + zopfliCostModelGetDistanceCost(model, uint(dist_symbol)&amp;0x3FF)</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>				/* Try all copy lengths up until the maximum copy length corresponding</code></span>
<span class="codeline" id="line-484"><code>				   to this distance. If the distance refers to the static dictionary, or</code></span>
<span class="codeline" id="line-485"><code>				   the maximum length is long enough, try only one maximum length. */</code></span>
<span class="codeline" id="line-486"><code>				max_match_len = backwardMatchLength(&amp;match)</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>				if len &lt; max_match_len &amp;&amp; (is_dictionary_match || max_match_len &gt; max_zopfli_len) {</code></span>
<span class="codeline" id="line-489"><code>					len = max_match_len</code></span>
<span class="codeline" id="line-490"><code>				}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>				for ; len &lt;= max_match_len; len++ {</code></span>
<span class="codeline" id="line-493"><code>					var len_code uint</code></span>
<span class="codeline" id="line-494"><code>					if is_dictionary_match {</code></span>
<span class="codeline" id="line-495"><code>						len_code = backwardMatchLengthCode(&amp;match)</code></span>
<span class="codeline" id="line-496"><code>					} else {</code></span>
<span class="codeline" id="line-497"><code>						len_code = len</code></span>
<span class="codeline" id="line-498"><code>					}</code></span>
<span class="codeline" id="line-499"><code>					var copycode uint16 = getCopyLengthCode(len_code)</code></span>
<span class="codeline" id="line-500"><code>					var cmdcode uint16 = combineLengthCodes(inscode, copycode, false)</code></span>
<span class="codeline" id="line-501"><code>					var cost float32 = dist_cost + float32(getCopyExtra(copycode)) + zopfliCostModelGetCommandCost(model, cmdcode)</code></span>
<span class="codeline" id="line-502"><code>					if cost &lt; nodes[pos+len].u.cost {</code></span>
<span class="codeline" id="line-503"><code>						updateZopfliNode(nodes, pos, start, uint(len), len_code, dist, 0, cost)</code></span>
<span class="codeline" id="line-504"><code>						if len &gt; result {</code></span>
<span class="codeline" id="line-505"><code>							result = len</code></span>
<span class="codeline" id="line-506"><code>						}</code></span>
<span class="codeline" id="line-507"><code>					}</code></span>
<span class="codeline" id="line-508"><code>				}</code></span>
<span class="codeline" id="line-509"><code>			}</code></span>
<span class="codeline" id="line-510"><code>		}</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	return result</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>func computeShortestPathFromNodes(num_bytes uint, nodes []zopfliNode) uint {</code></span>
<span class="codeline" id="line-517"><code>	var index uint = num_bytes</code></span>
<span class="codeline" id="line-518"><code>	var num_commands uint = 0</code></span>
<span class="codeline" id="line-519"><code>	for nodes[index].dcode_insert_length&amp;0x7FFFFFF == 0 &amp;&amp; nodes[index].length == 1 {</code></span>
<span class="codeline" id="line-520"><code>		index--</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code>	nodes[index].u.next = math.MaxUint32</code></span>
<span class="codeline" id="line-523"><code>	for index != 0 {</code></span>
<span class="codeline" id="line-524"><code>		var len uint = uint(zopfliNodeCommandLength(&amp;nodes[index]))</code></span>
<span class="codeline" id="line-525"><code>		index -= uint(len)</code></span>
<span class="codeline" id="line-526"><code>		nodes[index].u.next = uint32(len)</code></span>
<span class="codeline" id="line-527"><code>		num_commands++</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>	return num_commands</code></span>
<span class="codeline" id="line-531"><code>}</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>/* REQUIRES: nodes != NULL and len(nodes) &gt;= num_bytes + 1 */</code></span>
<span class="codeline" id="line-534"><code>func zopfliCreateCommands(num_bytes uint, block_start uint, nodes []zopfliNode, dist_cache []int, last_insert_len *uint, params *encoderParams, commands *[]command, num_literals *uint) {</code></span>
<span class="codeline" id="line-535"><code>	var max_backward_limit uint = maxBackwardLimit(params.lgwin)</code></span>
<span class="codeline" id="line-536"><code>	var pos uint = 0</code></span>
<span class="codeline" id="line-537"><code>	var offset uint32 = nodes[0].u.next</code></span>
<span class="codeline" id="line-538"><code>	var i uint</code></span>
<span class="codeline" id="line-539"><code>	var gap uint = 0</code></span>
<span class="codeline" id="line-540"><code>	for i = 0; offset != math.MaxUint32; i++ {</code></span>
<span class="codeline" id="line-541"><code>		var next *zopfliNode = &amp;nodes[uint32(pos)+offset]</code></span>
<span class="codeline" id="line-542"><code>		var copy_length uint = uint(zopfliNodeCopyLength(next))</code></span>
<span class="codeline" id="line-543"><code>		var insert_length uint = uint(next.dcode_insert_length &amp; 0x7FFFFFF)</code></span>
<span class="codeline" id="line-544"><code>		pos += insert_length</code></span>
<span class="codeline" id="line-545"><code>		offset = next.u.next</code></span>
<span class="codeline" id="line-546"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-547"><code>			insert_length += *last_insert_len</code></span>
<span class="codeline" id="line-548"><code>			*last_insert_len = 0</code></span>
<span class="codeline" id="line-549"><code>		}</code></span>
<span class="codeline" id="line-550"><code>		{</code></span>
<span class="codeline" id="line-551"><code>			var distance uint = uint(zopfliNodeCopyDistance(next))</code></span>
<span class="codeline" id="line-552"><code>			var len_code uint = uint(zopfliNodeLengthCode(next))</code></span>
<span class="codeline" id="line-553"><code>			var max_distance uint = brotli_min_size_t(block_start+pos, max_backward_limit)</code></span>
<span class="codeline" id="line-554"><code>			var is_dictionary bool = (distance &gt; max_distance+gap)</code></span>
<span class="codeline" id="line-555"><code>			var dist_code uint = uint(zopfliNodeDistanceCode(next))</code></span>
<span class="codeline" id="line-556"><code>			*commands = append(*commands, makeCommand(&amp;params.dist, insert_length, copy_length, int(len_code)-int(copy_length), dist_code))</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>			if !is_dictionary &amp;&amp; dist_code &gt; 0 {</code></span>
<span class="codeline" id="line-559"><code>				dist_cache[3] = dist_cache[2]</code></span>
<span class="codeline" id="line-560"><code>				dist_cache[2] = dist_cache[1]</code></span>
<span class="codeline" id="line-561"><code>				dist_cache[1] = dist_cache[0]</code></span>
<span class="codeline" id="line-562"><code>				dist_cache[0] = int(distance)</code></span>
<span class="codeline" id="line-563"><code>			}</code></span>
<span class="codeline" id="line-564"><code>		}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>		*num_literals += insert_length</code></span>
<span class="codeline" id="line-567"><code>		pos += copy_length</code></span>
<span class="codeline" id="line-568"><code>	}</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>	*last_insert_len += num_bytes - pos</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>func zopfliIterate(num_bytes uint, position uint, ringbuffer []byte, ringbuffer_mask uint, params *encoderParams, gap uint, dist_cache []int, model *zopfliCostModel, num_matches []uint32, matches []backwardMatch, nodes []zopfliNode) uint {</code></span>
<span class="codeline" id="line-574"><code>	var max_backward_limit uint = maxBackwardLimit(params.lgwin)</code></span>
<span class="codeline" id="line-575"><code>	var max_zopfli_len uint = maxZopfliLen(params)</code></span>
<span class="codeline" id="line-576"><code>	var queue startPosQueue</code></span>
<span class="codeline" id="line-577"><code>	var cur_match_pos uint = 0</code></span>
<span class="codeline" id="line-578"><code>	var i uint</code></span>
<span class="codeline" id="line-579"><code>	nodes[0].length = 0</code></span>
<span class="codeline" id="line-580"><code>	nodes[0].u.cost = 0</code></span>
<span class="codeline" id="line-581"><code>	initStartPosQueue(&amp;queue)</code></span>
<span class="codeline" id="line-582"><code>	for i = 0; i+3 &lt; num_bytes; i++ {</code></span>
<span class="codeline" id="line-583"><code>		var skip uint = updateNodes(num_bytes, position, i, ringbuffer, ringbuffer_mask, params, max_backward_limit, dist_cache, uint(num_matches[i]), matches[cur_match_pos:], model, &amp;queue, nodes)</code></span>
<span class="codeline" id="line-584"><code>		if skip &lt; longCopyQuickStep {</code></span>
<span class="codeline" id="line-585"><code>			skip = 0</code></span>
<span class="codeline" id="line-586"><code>		}</code></span>
<span class="codeline" id="line-587"><code>		cur_match_pos += uint(num_matches[i])</code></span>
<span class="codeline" id="line-588"><code>		if num_matches[i] == 1 &amp;&amp; backwardMatchLength(&amp;matches[cur_match_pos-1]) &gt; max_zopfli_len {</code></span>
<span class="codeline" id="line-589"><code>			skip = brotli_max_size_t(backwardMatchLength(&amp;matches[cur_match_pos-1]), skip)</code></span>
<span class="codeline" id="line-590"><code>		}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>		if skip &gt; 1 {</code></span>
<span class="codeline" id="line-593"><code>			skip--</code></span>
<span class="codeline" id="line-594"><code>			for skip != 0 {</code></span>
<span class="codeline" id="line-595"><code>				i++</code></span>
<span class="codeline" id="line-596"><code>				if i+3 &gt;= num_bytes {</code></span>
<span class="codeline" id="line-597"><code>					break</code></span>
<span class="codeline" id="line-598"><code>				}</code></span>
<span class="codeline" id="line-599"><code>				evaluateNode(position, i, max_backward_limit, gap, dist_cache, model, &amp;queue, nodes)</code></span>
<span class="codeline" id="line-600"><code>				cur_match_pos += uint(num_matches[i])</code></span>
<span class="codeline" id="line-601"><code>				skip--</code></span>
<span class="codeline" id="line-602"><code>			}</code></span>
<span class="codeline" id="line-603"><code>		}</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code></code></span>
<span class="codeline" id="line-606"><code>	return computeShortestPathFromNodes(num_bytes, nodes)</code></span>
<span class="codeline" id="line-607"><code>}</code></span>
<span class="codeline" id="line-608"><code></code></span>
<span class="codeline" id="line-609"><code>/* Computes the shortest path of commands from position to at most</code></span>
<span class="codeline" id="line-610"><code>   position + num_bytes.</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>   On return, path-&gt;size() is the number of commands found and path[i] is the</code></span>
<span class="codeline" id="line-613"><code>   length of the i-th command (copy length plus insert length).</code></span>
<span class="codeline" id="line-614"><code>   Note that the sum of the lengths of all commands can be less than num_bytes.</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>   On return, the nodes[0..num_bytes] array will have the following</code></span>
<span class="codeline" id="line-617"><code>   "ZopfliNode array invariant":</code></span>
<span class="codeline" id="line-618"><code>   For each i in [1..num_bytes], if nodes[i].cost &lt; kInfinity, then</code></span>
<span class="codeline" id="line-619"><code>     (1) nodes[i].copy_length() &gt;= 2</code></span>
<span class="codeline" id="line-620"><code>     (2) nodes[i].command_length() &lt;= i and</code></span>
<span class="codeline" id="line-621"><code>     (3) nodes[i - nodes[i].command_length()].cost &lt; kInfinity</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code> REQUIRES: nodes != nil and len(nodes) &gt;= num_bytes + 1 */</code></span>
<span class="codeline" id="line-624"><code>func zopfliComputeShortestPath(num_bytes uint, position uint, ringbuffer []byte, ringbuffer_mask uint, params *encoderParams, dist_cache []int, hasher *h10, nodes []zopfliNode) uint {</code></span>
<span class="codeline" id="line-625"><code>	var max_backward_limit uint = maxBackwardLimit(params.lgwin)</code></span>
<span class="codeline" id="line-626"><code>	var max_zopfli_len uint = maxZopfliLen(params)</code></span>
<span class="codeline" id="line-627"><code>	var model zopfliCostModel</code></span>
<span class="codeline" id="line-628"><code>	var queue startPosQueue</code></span>
<span class="codeline" id="line-629"><code>	var matches [2 * (maxNumMatchesH10 + 64)]backwardMatch</code></span>
<span class="codeline" id="line-630"><code>	var store_end uint</code></span>
<span class="codeline" id="line-631"><code>	if num_bytes &gt;= hasher.StoreLookahead() {</code></span>
<span class="codeline" id="line-632"><code>		store_end = position + num_bytes - hasher.StoreLookahead() + 1</code></span>
<span class="codeline" id="line-633"><code>	} else {</code></span>
<span class="codeline" id="line-634"><code>		store_end = position</code></span>
<span class="codeline" id="line-635"><code>	}</code></span>
<span class="codeline" id="line-636"><code>	var i uint</code></span>
<span class="codeline" id="line-637"><code>	var gap uint = 0</code></span>
<span class="codeline" id="line-638"><code>	var lz_matches_offset uint = 0</code></span>
<span class="codeline" id="line-639"><code>	nodes[0].length = 0</code></span>
<span class="codeline" id="line-640"><code>	nodes[0].u.cost = 0</code></span>
<span class="codeline" id="line-641"><code>	initZopfliCostModel(&amp;model, &amp;params.dist, num_bytes)</code></span>
<span class="codeline" id="line-642"><code>	zopfliCostModelSetFromLiteralCosts(&amp;model, position, ringbuffer, ringbuffer_mask)</code></span>
<span class="codeline" id="line-643"><code>	initStartPosQueue(&amp;queue)</code></span>
<span class="codeline" id="line-644"><code>	for i = 0; i+hasher.HashTypeLength()-1 &lt; num_bytes; i++ {</code></span>
<span class="codeline" id="line-645"><code>		var pos uint = position + i</code></span>
<span class="codeline" id="line-646"><code>		var max_distance uint = brotli_min_size_t(pos, max_backward_limit)</code></span>
<span class="codeline" id="line-647"><code>		var skip uint</code></span>
<span class="codeline" id="line-648"><code>		var num_matches uint</code></span>
<span class="codeline" id="line-649"><code>		num_matches = findAllMatchesH10(hasher, &amp;params.dictionary, ringbuffer, ringbuffer_mask, pos, num_bytes-i, max_distance, gap, params, matches[lz_matches_offset:])</code></span>
<span class="codeline" id="line-650"><code>		if num_matches &gt; 0 &amp;&amp; backwardMatchLength(&amp;matches[num_matches-1]) &gt; max_zopfli_len {</code></span>
<span class="codeline" id="line-651"><code>			matches[0] = matches[num_matches-1]</code></span>
<span class="codeline" id="line-652"><code>			num_matches = 1</code></span>
<span class="codeline" id="line-653"><code>		}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>		skip = updateNodes(num_bytes, position, i, ringbuffer, ringbuffer_mask, params, max_backward_limit, dist_cache, num_matches, matches[:], &amp;model, &amp;queue, nodes)</code></span>
<span class="codeline" id="line-656"><code>		if skip &lt; longCopyQuickStep {</code></span>
<span class="codeline" id="line-657"><code>			skip = 0</code></span>
<span class="codeline" id="line-658"><code>		}</code></span>
<span class="codeline" id="line-659"><code>		if num_matches == 1 &amp;&amp; backwardMatchLength(&amp;matches[0]) &gt; max_zopfli_len {</code></span>
<span class="codeline" id="line-660"><code>			skip = brotli_max_size_t(backwardMatchLength(&amp;matches[0]), skip)</code></span>
<span class="codeline" id="line-661"><code>		}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>		if skip &gt; 1 {</code></span>
<span class="codeline" id="line-664"><code>			/* Add the tail of the copy to the hasher. */</code></span>
<span class="codeline" id="line-665"><code>			hasher.StoreRange(ringbuffer, ringbuffer_mask, pos+1, brotli_min_size_t(pos+skip, store_end))</code></span>
<span class="codeline" id="line-666"><code></code></span>
<span class="codeline" id="line-667"><code>			skip--</code></span>
<span class="codeline" id="line-668"><code>			for skip != 0 {</code></span>
<span class="codeline" id="line-669"><code>				i++</code></span>
<span class="codeline" id="line-670"><code>				if i+hasher.HashTypeLength()-1 &gt;= num_bytes {</code></span>
<span class="codeline" id="line-671"><code>					break</code></span>
<span class="codeline" id="line-672"><code>				}</code></span>
<span class="codeline" id="line-673"><code>				evaluateNode(position, i, max_backward_limit, gap, dist_cache, &amp;model, &amp;queue, nodes)</code></span>
<span class="codeline" id="line-674"><code>				skip--</code></span>
<span class="codeline" id="line-675"><code>			}</code></span>
<span class="codeline" id="line-676"><code>		}</code></span>
<span class="codeline" id="line-677"><code>	}</code></span>
<span class="codeline" id="line-678"><code></code></span>
<span class="codeline" id="line-679"><code>	cleanupZopfliCostModel(&amp;model)</code></span>
<span class="codeline" id="line-680"><code>	return computeShortestPathFromNodes(num_bytes, nodes)</code></span>
<span class="codeline" id="line-681"><code>}</code></span>
<span class="codeline" id="line-682"><code></code></span>
<span class="codeline" id="line-683"><code>func createZopfliBackwardReferences(num_bytes uint, position uint, ringbuffer []byte, ringbuffer_mask uint, params *encoderParams, hasher *h10, dist_cache []int, last_insert_len *uint, commands *[]command, num_literals *uint) {</code></span>
<span class="codeline" id="line-684"><code>	var nodes []zopfliNode</code></span>
<span class="codeline" id="line-685"><code>	nodes = make([]zopfliNode, (num_bytes + 1))</code></span>
<span class="codeline" id="line-686"><code>	initZopfliNodes(nodes, num_bytes+1)</code></span>
<span class="codeline" id="line-687"><code>	zopfliComputeShortestPath(num_bytes, position, ringbuffer, ringbuffer_mask, params, dist_cache, hasher, nodes)</code></span>
<span class="codeline" id="line-688"><code>	zopfliCreateCommands(num_bytes, position, nodes, dist_cache, last_insert_len, params, commands, num_literals)</code></span>
<span class="codeline" id="line-689"><code>	nodes = nil</code></span>
<span class="codeline" id="line-690"><code>}</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>func createHqZopfliBackwardReferences(num_bytes uint, position uint, ringbuffer []byte, ringbuffer_mask uint, params *encoderParams, hasher hasherHandle, dist_cache []int, last_insert_len *uint, commands *[]command, num_literals *uint) {</code></span>
<span class="codeline" id="line-693"><code>	var max_backward_limit uint = maxBackwardLimit(params.lgwin)</code></span>
<span class="codeline" id="line-694"><code>	var num_matches []uint32 = make([]uint32, num_bytes)</code></span>
<span class="codeline" id="line-695"><code>	var matches_size uint = 4 * num_bytes</code></span>
<span class="codeline" id="line-696"><code>	var store_end uint</code></span>
<span class="codeline" id="line-697"><code>	if num_bytes &gt;= hasher.StoreLookahead() {</code></span>
<span class="codeline" id="line-698"><code>		store_end = position + num_bytes - hasher.StoreLookahead() + 1</code></span>
<span class="codeline" id="line-699"><code>	} else {</code></span>
<span class="codeline" id="line-700"><code>		store_end = position</code></span>
<span class="codeline" id="line-701"><code>	}</code></span>
<span class="codeline" id="line-702"><code>	var cur_match_pos uint = 0</code></span>
<span class="codeline" id="line-703"><code>	var i uint</code></span>
<span class="codeline" id="line-704"><code>	var orig_num_literals uint</code></span>
<span class="codeline" id="line-705"><code>	var orig_last_insert_len uint</code></span>
<span class="codeline" id="line-706"><code>	var orig_dist_cache [4]int</code></span>
<span class="codeline" id="line-707"><code>	var orig_num_commands int</code></span>
<span class="codeline" id="line-708"><code>	var model zopfliCostModel</code></span>
<span class="codeline" id="line-709"><code>	var nodes []zopfliNode</code></span>
<span class="codeline" id="line-710"><code>	var matches []backwardMatch = make([]backwardMatch, matches_size)</code></span>
<span class="codeline" id="line-711"><code>	var gap uint = 0</code></span>
<span class="codeline" id="line-712"><code>	var shadow_matches uint = 0</code></span>
<span class="codeline" id="line-713"><code>	var new_array []backwardMatch</code></span>
<span class="codeline" id="line-714"><code>	for i = 0; i+hasher.HashTypeLength()-1 &lt; num_bytes; i++ {</code></span>
<span class="codeline" id="line-715"><code>		var pos uint = position + i</code></span>
<span class="codeline" id="line-716"><code>		var max_distance uint = brotli_min_size_t(pos, max_backward_limit)</code></span>
<span class="codeline" id="line-717"><code>		var max_length uint = num_bytes - i</code></span>
<span class="codeline" id="line-718"><code>		var num_found_matches uint</code></span>
<span class="codeline" id="line-719"><code>		var cur_match_end uint</code></span>
<span class="codeline" id="line-720"><code>		var j uint</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>		/* Ensure that we have enough free slots. */</code></span>
<span class="codeline" id="line-723"><code>		if matches_size &lt; cur_match_pos+maxNumMatchesH10+shadow_matches {</code></span>
<span class="codeline" id="line-724"><code>			var new_size uint = matches_size</code></span>
<span class="codeline" id="line-725"><code>			if new_size == 0 {</code></span>
<span class="codeline" id="line-726"><code>				new_size = cur_match_pos + maxNumMatchesH10 + shadow_matches</code></span>
<span class="codeline" id="line-727"><code>			}</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>			for new_size &lt; cur_match_pos+maxNumMatchesH10+shadow_matches {</code></span>
<span class="codeline" id="line-730"><code>				new_size *= 2</code></span>
<span class="codeline" id="line-731"><code>			}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>			new_array = make([]backwardMatch, new_size)</code></span>
<span class="codeline" id="line-734"><code>			if matches_size != 0 {</code></span>
<span class="codeline" id="line-735"><code>				copy(new_array, matches[:matches_size])</code></span>
<span class="codeline" id="line-736"><code>			}</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>			matches = new_array</code></span>
<span class="codeline" id="line-739"><code>			matches_size = new_size</code></span>
<span class="codeline" id="line-740"><code>		}</code></span>
<span class="codeline" id="line-741"><code></code></span>
<span class="codeline" id="line-742"><code>		num_found_matches = findAllMatchesH10(hasher.(*h10), &amp;params.dictionary, ringbuffer, ringbuffer_mask, pos, max_length, max_distance, gap, params, matches[cur_match_pos+shadow_matches:])</code></span>
<span class="codeline" id="line-743"><code>		cur_match_end = cur_match_pos + num_found_matches</code></span>
<span class="codeline" id="line-744"><code>		for j = cur_match_pos; j+1 &lt; cur_match_end; j++ {</code></span>
<span class="codeline" id="line-745"><code>			assert(backwardMatchLength(&amp;matches[j]) &lt;= backwardMatchLength(&amp;matches[j+1]))</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>		num_matches[i] = uint32(num_found_matches)</code></span>
<span class="codeline" id="line-749"><code>		if num_found_matches &gt; 0 {</code></span>
<span class="codeline" id="line-750"><code>			var match_len uint = backwardMatchLength(&amp;matches[cur_match_end-1])</code></span>
<span class="codeline" id="line-751"><code>			if match_len &gt; maxZopfliLenQuality11 {</code></span>
<span class="codeline" id="line-752"><code>				var skip uint = match_len - 1</code></span>
<span class="codeline" id="line-753"><code>				matches[cur_match_pos] = matches[cur_match_end-1]</code></span>
<span class="codeline" id="line-754"><code>				cur_match_pos++</code></span>
<span class="codeline" id="line-755"><code>				num_matches[i] = 1</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>				/* Add the tail of the copy to the hasher. */</code></span>
<span class="codeline" id="line-758"><code>				hasher.StoreRange(ringbuffer, ringbuffer_mask, pos+1, brotli_min_size_t(pos+match_len, store_end))</code></span>
<span class="codeline" id="line-759"><code>				var pos uint = i</code></span>
<span class="codeline" id="line-760"><code>				for i := 0; i &lt; int(skip); i++ {</code></span>
<span class="codeline" id="line-761"><code>					num_matches[pos+1:][i] = 0</code></span>
<span class="codeline" id="line-762"><code>				}</code></span>
<span class="codeline" id="line-763"><code>				i += skip</code></span>
<span class="codeline" id="line-764"><code>			} else {</code></span>
<span class="codeline" id="line-765"><code>				cur_match_pos = cur_match_end</code></span>
<span class="codeline" id="line-766"><code>			}</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code>	}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	orig_num_literals = *num_literals</code></span>
<span class="codeline" id="line-771"><code>	orig_last_insert_len = *last_insert_len</code></span>
<span class="codeline" id="line-772"><code>	copy(orig_dist_cache[:], dist_cache[:4])</code></span>
<span class="codeline" id="line-773"><code>	orig_num_commands = len(*commands)</code></span>
<span class="codeline" id="line-774"><code>	nodes = make([]zopfliNode, (num_bytes + 1))</code></span>
<span class="codeline" id="line-775"><code>	initZopfliCostModel(&amp;model, &amp;params.dist, num_bytes)</code></span>
<span class="codeline" id="line-776"><code>	for i = 0; i &lt; 2; i++ {</code></span>
<span class="codeline" id="line-777"><code>		initZopfliNodes(nodes, num_bytes+1)</code></span>
<span class="codeline" id="line-778"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-779"><code>			zopfliCostModelSetFromLiteralCosts(&amp;model, position, ringbuffer, ringbuffer_mask)</code></span>
<span class="codeline" id="line-780"><code>		} else {</code></span>
<span class="codeline" id="line-781"><code>			zopfliCostModelSetFromCommands(&amp;model, position, ringbuffer, ringbuffer_mask, (*commands)[orig_num_commands:], orig_last_insert_len)</code></span>
<span class="codeline" id="line-782"><code>		}</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>		*commands = (*commands)[:orig_num_commands]</code></span>
<span class="codeline" id="line-785"><code>		*num_literals = orig_num_literals</code></span>
<span class="codeline" id="line-786"><code>		*last_insert_len = orig_last_insert_len</code></span>
<span class="codeline" id="line-787"><code>		copy(dist_cache, orig_dist_cache[:4])</code></span>
<span class="codeline" id="line-788"><code>		zopfliIterate(num_bytes, position, ringbuffer, ringbuffer_mask, params, gap, dist_cache, &amp;model, num_matches, matches, nodes)</code></span>
<span class="codeline" id="line-789"><code>		zopfliCreateCommands(num_bytes, position, nodes, dist_cache, last_insert_len, params, commands, num_literals)</code></span>
<span class="codeline" id="line-790"><code>	}</code></span>
<span class="codeline" id="line-791"><code></code></span>
<span class="codeline" id="line-792"><code>	cleanupZopfliCostModel(&amp;model)</code></span>
<span class="codeline" id="line-793"><code>	nodes = nil</code></span>
<span class="codeline" id="line-794"><code>	matches = nil</code></span>
<span class="codeline" id="line-795"><code>	num_matches = nil</code></span>
<span class="codeline" id="line-796"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>