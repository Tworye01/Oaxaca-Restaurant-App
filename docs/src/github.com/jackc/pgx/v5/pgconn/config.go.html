<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: config.go in package github.com/jackc/pgx/v5/pgconn</title>
<link href="../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	config.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../pkg/github.com/jackc/pgx/v5/pgconn.html">github.com/jackc/pgx/v5/pgconn</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package pgconn</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"context"</code></span>
<span class="codeline" id="line-5"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-6"><code>	"crypto/x509"</code></span>
<span class="codeline" id="line-7"><code>	"encoding/pem"</code></span>
<span class="codeline" id="line-8"><code>	"errors"</code></span>
<span class="codeline" id="line-9"><code>	"fmt"</code></span>
<span class="codeline" id="line-10"><code>	"io"</code></span>
<span class="codeline" id="line-11"><code>	"math"</code></span>
<span class="codeline" id="line-12"><code>	"net"</code></span>
<span class="codeline" id="line-13"><code>	"net/url"</code></span>
<span class="codeline" id="line-14"><code>	"os"</code></span>
<span class="codeline" id="line-15"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-16"><code>	"strconv"</code></span>
<span class="codeline" id="line-17"><code>	"strings"</code></span>
<span class="codeline" id="line-18"><code>	"time"</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>	"github.com/jackc/pgpassfile"</code></span>
<span class="codeline" id="line-21"><code>	"github.com/jackc/pgservicefile"</code></span>
<span class="codeline" id="line-22"><code>	"github.com/jackc/pgx/v5/pgproto3"</code></span>
<span class="codeline" id="line-23"><code>)</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>type AfterConnectFunc func(ctx context.Context, pgconn *PgConn) error</code></span>
<span class="codeline" id="line-26"><code>type ValidateConnectFunc func(ctx context.Context, pgconn *PgConn) error</code></span>
<span class="codeline" id="line-27"><code>type GetSSLPasswordFunc func(ctx context.Context) string</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// Config is the settings used to establish a connection to a PostgreSQL server. It must be created by [ParseConfig]. A</code></span>
<span class="codeline" id="line-30"><code>// manually initialized Config will cause ConnectConfig to panic.</code></span>
<span class="codeline" id="line-31"><code>type Config struct {</code></span>
<span class="codeline" id="line-32"><code>	Host           string // host (e.g. localhost) or absolute path to unix domain socket directory (e.g. /private/tmp)</code></span>
<span class="codeline" id="line-33"><code>	Port           uint16</code></span>
<span class="codeline" id="line-34"><code>	Database       string</code></span>
<span class="codeline" id="line-35"><code>	User           string</code></span>
<span class="codeline" id="line-36"><code>	Password       string</code></span>
<span class="codeline" id="line-37"><code>	TLSConfig      *tls.Config // nil disables TLS</code></span>
<span class="codeline" id="line-38"><code>	ConnectTimeout time.Duration</code></span>
<span class="codeline" id="line-39"><code>	DialFunc       DialFunc   // e.g. net.Dialer.DialContext</code></span>
<span class="codeline" id="line-40"><code>	LookupFunc     LookupFunc // e.g. net.Resolver.LookupHost</code></span>
<span class="codeline" id="line-41"><code>	BuildFrontend  BuildFrontendFunc</code></span>
<span class="codeline" id="line-42"><code>	RuntimeParams  map[string]string // Run-time parameters to set on connection as session default values (e.g. search_path or application_name)</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>	KerberosSrvName string</code></span>
<span class="codeline" id="line-45"><code>	KerberosSpn     string</code></span>
<span class="codeline" id="line-46"><code>	Fallbacks       []*FallbackConfig</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>	// ValidateConnect is called during a connection attempt after a successful authentication with the PostgreSQL server.</code></span>
<span class="codeline" id="line-49"><code>	// It can be used to validate that the server is acceptable. If this returns an error the connection is closed and the next</code></span>
<span class="codeline" id="line-50"><code>	// fallback config is tried. This allows implementing high availability behavior such as libpq does with target_session_attrs.</code></span>
<span class="codeline" id="line-51"><code>	ValidateConnect ValidateConnectFunc</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>	// AfterConnect is called after ValidateConnect. It can be used to set up the connection (e.g. Set session variables</code></span>
<span class="codeline" id="line-54"><code>	// or prepare statements). If this returns an error the connection attempt fails.</code></span>
<span class="codeline" id="line-55"><code>	AfterConnect AfterConnectFunc</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>	// OnNotice is a callback function called when a notice response is received.</code></span>
<span class="codeline" id="line-58"><code>	OnNotice NoticeHandler</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	// OnNotification is a callback function called when a notification from the LISTEN/NOTIFY system is received.</code></span>
<span class="codeline" id="line-61"><code>	OnNotification NotificationHandler</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>	// OnPgError is a callback function called when a Postgres error is received by the server. The default handler will close</code></span>
<span class="codeline" id="line-64"><code>	// the connection on any FATAL errors. If you override this handler you should call the previously set handler or ensure</code></span>
<span class="codeline" id="line-65"><code>	// that you close on FATAL errors by returning false.</code></span>
<span class="codeline" id="line-66"><code>	OnPgError PgErrorHandler</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>	createdByParseConfig bool // Used to enforce created by ParseConfig rule.</code></span>
<span class="codeline" id="line-69"><code>}</code></span>
<span class="codeline" id="line-70"><code></code></span>
<span class="codeline" id="line-71"><code>// ParseConfigOptions contains options that control how a config is built such as GetSSLPassword.</code></span>
<span class="codeline" id="line-72"><code>type ParseConfigOptions struct {</code></span>
<span class="codeline" id="line-73"><code>	// GetSSLPassword gets the password to decrypt a SSL client certificate. This is analogous to the the libpq function</code></span>
<span class="codeline" id="line-74"><code>	// PQsetSSLKeyPassHook_OpenSSL.</code></span>
<span class="codeline" id="line-75"><code>	GetSSLPassword GetSSLPasswordFunc</code></span>
<span class="codeline" id="line-76"><code>}</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>// Copy returns a deep copy of the config that is safe to use and modify.</code></span>
<span class="codeline" id="line-79"><code>// The only exception is the TLSConfig field:</code></span>
<span class="codeline" id="line-80"><code>// according to the tls.Config docs it must not be modified after creation.</code></span>
<span class="codeline" id="line-81"><code>func (c *Config) Copy() *Config {</code></span>
<span class="codeline" id="line-82"><code>	newConf := new(Config)</code></span>
<span class="codeline" id="line-83"><code>	*newConf = *c</code></span>
<span class="codeline" id="line-84"><code>	if newConf.TLSConfig != nil {</code></span>
<span class="codeline" id="line-85"><code>		newConf.TLSConfig = c.TLSConfig.Clone()</code></span>
<span class="codeline" id="line-86"><code>	}</code></span>
<span class="codeline" id="line-87"><code>	if newConf.RuntimeParams != nil {</code></span>
<span class="codeline" id="line-88"><code>		newConf.RuntimeParams = make(map[string]string, len(c.RuntimeParams))</code></span>
<span class="codeline" id="line-89"><code>		for k, v := range c.RuntimeParams {</code></span>
<span class="codeline" id="line-90"><code>			newConf.RuntimeParams[k] = v</code></span>
<span class="codeline" id="line-91"><code>		}</code></span>
<span class="codeline" id="line-92"><code>	}</code></span>
<span class="codeline" id="line-93"><code>	if newConf.Fallbacks != nil {</code></span>
<span class="codeline" id="line-94"><code>		newConf.Fallbacks = make([]*FallbackConfig, len(c.Fallbacks))</code></span>
<span class="codeline" id="line-95"><code>		for i, fallback := range c.Fallbacks {</code></span>
<span class="codeline" id="line-96"><code>			newFallback := new(FallbackConfig)</code></span>
<span class="codeline" id="line-97"><code>			*newFallback = *fallback</code></span>
<span class="codeline" id="line-98"><code>			if newFallback.TLSConfig != nil {</code></span>
<span class="codeline" id="line-99"><code>				newFallback.TLSConfig = fallback.TLSConfig.Clone()</code></span>
<span class="codeline" id="line-100"><code>			}</code></span>
<span class="codeline" id="line-101"><code>			newConf.Fallbacks[i] = newFallback</code></span>
<span class="codeline" id="line-102"><code>		}</code></span>
<span class="codeline" id="line-103"><code>	}</code></span>
<span class="codeline" id="line-104"><code>	return newConf</code></span>
<span class="codeline" id="line-105"><code>}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>// FallbackConfig is additional settings to attempt a connection with when the primary Config fails to establish a</code></span>
<span class="codeline" id="line-108"><code>// network connection. It is used for TLS fallback such as sslmode=prefer and high availability (HA) connections.</code></span>
<span class="codeline" id="line-109"><code>type FallbackConfig struct {</code></span>
<span class="codeline" id="line-110"><code>	Host      string // host (e.g. localhost) or path to unix domain socket directory (e.g. /private/tmp)</code></span>
<span class="codeline" id="line-111"><code>	Port      uint16</code></span>
<span class="codeline" id="line-112"><code>	TLSConfig *tls.Config // nil disables TLS</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// isAbsolutePath checks if the provided value is an absolute path either</code></span>
<span class="codeline" id="line-116"><code>// beginning with a forward slash (as on Linux-based systems) or with a capital</code></span>
<span class="codeline" id="line-117"><code>// letter A-Z followed by a colon and a backslash, e.g., "C:\", (as on Windows).</code></span>
<span class="codeline" id="line-118"><code>func isAbsolutePath(path string) bool {</code></span>
<span class="codeline" id="line-119"><code>	isWindowsPath := func(p string) bool {</code></span>
<span class="codeline" id="line-120"><code>		if len(p) &lt; 3 {</code></span>
<span class="codeline" id="line-121"><code>			return false</code></span>
<span class="codeline" id="line-122"><code>		}</code></span>
<span class="codeline" id="line-123"><code>		drive := p[0]</code></span>
<span class="codeline" id="line-124"><code>		colon := p[1]</code></span>
<span class="codeline" id="line-125"><code>		backslash := p[2]</code></span>
<span class="codeline" id="line-126"><code>		if drive &gt;= 'A' &amp;&amp; drive &lt;= 'Z' &amp;&amp; colon == ':' &amp;&amp; backslash == '\\' {</code></span>
<span class="codeline" id="line-127"><code>			return true</code></span>
<span class="codeline" id="line-128"><code>		}</code></span>
<span class="codeline" id="line-129"><code>		return false</code></span>
<span class="codeline" id="line-130"><code>	}</code></span>
<span class="codeline" id="line-131"><code>	return strings.HasPrefix(path, "/") || isWindowsPath(path)</code></span>
<span class="codeline" id="line-132"><code>}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>// NetworkAddress converts a PostgreSQL host and port into network and address suitable for use with</code></span>
<span class="codeline" id="line-135"><code>// net.Dial.</code></span>
<span class="codeline" id="line-136"><code>func NetworkAddress(host string, port uint16) (network, address string) {</code></span>
<span class="codeline" id="line-137"><code>	if isAbsolutePath(host) {</code></span>
<span class="codeline" id="line-138"><code>		network = "unix"</code></span>
<span class="codeline" id="line-139"><code>		address = filepath.Join(host, ".s.PGSQL.") + strconv.FormatInt(int64(port), 10)</code></span>
<span class="codeline" id="line-140"><code>	} else {</code></span>
<span class="codeline" id="line-141"><code>		network = "tcp"</code></span>
<span class="codeline" id="line-142"><code>		address = net.JoinHostPort(host, strconv.Itoa(int(port)))</code></span>
<span class="codeline" id="line-143"><code>	}</code></span>
<span class="codeline" id="line-144"><code>	return network, address</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// ParseConfig builds a *Config from connString with similar behavior to the PostgreSQL standard C library libpq. It</code></span>
<span class="codeline" id="line-148"><code>// uses the same defaults as libpq (e.g. port=5432) and understands most PG* environment variables. ParseConfig closely</code></span>
<span class="codeline" id="line-149"><code>// matches the parsing behavior of libpq. connString may either be in URL format or keyword = value format (DSN style).</code></span>
<span class="codeline" id="line-150"><code>// See https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING for details. connString also may be</code></span>
<span class="codeline" id="line-151"><code>// empty to only read from the environment. If a password is not supplied it will attempt to read the .pgpass file.</code></span>
<span class="codeline" id="line-152"><code>//</code></span>
<span class="codeline" id="line-153"><code>//	# Example DSN</code></span>
<span class="codeline" id="line-154"><code>//	user=jack password=secret host=pg.example.com port=5432 dbname=mydb sslmode=verify-ca</code></span>
<span class="codeline" id="line-155"><code>//</code></span>
<span class="codeline" id="line-156"><code>//	# Example URL</code></span>
<span class="codeline" id="line-157"><code>//	postgres://jack:secret@pg.example.com:5432/mydb?sslmode=verify-ca</code></span>
<span class="codeline" id="line-158"><code>//</code></span>
<span class="codeline" id="line-159"><code>// The returned *Config may be modified. However, it is strongly recommended that any configuration that can be done</code></span>
<span class="codeline" id="line-160"><code>// through the connection string be done there. In particular the fields Host, Port, TLSConfig, and Fallbacks can be</code></span>
<span class="codeline" id="line-161"><code>// interdependent (e.g. TLSConfig needs knowledge of the host to validate the server certificate). These fields should</code></span>
<span class="codeline" id="line-162"><code>// not be modified individually. They should all be modified or all left unchanged.</code></span>
<span class="codeline" id="line-163"><code>//</code></span>
<span class="codeline" id="line-164"><code>// ParseConfig supports specifying multiple hosts in similar manner to libpq. Host and port may include comma separated</code></span>
<span class="codeline" id="line-165"><code>// values that will be tried in order. This can be used as part of a high availability system. See</code></span>
<span class="codeline" id="line-166"><code>// https://www.postgresql.org/docs/11/libpq-connect.html#LIBPQ-MULTIPLE-HOSTS for more information.</code></span>
<span class="codeline" id="line-167"><code>//</code></span>
<span class="codeline" id="line-168"><code>//	# Example URL</code></span>
<span class="codeline" id="line-169"><code>//	postgres://jack:secret@foo.example.com:5432,bar.example.com:5432/mydb</code></span>
<span class="codeline" id="line-170"><code>//</code></span>
<span class="codeline" id="line-171"><code>// ParseConfig currently recognizes the following environment variable and their parameter key word equivalents passed</code></span>
<span class="codeline" id="line-172"><code>// via database URL or DSN:</code></span>
<span class="codeline" id="line-173"><code>//</code></span>
<span class="codeline" id="line-174"><code>//	PGHOST</code></span>
<span class="codeline" id="line-175"><code>//	PGPORT</code></span>
<span class="codeline" id="line-176"><code>//	PGDATABASE</code></span>
<span class="codeline" id="line-177"><code>//	PGUSER</code></span>
<span class="codeline" id="line-178"><code>//	PGPASSWORD</code></span>
<span class="codeline" id="line-179"><code>//	PGPASSFILE</code></span>
<span class="codeline" id="line-180"><code>//	PGSERVICE</code></span>
<span class="codeline" id="line-181"><code>//	PGSERVICEFILE</code></span>
<span class="codeline" id="line-182"><code>//	PGSSLMODE</code></span>
<span class="codeline" id="line-183"><code>//	PGSSLCERT</code></span>
<span class="codeline" id="line-184"><code>//	PGSSLKEY</code></span>
<span class="codeline" id="line-185"><code>//	PGSSLROOTCERT</code></span>
<span class="codeline" id="line-186"><code>//	PGSSLPASSWORD</code></span>
<span class="codeline" id="line-187"><code>//	PGAPPNAME</code></span>
<span class="codeline" id="line-188"><code>//	PGCONNECT_TIMEOUT</code></span>
<span class="codeline" id="line-189"><code>//	PGTARGETSESSIONATTRS</code></span>
<span class="codeline" id="line-190"><code>//</code></span>
<span class="codeline" id="line-191"><code>// See http://www.postgresql.org/docs/11/static/libpq-envars.html for details on the meaning of environment variables.</code></span>
<span class="codeline" id="line-192"><code>//</code></span>
<span class="codeline" id="line-193"><code>// See https://www.postgresql.org/docs/11/libpq-connect.html#LIBPQ-PARAMKEYWORDS for parameter key word names. They are</code></span>
<span class="codeline" id="line-194"><code>// usually but not always the environment variable name downcased and without the "PG" prefix.</code></span>
<span class="codeline" id="line-195"><code>//</code></span>
<span class="codeline" id="line-196"><code>// Important Security Notes:</code></span>
<span class="codeline" id="line-197"><code>//</code></span>
<span class="codeline" id="line-198"><code>// ParseConfig tries to match libpq behavior with regard to PGSSLMODE. This includes defaulting to "prefer" behavior if</code></span>
<span class="codeline" id="line-199"><code>// not set.</code></span>
<span class="codeline" id="line-200"><code>//</code></span>
<span class="codeline" id="line-201"><code>// See http://www.postgresql.org/docs/11/static/libpq-ssl.html#LIBPQ-SSL-PROTECTION for details on what level of</code></span>
<span class="codeline" id="line-202"><code>// security each sslmode provides.</code></span>
<span class="codeline" id="line-203"><code>//</code></span>
<span class="codeline" id="line-204"><code>// The sslmode "prefer" (the default), sslmode "allow", and multiple hosts are implemented via the Fallbacks field of</code></span>
<span class="codeline" id="line-205"><code>// the Config struct. If TLSConfig is manually changed it will not affect the fallbacks. For example, in the case of</code></span>
<span class="codeline" id="line-206"><code>// sslmode "prefer" this means it will first try the main Config settings which use TLS, then it will try the fallback</code></span>
<span class="codeline" id="line-207"><code>// which does not use TLS. This can lead to an unexpected unencrypted connection if the main TLS config is manually</code></span>
<span class="codeline" id="line-208"><code>// changed later but the unencrypted fallback is present. Ensure there are no stale fallbacks when manually setting</code></span>
<span class="codeline" id="line-209"><code>// TLSConfig.</code></span>
<span class="codeline" id="line-210"><code>//</code></span>
<span class="codeline" id="line-211"><code>// Other known differences with libpq:</code></span>
<span class="codeline" id="line-212"><code>//</code></span>
<span class="codeline" id="line-213"><code>// When multiple hosts are specified, libpq allows them to have different passwords set via the .pgpass file. pgconn</code></span>
<span class="codeline" id="line-214"><code>// does not.</code></span>
<span class="codeline" id="line-215"><code>//</code></span>
<span class="codeline" id="line-216"><code>// In addition, ParseConfig accepts the following options:</code></span>
<span class="codeline" id="line-217"><code>//</code></span>
<span class="codeline" id="line-218"><code>//   - servicefile.</code></span>
<span class="codeline" id="line-219"><code>//     libpq only reads servicefile from the PGSERVICEFILE environment variable. ParseConfig accepts servicefile as a</code></span>
<span class="codeline" id="line-220"><code>//     part of the connection string.</code></span>
<span class="codeline" id="line-221"><code>func ParseConfig(connString string) (*Config, error) {</code></span>
<span class="codeline" id="line-222"><code>	var parseConfigOptions ParseConfigOptions</code></span>
<span class="codeline" id="line-223"><code>	return ParseConfigWithOptions(connString, parseConfigOptions)</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// ParseConfigWithOptions builds a *Config from connString and options with similar behavior to the PostgreSQL standard</code></span>
<span class="codeline" id="line-227"><code>// C library libpq. options contains settings that cannot be specified in a connString such as providing a function to</code></span>
<span class="codeline" id="line-228"><code>// get the SSL password.</code></span>
<span class="codeline" id="line-229"><code>func ParseConfigWithOptions(connString string, options ParseConfigOptions) (*Config, error) {</code></span>
<span class="codeline" id="line-230"><code>	defaultSettings := defaultSettings()</code></span>
<span class="codeline" id="line-231"><code>	envSettings := parseEnvSettings()</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>	connStringSettings := make(map[string]string)</code></span>
<span class="codeline" id="line-234"><code>	if connString != "" {</code></span>
<span class="codeline" id="line-235"><code>		var err error</code></span>
<span class="codeline" id="line-236"><code>		// connString may be a database URL or a DSN</code></span>
<span class="codeline" id="line-237"><code>		if strings.HasPrefix(connString, "postgres://") || strings.HasPrefix(connString, "postgresql://") {</code></span>
<span class="codeline" id="line-238"><code>			connStringSettings, err = parseURLSettings(connString)</code></span>
<span class="codeline" id="line-239"><code>			if err != nil {</code></span>
<span class="codeline" id="line-240"><code>				return nil, &amp;ParseConfigError{ConnString: connString, msg: "failed to parse as URL", err: err}</code></span>
<span class="codeline" id="line-241"><code>			}</code></span>
<span class="codeline" id="line-242"><code>		} else {</code></span>
<span class="codeline" id="line-243"><code>			connStringSettings, err = parseDSNSettings(connString)</code></span>
<span class="codeline" id="line-244"><code>			if err != nil {</code></span>
<span class="codeline" id="line-245"><code>				return nil, &amp;ParseConfigError{ConnString: connString, msg: "failed to parse as DSN", err: err}</code></span>
<span class="codeline" id="line-246"><code>			}</code></span>
<span class="codeline" id="line-247"><code>		}</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	settings := mergeSettings(defaultSettings, envSettings, connStringSettings)</code></span>
<span class="codeline" id="line-251"><code>	if service, present := settings["service"]; present {</code></span>
<span class="codeline" id="line-252"><code>		serviceSettings, err := parseServiceSettings(settings["servicefile"], service)</code></span>
<span class="codeline" id="line-253"><code>		if err != nil {</code></span>
<span class="codeline" id="line-254"><code>			return nil, &amp;ParseConfigError{ConnString: connString, msg: "failed to read service", err: err}</code></span>
<span class="codeline" id="line-255"><code>		}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>		settings = mergeSettings(defaultSettings, envSettings, serviceSettings, connStringSettings)</code></span>
<span class="codeline" id="line-258"><code>	}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>	config := &amp;Config{</code></span>
<span class="codeline" id="line-261"><code>		createdByParseConfig: true,</code></span>
<span class="codeline" id="line-262"><code>		Database:             settings["database"],</code></span>
<span class="codeline" id="line-263"><code>		User:                 settings["user"],</code></span>
<span class="codeline" id="line-264"><code>		Password:             settings["password"],</code></span>
<span class="codeline" id="line-265"><code>		RuntimeParams:        make(map[string]string),</code></span>
<span class="codeline" id="line-266"><code>		BuildFrontend: func(r io.Reader, w io.Writer) *pgproto3.Frontend {</code></span>
<span class="codeline" id="line-267"><code>			return pgproto3.NewFrontend(r, w)</code></span>
<span class="codeline" id="line-268"><code>		},</code></span>
<span class="codeline" id="line-269"><code>		OnPgError: func(_ *PgConn, pgErr *PgError) bool {</code></span>
<span class="codeline" id="line-270"><code>			// we want to automatically close any fatal errors</code></span>
<span class="codeline" id="line-271"><code>			if strings.EqualFold(pgErr.Severity, "FATAL") {</code></span>
<span class="codeline" id="line-272"><code>				return false</code></span>
<span class="codeline" id="line-273"><code>			}</code></span>
<span class="codeline" id="line-274"><code>			return true</code></span>
<span class="codeline" id="line-275"><code>		},</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>	if connectTimeoutSetting, present := settings["connect_timeout"]; present {</code></span>
<span class="codeline" id="line-279"><code>		connectTimeout, err := parseConnectTimeoutSetting(connectTimeoutSetting)</code></span>
<span class="codeline" id="line-280"><code>		if err != nil {</code></span>
<span class="codeline" id="line-281"><code>			return nil, &amp;ParseConfigError{ConnString: connString, msg: "invalid connect_timeout", err: err}</code></span>
<span class="codeline" id="line-282"><code>		}</code></span>
<span class="codeline" id="line-283"><code>		config.ConnectTimeout = connectTimeout</code></span>
<span class="codeline" id="line-284"><code>		config.DialFunc = makeConnectTimeoutDialFunc(connectTimeout)</code></span>
<span class="codeline" id="line-285"><code>	} else {</code></span>
<span class="codeline" id="line-286"><code>		defaultDialer := makeDefaultDialer()</code></span>
<span class="codeline" id="line-287"><code>		config.DialFunc = defaultDialer.DialContext</code></span>
<span class="codeline" id="line-288"><code>	}</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>	config.LookupFunc = makeDefaultResolver().LookupHost</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>	notRuntimeParams := map[string]struct{}{</code></span>
<span class="codeline" id="line-293"><code>		"host":                 {},</code></span>
<span class="codeline" id="line-294"><code>		"port":                 {},</code></span>
<span class="codeline" id="line-295"><code>		"database":             {},</code></span>
<span class="codeline" id="line-296"><code>		"user":                 {},</code></span>
<span class="codeline" id="line-297"><code>		"password":             {},</code></span>
<span class="codeline" id="line-298"><code>		"passfile":             {},</code></span>
<span class="codeline" id="line-299"><code>		"connect_timeout":      {},</code></span>
<span class="codeline" id="line-300"><code>		"sslmode":              {},</code></span>
<span class="codeline" id="line-301"><code>		"sslkey":               {},</code></span>
<span class="codeline" id="line-302"><code>		"sslcert":              {},</code></span>
<span class="codeline" id="line-303"><code>		"sslrootcert":          {},</code></span>
<span class="codeline" id="line-304"><code>		"sslpassword":          {},</code></span>
<span class="codeline" id="line-305"><code>		"sslsni":               {},</code></span>
<span class="codeline" id="line-306"><code>		"krbspn":               {},</code></span>
<span class="codeline" id="line-307"><code>		"krbsrvname":           {},</code></span>
<span class="codeline" id="line-308"><code>		"target_session_attrs": {},</code></span>
<span class="codeline" id="line-309"><code>		"service":              {},</code></span>
<span class="codeline" id="line-310"><code>		"servicefile":          {},</code></span>
<span class="codeline" id="line-311"><code>	}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>	// Adding kerberos configuration</code></span>
<span class="codeline" id="line-314"><code>	if _, present := settings["krbsrvname"]; present {</code></span>
<span class="codeline" id="line-315"><code>		config.KerberosSrvName = settings["krbsrvname"]</code></span>
<span class="codeline" id="line-316"><code>	}</code></span>
<span class="codeline" id="line-317"><code>	if _, present := settings["krbspn"]; present {</code></span>
<span class="codeline" id="line-318"><code>		config.KerberosSpn = settings["krbspn"]</code></span>
<span class="codeline" id="line-319"><code>	}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>	for k, v := range settings {</code></span>
<span class="codeline" id="line-322"><code>		if _, present := notRuntimeParams[k]; present {</code></span>
<span class="codeline" id="line-323"><code>			continue</code></span>
<span class="codeline" id="line-324"><code>		}</code></span>
<span class="codeline" id="line-325"><code>		config.RuntimeParams[k] = v</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>	fallbacks := []*FallbackConfig{}</code></span>
<span class="codeline" id="line-329"><code></code></span>
<span class="codeline" id="line-330"><code>	hosts := strings.Split(settings["host"], ",")</code></span>
<span class="codeline" id="line-331"><code>	ports := strings.Split(settings["port"], ",")</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>	for i, host := range hosts {</code></span>
<span class="codeline" id="line-334"><code>		var portStr string</code></span>
<span class="codeline" id="line-335"><code>		if i &lt; len(ports) {</code></span>
<span class="codeline" id="line-336"><code>			portStr = ports[i]</code></span>
<span class="codeline" id="line-337"><code>		} else {</code></span>
<span class="codeline" id="line-338"><code>			portStr = ports[0]</code></span>
<span class="codeline" id="line-339"><code>		}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>		port, err := parsePort(portStr)</code></span>
<span class="codeline" id="line-342"><code>		if err != nil {</code></span>
<span class="codeline" id="line-343"><code>			return nil, &amp;ParseConfigError{ConnString: connString, msg: "invalid port", err: err}</code></span>
<span class="codeline" id="line-344"><code>		}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>		var tlsConfigs []*tls.Config</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>		// Ignore TLS settings if Unix domain socket like libpq</code></span>
<span class="codeline" id="line-349"><code>		if network, _ := NetworkAddress(host, port); network == "unix" {</code></span>
<span class="codeline" id="line-350"><code>			tlsConfigs = append(tlsConfigs, nil)</code></span>
<span class="codeline" id="line-351"><code>		} else {</code></span>
<span class="codeline" id="line-352"><code>			var err error</code></span>
<span class="codeline" id="line-353"><code>			tlsConfigs, err = configTLS(settings, host, options)</code></span>
<span class="codeline" id="line-354"><code>			if err != nil {</code></span>
<span class="codeline" id="line-355"><code>				return nil, &amp;ParseConfigError{ConnString: connString, msg: "failed to configure TLS", err: err}</code></span>
<span class="codeline" id="line-356"><code>			}</code></span>
<span class="codeline" id="line-357"><code>		}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>		for _, tlsConfig := range tlsConfigs {</code></span>
<span class="codeline" id="line-360"><code>			fallbacks = append(fallbacks, &amp;FallbackConfig{</code></span>
<span class="codeline" id="line-361"><code>				Host:      host,</code></span>
<span class="codeline" id="line-362"><code>				Port:      port,</code></span>
<span class="codeline" id="line-363"><code>				TLSConfig: tlsConfig,</code></span>
<span class="codeline" id="line-364"><code>			})</code></span>
<span class="codeline" id="line-365"><code>		}</code></span>
<span class="codeline" id="line-366"><code>	}</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>	config.Host = fallbacks[0].Host</code></span>
<span class="codeline" id="line-369"><code>	config.Port = fallbacks[0].Port</code></span>
<span class="codeline" id="line-370"><code>	config.TLSConfig = fallbacks[0].TLSConfig</code></span>
<span class="codeline" id="line-371"><code>	config.Fallbacks = fallbacks[1:]</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>	passfile, err := pgpassfile.ReadPassfile(settings["passfile"])</code></span>
<span class="codeline" id="line-374"><code>	if err == nil {</code></span>
<span class="codeline" id="line-375"><code>		if config.Password == "" {</code></span>
<span class="codeline" id="line-376"><code>			host := config.Host</code></span>
<span class="codeline" id="line-377"><code>			if network, _ := NetworkAddress(config.Host, config.Port); network == "unix" {</code></span>
<span class="codeline" id="line-378"><code>				host = "localhost"</code></span>
<span class="codeline" id="line-379"><code>			}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>			config.Password = passfile.FindPassword(host, strconv.Itoa(int(config.Port)), config.Database, config.User)</code></span>
<span class="codeline" id="line-382"><code>		}</code></span>
<span class="codeline" id="line-383"><code>	}</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	switch tsa := settings["target_session_attrs"]; tsa {</code></span>
<span class="codeline" id="line-386"><code>	case "read-write":</code></span>
<span class="codeline" id="line-387"><code>		config.ValidateConnect = ValidateConnectTargetSessionAttrsReadWrite</code></span>
<span class="codeline" id="line-388"><code>	case "read-only":</code></span>
<span class="codeline" id="line-389"><code>		config.ValidateConnect = ValidateConnectTargetSessionAttrsReadOnly</code></span>
<span class="codeline" id="line-390"><code>	case "primary":</code></span>
<span class="codeline" id="line-391"><code>		config.ValidateConnect = ValidateConnectTargetSessionAttrsPrimary</code></span>
<span class="codeline" id="line-392"><code>	case "standby":</code></span>
<span class="codeline" id="line-393"><code>		config.ValidateConnect = ValidateConnectTargetSessionAttrsStandby</code></span>
<span class="codeline" id="line-394"><code>	case "prefer-standby":</code></span>
<span class="codeline" id="line-395"><code>		config.ValidateConnect = ValidateConnectTargetSessionAttrsPreferStandby</code></span>
<span class="codeline" id="line-396"><code>	case "any":</code></span>
<span class="codeline" id="line-397"><code>		// do nothing</code></span>
<span class="codeline" id="line-398"><code>	default:</code></span>
<span class="codeline" id="line-399"><code>		return nil, &amp;ParseConfigError{ConnString: connString, msg: fmt.Sprintf("unknown target_session_attrs value: %v", tsa)}</code></span>
<span class="codeline" id="line-400"><code>	}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>	return config, nil</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>func mergeSettings(settingSets ...map[string]string) map[string]string {</code></span>
<span class="codeline" id="line-406"><code>	settings := make(map[string]string)</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>	for _, s2 := range settingSets {</code></span>
<span class="codeline" id="line-409"><code>		for k, v := range s2 {</code></span>
<span class="codeline" id="line-410"><code>			settings[k] = v</code></span>
<span class="codeline" id="line-411"><code>		}</code></span>
<span class="codeline" id="line-412"><code>	}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>	return settings</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>func parseEnvSettings() map[string]string {</code></span>
<span class="codeline" id="line-418"><code>	settings := make(map[string]string)</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	nameMap := map[string]string{</code></span>
<span class="codeline" id="line-421"><code>		"PGHOST":               "host",</code></span>
<span class="codeline" id="line-422"><code>		"PGPORT":               "port",</code></span>
<span class="codeline" id="line-423"><code>		"PGDATABASE":           "database",</code></span>
<span class="codeline" id="line-424"><code>		"PGUSER":               "user",</code></span>
<span class="codeline" id="line-425"><code>		"PGPASSWORD":           "password",</code></span>
<span class="codeline" id="line-426"><code>		"PGPASSFILE":           "passfile",</code></span>
<span class="codeline" id="line-427"><code>		"PGAPPNAME":            "application_name",</code></span>
<span class="codeline" id="line-428"><code>		"PGCONNECT_TIMEOUT":    "connect_timeout",</code></span>
<span class="codeline" id="line-429"><code>		"PGSSLMODE":            "sslmode",</code></span>
<span class="codeline" id="line-430"><code>		"PGSSLKEY":             "sslkey",</code></span>
<span class="codeline" id="line-431"><code>		"PGSSLCERT":            "sslcert",</code></span>
<span class="codeline" id="line-432"><code>		"PGSSLSNI":             "sslsni",</code></span>
<span class="codeline" id="line-433"><code>		"PGSSLROOTCERT":        "sslrootcert",</code></span>
<span class="codeline" id="line-434"><code>		"PGSSLPASSWORD":        "sslpassword",</code></span>
<span class="codeline" id="line-435"><code>		"PGTARGETSESSIONATTRS": "target_session_attrs",</code></span>
<span class="codeline" id="line-436"><code>		"PGSERVICE":            "service",</code></span>
<span class="codeline" id="line-437"><code>		"PGSERVICEFILE":        "servicefile",</code></span>
<span class="codeline" id="line-438"><code>	}</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>	for envname, realname := range nameMap {</code></span>
<span class="codeline" id="line-441"><code>		value := os.Getenv(envname)</code></span>
<span class="codeline" id="line-442"><code>		if value != "" {</code></span>
<span class="codeline" id="line-443"><code>			settings[realname] = value</code></span>
<span class="codeline" id="line-444"><code>		}</code></span>
<span class="codeline" id="line-445"><code>	}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	return settings</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>func parseURLSettings(connString string) (map[string]string, error) {</code></span>
<span class="codeline" id="line-451"><code>	settings := make(map[string]string)</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>	url, err := url.Parse(connString)</code></span>
<span class="codeline" id="line-454"><code>	if err != nil {</code></span>
<span class="codeline" id="line-455"><code>		return nil, err</code></span>
<span class="codeline" id="line-456"><code>	}</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>	if url.User != nil {</code></span>
<span class="codeline" id="line-459"><code>		settings["user"] = url.User.Username()</code></span>
<span class="codeline" id="line-460"><code>		if password, present := url.User.Password(); present {</code></span>
<span class="codeline" id="line-461"><code>			settings["password"] = password</code></span>
<span class="codeline" id="line-462"><code>		}</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	// Handle multiple host:port's in url.Host by splitting them into host,host,host and port,port,port.</code></span>
<span class="codeline" id="line-466"><code>	var hosts []string</code></span>
<span class="codeline" id="line-467"><code>	var ports []string</code></span>
<span class="codeline" id="line-468"><code>	for _, host := range strings.Split(url.Host, ",") {</code></span>
<span class="codeline" id="line-469"><code>		if host == "" {</code></span>
<span class="codeline" id="line-470"><code>			continue</code></span>
<span class="codeline" id="line-471"><code>		}</code></span>
<span class="codeline" id="line-472"><code>		if isIPOnly(host) {</code></span>
<span class="codeline" id="line-473"><code>			hosts = append(hosts, strings.Trim(host, "[]"))</code></span>
<span class="codeline" id="line-474"><code>			continue</code></span>
<span class="codeline" id="line-475"><code>		}</code></span>
<span class="codeline" id="line-476"><code>		h, p, err := net.SplitHostPort(host)</code></span>
<span class="codeline" id="line-477"><code>		if err != nil {</code></span>
<span class="codeline" id="line-478"><code>			return nil, fmt.Errorf("failed to split host:port in '%s', err: %w", host, err)</code></span>
<span class="codeline" id="line-479"><code>		}</code></span>
<span class="codeline" id="line-480"><code>		if h != "" {</code></span>
<span class="codeline" id="line-481"><code>			hosts = append(hosts, h)</code></span>
<span class="codeline" id="line-482"><code>		}</code></span>
<span class="codeline" id="line-483"><code>		if p != "" {</code></span>
<span class="codeline" id="line-484"><code>			ports = append(ports, p)</code></span>
<span class="codeline" id="line-485"><code>		}</code></span>
<span class="codeline" id="line-486"><code>	}</code></span>
<span class="codeline" id="line-487"><code>	if len(hosts) &gt; 0 {</code></span>
<span class="codeline" id="line-488"><code>		settings["host"] = strings.Join(hosts, ",")</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code>	if len(ports) &gt; 0 {</code></span>
<span class="codeline" id="line-491"><code>		settings["port"] = strings.Join(ports, ",")</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	database := strings.TrimLeft(url.Path, "/")</code></span>
<span class="codeline" id="line-495"><code>	if database != "" {</code></span>
<span class="codeline" id="line-496"><code>		settings["database"] = database</code></span>
<span class="codeline" id="line-497"><code>	}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>	nameMap := map[string]string{</code></span>
<span class="codeline" id="line-500"><code>		"dbname": "database",</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>	for k, v := range url.Query() {</code></span>
<span class="codeline" id="line-504"><code>		if k2, present := nameMap[k]; present {</code></span>
<span class="codeline" id="line-505"><code>			k = k2</code></span>
<span class="codeline" id="line-506"><code>		}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>		settings[k] = v[0]</code></span>
<span class="codeline" id="line-509"><code>	}</code></span>
<span class="codeline" id="line-510"><code></code></span>
<span class="codeline" id="line-511"><code>	return settings, nil</code></span>
<span class="codeline" id="line-512"><code>}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>func isIPOnly(host string) bool {</code></span>
<span class="codeline" id="line-515"><code>	return net.ParseIP(strings.Trim(host, "[]")) != nil || !strings.Contains(host, ":")</code></span>
<span class="codeline" id="line-516"><code>}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>var asciiSpace = [256]uint8{'\t': 1, '\n': 1, '\v': 1, '\f': 1, '\r': 1, ' ': 1}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>func parseDSNSettings(s string) (map[string]string, error) {</code></span>
<span class="codeline" id="line-521"><code>	settings := make(map[string]string)</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	nameMap := map[string]string{</code></span>
<span class="codeline" id="line-524"><code>		"dbname": "database",</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>	for len(s) &gt; 0 {</code></span>
<span class="codeline" id="line-528"><code>		var key, val string</code></span>
<span class="codeline" id="line-529"><code>		eqIdx := strings.IndexRune(s, '=')</code></span>
<span class="codeline" id="line-530"><code>		if eqIdx &lt; 0 {</code></span>
<span class="codeline" id="line-531"><code>			return nil, errors.New("invalid dsn")</code></span>
<span class="codeline" id="line-532"><code>		}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>		key = strings.Trim(s[:eqIdx], " \t\n\r\v\f")</code></span>
<span class="codeline" id="line-535"><code>		s = strings.TrimLeft(s[eqIdx+1:], " \t\n\r\v\f")</code></span>
<span class="codeline" id="line-536"><code>		if len(s) == 0 {</code></span>
<span class="codeline" id="line-537"><code>		} else if s[0] != '\'' {</code></span>
<span class="codeline" id="line-538"><code>			end := 0</code></span>
<span class="codeline" id="line-539"><code>			for ; end &lt; len(s); end++ {</code></span>
<span class="codeline" id="line-540"><code>				if asciiSpace[s[end]] == 1 {</code></span>
<span class="codeline" id="line-541"><code>					break</code></span>
<span class="codeline" id="line-542"><code>				}</code></span>
<span class="codeline" id="line-543"><code>				if s[end] == '\\' {</code></span>
<span class="codeline" id="line-544"><code>					end++</code></span>
<span class="codeline" id="line-545"><code>					if end == len(s) {</code></span>
<span class="codeline" id="line-546"><code>						return nil, errors.New("invalid backslash")</code></span>
<span class="codeline" id="line-547"><code>					}</code></span>
<span class="codeline" id="line-548"><code>				}</code></span>
<span class="codeline" id="line-549"><code>			}</code></span>
<span class="codeline" id="line-550"><code>			val = strings.Replace(strings.Replace(s[:end], "\\\\", "\\", -1), "\\'", "'", -1)</code></span>
<span class="codeline" id="line-551"><code>			if end == len(s) {</code></span>
<span class="codeline" id="line-552"><code>				s = ""</code></span>
<span class="codeline" id="line-553"><code>			} else {</code></span>
<span class="codeline" id="line-554"><code>				s = s[end+1:]</code></span>
<span class="codeline" id="line-555"><code>			}</code></span>
<span class="codeline" id="line-556"><code>		} else { // quoted string</code></span>
<span class="codeline" id="line-557"><code>			s = s[1:]</code></span>
<span class="codeline" id="line-558"><code>			end := 0</code></span>
<span class="codeline" id="line-559"><code>			for ; end &lt; len(s); end++ {</code></span>
<span class="codeline" id="line-560"><code>				if s[end] == '\'' {</code></span>
<span class="codeline" id="line-561"><code>					break</code></span>
<span class="codeline" id="line-562"><code>				}</code></span>
<span class="codeline" id="line-563"><code>				if s[end] == '\\' {</code></span>
<span class="codeline" id="line-564"><code>					end++</code></span>
<span class="codeline" id="line-565"><code>				}</code></span>
<span class="codeline" id="line-566"><code>			}</code></span>
<span class="codeline" id="line-567"><code>			if end == len(s) {</code></span>
<span class="codeline" id="line-568"><code>				return nil, errors.New("unterminated quoted string in connection info string")</code></span>
<span class="codeline" id="line-569"><code>			}</code></span>
<span class="codeline" id="line-570"><code>			val = strings.Replace(strings.Replace(s[:end], "\\\\", "\\", -1), "\\'", "'", -1)</code></span>
<span class="codeline" id="line-571"><code>			if end == len(s) {</code></span>
<span class="codeline" id="line-572"><code>				s = ""</code></span>
<span class="codeline" id="line-573"><code>			} else {</code></span>
<span class="codeline" id="line-574"><code>				s = s[end+1:]</code></span>
<span class="codeline" id="line-575"><code>			}</code></span>
<span class="codeline" id="line-576"><code>		}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>		if k, ok := nameMap[key]; ok {</code></span>
<span class="codeline" id="line-579"><code>			key = k</code></span>
<span class="codeline" id="line-580"><code>		}</code></span>
<span class="codeline" id="line-581"><code></code></span>
<span class="codeline" id="line-582"><code>		if key == "" {</code></span>
<span class="codeline" id="line-583"><code>			return nil, errors.New("invalid dsn")</code></span>
<span class="codeline" id="line-584"><code>		}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>		settings[key] = val</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>	return settings, nil</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>func parseServiceSettings(servicefilePath, serviceName string) (map[string]string, error) {</code></span>
<span class="codeline" id="line-593"><code>	servicefile, err := pgservicefile.ReadServicefile(servicefilePath)</code></span>
<span class="codeline" id="line-594"><code>	if err != nil {</code></span>
<span class="codeline" id="line-595"><code>		return nil, fmt.Errorf("failed to read service file: %v", servicefilePath)</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>	service, err := servicefile.GetService(serviceName)</code></span>
<span class="codeline" id="line-599"><code>	if err != nil {</code></span>
<span class="codeline" id="line-600"><code>		return nil, fmt.Errorf("unable to find service: %v", serviceName)</code></span>
<span class="codeline" id="line-601"><code>	}</code></span>
<span class="codeline" id="line-602"><code></code></span>
<span class="codeline" id="line-603"><code>	nameMap := map[string]string{</code></span>
<span class="codeline" id="line-604"><code>		"dbname": "database",</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	settings := make(map[string]string, len(service.Settings))</code></span>
<span class="codeline" id="line-608"><code>	for k, v := range service.Settings {</code></span>
<span class="codeline" id="line-609"><code>		if k2, present := nameMap[k]; present {</code></span>
<span class="codeline" id="line-610"><code>			k = k2</code></span>
<span class="codeline" id="line-611"><code>		}</code></span>
<span class="codeline" id="line-612"><code>		settings[k] = v</code></span>
<span class="codeline" id="line-613"><code>	}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>	return settings, nil</code></span>
<span class="codeline" id="line-616"><code>}</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>// configTLS uses libpq's TLS parameters to construct  []*tls.Config. It is</code></span>
<span class="codeline" id="line-619"><code>// necessary to allow returning multiple TLS configs as sslmode "allow" and</code></span>
<span class="codeline" id="line-620"><code>// "prefer" allow fallback.</code></span>
<span class="codeline" id="line-621"><code>func configTLS(settings map[string]string, thisHost string, parseConfigOptions ParseConfigOptions) ([]*tls.Config, error) {</code></span>
<span class="codeline" id="line-622"><code>	host := thisHost</code></span>
<span class="codeline" id="line-623"><code>	sslmode := settings["sslmode"]</code></span>
<span class="codeline" id="line-624"><code>	sslrootcert := settings["sslrootcert"]</code></span>
<span class="codeline" id="line-625"><code>	sslcert := settings["sslcert"]</code></span>
<span class="codeline" id="line-626"><code>	sslkey := settings["sslkey"]</code></span>
<span class="codeline" id="line-627"><code>	sslpassword := settings["sslpassword"]</code></span>
<span class="codeline" id="line-628"><code>	sslsni := settings["sslsni"]</code></span>
<span class="codeline" id="line-629"><code></code></span>
<span class="codeline" id="line-630"><code>	// Match libpq default behavior</code></span>
<span class="codeline" id="line-631"><code>	if sslmode == "" {</code></span>
<span class="codeline" id="line-632"><code>		sslmode = "prefer"</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	if sslsni == "" {</code></span>
<span class="codeline" id="line-635"><code>		sslsni = "1"</code></span>
<span class="codeline" id="line-636"><code>	}</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>	tlsConfig := &amp;tls.Config{}</code></span>
<span class="codeline" id="line-639"><code></code></span>
<span class="codeline" id="line-640"><code>	switch sslmode {</code></span>
<span class="codeline" id="line-641"><code>	case "disable":</code></span>
<span class="codeline" id="line-642"><code>		return []*tls.Config{nil}, nil</code></span>
<span class="codeline" id="line-643"><code>	case "allow", "prefer":</code></span>
<span class="codeline" id="line-644"><code>		tlsConfig.InsecureSkipVerify = true</code></span>
<span class="codeline" id="line-645"><code>	case "require":</code></span>
<span class="codeline" id="line-646"><code>		// According to PostgreSQL documentation, if a root CA file exists,</code></span>
<span class="codeline" id="line-647"><code>		// the behavior of sslmode=require should be the same as that of verify-ca</code></span>
<span class="codeline" id="line-648"><code>		//</code></span>
<span class="codeline" id="line-649"><code>		// See https://www.postgresql.org/docs/12/libpq-ssl.html</code></span>
<span class="codeline" id="line-650"><code>		if sslrootcert != "" {</code></span>
<span class="codeline" id="line-651"><code>			goto nextCase</code></span>
<span class="codeline" id="line-652"><code>		}</code></span>
<span class="codeline" id="line-653"><code>		tlsConfig.InsecureSkipVerify = true</code></span>
<span class="codeline" id="line-654"><code>		break</code></span>
<span class="codeline" id="line-655"><code>	nextCase:</code></span>
<span class="codeline" id="line-656"><code>		fallthrough</code></span>
<span class="codeline" id="line-657"><code>	case "verify-ca":</code></span>
<span class="codeline" id="line-658"><code>		// Don't perform the default certificate verification because it</code></span>
<span class="codeline" id="line-659"><code>		// will verify the hostname. Instead, verify the server's</code></span>
<span class="codeline" id="line-660"><code>		// certificate chain ourselves in VerifyPeerCertificate and</code></span>
<span class="codeline" id="line-661"><code>		// ignore the server name. This emulates libpq's verify-ca</code></span>
<span class="codeline" id="line-662"><code>		// behavior.</code></span>
<span class="codeline" id="line-663"><code>		//</code></span>
<span class="codeline" id="line-664"><code>		// See https://github.com/golang/go/issues/21971#issuecomment-332693931</code></span>
<span class="codeline" id="line-665"><code>		// and https://pkg.go.dev/crypto/tls?tab=doc#example-Config-VerifyPeerCertificate</code></span>
<span class="codeline" id="line-666"><code>		// for more info.</code></span>
<span class="codeline" id="line-667"><code>		tlsConfig.InsecureSkipVerify = true</code></span>
<span class="codeline" id="line-668"><code>		tlsConfig.VerifyPeerCertificate = func(certificates [][]byte, _ [][]*x509.Certificate) error {</code></span>
<span class="codeline" id="line-669"><code>			certs := make([]*x509.Certificate, len(certificates))</code></span>
<span class="codeline" id="line-670"><code>			for i, asn1Data := range certificates {</code></span>
<span class="codeline" id="line-671"><code>				cert, err := x509.ParseCertificate(asn1Data)</code></span>
<span class="codeline" id="line-672"><code>				if err != nil {</code></span>
<span class="codeline" id="line-673"><code>					return errors.New("failed to parse certificate from server: " + err.Error())</code></span>
<span class="codeline" id="line-674"><code>				}</code></span>
<span class="codeline" id="line-675"><code>				certs[i] = cert</code></span>
<span class="codeline" id="line-676"><code>			}</code></span>
<span class="codeline" id="line-677"><code></code></span>
<span class="codeline" id="line-678"><code>			// Leave DNSName empty to skip hostname verification.</code></span>
<span class="codeline" id="line-679"><code>			opts := x509.VerifyOptions{</code></span>
<span class="codeline" id="line-680"><code>				Roots:         tlsConfig.RootCAs,</code></span>
<span class="codeline" id="line-681"><code>				Intermediates: x509.NewCertPool(),</code></span>
<span class="codeline" id="line-682"><code>			}</code></span>
<span class="codeline" id="line-683"><code>			// Skip the first cert because it's the leaf. All others</code></span>
<span class="codeline" id="line-684"><code>			// are intermediates.</code></span>
<span class="codeline" id="line-685"><code>			for _, cert := range certs[1:] {</code></span>
<span class="codeline" id="line-686"><code>				opts.Intermediates.AddCert(cert)</code></span>
<span class="codeline" id="line-687"><code>			}</code></span>
<span class="codeline" id="line-688"><code>			_, err := certs[0].Verify(opts)</code></span>
<span class="codeline" id="line-689"><code>			return err</code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>	case "verify-full":</code></span>
<span class="codeline" id="line-692"><code>		tlsConfig.ServerName = host</code></span>
<span class="codeline" id="line-693"><code>	default:</code></span>
<span class="codeline" id="line-694"><code>		return nil, errors.New("sslmode is invalid")</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	if sslrootcert != "" {</code></span>
<span class="codeline" id="line-698"><code>		caCertPool := x509.NewCertPool()</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>		caPath := sslrootcert</code></span>
<span class="codeline" id="line-701"><code>		caCert, err := os.ReadFile(caPath)</code></span>
<span class="codeline" id="line-702"><code>		if err != nil {</code></span>
<span class="codeline" id="line-703"><code>			return nil, fmt.Errorf("unable to read CA file: %w", err)</code></span>
<span class="codeline" id="line-704"><code>		}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>		if !caCertPool.AppendCertsFromPEM(caCert) {</code></span>
<span class="codeline" id="line-707"><code>			return nil, errors.New("unable to add CA to cert pool")</code></span>
<span class="codeline" id="line-708"><code>		}</code></span>
<span class="codeline" id="line-709"><code></code></span>
<span class="codeline" id="line-710"><code>		tlsConfig.RootCAs = caCertPool</code></span>
<span class="codeline" id="line-711"><code>		tlsConfig.ClientCAs = caCertPool</code></span>
<span class="codeline" id="line-712"><code>	}</code></span>
<span class="codeline" id="line-713"><code></code></span>
<span class="codeline" id="line-714"><code>	if (sslcert != "" &amp;&amp; sslkey == "") || (sslcert == "" &amp;&amp; sslkey != "") {</code></span>
<span class="codeline" id="line-715"><code>		return nil, errors.New(`both "sslcert" and "sslkey" are required`)</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>	if sslcert != "" &amp;&amp; sslkey != "" {</code></span>
<span class="codeline" id="line-719"><code>		buf, err := os.ReadFile(sslkey)</code></span>
<span class="codeline" id="line-720"><code>		if err != nil {</code></span>
<span class="codeline" id="line-721"><code>			return nil, fmt.Errorf("unable to read sslkey: %w", err)</code></span>
<span class="codeline" id="line-722"><code>		}</code></span>
<span class="codeline" id="line-723"><code>		block, _ := pem.Decode(buf)</code></span>
<span class="codeline" id="line-724"><code>		var pemKey []byte</code></span>
<span class="codeline" id="line-725"><code>		var decryptedKey []byte</code></span>
<span class="codeline" id="line-726"><code>		var decryptedError error</code></span>
<span class="codeline" id="line-727"><code>		// If PEM is encrypted, attempt to decrypt using pass phrase</code></span>
<span class="codeline" id="line-728"><code>		if x509.IsEncryptedPEMBlock(block) {</code></span>
<span class="codeline" id="line-729"><code>			// Attempt decryption with pass phrase</code></span>
<span class="codeline" id="line-730"><code>			// NOTE: only supports RSA (PKCS#1)</code></span>
<span class="codeline" id="line-731"><code>			if sslpassword != "" {</code></span>
<span class="codeline" id="line-732"><code>				decryptedKey, decryptedError = x509.DecryptPEMBlock(block, []byte(sslpassword))</code></span>
<span class="codeline" id="line-733"><code>			}</code></span>
<span class="codeline" id="line-734"><code>			//if sslpassword not provided or has decryption error when use it</code></span>
<span class="codeline" id="line-735"><code>			//try to find sslpassword with callback function</code></span>
<span class="codeline" id="line-736"><code>			if sslpassword == "" || decryptedError != nil {</code></span>
<span class="codeline" id="line-737"><code>				if parseConfigOptions.GetSSLPassword != nil {</code></span>
<span class="codeline" id="line-738"><code>					sslpassword = parseConfigOptions.GetSSLPassword(context.Background())</code></span>
<span class="codeline" id="line-739"><code>				}</code></span>
<span class="codeline" id="line-740"><code>				if sslpassword == "" {</code></span>
<span class="codeline" id="line-741"><code>					return nil, fmt.Errorf("unable to find sslpassword")</code></span>
<span class="codeline" id="line-742"><code>				}</code></span>
<span class="codeline" id="line-743"><code>			}</code></span>
<span class="codeline" id="line-744"><code>			decryptedKey, decryptedError = x509.DecryptPEMBlock(block, []byte(sslpassword))</code></span>
<span class="codeline" id="line-745"><code>			// Should we also provide warning for PKCS#1 needed?</code></span>
<span class="codeline" id="line-746"><code>			if decryptedError != nil {</code></span>
<span class="codeline" id="line-747"><code>				return nil, fmt.Errorf("unable to decrypt key: %w", err)</code></span>
<span class="codeline" id="line-748"><code>			}</code></span>
<span class="codeline" id="line-749"><code></code></span>
<span class="codeline" id="line-750"><code>			pemBytes := pem.Block{</code></span>
<span class="codeline" id="line-751"><code>				Type:  "RSA PRIVATE KEY",</code></span>
<span class="codeline" id="line-752"><code>				Bytes: decryptedKey,</code></span>
<span class="codeline" id="line-753"><code>			}</code></span>
<span class="codeline" id="line-754"><code>			pemKey = pem.EncodeToMemory(&amp;pemBytes)</code></span>
<span class="codeline" id="line-755"><code>		} else {</code></span>
<span class="codeline" id="line-756"><code>			pemKey = pem.EncodeToMemory(block)</code></span>
<span class="codeline" id="line-757"><code>		}</code></span>
<span class="codeline" id="line-758"><code>		certfile, err := os.ReadFile(sslcert)</code></span>
<span class="codeline" id="line-759"><code>		if err != nil {</code></span>
<span class="codeline" id="line-760"><code>			return nil, fmt.Errorf("unable to read cert: %w", err)</code></span>
<span class="codeline" id="line-761"><code>		}</code></span>
<span class="codeline" id="line-762"><code>		cert, err := tls.X509KeyPair(certfile, pemKey)</code></span>
<span class="codeline" id="line-763"><code>		if err != nil {</code></span>
<span class="codeline" id="line-764"><code>			return nil, fmt.Errorf("unable to load cert: %w", err)</code></span>
<span class="codeline" id="line-765"><code>		}</code></span>
<span class="codeline" id="line-766"><code>		tlsConfig.Certificates = []tls.Certificate{cert}</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code></code></span>
<span class="codeline" id="line-769"><code>	// Set Server Name Indication (SNI), if enabled by connection parameters.</code></span>
<span class="codeline" id="line-770"><code>	// Per RFC 6066, do not set it if the host is a literal IP address (IPv4</code></span>
<span class="codeline" id="line-771"><code>	// or IPv6).</code></span>
<span class="codeline" id="line-772"><code>	if sslsni == "1" &amp;&amp; net.ParseIP(host) == nil {</code></span>
<span class="codeline" id="line-773"><code>		tlsConfig.ServerName = host</code></span>
<span class="codeline" id="line-774"><code>	}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>	switch sslmode {</code></span>
<span class="codeline" id="line-777"><code>	case "allow":</code></span>
<span class="codeline" id="line-778"><code>		return []*tls.Config{nil, tlsConfig}, nil</code></span>
<span class="codeline" id="line-779"><code>	case "prefer":</code></span>
<span class="codeline" id="line-780"><code>		return []*tls.Config{tlsConfig, nil}, nil</code></span>
<span class="codeline" id="line-781"><code>	case "require", "verify-ca", "verify-full":</code></span>
<span class="codeline" id="line-782"><code>		return []*tls.Config{tlsConfig}, nil</code></span>
<span class="codeline" id="line-783"><code>	default:</code></span>
<span class="codeline" id="line-784"><code>		panic("BUG: bad sslmode should already have been caught")</code></span>
<span class="codeline" id="line-785"><code>	}</code></span>
<span class="codeline" id="line-786"><code>}</code></span>
<span class="codeline" id="line-787"><code></code></span>
<span class="codeline" id="line-788"><code>func parsePort(s string) (uint16, error) {</code></span>
<span class="codeline" id="line-789"><code>	port, err := strconv.ParseUint(s, 10, 16)</code></span>
<span class="codeline" id="line-790"><code>	if err != nil {</code></span>
<span class="codeline" id="line-791"><code>		return 0, err</code></span>
<span class="codeline" id="line-792"><code>	}</code></span>
<span class="codeline" id="line-793"><code>	if port &lt; 1 || port &gt; math.MaxUint16 {</code></span>
<span class="codeline" id="line-794"><code>		return 0, errors.New("outside range")</code></span>
<span class="codeline" id="line-795"><code>	}</code></span>
<span class="codeline" id="line-796"><code>	return uint16(port), nil</code></span>
<span class="codeline" id="line-797"><code>}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>func makeDefaultDialer() *net.Dialer {</code></span>
<span class="codeline" id="line-800"><code>	return &amp;net.Dialer{KeepAlive: 5 * time.Minute}</code></span>
<span class="codeline" id="line-801"><code>}</code></span>
<span class="codeline" id="line-802"><code></code></span>
<span class="codeline" id="line-803"><code>func makeDefaultResolver() *net.Resolver {</code></span>
<span class="codeline" id="line-804"><code>	return net.DefaultResolver</code></span>
<span class="codeline" id="line-805"><code>}</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>func parseConnectTimeoutSetting(s string) (time.Duration, error) {</code></span>
<span class="codeline" id="line-808"><code>	timeout, err := strconv.ParseInt(s, 10, 64)</code></span>
<span class="codeline" id="line-809"><code>	if err != nil {</code></span>
<span class="codeline" id="line-810"><code>		return 0, err</code></span>
<span class="codeline" id="line-811"><code>	}</code></span>
<span class="codeline" id="line-812"><code>	if timeout &lt; 0 {</code></span>
<span class="codeline" id="line-813"><code>		return 0, errors.New("negative timeout")</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code>	return time.Duration(timeout) * time.Second, nil</code></span>
<span class="codeline" id="line-816"><code>}</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>func makeConnectTimeoutDialFunc(timeout time.Duration) DialFunc {</code></span>
<span class="codeline" id="line-819"><code>	d := makeDefaultDialer()</code></span>
<span class="codeline" id="line-820"><code>	d.Timeout = timeout</code></span>
<span class="codeline" id="line-821"><code>	return d.DialContext</code></span>
<span class="codeline" id="line-822"><code>}</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>// ValidateConnectTargetSessionAttrsReadWrite is a ValidateConnectFunc that implements libpq compatible</code></span>
<span class="codeline" id="line-825"><code>// target_session_attrs=read-write.</code></span>
<span class="codeline" id="line-826"><code>func ValidateConnectTargetSessionAttrsReadWrite(ctx context.Context, pgConn *PgConn) error {</code></span>
<span class="codeline" id="line-827"><code>	result := pgConn.ExecParams(ctx, "show transaction_read_only", nil, nil, nil, nil).Read()</code></span>
<span class="codeline" id="line-828"><code>	if result.Err != nil {</code></span>
<span class="codeline" id="line-829"><code>		return result.Err</code></span>
<span class="codeline" id="line-830"><code>	}</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>	if string(result.Rows[0][0]) == "on" {</code></span>
<span class="codeline" id="line-833"><code>		return errors.New("read only connection")</code></span>
<span class="codeline" id="line-834"><code>	}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>	return nil</code></span>
<span class="codeline" id="line-837"><code>}</code></span>
<span class="codeline" id="line-838"><code></code></span>
<span class="codeline" id="line-839"><code>// ValidateConnectTargetSessionAttrsReadOnly is a ValidateConnectFunc that implements libpq compatible</code></span>
<span class="codeline" id="line-840"><code>// target_session_attrs=read-only.</code></span>
<span class="codeline" id="line-841"><code>func ValidateConnectTargetSessionAttrsReadOnly(ctx context.Context, pgConn *PgConn) error {</code></span>
<span class="codeline" id="line-842"><code>	result := pgConn.ExecParams(ctx, "show transaction_read_only", nil, nil, nil, nil).Read()</code></span>
<span class="codeline" id="line-843"><code>	if result.Err != nil {</code></span>
<span class="codeline" id="line-844"><code>		return result.Err</code></span>
<span class="codeline" id="line-845"><code>	}</code></span>
<span class="codeline" id="line-846"><code></code></span>
<span class="codeline" id="line-847"><code>	if string(result.Rows[0][0]) != "on" {</code></span>
<span class="codeline" id="line-848"><code>		return errors.New("connection is not read only")</code></span>
<span class="codeline" id="line-849"><code>	}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>	return nil</code></span>
<span class="codeline" id="line-852"><code>}</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>// ValidateConnectTargetSessionAttrsStandby is a ValidateConnectFunc that implements libpq compatible</code></span>
<span class="codeline" id="line-855"><code>// target_session_attrs=standby.</code></span>
<span class="codeline" id="line-856"><code>func ValidateConnectTargetSessionAttrsStandby(ctx context.Context, pgConn *PgConn) error {</code></span>
<span class="codeline" id="line-857"><code>	result := pgConn.ExecParams(ctx, "select pg_is_in_recovery()", nil, nil, nil, nil).Read()</code></span>
<span class="codeline" id="line-858"><code>	if result.Err != nil {</code></span>
<span class="codeline" id="line-859"><code>		return result.Err</code></span>
<span class="codeline" id="line-860"><code>	}</code></span>
<span class="codeline" id="line-861"><code></code></span>
<span class="codeline" id="line-862"><code>	if string(result.Rows[0][0]) != "t" {</code></span>
<span class="codeline" id="line-863"><code>		return errors.New("server is not in hot standby mode")</code></span>
<span class="codeline" id="line-864"><code>	}</code></span>
<span class="codeline" id="line-865"><code></code></span>
<span class="codeline" id="line-866"><code>	return nil</code></span>
<span class="codeline" id="line-867"><code>}</code></span>
<span class="codeline" id="line-868"><code></code></span>
<span class="codeline" id="line-869"><code>// ValidateConnectTargetSessionAttrsPrimary is a ValidateConnectFunc that implements libpq compatible</code></span>
<span class="codeline" id="line-870"><code>// target_session_attrs=primary.</code></span>
<span class="codeline" id="line-871"><code>func ValidateConnectTargetSessionAttrsPrimary(ctx context.Context, pgConn *PgConn) error {</code></span>
<span class="codeline" id="line-872"><code>	result := pgConn.ExecParams(ctx, "select pg_is_in_recovery()", nil, nil, nil, nil).Read()</code></span>
<span class="codeline" id="line-873"><code>	if result.Err != nil {</code></span>
<span class="codeline" id="line-874"><code>		return result.Err</code></span>
<span class="codeline" id="line-875"><code>	}</code></span>
<span class="codeline" id="line-876"><code></code></span>
<span class="codeline" id="line-877"><code>	if string(result.Rows[0][0]) == "t" {</code></span>
<span class="codeline" id="line-878"><code>		return errors.New("server is in standby mode")</code></span>
<span class="codeline" id="line-879"><code>	}</code></span>
<span class="codeline" id="line-880"><code></code></span>
<span class="codeline" id="line-881"><code>	return nil</code></span>
<span class="codeline" id="line-882"><code>}</code></span>
<span class="codeline" id="line-883"><code></code></span>
<span class="codeline" id="line-884"><code>// ValidateConnectTargetSessionAttrsPreferStandby is a ValidateConnectFunc that implements libpq compatible</code></span>
<span class="codeline" id="line-885"><code>// target_session_attrs=prefer-standby.</code></span>
<span class="codeline" id="line-886"><code>func ValidateConnectTargetSessionAttrsPreferStandby(ctx context.Context, pgConn *PgConn) error {</code></span>
<span class="codeline" id="line-887"><code>	result := pgConn.ExecParams(ctx, "select pg_is_in_recovery()", nil, nil, nil, nil).Read()</code></span>
<span class="codeline" id="line-888"><code>	if result.Err != nil {</code></span>
<span class="codeline" id="line-889"><code>		return result.Err</code></span>
<span class="codeline" id="line-890"><code>	}</code></span>
<span class="codeline" id="line-891"><code></code></span>
<span class="codeline" id="line-892"><code>	if string(result.Rows[0][0]) != "t" {</code></span>
<span class="codeline" id="line-893"><code>		return &amp;NotPreferredError{err: errors.New("server is not in hot standby mode")}</code></span>
<span class="codeline" id="line-894"><code>	}</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>	return nil</code></span>
<span class="codeline" id="line-897"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>