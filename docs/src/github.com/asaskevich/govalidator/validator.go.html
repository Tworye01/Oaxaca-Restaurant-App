<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: validator.go in package github.com/asaskevich/govalidator</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	validator.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/asaskevich/govalidator.html">github.com/asaskevich/govalidator</a>
</code></pre>

<pre class="line-numbers">
<div class="anchor" id="doc"><span class="codeline" id="line-1"><code>// Package govalidator is package of validators and sanitizers for strings, structs and collections.</code></span></div><span class="codeline" id="line-2"><code>package govalidator</code></span>
<span class="codeline" id="line-3"><code></code></span>
<span class="codeline" id="line-4"><code>import (</code></span>
<span class="codeline" id="line-5"><code>	"bytes"</code></span>
<span class="codeline" id="line-6"><code>	"crypto/rsa"</code></span>
<span class="codeline" id="line-7"><code>	"crypto/x509"</code></span>
<span class="codeline" id="line-8"><code>	"encoding/base64"</code></span>
<span class="codeline" id="line-9"><code>	"encoding/json"</code></span>
<span class="codeline" id="line-10"><code>	"encoding/pem"</code></span>
<span class="codeline" id="line-11"><code>	"fmt"</code></span>
<span class="codeline" id="line-12"><code>	"io/ioutil"</code></span>
<span class="codeline" id="line-13"><code>	"net"</code></span>
<span class="codeline" id="line-14"><code>	"net/url"</code></span>
<span class="codeline" id="line-15"><code>	"reflect"</code></span>
<span class="codeline" id="line-16"><code>	"regexp"</code></span>
<span class="codeline" id="line-17"><code>	"sort"</code></span>
<span class="codeline" id="line-18"><code>	"strconv"</code></span>
<span class="codeline" id="line-19"><code>	"strings"</code></span>
<span class="codeline" id="line-20"><code>	"time"</code></span>
<span class="codeline" id="line-21"><code>	"unicode"</code></span>
<span class="codeline" id="line-22"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-23"><code>)</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>var (</code></span>
<span class="codeline" id="line-26"><code>	fieldsRequiredByDefault bool</code></span>
<span class="codeline" id="line-27"><code>	nilPtrAllowedByRequired = false</code></span>
<span class="codeline" id="line-28"><code>	notNumberRegexp         = regexp.MustCompile("[^0-9]+")</code></span>
<span class="codeline" id="line-29"><code>	whiteSpacesAndMinus     = regexp.MustCompile(`[\s-]+`)</code></span>
<span class="codeline" id="line-30"><code>	paramsRegexp            = regexp.MustCompile(`\(.*\)$`)</code></span>
<span class="codeline" id="line-31"><code>)</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>const maxURLRuneCount = 2083</code></span>
<span class="codeline" id="line-34"><code>const minURLRuneCount = 3</code></span>
<span class="codeline" id="line-35"><code>const rfc3339WithoutZone = "2006-01-02T15:04:05"</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>// SetFieldsRequiredByDefault causes validation to fail when struct fields</code></span>
<span class="codeline" id="line-38"><code>// do not include validations or are not explicitly marked as exempt (using `valid:"-"` or `valid:"email,optional"`).</code></span>
<span class="codeline" id="line-39"><code>// This struct definition will fail govalidator.ValidateStruct() (and the field values do not matter):</code></span>
<span class="codeline" id="line-40"><code>//     type exampleStruct struct {</code></span>
<span class="codeline" id="line-41"><code>//         Name  string ``</code></span>
<span class="codeline" id="line-42"><code>//         Email string `valid:"email"`</code></span>
<span class="codeline" id="line-43"><code>// This, however, will only fail when Email is empty or an invalid email address:</code></span>
<span class="codeline" id="line-44"><code>//     type exampleStruct2 struct {</code></span>
<span class="codeline" id="line-45"><code>//         Name  string `valid:"-"`</code></span>
<span class="codeline" id="line-46"><code>//         Email string `valid:"email"`</code></span>
<span class="codeline" id="line-47"><code>// Lastly, this will only fail when Email is an invalid email address but not when it's empty:</code></span>
<span class="codeline" id="line-48"><code>//     type exampleStruct2 struct {</code></span>
<span class="codeline" id="line-49"><code>//         Name  string `valid:"-"`</code></span>
<span class="codeline" id="line-50"><code>//         Email string `valid:"email,optional"`</code></span>
<span class="codeline" id="line-51"><code>func SetFieldsRequiredByDefault(value bool) {</code></span>
<span class="codeline" id="line-52"><code>	fieldsRequiredByDefault = value</code></span>
<span class="codeline" id="line-53"><code>}</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>// SetNilPtrAllowedByRequired causes validation to pass for nil ptrs when a field is set to required.</code></span>
<span class="codeline" id="line-56"><code>// The validation will still reject ptr fields in their zero value state. Example with this enabled:</code></span>
<span class="codeline" id="line-57"><code>//     type exampleStruct struct {</code></span>
<span class="codeline" id="line-58"><code>//         Name  *string `valid:"required"`</code></span>
<span class="codeline" id="line-59"><code>// With `Name` set to "", this will be considered invalid input and will cause a validation error.</code></span>
<span class="codeline" id="line-60"><code>// With `Name` set to nil, this will be considered valid by validation.</code></span>
<span class="codeline" id="line-61"><code>// By default this is disabled.</code></span>
<span class="codeline" id="line-62"><code>func SetNilPtrAllowedByRequired(value bool) {</code></span>
<span class="codeline" id="line-63"><code>	nilPtrAllowedByRequired = value</code></span>
<span class="codeline" id="line-64"><code>}</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// IsEmail checks if the string is an email.</code></span>
<span class="codeline" id="line-67"><code>func IsEmail(str string) bool {</code></span>
<span class="codeline" id="line-68"><code>	// TODO uppercase letters are not supported</code></span>
<span class="codeline" id="line-69"><code>	return rxEmail.MatchString(str)</code></span>
<span class="codeline" id="line-70"><code>}</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>// IsExistingEmail checks if the string is an email of existing domain</code></span>
<span class="codeline" id="line-73"><code>func IsExistingEmail(email string) bool {</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>	if len(email) &lt; 6 || len(email) &gt; 254 {</code></span>
<span class="codeline" id="line-76"><code>		return false</code></span>
<span class="codeline" id="line-77"><code>	}</code></span>
<span class="codeline" id="line-78"><code>	at := strings.LastIndex(email, "@")</code></span>
<span class="codeline" id="line-79"><code>	if at &lt;= 0 || at &gt; len(email)-3 {</code></span>
<span class="codeline" id="line-80"><code>		return false</code></span>
<span class="codeline" id="line-81"><code>	}</code></span>
<span class="codeline" id="line-82"><code>	user := email[:at]</code></span>
<span class="codeline" id="line-83"><code>	host := email[at+1:]</code></span>
<span class="codeline" id="line-84"><code>	if len(user) &gt; 64 {</code></span>
<span class="codeline" id="line-85"><code>		return false</code></span>
<span class="codeline" id="line-86"><code>	}</code></span>
<span class="codeline" id="line-87"><code>	switch host {</code></span>
<span class="codeline" id="line-88"><code>	case "localhost", "example.com":</code></span>
<span class="codeline" id="line-89"><code>		return true</code></span>
<span class="codeline" id="line-90"><code>	}</code></span>
<span class="codeline" id="line-91"><code>	if userDotRegexp.MatchString(user) || !userRegexp.MatchString(user) || !hostRegexp.MatchString(host) {</code></span>
<span class="codeline" id="line-92"><code>		return false</code></span>
<span class="codeline" id="line-93"><code>	}</code></span>
<span class="codeline" id="line-94"><code>	if _, err := net.LookupMX(host); err != nil {</code></span>
<span class="codeline" id="line-95"><code>		if _, err := net.LookupIP(host); err != nil {</code></span>
<span class="codeline" id="line-96"><code>			return false</code></span>
<span class="codeline" id="line-97"><code>		}</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>	return true</code></span>
<span class="codeline" id="line-101"><code>}</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>// IsURL checks if the string is an URL.</code></span>
<span class="codeline" id="line-104"><code>func IsURL(str string) bool {</code></span>
<span class="codeline" id="line-105"><code>	if str == "" || utf8.RuneCountInString(str) &gt;= maxURLRuneCount || len(str) &lt;= minURLRuneCount || strings.HasPrefix(str, ".") {</code></span>
<span class="codeline" id="line-106"><code>		return false</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code>	strTemp := str</code></span>
<span class="codeline" id="line-109"><code>	if strings.Contains(str, ":") &amp;&amp; !strings.Contains(str, "://") {</code></span>
<span class="codeline" id="line-110"><code>		// support no indicated urlscheme but with colon for port number</code></span>
<span class="codeline" id="line-111"><code>		// http:// is appended so url.Parse will succeed, strTemp used so it does not impact rxURL.MatchString</code></span>
<span class="codeline" id="line-112"><code>		strTemp = "http://" + str</code></span>
<span class="codeline" id="line-113"><code>	}</code></span>
<span class="codeline" id="line-114"><code>	u, err := url.Parse(strTemp)</code></span>
<span class="codeline" id="line-115"><code>	if err != nil {</code></span>
<span class="codeline" id="line-116"><code>		return false</code></span>
<span class="codeline" id="line-117"><code>	}</code></span>
<span class="codeline" id="line-118"><code>	if strings.HasPrefix(u.Host, ".") {</code></span>
<span class="codeline" id="line-119"><code>		return false</code></span>
<span class="codeline" id="line-120"><code>	}</code></span>
<span class="codeline" id="line-121"><code>	if u.Host == "" &amp;&amp; (u.Path != "" &amp;&amp; !strings.Contains(u.Path, ".")) {</code></span>
<span class="codeline" id="line-122"><code>		return false</code></span>
<span class="codeline" id="line-123"><code>	}</code></span>
<span class="codeline" id="line-124"><code>	return rxURL.MatchString(str)</code></span>
<span class="codeline" id="line-125"><code>}</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// IsRequestURL checks if the string rawurl, assuming</code></span>
<span class="codeline" id="line-128"><code>// it was received in an HTTP request, is a valid</code></span>
<span class="codeline" id="line-129"><code>// URL confirm to RFC 3986</code></span>
<span class="codeline" id="line-130"><code>func IsRequestURL(rawurl string) bool {</code></span>
<span class="codeline" id="line-131"><code>	url, err := url.ParseRequestURI(rawurl)</code></span>
<span class="codeline" id="line-132"><code>	if err != nil {</code></span>
<span class="codeline" id="line-133"><code>		return false //Couldn't even parse the rawurl</code></span>
<span class="codeline" id="line-134"><code>	}</code></span>
<span class="codeline" id="line-135"><code>	if len(url.Scheme) == 0 {</code></span>
<span class="codeline" id="line-136"><code>		return false //No Scheme found</code></span>
<span class="codeline" id="line-137"><code>	}</code></span>
<span class="codeline" id="line-138"><code>	return true</code></span>
<span class="codeline" id="line-139"><code>}</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>// IsRequestURI checks if the string rawurl, assuming</code></span>
<span class="codeline" id="line-142"><code>// it was received in an HTTP request, is an</code></span>
<span class="codeline" id="line-143"><code>// absolute URI or an absolute path.</code></span>
<span class="codeline" id="line-144"><code>func IsRequestURI(rawurl string) bool {</code></span>
<span class="codeline" id="line-145"><code>	_, err := url.ParseRequestURI(rawurl)</code></span>
<span class="codeline" id="line-146"><code>	return err == nil</code></span>
<span class="codeline" id="line-147"><code>}</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>// IsAlpha checks if the string contains only letters (a-zA-Z). Empty string is valid.</code></span>
<span class="codeline" id="line-150"><code>func IsAlpha(str string) bool {</code></span>
<span class="codeline" id="line-151"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-152"><code>		return true</code></span>
<span class="codeline" id="line-153"><code>	}</code></span>
<span class="codeline" id="line-154"><code>	return rxAlpha.MatchString(str)</code></span>
<span class="codeline" id="line-155"><code>}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>//IsUTFLetter checks if the string contains only unicode letter characters.</code></span>
<span class="codeline" id="line-158"><code>//Similar to IsAlpha but for all languages. Empty string is valid.</code></span>
<span class="codeline" id="line-159"><code>func IsUTFLetter(str string) bool {</code></span>
<span class="codeline" id="line-160"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-161"><code>		return true</code></span>
<span class="codeline" id="line-162"><code>	}</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	for _, c := range str {</code></span>
<span class="codeline" id="line-165"><code>		if !unicode.IsLetter(c) {</code></span>
<span class="codeline" id="line-166"><code>			return false</code></span>
<span class="codeline" id="line-167"><code>		}</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>	return true</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>// IsAlphanumeric checks if the string contains only letters and numbers. Empty string is valid.</code></span>
<span class="codeline" id="line-174"><code>func IsAlphanumeric(str string) bool {</code></span>
<span class="codeline" id="line-175"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-176"><code>		return true</code></span>
<span class="codeline" id="line-177"><code>	}</code></span>
<span class="codeline" id="line-178"><code>	return rxAlphanumeric.MatchString(str)</code></span>
<span class="codeline" id="line-179"><code>}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>// IsUTFLetterNumeric checks if the string contains only unicode letters and numbers. Empty string is valid.</code></span>
<span class="codeline" id="line-182"><code>func IsUTFLetterNumeric(str string) bool {</code></span>
<span class="codeline" id="line-183"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-184"><code>		return true</code></span>
<span class="codeline" id="line-185"><code>	}</code></span>
<span class="codeline" id="line-186"><code>	for _, c := range str {</code></span>
<span class="codeline" id="line-187"><code>		if !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) { //letters &amp;&amp; numbers are ok</code></span>
<span class="codeline" id="line-188"><code>			return false</code></span>
<span class="codeline" id="line-189"><code>		}</code></span>
<span class="codeline" id="line-190"><code>	}</code></span>
<span class="codeline" id="line-191"><code>	return true</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>}</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>// IsNumeric checks if the string contains only numbers. Empty string is valid.</code></span>
<span class="codeline" id="line-196"><code>func IsNumeric(str string) bool {</code></span>
<span class="codeline" id="line-197"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-198"><code>		return true</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	return rxNumeric.MatchString(str)</code></span>
<span class="codeline" id="line-201"><code>}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// IsUTFNumeric checks if the string contains only unicode numbers of any kind.</code></span>
<span class="codeline" id="line-204"><code>// Numbers can be 0-9 but also Fractions ¾,Roman Ⅸ and Hangzhou 〩. Empty string is valid.</code></span>
<span class="codeline" id="line-205"><code>func IsUTFNumeric(str string) bool {</code></span>
<span class="codeline" id="line-206"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-207"><code>		return true</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>	if strings.IndexAny(str, "+-") &gt; 0 {</code></span>
<span class="codeline" id="line-210"><code>		return false</code></span>
<span class="codeline" id="line-211"><code>	}</code></span>
<span class="codeline" id="line-212"><code>	if len(str) &gt; 1 {</code></span>
<span class="codeline" id="line-213"><code>		str = strings.TrimPrefix(str, "-")</code></span>
<span class="codeline" id="line-214"><code>		str = strings.TrimPrefix(str, "+")</code></span>
<span class="codeline" id="line-215"><code>	}</code></span>
<span class="codeline" id="line-216"><code>	for _, c := range str {</code></span>
<span class="codeline" id="line-217"><code>		if !unicode.IsNumber(c) { //numbers &amp;&amp; minus sign are ok</code></span>
<span class="codeline" id="line-218"><code>			return false</code></span>
<span class="codeline" id="line-219"><code>		}</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code>	return true</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>// IsUTFDigit checks if the string contains only unicode radix-10 decimal digits. Empty string is valid.</code></span>
<span class="codeline" id="line-226"><code>func IsUTFDigit(str string) bool {</code></span>
<span class="codeline" id="line-227"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-228"><code>		return true</code></span>
<span class="codeline" id="line-229"><code>	}</code></span>
<span class="codeline" id="line-230"><code>	if strings.IndexAny(str, "+-") &gt; 0 {</code></span>
<span class="codeline" id="line-231"><code>		return false</code></span>
<span class="codeline" id="line-232"><code>	}</code></span>
<span class="codeline" id="line-233"><code>	if len(str) &gt; 1 {</code></span>
<span class="codeline" id="line-234"><code>		str = strings.TrimPrefix(str, "-")</code></span>
<span class="codeline" id="line-235"><code>		str = strings.TrimPrefix(str, "+")</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	for _, c := range str {</code></span>
<span class="codeline" id="line-238"><code>		if !unicode.IsDigit(c) { //digits &amp;&amp; minus sign are ok</code></span>
<span class="codeline" id="line-239"><code>			return false</code></span>
<span class="codeline" id="line-240"><code>		}</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code>	return true</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>// IsHexadecimal checks if the string is a hexadecimal number.</code></span>
<span class="codeline" id="line-247"><code>func IsHexadecimal(str string) bool {</code></span>
<span class="codeline" id="line-248"><code>	return rxHexadecimal.MatchString(str)</code></span>
<span class="codeline" id="line-249"><code>}</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>// IsHexcolor checks if the string is a hexadecimal color.</code></span>
<span class="codeline" id="line-252"><code>func IsHexcolor(str string) bool {</code></span>
<span class="codeline" id="line-253"><code>	return rxHexcolor.MatchString(str)</code></span>
<span class="codeline" id="line-254"><code>}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// IsRGBcolor checks if the string is a valid RGB color in form rgb(RRR, GGG, BBB).</code></span>
<span class="codeline" id="line-257"><code>func IsRGBcolor(str string) bool {</code></span>
<span class="codeline" id="line-258"><code>	return rxRGBcolor.MatchString(str)</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// IsLowerCase checks if the string is lowercase. Empty string is valid.</code></span>
<span class="codeline" id="line-262"><code>func IsLowerCase(str string) bool {</code></span>
<span class="codeline" id="line-263"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-264"><code>		return true</code></span>
<span class="codeline" id="line-265"><code>	}</code></span>
<span class="codeline" id="line-266"><code>	return str == strings.ToLower(str)</code></span>
<span class="codeline" id="line-267"><code>}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// IsUpperCase checks if the string is uppercase. Empty string is valid.</code></span>
<span class="codeline" id="line-270"><code>func IsUpperCase(str string) bool {</code></span>
<span class="codeline" id="line-271"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-272"><code>		return true</code></span>
<span class="codeline" id="line-273"><code>	}</code></span>
<span class="codeline" id="line-274"><code>	return str == strings.ToUpper(str)</code></span>
<span class="codeline" id="line-275"><code>}</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// HasLowerCase checks if the string contains at least 1 lowercase. Empty string is valid.</code></span>
<span class="codeline" id="line-278"><code>func HasLowerCase(str string) bool {</code></span>
<span class="codeline" id="line-279"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-280"><code>		return true</code></span>
<span class="codeline" id="line-281"><code>	}</code></span>
<span class="codeline" id="line-282"><code>	return rxHasLowerCase.MatchString(str)</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// HasUpperCase checks if the string contains as least 1 uppercase. Empty string is valid.</code></span>
<span class="codeline" id="line-286"><code>func HasUpperCase(str string) bool {</code></span>
<span class="codeline" id="line-287"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-288"><code>		return true</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	return rxHasUpperCase.MatchString(str)</code></span>
<span class="codeline" id="line-291"><code>}</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>// IsInt checks if the string is an integer. Empty string is valid.</code></span>
<span class="codeline" id="line-294"><code>func IsInt(str string) bool {</code></span>
<span class="codeline" id="line-295"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-296"><code>		return true</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>	return rxInt.MatchString(str)</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// IsFloat checks if the string is a float.</code></span>
<span class="codeline" id="line-302"><code>func IsFloat(str string) bool {</code></span>
<span class="codeline" id="line-303"><code>	return str != "" &amp;&amp; rxFloat.MatchString(str)</code></span>
<span class="codeline" id="line-304"><code>}</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>// IsDivisibleBy checks if the string is a number that's divisible by another.</code></span>
<span class="codeline" id="line-307"><code>// If second argument is not valid integer or zero, it's return false.</code></span>
<span class="codeline" id="line-308"><code>// Otherwise, if first argument is not valid integer or zero, it's return true (Invalid string converts to zero).</code></span>
<span class="codeline" id="line-309"><code>func IsDivisibleBy(str, num string) bool {</code></span>
<span class="codeline" id="line-310"><code>	f, _ := ToFloat(str)</code></span>
<span class="codeline" id="line-311"><code>	p := int64(f)</code></span>
<span class="codeline" id="line-312"><code>	q, _ := ToInt(num)</code></span>
<span class="codeline" id="line-313"><code>	if q == 0 {</code></span>
<span class="codeline" id="line-314"><code>		return false</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code>	return (p == 0) || (p%q == 0)</code></span>
<span class="codeline" id="line-317"><code>}</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>// IsNull checks if the string is null.</code></span>
<span class="codeline" id="line-320"><code>func IsNull(str string) bool {</code></span>
<span class="codeline" id="line-321"><code>	return len(str) == 0</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// IsNotNull checks if the string is not null.</code></span>
<span class="codeline" id="line-325"><code>func IsNotNull(str string) bool {</code></span>
<span class="codeline" id="line-326"><code>	return !IsNull(str)</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>// HasWhitespaceOnly checks the string only contains whitespace</code></span>
<span class="codeline" id="line-330"><code>func HasWhitespaceOnly(str string) bool {</code></span>
<span class="codeline" id="line-331"><code>	return len(str) &gt; 0 &amp;&amp; rxHasWhitespaceOnly.MatchString(str)</code></span>
<span class="codeline" id="line-332"><code>}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>// HasWhitespace checks if the string contains any whitespace</code></span>
<span class="codeline" id="line-335"><code>func HasWhitespace(str string) bool {</code></span>
<span class="codeline" id="line-336"><code>	return len(str) &gt; 0 &amp;&amp; rxHasWhitespace.MatchString(str)</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// IsByteLength checks if the string's length (in bytes) falls in a range.</code></span>
<span class="codeline" id="line-340"><code>func IsByteLength(str string, min, max int) bool {</code></span>
<span class="codeline" id="line-341"><code>	return len(str) &gt;= min &amp;&amp; len(str) &lt;= max</code></span>
<span class="codeline" id="line-342"><code>}</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>// IsUUIDv3 checks if the string is a UUID version 3.</code></span>
<span class="codeline" id="line-345"><code>func IsUUIDv3(str string) bool {</code></span>
<span class="codeline" id="line-346"><code>	return rxUUID3.MatchString(str)</code></span>
<span class="codeline" id="line-347"><code>}</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>// IsUUIDv4 checks if the string is a UUID version 4.</code></span>
<span class="codeline" id="line-350"><code>func IsUUIDv4(str string) bool {</code></span>
<span class="codeline" id="line-351"><code>	return rxUUID4.MatchString(str)</code></span>
<span class="codeline" id="line-352"><code>}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>// IsUUIDv5 checks if the string is a UUID version 5.</code></span>
<span class="codeline" id="line-355"><code>func IsUUIDv5(str string) bool {</code></span>
<span class="codeline" id="line-356"><code>	return rxUUID5.MatchString(str)</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>// IsUUID checks if the string is a UUID (version 3, 4 or 5).</code></span>
<span class="codeline" id="line-360"><code>func IsUUID(str string) bool {</code></span>
<span class="codeline" id="line-361"><code>	return rxUUID.MatchString(str)</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>// Byte to index table for O(1) lookups when unmarshaling.</code></span>
<span class="codeline" id="line-365"><code>// We use 0xFF as sentinel value for invalid indexes.</code></span>
<span class="codeline" id="line-366"><code>var ulidDec = [...]byte{</code></span>
<span class="codeline" id="line-367"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-368"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-369"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-370"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-371"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,</code></span>
<span class="codeline" id="line-372"><code>	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-373"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,</code></span>
<span class="codeline" id="line-374"><code>	0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14, 0x15, 0xFF,</code></span>
<span class="codeline" id="line-375"><code>	0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C, 0x1D, 0x1E,</code></span>
<span class="codeline" id="line-376"><code>	0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,</code></span>
<span class="codeline" id="line-377"><code>	0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,</code></span>
<span class="codeline" id="line-378"><code>	0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,</code></span>
<span class="codeline" id="line-379"><code>	0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-380"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-381"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-382"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-383"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-384"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-385"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-386"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-387"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-388"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-389"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-390"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-391"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-392"><code>	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,</code></span>
<span class="codeline" id="line-393"><code>}</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>// EncodedSize is the length of a text encoded ULID.</code></span>
<span class="codeline" id="line-396"><code>const ulidEncodedSize = 26</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>// IsULID checks if the string is a ULID.</code></span>
<span class="codeline" id="line-399"><code>//</code></span>
<span class="codeline" id="line-400"><code>// Implementation got from:</code></span>
<span class="codeline" id="line-401"><code>//   https://github.com/oklog/ulid (Apache-2.0 License)</code></span>
<span class="codeline" id="line-402"><code>//</code></span>
<span class="codeline" id="line-403"><code>func IsULID(str string) bool {</code></span>
<span class="codeline" id="line-404"><code>	// Check if a base32 encoded ULID is the right length.</code></span>
<span class="codeline" id="line-405"><code>	if len(str) != ulidEncodedSize {</code></span>
<span class="codeline" id="line-406"><code>		return false</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>	// Check if all the characters in a base32 encoded ULID are part of the</code></span>
<span class="codeline" id="line-410"><code>	// expected base32 character set.</code></span>
<span class="codeline" id="line-411"><code>	if ulidDec[str[0]] == 0xFF ||</code></span>
<span class="codeline" id="line-412"><code>		ulidDec[str[1]] == 0xFF ||</code></span>
<span class="codeline" id="line-413"><code>		ulidDec[str[2]] == 0xFF ||</code></span>
<span class="codeline" id="line-414"><code>		ulidDec[str[3]] == 0xFF ||</code></span>
<span class="codeline" id="line-415"><code>		ulidDec[str[4]] == 0xFF ||</code></span>
<span class="codeline" id="line-416"><code>		ulidDec[str[5]] == 0xFF ||</code></span>
<span class="codeline" id="line-417"><code>		ulidDec[str[6]] == 0xFF ||</code></span>
<span class="codeline" id="line-418"><code>		ulidDec[str[7]] == 0xFF ||</code></span>
<span class="codeline" id="line-419"><code>		ulidDec[str[8]] == 0xFF ||</code></span>
<span class="codeline" id="line-420"><code>		ulidDec[str[9]] == 0xFF ||</code></span>
<span class="codeline" id="line-421"><code>		ulidDec[str[10]] == 0xFF ||</code></span>
<span class="codeline" id="line-422"><code>		ulidDec[str[11]] == 0xFF ||</code></span>
<span class="codeline" id="line-423"><code>		ulidDec[str[12]] == 0xFF ||</code></span>
<span class="codeline" id="line-424"><code>		ulidDec[str[13]] == 0xFF ||</code></span>
<span class="codeline" id="line-425"><code>		ulidDec[str[14]] == 0xFF ||</code></span>
<span class="codeline" id="line-426"><code>		ulidDec[str[15]] == 0xFF ||</code></span>
<span class="codeline" id="line-427"><code>		ulidDec[str[16]] == 0xFF ||</code></span>
<span class="codeline" id="line-428"><code>		ulidDec[str[17]] == 0xFF ||</code></span>
<span class="codeline" id="line-429"><code>		ulidDec[str[18]] == 0xFF ||</code></span>
<span class="codeline" id="line-430"><code>		ulidDec[str[19]] == 0xFF ||</code></span>
<span class="codeline" id="line-431"><code>		ulidDec[str[20]] == 0xFF ||</code></span>
<span class="codeline" id="line-432"><code>		ulidDec[str[21]] == 0xFF ||</code></span>
<span class="codeline" id="line-433"><code>		ulidDec[str[22]] == 0xFF ||</code></span>
<span class="codeline" id="line-434"><code>		ulidDec[str[23]] == 0xFF ||</code></span>
<span class="codeline" id="line-435"><code>		ulidDec[str[24]] == 0xFF ||</code></span>
<span class="codeline" id="line-436"><code>		ulidDec[str[25]] == 0xFF {</code></span>
<span class="codeline" id="line-437"><code>		return false</code></span>
<span class="codeline" id="line-438"><code>	}</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>	// Check if the first character in a base32 encoded ULID will overflow. This</code></span>
<span class="codeline" id="line-441"><code>	// happens because the base32 representation encodes 130 bits, while the</code></span>
<span class="codeline" id="line-442"><code>	// ULID is only 128 bits.</code></span>
<span class="codeline" id="line-443"><code>	//</code></span>
<span class="codeline" id="line-444"><code>	// See https://github.com/oklog/ulid/issues/9 for details.</code></span>
<span class="codeline" id="line-445"><code>	if str[0] &gt; '7' {</code></span>
<span class="codeline" id="line-446"><code>		return false</code></span>
<span class="codeline" id="line-447"><code>	}</code></span>
<span class="codeline" id="line-448"><code>	return true</code></span>
<span class="codeline" id="line-449"><code>}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>// IsCreditCard checks if the string is a credit card.</code></span>
<span class="codeline" id="line-452"><code>func IsCreditCard(str string) bool {</code></span>
<span class="codeline" id="line-453"><code>	sanitized := whiteSpacesAndMinus.ReplaceAllString(str, "")</code></span>
<span class="codeline" id="line-454"><code>	if !rxCreditCard.MatchString(sanitized) {</code></span>
<span class="codeline" id="line-455"><code>		return false</code></span>
<span class="codeline" id="line-456"><code>	}</code></span>
<span class="codeline" id="line-457"><code>	</code></span>
<span class="codeline" id="line-458"><code>	number, _ := ToInt(sanitized)</code></span>
<span class="codeline" id="line-459"><code>	number, lastDigit := number / 10, number % 10	</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	var sum int64</code></span>
<span class="codeline" id="line-462"><code>	for i:=0; number &gt; 0; i++ {</code></span>
<span class="codeline" id="line-463"><code>		digit := number % 10</code></span>
<span class="codeline" id="line-464"><code>		</code></span>
<span class="codeline" id="line-465"><code>		if i % 2 == 0 {</code></span>
<span class="codeline" id="line-466"><code>			digit *= 2</code></span>
<span class="codeline" id="line-467"><code>			if digit &gt; 9 {</code></span>
<span class="codeline" id="line-468"><code>				digit -= 9</code></span>
<span class="codeline" id="line-469"><code>			}</code></span>
<span class="codeline" id="line-470"><code>		}</code></span>
<span class="codeline" id="line-471"><code>		</code></span>
<span class="codeline" id="line-472"><code>		sum += digit</code></span>
<span class="codeline" id="line-473"><code>		number = number / 10</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>	</code></span>
<span class="codeline" id="line-476"><code>	return (sum + lastDigit) % 10 == 0</code></span>
<span class="codeline" id="line-477"><code>}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>// IsISBN10 checks if the string is an ISBN version 10.</code></span>
<span class="codeline" id="line-480"><code>func IsISBN10(str string) bool {</code></span>
<span class="codeline" id="line-481"><code>	return IsISBN(str, 10)</code></span>
<span class="codeline" id="line-482"><code>}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>// IsISBN13 checks if the string is an ISBN version 13.</code></span>
<span class="codeline" id="line-485"><code>func IsISBN13(str string) bool {</code></span>
<span class="codeline" id="line-486"><code>	return IsISBN(str, 13)</code></span>
<span class="codeline" id="line-487"><code>}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>// IsISBN checks if the string is an ISBN (version 10 or 13).</code></span>
<span class="codeline" id="line-490"><code>// If version value is not equal to 10 or 13, it will be checks both variants.</code></span>
<span class="codeline" id="line-491"><code>func IsISBN(str string, version int) bool {</code></span>
<span class="codeline" id="line-492"><code>	sanitized := whiteSpacesAndMinus.ReplaceAllString(str, "")</code></span>
<span class="codeline" id="line-493"><code>	var checksum int32</code></span>
<span class="codeline" id="line-494"><code>	var i int32</code></span>
<span class="codeline" id="line-495"><code>	if version == 10 {</code></span>
<span class="codeline" id="line-496"><code>		if !rxISBN10.MatchString(sanitized) {</code></span>
<span class="codeline" id="line-497"><code>			return false</code></span>
<span class="codeline" id="line-498"><code>		}</code></span>
<span class="codeline" id="line-499"><code>		for i = 0; i &lt; 9; i++ {</code></span>
<span class="codeline" id="line-500"><code>			checksum += (i + 1) * int32(sanitized[i]-'0')</code></span>
<span class="codeline" id="line-501"><code>		}</code></span>
<span class="codeline" id="line-502"><code>		if sanitized[9] == 'X' {</code></span>
<span class="codeline" id="line-503"><code>			checksum += 10 * 10</code></span>
<span class="codeline" id="line-504"><code>		} else {</code></span>
<span class="codeline" id="line-505"><code>			checksum += 10 * int32(sanitized[9]-'0')</code></span>
<span class="codeline" id="line-506"><code>		}</code></span>
<span class="codeline" id="line-507"><code>		if checksum%11 == 0 {</code></span>
<span class="codeline" id="line-508"><code>			return true</code></span>
<span class="codeline" id="line-509"><code>		}</code></span>
<span class="codeline" id="line-510"><code>		return false</code></span>
<span class="codeline" id="line-511"><code>	} else if version == 13 {</code></span>
<span class="codeline" id="line-512"><code>		if !rxISBN13.MatchString(sanitized) {</code></span>
<span class="codeline" id="line-513"><code>			return false</code></span>
<span class="codeline" id="line-514"><code>		}</code></span>
<span class="codeline" id="line-515"><code>		factor := []int32{1, 3}</code></span>
<span class="codeline" id="line-516"><code>		for i = 0; i &lt; 12; i++ {</code></span>
<span class="codeline" id="line-517"><code>			checksum += factor[i%2] * int32(sanitized[i]-'0')</code></span>
<span class="codeline" id="line-518"><code>		}</code></span>
<span class="codeline" id="line-519"><code>		return (int32(sanitized[12]-'0'))-((10-(checksum%10))%10) == 0</code></span>
<span class="codeline" id="line-520"><code>	}</code></span>
<span class="codeline" id="line-521"><code>	return IsISBN(str, 10) || IsISBN(str, 13)</code></span>
<span class="codeline" id="line-522"><code>}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>// IsJSON checks if the string is valid JSON (note: uses json.Unmarshal).</code></span>
<span class="codeline" id="line-525"><code>func IsJSON(str string) bool {</code></span>
<span class="codeline" id="line-526"><code>	var js json.RawMessage</code></span>
<span class="codeline" id="line-527"><code>	return json.Unmarshal([]byte(str), &amp;js) == nil</code></span>
<span class="codeline" id="line-528"><code>}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>// IsMultibyte checks if the string contains one or more multibyte chars. Empty string is valid.</code></span>
<span class="codeline" id="line-531"><code>func IsMultibyte(str string) bool {</code></span>
<span class="codeline" id="line-532"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-533"><code>		return true</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>	return rxMultibyte.MatchString(str)</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// IsASCII checks if the string contains ASCII chars only. Empty string is valid.</code></span>
<span class="codeline" id="line-539"><code>func IsASCII(str string) bool {</code></span>
<span class="codeline" id="line-540"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-541"><code>		return true</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code>	return rxASCII.MatchString(str)</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>// IsPrintableASCII checks if the string contains printable ASCII chars only. Empty string is valid.</code></span>
<span class="codeline" id="line-547"><code>func IsPrintableASCII(str string) bool {</code></span>
<span class="codeline" id="line-548"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-549"><code>		return true</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code>	return rxPrintableASCII.MatchString(str)</code></span>
<span class="codeline" id="line-552"><code>}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>// IsFullWidth checks if the string contains any full-width chars. Empty string is valid.</code></span>
<span class="codeline" id="line-555"><code>func IsFullWidth(str string) bool {</code></span>
<span class="codeline" id="line-556"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-557"><code>		return true</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code>	return rxFullWidth.MatchString(str)</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// IsHalfWidth checks if the string contains any half-width chars. Empty string is valid.</code></span>
<span class="codeline" id="line-563"><code>func IsHalfWidth(str string) bool {</code></span>
<span class="codeline" id="line-564"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-565"><code>		return true</code></span>
<span class="codeline" id="line-566"><code>	}</code></span>
<span class="codeline" id="line-567"><code>	return rxHalfWidth.MatchString(str)</code></span>
<span class="codeline" id="line-568"><code>}</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>// IsVariableWidth checks if the string contains a mixture of full and half-width chars. Empty string is valid.</code></span>
<span class="codeline" id="line-571"><code>func IsVariableWidth(str string) bool {</code></span>
<span class="codeline" id="line-572"><code>	if IsNull(str) {</code></span>
<span class="codeline" id="line-573"><code>		return true</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	return rxHalfWidth.MatchString(str) &amp;&amp; rxFullWidth.MatchString(str)</code></span>
<span class="codeline" id="line-576"><code>}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>// IsBase64 checks if a string is base64 encoded.</code></span>
<span class="codeline" id="line-579"><code>func IsBase64(str string) bool {</code></span>
<span class="codeline" id="line-580"><code>	return rxBase64.MatchString(str)</code></span>
<span class="codeline" id="line-581"><code>}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>// IsFilePath checks is a string is Win or Unix file path and returns it's type.</code></span>
<span class="codeline" id="line-584"><code>func IsFilePath(str string) (bool, int) {</code></span>
<span class="codeline" id="line-585"><code>	if rxWinPath.MatchString(str) {</code></span>
<span class="codeline" id="line-586"><code>		//check windows path limit see:</code></span>
<span class="codeline" id="line-587"><code>		//  http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath</code></span>
<span class="codeline" id="line-588"><code>		if len(str[3:]) &gt; 32767 {</code></span>
<span class="codeline" id="line-589"><code>			return false, Win</code></span>
<span class="codeline" id="line-590"><code>		}</code></span>
<span class="codeline" id="line-591"><code>		return true, Win</code></span>
<span class="codeline" id="line-592"><code>	} else if rxUnixPath.MatchString(str) {</code></span>
<span class="codeline" id="line-593"><code>		return true, Unix</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code>	return false, Unknown</code></span>
<span class="codeline" id="line-596"><code>}</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>//IsWinFilePath checks both relative &amp; absolute paths in Windows</code></span>
<span class="codeline" id="line-599"><code>func IsWinFilePath(str string) bool {</code></span>
<span class="codeline" id="line-600"><code>	if rxARWinPath.MatchString(str) {</code></span>
<span class="codeline" id="line-601"><code>		//check windows path limit see:</code></span>
<span class="codeline" id="line-602"><code>		//  http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath</code></span>
<span class="codeline" id="line-603"><code>		if len(str[3:]) &gt; 32767 {</code></span>
<span class="codeline" id="line-604"><code>			return false</code></span>
<span class="codeline" id="line-605"><code>		}</code></span>
<span class="codeline" id="line-606"><code>		return true</code></span>
<span class="codeline" id="line-607"><code>	}</code></span>
<span class="codeline" id="line-608"><code>	return false</code></span>
<span class="codeline" id="line-609"><code>}</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>//IsUnixFilePath checks both relative &amp; absolute paths in Unix</code></span>
<span class="codeline" id="line-612"><code>func IsUnixFilePath(str string) bool {</code></span>
<span class="codeline" id="line-613"><code>	if rxARUnixPath.MatchString(str) {</code></span>
<span class="codeline" id="line-614"><code>		return true</code></span>
<span class="codeline" id="line-615"><code>	}</code></span>
<span class="codeline" id="line-616"><code>	return false</code></span>
<span class="codeline" id="line-617"><code>}</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>// IsDataURI checks if a string is base64 encoded data URI such as an image</code></span>
<span class="codeline" id="line-620"><code>func IsDataURI(str string) bool {</code></span>
<span class="codeline" id="line-621"><code>	dataURI := strings.Split(str, ",")</code></span>
<span class="codeline" id="line-622"><code>	if !rxDataURI.MatchString(dataURI[0]) {</code></span>
<span class="codeline" id="line-623"><code>		return false</code></span>
<span class="codeline" id="line-624"><code>	}</code></span>
<span class="codeline" id="line-625"><code>	return IsBase64(dataURI[1])</code></span>
<span class="codeline" id="line-626"><code>}</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>// IsMagnetURI checks if a string is valid magnet URI</code></span>
<span class="codeline" id="line-629"><code>func IsMagnetURI(str string) bool {</code></span>
<span class="codeline" id="line-630"><code>	return rxMagnetURI.MatchString(str)</code></span>
<span class="codeline" id="line-631"><code>}</code></span>
<span class="codeline" id="line-632"><code></code></span>
<span class="codeline" id="line-633"><code>// IsISO3166Alpha2 checks if a string is valid two-letter country code</code></span>
<span class="codeline" id="line-634"><code>func IsISO3166Alpha2(str string) bool {</code></span>
<span class="codeline" id="line-635"><code>	for _, entry := range ISO3166List {</code></span>
<span class="codeline" id="line-636"><code>		if str == entry.Alpha2Code {</code></span>
<span class="codeline" id="line-637"><code>			return true</code></span>
<span class="codeline" id="line-638"><code>		}</code></span>
<span class="codeline" id="line-639"><code>	}</code></span>
<span class="codeline" id="line-640"><code>	return false</code></span>
<span class="codeline" id="line-641"><code>}</code></span>
<span class="codeline" id="line-642"><code></code></span>
<span class="codeline" id="line-643"><code>// IsISO3166Alpha3 checks if a string is valid three-letter country code</code></span>
<span class="codeline" id="line-644"><code>func IsISO3166Alpha3(str string) bool {</code></span>
<span class="codeline" id="line-645"><code>	for _, entry := range ISO3166List {</code></span>
<span class="codeline" id="line-646"><code>		if str == entry.Alpha3Code {</code></span>
<span class="codeline" id="line-647"><code>			return true</code></span>
<span class="codeline" id="line-648"><code>		}</code></span>
<span class="codeline" id="line-649"><code>	}</code></span>
<span class="codeline" id="line-650"><code>	return false</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>// IsISO693Alpha2 checks if a string is valid two-letter language code</code></span>
<span class="codeline" id="line-654"><code>func IsISO693Alpha2(str string) bool {</code></span>
<span class="codeline" id="line-655"><code>	for _, entry := range ISO693List {</code></span>
<span class="codeline" id="line-656"><code>		if str == entry.Alpha2Code {</code></span>
<span class="codeline" id="line-657"><code>			return true</code></span>
<span class="codeline" id="line-658"><code>		}</code></span>
<span class="codeline" id="line-659"><code>	}</code></span>
<span class="codeline" id="line-660"><code>	return false</code></span>
<span class="codeline" id="line-661"><code>}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>// IsISO693Alpha3b checks if a string is valid three-letter language code</code></span>
<span class="codeline" id="line-664"><code>func IsISO693Alpha3b(str string) bool {</code></span>
<span class="codeline" id="line-665"><code>	for _, entry := range ISO693List {</code></span>
<span class="codeline" id="line-666"><code>		if str == entry.Alpha3bCode {</code></span>
<span class="codeline" id="line-667"><code>			return true</code></span>
<span class="codeline" id="line-668"><code>		}</code></span>
<span class="codeline" id="line-669"><code>	}</code></span>
<span class="codeline" id="line-670"><code>	return false</code></span>
<span class="codeline" id="line-671"><code>}</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>// IsDNSName will validate the given string as a DNS name</code></span>
<span class="codeline" id="line-674"><code>func IsDNSName(str string) bool {</code></span>
<span class="codeline" id="line-675"><code>	if str == "" || len(strings.Replace(str, ".", "", -1)) &gt; 255 {</code></span>
<span class="codeline" id="line-676"><code>		// constraints already violated</code></span>
<span class="codeline" id="line-677"><code>		return false</code></span>
<span class="codeline" id="line-678"><code>	}</code></span>
<span class="codeline" id="line-679"><code>	return !IsIP(str) &amp;&amp; rxDNSName.MatchString(str)</code></span>
<span class="codeline" id="line-680"><code>}</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>// IsHash checks if a string is a hash of type algorithm.</code></span>
<span class="codeline" id="line-683"><code>// Algorithm is one of ['md4', 'md5', 'sha1', 'sha256', 'sha384', 'sha512', 'ripemd128', 'ripemd160', 'tiger128', 'tiger160', 'tiger192', 'crc32', 'crc32b']</code></span>
<span class="codeline" id="line-684"><code>func IsHash(str string, algorithm string) bool {</code></span>
<span class="codeline" id="line-685"><code>	var len string</code></span>
<span class="codeline" id="line-686"><code>	algo := strings.ToLower(algorithm)</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>	if algo == "crc32" || algo == "crc32b" {</code></span>
<span class="codeline" id="line-689"><code>		len = "8"</code></span>
<span class="codeline" id="line-690"><code>	} else if algo == "md5" || algo == "md4" || algo == "ripemd128" || algo == "tiger128" {</code></span>
<span class="codeline" id="line-691"><code>		len = "32"</code></span>
<span class="codeline" id="line-692"><code>	} else if algo == "sha1" || algo == "ripemd160" || algo == "tiger160" {</code></span>
<span class="codeline" id="line-693"><code>		len = "40"</code></span>
<span class="codeline" id="line-694"><code>	} else if algo == "tiger192" {</code></span>
<span class="codeline" id="line-695"><code>		len = "48"</code></span>
<span class="codeline" id="line-696"><code>	} else if algo == "sha3-224" {</code></span>
<span class="codeline" id="line-697"><code>		len = "56"</code></span>
<span class="codeline" id="line-698"><code>	} else if algo == "sha256" || algo == "sha3-256" {</code></span>
<span class="codeline" id="line-699"><code>		len = "64"</code></span>
<span class="codeline" id="line-700"><code>	} else if algo == "sha384" || algo == "sha3-384" {</code></span>
<span class="codeline" id="line-701"><code>		len = "96"</code></span>
<span class="codeline" id="line-702"><code>	} else if algo == "sha512" || algo == "sha3-512" {</code></span>
<span class="codeline" id="line-703"><code>		len = "128"</code></span>
<span class="codeline" id="line-704"><code>	} else {</code></span>
<span class="codeline" id="line-705"><code>		return false</code></span>
<span class="codeline" id="line-706"><code>	}</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>	return Matches(str, "^[a-f0-9]{"+len+"}$")</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>// IsSHA3224 checks is a string is a SHA3-224 hash. Alias for `IsHash(str, "sha3-224")`</code></span>
<span class="codeline" id="line-712"><code>func IsSHA3224(str string) bool {</code></span>
<span class="codeline" id="line-713"><code>	return IsHash(str, "sha3-224")</code></span>
<span class="codeline" id="line-714"><code>}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>// IsSHA3256 checks is a string is a SHA3-256 hash. Alias for `IsHash(str, "sha3-256")`</code></span>
<span class="codeline" id="line-717"><code>func IsSHA3256(str string) bool {</code></span>
<span class="codeline" id="line-718"><code>	return IsHash(str, "sha3-256")</code></span>
<span class="codeline" id="line-719"><code>}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>// IsSHA3384 checks is a string is a SHA3-384 hash. Alias for `IsHash(str, "sha3-384")`</code></span>
<span class="codeline" id="line-722"><code>func IsSHA3384(str string) bool {</code></span>
<span class="codeline" id="line-723"><code>	return IsHash(str, "sha3-384")</code></span>
<span class="codeline" id="line-724"><code>}</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>// IsSHA3512 checks is a string is a SHA3-512 hash. Alias for `IsHash(str, "sha3-512")`</code></span>
<span class="codeline" id="line-727"><code>func IsSHA3512(str string) bool {</code></span>
<span class="codeline" id="line-728"><code>	return IsHash(str, "sha3-512")</code></span>
<span class="codeline" id="line-729"><code>}</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>// IsSHA512 checks is a string is a SHA512 hash. Alias for `IsHash(str, "sha512")`</code></span>
<span class="codeline" id="line-732"><code>func IsSHA512(str string) bool {</code></span>
<span class="codeline" id="line-733"><code>	return IsHash(str, "sha512")</code></span>
<span class="codeline" id="line-734"><code>}</code></span>
<span class="codeline" id="line-735"><code></code></span>
<span class="codeline" id="line-736"><code>// IsSHA384 checks is a string is a SHA384 hash. Alias for `IsHash(str, "sha384")`</code></span>
<span class="codeline" id="line-737"><code>func IsSHA384(str string) bool {</code></span>
<span class="codeline" id="line-738"><code>	return IsHash(str, "sha384")</code></span>
<span class="codeline" id="line-739"><code>}</code></span>
<span class="codeline" id="line-740"><code></code></span>
<span class="codeline" id="line-741"><code>// IsSHA256 checks is a string is a SHA256 hash. Alias for `IsHash(str, "sha256")`</code></span>
<span class="codeline" id="line-742"><code>func IsSHA256(str string) bool {</code></span>
<span class="codeline" id="line-743"><code>	return IsHash(str, "sha256")</code></span>
<span class="codeline" id="line-744"><code>}</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>// IsTiger192 checks is a string is a Tiger192 hash. Alias for `IsHash(str, "tiger192")`</code></span>
<span class="codeline" id="line-747"><code>func IsTiger192(str string) bool {</code></span>
<span class="codeline" id="line-748"><code>	return IsHash(str, "tiger192")</code></span>
<span class="codeline" id="line-749"><code>}</code></span>
<span class="codeline" id="line-750"><code></code></span>
<span class="codeline" id="line-751"><code>// IsTiger160 checks is a string is a Tiger160 hash. Alias for `IsHash(str, "tiger160")`</code></span>
<span class="codeline" id="line-752"><code>func IsTiger160(str string) bool {</code></span>
<span class="codeline" id="line-753"><code>	return IsHash(str, "tiger160")</code></span>
<span class="codeline" id="line-754"><code>}</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>// IsRipeMD160 checks is a string is a RipeMD160 hash. Alias for `IsHash(str, "ripemd160")`</code></span>
<span class="codeline" id="line-757"><code>func IsRipeMD160(str string) bool {</code></span>
<span class="codeline" id="line-758"><code>	return IsHash(str, "ripemd160")</code></span>
<span class="codeline" id="line-759"><code>}</code></span>
<span class="codeline" id="line-760"><code></code></span>
<span class="codeline" id="line-761"><code>// IsSHA1 checks is a string is a SHA-1 hash. Alias for `IsHash(str, "sha1")`</code></span>
<span class="codeline" id="line-762"><code>func IsSHA1(str string) bool {</code></span>
<span class="codeline" id="line-763"><code>	return IsHash(str, "sha1")</code></span>
<span class="codeline" id="line-764"><code>}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>// IsTiger128 checks is a string is a Tiger128 hash. Alias for `IsHash(str, "tiger128")`</code></span>
<span class="codeline" id="line-767"><code>func IsTiger128(str string) bool {</code></span>
<span class="codeline" id="line-768"><code>	return IsHash(str, "tiger128")</code></span>
<span class="codeline" id="line-769"><code>}</code></span>
<span class="codeline" id="line-770"><code></code></span>
<span class="codeline" id="line-771"><code>// IsRipeMD128 checks is a string is a RipeMD128 hash. Alias for `IsHash(str, "ripemd128")`</code></span>
<span class="codeline" id="line-772"><code>func IsRipeMD128(str string) bool {</code></span>
<span class="codeline" id="line-773"><code>	return IsHash(str, "ripemd128")</code></span>
<span class="codeline" id="line-774"><code>}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>// IsCRC32 checks is a string is a CRC32 hash. Alias for `IsHash(str, "crc32")`</code></span>
<span class="codeline" id="line-777"><code>func IsCRC32(str string) bool {</code></span>
<span class="codeline" id="line-778"><code>	return IsHash(str, "crc32")</code></span>
<span class="codeline" id="line-779"><code>}</code></span>
<span class="codeline" id="line-780"><code></code></span>
<span class="codeline" id="line-781"><code>// IsCRC32b checks is a string is a CRC32b hash. Alias for `IsHash(str, "crc32b")`</code></span>
<span class="codeline" id="line-782"><code>func IsCRC32b(str string) bool {</code></span>
<span class="codeline" id="line-783"><code>	return IsHash(str, "crc32b")</code></span>
<span class="codeline" id="line-784"><code>}</code></span>
<span class="codeline" id="line-785"><code></code></span>
<span class="codeline" id="line-786"><code>// IsMD5 checks is a string is a MD5 hash. Alias for `IsHash(str, "md5")`</code></span>
<span class="codeline" id="line-787"><code>func IsMD5(str string) bool {</code></span>
<span class="codeline" id="line-788"><code>	return IsHash(str, "md5")</code></span>
<span class="codeline" id="line-789"><code>}</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>// IsMD4 checks is a string is a MD4 hash. Alias for `IsHash(str, "md4")`</code></span>
<span class="codeline" id="line-792"><code>func IsMD4(str string) bool {</code></span>
<span class="codeline" id="line-793"><code>	return IsHash(str, "md4")</code></span>
<span class="codeline" id="line-794"><code>}</code></span>
<span class="codeline" id="line-795"><code></code></span>
<span class="codeline" id="line-796"><code>// IsDialString validates the given string for usage with the various Dial() functions</code></span>
<span class="codeline" id="line-797"><code>func IsDialString(str string) bool {</code></span>
<span class="codeline" id="line-798"><code>	if h, p, err := net.SplitHostPort(str); err == nil &amp;&amp; h != "" &amp;&amp; p != "" &amp;&amp; (IsDNSName(h) || IsIP(h)) &amp;&amp; IsPort(p) {</code></span>
<span class="codeline" id="line-799"><code>		return true</code></span>
<span class="codeline" id="line-800"><code>	}</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>	return false</code></span>
<span class="codeline" id="line-803"><code>}</code></span>
<span class="codeline" id="line-804"><code></code></span>
<span class="codeline" id="line-805"><code>// IsIP checks if a string is either IP version 4 or 6. Alias for `net.ParseIP`</code></span>
<span class="codeline" id="line-806"><code>func IsIP(str string) bool {</code></span>
<span class="codeline" id="line-807"><code>	return net.ParseIP(str) != nil</code></span>
<span class="codeline" id="line-808"><code>}</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>// IsPort checks if a string represents a valid port</code></span>
<span class="codeline" id="line-811"><code>func IsPort(str string) bool {</code></span>
<span class="codeline" id="line-812"><code>	if i, err := strconv.Atoi(str); err == nil &amp;&amp; i &gt; 0 &amp;&amp; i &lt; 65536 {</code></span>
<span class="codeline" id="line-813"><code>		return true</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code>	return false</code></span>
<span class="codeline" id="line-816"><code>}</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>// IsIPv4 checks if the string is an IP version 4.</code></span>
<span class="codeline" id="line-819"><code>func IsIPv4(str string) bool {</code></span>
<span class="codeline" id="line-820"><code>	ip := net.ParseIP(str)</code></span>
<span class="codeline" id="line-821"><code>	return ip != nil &amp;&amp; strings.Contains(str, ".")</code></span>
<span class="codeline" id="line-822"><code>}</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>// IsIPv6 checks if the string is an IP version 6.</code></span>
<span class="codeline" id="line-825"><code>func IsIPv6(str string) bool {</code></span>
<span class="codeline" id="line-826"><code>	ip := net.ParseIP(str)</code></span>
<span class="codeline" id="line-827"><code>	return ip != nil &amp;&amp; strings.Contains(str, ":")</code></span>
<span class="codeline" id="line-828"><code>}</code></span>
<span class="codeline" id="line-829"><code></code></span>
<span class="codeline" id="line-830"><code>// IsCIDR checks if the string is an valid CIDR notiation (IPV4 &amp; IPV6)</code></span>
<span class="codeline" id="line-831"><code>func IsCIDR(str string) bool {</code></span>
<span class="codeline" id="line-832"><code>	_, _, err := net.ParseCIDR(str)</code></span>
<span class="codeline" id="line-833"><code>	return err == nil</code></span>
<span class="codeline" id="line-834"><code>}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>// IsMAC checks if a string is valid MAC address.</code></span>
<span class="codeline" id="line-837"><code>// Possible MAC formats:</code></span>
<span class="codeline" id="line-838"><code>// 01:23:45:67:89:ab</code></span>
<span class="codeline" id="line-839"><code>// 01:23:45:67:89:ab:cd:ef</code></span>
<span class="codeline" id="line-840"><code>// 01-23-45-67-89-ab</code></span>
<span class="codeline" id="line-841"><code>// 01-23-45-67-89-ab-cd-ef</code></span>
<span class="codeline" id="line-842"><code>// 0123.4567.89ab</code></span>
<span class="codeline" id="line-843"><code>// 0123.4567.89ab.cdef</code></span>
<span class="codeline" id="line-844"><code>func IsMAC(str string) bool {</code></span>
<span class="codeline" id="line-845"><code>	_, err := net.ParseMAC(str)</code></span>
<span class="codeline" id="line-846"><code>	return err == nil</code></span>
<span class="codeline" id="line-847"><code>}</code></span>
<span class="codeline" id="line-848"><code></code></span>
<span class="codeline" id="line-849"><code>// IsHost checks if the string is a valid IP (both v4 and v6) or a valid DNS name</code></span>
<span class="codeline" id="line-850"><code>func IsHost(str string) bool {</code></span>
<span class="codeline" id="line-851"><code>	return IsIP(str) || IsDNSName(str)</code></span>
<span class="codeline" id="line-852"><code>}</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>// IsMongoID checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.</code></span>
<span class="codeline" id="line-855"><code>func IsMongoID(str string) bool {</code></span>
<span class="codeline" id="line-856"><code>	return rxHexadecimal.MatchString(str) &amp;&amp; (len(str) == 24)</code></span>
<span class="codeline" id="line-857"><code>}</code></span>
<span class="codeline" id="line-858"><code></code></span>
<span class="codeline" id="line-859"><code>// IsLatitude checks if a string is valid latitude.</code></span>
<span class="codeline" id="line-860"><code>func IsLatitude(str string) bool {</code></span>
<span class="codeline" id="line-861"><code>	return rxLatitude.MatchString(str)</code></span>
<span class="codeline" id="line-862"><code>}</code></span>
<span class="codeline" id="line-863"><code></code></span>
<span class="codeline" id="line-864"><code>// IsLongitude checks if a string is valid longitude.</code></span>
<span class="codeline" id="line-865"><code>func IsLongitude(str string) bool {</code></span>
<span class="codeline" id="line-866"><code>	return rxLongitude.MatchString(str)</code></span>
<span class="codeline" id="line-867"><code>}</code></span>
<span class="codeline" id="line-868"><code></code></span>
<span class="codeline" id="line-869"><code>// IsIMEI checks if a string is valid IMEI</code></span>
<span class="codeline" id="line-870"><code>func IsIMEI(str string) bool {</code></span>
<span class="codeline" id="line-871"><code>	return rxIMEI.MatchString(str)</code></span>
<span class="codeline" id="line-872"><code>}</code></span>
<span class="codeline" id="line-873"><code></code></span>
<span class="codeline" id="line-874"><code>// IsIMSI checks if a string is valid IMSI</code></span>
<span class="codeline" id="line-875"><code>func IsIMSI(str string) bool {</code></span>
<span class="codeline" id="line-876"><code>	if !rxIMSI.MatchString(str) {</code></span>
<span class="codeline" id="line-877"><code>		return false</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code></code></span>
<span class="codeline" id="line-880"><code>	mcc, err := strconv.ParseInt(str[0:3], 10, 32)</code></span>
<span class="codeline" id="line-881"><code>	if err != nil {</code></span>
<span class="codeline" id="line-882"><code>		return false</code></span>
<span class="codeline" id="line-883"><code>	}</code></span>
<span class="codeline" id="line-884"><code></code></span>
<span class="codeline" id="line-885"><code>	switch mcc {</code></span>
<span class="codeline" id="line-886"><code>	case 202, 204, 206, 208, 212, 213, 214, 216, 218, 219:</code></span>
<span class="codeline" id="line-887"><code>	case 220, 221, 222, 226, 228, 230, 231, 232, 234, 235:</code></span>
<span class="codeline" id="line-888"><code>	case 238, 240, 242, 244, 246, 247, 248, 250, 255, 257:</code></span>
<span class="codeline" id="line-889"><code>	case 259, 260, 262, 266, 268, 270, 272, 274, 276, 278:</code></span>
<span class="codeline" id="line-890"><code>	case 280, 282, 283, 284, 286, 288, 289, 290, 292, 293:</code></span>
<span class="codeline" id="line-891"><code>	case 294, 295, 297, 302, 308, 310, 311, 312, 313, 314:</code></span>
<span class="codeline" id="line-892"><code>	case 315, 316, 330, 332, 334, 338, 340, 342, 344, 346:</code></span>
<span class="codeline" id="line-893"><code>	case 348, 350, 352, 354, 356, 358, 360, 362, 363, 364:</code></span>
<span class="codeline" id="line-894"><code>	case 365, 366, 368, 370, 372, 374, 376, 400, 401, 402:</code></span>
<span class="codeline" id="line-895"><code>	case 404, 405, 406, 410, 412, 413, 414, 415, 416, 417:</code></span>
<span class="codeline" id="line-896"><code>	case 418, 419, 420, 421, 422, 424, 425, 426, 427, 428:</code></span>
<span class="codeline" id="line-897"><code>	case 429, 430, 431, 432, 434, 436, 437, 438, 440, 441:</code></span>
<span class="codeline" id="line-898"><code>	case 450, 452, 454, 455, 456, 457, 460, 461, 466, 467:</code></span>
<span class="codeline" id="line-899"><code>	case 470, 472, 502, 505, 510, 514, 515, 520, 525, 528:</code></span>
<span class="codeline" id="line-900"><code>	case 530, 536, 537, 539, 540, 541, 542, 543, 544, 545:</code></span>
<span class="codeline" id="line-901"><code>	case 546, 547, 548, 549, 550, 551, 552, 553, 554, 555:</code></span>
<span class="codeline" id="line-902"><code>	case 602, 603, 604, 605, 606, 607, 608, 609, 610, 611:</code></span>
<span class="codeline" id="line-903"><code>	case 612, 613, 614, 615, 616, 617, 618, 619, 620, 621:</code></span>
<span class="codeline" id="line-904"><code>	case 622, 623, 624, 625, 626, 627, 628, 629, 630, 631:</code></span>
<span class="codeline" id="line-905"><code>	case 632, 633, 634, 635, 636, 637, 638, 639, 640, 641:</code></span>
<span class="codeline" id="line-906"><code>	case 642, 643, 645, 646, 647, 648, 649, 650, 651, 652:</code></span>
<span class="codeline" id="line-907"><code>	case 653, 654, 655, 657, 658, 659, 702, 704, 706, 708:</code></span>
<span class="codeline" id="line-908"><code>	case 710, 712, 714, 716, 722, 724, 730, 732, 734, 736:</code></span>
<span class="codeline" id="line-909"><code>	case 738, 740, 742, 744, 746, 748, 750, 995:</code></span>
<span class="codeline" id="line-910"><code>		return true</code></span>
<span class="codeline" id="line-911"><code>	default:</code></span>
<span class="codeline" id="line-912"><code>		return false</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code>	return true</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>// IsRsaPublicKey checks if a string is valid public key with provided length</code></span>
<span class="codeline" id="line-918"><code>func IsRsaPublicKey(str string, keylen int) bool {</code></span>
<span class="codeline" id="line-919"><code>	bb := bytes.NewBufferString(str)</code></span>
<span class="codeline" id="line-920"><code>	pemBytes, err := ioutil.ReadAll(bb)</code></span>
<span class="codeline" id="line-921"><code>	if err != nil {</code></span>
<span class="codeline" id="line-922"><code>		return false</code></span>
<span class="codeline" id="line-923"><code>	}</code></span>
<span class="codeline" id="line-924"><code>	block, _ := pem.Decode(pemBytes)</code></span>
<span class="codeline" id="line-925"><code>	if block != nil &amp;&amp; block.Type != "PUBLIC KEY" {</code></span>
<span class="codeline" id="line-926"><code>		return false</code></span>
<span class="codeline" id="line-927"><code>	}</code></span>
<span class="codeline" id="line-928"><code>	var der []byte</code></span>
<span class="codeline" id="line-929"><code></code></span>
<span class="codeline" id="line-930"><code>	if block != nil {</code></span>
<span class="codeline" id="line-931"><code>		der = block.Bytes</code></span>
<span class="codeline" id="line-932"><code>	} else {</code></span>
<span class="codeline" id="line-933"><code>		der, err = base64.StdEncoding.DecodeString(str)</code></span>
<span class="codeline" id="line-934"><code>		if err != nil {</code></span>
<span class="codeline" id="line-935"><code>			return false</code></span>
<span class="codeline" id="line-936"><code>		}</code></span>
<span class="codeline" id="line-937"><code>	}</code></span>
<span class="codeline" id="line-938"><code></code></span>
<span class="codeline" id="line-939"><code>	key, err := x509.ParsePKIXPublicKey(der)</code></span>
<span class="codeline" id="line-940"><code>	if err != nil {</code></span>
<span class="codeline" id="line-941"><code>		return false</code></span>
<span class="codeline" id="line-942"><code>	}</code></span>
<span class="codeline" id="line-943"><code>	pubkey, ok := key.(*rsa.PublicKey)</code></span>
<span class="codeline" id="line-944"><code>	if !ok {</code></span>
<span class="codeline" id="line-945"><code>		return false</code></span>
<span class="codeline" id="line-946"><code>	}</code></span>
<span class="codeline" id="line-947"><code>	bitlen := len(pubkey.N.Bytes()) * 8</code></span>
<span class="codeline" id="line-948"><code>	return bitlen == int(keylen)</code></span>
<span class="codeline" id="line-949"><code>}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>// IsRegex checks if a give string is a valid regex with RE2 syntax or not</code></span>
<span class="codeline" id="line-952"><code>func IsRegex(str string) bool {</code></span>
<span class="codeline" id="line-953"><code>	if _, err := regexp.Compile(str); err == nil {</code></span>
<span class="codeline" id="line-954"><code>		return true</code></span>
<span class="codeline" id="line-955"><code>	}</code></span>
<span class="codeline" id="line-956"><code>	return false</code></span>
<span class="codeline" id="line-957"><code>}</code></span>
<span class="codeline" id="line-958"><code></code></span>
<span class="codeline" id="line-959"><code>func toJSONName(tag string) string {</code></span>
<span class="codeline" id="line-960"><code>	if tag == "" {</code></span>
<span class="codeline" id="line-961"><code>		return ""</code></span>
<span class="codeline" id="line-962"><code>	}</code></span>
<span class="codeline" id="line-963"><code></code></span>
<span class="codeline" id="line-964"><code>	// JSON name always comes first. If there's no options then split[0] is</code></span>
<span class="codeline" id="line-965"><code>	// JSON name, if JSON name is not set, then split[0] is an empty string.</code></span>
<span class="codeline" id="line-966"><code>	split := strings.SplitN(tag, ",", 2)</code></span>
<span class="codeline" id="line-967"><code></code></span>
<span class="codeline" id="line-968"><code>	name := split[0]</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>	// However it is possible that the field is skipped when</code></span>
<span class="codeline" id="line-971"><code>	// (de-)serializing from/to JSON, in which case assume that there is no</code></span>
<span class="codeline" id="line-972"><code>	// tag name to use</code></span>
<span class="codeline" id="line-973"><code>	if name == "-" {</code></span>
<span class="codeline" id="line-974"><code>		return ""</code></span>
<span class="codeline" id="line-975"><code>	}</code></span>
<span class="codeline" id="line-976"><code>	return name</code></span>
<span class="codeline" id="line-977"><code>}</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>func prependPathToErrors(err error, path string) error {</code></span>
<span class="codeline" id="line-980"><code>	switch err2 := err.(type) {</code></span>
<span class="codeline" id="line-981"><code>	case Error:</code></span>
<span class="codeline" id="line-982"><code>		err2.Path = append([]string{path}, err2.Path...)</code></span>
<span class="codeline" id="line-983"><code>		return err2</code></span>
<span class="codeline" id="line-984"><code>	case Errors:</code></span>
<span class="codeline" id="line-985"><code>		errors := err2.Errors()</code></span>
<span class="codeline" id="line-986"><code>		for i, err3 := range errors {</code></span>
<span class="codeline" id="line-987"><code>			errors[i] = prependPathToErrors(err3, path)</code></span>
<span class="codeline" id="line-988"><code>		}</code></span>
<span class="codeline" id="line-989"><code>		return err2</code></span>
<span class="codeline" id="line-990"><code>	}</code></span>
<span class="codeline" id="line-991"><code>	return err</code></span>
<span class="codeline" id="line-992"><code>}</code></span>
<span class="codeline" id="line-993"><code></code></span>
<span class="codeline" id="line-994"><code>// ValidateArray performs validation according to condition iterator that validates every element of the array</code></span>
<span class="codeline" id="line-995"><code>func ValidateArray(array []interface{}, iterator ConditionIterator) bool {</code></span>
<span class="codeline" id="line-996"><code>	return Every(array, iterator)</code></span>
<span class="codeline" id="line-997"><code>}</code></span>
<span class="codeline" id="line-998"><code></code></span>
<span class="codeline" id="line-999"><code>// ValidateMap use validation map for fields.</code></span>
<span class="codeline" id="line-1000"><code>// result will be equal to `false` if there are any errors.</code></span>
<span class="codeline" id="line-1001"><code>// s is the map containing the data to be validated.</code></span>
<span class="codeline" id="line-1002"><code>// m is the validation map in the form:</code></span>
<span class="codeline" id="line-1003"><code>//   map[string]interface{}{"name":"required,alpha","address":map[string]interface{}{"line1":"required,alphanum"}}</code></span>
<span class="codeline" id="line-1004"><code>func ValidateMap(s map[string]interface{}, m map[string]interface{}) (bool, error) {</code></span>
<span class="codeline" id="line-1005"><code>	if s == nil {</code></span>
<span class="codeline" id="line-1006"><code>		return true, nil</code></span>
<span class="codeline" id="line-1007"><code>	}</code></span>
<span class="codeline" id="line-1008"><code>	result := true</code></span>
<span class="codeline" id="line-1009"><code>	var err error</code></span>
<span class="codeline" id="line-1010"><code>	var errs Errors</code></span>
<span class="codeline" id="line-1011"><code>	var index int</code></span>
<span class="codeline" id="line-1012"><code>	val := reflect.ValueOf(s)</code></span>
<span class="codeline" id="line-1013"><code>	for key, value := range s {</code></span>
<span class="codeline" id="line-1014"><code>		presentResult := true</code></span>
<span class="codeline" id="line-1015"><code>		validator, ok := m[key]</code></span>
<span class="codeline" id="line-1016"><code>		if !ok {</code></span>
<span class="codeline" id="line-1017"><code>			presentResult = false</code></span>
<span class="codeline" id="line-1018"><code>			var err error</code></span>
<span class="codeline" id="line-1019"><code>			err = fmt.Errorf("all map keys has to be present in the validation map; got %s", key)</code></span>
<span class="codeline" id="line-1020"><code>			err = prependPathToErrors(err, key)</code></span>
<span class="codeline" id="line-1021"><code>			errs = append(errs, err)</code></span>
<span class="codeline" id="line-1022"><code>		}</code></span>
<span class="codeline" id="line-1023"><code>		valueField := reflect.ValueOf(value)</code></span>
<span class="codeline" id="line-1024"><code>		mapResult := true</code></span>
<span class="codeline" id="line-1025"><code>		typeResult := true</code></span>
<span class="codeline" id="line-1026"><code>		structResult := true</code></span>
<span class="codeline" id="line-1027"><code>		resultField := true</code></span>
<span class="codeline" id="line-1028"><code>		switch subValidator := validator.(type) {</code></span>
<span class="codeline" id="line-1029"><code>		case map[string]interface{}:</code></span>
<span class="codeline" id="line-1030"><code>			var err error</code></span>
<span class="codeline" id="line-1031"><code>			if v, ok := value.(map[string]interface{}); !ok {</code></span>
<span class="codeline" id="line-1032"><code>				mapResult = false</code></span>
<span class="codeline" id="line-1033"><code>				err = fmt.Errorf("map validator has to be for the map type only; got %s", valueField.Type().String())</code></span>
<span class="codeline" id="line-1034"><code>				err = prependPathToErrors(err, key)</code></span>
<span class="codeline" id="line-1035"><code>				errs = append(errs, err)</code></span>
<span class="codeline" id="line-1036"><code>			} else {</code></span>
<span class="codeline" id="line-1037"><code>				mapResult, err = ValidateMap(v, subValidator)</code></span>
<span class="codeline" id="line-1038"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1039"><code>					mapResult = false</code></span>
<span class="codeline" id="line-1040"><code>					err = prependPathToErrors(err, key)</code></span>
<span class="codeline" id="line-1041"><code>					errs = append(errs, err)</code></span>
<span class="codeline" id="line-1042"><code>				}</code></span>
<span class="codeline" id="line-1043"><code>			}</code></span>
<span class="codeline" id="line-1044"><code>		case string:</code></span>
<span class="codeline" id="line-1045"><code>			if (valueField.Kind() == reflect.Struct ||</code></span>
<span class="codeline" id="line-1046"><code>				(valueField.Kind() == reflect.Ptr &amp;&amp; valueField.Elem().Kind() == reflect.Struct)) &amp;&amp;</code></span>
<span class="codeline" id="line-1047"><code>				subValidator != "-" {</code></span>
<span class="codeline" id="line-1048"><code>				var err error</code></span>
<span class="codeline" id="line-1049"><code>				structResult, err = ValidateStruct(valueField.Interface())</code></span>
<span class="codeline" id="line-1050"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1051"><code>					err = prependPathToErrors(err, key)</code></span>
<span class="codeline" id="line-1052"><code>					errs = append(errs, err)</code></span>
<span class="codeline" id="line-1053"><code>				}</code></span>
<span class="codeline" id="line-1054"><code>			}</code></span>
<span class="codeline" id="line-1055"><code>			resultField, err = typeCheck(valueField, reflect.StructField{</code></span>
<span class="codeline" id="line-1056"><code>				Name:      key,</code></span>
<span class="codeline" id="line-1057"><code>				PkgPath:   "",</code></span>
<span class="codeline" id="line-1058"><code>				Type:      val.Type(),</code></span>
<span class="codeline" id="line-1059"><code>				Tag:       reflect.StructTag(fmt.Sprintf("%s:%q", tagName, subValidator)),</code></span>
<span class="codeline" id="line-1060"><code>				Offset:    0,</code></span>
<span class="codeline" id="line-1061"><code>				Index:     []int{index},</code></span>
<span class="codeline" id="line-1062"><code>				Anonymous: false,</code></span>
<span class="codeline" id="line-1063"><code>			}, val, nil)</code></span>
<span class="codeline" id="line-1064"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1065"><code>				errs = append(errs, err)</code></span>
<span class="codeline" id="line-1066"><code>			}</code></span>
<span class="codeline" id="line-1067"><code>		case nil:</code></span>
<span class="codeline" id="line-1068"><code>			// already handlerd when checked before</code></span>
<span class="codeline" id="line-1069"><code>		default:</code></span>
<span class="codeline" id="line-1070"><code>			typeResult = false</code></span>
<span class="codeline" id="line-1071"><code>			err = fmt.Errorf("map validator has to be either map[string]interface{} or string; got %s", valueField.Type().String())</code></span>
<span class="codeline" id="line-1072"><code>			err = prependPathToErrors(err, key)</code></span>
<span class="codeline" id="line-1073"><code>			errs = append(errs, err)</code></span>
<span class="codeline" id="line-1074"><code>		}</code></span>
<span class="codeline" id="line-1075"><code>		result = result &amp;&amp; presentResult &amp;&amp; typeResult &amp;&amp; resultField &amp;&amp; structResult &amp;&amp; mapResult</code></span>
<span class="codeline" id="line-1076"><code>		index++</code></span>
<span class="codeline" id="line-1077"><code>	}</code></span>
<span class="codeline" id="line-1078"><code>	// checks required keys</code></span>
<span class="codeline" id="line-1079"><code>	requiredResult := true</code></span>
<span class="codeline" id="line-1080"><code>	for key, value := range m {</code></span>
<span class="codeline" id="line-1081"><code>		if schema, ok := value.(string); ok {</code></span>
<span class="codeline" id="line-1082"><code>			tags := parseTagIntoMap(schema)</code></span>
<span class="codeline" id="line-1083"><code>			if required, ok := tags["required"]; ok {</code></span>
<span class="codeline" id="line-1084"><code>				if _, ok := s[key]; !ok {</code></span>
<span class="codeline" id="line-1085"><code>					requiredResult = false</code></span>
<span class="codeline" id="line-1086"><code>					if required.customErrorMessage != "" {</code></span>
<span class="codeline" id="line-1087"><code>						err = Error{key, fmt.Errorf(required.customErrorMessage), true, "required", []string{}}</code></span>
<span class="codeline" id="line-1088"><code>					} else {</code></span>
<span class="codeline" id="line-1089"><code>						err = Error{key, fmt.Errorf("required field missing"), false, "required", []string{}}</code></span>
<span class="codeline" id="line-1090"><code>					}</code></span>
<span class="codeline" id="line-1091"><code>					errs = append(errs, err)</code></span>
<span class="codeline" id="line-1092"><code>				}</code></span>
<span class="codeline" id="line-1093"><code>			}</code></span>
<span class="codeline" id="line-1094"><code>		}</code></span>
<span class="codeline" id="line-1095"><code>	}</code></span>
<span class="codeline" id="line-1096"><code></code></span>
<span class="codeline" id="line-1097"><code>	if len(errs) &gt; 0 {</code></span>
<span class="codeline" id="line-1098"><code>		err = errs</code></span>
<span class="codeline" id="line-1099"><code>	}</code></span>
<span class="codeline" id="line-1100"><code>	return result &amp;&amp; requiredResult, err</code></span>
<span class="codeline" id="line-1101"><code>}</code></span>
<span class="codeline" id="line-1102"><code></code></span>
<span class="codeline" id="line-1103"><code>// ValidateStruct use tags for fields.</code></span>
<span class="codeline" id="line-1104"><code>// result will be equal to `false` if there are any errors.</code></span>
<span class="codeline" id="line-1105"><code>// todo currently there is no guarantee that errors will be returned in predictable order (tests may to fail)</code></span>
<span class="codeline" id="line-1106"><code>func ValidateStruct(s interface{}) (bool, error) {</code></span>
<span class="codeline" id="line-1107"><code>	if s == nil {</code></span>
<span class="codeline" id="line-1108"><code>		return true, nil</code></span>
<span class="codeline" id="line-1109"><code>	}</code></span>
<span class="codeline" id="line-1110"><code>	result := true</code></span>
<span class="codeline" id="line-1111"><code>	var err error</code></span>
<span class="codeline" id="line-1112"><code>	val := reflect.ValueOf(s)</code></span>
<span class="codeline" id="line-1113"><code>	if val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-1114"><code>		val = val.Elem()</code></span>
<span class="codeline" id="line-1115"><code>	}</code></span>
<span class="codeline" id="line-1116"><code>	// we only accept structs</code></span>
<span class="codeline" id="line-1117"><code>	if val.Kind() != reflect.Struct {</code></span>
<span class="codeline" id="line-1118"><code>		return false, fmt.Errorf("function only accepts structs; got %s", val.Kind())</code></span>
<span class="codeline" id="line-1119"><code>	}</code></span>
<span class="codeline" id="line-1120"><code>	var errs Errors</code></span>
<span class="codeline" id="line-1121"><code>	for i := 0; i &lt; val.NumField(); i++ {</code></span>
<span class="codeline" id="line-1122"><code>		valueField := val.Field(i)</code></span>
<span class="codeline" id="line-1123"><code>		typeField := val.Type().Field(i)</code></span>
<span class="codeline" id="line-1124"><code>		if typeField.PkgPath != "" {</code></span>
<span class="codeline" id="line-1125"><code>			continue // Private field</code></span>
<span class="codeline" id="line-1126"><code>		}</code></span>
<span class="codeline" id="line-1127"><code>		structResult := true</code></span>
<span class="codeline" id="line-1128"><code>		if valueField.Kind() == reflect.Interface {</code></span>
<span class="codeline" id="line-1129"><code>			valueField = valueField.Elem()</code></span>
<span class="codeline" id="line-1130"><code>		}</code></span>
<span class="codeline" id="line-1131"><code>		if (valueField.Kind() == reflect.Struct ||</code></span>
<span class="codeline" id="line-1132"><code>			(valueField.Kind() == reflect.Ptr &amp;&amp; valueField.Elem().Kind() == reflect.Struct)) &amp;&amp;</code></span>
<span class="codeline" id="line-1133"><code>			typeField.Tag.Get(tagName) != "-" {</code></span>
<span class="codeline" id="line-1134"><code>			var err error</code></span>
<span class="codeline" id="line-1135"><code>			structResult, err = ValidateStruct(valueField.Interface())</code></span>
<span class="codeline" id="line-1136"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1137"><code>				err = prependPathToErrors(err, typeField.Name)</code></span>
<span class="codeline" id="line-1138"><code>				errs = append(errs, err)</code></span>
<span class="codeline" id="line-1139"><code>			}</code></span>
<span class="codeline" id="line-1140"><code>		}</code></span>
<span class="codeline" id="line-1141"><code>		resultField, err2 := typeCheck(valueField, typeField, val, nil)</code></span>
<span class="codeline" id="line-1142"><code>		if err2 != nil {</code></span>
<span class="codeline" id="line-1143"><code></code></span>
<span class="codeline" id="line-1144"><code>			// Replace structure name with JSON name if there is a tag on the variable</code></span>
<span class="codeline" id="line-1145"><code>			jsonTag := toJSONName(typeField.Tag.Get("json"))</code></span>
<span class="codeline" id="line-1146"><code>			if jsonTag != "" {</code></span>
<span class="codeline" id="line-1147"><code>				switch jsonError := err2.(type) {</code></span>
<span class="codeline" id="line-1148"><code>				case Error:</code></span>
<span class="codeline" id="line-1149"><code>					jsonError.Name = jsonTag</code></span>
<span class="codeline" id="line-1150"><code>					err2 = jsonError</code></span>
<span class="codeline" id="line-1151"><code>				case Errors:</code></span>
<span class="codeline" id="line-1152"><code>					for i2, err3 := range jsonError {</code></span>
<span class="codeline" id="line-1153"><code>						switch customErr := err3.(type) {</code></span>
<span class="codeline" id="line-1154"><code>						case Error:</code></span>
<span class="codeline" id="line-1155"><code>							customErr.Name = jsonTag</code></span>
<span class="codeline" id="line-1156"><code>							jsonError[i2] = customErr</code></span>
<span class="codeline" id="line-1157"><code>						}</code></span>
<span class="codeline" id="line-1158"><code>					}</code></span>
<span class="codeline" id="line-1159"><code></code></span>
<span class="codeline" id="line-1160"><code>					err2 = jsonError</code></span>
<span class="codeline" id="line-1161"><code>				}</code></span>
<span class="codeline" id="line-1162"><code>			}</code></span>
<span class="codeline" id="line-1163"><code></code></span>
<span class="codeline" id="line-1164"><code>			errs = append(errs, err2)</code></span>
<span class="codeline" id="line-1165"><code>		}</code></span>
<span class="codeline" id="line-1166"><code>		result = result &amp;&amp; resultField &amp;&amp; structResult</code></span>
<span class="codeline" id="line-1167"><code>	}</code></span>
<span class="codeline" id="line-1168"><code>	if len(errs) &gt; 0 {</code></span>
<span class="codeline" id="line-1169"><code>		err = errs</code></span>
<span class="codeline" id="line-1170"><code>	}</code></span>
<span class="codeline" id="line-1171"><code>	return result, err</code></span>
<span class="codeline" id="line-1172"><code>}</code></span>
<span class="codeline" id="line-1173"><code></code></span>
<span class="codeline" id="line-1174"><code>// ValidateStructAsync performs async validation of the struct and returns results through the channels</code></span>
<span class="codeline" id="line-1175"><code>func ValidateStructAsync(s interface{}) (&lt;-chan bool, &lt;-chan error) {</code></span>
<span class="codeline" id="line-1176"><code>	res := make(chan bool)</code></span>
<span class="codeline" id="line-1177"><code>	errors := make(chan error)</code></span>
<span class="codeline" id="line-1178"><code></code></span>
<span class="codeline" id="line-1179"><code>	go func() {</code></span>
<span class="codeline" id="line-1180"><code>		defer close(res)</code></span>
<span class="codeline" id="line-1181"><code>		defer close(errors)</code></span>
<span class="codeline" id="line-1182"><code></code></span>
<span class="codeline" id="line-1183"><code>		isValid, isFailed := ValidateStruct(s)</code></span>
<span class="codeline" id="line-1184"><code></code></span>
<span class="codeline" id="line-1185"><code>		res &lt;- isValid</code></span>
<span class="codeline" id="line-1186"><code>		errors &lt;- isFailed</code></span>
<span class="codeline" id="line-1187"><code>	}()</code></span>
<span class="codeline" id="line-1188"><code></code></span>
<span class="codeline" id="line-1189"><code>	return res, errors</code></span>
<span class="codeline" id="line-1190"><code>}</code></span>
<span class="codeline" id="line-1191"><code></code></span>
<span class="codeline" id="line-1192"><code>// ValidateMapAsync performs async validation of the map and returns results through the channels</code></span>
<span class="codeline" id="line-1193"><code>func ValidateMapAsync(s map[string]interface{}, m map[string]interface{}) (&lt;-chan bool, &lt;-chan error) {</code></span>
<span class="codeline" id="line-1194"><code>	res := make(chan bool)</code></span>
<span class="codeline" id="line-1195"><code>	errors := make(chan error)</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>	go func() {</code></span>
<span class="codeline" id="line-1198"><code>		defer close(res)</code></span>
<span class="codeline" id="line-1199"><code>		defer close(errors)</code></span>
<span class="codeline" id="line-1200"><code></code></span>
<span class="codeline" id="line-1201"><code>		isValid, isFailed := ValidateMap(s, m)</code></span>
<span class="codeline" id="line-1202"><code></code></span>
<span class="codeline" id="line-1203"><code>		res &lt;- isValid</code></span>
<span class="codeline" id="line-1204"><code>		errors &lt;- isFailed</code></span>
<span class="codeline" id="line-1205"><code>	}()</code></span>
<span class="codeline" id="line-1206"><code></code></span>
<span class="codeline" id="line-1207"><code>	return res, errors</code></span>
<span class="codeline" id="line-1208"><code>}</code></span>
<span class="codeline" id="line-1209"><code></code></span>
<span class="codeline" id="line-1210"><code>// parseTagIntoMap parses a struct tag `valid:required~Some error message,length(2|3)` into map[string]string{"required": "Some error message", "length(2|3)": ""}</code></span>
<span class="codeline" id="line-1211"><code>func parseTagIntoMap(tag string) tagOptionsMap {</code></span>
<span class="codeline" id="line-1212"><code>	optionsMap := make(tagOptionsMap)</code></span>
<span class="codeline" id="line-1213"><code>	options := strings.Split(tag, ",")</code></span>
<span class="codeline" id="line-1214"><code></code></span>
<span class="codeline" id="line-1215"><code>	for i, option := range options {</code></span>
<span class="codeline" id="line-1216"><code>		option = strings.TrimSpace(option)</code></span>
<span class="codeline" id="line-1217"><code></code></span>
<span class="codeline" id="line-1218"><code>		validationOptions := strings.Split(option, "~")</code></span>
<span class="codeline" id="line-1219"><code>		if !isValidTag(validationOptions[0]) {</code></span>
<span class="codeline" id="line-1220"><code>			continue</code></span>
<span class="codeline" id="line-1221"><code>		}</code></span>
<span class="codeline" id="line-1222"><code>		if len(validationOptions) == 2 {</code></span>
<span class="codeline" id="line-1223"><code>			optionsMap[validationOptions[0]] = tagOption{validationOptions[0], validationOptions[1], i}</code></span>
<span class="codeline" id="line-1224"><code>		} else {</code></span>
<span class="codeline" id="line-1225"><code>			optionsMap[validationOptions[0]] = tagOption{validationOptions[0], "", i}</code></span>
<span class="codeline" id="line-1226"><code>		}</code></span>
<span class="codeline" id="line-1227"><code>	}</code></span>
<span class="codeline" id="line-1228"><code>	return optionsMap</code></span>
<span class="codeline" id="line-1229"><code>}</code></span>
<span class="codeline" id="line-1230"><code></code></span>
<span class="codeline" id="line-1231"><code>func isValidTag(s string) bool {</code></span>
<span class="codeline" id="line-1232"><code>	if s == "" {</code></span>
<span class="codeline" id="line-1233"><code>		return false</code></span>
<span class="codeline" id="line-1234"><code>	}</code></span>
<span class="codeline" id="line-1235"><code>	for _, c := range s {</code></span>
<span class="codeline" id="line-1236"><code>		switch {</code></span>
<span class="codeline" id="line-1237"><code>		case strings.ContainsRune("\\'\"!#$%&amp;()*+-./:&lt;=&gt;?@[]^_{|}~ ", c):</code></span>
<span class="codeline" id="line-1238"><code>			// Backslash and quote chars are reserved, but</code></span>
<span class="codeline" id="line-1239"><code>			// otherwise any punctuation chars are allowed</code></span>
<span class="codeline" id="line-1240"><code>			// in a tag name.</code></span>
<span class="codeline" id="line-1241"><code>		default:</code></span>
<span class="codeline" id="line-1242"><code>			if !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c) {</code></span>
<span class="codeline" id="line-1243"><code>				return false</code></span>
<span class="codeline" id="line-1244"><code>			}</code></span>
<span class="codeline" id="line-1245"><code>		}</code></span>
<span class="codeline" id="line-1246"><code>	}</code></span>
<span class="codeline" id="line-1247"><code>	return true</code></span>
<span class="codeline" id="line-1248"><code>}</code></span>
<span class="codeline" id="line-1249"><code></code></span>
<span class="codeline" id="line-1250"><code>// IsSSN will validate the given string as a U.S. Social Security Number</code></span>
<span class="codeline" id="line-1251"><code>func IsSSN(str string) bool {</code></span>
<span class="codeline" id="line-1252"><code>	if str == "" || len(str) != 11 {</code></span>
<span class="codeline" id="line-1253"><code>		return false</code></span>
<span class="codeline" id="line-1254"><code>	}</code></span>
<span class="codeline" id="line-1255"><code>	return rxSSN.MatchString(str)</code></span>
<span class="codeline" id="line-1256"><code>}</code></span>
<span class="codeline" id="line-1257"><code></code></span>
<span class="codeline" id="line-1258"><code>// IsSemver checks if string is valid semantic version</code></span>
<span class="codeline" id="line-1259"><code>func IsSemver(str string) bool {</code></span>
<span class="codeline" id="line-1260"><code>	return rxSemver.MatchString(str)</code></span>
<span class="codeline" id="line-1261"><code>}</code></span>
<span class="codeline" id="line-1262"><code></code></span>
<span class="codeline" id="line-1263"><code>// IsType checks if interface is of some type</code></span>
<span class="codeline" id="line-1264"><code>func IsType(v interface{}, params ...string) bool {</code></span>
<span class="codeline" id="line-1265"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1266"><code>		typ := params[0]</code></span>
<span class="codeline" id="line-1267"><code>		return strings.Replace(reflect.TypeOf(v).String(), " ", "", -1) == strings.Replace(typ, " ", "", -1)</code></span>
<span class="codeline" id="line-1268"><code>	}</code></span>
<span class="codeline" id="line-1269"><code>	return false</code></span>
<span class="codeline" id="line-1270"><code>}</code></span>
<span class="codeline" id="line-1271"><code></code></span>
<span class="codeline" id="line-1272"><code>// IsTime checks if string is valid according to given format</code></span>
<span class="codeline" id="line-1273"><code>func IsTime(str string, format string) bool {</code></span>
<span class="codeline" id="line-1274"><code>	_, err := time.Parse(format, str)</code></span>
<span class="codeline" id="line-1275"><code>	return err == nil</code></span>
<span class="codeline" id="line-1276"><code>}</code></span>
<span class="codeline" id="line-1277"><code></code></span>
<span class="codeline" id="line-1278"><code>// IsUnixTime checks if string is valid unix timestamp value</code></span>
<span class="codeline" id="line-1279"><code>func IsUnixTime(str string) bool {</code></span>
<span class="codeline" id="line-1280"><code>	if _, err := strconv.Atoi(str); err == nil {</code></span>
<span class="codeline" id="line-1281"><code>		return true</code></span>
<span class="codeline" id="line-1282"><code>	}</code></span>
<span class="codeline" id="line-1283"><code>	return false</code></span>
<span class="codeline" id="line-1284"><code>}</code></span>
<span class="codeline" id="line-1285"><code></code></span>
<span class="codeline" id="line-1286"><code>// IsRFC3339 checks if string is valid timestamp value according to RFC3339</code></span>
<span class="codeline" id="line-1287"><code>func IsRFC3339(str string) bool {</code></span>
<span class="codeline" id="line-1288"><code>	return IsTime(str, time.RFC3339)</code></span>
<span class="codeline" id="line-1289"><code>}</code></span>
<span class="codeline" id="line-1290"><code></code></span>
<span class="codeline" id="line-1291"><code>// IsRFC3339WithoutZone checks if string is valid timestamp value according to RFC3339 which excludes the timezone.</code></span>
<span class="codeline" id="line-1292"><code>func IsRFC3339WithoutZone(str string) bool {</code></span>
<span class="codeline" id="line-1293"><code>	return IsTime(str, rfc3339WithoutZone)</code></span>
<span class="codeline" id="line-1294"><code>}</code></span>
<span class="codeline" id="line-1295"><code></code></span>
<span class="codeline" id="line-1296"><code>// IsISO4217 checks if string is valid ISO currency code</code></span>
<span class="codeline" id="line-1297"><code>func IsISO4217(str string) bool {</code></span>
<span class="codeline" id="line-1298"><code>	for _, currency := range ISO4217List {</code></span>
<span class="codeline" id="line-1299"><code>		if str == currency {</code></span>
<span class="codeline" id="line-1300"><code>			return true</code></span>
<span class="codeline" id="line-1301"><code>		}</code></span>
<span class="codeline" id="line-1302"><code>	}</code></span>
<span class="codeline" id="line-1303"><code></code></span>
<span class="codeline" id="line-1304"><code>	return false</code></span>
<span class="codeline" id="line-1305"><code>}</code></span>
<span class="codeline" id="line-1306"><code></code></span>
<span class="codeline" id="line-1307"><code>// ByteLength checks string's length</code></span>
<span class="codeline" id="line-1308"><code>func ByteLength(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1309"><code>	if len(params) == 2 {</code></span>
<span class="codeline" id="line-1310"><code>		min, _ := ToInt(params[0])</code></span>
<span class="codeline" id="line-1311"><code>		max, _ := ToInt(params[1])</code></span>
<span class="codeline" id="line-1312"><code>		return len(str) &gt;= int(min) &amp;&amp; len(str) &lt;= int(max)</code></span>
<span class="codeline" id="line-1313"><code>	}</code></span>
<span class="codeline" id="line-1314"><code></code></span>
<span class="codeline" id="line-1315"><code>	return false</code></span>
<span class="codeline" id="line-1316"><code>}</code></span>
<span class="codeline" id="line-1317"><code></code></span>
<span class="codeline" id="line-1318"><code>// RuneLength checks string's length</code></span>
<span class="codeline" id="line-1319"><code>// Alias for StringLength</code></span>
<span class="codeline" id="line-1320"><code>func RuneLength(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1321"><code>	return StringLength(str, params...)</code></span>
<span class="codeline" id="line-1322"><code>}</code></span>
<span class="codeline" id="line-1323"><code></code></span>
<span class="codeline" id="line-1324"><code>// IsRsaPub checks whether string is valid RSA key</code></span>
<span class="codeline" id="line-1325"><code>// Alias for IsRsaPublicKey</code></span>
<span class="codeline" id="line-1326"><code>func IsRsaPub(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1327"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1328"><code>		len, _ := ToInt(params[0])</code></span>
<span class="codeline" id="line-1329"><code>		return IsRsaPublicKey(str, int(len))</code></span>
<span class="codeline" id="line-1330"><code>	}</code></span>
<span class="codeline" id="line-1331"><code></code></span>
<span class="codeline" id="line-1332"><code>	return false</code></span>
<span class="codeline" id="line-1333"><code>}</code></span>
<span class="codeline" id="line-1334"><code></code></span>
<span class="codeline" id="line-1335"><code>// StringMatches checks if a string matches a given pattern.</code></span>
<span class="codeline" id="line-1336"><code>func StringMatches(s string, params ...string) bool {</code></span>
<span class="codeline" id="line-1337"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1338"><code>		pattern := params[0]</code></span>
<span class="codeline" id="line-1339"><code>		return Matches(s, pattern)</code></span>
<span class="codeline" id="line-1340"><code>	}</code></span>
<span class="codeline" id="line-1341"><code>	return false</code></span>
<span class="codeline" id="line-1342"><code>}</code></span>
<span class="codeline" id="line-1343"><code></code></span>
<span class="codeline" id="line-1344"><code>// StringLength checks string's length (including multi byte strings)</code></span>
<span class="codeline" id="line-1345"><code>func StringLength(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1346"><code></code></span>
<span class="codeline" id="line-1347"><code>	if len(params) == 2 {</code></span>
<span class="codeline" id="line-1348"><code>		strLength := utf8.RuneCountInString(str)</code></span>
<span class="codeline" id="line-1349"><code>		min, _ := ToInt(params[0])</code></span>
<span class="codeline" id="line-1350"><code>		max, _ := ToInt(params[1])</code></span>
<span class="codeline" id="line-1351"><code>		return strLength &gt;= int(min) &amp;&amp; strLength &lt;= int(max)</code></span>
<span class="codeline" id="line-1352"><code>	}</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>	return false</code></span>
<span class="codeline" id="line-1355"><code>}</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>// MinStringLength checks string's minimum length (including multi byte strings)</code></span>
<span class="codeline" id="line-1358"><code>func MinStringLength(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1359"><code></code></span>
<span class="codeline" id="line-1360"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1361"><code>		strLength := utf8.RuneCountInString(str)</code></span>
<span class="codeline" id="line-1362"><code>		min, _ := ToInt(params[0])</code></span>
<span class="codeline" id="line-1363"><code>		return strLength &gt;= int(min)</code></span>
<span class="codeline" id="line-1364"><code>	}</code></span>
<span class="codeline" id="line-1365"><code></code></span>
<span class="codeline" id="line-1366"><code>	return false</code></span>
<span class="codeline" id="line-1367"><code>}</code></span>
<span class="codeline" id="line-1368"><code></code></span>
<span class="codeline" id="line-1369"><code>// MaxStringLength checks string's maximum length (including multi byte strings)</code></span>
<span class="codeline" id="line-1370"><code>func MaxStringLength(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1371"><code></code></span>
<span class="codeline" id="line-1372"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1373"><code>		strLength := utf8.RuneCountInString(str)</code></span>
<span class="codeline" id="line-1374"><code>		max, _ := ToInt(params[0])</code></span>
<span class="codeline" id="line-1375"><code>		return strLength &lt;= int(max)</code></span>
<span class="codeline" id="line-1376"><code>	}</code></span>
<span class="codeline" id="line-1377"><code></code></span>
<span class="codeline" id="line-1378"><code>	return false</code></span>
<span class="codeline" id="line-1379"><code>}</code></span>
<span class="codeline" id="line-1380"><code></code></span>
<span class="codeline" id="line-1381"><code>// Range checks string's length</code></span>
<span class="codeline" id="line-1382"><code>func Range(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1383"><code>	if len(params) == 2 {</code></span>
<span class="codeline" id="line-1384"><code>		value, _ := ToFloat(str)</code></span>
<span class="codeline" id="line-1385"><code>		min, _ := ToFloat(params[0])</code></span>
<span class="codeline" id="line-1386"><code>		max, _ := ToFloat(params[1])</code></span>
<span class="codeline" id="line-1387"><code>		return InRange(value, min, max)</code></span>
<span class="codeline" id="line-1388"><code>	}</code></span>
<span class="codeline" id="line-1389"><code></code></span>
<span class="codeline" id="line-1390"><code>	return false</code></span>
<span class="codeline" id="line-1391"><code>}</code></span>
<span class="codeline" id="line-1392"><code></code></span>
<span class="codeline" id="line-1393"><code>// IsInRaw checks if string is in list of allowed values</code></span>
<span class="codeline" id="line-1394"><code>func IsInRaw(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1395"><code>	if len(params) == 1 {</code></span>
<span class="codeline" id="line-1396"><code>		rawParams := params[0]</code></span>
<span class="codeline" id="line-1397"><code></code></span>
<span class="codeline" id="line-1398"><code>		parsedParams := strings.Split(rawParams, "|")</code></span>
<span class="codeline" id="line-1399"><code></code></span>
<span class="codeline" id="line-1400"><code>		return IsIn(str, parsedParams...)</code></span>
<span class="codeline" id="line-1401"><code>	}</code></span>
<span class="codeline" id="line-1402"><code></code></span>
<span class="codeline" id="line-1403"><code>	return false</code></span>
<span class="codeline" id="line-1404"><code>}</code></span>
<span class="codeline" id="line-1405"><code></code></span>
<span class="codeline" id="line-1406"><code>// IsIn checks if string str is a member of the set of strings params</code></span>
<span class="codeline" id="line-1407"><code>func IsIn(str string, params ...string) bool {</code></span>
<span class="codeline" id="line-1408"><code>	for _, param := range params {</code></span>
<span class="codeline" id="line-1409"><code>		if str == param {</code></span>
<span class="codeline" id="line-1410"><code>			return true</code></span>
<span class="codeline" id="line-1411"><code>		}</code></span>
<span class="codeline" id="line-1412"><code>	}</code></span>
<span class="codeline" id="line-1413"><code></code></span>
<span class="codeline" id="line-1414"><code>	return false</code></span>
<span class="codeline" id="line-1415"><code>}</code></span>
<span class="codeline" id="line-1416"><code></code></span>
<span class="codeline" id="line-1417"><code>func checkRequired(v reflect.Value, t reflect.StructField, options tagOptionsMap) (bool, error) {</code></span>
<span class="codeline" id="line-1418"><code>	if nilPtrAllowedByRequired {</code></span>
<span class="codeline" id="line-1419"><code>		k := v.Kind()</code></span>
<span class="codeline" id="line-1420"><code>		if (k == reflect.Ptr || k == reflect.Interface) &amp;&amp; v.IsNil() {</code></span>
<span class="codeline" id="line-1421"><code>			return true, nil</code></span>
<span class="codeline" id="line-1422"><code>		}</code></span>
<span class="codeline" id="line-1423"><code>	}</code></span>
<span class="codeline" id="line-1424"><code></code></span>
<span class="codeline" id="line-1425"><code>	if requiredOption, isRequired := options["required"]; isRequired {</code></span>
<span class="codeline" id="line-1426"><code>		if len(requiredOption.customErrorMessage) &gt; 0 {</code></span>
<span class="codeline" id="line-1427"><code>			return false, Error{t.Name, fmt.Errorf(requiredOption.customErrorMessage), true, "required", []string{}}</code></span>
<span class="codeline" id="line-1428"><code>		}</code></span>
<span class="codeline" id="line-1429"><code>		return false, Error{t.Name, fmt.Errorf("non zero value required"), false, "required", []string{}}</code></span>
<span class="codeline" id="line-1430"><code>	} else if _, isOptional := options["optional"]; fieldsRequiredByDefault &amp;&amp; !isOptional {</code></span>
<span class="codeline" id="line-1431"><code>		return false, Error{t.Name, fmt.Errorf("Missing required field"), false, "required", []string{}}</code></span>
<span class="codeline" id="line-1432"><code>	}</code></span>
<span class="codeline" id="line-1433"><code>	// not required and empty is valid</code></span>
<span class="codeline" id="line-1434"><code>	return true, nil</code></span>
<span class="codeline" id="line-1435"><code>}</code></span>
<span class="codeline" id="line-1436"><code></code></span>
<span class="codeline" id="line-1437"><code>func typeCheck(v reflect.Value, t reflect.StructField, o reflect.Value, options tagOptionsMap) (isValid bool, resultErr error) {</code></span>
<span class="codeline" id="line-1438"><code>	if !v.IsValid() {</code></span>
<span class="codeline" id="line-1439"><code>		return false, nil</code></span>
<span class="codeline" id="line-1440"><code>	}</code></span>
<span class="codeline" id="line-1441"><code></code></span>
<span class="codeline" id="line-1442"><code>	tag := t.Tag.Get(tagName)</code></span>
<span class="codeline" id="line-1443"><code></code></span>
<span class="codeline" id="line-1444"><code>	// checks if the field should be ignored</code></span>
<span class="codeline" id="line-1445"><code>	switch tag {</code></span>
<span class="codeline" id="line-1446"><code>	case "":</code></span>
<span class="codeline" id="line-1447"><code>		if v.Kind() != reflect.Slice &amp;&amp; v.Kind() != reflect.Map {</code></span>
<span class="codeline" id="line-1448"><code>			if !fieldsRequiredByDefault {</code></span>
<span class="codeline" id="line-1449"><code>				return true, nil</code></span>
<span class="codeline" id="line-1450"><code>			}</code></span>
<span class="codeline" id="line-1451"><code>			return false, Error{t.Name, fmt.Errorf("All fields are required to at least have one validation defined"), false, "required", []string{}}</code></span>
<span class="codeline" id="line-1452"><code>		}</code></span>
<span class="codeline" id="line-1453"><code>	case "-":</code></span>
<span class="codeline" id="line-1454"><code>		return true, nil</code></span>
<span class="codeline" id="line-1455"><code>	}</code></span>
<span class="codeline" id="line-1456"><code></code></span>
<span class="codeline" id="line-1457"><code>	isRootType := false</code></span>
<span class="codeline" id="line-1458"><code>	if options == nil {</code></span>
<span class="codeline" id="line-1459"><code>		isRootType = true</code></span>
<span class="codeline" id="line-1460"><code>		options = parseTagIntoMap(tag)</code></span>
<span class="codeline" id="line-1461"><code>	}</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>	if isEmptyValue(v) {</code></span>
<span class="codeline" id="line-1464"><code>		// an empty value is not validated, checks only required</code></span>
<span class="codeline" id="line-1465"><code>		isValid, resultErr = checkRequired(v, t, options)</code></span>
<span class="codeline" id="line-1466"><code>		for key := range options {</code></span>
<span class="codeline" id="line-1467"><code>			delete(options, key)</code></span>
<span class="codeline" id="line-1468"><code>		}</code></span>
<span class="codeline" id="line-1469"><code>		return isValid, resultErr</code></span>
<span class="codeline" id="line-1470"><code>	}</code></span>
<span class="codeline" id="line-1471"><code></code></span>
<span class="codeline" id="line-1472"><code>	var customTypeErrors Errors</code></span>
<span class="codeline" id="line-1473"><code>	optionsOrder := options.orderedKeys()</code></span>
<span class="codeline" id="line-1474"><code>	for _, validatorName := range optionsOrder {</code></span>
<span class="codeline" id="line-1475"><code>		validatorStruct := options[validatorName]</code></span>
<span class="codeline" id="line-1476"><code>		if validatefunc, ok := CustomTypeTagMap.Get(validatorName); ok {</code></span>
<span class="codeline" id="line-1477"><code>			delete(options, validatorName)</code></span>
<span class="codeline" id="line-1478"><code></code></span>
<span class="codeline" id="line-1479"><code>			if result := validatefunc(v.Interface(), o.Interface()); !result {</code></span>
<span class="codeline" id="line-1480"><code>				if len(validatorStruct.customErrorMessage) &gt; 0 {</code></span>
<span class="codeline" id="line-1481"><code>					customTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: TruncatingErrorf(validatorStruct.customErrorMessage, fmt.Sprint(v), validatorName), CustomErrorMessageExists: true, Validator: stripParams(validatorName)})</code></span>
<span class="codeline" id="line-1482"><code>					continue</code></span>
<span class="codeline" id="line-1483"><code>				}</code></span>
<span class="codeline" id="line-1484"><code>				customTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: fmt.Errorf("%s does not validate as %s", fmt.Sprint(v), validatorName), CustomErrorMessageExists: false, Validator: stripParams(validatorName)})</code></span>
<span class="codeline" id="line-1485"><code>			}</code></span>
<span class="codeline" id="line-1486"><code>		}</code></span>
<span class="codeline" id="line-1487"><code>	}</code></span>
<span class="codeline" id="line-1488"><code></code></span>
<span class="codeline" id="line-1489"><code>	if len(customTypeErrors.Errors()) &gt; 0 {</code></span>
<span class="codeline" id="line-1490"><code>		return false, customTypeErrors</code></span>
<span class="codeline" id="line-1491"><code>	}</code></span>
<span class="codeline" id="line-1492"><code></code></span>
<span class="codeline" id="line-1493"><code>	if isRootType {</code></span>
<span class="codeline" id="line-1494"><code>		// Ensure that we've checked the value by all specified validators before report that the value is valid</code></span>
<span class="codeline" id="line-1495"><code>		defer func() {</code></span>
<span class="codeline" id="line-1496"><code>			delete(options, "optional")</code></span>
<span class="codeline" id="line-1497"><code>			delete(options, "required")</code></span>
<span class="codeline" id="line-1498"><code></code></span>
<span class="codeline" id="line-1499"><code>			if isValid &amp;&amp; resultErr == nil &amp;&amp; len(options) != 0 {</code></span>
<span class="codeline" id="line-1500"><code>				optionsOrder := options.orderedKeys()</code></span>
<span class="codeline" id="line-1501"><code>				for _, validator := range optionsOrder {</code></span>
<span class="codeline" id="line-1502"><code>					isValid = false</code></span>
<span class="codeline" id="line-1503"><code>					resultErr = Error{t.Name, fmt.Errorf(</code></span>
<span class="codeline" id="line-1504"><code>						"The following validator is invalid or can't be applied to the field: %q", validator), false, stripParams(validator), []string{}}</code></span>
<span class="codeline" id="line-1505"><code>					return</code></span>
<span class="codeline" id="line-1506"><code>				}</code></span>
<span class="codeline" id="line-1507"><code>			}</code></span>
<span class="codeline" id="line-1508"><code>		}()</code></span>
<span class="codeline" id="line-1509"><code>	}</code></span>
<span class="codeline" id="line-1510"><code></code></span>
<span class="codeline" id="line-1511"><code>	for _, validatorSpec := range optionsOrder {</code></span>
<span class="codeline" id="line-1512"><code>		validatorStruct := options[validatorSpec]</code></span>
<span class="codeline" id="line-1513"><code>		var negate bool</code></span>
<span class="codeline" id="line-1514"><code>		validator := validatorSpec</code></span>
<span class="codeline" id="line-1515"><code>		customMsgExists := len(validatorStruct.customErrorMessage) &gt; 0</code></span>
<span class="codeline" id="line-1516"><code></code></span>
<span class="codeline" id="line-1517"><code>		// checks whether the tag looks like '!something' or 'something'</code></span>
<span class="codeline" id="line-1518"><code>		if validator[0] == '!' {</code></span>
<span class="codeline" id="line-1519"><code>			validator = validator[1:]</code></span>
<span class="codeline" id="line-1520"><code>			negate = true</code></span>
<span class="codeline" id="line-1521"><code>		}</code></span>
<span class="codeline" id="line-1522"><code></code></span>
<span class="codeline" id="line-1523"><code>		// checks for interface param validators</code></span>
<span class="codeline" id="line-1524"><code>		for key, value := range InterfaceParamTagRegexMap {</code></span>
<span class="codeline" id="line-1525"><code>			ps := value.FindStringSubmatch(validator)</code></span>
<span class="codeline" id="line-1526"><code>			if len(ps) == 0 {</code></span>
<span class="codeline" id="line-1527"><code>				continue</code></span>
<span class="codeline" id="line-1528"><code>			}</code></span>
<span class="codeline" id="line-1529"><code></code></span>
<span class="codeline" id="line-1530"><code>			validatefunc, ok := InterfaceParamTagMap[key]</code></span>
<span class="codeline" id="line-1531"><code>			if !ok {</code></span>
<span class="codeline" id="line-1532"><code>				continue</code></span>
<span class="codeline" id="line-1533"><code>			}</code></span>
<span class="codeline" id="line-1534"><code></code></span>
<span class="codeline" id="line-1535"><code>			delete(options, validatorSpec)</code></span>
<span class="codeline" id="line-1536"><code></code></span>
<span class="codeline" id="line-1537"><code>			field := fmt.Sprint(v)</code></span>
<span class="codeline" id="line-1538"><code>			if result := validatefunc(v.Interface(), ps[1:]...); (!result &amp;&amp; !negate) || (result &amp;&amp; negate) {</code></span>
<span class="codeline" id="line-1539"><code>				if customMsgExists {</code></span>
<span class="codeline" id="line-1540"><code>					return false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1541"><code>				}</code></span>
<span class="codeline" id="line-1542"><code>				if negate {</code></span>
<span class="codeline" id="line-1543"><code>					return false, Error{t.Name, fmt.Errorf("%s does validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1544"><code>				}</code></span>
<span class="codeline" id="line-1545"><code>				return false, Error{t.Name, fmt.Errorf("%s does not validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1546"><code>			}</code></span>
<span class="codeline" id="line-1547"><code>		}</code></span>
<span class="codeline" id="line-1548"><code>	}</code></span>
<span class="codeline" id="line-1549"><code></code></span>
<span class="codeline" id="line-1550"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-1551"><code>	case reflect.Bool,</code></span>
<span class="codeline" id="line-1552"><code>		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-1553"><code>		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,</code></span>
<span class="codeline" id="line-1554"><code>		reflect.Float32, reflect.Float64,</code></span>
<span class="codeline" id="line-1555"><code>		reflect.String:</code></span>
<span class="codeline" id="line-1556"><code>		// for each tag option checks the map of validator functions</code></span>
<span class="codeline" id="line-1557"><code>		for _, validatorSpec := range optionsOrder {</code></span>
<span class="codeline" id="line-1558"><code>			validatorStruct := options[validatorSpec]</code></span>
<span class="codeline" id="line-1559"><code>			var negate bool</code></span>
<span class="codeline" id="line-1560"><code>			validator := validatorSpec</code></span>
<span class="codeline" id="line-1561"><code>			customMsgExists := len(validatorStruct.customErrorMessage) &gt; 0</code></span>
<span class="codeline" id="line-1562"><code></code></span>
<span class="codeline" id="line-1563"><code>			// checks whether the tag looks like '!something' or 'something'</code></span>
<span class="codeline" id="line-1564"><code>			if validator[0] == '!' {</code></span>
<span class="codeline" id="line-1565"><code>				validator = validator[1:]</code></span>
<span class="codeline" id="line-1566"><code>				negate = true</code></span>
<span class="codeline" id="line-1567"><code>			}</code></span>
<span class="codeline" id="line-1568"><code></code></span>
<span class="codeline" id="line-1569"><code>			// checks for param validators</code></span>
<span class="codeline" id="line-1570"><code>			for key, value := range ParamTagRegexMap {</code></span>
<span class="codeline" id="line-1571"><code>				ps := value.FindStringSubmatch(validator)</code></span>
<span class="codeline" id="line-1572"><code>				if len(ps) == 0 {</code></span>
<span class="codeline" id="line-1573"><code>					continue</code></span>
<span class="codeline" id="line-1574"><code>				}</code></span>
<span class="codeline" id="line-1575"><code></code></span>
<span class="codeline" id="line-1576"><code>				validatefunc, ok := ParamTagMap[key]</code></span>
<span class="codeline" id="line-1577"><code>				if !ok {</code></span>
<span class="codeline" id="line-1578"><code>					continue</code></span>
<span class="codeline" id="line-1579"><code>				}</code></span>
<span class="codeline" id="line-1580"><code></code></span>
<span class="codeline" id="line-1581"><code>				delete(options, validatorSpec)</code></span>
<span class="codeline" id="line-1582"><code></code></span>
<span class="codeline" id="line-1583"><code>				switch v.Kind() {</code></span>
<span class="codeline" id="line-1584"><code>				case reflect.String,</code></span>
<span class="codeline" id="line-1585"><code>					reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-1586"><code>					reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,</code></span>
<span class="codeline" id="line-1587"><code>					reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-1588"><code></code></span>
<span class="codeline" id="line-1589"><code>					field := fmt.Sprint(v) // make value into string, then validate with regex</code></span>
<span class="codeline" id="line-1590"><code>					if result := validatefunc(field, ps[1:]...); (!result &amp;&amp; !negate) || (result &amp;&amp; negate) {</code></span>
<span class="codeline" id="line-1591"><code>						if customMsgExists {</code></span>
<span class="codeline" id="line-1592"><code>							return false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1593"><code>						}</code></span>
<span class="codeline" id="line-1594"><code>						if negate {</code></span>
<span class="codeline" id="line-1595"><code>							return false, Error{t.Name, fmt.Errorf("%s does validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1596"><code>						}</code></span>
<span class="codeline" id="line-1597"><code>						return false, Error{t.Name, fmt.Errorf("%s does not validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1598"><code>					}</code></span>
<span class="codeline" id="line-1599"><code>				default:</code></span>
<span class="codeline" id="line-1600"><code>					// type not yet supported, fail</code></span>
<span class="codeline" id="line-1601"><code>					return false, Error{t.Name, fmt.Errorf("Validator %s doesn't support kind %s", validator, v.Kind()), false, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1602"><code>				}</code></span>
<span class="codeline" id="line-1603"><code>			}</code></span>
<span class="codeline" id="line-1604"><code></code></span>
<span class="codeline" id="line-1605"><code>			if validatefunc, ok := TagMap[validator]; ok {</code></span>
<span class="codeline" id="line-1606"><code>				delete(options, validatorSpec)</code></span>
<span class="codeline" id="line-1607"><code></code></span>
<span class="codeline" id="line-1608"><code>				switch v.Kind() {</code></span>
<span class="codeline" id="line-1609"><code>				case reflect.String,</code></span>
<span class="codeline" id="line-1610"><code>					reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-1611"><code>					reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,</code></span>
<span class="codeline" id="line-1612"><code>					reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-1613"><code>					field := fmt.Sprint(v) // make value into string, then validate with regex</code></span>
<span class="codeline" id="line-1614"><code>					if result := validatefunc(field); !result &amp;&amp; !negate || result &amp;&amp; negate {</code></span>
<span class="codeline" id="line-1615"><code>						if customMsgExists {</code></span>
<span class="codeline" id="line-1616"><code>							return false, Error{t.Name, TruncatingErrorf(validatorStruct.customErrorMessage, field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1617"><code>						}</code></span>
<span class="codeline" id="line-1618"><code>						if negate {</code></span>
<span class="codeline" id="line-1619"><code>							return false, Error{t.Name, fmt.Errorf("%s does validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1620"><code>						}</code></span>
<span class="codeline" id="line-1621"><code>						return false, Error{t.Name, fmt.Errorf("%s does not validate as %s", field, validator), customMsgExists, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1622"><code>					}</code></span>
<span class="codeline" id="line-1623"><code>				default:</code></span>
<span class="codeline" id="line-1624"><code>					//Not Yet Supported Types (Fail here!)</code></span>
<span class="codeline" id="line-1625"><code>					err := fmt.Errorf("Validator %s doesn't support kind %s for value %v", validator, v.Kind(), v)</code></span>
<span class="codeline" id="line-1626"><code>					return false, Error{t.Name, err, false, stripParams(validatorSpec), []string{}}</code></span>
<span class="codeline" id="line-1627"><code>				}</code></span>
<span class="codeline" id="line-1628"><code>			}</code></span>
<span class="codeline" id="line-1629"><code>		}</code></span>
<span class="codeline" id="line-1630"><code>		return true, nil</code></span>
<span class="codeline" id="line-1631"><code>	case reflect.Map:</code></span>
<span class="codeline" id="line-1632"><code>		if v.Type().Key().Kind() != reflect.String {</code></span>
<span class="codeline" id="line-1633"><code>			return false, &amp;UnsupportedTypeError{v.Type()}</code></span>
<span class="codeline" id="line-1634"><code>		}</code></span>
<span class="codeline" id="line-1635"><code>		var sv stringValues</code></span>
<span class="codeline" id="line-1636"><code>		sv = v.MapKeys()</code></span>
<span class="codeline" id="line-1637"><code>		sort.Sort(sv)</code></span>
<span class="codeline" id="line-1638"><code>		result := true</code></span>
<span class="codeline" id="line-1639"><code>		for i, k := range sv {</code></span>
<span class="codeline" id="line-1640"><code>			var resultItem bool</code></span>
<span class="codeline" id="line-1641"><code>			var err error</code></span>
<span class="codeline" id="line-1642"><code>			if v.MapIndex(k).Kind() != reflect.Struct {</code></span>
<span class="codeline" id="line-1643"><code>				resultItem, err = typeCheck(v.MapIndex(k), t, o, options)</code></span>
<span class="codeline" id="line-1644"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1645"><code>					return false, err</code></span>
<span class="codeline" id="line-1646"><code>				}</code></span>
<span class="codeline" id="line-1647"><code>			} else {</code></span>
<span class="codeline" id="line-1648"><code>				resultItem, err = ValidateStruct(v.MapIndex(k).Interface())</code></span>
<span class="codeline" id="line-1649"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1650"><code>					err = prependPathToErrors(err, t.Name+"."+sv[i].Interface().(string))</code></span>
<span class="codeline" id="line-1651"><code>					return false, err</code></span>
<span class="codeline" id="line-1652"><code>				}</code></span>
<span class="codeline" id="line-1653"><code>			}</code></span>
<span class="codeline" id="line-1654"><code>			result = result &amp;&amp; resultItem</code></span>
<span class="codeline" id="line-1655"><code>		}</code></span>
<span class="codeline" id="line-1656"><code>		return result, nil</code></span>
<span class="codeline" id="line-1657"><code>	case reflect.Slice, reflect.Array:</code></span>
<span class="codeline" id="line-1658"><code>		result := true</code></span>
<span class="codeline" id="line-1659"><code>		for i := 0; i &lt; v.Len(); i++ {</code></span>
<span class="codeline" id="line-1660"><code>			var resultItem bool</code></span>
<span class="codeline" id="line-1661"><code>			var err error</code></span>
<span class="codeline" id="line-1662"><code>			if v.Index(i).Kind() != reflect.Struct {</code></span>
<span class="codeline" id="line-1663"><code>				resultItem, err = typeCheck(v.Index(i), t, o, options)</code></span>
<span class="codeline" id="line-1664"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1665"><code>					return false, err</code></span>
<span class="codeline" id="line-1666"><code>				}</code></span>
<span class="codeline" id="line-1667"><code>			} else {</code></span>
<span class="codeline" id="line-1668"><code>				resultItem, err = ValidateStruct(v.Index(i).Interface())</code></span>
<span class="codeline" id="line-1669"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1670"><code>					err = prependPathToErrors(err, t.Name+"."+strconv.Itoa(i))</code></span>
<span class="codeline" id="line-1671"><code>					return false, err</code></span>
<span class="codeline" id="line-1672"><code>				}</code></span>
<span class="codeline" id="line-1673"><code>			}</code></span>
<span class="codeline" id="line-1674"><code>			result = result &amp;&amp; resultItem</code></span>
<span class="codeline" id="line-1675"><code>		}</code></span>
<span class="codeline" id="line-1676"><code>		return result, nil</code></span>
<span class="codeline" id="line-1677"><code>	case reflect.Interface:</code></span>
<span class="codeline" id="line-1678"><code>		// If the value is an interface then encode its element</code></span>
<span class="codeline" id="line-1679"><code>		if v.IsNil() {</code></span>
<span class="codeline" id="line-1680"><code>			return true, nil</code></span>
<span class="codeline" id="line-1681"><code>		}</code></span>
<span class="codeline" id="line-1682"><code>		return ValidateStruct(v.Interface())</code></span>
<span class="codeline" id="line-1683"><code>	case reflect.Ptr:</code></span>
<span class="codeline" id="line-1684"><code>		// If the value is a pointer then checks its element</code></span>
<span class="codeline" id="line-1685"><code>		if v.IsNil() {</code></span>
<span class="codeline" id="line-1686"><code>			return true, nil</code></span>
<span class="codeline" id="line-1687"><code>		}</code></span>
<span class="codeline" id="line-1688"><code>		return typeCheck(v.Elem(), t, o, options)</code></span>
<span class="codeline" id="line-1689"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-1690"><code>		return true, nil</code></span>
<span class="codeline" id="line-1691"><code>	default:</code></span>
<span class="codeline" id="line-1692"><code>		return false, &amp;UnsupportedTypeError{v.Type()}</code></span>
<span class="codeline" id="line-1693"><code>	}</code></span>
<span class="codeline" id="line-1694"><code>}</code></span>
<span class="codeline" id="line-1695"><code></code></span>
<span class="codeline" id="line-1696"><code>func stripParams(validatorString string) string {</code></span>
<span class="codeline" id="line-1697"><code>	return paramsRegexp.ReplaceAllString(validatorString, "")</code></span>
<span class="codeline" id="line-1698"><code>}</code></span>
<span class="codeline" id="line-1699"><code></code></span>
<span class="codeline" id="line-1700"><code>// isEmptyValue checks whether value empty or not</code></span>
<span class="codeline" id="line-1701"><code>func isEmptyValue(v reflect.Value) bool {</code></span>
<span class="codeline" id="line-1702"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-1703"><code>	case reflect.String, reflect.Array:</code></span>
<span class="codeline" id="line-1704"><code>		return v.Len() == 0</code></span>
<span class="codeline" id="line-1705"><code>	case reflect.Map, reflect.Slice:</code></span>
<span class="codeline" id="line-1706"><code>		return v.Len() == 0 || v.IsNil()</code></span>
<span class="codeline" id="line-1707"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-1708"><code>		return !v.Bool()</code></span>
<span class="codeline" id="line-1709"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-1710"><code>		return v.Int() == 0</code></span>
<span class="codeline" id="line-1711"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-1712"><code>		return v.Uint() == 0</code></span>
<span class="codeline" id="line-1713"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-1714"><code>		return v.Float() == 0</code></span>
<span class="codeline" id="line-1715"><code>	case reflect.Interface, reflect.Ptr:</code></span>
<span class="codeline" id="line-1716"><code>		return v.IsNil()</code></span>
<span class="codeline" id="line-1717"><code>	}</code></span>
<span class="codeline" id="line-1718"><code></code></span>
<span class="codeline" id="line-1719"><code>	return reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface())</code></span>
<span class="codeline" id="line-1720"><code>}</code></span>
<span class="codeline" id="line-1721"><code></code></span>
<span class="codeline" id="line-1722"><code>// ErrorByField returns error for specified field of the struct</code></span>
<span class="codeline" id="line-1723"><code>// validated by ValidateStruct or empty string if there are no errors</code></span>
<span class="codeline" id="line-1724"><code>// or this field doesn't exists or doesn't have any errors.</code></span>
<span class="codeline" id="line-1725"><code>func ErrorByField(e error, field string) string {</code></span>
<span class="codeline" id="line-1726"><code>	if e == nil {</code></span>
<span class="codeline" id="line-1727"><code>		return ""</code></span>
<span class="codeline" id="line-1728"><code>	}</code></span>
<span class="codeline" id="line-1729"><code>	return ErrorsByField(e)[field]</code></span>
<span class="codeline" id="line-1730"><code>}</code></span>
<span class="codeline" id="line-1731"><code></code></span>
<span class="codeline" id="line-1732"><code>// ErrorsByField returns map of errors of the struct validated</code></span>
<span class="codeline" id="line-1733"><code>// by ValidateStruct or empty map if there are no errors.</code></span>
<span class="codeline" id="line-1734"><code>func ErrorsByField(e error) map[string]string {</code></span>
<span class="codeline" id="line-1735"><code>	m := make(map[string]string)</code></span>
<span class="codeline" id="line-1736"><code>	if e == nil {</code></span>
<span class="codeline" id="line-1737"><code>		return m</code></span>
<span class="codeline" id="line-1738"><code>	}</code></span>
<span class="codeline" id="line-1739"><code>	// prototype for ValidateStruct</code></span>
<span class="codeline" id="line-1740"><code></code></span>
<span class="codeline" id="line-1741"><code>	switch e := e.(type) {</code></span>
<span class="codeline" id="line-1742"><code>	case Error:</code></span>
<span class="codeline" id="line-1743"><code>		m[e.Name] = e.Err.Error()</code></span>
<span class="codeline" id="line-1744"><code>	case Errors:</code></span>
<span class="codeline" id="line-1745"><code>		for _, item := range e.Errors() {</code></span>
<span class="codeline" id="line-1746"><code>			n := ErrorsByField(item)</code></span>
<span class="codeline" id="line-1747"><code>			for k, v := range n {</code></span>
<span class="codeline" id="line-1748"><code>				m[k] = v</code></span>
<span class="codeline" id="line-1749"><code>			}</code></span>
<span class="codeline" id="line-1750"><code>		}</code></span>
<span class="codeline" id="line-1751"><code>	}</code></span>
<span class="codeline" id="line-1752"><code></code></span>
<span class="codeline" id="line-1753"><code>	return m</code></span>
<span class="codeline" id="line-1754"><code>}</code></span>
<span class="codeline" id="line-1755"><code></code></span>
<span class="codeline" id="line-1756"><code>// Error returns string equivalent for reflect.Type</code></span>
<span class="codeline" id="line-1757"><code>func (e *UnsupportedTypeError) Error() string {</code></span>
<span class="codeline" id="line-1758"><code>	return "validator: unsupported type: " + e.Type.String()</code></span>
<span class="codeline" id="line-1759"><code>}</code></span>
<span class="codeline" id="line-1760"><code></code></span>
<span class="codeline" id="line-1761"><code>func (sv stringValues) Len() int           { return len(sv) }</code></span>
<span class="codeline" id="line-1762"><code>func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }</code></span>
<span class="codeline" id="line-1763"><code>func (sv stringValues) Less(i, j int) bool { return sv.get(i) &lt; sv.get(j) }</code></span>
<span class="codeline" id="line-1764"><code>func (sv stringValues) get(i int) string   { return sv[i].String() }</code></span>
<span class="codeline" id="line-1765"><code></code></span>
<span class="codeline" id="line-1766"><code>func IsE164(str string) bool {</code></span>
<span class="codeline" id="line-1767"><code>	return rxE164.MatchString(str)</code></span>
<span class="codeline" id="line-1768"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>