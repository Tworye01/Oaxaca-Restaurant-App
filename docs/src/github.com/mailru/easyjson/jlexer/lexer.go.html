<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: lexer.go in package github.com/mailru/easyjson/jlexer</title>
<link href="../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	lexer.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/github.com/mailru/easyjson/jlexer.html">github.com/mailru/easyjson/jlexer</a>
</code></pre>

<pre class="line-numbers">
<div class="anchor" id="doc"><span class="codeline" id="line-1"><code>// Package jlexer contains a JSON lexer implementation.</code></span>
<span class="codeline" id="line-2"><code>//</code></span>
<span class="codeline" id="line-3"><code>// It is expected that it is mostly used with generated parser code, so the interface is tuned</code></span>
<span class="codeline" id="line-4"><code>// for a parser that knows what kind of data is expected.</code></span></div><span class="codeline" id="line-5"><code>package jlexer</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"bytes"</code></span>
<span class="codeline" id="line-9"><code>	"encoding/base64"</code></span>
<span class="codeline" id="line-10"><code>	"encoding/json"</code></span>
<span class="codeline" id="line-11"><code>	"errors"</code></span>
<span class="codeline" id="line-12"><code>	"fmt"</code></span>
<span class="codeline" id="line-13"><code>	"io"</code></span>
<span class="codeline" id="line-14"><code>	"strconv"</code></span>
<span class="codeline" id="line-15"><code>	"unicode"</code></span>
<span class="codeline" id="line-16"><code>	"unicode/utf16"</code></span>
<span class="codeline" id="line-17"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>	"github.com/josharian/intern"</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// tokenKind determines type of a token.</code></span>
<span class="codeline" id="line-23"><code>type tokenKind byte</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>const (</code></span>
<span class="codeline" id="line-26"><code>	tokenUndef  tokenKind = iota // No token.</code></span>
<span class="codeline" id="line-27"><code>	tokenDelim                   // Delimiter: one of '{', '}', '[' or ']'.</code></span>
<span class="codeline" id="line-28"><code>	tokenString                  // A string literal, e.g. "abc\u1234"</code></span>
<span class="codeline" id="line-29"><code>	tokenNumber                  // Number literal, e.g. 1.5e5</code></span>
<span class="codeline" id="line-30"><code>	tokenBool                    // Boolean literal: true or false.</code></span>
<span class="codeline" id="line-31"><code>	tokenNull                    // null keyword.</code></span>
<span class="codeline" id="line-32"><code>)</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// token describes a single token: type, position in the input and value.</code></span>
<span class="codeline" id="line-35"><code>type token struct {</code></span>
<span class="codeline" id="line-36"><code>	kind tokenKind // Type of a token.</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>	boolValue       bool   // Value if a boolean literal token.</code></span>
<span class="codeline" id="line-39"><code>	byteValueCloned bool   // true if byteValue was allocated and does not refer to original json body</code></span>
<span class="codeline" id="line-40"><code>	byteValue       []byte // Raw value of a token.</code></span>
<span class="codeline" id="line-41"><code>	delimValue      byte</code></span>
<span class="codeline" id="line-42"><code>}</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>// Lexer is a JSON lexer: it iterates over JSON tokens in a byte slice.</code></span>
<span class="codeline" id="line-45"><code>type Lexer struct {</code></span>
<span class="codeline" id="line-46"><code>	Data []byte // Input data given to the lexer.</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>	start int   // Start of the current token.</code></span>
<span class="codeline" id="line-49"><code>	pos   int   // Current unscanned position in the input stream.</code></span>
<span class="codeline" id="line-50"><code>	token token // Last scanned token, if token.kind != tokenUndef.</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>	firstElement bool // Whether current element is the first in array or an object.</code></span>
<span class="codeline" id="line-53"><code>	wantSep      byte // A comma or a colon character, which need to occur before a token.</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>	UseMultipleErrors bool          // If we want to use multiple errors.</code></span>
<span class="codeline" id="line-56"><code>	fatalError        error         // Fatal error occurred during lexing. It is usually a syntax error.</code></span>
<span class="codeline" id="line-57"><code>	multipleErrors    []*LexerError // Semantic errors occurred during lexing. Marshalling will be continued after finding this errors.</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// FetchToken scans the input for the next token.</code></span>
<span class="codeline" id="line-61"><code>func (r *Lexer) FetchToken() {</code></span>
<span class="codeline" id="line-62"><code>	r.token.kind = tokenUndef</code></span>
<span class="codeline" id="line-63"><code>	r.start = r.pos</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>	// Check if r.Data has r.pos element</code></span>
<span class="codeline" id="line-66"><code>	// If it doesn't, it mean corrupted input data</code></span>
<span class="codeline" id="line-67"><code>	if len(r.Data) &lt; r.pos {</code></span>
<span class="codeline" id="line-68"><code>		r.errParse("Unexpected end of data")</code></span>
<span class="codeline" id="line-69"><code>		return</code></span>
<span class="codeline" id="line-70"><code>	}</code></span>
<span class="codeline" id="line-71"><code>	// Determine the type of a token by skipping whitespace and reading the</code></span>
<span class="codeline" id="line-72"><code>	// first character.</code></span>
<span class="codeline" id="line-73"><code>	for _, c := range r.Data[r.pos:] {</code></span>
<span class="codeline" id="line-74"><code>		switch c {</code></span>
<span class="codeline" id="line-75"><code>		case ':', ',':</code></span>
<span class="codeline" id="line-76"><code>			if r.wantSep == c {</code></span>
<span class="codeline" id="line-77"><code>				r.pos++</code></span>
<span class="codeline" id="line-78"><code>				r.start++</code></span>
<span class="codeline" id="line-79"><code>				r.wantSep = 0</code></span>
<span class="codeline" id="line-80"><code>			} else {</code></span>
<span class="codeline" id="line-81"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-82"><code>			}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>		case ' ', '\t', '\r', '\n':</code></span>
<span class="codeline" id="line-85"><code>			r.pos++</code></span>
<span class="codeline" id="line-86"><code>			r.start++</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>		case '"':</code></span>
<span class="codeline" id="line-89"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-90"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-91"><code>			}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>			r.token.kind = tokenString</code></span>
<span class="codeline" id="line-94"><code>			r.fetchString()</code></span>
<span class="codeline" id="line-95"><code>			return</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>		case '{', '[':</code></span>
<span class="codeline" id="line-98"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-99"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-100"><code>			}</code></span>
<span class="codeline" id="line-101"><code>			r.firstElement = true</code></span>
<span class="codeline" id="line-102"><code>			r.token.kind = tokenDelim</code></span>
<span class="codeline" id="line-103"><code>			r.token.delimValue = r.Data[r.pos]</code></span>
<span class="codeline" id="line-104"><code>			r.pos++</code></span>
<span class="codeline" id="line-105"><code>			return</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>		case '}', ']':</code></span>
<span class="codeline" id="line-108"><code>			if !r.firstElement &amp;&amp; (r.wantSep != ',') {</code></span>
<span class="codeline" id="line-109"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-110"><code>			}</code></span>
<span class="codeline" id="line-111"><code>			r.wantSep = 0</code></span>
<span class="codeline" id="line-112"><code>			r.token.kind = tokenDelim</code></span>
<span class="codeline" id="line-113"><code>			r.token.delimValue = r.Data[r.pos]</code></span>
<span class="codeline" id="line-114"><code>			r.pos++</code></span>
<span class="codeline" id="line-115"><code>			return</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-':</code></span>
<span class="codeline" id="line-118"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-119"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-120"><code>			}</code></span>
<span class="codeline" id="line-121"><code>			r.token.kind = tokenNumber</code></span>
<span class="codeline" id="line-122"><code>			r.fetchNumber()</code></span>
<span class="codeline" id="line-123"><code>			return</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>		case 'n':</code></span>
<span class="codeline" id="line-126"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-127"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-128"><code>			}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>			r.token.kind = tokenNull</code></span>
<span class="codeline" id="line-131"><code>			r.fetchNull()</code></span>
<span class="codeline" id="line-132"><code>			return</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>		case 't':</code></span>
<span class="codeline" id="line-135"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-136"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-137"><code>			}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>			r.token.kind = tokenBool</code></span>
<span class="codeline" id="line-140"><code>			r.token.boolValue = true</code></span>
<span class="codeline" id="line-141"><code>			r.fetchTrue()</code></span>
<span class="codeline" id="line-142"><code>			return</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>		case 'f':</code></span>
<span class="codeline" id="line-145"><code>			if r.wantSep != 0 {</code></span>
<span class="codeline" id="line-146"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-147"><code>			}</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>			r.token.kind = tokenBool</code></span>
<span class="codeline" id="line-150"><code>			r.token.boolValue = false</code></span>
<span class="codeline" id="line-151"><code>			r.fetchFalse()</code></span>
<span class="codeline" id="line-152"><code>			return</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>		default:</code></span>
<span class="codeline" id="line-155"><code>			r.errSyntax()</code></span>
<span class="codeline" id="line-156"><code>			return</code></span>
<span class="codeline" id="line-157"><code>		}</code></span>
<span class="codeline" id="line-158"><code>	}</code></span>
<span class="codeline" id="line-159"><code>	r.fatalError = io.EOF</code></span>
<span class="codeline" id="line-160"><code>	return</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// isTokenEnd returns true if the char can follow a non-delimiter token</code></span>
<span class="codeline" id="line-164"><code>func isTokenEnd(c byte) bool {</code></span>
<span class="codeline" id="line-165"><code>	return c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '[' || c == ']' || c == '{' || c == '}' || c == ',' || c == ':'</code></span>
<span class="codeline" id="line-166"><code>}</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>// fetchNull fetches and checks remaining bytes of null keyword.</code></span>
<span class="codeline" id="line-169"><code>func (r *Lexer) fetchNull() {</code></span>
<span class="codeline" id="line-170"><code>	r.pos += 4</code></span>
<span class="codeline" id="line-171"><code>	if r.pos &gt; len(r.Data) ||</code></span>
<span class="codeline" id="line-172"><code>		r.Data[r.pos-3] != 'u' ||</code></span>
<span class="codeline" id="line-173"><code>		r.Data[r.pos-2] != 'l' ||</code></span>
<span class="codeline" id="line-174"><code>		r.Data[r.pos-1] != 'l' ||</code></span>
<span class="codeline" id="line-175"><code>		(r.pos != len(r.Data) &amp;&amp; !isTokenEnd(r.Data[r.pos])) {</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>		r.pos -= 4</code></span>
<span class="codeline" id="line-178"><code>		r.errSyntax()</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>}</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>// fetchTrue fetches and checks remaining bytes of true keyword.</code></span>
<span class="codeline" id="line-183"><code>func (r *Lexer) fetchTrue() {</code></span>
<span class="codeline" id="line-184"><code>	r.pos += 4</code></span>
<span class="codeline" id="line-185"><code>	if r.pos &gt; len(r.Data) ||</code></span>
<span class="codeline" id="line-186"><code>		r.Data[r.pos-3] != 'r' ||</code></span>
<span class="codeline" id="line-187"><code>		r.Data[r.pos-2] != 'u' ||</code></span>
<span class="codeline" id="line-188"><code>		r.Data[r.pos-1] != 'e' ||</code></span>
<span class="codeline" id="line-189"><code>		(r.pos != len(r.Data) &amp;&amp; !isTokenEnd(r.Data[r.pos])) {</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>		r.pos -= 4</code></span>
<span class="codeline" id="line-192"><code>		r.errSyntax()</code></span>
<span class="codeline" id="line-193"><code>	}</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// fetchFalse fetches and checks remaining bytes of false keyword.</code></span>
<span class="codeline" id="line-197"><code>func (r *Lexer) fetchFalse() {</code></span>
<span class="codeline" id="line-198"><code>	r.pos += 5</code></span>
<span class="codeline" id="line-199"><code>	if r.pos &gt; len(r.Data) ||</code></span>
<span class="codeline" id="line-200"><code>		r.Data[r.pos-4] != 'a' ||</code></span>
<span class="codeline" id="line-201"><code>		r.Data[r.pos-3] != 'l' ||</code></span>
<span class="codeline" id="line-202"><code>		r.Data[r.pos-2] != 's' ||</code></span>
<span class="codeline" id="line-203"><code>		r.Data[r.pos-1] != 'e' ||</code></span>
<span class="codeline" id="line-204"><code>		(r.pos != len(r.Data) &amp;&amp; !isTokenEnd(r.Data[r.pos])) {</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>		r.pos -= 5</code></span>
<span class="codeline" id="line-207"><code>		r.errSyntax()</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>// fetchNumber scans a number literal token.</code></span>
<span class="codeline" id="line-212"><code>func (r *Lexer) fetchNumber() {</code></span>
<span class="codeline" id="line-213"><code>	hasE := false</code></span>
<span class="codeline" id="line-214"><code>	afterE := false</code></span>
<span class="codeline" id="line-215"><code>	hasDot := false</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>	r.pos++</code></span>
<span class="codeline" id="line-218"><code>	for i, c := range r.Data[r.pos:] {</code></span>
<span class="codeline" id="line-219"><code>		switch {</code></span>
<span class="codeline" id="line-220"><code>		case c &gt;= '0' &amp;&amp; c &lt;= '9':</code></span>
<span class="codeline" id="line-221"><code>			afterE = false</code></span>
<span class="codeline" id="line-222"><code>		case c == '.' &amp;&amp; !hasDot:</code></span>
<span class="codeline" id="line-223"><code>			hasDot = true</code></span>
<span class="codeline" id="line-224"><code>		case (c == 'e' || c == 'E') &amp;&amp; !hasE:</code></span>
<span class="codeline" id="line-225"><code>			hasE = true</code></span>
<span class="codeline" id="line-226"><code>			hasDot = true</code></span>
<span class="codeline" id="line-227"><code>			afterE = true</code></span>
<span class="codeline" id="line-228"><code>		case (c == '+' || c == '-') &amp;&amp; afterE:</code></span>
<span class="codeline" id="line-229"><code>			afterE = false</code></span>
<span class="codeline" id="line-230"><code>		default:</code></span>
<span class="codeline" id="line-231"><code>			r.pos += i</code></span>
<span class="codeline" id="line-232"><code>			if !isTokenEnd(c) {</code></span>
<span class="codeline" id="line-233"><code>				r.errSyntax()</code></span>
<span class="codeline" id="line-234"><code>			} else {</code></span>
<span class="codeline" id="line-235"><code>				r.token.byteValue = r.Data[r.start:r.pos]</code></span>
<span class="codeline" id="line-236"><code>			}</code></span>
<span class="codeline" id="line-237"><code>			return</code></span>
<span class="codeline" id="line-238"><code>		}</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	r.pos = len(r.Data)</code></span>
<span class="codeline" id="line-242"><code>	r.token.byteValue = r.Data[r.start:]</code></span>
<span class="codeline" id="line-243"><code>}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>// findStringLen tries to scan into the string literal for ending quote char to determine required size.</code></span>
<span class="codeline" id="line-246"><code>// The size will be exact if no escapes are present and may be inexact if there are escaped chars.</code></span>
<span class="codeline" id="line-247"><code>func findStringLen(data []byte) (isValid bool, length int) {</code></span>
<span class="codeline" id="line-248"><code>	for {</code></span>
<span class="codeline" id="line-249"><code>		idx := bytes.IndexByte(data, '"')</code></span>
<span class="codeline" id="line-250"><code>		if idx == -1 {</code></span>
<span class="codeline" id="line-251"><code>			return false, len(data)</code></span>
<span class="codeline" id="line-252"><code>		}</code></span>
<span class="codeline" id="line-253"><code>		if idx == 0 || (idx &gt; 0 &amp;&amp; data[idx-1] != '\\') {</code></span>
<span class="codeline" id="line-254"><code>			return true, length + idx</code></span>
<span class="codeline" id="line-255"><code>		}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>		// count \\\\\\\ sequences. even number of slashes means quote is not really escaped</code></span>
<span class="codeline" id="line-258"><code>		cnt := 1</code></span>
<span class="codeline" id="line-259"><code>		for idx-cnt-1 &gt;= 0 &amp;&amp; data[idx-cnt-1] == '\\' {</code></span>
<span class="codeline" id="line-260"><code>			cnt++</code></span>
<span class="codeline" id="line-261"><code>		}</code></span>
<span class="codeline" id="line-262"><code>		if cnt%2 == 0 {</code></span>
<span class="codeline" id="line-263"><code>			return true, length + idx</code></span>
<span class="codeline" id="line-264"><code>		}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>		length += idx + 1</code></span>
<span class="codeline" id="line-267"><code>		data = data[idx+1:]</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>}</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>// unescapeStringToken performs unescaping of string token.</code></span>
<span class="codeline" id="line-272"><code>// if no escaping is needed, original string is returned, otherwise - a new one allocated</code></span>
<span class="codeline" id="line-273"><code>func (r *Lexer) unescapeStringToken() (err error) {</code></span>
<span class="codeline" id="line-274"><code>	data := r.token.byteValue</code></span>
<span class="codeline" id="line-275"><code>	var unescapedData []byte</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>	for {</code></span>
<span class="codeline" id="line-278"><code>		i := bytes.IndexByte(data, '\\')</code></span>
<span class="codeline" id="line-279"><code>		if i == -1 {</code></span>
<span class="codeline" id="line-280"><code>			break</code></span>
<span class="codeline" id="line-281"><code>		}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>		escapedRune, escapedBytes, err := decodeEscape(data[i:])</code></span>
<span class="codeline" id="line-284"><code>		if err != nil {</code></span>
<span class="codeline" id="line-285"><code>			r.errParse(err.Error())</code></span>
<span class="codeline" id="line-286"><code>			return err</code></span>
<span class="codeline" id="line-287"><code>		}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>		if unescapedData == nil {</code></span>
<span class="codeline" id="line-290"><code>			unescapedData = make([]byte, 0, len(r.token.byteValue))</code></span>
<span class="codeline" id="line-291"><code>		}</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>		var d [4]byte</code></span>
<span class="codeline" id="line-294"><code>		s := utf8.EncodeRune(d[:], escapedRune)</code></span>
<span class="codeline" id="line-295"><code>		unescapedData = append(unescapedData, data[:i]...)</code></span>
<span class="codeline" id="line-296"><code>		unescapedData = append(unescapedData, d[:s]...)</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>		data = data[i+escapedBytes:]</code></span>
<span class="codeline" id="line-299"><code>	}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>	if unescapedData != nil {</code></span>
<span class="codeline" id="line-302"><code>		r.token.byteValue = append(unescapedData, data...)</code></span>
<span class="codeline" id="line-303"><code>		r.token.byteValueCloned = true</code></span>
<span class="codeline" id="line-304"><code>	}</code></span>
<span class="codeline" id="line-305"><code>	return</code></span>
<span class="codeline" id="line-306"><code>}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>// getu4 decodes \uXXXX from the beginning of s, returning the hex value,</code></span>
<span class="codeline" id="line-309"><code>// or it returns -1.</code></span>
<span class="codeline" id="line-310"><code>func getu4(s []byte) rune {</code></span>
<span class="codeline" id="line-311"><code>	if len(s) &lt; 6 || s[0] != '\\' || s[1] != 'u' {</code></span>
<span class="codeline" id="line-312"><code>		return -1</code></span>
<span class="codeline" id="line-313"><code>	}</code></span>
<span class="codeline" id="line-314"><code>	var val rune</code></span>
<span class="codeline" id="line-315"><code>	for i := 2; i &lt; len(s) &amp;&amp; i &lt; 6; i++ {</code></span>
<span class="codeline" id="line-316"><code>		var v byte</code></span>
<span class="codeline" id="line-317"><code>		c := s[i]</code></span>
<span class="codeline" id="line-318"><code>		switch c {</code></span>
<span class="codeline" id="line-319"><code>		case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':</code></span>
<span class="codeline" id="line-320"><code>			v = c - '0'</code></span>
<span class="codeline" id="line-321"><code>		case 'a', 'b', 'c', 'd', 'e', 'f':</code></span>
<span class="codeline" id="line-322"><code>			v = c - 'a' + 10</code></span>
<span class="codeline" id="line-323"><code>		case 'A', 'B', 'C', 'D', 'E', 'F':</code></span>
<span class="codeline" id="line-324"><code>			v = c - 'A' + 10</code></span>
<span class="codeline" id="line-325"><code>		default:</code></span>
<span class="codeline" id="line-326"><code>			return -1</code></span>
<span class="codeline" id="line-327"><code>		}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>		val &lt;&lt;= 4</code></span>
<span class="codeline" id="line-330"><code>		val |= rune(v)</code></span>
<span class="codeline" id="line-331"><code>	}</code></span>
<span class="codeline" id="line-332"><code>	return val</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// decodeEscape processes a single escape sequence and returns number of bytes processed.</code></span>
<span class="codeline" id="line-336"><code>func decodeEscape(data []byte) (decoded rune, bytesProcessed int, err error) {</code></span>
<span class="codeline" id="line-337"><code>	if len(data) &lt; 2 {</code></span>
<span class="codeline" id="line-338"><code>		return 0, 0, errors.New("incorrect escape symbol \\ at the end of token")</code></span>
<span class="codeline" id="line-339"><code>	}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>	c := data[1]</code></span>
<span class="codeline" id="line-342"><code>	switch c {</code></span>
<span class="codeline" id="line-343"><code>	case '"', '/', '\\':</code></span>
<span class="codeline" id="line-344"><code>		return rune(c), 2, nil</code></span>
<span class="codeline" id="line-345"><code>	case 'b':</code></span>
<span class="codeline" id="line-346"><code>		return '\b', 2, nil</code></span>
<span class="codeline" id="line-347"><code>	case 'f':</code></span>
<span class="codeline" id="line-348"><code>		return '\f', 2, nil</code></span>
<span class="codeline" id="line-349"><code>	case 'n':</code></span>
<span class="codeline" id="line-350"><code>		return '\n', 2, nil</code></span>
<span class="codeline" id="line-351"><code>	case 'r':</code></span>
<span class="codeline" id="line-352"><code>		return '\r', 2, nil</code></span>
<span class="codeline" id="line-353"><code>	case 't':</code></span>
<span class="codeline" id="line-354"><code>		return '\t', 2, nil</code></span>
<span class="codeline" id="line-355"><code>	case 'u':</code></span>
<span class="codeline" id="line-356"><code>		rr := getu4(data)</code></span>
<span class="codeline" id="line-357"><code>		if rr &lt; 0 {</code></span>
<span class="codeline" id="line-358"><code>			return 0, 0, errors.New("incorrectly escaped \\uXXXX sequence")</code></span>
<span class="codeline" id="line-359"><code>		}</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>		read := 6</code></span>
<span class="codeline" id="line-362"><code>		if utf16.IsSurrogate(rr) {</code></span>
<span class="codeline" id="line-363"><code>			rr1 := getu4(data[read:])</code></span>
<span class="codeline" id="line-364"><code>			if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {</code></span>
<span class="codeline" id="line-365"><code>				read += 6</code></span>
<span class="codeline" id="line-366"><code>				rr = dec</code></span>
<span class="codeline" id="line-367"><code>			} else {</code></span>
<span class="codeline" id="line-368"><code>				rr = unicode.ReplacementChar</code></span>
<span class="codeline" id="line-369"><code>			}</code></span>
<span class="codeline" id="line-370"><code>		}</code></span>
<span class="codeline" id="line-371"><code>		return rr, read, nil</code></span>
<span class="codeline" id="line-372"><code>	}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>	return 0, 0, errors.New("incorrectly escaped bytes")</code></span>
<span class="codeline" id="line-375"><code>}</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>// fetchString scans a string literal token.</code></span>
<span class="codeline" id="line-378"><code>func (r *Lexer) fetchString() {</code></span>
<span class="codeline" id="line-379"><code>	r.pos++</code></span>
<span class="codeline" id="line-380"><code>	data := r.Data[r.pos:]</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>	isValid, length := findStringLen(data)</code></span>
<span class="codeline" id="line-383"><code>	if !isValid {</code></span>
<span class="codeline" id="line-384"><code>		r.pos += length</code></span>
<span class="codeline" id="line-385"><code>		r.errParse("unterminated string literal")</code></span>
<span class="codeline" id="line-386"><code>		return</code></span>
<span class="codeline" id="line-387"><code>	}</code></span>
<span class="codeline" id="line-388"><code>	r.token.byteValue = data[:length]</code></span>
<span class="codeline" id="line-389"><code>	r.pos += length + 1 // skip closing '"' as well</code></span>
<span class="codeline" id="line-390"><code>}</code></span>
<span class="codeline" id="line-391"><code></code></span>
<span class="codeline" id="line-392"><code>// scanToken scans the next token if no token is currently available in the lexer.</code></span>
<span class="codeline" id="line-393"><code>func (r *Lexer) scanToken() {</code></span>
<span class="codeline" id="line-394"><code>	if r.token.kind != tokenUndef || r.fatalError != nil {</code></span>
<span class="codeline" id="line-395"><code>		return</code></span>
<span class="codeline" id="line-396"><code>	}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>	r.FetchToken()</code></span>
<span class="codeline" id="line-399"><code>}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>// consume resets the current token to allow scanning the next one.</code></span>
<span class="codeline" id="line-402"><code>func (r *Lexer) consume() {</code></span>
<span class="codeline" id="line-403"><code>	r.token.kind = tokenUndef</code></span>
<span class="codeline" id="line-404"><code>	r.token.byteValueCloned = false</code></span>
<span class="codeline" id="line-405"><code>	r.token.delimValue = 0</code></span>
<span class="codeline" id="line-406"><code>}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>// Ok returns true if no error (including io.EOF) was encountered during scanning.</code></span>
<span class="codeline" id="line-409"><code>func (r *Lexer) Ok() bool {</code></span>
<span class="codeline" id="line-410"><code>	return r.fatalError == nil</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>const maxErrorContextLen = 13</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>func (r *Lexer) errParse(what string) {</code></span>
<span class="codeline" id="line-416"><code>	if r.fatalError == nil {</code></span>
<span class="codeline" id="line-417"><code>		var str string</code></span>
<span class="codeline" id="line-418"><code>		if len(r.Data)-r.pos &lt;= maxErrorContextLen {</code></span>
<span class="codeline" id="line-419"><code>			str = string(r.Data)</code></span>
<span class="codeline" id="line-420"><code>		} else {</code></span>
<span class="codeline" id="line-421"><code>			str = string(r.Data[r.pos:r.pos+maxErrorContextLen-3]) + "..."</code></span>
<span class="codeline" id="line-422"><code>		}</code></span>
<span class="codeline" id="line-423"><code>		r.fatalError = &amp;LexerError{</code></span>
<span class="codeline" id="line-424"><code>			Reason: what,</code></span>
<span class="codeline" id="line-425"><code>			Offset: r.pos,</code></span>
<span class="codeline" id="line-426"><code>			Data:   str,</code></span>
<span class="codeline" id="line-427"><code>		}</code></span>
<span class="codeline" id="line-428"><code>	}</code></span>
<span class="codeline" id="line-429"><code>}</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>func (r *Lexer) errSyntax() {</code></span>
<span class="codeline" id="line-432"><code>	r.errParse("syntax error")</code></span>
<span class="codeline" id="line-433"><code>}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>func (r *Lexer) errInvalidToken(expected string) {</code></span>
<span class="codeline" id="line-436"><code>	if r.fatalError != nil {</code></span>
<span class="codeline" id="line-437"><code>		return</code></span>
<span class="codeline" id="line-438"><code>	}</code></span>
<span class="codeline" id="line-439"><code>	if r.UseMultipleErrors {</code></span>
<span class="codeline" id="line-440"><code>		r.pos = r.start</code></span>
<span class="codeline" id="line-441"><code>		r.consume()</code></span>
<span class="codeline" id="line-442"><code>		r.SkipRecursive()</code></span>
<span class="codeline" id="line-443"><code>		switch expected {</code></span>
<span class="codeline" id="line-444"><code>		case "[":</code></span>
<span class="codeline" id="line-445"><code>			r.token.delimValue = ']'</code></span>
<span class="codeline" id="line-446"><code>			r.token.kind = tokenDelim</code></span>
<span class="codeline" id="line-447"><code>		case "{":</code></span>
<span class="codeline" id="line-448"><code>			r.token.delimValue = '}'</code></span>
<span class="codeline" id="line-449"><code>			r.token.kind = tokenDelim</code></span>
<span class="codeline" id="line-450"><code>		}</code></span>
<span class="codeline" id="line-451"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-452"><code>			Reason: fmt.Sprintf("expected %s", expected),</code></span>
<span class="codeline" id="line-453"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-454"><code>			Data:   string(r.Data[r.start:r.pos]),</code></span>
<span class="codeline" id="line-455"><code>		})</code></span>
<span class="codeline" id="line-456"><code>		return</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>	var str string</code></span>
<span class="codeline" id="line-460"><code>	if len(r.token.byteValue) &lt;= maxErrorContextLen {</code></span>
<span class="codeline" id="line-461"><code>		str = string(r.token.byteValue)</code></span>
<span class="codeline" id="line-462"><code>	} else {</code></span>
<span class="codeline" id="line-463"><code>		str = string(r.token.byteValue[:maxErrorContextLen-3]) + "..."</code></span>
<span class="codeline" id="line-464"><code>	}</code></span>
<span class="codeline" id="line-465"><code>	r.fatalError = &amp;LexerError{</code></span>
<span class="codeline" id="line-466"><code>		Reason: fmt.Sprintf("expected %s", expected),</code></span>
<span class="codeline" id="line-467"><code>		Offset: r.pos,</code></span>
<span class="codeline" id="line-468"><code>		Data:   str,</code></span>
<span class="codeline" id="line-469"><code>	}</code></span>
<span class="codeline" id="line-470"><code>}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>func (r *Lexer) GetPos() int {</code></span>
<span class="codeline" id="line-473"><code>	return r.pos</code></span>
<span class="codeline" id="line-474"><code>}</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>// Delim consumes a token and verifies that it is the given delimiter.</code></span>
<span class="codeline" id="line-477"><code>func (r *Lexer) Delim(c byte) {</code></span>
<span class="codeline" id="line-478"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-479"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>	if !r.Ok() || r.token.delimValue != c {</code></span>
<span class="codeline" id="line-483"><code>		r.consume() // errInvalidToken can change token if UseMultipleErrors is enabled.</code></span>
<span class="codeline" id="line-484"><code>		r.errInvalidToken(string([]byte{c}))</code></span>
<span class="codeline" id="line-485"><code>	} else {</code></span>
<span class="codeline" id="line-486"><code>		r.consume()</code></span>
<span class="codeline" id="line-487"><code>	}</code></span>
<span class="codeline" id="line-488"><code>}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>// IsDelim returns true if there was no scanning error and next token is the given delimiter.</code></span>
<span class="codeline" id="line-491"><code>func (r *Lexer) IsDelim(c byte) bool {</code></span>
<span class="codeline" id="line-492"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-493"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-494"><code>	}</code></span>
<span class="codeline" id="line-495"><code>	return !r.Ok() || r.token.delimValue == c</code></span>
<span class="codeline" id="line-496"><code>}</code></span>
<span class="codeline" id="line-497"><code></code></span>
<span class="codeline" id="line-498"><code>// Null verifies that the next token is null and consumes it.</code></span>
<span class="codeline" id="line-499"><code>func (r *Lexer) Null() {</code></span>
<span class="codeline" id="line-500"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-501"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-502"><code>	}</code></span>
<span class="codeline" id="line-503"><code>	if !r.Ok() || r.token.kind != tokenNull {</code></span>
<span class="codeline" id="line-504"><code>		r.errInvalidToken("null")</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>	r.consume()</code></span>
<span class="codeline" id="line-507"><code>}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>// IsNull returns true if the next token is a null keyword.</code></span>
<span class="codeline" id="line-510"><code>func (r *Lexer) IsNull() bool {</code></span>
<span class="codeline" id="line-511"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-512"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-513"><code>	}</code></span>
<span class="codeline" id="line-514"><code>	return r.Ok() &amp;&amp; r.token.kind == tokenNull</code></span>
<span class="codeline" id="line-515"><code>}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>// Skip skips a single token.</code></span>
<span class="codeline" id="line-518"><code>func (r *Lexer) Skip() {</code></span>
<span class="codeline" id="line-519"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-520"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code>	r.consume()</code></span>
<span class="codeline" id="line-523"><code>}</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>// SkipRecursive skips next array or object completely, or just skips a single token if not</code></span>
<span class="codeline" id="line-526"><code>// an array/object.</code></span>
<span class="codeline" id="line-527"><code>//</code></span>
<span class="codeline" id="line-528"><code>// Note: no syntax validation is performed on the skipped data.</code></span>
<span class="codeline" id="line-529"><code>func (r *Lexer) SkipRecursive() {</code></span>
<span class="codeline" id="line-530"><code>	r.scanToken()</code></span>
<span class="codeline" id="line-531"><code>	var start, end byte</code></span>
<span class="codeline" id="line-532"><code>	startPos := r.start</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>	switch r.token.delimValue {</code></span>
<span class="codeline" id="line-535"><code>	case '{':</code></span>
<span class="codeline" id="line-536"><code>		start, end = '{', '}'</code></span>
<span class="codeline" id="line-537"><code>	case '[':</code></span>
<span class="codeline" id="line-538"><code>		start, end = '[', ']'</code></span>
<span class="codeline" id="line-539"><code>	default:</code></span>
<span class="codeline" id="line-540"><code>		r.consume()</code></span>
<span class="codeline" id="line-541"><code>		return</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>	r.consume()</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>	level := 1</code></span>
<span class="codeline" id="line-547"><code>	inQuotes := false</code></span>
<span class="codeline" id="line-548"><code>	wasEscape := false</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>	for i, c := range r.Data[r.pos:] {</code></span>
<span class="codeline" id="line-551"><code>		switch {</code></span>
<span class="codeline" id="line-552"><code>		case c == start &amp;&amp; !inQuotes:</code></span>
<span class="codeline" id="line-553"><code>			level++</code></span>
<span class="codeline" id="line-554"><code>		case c == end &amp;&amp; !inQuotes:</code></span>
<span class="codeline" id="line-555"><code>			level--</code></span>
<span class="codeline" id="line-556"><code>			if level == 0 {</code></span>
<span class="codeline" id="line-557"><code>				r.pos += i + 1</code></span>
<span class="codeline" id="line-558"><code>				if !json.Valid(r.Data[startPos:r.pos]) {</code></span>
<span class="codeline" id="line-559"><code>					r.pos = len(r.Data)</code></span>
<span class="codeline" id="line-560"><code>					r.fatalError = &amp;LexerError{</code></span>
<span class="codeline" id="line-561"><code>						Reason: "skipped array/object json value is invalid",</code></span>
<span class="codeline" id="line-562"><code>						Offset: r.pos,</code></span>
<span class="codeline" id="line-563"><code>						Data:   string(r.Data[r.pos:]),</code></span>
<span class="codeline" id="line-564"><code>					}</code></span>
<span class="codeline" id="line-565"><code>				}</code></span>
<span class="codeline" id="line-566"><code>				return</code></span>
<span class="codeline" id="line-567"><code>			}</code></span>
<span class="codeline" id="line-568"><code>		case c == '\\' &amp;&amp; inQuotes:</code></span>
<span class="codeline" id="line-569"><code>			wasEscape = !wasEscape</code></span>
<span class="codeline" id="line-570"><code>			continue</code></span>
<span class="codeline" id="line-571"><code>		case c == '"' &amp;&amp; inQuotes:</code></span>
<span class="codeline" id="line-572"><code>			inQuotes = wasEscape</code></span>
<span class="codeline" id="line-573"><code>		case c == '"':</code></span>
<span class="codeline" id="line-574"><code>			inQuotes = true</code></span>
<span class="codeline" id="line-575"><code>		}</code></span>
<span class="codeline" id="line-576"><code>		wasEscape = false</code></span>
<span class="codeline" id="line-577"><code>	}</code></span>
<span class="codeline" id="line-578"><code>	r.pos = len(r.Data)</code></span>
<span class="codeline" id="line-579"><code>	r.fatalError = &amp;LexerError{</code></span>
<span class="codeline" id="line-580"><code>		Reason: "EOF reached while skipping array/object or token",</code></span>
<span class="codeline" id="line-581"><code>		Offset: r.pos,</code></span>
<span class="codeline" id="line-582"><code>		Data:   string(r.Data[r.pos:]),</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code>}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>// Raw fetches the next item recursively as a data slice</code></span>
<span class="codeline" id="line-587"><code>func (r *Lexer) Raw() []byte {</code></span>
<span class="codeline" id="line-588"><code>	r.SkipRecursive()</code></span>
<span class="codeline" id="line-589"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-590"><code>		return nil</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>	return r.Data[r.start:r.pos]</code></span>
<span class="codeline" id="line-593"><code>}</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>// IsStart returns whether the lexer is positioned at the start</code></span>
<span class="codeline" id="line-596"><code>// of an input string.</code></span>
<span class="codeline" id="line-597"><code>func (r *Lexer) IsStart() bool {</code></span>
<span class="codeline" id="line-598"><code>	return r.pos == 0</code></span>
<span class="codeline" id="line-599"><code>}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>// Consumed reads all remaining bytes from the input, publishing an error if</code></span>
<span class="codeline" id="line-602"><code>// there is anything but whitespace remaining.</code></span>
<span class="codeline" id="line-603"><code>func (r *Lexer) Consumed() {</code></span>
<span class="codeline" id="line-604"><code>	if r.pos &gt; len(r.Data) || !r.Ok() {</code></span>
<span class="codeline" id="line-605"><code>		return</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>	for _, c := range r.Data[r.pos:] {</code></span>
<span class="codeline" id="line-609"><code>		if c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\r' &amp;&amp; c != '\n' {</code></span>
<span class="codeline" id="line-610"><code>			r.AddError(&amp;LexerError{</code></span>
<span class="codeline" id="line-611"><code>				Reason: "invalid character '" + string(c) + "' after top-level value",</code></span>
<span class="codeline" id="line-612"><code>				Offset: r.pos,</code></span>
<span class="codeline" id="line-613"><code>				Data:   string(r.Data[r.pos:]),</code></span>
<span class="codeline" id="line-614"><code>			})</code></span>
<span class="codeline" id="line-615"><code>			return</code></span>
<span class="codeline" id="line-616"><code>		}</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>		r.pos++</code></span>
<span class="codeline" id="line-619"><code>		r.start++</code></span>
<span class="codeline" id="line-620"><code>	}</code></span>
<span class="codeline" id="line-621"><code>}</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>func (r *Lexer) unsafeString(skipUnescape bool) (string, []byte) {</code></span>
<span class="codeline" id="line-624"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-625"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-626"><code>	}</code></span>
<span class="codeline" id="line-627"><code>	if !r.Ok() || r.token.kind != tokenString {</code></span>
<span class="codeline" id="line-628"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-629"><code>		return "", nil</code></span>
<span class="codeline" id="line-630"><code>	}</code></span>
<span class="codeline" id="line-631"><code>	if !skipUnescape {</code></span>
<span class="codeline" id="line-632"><code>		if err := r.unescapeStringToken(); err != nil {</code></span>
<span class="codeline" id="line-633"><code>			r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-634"><code>			return "", nil</code></span>
<span class="codeline" id="line-635"><code>		}</code></span>
<span class="codeline" id="line-636"><code>	}</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>	bytes := r.token.byteValue</code></span>
<span class="codeline" id="line-639"><code>	ret := bytesToStr(r.token.byteValue)</code></span>
<span class="codeline" id="line-640"><code>	r.consume()</code></span>
<span class="codeline" id="line-641"><code>	return ret, bytes</code></span>
<span class="codeline" id="line-642"><code>}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>// UnsafeString returns the string value if the token is a string literal.</code></span>
<span class="codeline" id="line-645"><code>//</code></span>
<span class="codeline" id="line-646"><code>// Warning: returned string may point to the input buffer, so the string should not outlive</code></span>
<span class="codeline" id="line-647"><code>// the input buffer. Intended pattern of usage is as an argument to a switch statement.</code></span>
<span class="codeline" id="line-648"><code>func (r *Lexer) UnsafeString() string {</code></span>
<span class="codeline" id="line-649"><code>	ret, _ := r.unsafeString(false)</code></span>
<span class="codeline" id="line-650"><code>	return ret</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>// UnsafeBytes returns the byte slice if the token is a string literal.</code></span>
<span class="codeline" id="line-654"><code>func (r *Lexer) UnsafeBytes() []byte {</code></span>
<span class="codeline" id="line-655"><code>	_, ret := r.unsafeString(false)</code></span>
<span class="codeline" id="line-656"><code>	return ret</code></span>
<span class="codeline" id="line-657"><code>}</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>// UnsafeFieldName returns current member name string token</code></span>
<span class="codeline" id="line-660"><code>func (r *Lexer) UnsafeFieldName(skipUnescape bool) string {</code></span>
<span class="codeline" id="line-661"><code>	ret, _ := r.unsafeString(skipUnescape)</code></span>
<span class="codeline" id="line-662"><code>	return ret</code></span>
<span class="codeline" id="line-663"><code>}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>// String reads a string literal.</code></span>
<span class="codeline" id="line-666"><code>func (r *Lexer) String() string {</code></span>
<span class="codeline" id="line-667"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-668"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-669"><code>	}</code></span>
<span class="codeline" id="line-670"><code>	if !r.Ok() || r.token.kind != tokenString {</code></span>
<span class="codeline" id="line-671"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-672"><code>		return ""</code></span>
<span class="codeline" id="line-673"><code>	}</code></span>
<span class="codeline" id="line-674"><code>	if err := r.unescapeStringToken(); err != nil {</code></span>
<span class="codeline" id="line-675"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-676"><code>		return ""</code></span>
<span class="codeline" id="line-677"><code>	}</code></span>
<span class="codeline" id="line-678"><code>	var ret string</code></span>
<span class="codeline" id="line-679"><code>	if r.token.byteValueCloned {</code></span>
<span class="codeline" id="line-680"><code>		ret = bytesToStr(r.token.byteValue)</code></span>
<span class="codeline" id="line-681"><code>	} else {</code></span>
<span class="codeline" id="line-682"><code>		ret = string(r.token.byteValue)</code></span>
<span class="codeline" id="line-683"><code>	}</code></span>
<span class="codeline" id="line-684"><code>	r.consume()</code></span>
<span class="codeline" id="line-685"><code>	return ret</code></span>
<span class="codeline" id="line-686"><code>}</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>// StringIntern reads a string literal, and performs string interning on it.</code></span>
<span class="codeline" id="line-689"><code>func (r *Lexer) StringIntern() string {</code></span>
<span class="codeline" id="line-690"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-691"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-692"><code>	}</code></span>
<span class="codeline" id="line-693"><code>	if !r.Ok() || r.token.kind != tokenString {</code></span>
<span class="codeline" id="line-694"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-695"><code>		return ""</code></span>
<span class="codeline" id="line-696"><code>	}</code></span>
<span class="codeline" id="line-697"><code>	if err := r.unescapeStringToken(); err != nil {</code></span>
<span class="codeline" id="line-698"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-699"><code>		return ""</code></span>
<span class="codeline" id="line-700"><code>	}</code></span>
<span class="codeline" id="line-701"><code>	ret := intern.Bytes(r.token.byteValue)</code></span>
<span class="codeline" id="line-702"><code>	r.consume()</code></span>
<span class="codeline" id="line-703"><code>	return ret</code></span>
<span class="codeline" id="line-704"><code>}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>// Bytes reads a string literal and base64 decodes it into a byte slice.</code></span>
<span class="codeline" id="line-707"><code>func (r *Lexer) Bytes() []byte {</code></span>
<span class="codeline" id="line-708"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-709"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>	if !r.Ok() || r.token.kind != tokenString {</code></span>
<span class="codeline" id="line-712"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-713"><code>		return nil</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>	if err := r.unescapeStringToken(); err != nil {</code></span>
<span class="codeline" id="line-716"><code>		r.errInvalidToken("string")</code></span>
<span class="codeline" id="line-717"><code>		return nil</code></span>
<span class="codeline" id="line-718"><code>	}</code></span>
<span class="codeline" id="line-719"><code>	ret := make([]byte, base64.StdEncoding.DecodedLen(len(r.token.byteValue)))</code></span>
<span class="codeline" id="line-720"><code>	n, err := base64.StdEncoding.Decode(ret, r.token.byteValue)</code></span>
<span class="codeline" id="line-721"><code>	if err != nil {</code></span>
<span class="codeline" id="line-722"><code>		r.fatalError = &amp;LexerError{</code></span>
<span class="codeline" id="line-723"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-724"><code>		}</code></span>
<span class="codeline" id="line-725"><code>		return nil</code></span>
<span class="codeline" id="line-726"><code>	}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>	r.consume()</code></span>
<span class="codeline" id="line-729"><code>	return ret[:n]</code></span>
<span class="codeline" id="line-730"><code>}</code></span>
<span class="codeline" id="line-731"><code></code></span>
<span class="codeline" id="line-732"><code>// Bool reads a true or false boolean keyword.</code></span>
<span class="codeline" id="line-733"><code>func (r *Lexer) Bool() bool {</code></span>
<span class="codeline" id="line-734"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-735"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-736"><code>	}</code></span>
<span class="codeline" id="line-737"><code>	if !r.Ok() || r.token.kind != tokenBool {</code></span>
<span class="codeline" id="line-738"><code>		r.errInvalidToken("bool")</code></span>
<span class="codeline" id="line-739"><code>		return false</code></span>
<span class="codeline" id="line-740"><code>	}</code></span>
<span class="codeline" id="line-741"><code>	ret := r.token.boolValue</code></span>
<span class="codeline" id="line-742"><code>	r.consume()</code></span>
<span class="codeline" id="line-743"><code>	return ret</code></span>
<span class="codeline" id="line-744"><code>}</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>func (r *Lexer) number() string {</code></span>
<span class="codeline" id="line-747"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-748"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-749"><code>	}</code></span>
<span class="codeline" id="line-750"><code>	if !r.Ok() || r.token.kind != tokenNumber {</code></span>
<span class="codeline" id="line-751"><code>		r.errInvalidToken("number")</code></span>
<span class="codeline" id="line-752"><code>		return ""</code></span>
<span class="codeline" id="line-753"><code>	}</code></span>
<span class="codeline" id="line-754"><code>	ret := bytesToStr(r.token.byteValue)</code></span>
<span class="codeline" id="line-755"><code>	r.consume()</code></span>
<span class="codeline" id="line-756"><code>	return ret</code></span>
<span class="codeline" id="line-757"><code>}</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>func (r *Lexer) Uint8() uint8 {</code></span>
<span class="codeline" id="line-760"><code>	s := r.number()</code></span>
<span class="codeline" id="line-761"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-762"><code>		return 0</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	n, err := strconv.ParseUint(s, 10, 8)</code></span>
<span class="codeline" id="line-766"><code>	if err != nil {</code></span>
<span class="codeline" id="line-767"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-768"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-769"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-770"><code>			Data:   s,</code></span>
<span class="codeline" id="line-771"><code>		})</code></span>
<span class="codeline" id="line-772"><code>	}</code></span>
<span class="codeline" id="line-773"><code>	return uint8(n)</code></span>
<span class="codeline" id="line-774"><code>}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>func (r *Lexer) Uint16() uint16 {</code></span>
<span class="codeline" id="line-777"><code>	s := r.number()</code></span>
<span class="codeline" id="line-778"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-779"><code>		return 0</code></span>
<span class="codeline" id="line-780"><code>	}</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>	n, err := strconv.ParseUint(s, 10, 16)</code></span>
<span class="codeline" id="line-783"><code>	if err != nil {</code></span>
<span class="codeline" id="line-784"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-785"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-786"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-787"><code>			Data:   s,</code></span>
<span class="codeline" id="line-788"><code>		})</code></span>
<span class="codeline" id="line-789"><code>	}</code></span>
<span class="codeline" id="line-790"><code>	return uint16(n)</code></span>
<span class="codeline" id="line-791"><code>}</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>func (r *Lexer) Uint32() uint32 {</code></span>
<span class="codeline" id="line-794"><code>	s := r.number()</code></span>
<span class="codeline" id="line-795"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-796"><code>		return 0</code></span>
<span class="codeline" id="line-797"><code>	}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>	n, err := strconv.ParseUint(s, 10, 32)</code></span>
<span class="codeline" id="line-800"><code>	if err != nil {</code></span>
<span class="codeline" id="line-801"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-802"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-803"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-804"><code>			Data:   s,</code></span>
<span class="codeline" id="line-805"><code>		})</code></span>
<span class="codeline" id="line-806"><code>	}</code></span>
<span class="codeline" id="line-807"><code>	return uint32(n)</code></span>
<span class="codeline" id="line-808"><code>}</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>func (r *Lexer) Uint64() uint64 {</code></span>
<span class="codeline" id="line-811"><code>	s := r.number()</code></span>
<span class="codeline" id="line-812"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-813"><code>		return 0</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>	n, err := strconv.ParseUint(s, 10, 64)</code></span>
<span class="codeline" id="line-817"><code>	if err != nil {</code></span>
<span class="codeline" id="line-818"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-819"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-820"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-821"><code>			Data:   s,</code></span>
<span class="codeline" id="line-822"><code>		})</code></span>
<span class="codeline" id="line-823"><code>	}</code></span>
<span class="codeline" id="line-824"><code>	return n</code></span>
<span class="codeline" id="line-825"><code>}</code></span>
<span class="codeline" id="line-826"><code></code></span>
<span class="codeline" id="line-827"><code>func (r *Lexer) Uint() uint {</code></span>
<span class="codeline" id="line-828"><code>	return uint(r.Uint64())</code></span>
<span class="codeline" id="line-829"><code>}</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>func (r *Lexer) Int8() int8 {</code></span>
<span class="codeline" id="line-832"><code>	s := r.number()</code></span>
<span class="codeline" id="line-833"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-834"><code>		return 0</code></span>
<span class="codeline" id="line-835"><code>	}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>	n, err := strconv.ParseInt(s, 10, 8)</code></span>
<span class="codeline" id="line-838"><code>	if err != nil {</code></span>
<span class="codeline" id="line-839"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-840"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-841"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-842"><code>			Data:   s,</code></span>
<span class="codeline" id="line-843"><code>		})</code></span>
<span class="codeline" id="line-844"><code>	}</code></span>
<span class="codeline" id="line-845"><code>	return int8(n)</code></span>
<span class="codeline" id="line-846"><code>}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>func (r *Lexer) Int16() int16 {</code></span>
<span class="codeline" id="line-849"><code>	s := r.number()</code></span>
<span class="codeline" id="line-850"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-851"><code>		return 0</code></span>
<span class="codeline" id="line-852"><code>	}</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>	n, err := strconv.ParseInt(s, 10, 16)</code></span>
<span class="codeline" id="line-855"><code>	if err != nil {</code></span>
<span class="codeline" id="line-856"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-857"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-858"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-859"><code>			Data:   s,</code></span>
<span class="codeline" id="line-860"><code>		})</code></span>
<span class="codeline" id="line-861"><code>	}</code></span>
<span class="codeline" id="line-862"><code>	return int16(n)</code></span>
<span class="codeline" id="line-863"><code>}</code></span>
<span class="codeline" id="line-864"><code></code></span>
<span class="codeline" id="line-865"><code>func (r *Lexer) Int32() int32 {</code></span>
<span class="codeline" id="line-866"><code>	s := r.number()</code></span>
<span class="codeline" id="line-867"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-868"><code>		return 0</code></span>
<span class="codeline" id="line-869"><code>	}</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>	n, err := strconv.ParseInt(s, 10, 32)</code></span>
<span class="codeline" id="line-872"><code>	if err != nil {</code></span>
<span class="codeline" id="line-873"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-874"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-875"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-876"><code>			Data:   s,</code></span>
<span class="codeline" id="line-877"><code>		})</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code>	return int32(n)</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>func (r *Lexer) Int64() int64 {</code></span>
<span class="codeline" id="line-883"><code>	s := r.number()</code></span>
<span class="codeline" id="line-884"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-885"><code>		return 0</code></span>
<span class="codeline" id="line-886"><code>	}</code></span>
<span class="codeline" id="line-887"><code></code></span>
<span class="codeline" id="line-888"><code>	n, err := strconv.ParseInt(s, 10, 64)</code></span>
<span class="codeline" id="line-889"><code>	if err != nil {</code></span>
<span class="codeline" id="line-890"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-891"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-892"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-893"><code>			Data:   s,</code></span>
<span class="codeline" id="line-894"><code>		})</code></span>
<span class="codeline" id="line-895"><code>	}</code></span>
<span class="codeline" id="line-896"><code>	return n</code></span>
<span class="codeline" id="line-897"><code>}</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>func (r *Lexer) Int() int {</code></span>
<span class="codeline" id="line-900"><code>	return int(r.Int64())</code></span>
<span class="codeline" id="line-901"><code>}</code></span>
<span class="codeline" id="line-902"><code></code></span>
<span class="codeline" id="line-903"><code>func (r *Lexer) Uint8Str() uint8 {</code></span>
<span class="codeline" id="line-904"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-905"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-906"><code>		return 0</code></span>
<span class="codeline" id="line-907"><code>	}</code></span>
<span class="codeline" id="line-908"><code></code></span>
<span class="codeline" id="line-909"><code>	n, err := strconv.ParseUint(s, 10, 8)</code></span>
<span class="codeline" id="line-910"><code>	if err != nil {</code></span>
<span class="codeline" id="line-911"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-912"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-913"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-914"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-915"><code>		})</code></span>
<span class="codeline" id="line-916"><code>	}</code></span>
<span class="codeline" id="line-917"><code>	return uint8(n)</code></span>
<span class="codeline" id="line-918"><code>}</code></span>
<span class="codeline" id="line-919"><code></code></span>
<span class="codeline" id="line-920"><code>func (r *Lexer) Uint16Str() uint16 {</code></span>
<span class="codeline" id="line-921"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-922"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-923"><code>		return 0</code></span>
<span class="codeline" id="line-924"><code>	}</code></span>
<span class="codeline" id="line-925"><code></code></span>
<span class="codeline" id="line-926"><code>	n, err := strconv.ParseUint(s, 10, 16)</code></span>
<span class="codeline" id="line-927"><code>	if err != nil {</code></span>
<span class="codeline" id="line-928"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-929"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-930"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-931"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-932"><code>		})</code></span>
<span class="codeline" id="line-933"><code>	}</code></span>
<span class="codeline" id="line-934"><code>	return uint16(n)</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>func (r *Lexer) Uint32Str() uint32 {</code></span>
<span class="codeline" id="line-938"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-939"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-940"><code>		return 0</code></span>
<span class="codeline" id="line-941"><code>	}</code></span>
<span class="codeline" id="line-942"><code></code></span>
<span class="codeline" id="line-943"><code>	n, err := strconv.ParseUint(s, 10, 32)</code></span>
<span class="codeline" id="line-944"><code>	if err != nil {</code></span>
<span class="codeline" id="line-945"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-946"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-947"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-948"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-949"><code>		})</code></span>
<span class="codeline" id="line-950"><code>	}</code></span>
<span class="codeline" id="line-951"><code>	return uint32(n)</code></span>
<span class="codeline" id="line-952"><code>}</code></span>
<span class="codeline" id="line-953"><code></code></span>
<span class="codeline" id="line-954"><code>func (r *Lexer) Uint64Str() uint64 {</code></span>
<span class="codeline" id="line-955"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-956"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-957"><code>		return 0</code></span>
<span class="codeline" id="line-958"><code>	}</code></span>
<span class="codeline" id="line-959"><code></code></span>
<span class="codeline" id="line-960"><code>	n, err := strconv.ParseUint(s, 10, 64)</code></span>
<span class="codeline" id="line-961"><code>	if err != nil {</code></span>
<span class="codeline" id="line-962"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-963"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-964"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-965"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-966"><code>		})</code></span>
<span class="codeline" id="line-967"><code>	}</code></span>
<span class="codeline" id="line-968"><code>	return n</code></span>
<span class="codeline" id="line-969"><code>}</code></span>
<span class="codeline" id="line-970"><code></code></span>
<span class="codeline" id="line-971"><code>func (r *Lexer) UintStr() uint {</code></span>
<span class="codeline" id="line-972"><code>	return uint(r.Uint64Str())</code></span>
<span class="codeline" id="line-973"><code>}</code></span>
<span class="codeline" id="line-974"><code></code></span>
<span class="codeline" id="line-975"><code>func (r *Lexer) UintptrStr() uintptr {</code></span>
<span class="codeline" id="line-976"><code>	return uintptr(r.Uint64Str())</code></span>
<span class="codeline" id="line-977"><code>}</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>func (r *Lexer) Int8Str() int8 {</code></span>
<span class="codeline" id="line-980"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-981"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-982"><code>		return 0</code></span>
<span class="codeline" id="line-983"><code>	}</code></span>
<span class="codeline" id="line-984"><code></code></span>
<span class="codeline" id="line-985"><code>	n, err := strconv.ParseInt(s, 10, 8)</code></span>
<span class="codeline" id="line-986"><code>	if err != nil {</code></span>
<span class="codeline" id="line-987"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-988"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-989"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-990"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-991"><code>		})</code></span>
<span class="codeline" id="line-992"><code>	}</code></span>
<span class="codeline" id="line-993"><code>	return int8(n)</code></span>
<span class="codeline" id="line-994"><code>}</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>func (r *Lexer) Int16Str() int16 {</code></span>
<span class="codeline" id="line-997"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-998"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-999"><code>		return 0</code></span>
<span class="codeline" id="line-1000"><code>	}</code></span>
<span class="codeline" id="line-1001"><code></code></span>
<span class="codeline" id="line-1002"><code>	n, err := strconv.ParseInt(s, 10, 16)</code></span>
<span class="codeline" id="line-1003"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1004"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1005"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1006"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1007"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-1008"><code>		})</code></span>
<span class="codeline" id="line-1009"><code>	}</code></span>
<span class="codeline" id="line-1010"><code>	return int16(n)</code></span>
<span class="codeline" id="line-1011"><code>}</code></span>
<span class="codeline" id="line-1012"><code></code></span>
<span class="codeline" id="line-1013"><code>func (r *Lexer) Int32Str() int32 {</code></span>
<span class="codeline" id="line-1014"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-1015"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1016"><code>		return 0</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code></code></span>
<span class="codeline" id="line-1019"><code>	n, err := strconv.ParseInt(s, 10, 32)</code></span>
<span class="codeline" id="line-1020"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1021"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1022"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1023"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1024"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-1025"><code>		})</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code>	return int32(n)</code></span>
<span class="codeline" id="line-1028"><code>}</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>func (r *Lexer) Int64Str() int64 {</code></span>
<span class="codeline" id="line-1031"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-1032"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1033"><code>		return 0</code></span>
<span class="codeline" id="line-1034"><code>	}</code></span>
<span class="codeline" id="line-1035"><code></code></span>
<span class="codeline" id="line-1036"><code>	n, err := strconv.ParseInt(s, 10, 64)</code></span>
<span class="codeline" id="line-1037"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1038"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1039"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1040"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1041"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-1042"><code>		})</code></span>
<span class="codeline" id="line-1043"><code>	}</code></span>
<span class="codeline" id="line-1044"><code>	return n</code></span>
<span class="codeline" id="line-1045"><code>}</code></span>
<span class="codeline" id="line-1046"><code></code></span>
<span class="codeline" id="line-1047"><code>func (r *Lexer) IntStr() int {</code></span>
<span class="codeline" id="line-1048"><code>	return int(r.Int64Str())</code></span>
<span class="codeline" id="line-1049"><code>}</code></span>
<span class="codeline" id="line-1050"><code></code></span>
<span class="codeline" id="line-1051"><code>func (r *Lexer) Float32() float32 {</code></span>
<span class="codeline" id="line-1052"><code>	s := r.number()</code></span>
<span class="codeline" id="line-1053"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1054"><code>		return 0</code></span>
<span class="codeline" id="line-1055"><code>	}</code></span>
<span class="codeline" id="line-1056"><code></code></span>
<span class="codeline" id="line-1057"><code>	n, err := strconv.ParseFloat(s, 32)</code></span>
<span class="codeline" id="line-1058"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1059"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1060"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1061"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1062"><code>			Data:   s,</code></span>
<span class="codeline" id="line-1063"><code>		})</code></span>
<span class="codeline" id="line-1064"><code>	}</code></span>
<span class="codeline" id="line-1065"><code>	return float32(n)</code></span>
<span class="codeline" id="line-1066"><code>}</code></span>
<span class="codeline" id="line-1067"><code></code></span>
<span class="codeline" id="line-1068"><code>func (r *Lexer) Float32Str() float32 {</code></span>
<span class="codeline" id="line-1069"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-1070"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1071"><code>		return 0</code></span>
<span class="codeline" id="line-1072"><code>	}</code></span>
<span class="codeline" id="line-1073"><code>	n, err := strconv.ParseFloat(s, 32)</code></span>
<span class="codeline" id="line-1074"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1075"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1076"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1077"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1078"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-1079"><code>		})</code></span>
<span class="codeline" id="line-1080"><code>	}</code></span>
<span class="codeline" id="line-1081"><code>	return float32(n)</code></span>
<span class="codeline" id="line-1082"><code>}</code></span>
<span class="codeline" id="line-1083"><code></code></span>
<span class="codeline" id="line-1084"><code>func (r *Lexer) Float64() float64 {</code></span>
<span class="codeline" id="line-1085"><code>	s := r.number()</code></span>
<span class="codeline" id="line-1086"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1087"><code>		return 0</code></span>
<span class="codeline" id="line-1088"><code>	}</code></span>
<span class="codeline" id="line-1089"><code></code></span>
<span class="codeline" id="line-1090"><code>	n, err := strconv.ParseFloat(s, 64)</code></span>
<span class="codeline" id="line-1091"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1092"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1093"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1094"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1095"><code>			Data:   s,</code></span>
<span class="codeline" id="line-1096"><code>		})</code></span>
<span class="codeline" id="line-1097"><code>	}</code></span>
<span class="codeline" id="line-1098"><code>	return n</code></span>
<span class="codeline" id="line-1099"><code>}</code></span>
<span class="codeline" id="line-1100"><code></code></span>
<span class="codeline" id="line-1101"><code>func (r *Lexer) Float64Str() float64 {</code></span>
<span class="codeline" id="line-1102"><code>	s, b := r.unsafeString(false)</code></span>
<span class="codeline" id="line-1103"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1104"><code>		return 0</code></span>
<span class="codeline" id="line-1105"><code>	}</code></span>
<span class="codeline" id="line-1106"><code>	n, err := strconv.ParseFloat(s, 64)</code></span>
<span class="codeline" id="line-1107"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1108"><code>		r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1109"><code>			Offset: r.start,</code></span>
<span class="codeline" id="line-1110"><code>			Reason: err.Error(),</code></span>
<span class="codeline" id="line-1111"><code>			Data:   string(b),</code></span>
<span class="codeline" id="line-1112"><code>		})</code></span>
<span class="codeline" id="line-1113"><code>	}</code></span>
<span class="codeline" id="line-1114"><code>	return n</code></span>
<span class="codeline" id="line-1115"><code>}</code></span>
<span class="codeline" id="line-1116"><code></code></span>
<span class="codeline" id="line-1117"><code>func (r *Lexer) Error() error {</code></span>
<span class="codeline" id="line-1118"><code>	return r.fatalError</code></span>
<span class="codeline" id="line-1119"><code>}</code></span>
<span class="codeline" id="line-1120"><code></code></span>
<span class="codeline" id="line-1121"><code>func (r *Lexer) AddError(e error) {</code></span>
<span class="codeline" id="line-1122"><code>	if r.fatalError == nil {</code></span>
<span class="codeline" id="line-1123"><code>		r.fatalError = e</code></span>
<span class="codeline" id="line-1124"><code>	}</code></span>
<span class="codeline" id="line-1125"><code>}</code></span>
<span class="codeline" id="line-1126"><code></code></span>
<span class="codeline" id="line-1127"><code>func (r *Lexer) AddNonFatalError(e error) {</code></span>
<span class="codeline" id="line-1128"><code>	r.addNonfatalError(&amp;LexerError{</code></span>
<span class="codeline" id="line-1129"><code>		Offset: r.start,</code></span>
<span class="codeline" id="line-1130"><code>		Data:   string(r.Data[r.start:r.pos]),</code></span>
<span class="codeline" id="line-1131"><code>		Reason: e.Error(),</code></span>
<span class="codeline" id="line-1132"><code>	})</code></span>
<span class="codeline" id="line-1133"><code>}</code></span>
<span class="codeline" id="line-1134"><code></code></span>
<span class="codeline" id="line-1135"><code>func (r *Lexer) addNonfatalError(err *LexerError) {</code></span>
<span class="codeline" id="line-1136"><code>	if r.UseMultipleErrors {</code></span>
<span class="codeline" id="line-1137"><code>		// We don't want to add errors with the same offset.</code></span>
<span class="codeline" id="line-1138"><code>		if len(r.multipleErrors) != 0 &amp;&amp; r.multipleErrors[len(r.multipleErrors)-1].Offset == err.Offset {</code></span>
<span class="codeline" id="line-1139"><code>			return</code></span>
<span class="codeline" id="line-1140"><code>		}</code></span>
<span class="codeline" id="line-1141"><code>		r.multipleErrors = append(r.multipleErrors, err)</code></span>
<span class="codeline" id="line-1142"><code>		return</code></span>
<span class="codeline" id="line-1143"><code>	}</code></span>
<span class="codeline" id="line-1144"><code>	r.fatalError = err</code></span>
<span class="codeline" id="line-1145"><code>}</code></span>
<span class="codeline" id="line-1146"><code></code></span>
<span class="codeline" id="line-1147"><code>func (r *Lexer) GetNonFatalErrors() []*LexerError {</code></span>
<span class="codeline" id="line-1148"><code>	return r.multipleErrors</code></span>
<span class="codeline" id="line-1149"><code>}</code></span>
<span class="codeline" id="line-1150"><code></code></span>
<span class="codeline" id="line-1151"><code>// JsonNumber fetches and json.Number from 'encoding/json' package.</code></span>
<span class="codeline" id="line-1152"><code>// Both int, float or string, contains them are valid values</code></span>
<span class="codeline" id="line-1153"><code>func (r *Lexer) JsonNumber() json.Number {</code></span>
<span class="codeline" id="line-1154"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-1155"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-1156"><code>	}</code></span>
<span class="codeline" id="line-1157"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1158"><code>		r.errInvalidToken("json.Number")</code></span>
<span class="codeline" id="line-1159"><code>		return json.Number("")</code></span>
<span class="codeline" id="line-1160"><code>	}</code></span>
<span class="codeline" id="line-1161"><code></code></span>
<span class="codeline" id="line-1162"><code>	switch r.token.kind {</code></span>
<span class="codeline" id="line-1163"><code>	case tokenString:</code></span>
<span class="codeline" id="line-1164"><code>		return json.Number(r.String())</code></span>
<span class="codeline" id="line-1165"><code>	case tokenNumber:</code></span>
<span class="codeline" id="line-1166"><code>		return json.Number(r.Raw())</code></span>
<span class="codeline" id="line-1167"><code>	case tokenNull:</code></span>
<span class="codeline" id="line-1168"><code>		r.Null()</code></span>
<span class="codeline" id="line-1169"><code>		return json.Number("")</code></span>
<span class="codeline" id="line-1170"><code>	default:</code></span>
<span class="codeline" id="line-1171"><code>		r.errSyntax()</code></span>
<span class="codeline" id="line-1172"><code>		return json.Number("")</code></span>
<span class="codeline" id="line-1173"><code>	}</code></span>
<span class="codeline" id="line-1174"><code>}</code></span>
<span class="codeline" id="line-1175"><code></code></span>
<span class="codeline" id="line-1176"><code>// Interface fetches an interface{} analogous to the 'encoding/json' package.</code></span>
<span class="codeline" id="line-1177"><code>func (r *Lexer) Interface() interface{} {</code></span>
<span class="codeline" id="line-1178"><code>	if r.token.kind == tokenUndef &amp;&amp; r.Ok() {</code></span>
<span class="codeline" id="line-1179"><code>		r.FetchToken()</code></span>
<span class="codeline" id="line-1180"><code>	}</code></span>
<span class="codeline" id="line-1181"><code></code></span>
<span class="codeline" id="line-1182"><code>	if !r.Ok() {</code></span>
<span class="codeline" id="line-1183"><code>		return nil</code></span>
<span class="codeline" id="line-1184"><code>	}</code></span>
<span class="codeline" id="line-1185"><code>	switch r.token.kind {</code></span>
<span class="codeline" id="line-1186"><code>	case tokenString:</code></span>
<span class="codeline" id="line-1187"><code>		return r.String()</code></span>
<span class="codeline" id="line-1188"><code>	case tokenNumber:</code></span>
<span class="codeline" id="line-1189"><code>		return r.Float64()</code></span>
<span class="codeline" id="line-1190"><code>	case tokenBool:</code></span>
<span class="codeline" id="line-1191"><code>		return r.Bool()</code></span>
<span class="codeline" id="line-1192"><code>	case tokenNull:</code></span>
<span class="codeline" id="line-1193"><code>		r.Null()</code></span>
<span class="codeline" id="line-1194"><code>		return nil</code></span>
<span class="codeline" id="line-1195"><code>	}</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>	if r.token.delimValue == '{' {</code></span>
<span class="codeline" id="line-1198"><code>		r.consume()</code></span>
<span class="codeline" id="line-1199"><code></code></span>
<span class="codeline" id="line-1200"><code>		ret := map[string]interface{}{}</code></span>
<span class="codeline" id="line-1201"><code>		for !r.IsDelim('}') {</code></span>
<span class="codeline" id="line-1202"><code>			key := r.String()</code></span>
<span class="codeline" id="line-1203"><code>			r.WantColon()</code></span>
<span class="codeline" id="line-1204"><code>			ret[key] = r.Interface()</code></span>
<span class="codeline" id="line-1205"><code>			r.WantComma()</code></span>
<span class="codeline" id="line-1206"><code>		}</code></span>
<span class="codeline" id="line-1207"><code>		r.Delim('}')</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>		if r.Ok() {</code></span>
<span class="codeline" id="line-1210"><code>			return ret</code></span>
<span class="codeline" id="line-1211"><code>		} else {</code></span>
<span class="codeline" id="line-1212"><code>			return nil</code></span>
<span class="codeline" id="line-1213"><code>		}</code></span>
<span class="codeline" id="line-1214"><code>	} else if r.token.delimValue == '[' {</code></span>
<span class="codeline" id="line-1215"><code>		r.consume()</code></span>
<span class="codeline" id="line-1216"><code></code></span>
<span class="codeline" id="line-1217"><code>		ret := []interface{}{}</code></span>
<span class="codeline" id="line-1218"><code>		for !r.IsDelim(']') {</code></span>
<span class="codeline" id="line-1219"><code>			ret = append(ret, r.Interface())</code></span>
<span class="codeline" id="line-1220"><code>			r.WantComma()</code></span>
<span class="codeline" id="line-1221"><code>		}</code></span>
<span class="codeline" id="line-1222"><code>		r.Delim(']')</code></span>
<span class="codeline" id="line-1223"><code></code></span>
<span class="codeline" id="line-1224"><code>		if r.Ok() {</code></span>
<span class="codeline" id="line-1225"><code>			return ret</code></span>
<span class="codeline" id="line-1226"><code>		} else {</code></span>
<span class="codeline" id="line-1227"><code>			return nil</code></span>
<span class="codeline" id="line-1228"><code>		}</code></span>
<span class="codeline" id="line-1229"><code>	}</code></span>
<span class="codeline" id="line-1230"><code>	r.errSyntax()</code></span>
<span class="codeline" id="line-1231"><code>	return nil</code></span>
<span class="codeline" id="line-1232"><code>}</code></span>
<span class="codeline" id="line-1233"><code></code></span>
<span class="codeline" id="line-1234"><code>// WantComma requires a comma to be present before fetching next token.</code></span>
<span class="codeline" id="line-1235"><code>func (r *Lexer) WantComma() {</code></span>
<span class="codeline" id="line-1236"><code>	r.wantSep = ','</code></span>
<span class="codeline" id="line-1237"><code>	r.firstElement = false</code></span>
<span class="codeline" id="line-1238"><code>}</code></span>
<span class="codeline" id="line-1239"><code></code></span>
<span class="codeline" id="line-1240"><code>// WantColon requires a colon to be present before fetching next token.</code></span>
<span class="codeline" id="line-1241"><code>func (r *Lexer) WantColon() {</code></span>
<span class="codeline" id="line-1242"><code>	r.wantSep = ':'</code></span>
<span class="codeline" id="line-1243"><code>	r.firstElement = false</code></span>
<span class="codeline" id="line-1244"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>