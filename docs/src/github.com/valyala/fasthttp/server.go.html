<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: server.go in package github.com/valyala/fasthttp</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	server.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/valyala/fasthttp.html">github.com/valyala/fasthttp</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package fasthttp</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"bufio"</code></span>
<span class="codeline" id="line-5"><code>	"context"</code></span>
<span class="codeline" id="line-6"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-7"><code>	"errors"</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"io"</code></span>
<span class="codeline" id="line-10"><code>	"log"</code></span>
<span class="codeline" id="line-11"><code>	"mime/multipart"</code></span>
<span class="codeline" id="line-12"><code>	"net"</code></span>
<span class="codeline" id="line-13"><code>	"os"</code></span>
<span class="codeline" id="line-14"><code>	"strings"</code></span>
<span class="codeline" id="line-15"><code>	"sync"</code></span>
<span class="codeline" id="line-16"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-17"><code>	"time"</code></span>
<span class="codeline" id="line-18"><code>)</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>var errNoCertOrKeyProvided = errors.New("cert or key has not provided")</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// ErrAlreadyServing is deprecated.</code></span>
<span class="codeline" id="line-23"><code>// Deprecated: ErrAlreadyServing is never returned from Serve. See issue #633.</code></span>
<span class="codeline" id="line-24"><code>var ErrAlreadyServing = errors.New("Server is already serving connections")</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>// ServeConn serves HTTP requests from the given connection</code></span>
<span class="codeline" id="line-27"><code>// using the given handler.</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// ServeConn returns nil if all requests from the c are successfully served.</code></span>
<span class="codeline" id="line-30"><code>// It returns non-nil error otherwise.</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>// Connection c must immediately propagate all the data passed to Write()</code></span>
<span class="codeline" id="line-33"><code>// to the client. Otherwise requests' processing may hang.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// ServeConn closes c before returning.</code></span>
<span class="codeline" id="line-36"><code>func ServeConn(c net.Conn, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-37"><code>	v := serverPool.Get()</code></span>
<span class="codeline" id="line-38"><code>	if v == nil {</code></span>
<span class="codeline" id="line-39"><code>		v = &amp;Server{}</code></span>
<span class="codeline" id="line-40"><code>	}</code></span>
<span class="codeline" id="line-41"><code>	s := v.(*Server)</code></span>
<span class="codeline" id="line-42"><code>	s.Handler = handler</code></span>
<span class="codeline" id="line-43"><code>	err := s.ServeConn(c)</code></span>
<span class="codeline" id="line-44"><code>	s.Handler = nil</code></span>
<span class="codeline" id="line-45"><code>	serverPool.Put(v)</code></span>
<span class="codeline" id="line-46"><code>	return err</code></span>
<span class="codeline" id="line-47"><code>}</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>var serverPool sync.Pool</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// Serve serves incoming connections from the given listener</code></span>
<span class="codeline" id="line-52"><code>// using the given handler.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// Serve blocks until the given listener returns permanent error.</code></span>
<span class="codeline" id="line-55"><code>func Serve(ln net.Listener, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-56"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-57"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-58"><code>	}</code></span>
<span class="codeline" id="line-59"><code>	return s.Serve(ln)</code></span>
<span class="codeline" id="line-60"><code>}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// ServeTLS serves HTTPS requests from the given net.Listener</code></span>
<span class="codeline" id="line-63"><code>// using the given handler.</code></span>
<span class="codeline" id="line-64"><code>//</code></span>
<span class="codeline" id="line-65"><code>// certFile and keyFile are paths to TLS certificate and key files.</code></span>
<span class="codeline" id="line-66"><code>func ServeTLS(ln net.Listener, certFile, keyFile string, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-67"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-68"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-69"><code>	}</code></span>
<span class="codeline" id="line-70"><code>	return s.ServeTLS(ln, certFile, keyFile)</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// ServeTLSEmbed serves HTTPS requests from the given net.Listener</code></span>
<span class="codeline" id="line-74"><code>// using the given handler.</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>// certData and keyData must contain valid TLS certificate and key data.</code></span>
<span class="codeline" id="line-77"><code>func ServeTLSEmbed(ln net.Listener, certData, keyData []byte, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-78"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-79"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code>	return s.ServeTLSEmbed(ln, certData, keyData)</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>// ListenAndServe serves HTTP requests from the given TCP addr</code></span>
<span class="codeline" id="line-85"><code>// using the given handler.</code></span>
<span class="codeline" id="line-86"><code>func ListenAndServe(addr string, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-87"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-88"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-89"><code>	}</code></span>
<span class="codeline" id="line-90"><code>	return s.ListenAndServe(addr)</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>// ListenAndServeUNIX serves HTTP requests from the given UNIX addr</code></span>
<span class="codeline" id="line-94"><code>// using the given handler.</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// The function deletes existing file at addr before starting serving.</code></span>
<span class="codeline" id="line-97"><code>//</code></span>
<span class="codeline" id="line-98"><code>// The server sets the given file mode for the UNIX addr.</code></span>
<span class="codeline" id="line-99"><code>func ListenAndServeUNIX(addr string, mode os.FileMode, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-100"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-101"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code>	return s.ListenAndServeUNIX(addr, mode)</code></span>
<span class="codeline" id="line-104"><code>}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>// ListenAndServeTLS serves HTTPS requests from the given TCP addr</code></span>
<span class="codeline" id="line-107"><code>// using the given handler.</code></span>
<span class="codeline" id="line-108"><code>//</code></span>
<span class="codeline" id="line-109"><code>// certFile and keyFile are paths to TLS certificate and key files.</code></span>
<span class="codeline" id="line-110"><code>func ListenAndServeTLS(addr, certFile, keyFile string, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-111"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-112"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-113"><code>	}</code></span>
<span class="codeline" id="line-114"><code>	return s.ListenAndServeTLS(addr, certFile, keyFile)</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// ListenAndServeTLSEmbed serves HTTPS requests from the given TCP addr</code></span>
<span class="codeline" id="line-118"><code>// using the given handler.</code></span>
<span class="codeline" id="line-119"><code>//</code></span>
<span class="codeline" id="line-120"><code>// certData and keyData must contain valid TLS certificate and key data.</code></span>
<span class="codeline" id="line-121"><code>func ListenAndServeTLSEmbed(addr string, certData, keyData []byte, handler RequestHandler) error {</code></span>
<span class="codeline" id="line-122"><code>	s := &amp;Server{</code></span>
<span class="codeline" id="line-123"><code>		Handler: handler,</code></span>
<span class="codeline" id="line-124"><code>	}</code></span>
<span class="codeline" id="line-125"><code>	return s.ListenAndServeTLSEmbed(addr, certData, keyData)</code></span>
<span class="codeline" id="line-126"><code>}</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>// RequestHandler must process incoming requests.</code></span>
<span class="codeline" id="line-129"><code>//</code></span>
<span class="codeline" id="line-130"><code>// RequestHandler must call ctx.TimeoutError() before returning</code></span>
<span class="codeline" id="line-131"><code>// if it keeps references to ctx and/or its members after the return.</code></span>
<span class="codeline" id="line-132"><code>// Consider wrapping RequestHandler into TimeoutHandler if response time</code></span>
<span class="codeline" id="line-133"><code>// must be limited.</code></span>
<span class="codeline" id="line-134"><code>type RequestHandler func(ctx *RequestCtx)</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// ServeHandler must process tls.Config.NextProto negotiated requests.</code></span>
<span class="codeline" id="line-137"><code>type ServeHandler func(c net.Conn) error</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// Server implements HTTP server.</code></span>
<span class="codeline" id="line-140"><code>//</code></span>
<span class="codeline" id="line-141"><code>// Default Server settings should satisfy the majority of Server users.</code></span>
<span class="codeline" id="line-142"><code>// Adjust Server settings only if you really understand the consequences.</code></span>
<span class="codeline" id="line-143"><code>//</code></span>
<span class="codeline" id="line-144"><code>// It is forbidden copying Server instances. Create new Server instances</code></span>
<span class="codeline" id="line-145"><code>// instead.</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// It is safe to call Server methods from concurrently running goroutines.</code></span>
<span class="codeline" id="line-148"><code>type Server struct {</code></span>
<span class="codeline" id="line-149"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>	// Handler for processing incoming requests.</code></span>
<span class="codeline" id="line-152"><code>	//</code></span>
<span class="codeline" id="line-153"><code>	// Take into account that no `panic` recovery is done by `fasthttp` (thus any `panic` will take down the entire server).</code></span>
<span class="codeline" id="line-154"><code>	// Instead the user should use `recover` to handle these situations.</code></span>
<span class="codeline" id="line-155"><code>	Handler RequestHandler</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>	// ErrorHandler for returning a response in case of an error while receiving or parsing the request.</code></span>
<span class="codeline" id="line-158"><code>	//</code></span>
<span class="codeline" id="line-159"><code>	// The following is a non-exhaustive list of errors that can be expected as argument:</code></span>
<span class="codeline" id="line-160"><code>	//   * io.EOF</code></span>
<span class="codeline" id="line-161"><code>	//   * io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-162"><code>	//   * ErrGetOnly</code></span>
<span class="codeline" id="line-163"><code>	//   * ErrSmallBuffer</code></span>
<span class="codeline" id="line-164"><code>	//   * ErrBodyTooLarge</code></span>
<span class="codeline" id="line-165"><code>	//   * ErrBrokenChunks</code></span>
<span class="codeline" id="line-166"><code>	ErrorHandler func(ctx *RequestCtx, err error)</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>	// HeaderReceived is called after receiving the header.</code></span>
<span class="codeline" id="line-169"><code>	//</code></span>
<span class="codeline" id="line-170"><code>	// Non zero RequestConfig field values will overwrite the default configs</code></span>
<span class="codeline" id="line-171"><code>	HeaderReceived func(header *RequestHeader) RequestConfig</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>	// ContinueHandler is called after receiving the Expect 100 Continue Header.</code></span>
<span class="codeline" id="line-174"><code>	//</code></span>
<span class="codeline" id="line-175"><code>	// https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3</code></span>
<span class="codeline" id="line-176"><code>	// https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1</code></span>
<span class="codeline" id="line-177"><code>	// Using ContinueHandler a server can make decisioning on whether or not</code></span>
<span class="codeline" id="line-178"><code>	// to read a potentially large request body based on the headers.</code></span>
<span class="codeline" id="line-179"><code>	//</code></span>
<span class="codeline" id="line-180"><code>	// The default is to automatically read request bodies of Expect 100 Continue requests</code></span>
<span class="codeline" id="line-181"><code>	// like they are normal requests.</code></span>
<span class="codeline" id="line-182"><code>	ContinueHandler func(header *RequestHeader) bool</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	// Server name for sending in response headers.</code></span>
<span class="codeline" id="line-185"><code>	//</code></span>
<span class="codeline" id="line-186"><code>	// Default server name is used if left blank.</code></span>
<span class="codeline" id="line-187"><code>	Name string</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	// The maximum number of concurrent connections the server may serve.</code></span>
<span class="codeline" id="line-190"><code>	//</code></span>
<span class="codeline" id="line-191"><code>	// DefaultConcurrency is used if not set.</code></span>
<span class="codeline" id="line-192"><code>	//</code></span>
<span class="codeline" id="line-193"><code>	// Concurrency only works if you either call Serve once, or only ServeConn multiple times.</code></span>
<span class="codeline" id="line-194"><code>	// It works with ListenAndServe as well.</code></span>
<span class="codeline" id="line-195"><code>	Concurrency int</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>	// Per-connection buffer size for requests' reading.</code></span>
<span class="codeline" id="line-198"><code>	// This also limits the maximum header size.</code></span>
<span class="codeline" id="line-199"><code>	//</code></span>
<span class="codeline" id="line-200"><code>	// Increase this buffer if your clients send multi-KB RequestURIs</code></span>
<span class="codeline" id="line-201"><code>	// and/or multi-KB headers (for example, BIG cookies).</code></span>
<span class="codeline" id="line-202"><code>	//</code></span>
<span class="codeline" id="line-203"><code>	// Default buffer size is used if not set.</code></span>
<span class="codeline" id="line-204"><code>	ReadBufferSize int</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>	// Per-connection buffer size for responses' writing.</code></span>
<span class="codeline" id="line-207"><code>	//</code></span>
<span class="codeline" id="line-208"><code>	// Default buffer size is used if not set.</code></span>
<span class="codeline" id="line-209"><code>	WriteBufferSize int</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>	// ReadTimeout is the amount of time allowed to read</code></span>
<span class="codeline" id="line-212"><code>	// the full request including body. The connection's read</code></span>
<span class="codeline" id="line-213"><code>	// deadline is reset when the connection opens, or for</code></span>
<span class="codeline" id="line-214"><code>	// keep-alive connections after the first byte has been read.</code></span>
<span class="codeline" id="line-215"><code>	//</code></span>
<span class="codeline" id="line-216"><code>	// By default request read timeout is unlimited.</code></span>
<span class="codeline" id="line-217"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>	// WriteTimeout is the maximum duration before timing out</code></span>
<span class="codeline" id="line-220"><code>	// writes of the response. It is reset after the request handler</code></span>
<span class="codeline" id="line-221"><code>	// has returned.</code></span>
<span class="codeline" id="line-222"><code>	//</code></span>
<span class="codeline" id="line-223"><code>	// By default response write timeout is unlimited.</code></span>
<span class="codeline" id="line-224"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	// IdleTimeout is the maximum amount of time to wait for the</code></span>
<span class="codeline" id="line-227"><code>	// next request when keep-alive is enabled. If IdleTimeout</code></span>
<span class="codeline" id="line-228"><code>	// is zero, the value of ReadTimeout is used.</code></span>
<span class="codeline" id="line-229"><code>	IdleTimeout time.Duration</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>	// Maximum number of concurrent client connections allowed per IP.</code></span>
<span class="codeline" id="line-232"><code>	//</code></span>
<span class="codeline" id="line-233"><code>	// By default unlimited number of concurrent connections</code></span>
<span class="codeline" id="line-234"><code>	// may be established to the server from a single IP address.</code></span>
<span class="codeline" id="line-235"><code>	MaxConnsPerIP int</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>	// Maximum number of requests served per connection.</code></span>
<span class="codeline" id="line-238"><code>	//</code></span>
<span class="codeline" id="line-239"><code>	// The server closes connection after the last request.</code></span>
<span class="codeline" id="line-240"><code>	// 'Connection: close' header is added to the last response.</code></span>
<span class="codeline" id="line-241"><code>	//</code></span>
<span class="codeline" id="line-242"><code>	// By default unlimited number of requests may be served per connection.</code></span>
<span class="codeline" id="line-243"><code>	MaxRequestsPerConn int</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>	// MaxKeepaliveDuration is a no-op and only left here for backwards compatibility.</code></span>
<span class="codeline" id="line-246"><code>	// Deprecated: Use IdleTimeout instead.</code></span>
<span class="codeline" id="line-247"><code>	MaxKeepaliveDuration time.Duration</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>	// MaxIdleWorkerDuration is the maximum idle time of a single worker in the underlying</code></span>
<span class="codeline" id="line-250"><code>	// worker pool of the Server. Idle workers beyond this time will be cleared.</code></span>
<span class="codeline" id="line-251"><code>	MaxIdleWorkerDuration time.Duration</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>	// Period between tcp keep-alive messages.</code></span>
<span class="codeline" id="line-254"><code>	//</code></span>
<span class="codeline" id="line-255"><code>	// TCP keep-alive period is determined by operation system by default.</code></span>
<span class="codeline" id="line-256"><code>	TCPKeepalivePeriod time.Duration</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	// Maximum request body size.</code></span>
<span class="codeline" id="line-259"><code>	//</code></span>
<span class="codeline" id="line-260"><code>	// The server rejects requests with bodies exceeding this limit.</code></span>
<span class="codeline" id="line-261"><code>	//</code></span>
<span class="codeline" id="line-262"><code>	// Request body size is limited by DefaultMaxRequestBodySize by default.</code></span>
<span class="codeline" id="line-263"><code>	MaxRequestBodySize int</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>	// Whether to disable keep-alive connections.</code></span>
<span class="codeline" id="line-266"><code>	//</code></span>
<span class="codeline" id="line-267"><code>	// The server will close all the incoming connections after sending</code></span>
<span class="codeline" id="line-268"><code>	// the first response to client if this option is set to true.</code></span>
<span class="codeline" id="line-269"><code>	//</code></span>
<span class="codeline" id="line-270"><code>	// By default keep-alive connections are enabled.</code></span>
<span class="codeline" id="line-271"><code>	DisableKeepalive bool</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	// Whether to enable tcp keep-alive connections.</code></span>
<span class="codeline" id="line-274"><code>	//</code></span>
<span class="codeline" id="line-275"><code>	// Whether the operating system should send tcp keep-alive messages on the tcp connection.</code></span>
<span class="codeline" id="line-276"><code>	//</code></span>
<span class="codeline" id="line-277"><code>	// By default tcp keep-alive connections are disabled.</code></span>
<span class="codeline" id="line-278"><code>	TCPKeepalive bool</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	// Aggressively reduces memory usage at the cost of higher CPU usage</code></span>
<span class="codeline" id="line-281"><code>	// if set to true.</code></span>
<span class="codeline" id="line-282"><code>	//</code></span>
<span class="codeline" id="line-283"><code>	// Try enabling this option only if the server consumes too much memory</code></span>
<span class="codeline" id="line-284"><code>	// serving mostly idle keep-alive connections. This may reduce memory</code></span>
<span class="codeline" id="line-285"><code>	// usage by more than 50%.</code></span>
<span class="codeline" id="line-286"><code>	//</code></span>
<span class="codeline" id="line-287"><code>	// Aggressive memory usage reduction is disabled by default.</code></span>
<span class="codeline" id="line-288"><code>	ReduceMemoryUsage bool</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>	// Rejects all non-GET requests if set to true.</code></span>
<span class="codeline" id="line-291"><code>	//</code></span>
<span class="codeline" id="line-292"><code>	// This option is useful as anti-DoS protection for servers</code></span>
<span class="codeline" id="line-293"><code>	// accepting only GET requests and HEAD requests. The request size is limited</code></span>
<span class="codeline" id="line-294"><code>	// by ReadBufferSize if GetOnly is set.</code></span>
<span class="codeline" id="line-295"><code>	//</code></span>
<span class="codeline" id="line-296"><code>	// Server accepts all the requests by default.</code></span>
<span class="codeline" id="line-297"><code>	GetOnly bool</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>	// Will not pre parse Multipart Form data if set to true.</code></span>
<span class="codeline" id="line-300"><code>	//</code></span>
<span class="codeline" id="line-301"><code>	// This option is useful for servers that desire to treat</code></span>
<span class="codeline" id="line-302"><code>	// multipart form data as a binary blob, or choose when to parse the data.</code></span>
<span class="codeline" id="line-303"><code>	//</code></span>
<span class="codeline" id="line-304"><code>	// Server pre parses multipart form data by default.</code></span>
<span class="codeline" id="line-305"><code>	DisablePreParseMultipartForm bool</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>	// Logs all errors, including the most frequent</code></span>
<span class="codeline" id="line-308"><code>	// 'connection reset by peer', 'broken pipe' and 'connection timeout'</code></span>
<span class="codeline" id="line-309"><code>	// errors. Such errors are common in production serving real-world</code></span>
<span class="codeline" id="line-310"><code>	// clients.</code></span>
<span class="codeline" id="line-311"><code>	//</code></span>
<span class="codeline" id="line-312"><code>	// By default the most frequent errors such as</code></span>
<span class="codeline" id="line-313"><code>	// 'connection reset by peer', 'broken pipe' and 'connection timeout'</code></span>
<span class="codeline" id="line-314"><code>	// are suppressed in order to limit output log traffic.</code></span>
<span class="codeline" id="line-315"><code>	LogAllErrors bool</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>	// Will not log potentially sensitive content in error logs</code></span>
<span class="codeline" id="line-318"><code>	//</code></span>
<span class="codeline" id="line-319"><code>	// This option is useful for servers that handle sensitive data</code></span>
<span class="codeline" id="line-320"><code>	// in the request/response.</code></span>
<span class="codeline" id="line-321"><code>	//</code></span>
<span class="codeline" id="line-322"><code>	// Server logs all full errors by default.</code></span>
<span class="codeline" id="line-323"><code>	SecureErrorLogMessage bool</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	// Header names are passed as-is without normalization</code></span>
<span class="codeline" id="line-326"><code>	// if this option is set.</code></span>
<span class="codeline" id="line-327"><code>	//</code></span>
<span class="codeline" id="line-328"><code>	// Disabled header names' normalization may be useful only for proxying</code></span>
<span class="codeline" id="line-329"><code>	// incoming requests to other servers expecting case-sensitive</code></span>
<span class="codeline" id="line-330"><code>	// header names. See https://github.com/valyala/fasthttp/issues/57</code></span>
<span class="codeline" id="line-331"><code>	// for details.</code></span>
<span class="codeline" id="line-332"><code>	//</code></span>
<span class="codeline" id="line-333"><code>	// By default request and response header names are normalized, i.e.</code></span>
<span class="codeline" id="line-334"><code>	// The first letter and the first letters following dashes</code></span>
<span class="codeline" id="line-335"><code>	// are uppercased, while all the other letters are lowercased.</code></span>
<span class="codeline" id="line-336"><code>	// Examples:</code></span>
<span class="codeline" id="line-337"><code>	//</code></span>
<span class="codeline" id="line-338"><code>	//     * HOST -&gt; Host</code></span>
<span class="codeline" id="line-339"><code>	//     * content-type -&gt; Content-Type</code></span>
<span class="codeline" id="line-340"><code>	//     * cONTENT-lenGTH -&gt; Content-Length</code></span>
<span class="codeline" id="line-341"><code>	DisableHeaderNamesNormalizing bool</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>	// SleepWhenConcurrencyLimitsExceeded is a duration to be slept of if</code></span>
<span class="codeline" id="line-344"><code>	// the concurrency limit in exceeded (default [when is 0]: don't sleep</code></span>
<span class="codeline" id="line-345"><code>	// and accept new connections immediately).</code></span>
<span class="codeline" id="line-346"><code>	SleepWhenConcurrencyLimitsExceeded time.Duration</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>	// NoDefaultServerHeader, when set to true, causes the default Server header</code></span>
<span class="codeline" id="line-349"><code>	// to be excluded from the Response.</code></span>
<span class="codeline" id="line-350"><code>	//</code></span>
<span class="codeline" id="line-351"><code>	// The default Server header value is the value of the Name field or an</code></span>
<span class="codeline" id="line-352"><code>	// internal default value in its absence. With this option set to true,</code></span>
<span class="codeline" id="line-353"><code>	// the only time a Server header will be sent is if a non-zero length</code></span>
<span class="codeline" id="line-354"><code>	// value is explicitly provided during a request.</code></span>
<span class="codeline" id="line-355"><code>	NoDefaultServerHeader bool</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	// NoDefaultDate, when set to true, causes the default Date</code></span>
<span class="codeline" id="line-358"><code>	// header to be excluded from the Response.</code></span>
<span class="codeline" id="line-359"><code>	//</code></span>
<span class="codeline" id="line-360"><code>	// The default Date header value is the current date value. When</code></span>
<span class="codeline" id="line-361"><code>	// set to true, the Date will not be present.</code></span>
<span class="codeline" id="line-362"><code>	NoDefaultDate bool</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>	// NoDefaultContentType, when set to true, causes the default Content-Type</code></span>
<span class="codeline" id="line-365"><code>	// header to be excluded from the Response.</code></span>
<span class="codeline" id="line-366"><code>	//</code></span>
<span class="codeline" id="line-367"><code>	// The default Content-Type header value is the internal default value. When</code></span>
<span class="codeline" id="line-368"><code>	// set to true, the Content-Type will not be present.</code></span>
<span class="codeline" id="line-369"><code>	NoDefaultContentType bool</code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code>	// KeepHijackedConns is an opt-in disable of connection</code></span>
<span class="codeline" id="line-372"><code>	// close by fasthttp after connections' HijackHandler returns.</code></span>
<span class="codeline" id="line-373"><code>	// This allows to save goroutines, e.g. when fasthttp used to upgrade</code></span>
<span class="codeline" id="line-374"><code>	// http connections to WS and connection goes to another handler,</code></span>
<span class="codeline" id="line-375"><code>	// which will close it when needed.</code></span>
<span class="codeline" id="line-376"><code>	KeepHijackedConns bool</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>	// CloseOnShutdown when true adds a `Connection: close` header when the server is shutting down.</code></span>
<span class="codeline" id="line-379"><code>	CloseOnShutdown bool</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>	// StreamRequestBody enables request body streaming,</code></span>
<span class="codeline" id="line-382"><code>	// and calls the handler sooner when given body is</code></span>
<span class="codeline" id="line-383"><code>	// larger than the current limit.</code></span>
<span class="codeline" id="line-384"><code>	StreamRequestBody bool</code></span>
<span class="codeline" id="line-385"><code></code></span>
<span class="codeline" id="line-386"><code>	// ConnState specifies an optional callback function that is</code></span>
<span class="codeline" id="line-387"><code>	// called when a client connection changes state. See the</code></span>
<span class="codeline" id="line-388"><code>	// ConnState type and associated constants for details.</code></span>
<span class="codeline" id="line-389"><code>	ConnState func(net.Conn, ConnState)</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>	// Logger, which is used by RequestCtx.Logger().</code></span>
<span class="codeline" id="line-392"><code>	//</code></span>
<span class="codeline" id="line-393"><code>	// By default standard logger from log package is used.</code></span>
<span class="codeline" id="line-394"><code>	Logger Logger</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	// TLSConfig optionally provides a TLS configuration for use</code></span>
<span class="codeline" id="line-397"><code>	// by ServeTLS, ServeTLSEmbed, ListenAndServeTLS, ListenAndServeTLSEmbed,</code></span>
<span class="codeline" id="line-398"><code>	// AppendCert, AppendCertEmbed and NextProto.</code></span>
<span class="codeline" id="line-399"><code>	//</code></span>
<span class="codeline" id="line-400"><code>	// Note that this value is cloned by ServeTLS, ServeTLSEmbed, ListenAndServeTLS</code></span>
<span class="codeline" id="line-401"><code>	// and ListenAndServeTLSEmbed, so it's not possible to modify the configuration</code></span>
<span class="codeline" id="line-402"><code>	// with methods like tls.Config.SetSessionTicketKeys.</code></span>
<span class="codeline" id="line-403"><code>	// To use SetSessionTicketKeys, use Server.Serve with a TLS Listener</code></span>
<span class="codeline" id="line-404"><code>	// instead.</code></span>
<span class="codeline" id="line-405"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>	// FormValueFunc, which is used by RequestCtx.FormValue and support for customizing</code></span>
<span class="codeline" id="line-408"><code>	// the behaviour of the RequestCtx.FormValue function.</code></span>
<span class="codeline" id="line-409"><code>	//</code></span>
<span class="codeline" id="line-410"><code>	// NetHttpFormValueFunc gives a FormValueFunc func implementation that is consistent with net/http.</code></span>
<span class="codeline" id="line-411"><code>	FormValueFunc FormValueFunc</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	nextProtos map[string]ServeHandler</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>	concurrency      uint32</code></span>
<span class="codeline" id="line-416"><code>	concurrencyCh    chan struct{}</code></span>
<span class="codeline" id="line-417"><code>	perIPConnCounter perIPConnCounter</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>	ctxPool        sync.Pool</code></span>
<span class="codeline" id="line-420"><code>	readerPool     sync.Pool</code></span>
<span class="codeline" id="line-421"><code>	writerPool     sync.Pool</code></span>
<span class="codeline" id="line-422"><code>	hijackConnPool sync.Pool</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>	// We need to know our listeners and idle connections so we can close them in Shutdown().</code></span>
<span class="codeline" id="line-425"><code>	ln []net.Listener</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>	idleConns   map[net.Conn]time.Time</code></span>
<span class="codeline" id="line-428"><code>	idleConnsMu sync.Mutex</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>	mu   sync.Mutex</code></span>
<span class="codeline" id="line-431"><code>	open int32</code></span>
<span class="codeline" id="line-432"><code>	stop int32</code></span>
<span class="codeline" id="line-433"><code>	done chan struct{}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>	rejectedRequestsCount uint32</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>// TimeoutHandler creates RequestHandler, which returns StatusRequestTimeout</code></span>
<span class="codeline" id="line-439"><code>// error with the given msg to the client if h didn't return during</code></span>
<span class="codeline" id="line-440"><code>// the given duration.</code></span>
<span class="codeline" id="line-441"><code>//</code></span>
<span class="codeline" id="line-442"><code>// The returned handler may return StatusTooManyRequests error with the given</code></span>
<span class="codeline" id="line-443"><code>// msg to the client if there are more than Server.Concurrency concurrent</code></span>
<span class="codeline" id="line-444"><code>// handlers h are running at the moment.</code></span>
<span class="codeline" id="line-445"><code>func TimeoutHandler(h RequestHandler, timeout time.Duration, msg string) RequestHandler {</code></span>
<span class="codeline" id="line-446"><code>	return TimeoutWithCodeHandler(h, timeout, msg, StatusRequestTimeout)</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>// TimeoutWithCodeHandler creates RequestHandler, which returns an error with</code></span>
<span class="codeline" id="line-450"><code>// the given msg and status code to the client  if h didn't return during</code></span>
<span class="codeline" id="line-451"><code>// the given duration.</code></span>
<span class="codeline" id="line-452"><code>//</code></span>
<span class="codeline" id="line-453"><code>// The returned handler may return StatusTooManyRequests error with the given</code></span>
<span class="codeline" id="line-454"><code>// msg to the client if there are more than Server.Concurrency concurrent</code></span>
<span class="codeline" id="line-455"><code>// handlers h are running at the moment.</code></span>
<span class="codeline" id="line-456"><code>func TimeoutWithCodeHandler(h RequestHandler, timeout time.Duration, msg string, statusCode int) RequestHandler {</code></span>
<span class="codeline" id="line-457"><code>	if timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-458"><code>		return h</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	return func(ctx *RequestCtx) {</code></span>
<span class="codeline" id="line-462"><code>		concurrencyCh := ctx.s.concurrencyCh</code></span>
<span class="codeline" id="line-463"><code>		select {</code></span>
<span class="codeline" id="line-464"><code>		case concurrencyCh &lt;- struct{}{}:</code></span>
<span class="codeline" id="line-465"><code>		default:</code></span>
<span class="codeline" id="line-466"><code>			ctx.Error(msg, StatusTooManyRequests)</code></span>
<span class="codeline" id="line-467"><code>			return</code></span>
<span class="codeline" id="line-468"><code>		}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>		ch := ctx.timeoutCh</code></span>
<span class="codeline" id="line-471"><code>		if ch == nil {</code></span>
<span class="codeline" id="line-472"><code>			ch = make(chan struct{}, 1)</code></span>
<span class="codeline" id="line-473"><code>			ctx.timeoutCh = ch</code></span>
<span class="codeline" id="line-474"><code>		}</code></span>
<span class="codeline" id="line-475"><code>		go func() {</code></span>
<span class="codeline" id="line-476"><code>			h(ctx)</code></span>
<span class="codeline" id="line-477"><code>			ch &lt;- struct{}{}</code></span>
<span class="codeline" id="line-478"><code>			&lt;-concurrencyCh</code></span>
<span class="codeline" id="line-479"><code>		}()</code></span>
<span class="codeline" id="line-480"><code>		ctx.timeoutTimer = initTimer(ctx.timeoutTimer, timeout)</code></span>
<span class="codeline" id="line-481"><code>		select {</code></span>
<span class="codeline" id="line-482"><code>		case &lt;-ch:</code></span>
<span class="codeline" id="line-483"><code>		case &lt;-ctx.timeoutTimer.C:</code></span>
<span class="codeline" id="line-484"><code>			ctx.TimeoutErrorWithCode(msg, statusCode)</code></span>
<span class="codeline" id="line-485"><code>		}</code></span>
<span class="codeline" id="line-486"><code>		stopTimer(ctx.timeoutTimer)</code></span>
<span class="codeline" id="line-487"><code>	}</code></span>
<span class="codeline" id="line-488"><code>}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>// RequestConfig configure the per request deadline and body limits.</code></span>
<span class="codeline" id="line-491"><code>type RequestConfig struct {</code></span>
<span class="codeline" id="line-492"><code>	// ReadTimeout is the maximum duration for reading the entire</code></span>
<span class="codeline" id="line-493"><code>	// request body.</code></span>
<span class="codeline" id="line-494"><code>	// A zero value means that default values will be honored.</code></span>
<span class="codeline" id="line-495"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-496"><code>	// WriteTimeout is the maximum duration before timing out</code></span>
<span class="codeline" id="line-497"><code>	// writes of the response.</code></span>
<span class="codeline" id="line-498"><code>	// A zero value means that default values will be honored.</code></span>
<span class="codeline" id="line-499"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-500"><code>	// Maximum request body size.</code></span>
<span class="codeline" id="line-501"><code>	// A zero value means that default values will be honored.</code></span>
<span class="codeline" id="line-502"><code>	MaxRequestBodySize int</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>// CompressHandler returns RequestHandler that transparently compresses</code></span>
<span class="codeline" id="line-506"><code>// response body generated by h if the request contains 'gzip' or 'deflate'</code></span>
<span class="codeline" id="line-507"><code>// 'Accept-Encoding' header.</code></span>
<span class="codeline" id="line-508"><code>func CompressHandler(h RequestHandler) RequestHandler {</code></span>
<span class="codeline" id="line-509"><code>	return CompressHandlerLevel(h, CompressDefaultCompression)</code></span>
<span class="codeline" id="line-510"><code>}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>// CompressHandlerLevel returns RequestHandler that transparently compresses</code></span>
<span class="codeline" id="line-513"><code>// response body generated by h if the request contains a 'gzip' or 'deflate'</code></span>
<span class="codeline" id="line-514"><code>// 'Accept-Encoding' header.</code></span>
<span class="codeline" id="line-515"><code>//</code></span>
<span class="codeline" id="line-516"><code>// Level is the desired compression level:</code></span>
<span class="codeline" id="line-517"><code>//</code></span>
<span class="codeline" id="line-518"><code>//   - CompressNoCompression</code></span>
<span class="codeline" id="line-519"><code>//   - CompressBestSpeed</code></span>
<span class="codeline" id="line-520"><code>//   - CompressBestCompression</code></span>
<span class="codeline" id="line-521"><code>//   - CompressDefaultCompression</code></span>
<span class="codeline" id="line-522"><code>//   - CompressHuffmanOnly</code></span>
<span class="codeline" id="line-523"><code>func CompressHandlerLevel(h RequestHandler, level int) RequestHandler {</code></span>
<span class="codeline" id="line-524"><code>	return func(ctx *RequestCtx) {</code></span>
<span class="codeline" id="line-525"><code>		h(ctx)</code></span>
<span class="codeline" id="line-526"><code>		if ctx.Request.Header.HasAcceptEncodingBytes(strGzip) {</code></span>
<span class="codeline" id="line-527"><code>			ctx.Response.gzipBody(level) //nolint:errcheck</code></span>
<span class="codeline" id="line-528"><code>		} else if ctx.Request.Header.HasAcceptEncodingBytes(strDeflate) {</code></span>
<span class="codeline" id="line-529"><code>			ctx.Response.deflateBody(level) //nolint:errcheck</code></span>
<span class="codeline" id="line-530"><code>		}</code></span>
<span class="codeline" id="line-531"><code>	}</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>// CompressHandlerBrotliLevel returns RequestHandler that transparently compresses</code></span>
<span class="codeline" id="line-535"><code>// response body generated by h if the request contains a 'br', 'gzip' or 'deflate'</code></span>
<span class="codeline" id="line-536"><code>// 'Accept-Encoding' header.</code></span>
<span class="codeline" id="line-537"><code>//</code></span>
<span class="codeline" id="line-538"><code>// brotliLevel is the desired compression level for brotli.</code></span>
<span class="codeline" id="line-539"><code>//</code></span>
<span class="codeline" id="line-540"><code>//   - CompressBrotliNoCompression</code></span>
<span class="codeline" id="line-541"><code>//   - CompressBrotliBestSpeed</code></span>
<span class="codeline" id="line-542"><code>//   - CompressBrotliBestCompression</code></span>
<span class="codeline" id="line-543"><code>//   - CompressBrotliDefaultCompression</code></span>
<span class="codeline" id="line-544"><code>//</code></span>
<span class="codeline" id="line-545"><code>// otherLevel is the desired compression level for gzip and deflate.</code></span>
<span class="codeline" id="line-546"><code>//</code></span>
<span class="codeline" id="line-547"><code>//   - CompressNoCompression</code></span>
<span class="codeline" id="line-548"><code>//   - CompressBestSpeed</code></span>
<span class="codeline" id="line-549"><code>//   - CompressBestCompression</code></span>
<span class="codeline" id="line-550"><code>//   - CompressDefaultCompression</code></span>
<span class="codeline" id="line-551"><code>//   - CompressHuffmanOnly</code></span>
<span class="codeline" id="line-552"><code>func CompressHandlerBrotliLevel(h RequestHandler, brotliLevel, otherLevel int) RequestHandler {</code></span>
<span class="codeline" id="line-553"><code>	return func(ctx *RequestCtx) {</code></span>
<span class="codeline" id="line-554"><code>		h(ctx)</code></span>
<span class="codeline" id="line-555"><code>		switch {</code></span>
<span class="codeline" id="line-556"><code>		case ctx.Request.Header.HasAcceptEncodingBytes(strBr):</code></span>
<span class="codeline" id="line-557"><code>			ctx.Response.brotliBody(brotliLevel) //nolint:errcheck</code></span>
<span class="codeline" id="line-558"><code>		case ctx.Request.Header.HasAcceptEncodingBytes(strGzip):</code></span>
<span class="codeline" id="line-559"><code>			ctx.Response.gzipBody(otherLevel) //nolint:errcheck</code></span>
<span class="codeline" id="line-560"><code>		case ctx.Request.Header.HasAcceptEncodingBytes(strDeflate):</code></span>
<span class="codeline" id="line-561"><code>			ctx.Response.deflateBody(otherLevel) //nolint:errcheck</code></span>
<span class="codeline" id="line-562"><code>		}</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code>}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>// RequestCtx contains incoming request and manages outgoing response.</code></span>
<span class="codeline" id="line-567"><code>//</code></span>
<span class="codeline" id="line-568"><code>// It is forbidden copying RequestCtx instances.</code></span>
<span class="codeline" id="line-569"><code>//</code></span>
<span class="codeline" id="line-570"><code>// RequestHandler should avoid holding references to incoming RequestCtx and/or</code></span>
<span class="codeline" id="line-571"><code>// its members after the return.</code></span>
<span class="codeline" id="line-572"><code>// If holding RequestCtx references after the return is unavoidable</code></span>
<span class="codeline" id="line-573"><code>// (for instance, ctx is passed to a separate goroutine and ctx lifetime cannot</code></span>
<span class="codeline" id="line-574"><code>// be controlled), then the RequestHandler MUST call ctx.TimeoutError()</code></span>
<span class="codeline" id="line-575"><code>// before return.</code></span>
<span class="codeline" id="line-576"><code>//</code></span>
<span class="codeline" id="line-577"><code>// It is unsafe modifying/reading RequestCtx instance from concurrently</code></span>
<span class="codeline" id="line-578"><code>// running goroutines. The only exception is TimeoutError*, which may be called</code></span>
<span class="codeline" id="line-579"><code>// while other goroutines accessing RequestCtx.</code></span>
<span class="codeline" id="line-580"><code>type RequestCtx struct {</code></span>
<span class="codeline" id="line-581"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>	// Incoming request.</code></span>
<span class="codeline" id="line-584"><code>	//</code></span>
<span class="codeline" id="line-585"><code>	// Copying Request by value is forbidden. Use pointer to Request instead.</code></span>
<span class="codeline" id="line-586"><code>	Request Request</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>	// Outgoing response.</code></span>
<span class="codeline" id="line-589"><code>	//</code></span>
<span class="codeline" id="line-590"><code>	// Copying Response by value is forbidden. Use pointer to Response instead.</code></span>
<span class="codeline" id="line-591"><code>	Response Response</code></span>
<span class="codeline" id="line-592"><code></code></span>
<span class="codeline" id="line-593"><code>	userValues userData</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>	connID         uint64</code></span>
<span class="codeline" id="line-596"><code>	connRequestNum uint64</code></span>
<span class="codeline" id="line-597"><code>	connTime       time.Time</code></span>
<span class="codeline" id="line-598"><code>	remoteAddr     net.Addr</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>	time time.Time</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>	logger ctxLogger</code></span>
<span class="codeline" id="line-603"><code>	s      *Server</code></span>
<span class="codeline" id="line-604"><code>	c      net.Conn</code></span>
<span class="codeline" id="line-605"><code>	fbr    firstByteReader</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	timeoutResponse *Response</code></span>
<span class="codeline" id="line-608"><code>	timeoutCh       chan struct{}</code></span>
<span class="codeline" id="line-609"><code>	timeoutTimer    *time.Timer</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>	hijackHandler    HijackHandler</code></span>
<span class="codeline" id="line-612"><code>	hijackNoResponse bool</code></span>
<span class="codeline" id="line-613"><code>	formValueFunc    FormValueFunc</code></span>
<span class="codeline" id="line-614"><code>}</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>// HijackHandler must process the hijacked connection c.</code></span>
<span class="codeline" id="line-617"><code>//</code></span>
<span class="codeline" id="line-618"><code>// If KeepHijackedConns is disabled, which is by default,</code></span>
<span class="codeline" id="line-619"><code>// the connection c is automatically closed after returning from HijackHandler.</code></span>
<span class="codeline" id="line-620"><code>//</code></span>
<span class="codeline" id="line-621"><code>// The connection c must not be used after returning from the handler, if KeepHijackedConns is disabled.</code></span>
<span class="codeline" id="line-622"><code>//</code></span>
<span class="codeline" id="line-623"><code>// When KeepHijackedConns enabled, fasthttp will not Close() the connection,</code></span>
<span class="codeline" id="line-624"><code>// you must do it when you need it. You must not use c in any way after calling Close().</code></span>
<span class="codeline" id="line-625"><code>type HijackHandler func(c net.Conn)</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>// Hijack registers the given handler for connection hijacking.</code></span>
<span class="codeline" id="line-628"><code>//</code></span>
<span class="codeline" id="line-629"><code>// The handler is called after returning from RequestHandler</code></span>
<span class="codeline" id="line-630"><code>// and sending http response. The current connection is passed</code></span>
<span class="codeline" id="line-631"><code>// to the handler. The connection is automatically closed after</code></span>
<span class="codeline" id="line-632"><code>// returning from the handler.</code></span>
<span class="codeline" id="line-633"><code>//</code></span>
<span class="codeline" id="line-634"><code>// The server skips calling the handler in the following cases:</code></span>
<span class="codeline" id="line-635"><code>//</code></span>
<span class="codeline" id="line-636"><code>//   - 'Connection: close' header exists in either request or response.</code></span>
<span class="codeline" id="line-637"><code>//   - Unexpected error during response writing to the connection.</code></span>
<span class="codeline" id="line-638"><code>//</code></span>
<span class="codeline" id="line-639"><code>// The server stops processing requests from hijacked connections.</code></span>
<span class="codeline" id="line-640"><code>//</code></span>
<span class="codeline" id="line-641"><code>// Server limits such as Concurrency, ReadTimeout, WriteTimeout, etc.</code></span>
<span class="codeline" id="line-642"><code>// aren't applied to hijacked connections.</code></span>
<span class="codeline" id="line-643"><code>//</code></span>
<span class="codeline" id="line-644"><code>// The handler must not retain references to ctx members.</code></span>
<span class="codeline" id="line-645"><code>//</code></span>
<span class="codeline" id="line-646"><code>// Arbitrary 'Connection: Upgrade' protocols may be implemented</code></span>
<span class="codeline" id="line-647"><code>// with HijackHandler. For instance,</code></span>
<span class="codeline" id="line-648"><code>//</code></span>
<span class="codeline" id="line-649"><code>//   - WebSocket ( https://en.wikipedia.org/wiki/WebSocket )</code></span>
<span class="codeline" id="line-650"><code>//   - HTTP/2.0 ( https://en.wikipedia.org/wiki/HTTP/2 )</code></span>
<span class="codeline" id="line-651"><code>func (ctx *RequestCtx) Hijack(handler HijackHandler) {</code></span>
<span class="codeline" id="line-652"><code>	ctx.hijackHandler = handler</code></span>
<span class="codeline" id="line-653"><code>}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>// HijackSetNoResponse changes the behavior of hijacking a request.</code></span>
<span class="codeline" id="line-656"><code>// If HijackSetNoResponse is called with false fasthttp will send a response</code></span>
<span class="codeline" id="line-657"><code>// to the client before calling the HijackHandler (default). If HijackSetNoResponse</code></span>
<span class="codeline" id="line-658"><code>// is called with true no response is send back before calling the</code></span>
<span class="codeline" id="line-659"><code>// HijackHandler supplied in the Hijack function.</code></span>
<span class="codeline" id="line-660"><code>func (ctx *RequestCtx) HijackSetNoResponse(noResponse bool) {</code></span>
<span class="codeline" id="line-661"><code>	ctx.hijackNoResponse = noResponse</code></span>
<span class="codeline" id="line-662"><code>}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>// Hijacked returns true after Hijack is called.</code></span>
<span class="codeline" id="line-665"><code>func (ctx *RequestCtx) Hijacked() bool {</code></span>
<span class="codeline" id="line-666"><code>	return ctx.hijackHandler != nil</code></span>
<span class="codeline" id="line-667"><code>}</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>// SetUserValue stores the given value (arbitrary object)</code></span>
<span class="codeline" id="line-670"><code>// under the given key in ctx.</code></span>
<span class="codeline" id="line-671"><code>//</code></span>
<span class="codeline" id="line-672"><code>// The value stored in ctx may be obtained by UserValue*.</code></span>
<span class="codeline" id="line-673"><code>//</code></span>
<span class="codeline" id="line-674"><code>// This functionality may be useful for passing arbitrary values between</code></span>
<span class="codeline" id="line-675"><code>// functions involved in request processing.</code></span>
<span class="codeline" id="line-676"><code>//</code></span>
<span class="codeline" id="line-677"><code>// All the values are removed from ctx after returning from the top</code></span>
<span class="codeline" id="line-678"><code>// RequestHandler. Additionally, Close method is called on each value</code></span>
<span class="codeline" id="line-679"><code>// implementing io.Closer before removing the value from ctx.</code></span>
<span class="codeline" id="line-680"><code>func (ctx *RequestCtx) SetUserValue(key any, value any) {</code></span>
<span class="codeline" id="line-681"><code>	ctx.userValues.Set(key, value)</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>// SetUserValueBytes stores the given value (arbitrary object)</code></span>
<span class="codeline" id="line-685"><code>// under the given key in ctx.</code></span>
<span class="codeline" id="line-686"><code>//</code></span>
<span class="codeline" id="line-687"><code>// The value stored in ctx may be obtained by UserValue*.</code></span>
<span class="codeline" id="line-688"><code>//</code></span>
<span class="codeline" id="line-689"><code>// This functionality may be useful for passing arbitrary values between</code></span>
<span class="codeline" id="line-690"><code>// functions involved in request processing.</code></span>
<span class="codeline" id="line-691"><code>//</code></span>
<span class="codeline" id="line-692"><code>// All the values stored in ctx are deleted after returning from RequestHandler.</code></span>
<span class="codeline" id="line-693"><code>func (ctx *RequestCtx) SetUserValueBytes(key []byte, value any) {</code></span>
<span class="codeline" id="line-694"><code>	ctx.userValues.SetBytes(key, value)</code></span>
<span class="codeline" id="line-695"><code>}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>// UserValue returns the value stored via SetUserValue* under the given key.</code></span>
<span class="codeline" id="line-698"><code>func (ctx *RequestCtx) UserValue(key any) any {</code></span>
<span class="codeline" id="line-699"><code>	return ctx.userValues.Get(key)</code></span>
<span class="codeline" id="line-700"><code>}</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>// UserValueBytes returns the value stored via SetUserValue*</code></span>
<span class="codeline" id="line-703"><code>// under the given key.</code></span>
<span class="codeline" id="line-704"><code>func (ctx *RequestCtx) UserValueBytes(key []byte) any {</code></span>
<span class="codeline" id="line-705"><code>	return ctx.userValues.GetBytes(key)</code></span>
<span class="codeline" id="line-706"><code>}</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>// VisitUserValues calls visitor for each existing userValue with a key that is a string or []byte.</code></span>
<span class="codeline" id="line-709"><code>//</code></span>
<span class="codeline" id="line-710"><code>// visitor must not retain references to key and value after returning.</code></span>
<span class="codeline" id="line-711"><code>// Make key and/or value copies if you need storing them after returning.</code></span>
<span class="codeline" id="line-712"><code>func (ctx *RequestCtx) VisitUserValues(visitor func([]byte, any)) {</code></span>
<span class="codeline" id="line-713"><code>	for i, n := 0, len(ctx.userValues); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-714"><code>		kv := &amp;ctx.userValues[i]</code></span>
<span class="codeline" id="line-715"><code>		if _, ok := kv.key.(string); ok {</code></span>
<span class="codeline" id="line-716"><code>			visitor(s2b(kv.key.(string)), kv.value)</code></span>
<span class="codeline" id="line-717"><code>		}</code></span>
<span class="codeline" id="line-718"><code>	}</code></span>
<span class="codeline" id="line-719"><code>}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>// VisitUserValuesAll calls visitor for each existing userValue.</code></span>
<span class="codeline" id="line-722"><code>//</code></span>
<span class="codeline" id="line-723"><code>// visitor must not retain references to key and value after returning.</code></span>
<span class="codeline" id="line-724"><code>// Make key and/or value copies if you need storing them after returning.</code></span>
<span class="codeline" id="line-725"><code>func (ctx *RequestCtx) VisitUserValuesAll(visitor func(any, any)) {</code></span>
<span class="codeline" id="line-726"><code>	for i, n := 0, len(ctx.userValues); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-727"><code>		kv := &amp;ctx.userValues[i]</code></span>
<span class="codeline" id="line-728"><code>		visitor(kv.key, kv.value)</code></span>
<span class="codeline" id="line-729"><code>	}</code></span>
<span class="codeline" id="line-730"><code>}</code></span>
<span class="codeline" id="line-731"><code></code></span>
<span class="codeline" id="line-732"><code>// ResetUserValues allows to reset user values from Request Context.</code></span>
<span class="codeline" id="line-733"><code>func (ctx *RequestCtx) ResetUserValues() {</code></span>
<span class="codeline" id="line-734"><code>	ctx.userValues.Reset()</code></span>
<span class="codeline" id="line-735"><code>}</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>// RemoveUserValue removes the given key and the value under it in ctx.</code></span>
<span class="codeline" id="line-738"><code>func (ctx *RequestCtx) RemoveUserValue(key any) {</code></span>
<span class="codeline" id="line-739"><code>	ctx.userValues.Remove(key)</code></span>
<span class="codeline" id="line-740"><code>}</code></span>
<span class="codeline" id="line-741"><code></code></span>
<span class="codeline" id="line-742"><code>// RemoveUserValueBytes removes the given key and the value under it in ctx.</code></span>
<span class="codeline" id="line-743"><code>func (ctx *RequestCtx) RemoveUserValueBytes(key []byte) {</code></span>
<span class="codeline" id="line-744"><code>	ctx.userValues.RemoveBytes(key)</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>type connTLSer interface {</code></span>
<span class="codeline" id="line-748"><code>	Handshake() error</code></span>
<span class="codeline" id="line-749"><code>	ConnectionState() tls.ConnectionState</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>// IsTLS returns true if the underlying connection is tls.Conn.</code></span>
<span class="codeline" id="line-753"><code>//</code></span>
<span class="codeline" id="line-754"><code>// tls.Conn is an encrypted connection (aka SSL, HTTPS).</code></span>
<span class="codeline" id="line-755"><code>func (ctx *RequestCtx) IsTLS() bool {</code></span>
<span class="codeline" id="line-756"><code>	// cast to (connTLSer) instead of (*tls.Conn), since it catches</code></span>
<span class="codeline" id="line-757"><code>	// cases with overridden tls.Conn such as:</code></span>
<span class="codeline" id="line-758"><code>	//</code></span>
<span class="codeline" id="line-759"><code>	// type customConn struct {</code></span>
<span class="codeline" id="line-760"><code>	//     *tls.Conn</code></span>
<span class="codeline" id="line-761"><code>	//</code></span>
<span class="codeline" id="line-762"><code>	//     // other custom fields here</code></span>
<span class="codeline" id="line-763"><code>	// }</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	// perIPConn wraps the net.Conn in the Conn field</code></span>
<span class="codeline" id="line-766"><code>	if pic, ok := ctx.c.(*perIPConn); ok {</code></span>
<span class="codeline" id="line-767"><code>		_, ok := pic.Conn.(connTLSer)</code></span>
<span class="codeline" id="line-768"><code>		return ok</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code></code></span>
<span class="codeline" id="line-771"><code>	_, ok := ctx.c.(connTLSer)</code></span>
<span class="codeline" id="line-772"><code>	return ok</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>// TLSConnectionState returns TLS connection state.</code></span>
<span class="codeline" id="line-776"><code>//</code></span>
<span class="codeline" id="line-777"><code>// The function returns nil if the underlying connection isn't tls.Conn.</code></span>
<span class="codeline" id="line-778"><code>//</code></span>
<span class="codeline" id="line-779"><code>// The returned state may be used for verifying TLS version, client certificates,</code></span>
<span class="codeline" id="line-780"><code>// etc.</code></span>
<span class="codeline" id="line-781"><code>func (ctx *RequestCtx) TLSConnectionState() *tls.ConnectionState {</code></span>
<span class="codeline" id="line-782"><code>	tlsConn, ok := ctx.c.(connTLSer)</code></span>
<span class="codeline" id="line-783"><code>	if !ok {</code></span>
<span class="codeline" id="line-784"><code>		return nil</code></span>
<span class="codeline" id="line-785"><code>	}</code></span>
<span class="codeline" id="line-786"><code>	state := tlsConn.ConnectionState()</code></span>
<span class="codeline" id="line-787"><code>	return &amp;state</code></span>
<span class="codeline" id="line-788"><code>}</code></span>
<span class="codeline" id="line-789"><code></code></span>
<span class="codeline" id="line-790"><code>// Conn returns a reference to the underlying net.Conn.</code></span>
<span class="codeline" id="line-791"><code>//</code></span>
<span class="codeline" id="line-792"><code>// WARNING: Only use this method if you know what you are doing!</code></span>
<span class="codeline" id="line-793"><code>//</code></span>
<span class="codeline" id="line-794"><code>// Reading from or writing to the returned connection will end badly!</code></span>
<span class="codeline" id="line-795"><code>func (ctx *RequestCtx) Conn() net.Conn {</code></span>
<span class="codeline" id="line-796"><code>	return ctx.c</code></span>
<span class="codeline" id="line-797"><code>}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>func (ctx *RequestCtx) reset() {</code></span>
<span class="codeline" id="line-800"><code>	ctx.userValues.Reset()</code></span>
<span class="codeline" id="line-801"><code>	ctx.Request.Reset()</code></span>
<span class="codeline" id="line-802"><code>	ctx.Response.Reset()</code></span>
<span class="codeline" id="line-803"><code>	ctx.fbr.reset()</code></span>
<span class="codeline" id="line-804"><code></code></span>
<span class="codeline" id="line-805"><code>	ctx.connID = 0</code></span>
<span class="codeline" id="line-806"><code>	ctx.connRequestNum = 0</code></span>
<span class="codeline" id="line-807"><code>	ctx.connTime = zeroTime</code></span>
<span class="codeline" id="line-808"><code>	ctx.remoteAddr = nil</code></span>
<span class="codeline" id="line-809"><code>	ctx.time = zeroTime</code></span>
<span class="codeline" id="line-810"><code>	ctx.c = nil</code></span>
<span class="codeline" id="line-811"><code></code></span>
<span class="codeline" id="line-812"><code>	// Don't reset ctx.s!</code></span>
<span class="codeline" id="line-813"><code>	// We have a pool per server so the next time this ctx is used it</code></span>
<span class="codeline" id="line-814"><code>	// will be assigned the same value again.</code></span>
<span class="codeline" id="line-815"><code>	// ctx might still be in use for context.Done() and context.Err()</code></span>
<span class="codeline" id="line-816"><code>	// which are safe to use as they only use ctx.s and no other value.</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>	if ctx.timeoutResponse != nil {</code></span>
<span class="codeline" id="line-819"><code>		ctx.timeoutResponse.Reset()</code></span>
<span class="codeline" id="line-820"><code>	}</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>	if ctx.timeoutTimer != nil {</code></span>
<span class="codeline" id="line-823"><code>		stopTimer(ctx.timeoutTimer)</code></span>
<span class="codeline" id="line-824"><code>	}</code></span>
<span class="codeline" id="line-825"><code></code></span>
<span class="codeline" id="line-826"><code>	ctx.hijackHandler = nil</code></span>
<span class="codeline" id="line-827"><code>	ctx.hijackNoResponse = false</code></span>
<span class="codeline" id="line-828"><code>}</code></span>
<span class="codeline" id="line-829"><code></code></span>
<span class="codeline" id="line-830"><code>type firstByteReader struct {</code></span>
<span class="codeline" id="line-831"><code>	c        net.Conn</code></span>
<span class="codeline" id="line-832"><code>	ch       byte</code></span>
<span class="codeline" id="line-833"><code>	byteRead bool</code></span>
<span class="codeline" id="line-834"><code>}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>func (r *firstByteReader) reset() {</code></span>
<span class="codeline" id="line-837"><code>	r.c = nil</code></span>
<span class="codeline" id="line-838"><code>	r.ch = 0</code></span>
<span class="codeline" id="line-839"><code>	r.byteRead = false</code></span>
<span class="codeline" id="line-840"><code>}</code></span>
<span class="codeline" id="line-841"><code></code></span>
<span class="codeline" id="line-842"><code>func (r *firstByteReader) Read(b []byte) (int, error) {</code></span>
<span class="codeline" id="line-843"><code>	if len(b) == 0 {</code></span>
<span class="codeline" id="line-844"><code>		return 0, nil</code></span>
<span class="codeline" id="line-845"><code>	}</code></span>
<span class="codeline" id="line-846"><code>	nn := 0</code></span>
<span class="codeline" id="line-847"><code>	if !r.byteRead {</code></span>
<span class="codeline" id="line-848"><code>		b[0] = r.ch</code></span>
<span class="codeline" id="line-849"><code>		b = b[1:]</code></span>
<span class="codeline" id="line-850"><code>		r.byteRead = true</code></span>
<span class="codeline" id="line-851"><code>		nn = 1</code></span>
<span class="codeline" id="line-852"><code>	}</code></span>
<span class="codeline" id="line-853"><code>	n, err := r.c.Read(b)</code></span>
<span class="codeline" id="line-854"><code>	return n + nn, err</code></span>
<span class="codeline" id="line-855"><code>}</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>// Logger is used for logging formatted messages.</code></span>
<span class="codeline" id="line-858"><code>type Logger interface {</code></span>
<span class="codeline" id="line-859"><code>	// Printf must have the same semantics as log.Printf.</code></span>
<span class="codeline" id="line-860"><code>	Printf(format string, args ...any)</code></span>
<span class="codeline" id="line-861"><code>}</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>var ctxLoggerLock sync.Mutex</code></span>
<span class="codeline" id="line-864"><code></code></span>
<span class="codeline" id="line-865"><code>type ctxLogger struct {</code></span>
<span class="codeline" id="line-866"><code>	ctx    *RequestCtx</code></span>
<span class="codeline" id="line-867"><code>	logger Logger</code></span>
<span class="codeline" id="line-868"><code>}</code></span>
<span class="codeline" id="line-869"><code></code></span>
<span class="codeline" id="line-870"><code>func (cl *ctxLogger) Printf(format string, args ...any) {</code></span>
<span class="codeline" id="line-871"><code>	msg := fmt.Sprintf(format, args...)</code></span>
<span class="codeline" id="line-872"><code>	ctxLoggerLock.Lock()</code></span>
<span class="codeline" id="line-873"><code>	cl.logger.Printf("%.3f %s - %s", time.Since(cl.ctx.ConnTime()).Seconds(), cl.ctx.String(), msg)</code></span>
<span class="codeline" id="line-874"><code>	ctxLoggerLock.Unlock()</code></span>
<span class="codeline" id="line-875"><code>}</code></span>
<span class="codeline" id="line-876"><code></code></span>
<span class="codeline" id="line-877"><code>var zeroTCPAddr = &amp;net.TCPAddr{</code></span>
<span class="codeline" id="line-878"><code>	IP: net.IPv4zero,</code></span>
<span class="codeline" id="line-879"><code>}</code></span>
<span class="codeline" id="line-880"><code></code></span>
<span class="codeline" id="line-881"><code>// String returns unique string representation of the ctx.</code></span>
<span class="codeline" id="line-882"><code>//</code></span>
<span class="codeline" id="line-883"><code>// The returned value may be useful for logging.</code></span>
<span class="codeline" id="line-884"><code>func (ctx *RequestCtx) String() string {</code></span>
<span class="codeline" id="line-885"><code>	return fmt.Sprintf("#%016X - %s&lt;-&gt;%s - %s %s", ctx.ID(), ctx.LocalAddr(), ctx.RemoteAddr(),</code></span>
<span class="codeline" id="line-886"><code>		ctx.Request.Header.Method(), ctx.URI().FullURI())</code></span>
<span class="codeline" id="line-887"><code>}</code></span>
<span class="codeline" id="line-888"><code></code></span>
<span class="codeline" id="line-889"><code>// ID returns unique ID of the request.</code></span>
<span class="codeline" id="line-890"><code>func (ctx *RequestCtx) ID() uint64 {</code></span>
<span class="codeline" id="line-891"><code>	return (ctx.connID &lt;&lt; 32) | ctx.connRequestNum</code></span>
<span class="codeline" id="line-892"><code>}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>// ConnID returns unique connection ID.</code></span>
<span class="codeline" id="line-895"><code>//</code></span>
<span class="codeline" id="line-896"><code>// This ID may be used to match distinct requests to the same incoming</code></span>
<span class="codeline" id="line-897"><code>// connection.</code></span>
<span class="codeline" id="line-898"><code>func (ctx *RequestCtx) ConnID() uint64 {</code></span>
<span class="codeline" id="line-899"><code>	return ctx.connID</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// Time returns RequestHandler call time.</code></span>
<span class="codeline" id="line-903"><code>func (ctx *RequestCtx) Time() time.Time {</code></span>
<span class="codeline" id="line-904"><code>	return ctx.time</code></span>
<span class="codeline" id="line-905"><code>}</code></span>
<span class="codeline" id="line-906"><code></code></span>
<span class="codeline" id="line-907"><code>// ConnTime returns the time the server started serving the connection</code></span>
<span class="codeline" id="line-908"><code>// the current request came from.</code></span>
<span class="codeline" id="line-909"><code>func (ctx *RequestCtx) ConnTime() time.Time {</code></span>
<span class="codeline" id="line-910"><code>	return ctx.connTime</code></span>
<span class="codeline" id="line-911"><code>}</code></span>
<span class="codeline" id="line-912"><code></code></span>
<span class="codeline" id="line-913"><code>// ConnRequestNum returns request sequence number</code></span>
<span class="codeline" id="line-914"><code>// for the current connection.</code></span>
<span class="codeline" id="line-915"><code>//</code></span>
<span class="codeline" id="line-916"><code>// Sequence starts with 1.</code></span>
<span class="codeline" id="line-917"><code>func (ctx *RequestCtx) ConnRequestNum() uint64 {</code></span>
<span class="codeline" id="line-918"><code>	return ctx.connRequestNum</code></span>
<span class="codeline" id="line-919"><code>}</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>// SetConnectionClose sets 'Connection: close' response header and closes</code></span>
<span class="codeline" id="line-922"><code>// connection after the RequestHandler returns.</code></span>
<span class="codeline" id="line-923"><code>func (ctx *RequestCtx) SetConnectionClose() {</code></span>
<span class="codeline" id="line-924"><code>	ctx.Response.SetConnectionClose()</code></span>
<span class="codeline" id="line-925"><code>}</code></span>
<span class="codeline" id="line-926"><code></code></span>
<span class="codeline" id="line-927"><code>// SetStatusCode sets response status code.</code></span>
<span class="codeline" id="line-928"><code>func (ctx *RequestCtx) SetStatusCode(statusCode int) {</code></span>
<span class="codeline" id="line-929"><code>	ctx.Response.SetStatusCode(statusCode)</code></span>
<span class="codeline" id="line-930"><code>}</code></span>
<span class="codeline" id="line-931"><code></code></span>
<span class="codeline" id="line-932"><code>// SetContentType sets response Content-Type.</code></span>
<span class="codeline" id="line-933"><code>func (ctx *RequestCtx) SetContentType(contentType string) {</code></span>
<span class="codeline" id="line-934"><code>	ctx.Response.Header.SetContentType(contentType)</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>// SetContentTypeBytes sets response Content-Type.</code></span>
<span class="codeline" id="line-938"><code>//</code></span>
<span class="codeline" id="line-939"><code>// It is safe modifying contentType buffer after function return.</code></span>
<span class="codeline" id="line-940"><code>func (ctx *RequestCtx) SetContentTypeBytes(contentType []byte) {</code></span>
<span class="codeline" id="line-941"><code>	ctx.Response.Header.SetContentTypeBytes(contentType)</code></span>
<span class="codeline" id="line-942"><code>}</code></span>
<span class="codeline" id="line-943"><code></code></span>
<span class="codeline" id="line-944"><code>// RequestURI returns RequestURI.</code></span>
<span class="codeline" id="line-945"><code>//</code></span>
<span class="codeline" id="line-946"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-947"><code>func (ctx *RequestCtx) RequestURI() []byte {</code></span>
<span class="codeline" id="line-948"><code>	return ctx.Request.Header.RequestURI()</code></span>
<span class="codeline" id="line-949"><code>}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>// URI returns requested uri.</code></span>
<span class="codeline" id="line-952"><code>//</code></span>
<span class="codeline" id="line-953"><code>// This uri is valid until your request handler returns.</code></span>
<span class="codeline" id="line-954"><code>func (ctx *RequestCtx) URI() *URI {</code></span>
<span class="codeline" id="line-955"><code>	return ctx.Request.URI()</code></span>
<span class="codeline" id="line-956"><code>}</code></span>
<span class="codeline" id="line-957"><code></code></span>
<span class="codeline" id="line-958"><code>// Referer returns request referer.</code></span>
<span class="codeline" id="line-959"><code>//</code></span>
<span class="codeline" id="line-960"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-961"><code>func (ctx *RequestCtx) Referer() []byte {</code></span>
<span class="codeline" id="line-962"><code>	return ctx.Request.Header.Referer()</code></span>
<span class="codeline" id="line-963"><code>}</code></span>
<span class="codeline" id="line-964"><code></code></span>
<span class="codeline" id="line-965"><code>// UserAgent returns User-Agent header value from the request.</code></span>
<span class="codeline" id="line-966"><code>//</code></span>
<span class="codeline" id="line-967"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-968"><code>func (ctx *RequestCtx) UserAgent() []byte {</code></span>
<span class="codeline" id="line-969"><code>	return ctx.Request.Header.UserAgent()</code></span>
<span class="codeline" id="line-970"><code>}</code></span>
<span class="codeline" id="line-971"><code></code></span>
<span class="codeline" id="line-972"><code>// Path returns requested path.</code></span>
<span class="codeline" id="line-973"><code>//</code></span>
<span class="codeline" id="line-974"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-975"><code>func (ctx *RequestCtx) Path() []byte {</code></span>
<span class="codeline" id="line-976"><code>	return ctx.URI().Path()</code></span>
<span class="codeline" id="line-977"><code>}</code></span>
<span class="codeline" id="line-978"><code></code></span>
<span class="codeline" id="line-979"><code>// Host returns requested host.</code></span>
<span class="codeline" id="line-980"><code>//</code></span>
<span class="codeline" id="line-981"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-982"><code>func (ctx *RequestCtx) Host() []byte {</code></span>
<span class="codeline" id="line-983"><code>	return ctx.URI().Host()</code></span>
<span class="codeline" id="line-984"><code>}</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>// QueryArgs returns query arguments from RequestURI.</code></span>
<span class="codeline" id="line-987"><code>//</code></span>
<span class="codeline" id="line-988"><code>// It doesn't return POST'ed arguments - use PostArgs() for this.</code></span>
<span class="codeline" id="line-989"><code>//</code></span>
<span class="codeline" id="line-990"><code>// See also PostArgs, FormValue and FormFile.</code></span>
<span class="codeline" id="line-991"><code>//</code></span>
<span class="codeline" id="line-992"><code>// These args are valid until your request handler returns.</code></span>
<span class="codeline" id="line-993"><code>func (ctx *RequestCtx) QueryArgs() *Args {</code></span>
<span class="codeline" id="line-994"><code>	return ctx.URI().QueryArgs()</code></span>
<span class="codeline" id="line-995"><code>}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>// PostArgs returns POST arguments.</code></span>
<span class="codeline" id="line-998"><code>//</code></span>
<span class="codeline" id="line-999"><code>// It doesn't return query arguments from RequestURI - use QueryArgs for this.</code></span>
<span class="codeline" id="line-1000"><code>//</code></span>
<span class="codeline" id="line-1001"><code>// See also QueryArgs, FormValue and FormFile.</code></span>
<span class="codeline" id="line-1002"><code>//</code></span>
<span class="codeline" id="line-1003"><code>// These args are valid until your request handler returns.</code></span>
<span class="codeline" id="line-1004"><code>func (ctx *RequestCtx) PostArgs() *Args {</code></span>
<span class="codeline" id="line-1005"><code>	return ctx.Request.PostArgs()</code></span>
<span class="codeline" id="line-1006"><code>}</code></span>
<span class="codeline" id="line-1007"><code></code></span>
<span class="codeline" id="line-1008"><code>// MultipartForm returns request's multipart form.</code></span>
<span class="codeline" id="line-1009"><code>//</code></span>
<span class="codeline" id="line-1010"><code>// Returns ErrNoMultipartForm if request's content-type</code></span>
<span class="codeline" id="line-1011"><code>// isn't 'multipart/form-data'.</code></span>
<span class="codeline" id="line-1012"><code>//</code></span>
<span class="codeline" id="line-1013"><code>// All uploaded temporary files are automatically deleted after</code></span>
<span class="codeline" id="line-1014"><code>// returning from RequestHandler. Either move or copy uploaded files</code></span>
<span class="codeline" id="line-1015"><code>// into new place if you want retaining them.</code></span>
<span class="codeline" id="line-1016"><code>//</code></span>
<span class="codeline" id="line-1017"><code>// Use SaveMultipartFile function for permanently saving uploaded file.</code></span>
<span class="codeline" id="line-1018"><code>//</code></span>
<span class="codeline" id="line-1019"><code>// The returned form is valid until your request handler returns.</code></span>
<span class="codeline" id="line-1020"><code>//</code></span>
<span class="codeline" id="line-1021"><code>// See also FormFile and FormValue.</code></span>
<span class="codeline" id="line-1022"><code>func (ctx *RequestCtx) MultipartForm() (*multipart.Form, error) {</code></span>
<span class="codeline" id="line-1023"><code>	return ctx.Request.MultipartForm()</code></span>
<span class="codeline" id="line-1024"><code>}</code></span>
<span class="codeline" id="line-1025"><code></code></span>
<span class="codeline" id="line-1026"><code>// FormFile returns uploaded file associated with the given multipart form key.</code></span>
<span class="codeline" id="line-1027"><code>//</code></span>
<span class="codeline" id="line-1028"><code>// The file is automatically deleted after returning from RequestHandler,</code></span>
<span class="codeline" id="line-1029"><code>// so either move or copy uploaded file into new place if you want retaining it.</code></span>
<span class="codeline" id="line-1030"><code>//</code></span>
<span class="codeline" id="line-1031"><code>// Use SaveMultipartFile function for permanently saving uploaded file.</code></span>
<span class="codeline" id="line-1032"><code>//</code></span>
<span class="codeline" id="line-1033"><code>// The returned file header is valid until your request handler returns.</code></span>
<span class="codeline" id="line-1034"><code>func (ctx *RequestCtx) FormFile(key string) (*multipart.FileHeader, error) {</code></span>
<span class="codeline" id="line-1035"><code>	mf, err := ctx.MultipartForm()</code></span>
<span class="codeline" id="line-1036"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1037"><code>		return nil, err</code></span>
<span class="codeline" id="line-1038"><code>	}</code></span>
<span class="codeline" id="line-1039"><code>	if mf.File == nil {</code></span>
<span class="codeline" id="line-1040"><code>		return nil, err</code></span>
<span class="codeline" id="line-1041"><code>	}</code></span>
<span class="codeline" id="line-1042"><code>	fhh := mf.File[key]</code></span>
<span class="codeline" id="line-1043"><code>	if fhh == nil {</code></span>
<span class="codeline" id="line-1044"><code>		return nil, ErrMissingFile</code></span>
<span class="codeline" id="line-1045"><code>	}</code></span>
<span class="codeline" id="line-1046"><code>	return fhh[0], nil</code></span>
<span class="codeline" id="line-1047"><code>}</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>// ErrMissingFile may be returned from FormFile when the is no uploaded file</code></span>
<span class="codeline" id="line-1050"><code>// associated with the given multipart form key.</code></span>
<span class="codeline" id="line-1051"><code>var ErrMissingFile = errors.New("there is no uploaded file associated with the given key")</code></span>
<span class="codeline" id="line-1052"><code></code></span>
<span class="codeline" id="line-1053"><code>// SaveMultipartFile saves multipart file fh under the given filename path.</code></span>
<span class="codeline" id="line-1054"><code>func SaveMultipartFile(fh *multipart.FileHeader, path string) (err error) {</code></span>
<span class="codeline" id="line-1055"><code>	var (</code></span>
<span class="codeline" id="line-1056"><code>		f  multipart.File</code></span>
<span class="codeline" id="line-1057"><code>		ff *os.File</code></span>
<span class="codeline" id="line-1058"><code>	)</code></span>
<span class="codeline" id="line-1059"><code>	f, err = fh.Open()</code></span>
<span class="codeline" id="line-1060"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1061"><code>		return</code></span>
<span class="codeline" id="line-1062"><code>	}</code></span>
<span class="codeline" id="line-1063"><code></code></span>
<span class="codeline" id="line-1064"><code>	var ok bool</code></span>
<span class="codeline" id="line-1065"><code>	if ff, ok = f.(*os.File); ok {</code></span>
<span class="codeline" id="line-1066"><code>		// Windows can't rename files that are opened.</code></span>
<span class="codeline" id="line-1067"><code>		if err = f.Close(); err != nil {</code></span>
<span class="codeline" id="line-1068"><code>			return</code></span>
<span class="codeline" id="line-1069"><code>		}</code></span>
<span class="codeline" id="line-1070"><code></code></span>
<span class="codeline" id="line-1071"><code>		// If renaming fails we try the normal copying method.</code></span>
<span class="codeline" id="line-1072"><code>		// Renaming could fail if the files are on different devices.</code></span>
<span class="codeline" id="line-1073"><code>		if os.Rename(ff.Name(), path) == nil {</code></span>
<span class="codeline" id="line-1074"><code>			return nil</code></span>
<span class="codeline" id="line-1075"><code>		}</code></span>
<span class="codeline" id="line-1076"><code></code></span>
<span class="codeline" id="line-1077"><code>		// Reopen f for the code below.</code></span>
<span class="codeline" id="line-1078"><code>		if f, err = fh.Open(); err != nil {</code></span>
<span class="codeline" id="line-1079"><code>			return</code></span>
<span class="codeline" id="line-1080"><code>		}</code></span>
<span class="codeline" id="line-1081"><code>	}</code></span>
<span class="codeline" id="line-1082"><code></code></span>
<span class="codeline" id="line-1083"><code>	defer func() {</code></span>
<span class="codeline" id="line-1084"><code>		e := f.Close()</code></span>
<span class="codeline" id="line-1085"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1086"><code>			err = e</code></span>
<span class="codeline" id="line-1087"><code>		}</code></span>
<span class="codeline" id="line-1088"><code>	}()</code></span>
<span class="codeline" id="line-1089"><code></code></span>
<span class="codeline" id="line-1090"><code>	if ff, err = os.Create(path); err != nil {</code></span>
<span class="codeline" id="line-1091"><code>		return</code></span>
<span class="codeline" id="line-1092"><code>	}</code></span>
<span class="codeline" id="line-1093"><code>	defer func() {</code></span>
<span class="codeline" id="line-1094"><code>		e := ff.Close()</code></span>
<span class="codeline" id="line-1095"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1096"><code>			err = e</code></span>
<span class="codeline" id="line-1097"><code>		}</code></span>
<span class="codeline" id="line-1098"><code>	}()</code></span>
<span class="codeline" id="line-1099"><code>	_, err = copyZeroAlloc(ff, f)</code></span>
<span class="codeline" id="line-1100"><code>	return</code></span>
<span class="codeline" id="line-1101"><code>}</code></span>
<span class="codeline" id="line-1102"><code></code></span>
<span class="codeline" id="line-1103"><code>// FormValue returns form value associated with the given key.</code></span>
<span class="codeline" id="line-1104"><code>//</code></span>
<span class="codeline" id="line-1105"><code>// The value is searched in the following places:</code></span>
<span class="codeline" id="line-1106"><code>//</code></span>
<span class="codeline" id="line-1107"><code>//   - Query string.</code></span>
<span class="codeline" id="line-1108"><code>//   - POST or PUT body.</code></span>
<span class="codeline" id="line-1109"><code>//</code></span>
<span class="codeline" id="line-1110"><code>// There are more fine-grained methods for obtaining form values:</code></span>
<span class="codeline" id="line-1111"><code>//</code></span>
<span class="codeline" id="line-1112"><code>//   - QueryArgs for obtaining values from query string.</code></span>
<span class="codeline" id="line-1113"><code>//   - PostArgs for obtaining values from POST or PUT body.</code></span>
<span class="codeline" id="line-1114"><code>//   - MultipartForm for obtaining values from multipart form.</code></span>
<span class="codeline" id="line-1115"><code>//   - FormFile for obtaining uploaded files.</code></span>
<span class="codeline" id="line-1116"><code>//</code></span>
<span class="codeline" id="line-1117"><code>// The returned value is valid until your request handler returns.</code></span>
<span class="codeline" id="line-1118"><code>func (ctx *RequestCtx) FormValue(key string) []byte {</code></span>
<span class="codeline" id="line-1119"><code>	if ctx.formValueFunc != nil {</code></span>
<span class="codeline" id="line-1120"><code>		return ctx.formValueFunc(ctx, key)</code></span>
<span class="codeline" id="line-1121"><code>	}</code></span>
<span class="codeline" id="line-1122"><code>	return defaultFormValue(ctx, key)</code></span>
<span class="codeline" id="line-1123"><code>}</code></span>
<span class="codeline" id="line-1124"><code></code></span>
<span class="codeline" id="line-1125"><code>type FormValueFunc func(*RequestCtx, string) []byte</code></span>
<span class="codeline" id="line-1126"><code></code></span>
<span class="codeline" id="line-1127"><code>var (</code></span>
<span class="codeline" id="line-1128"><code>	defaultFormValue = func(ctx *RequestCtx, key string) []byte {</code></span>
<span class="codeline" id="line-1129"><code>		v := ctx.QueryArgs().Peek(key)</code></span>
<span class="codeline" id="line-1130"><code>		if len(v) &gt; 0 {</code></span>
<span class="codeline" id="line-1131"><code>			return v</code></span>
<span class="codeline" id="line-1132"><code>		}</code></span>
<span class="codeline" id="line-1133"><code>		v = ctx.PostArgs().Peek(key)</code></span>
<span class="codeline" id="line-1134"><code>		if len(v) &gt; 0 {</code></span>
<span class="codeline" id="line-1135"><code>			return v</code></span>
<span class="codeline" id="line-1136"><code>		}</code></span>
<span class="codeline" id="line-1137"><code>		mf, err := ctx.MultipartForm()</code></span>
<span class="codeline" id="line-1138"><code>		if err == nil &amp;&amp; mf.Value != nil {</code></span>
<span class="codeline" id="line-1139"><code>			vv := mf.Value[key]</code></span>
<span class="codeline" id="line-1140"><code>			if len(vv) &gt; 0 {</code></span>
<span class="codeline" id="line-1141"><code>				return []byte(vv[0])</code></span>
<span class="codeline" id="line-1142"><code>			}</code></span>
<span class="codeline" id="line-1143"><code>		}</code></span>
<span class="codeline" id="line-1144"><code>		return nil</code></span>
<span class="codeline" id="line-1145"><code>	}</code></span>
<span class="codeline" id="line-1146"><code></code></span>
<span class="codeline" id="line-1147"><code>	// NetHttpFormValueFunc gives consistent behavior with net/http.</code></span>
<span class="codeline" id="line-1148"><code>	// POST and PUT body parameters take precedence over URL query string values.</code></span>
<span class="codeline" id="line-1149"><code>	//</code></span>
<span class="codeline" id="line-1150"><code>	//nolint:stylecheck // backwards compatibility</code></span>
<span class="codeline" id="line-1151"><code>	NetHttpFormValueFunc = func(ctx *RequestCtx, key string) []byte {</code></span>
<span class="codeline" id="line-1152"><code>		v := ctx.PostArgs().Peek(key)</code></span>
<span class="codeline" id="line-1153"><code>		if len(v) &gt; 0 {</code></span>
<span class="codeline" id="line-1154"><code>			return v</code></span>
<span class="codeline" id="line-1155"><code>		}</code></span>
<span class="codeline" id="line-1156"><code>		mf, err := ctx.MultipartForm()</code></span>
<span class="codeline" id="line-1157"><code>		if err == nil &amp;&amp; mf.Value != nil {</code></span>
<span class="codeline" id="line-1158"><code>			vv := mf.Value[key]</code></span>
<span class="codeline" id="line-1159"><code>			if len(vv) &gt; 0 {</code></span>
<span class="codeline" id="line-1160"><code>				return []byte(vv[0])</code></span>
<span class="codeline" id="line-1161"><code>			}</code></span>
<span class="codeline" id="line-1162"><code>		}</code></span>
<span class="codeline" id="line-1163"><code>		v = ctx.QueryArgs().Peek(key)</code></span>
<span class="codeline" id="line-1164"><code>		if len(v) &gt; 0 {</code></span>
<span class="codeline" id="line-1165"><code>			return v</code></span>
<span class="codeline" id="line-1166"><code>		}</code></span>
<span class="codeline" id="line-1167"><code>		return nil</code></span>
<span class="codeline" id="line-1168"><code>	}</code></span>
<span class="codeline" id="line-1169"><code>)</code></span>
<span class="codeline" id="line-1170"><code></code></span>
<span class="codeline" id="line-1171"><code>// IsGet returns true if request method is GET.</code></span>
<span class="codeline" id="line-1172"><code>func (ctx *RequestCtx) IsGet() bool {</code></span>
<span class="codeline" id="line-1173"><code>	return ctx.Request.Header.IsGet()</code></span>
<span class="codeline" id="line-1174"><code>}</code></span>
<span class="codeline" id="line-1175"><code></code></span>
<span class="codeline" id="line-1176"><code>// IsPost returns true if request method is POST.</code></span>
<span class="codeline" id="line-1177"><code>func (ctx *RequestCtx) IsPost() bool {</code></span>
<span class="codeline" id="line-1178"><code>	return ctx.Request.Header.IsPost()</code></span>
<span class="codeline" id="line-1179"><code>}</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>// IsPut returns true if request method is PUT.</code></span>
<span class="codeline" id="line-1182"><code>func (ctx *RequestCtx) IsPut() bool {</code></span>
<span class="codeline" id="line-1183"><code>	return ctx.Request.Header.IsPut()</code></span>
<span class="codeline" id="line-1184"><code>}</code></span>
<span class="codeline" id="line-1185"><code></code></span>
<span class="codeline" id="line-1186"><code>// IsDelete returns true if request method is DELETE.</code></span>
<span class="codeline" id="line-1187"><code>func (ctx *RequestCtx) IsDelete() bool {</code></span>
<span class="codeline" id="line-1188"><code>	return ctx.Request.Header.IsDelete()</code></span>
<span class="codeline" id="line-1189"><code>}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>// IsConnect returns true if request method is CONNECT.</code></span>
<span class="codeline" id="line-1192"><code>func (ctx *RequestCtx) IsConnect() bool {</code></span>
<span class="codeline" id="line-1193"><code>	return ctx.Request.Header.IsConnect()</code></span>
<span class="codeline" id="line-1194"><code>}</code></span>
<span class="codeline" id="line-1195"><code></code></span>
<span class="codeline" id="line-1196"><code>// IsOptions returns true if request method is OPTIONS.</code></span>
<span class="codeline" id="line-1197"><code>func (ctx *RequestCtx) IsOptions() bool {</code></span>
<span class="codeline" id="line-1198"><code>	return ctx.Request.Header.IsOptions()</code></span>
<span class="codeline" id="line-1199"><code>}</code></span>
<span class="codeline" id="line-1200"><code></code></span>
<span class="codeline" id="line-1201"><code>// IsTrace returns true if request method is TRACE.</code></span>
<span class="codeline" id="line-1202"><code>func (ctx *RequestCtx) IsTrace() bool {</code></span>
<span class="codeline" id="line-1203"><code>	return ctx.Request.Header.IsTrace()</code></span>
<span class="codeline" id="line-1204"><code>}</code></span>
<span class="codeline" id="line-1205"><code></code></span>
<span class="codeline" id="line-1206"><code>// IsPatch returns true if request method is PATCH.</code></span>
<span class="codeline" id="line-1207"><code>func (ctx *RequestCtx) IsPatch() bool {</code></span>
<span class="codeline" id="line-1208"><code>	return ctx.Request.Header.IsPatch()</code></span>
<span class="codeline" id="line-1209"><code>}</code></span>
<span class="codeline" id="line-1210"><code></code></span>
<span class="codeline" id="line-1211"><code>// Method return request method.</code></span>
<span class="codeline" id="line-1212"><code>//</code></span>
<span class="codeline" id="line-1213"><code>// Returned value is valid until your request handler returns.</code></span>
<span class="codeline" id="line-1214"><code>func (ctx *RequestCtx) Method() []byte {</code></span>
<span class="codeline" id="line-1215"><code>	return ctx.Request.Header.Method()</code></span>
<span class="codeline" id="line-1216"><code>}</code></span>
<span class="codeline" id="line-1217"><code></code></span>
<span class="codeline" id="line-1218"><code>// IsHead returns true if request method is HEAD.</code></span>
<span class="codeline" id="line-1219"><code>func (ctx *RequestCtx) IsHead() bool {</code></span>
<span class="codeline" id="line-1220"><code>	return ctx.Request.Header.IsHead()</code></span>
<span class="codeline" id="line-1221"><code>}</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>// RemoteAddr returns client address for the given request.</code></span>
<span class="codeline" id="line-1224"><code>//</code></span>
<span class="codeline" id="line-1225"><code>// Always returns non-nil result.</code></span>
<span class="codeline" id="line-1226"><code>func (ctx *RequestCtx) RemoteAddr() net.Addr {</code></span>
<span class="codeline" id="line-1227"><code>	if ctx.remoteAddr != nil {</code></span>
<span class="codeline" id="line-1228"><code>		return ctx.remoteAddr</code></span>
<span class="codeline" id="line-1229"><code>	}</code></span>
<span class="codeline" id="line-1230"><code>	if ctx.c == nil {</code></span>
<span class="codeline" id="line-1231"><code>		return zeroTCPAddr</code></span>
<span class="codeline" id="line-1232"><code>	}</code></span>
<span class="codeline" id="line-1233"><code>	addr := ctx.c.RemoteAddr()</code></span>
<span class="codeline" id="line-1234"><code>	if addr == nil {</code></span>
<span class="codeline" id="line-1235"><code>		return zeroTCPAddr</code></span>
<span class="codeline" id="line-1236"><code>	}</code></span>
<span class="codeline" id="line-1237"><code>	return addr</code></span>
<span class="codeline" id="line-1238"><code>}</code></span>
<span class="codeline" id="line-1239"><code></code></span>
<span class="codeline" id="line-1240"><code>// SetRemoteAddr sets remote address to the given value.</code></span>
<span class="codeline" id="line-1241"><code>//</code></span>
<span class="codeline" id="line-1242"><code>// Set nil value to restore default behaviour for using</code></span>
<span class="codeline" id="line-1243"><code>// connection remote address.</code></span>
<span class="codeline" id="line-1244"><code>func (ctx *RequestCtx) SetRemoteAddr(remoteAddr net.Addr) {</code></span>
<span class="codeline" id="line-1245"><code>	ctx.remoteAddr = remoteAddr</code></span>
<span class="codeline" id="line-1246"><code>}</code></span>
<span class="codeline" id="line-1247"><code></code></span>
<span class="codeline" id="line-1248"><code>// LocalAddr returns server address for the given request.</code></span>
<span class="codeline" id="line-1249"><code>//</code></span>
<span class="codeline" id="line-1250"><code>// Always returns non-nil result.</code></span>
<span class="codeline" id="line-1251"><code>func (ctx *RequestCtx) LocalAddr() net.Addr {</code></span>
<span class="codeline" id="line-1252"><code>	if ctx.c == nil {</code></span>
<span class="codeline" id="line-1253"><code>		return zeroTCPAddr</code></span>
<span class="codeline" id="line-1254"><code>	}</code></span>
<span class="codeline" id="line-1255"><code>	addr := ctx.c.LocalAddr()</code></span>
<span class="codeline" id="line-1256"><code>	if addr == nil {</code></span>
<span class="codeline" id="line-1257"><code>		return zeroTCPAddr</code></span>
<span class="codeline" id="line-1258"><code>	}</code></span>
<span class="codeline" id="line-1259"><code>	return addr</code></span>
<span class="codeline" id="line-1260"><code>}</code></span>
<span class="codeline" id="line-1261"><code></code></span>
<span class="codeline" id="line-1262"><code>// RemoteIP returns the client ip the request came from.</code></span>
<span class="codeline" id="line-1263"><code>//</code></span>
<span class="codeline" id="line-1264"><code>// Always returns non-nil result.</code></span>
<span class="codeline" id="line-1265"><code>func (ctx *RequestCtx) RemoteIP() net.IP {</code></span>
<span class="codeline" id="line-1266"><code>	return addrToIP(ctx.RemoteAddr())</code></span>
<span class="codeline" id="line-1267"><code>}</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>// LocalIP returns the server ip the request came to.</code></span>
<span class="codeline" id="line-1270"><code>//</code></span>
<span class="codeline" id="line-1271"><code>// Always returns non-nil result.</code></span>
<span class="codeline" id="line-1272"><code>func (ctx *RequestCtx) LocalIP() net.IP {</code></span>
<span class="codeline" id="line-1273"><code>	return addrToIP(ctx.LocalAddr())</code></span>
<span class="codeline" id="line-1274"><code>}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>func addrToIP(addr net.Addr) net.IP {</code></span>
<span class="codeline" id="line-1277"><code>	x, ok := addr.(*net.TCPAddr)</code></span>
<span class="codeline" id="line-1278"><code>	if !ok {</code></span>
<span class="codeline" id="line-1279"><code>		return net.IPv4zero</code></span>
<span class="codeline" id="line-1280"><code>	}</code></span>
<span class="codeline" id="line-1281"><code>	return x.IP</code></span>
<span class="codeline" id="line-1282"><code>}</code></span>
<span class="codeline" id="line-1283"><code></code></span>
<span class="codeline" id="line-1284"><code>// Error sets response status code to the given value and sets response body</code></span>
<span class="codeline" id="line-1285"><code>// to the given message.</code></span>
<span class="codeline" id="line-1286"><code>//</code></span>
<span class="codeline" id="line-1287"><code>// Warning: this will reset the response headers and body already set!</code></span>
<span class="codeline" id="line-1288"><code>func (ctx *RequestCtx) Error(msg string, statusCode int) {</code></span>
<span class="codeline" id="line-1289"><code>	ctx.Response.Reset()</code></span>
<span class="codeline" id="line-1290"><code>	ctx.SetStatusCode(statusCode)</code></span>
<span class="codeline" id="line-1291"><code>	ctx.SetContentTypeBytes(defaultContentType)</code></span>
<span class="codeline" id="line-1292"><code>	ctx.SetBodyString(msg)</code></span>
<span class="codeline" id="line-1293"><code>}</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>// Success sets response Content-Type and body to the given values.</code></span>
<span class="codeline" id="line-1296"><code>func (ctx *RequestCtx) Success(contentType string, body []byte) {</code></span>
<span class="codeline" id="line-1297"><code>	ctx.SetContentType(contentType)</code></span>
<span class="codeline" id="line-1298"><code>	ctx.SetBody(body)</code></span>
<span class="codeline" id="line-1299"><code>}</code></span>
<span class="codeline" id="line-1300"><code></code></span>
<span class="codeline" id="line-1301"><code>// SuccessString sets response Content-Type and body to the given values.</code></span>
<span class="codeline" id="line-1302"><code>func (ctx *RequestCtx) SuccessString(contentType, body string) {</code></span>
<span class="codeline" id="line-1303"><code>	ctx.SetContentType(contentType)</code></span>
<span class="codeline" id="line-1304"><code>	ctx.SetBodyString(body)</code></span>
<span class="codeline" id="line-1305"><code>}</code></span>
<span class="codeline" id="line-1306"><code></code></span>
<span class="codeline" id="line-1307"><code>// Redirect sets 'Location: uri' response header and sets the given statusCode.</code></span>
<span class="codeline" id="line-1308"><code>//</code></span>
<span class="codeline" id="line-1309"><code>// statusCode must have one of the following values:</code></span>
<span class="codeline" id="line-1310"><code>//</code></span>
<span class="codeline" id="line-1311"><code>//   - StatusMovedPermanently (301)</code></span>
<span class="codeline" id="line-1312"><code>//   - StatusFound (302)</code></span>
<span class="codeline" id="line-1313"><code>//   - StatusSeeOther (303)</code></span>
<span class="codeline" id="line-1314"><code>//   - StatusTemporaryRedirect (307)</code></span>
<span class="codeline" id="line-1315"><code>//   - StatusPermanentRedirect (308)</code></span>
<span class="codeline" id="line-1316"><code>//</code></span>
<span class="codeline" id="line-1317"><code>// All other statusCode values are replaced by StatusFound (302).</code></span>
<span class="codeline" id="line-1318"><code>//</code></span>
<span class="codeline" id="line-1319"><code>// The redirect uri may be either absolute or relative to the current</code></span>
<span class="codeline" id="line-1320"><code>// request uri. Fasthttp will always send an absolute uri back to the client.</code></span>
<span class="codeline" id="line-1321"><code>// To send a relative uri you can use the following code:</code></span>
<span class="codeline" id="line-1322"><code>//</code></span>
<span class="codeline" id="line-1323"><code>//	strLocation = []byte("Location") // Put this with your top level var () declarations.</code></span>
<span class="codeline" id="line-1324"><code>//	ctx.Response.Header.SetCanonical(strLocation, "/relative?uri")</code></span>
<span class="codeline" id="line-1325"><code>//	ctx.Response.SetStatusCode(fasthttp.StatusMovedPermanently)</code></span>
<span class="codeline" id="line-1326"><code>func (ctx *RequestCtx) Redirect(uri string, statusCode int) {</code></span>
<span class="codeline" id="line-1327"><code>	u := AcquireURI()</code></span>
<span class="codeline" id="line-1328"><code>	ctx.URI().CopyTo(u)</code></span>
<span class="codeline" id="line-1329"><code>	u.Update(uri)</code></span>
<span class="codeline" id="line-1330"><code>	ctx.redirect(u.FullURI(), statusCode)</code></span>
<span class="codeline" id="line-1331"><code>	ReleaseURI(u)</code></span>
<span class="codeline" id="line-1332"><code>}</code></span>
<span class="codeline" id="line-1333"><code></code></span>
<span class="codeline" id="line-1334"><code>// RedirectBytes sets 'Location: uri' response header and sets</code></span>
<span class="codeline" id="line-1335"><code>// the given statusCode.</code></span>
<span class="codeline" id="line-1336"><code>//</code></span>
<span class="codeline" id="line-1337"><code>// statusCode must have one of the following values:</code></span>
<span class="codeline" id="line-1338"><code>//</code></span>
<span class="codeline" id="line-1339"><code>//   - StatusMovedPermanently (301)</code></span>
<span class="codeline" id="line-1340"><code>//   - StatusFound (302)</code></span>
<span class="codeline" id="line-1341"><code>//   - StatusSeeOther (303)</code></span>
<span class="codeline" id="line-1342"><code>//   - StatusTemporaryRedirect (307)</code></span>
<span class="codeline" id="line-1343"><code>//   - StatusPermanentRedirect (308)</code></span>
<span class="codeline" id="line-1344"><code>//</code></span>
<span class="codeline" id="line-1345"><code>// All other statusCode values are replaced by StatusFound (302).</code></span>
<span class="codeline" id="line-1346"><code>//</code></span>
<span class="codeline" id="line-1347"><code>// The redirect uri may be either absolute or relative to the current</code></span>
<span class="codeline" id="line-1348"><code>// request uri. Fasthttp will always send an absolute uri back to the client.</code></span>
<span class="codeline" id="line-1349"><code>// To send a relative uri you can use the following code:</code></span>
<span class="codeline" id="line-1350"><code>//</code></span>
<span class="codeline" id="line-1351"><code>//	strLocation = []byte("Location") // Put this with your top level var () declarations.</code></span>
<span class="codeline" id="line-1352"><code>//	ctx.Response.Header.SetCanonical(strLocation, "/relative?uri")</code></span>
<span class="codeline" id="line-1353"><code>//	ctx.Response.SetStatusCode(fasthttp.StatusMovedPermanently)</code></span>
<span class="codeline" id="line-1354"><code>func (ctx *RequestCtx) RedirectBytes(uri []byte, statusCode int) {</code></span>
<span class="codeline" id="line-1355"><code>	s := b2s(uri)</code></span>
<span class="codeline" id="line-1356"><code>	ctx.Redirect(s, statusCode)</code></span>
<span class="codeline" id="line-1357"><code>}</code></span>
<span class="codeline" id="line-1358"><code></code></span>
<span class="codeline" id="line-1359"><code>func (ctx *RequestCtx) redirect(uri []byte, statusCode int) {</code></span>
<span class="codeline" id="line-1360"><code>	ctx.Response.Header.setNonSpecial(strLocation, uri)</code></span>
<span class="codeline" id="line-1361"><code>	statusCode = getRedirectStatusCode(statusCode)</code></span>
<span class="codeline" id="line-1362"><code>	ctx.Response.SetStatusCode(statusCode)</code></span>
<span class="codeline" id="line-1363"><code>}</code></span>
<span class="codeline" id="line-1364"><code></code></span>
<span class="codeline" id="line-1365"><code>func getRedirectStatusCode(statusCode int) int {</code></span>
<span class="codeline" id="line-1366"><code>	if statusCode == StatusMovedPermanently || statusCode == StatusFound ||</code></span>
<span class="codeline" id="line-1367"><code>		statusCode == StatusSeeOther || statusCode == StatusTemporaryRedirect ||</code></span>
<span class="codeline" id="line-1368"><code>		statusCode == StatusPermanentRedirect {</code></span>
<span class="codeline" id="line-1369"><code>		return statusCode</code></span>
<span class="codeline" id="line-1370"><code>	}</code></span>
<span class="codeline" id="line-1371"><code>	return StatusFound</code></span>
<span class="codeline" id="line-1372"><code>}</code></span>
<span class="codeline" id="line-1373"><code></code></span>
<span class="codeline" id="line-1374"><code>// SetBody sets response body to the given value.</code></span>
<span class="codeline" id="line-1375"><code>//</code></span>
<span class="codeline" id="line-1376"><code>// It is safe re-using body argument after the function returns.</code></span>
<span class="codeline" id="line-1377"><code>func (ctx *RequestCtx) SetBody(body []byte) {</code></span>
<span class="codeline" id="line-1378"><code>	ctx.Response.SetBody(body)</code></span>
<span class="codeline" id="line-1379"><code>}</code></span>
<span class="codeline" id="line-1380"><code></code></span>
<span class="codeline" id="line-1381"><code>// SetBodyString sets response body to the given value.</code></span>
<span class="codeline" id="line-1382"><code>func (ctx *RequestCtx) SetBodyString(body string) {</code></span>
<span class="codeline" id="line-1383"><code>	ctx.Response.SetBodyString(body)</code></span>
<span class="codeline" id="line-1384"><code>}</code></span>
<span class="codeline" id="line-1385"><code></code></span>
<span class="codeline" id="line-1386"><code>// ResetBody resets response body contents.</code></span>
<span class="codeline" id="line-1387"><code>func (ctx *RequestCtx) ResetBody() {</code></span>
<span class="codeline" id="line-1388"><code>	ctx.Response.ResetBody()</code></span>
<span class="codeline" id="line-1389"><code>}</code></span>
<span class="codeline" id="line-1390"><code></code></span>
<span class="codeline" id="line-1391"><code>// SendFile sends local file contents from the given path as response body.</code></span>
<span class="codeline" id="line-1392"><code>//</code></span>
<span class="codeline" id="line-1393"><code>// This is a shortcut to ServeFile(ctx, path).</code></span>
<span class="codeline" id="line-1394"><code>//</code></span>
<span class="codeline" id="line-1395"><code>// SendFile logs all the errors via ctx.Logger.</code></span>
<span class="codeline" id="line-1396"><code>//</code></span>
<span class="codeline" id="line-1397"><code>// See also ServeFile, FSHandler and FS.</code></span>
<span class="codeline" id="line-1398"><code>//</code></span>
<span class="codeline" id="line-1399"><code>// WARNING: do not pass any user supplied paths to this function!</code></span>
<span class="codeline" id="line-1400"><code>// WARNING: if path is based on user input users will be able to request</code></span>
<span class="codeline" id="line-1401"><code>// any file on your filesystem! Use fasthttp.FS with a sane Root instead.</code></span>
<span class="codeline" id="line-1402"><code>func (ctx *RequestCtx) SendFile(path string) {</code></span>
<span class="codeline" id="line-1403"><code>	ServeFile(ctx, path)</code></span>
<span class="codeline" id="line-1404"><code>}</code></span>
<span class="codeline" id="line-1405"><code></code></span>
<span class="codeline" id="line-1406"><code>// SendFileBytes sends local file contents from the given path as response body.</code></span>
<span class="codeline" id="line-1407"><code>//</code></span>
<span class="codeline" id="line-1408"><code>// This is a shortcut to ServeFileBytes(ctx, path).</code></span>
<span class="codeline" id="line-1409"><code>//</code></span>
<span class="codeline" id="line-1410"><code>// SendFileBytes logs all the errors via ctx.Logger.</code></span>
<span class="codeline" id="line-1411"><code>//</code></span>
<span class="codeline" id="line-1412"><code>// See also ServeFileBytes, FSHandler and FS.</code></span>
<span class="codeline" id="line-1413"><code>//</code></span>
<span class="codeline" id="line-1414"><code>// WARNING: do not pass any user supplied paths to this function!</code></span>
<span class="codeline" id="line-1415"><code>// WARNING: if path is based on user input users will be able to request</code></span>
<span class="codeline" id="line-1416"><code>// any file on your filesystem! Use fasthttp.FS with a sane Root instead.</code></span>
<span class="codeline" id="line-1417"><code>func (ctx *RequestCtx) SendFileBytes(path []byte) {</code></span>
<span class="codeline" id="line-1418"><code>	ServeFileBytes(ctx, path)</code></span>
<span class="codeline" id="line-1419"><code>}</code></span>
<span class="codeline" id="line-1420"><code></code></span>
<span class="codeline" id="line-1421"><code>// IfModifiedSince returns true if lastModified exceeds 'If-Modified-Since'</code></span>
<span class="codeline" id="line-1422"><code>// value from the request header.</code></span>
<span class="codeline" id="line-1423"><code>//</code></span>
<span class="codeline" id="line-1424"><code>// The function returns true also 'If-Modified-Since' request header is missing.</code></span>
<span class="codeline" id="line-1425"><code>func (ctx *RequestCtx) IfModifiedSince(lastModified time.Time) bool {</code></span>
<span class="codeline" id="line-1426"><code>	ifModStr := ctx.Request.Header.peek(strIfModifiedSince)</code></span>
<span class="codeline" id="line-1427"><code>	if len(ifModStr) == 0 {</code></span>
<span class="codeline" id="line-1428"><code>		return true</code></span>
<span class="codeline" id="line-1429"><code>	}</code></span>
<span class="codeline" id="line-1430"><code>	ifMod, err := ParseHTTPDate(ifModStr)</code></span>
<span class="codeline" id="line-1431"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1432"><code>		return true</code></span>
<span class="codeline" id="line-1433"><code>	}</code></span>
<span class="codeline" id="line-1434"><code>	lastModified = lastModified.Truncate(time.Second)</code></span>
<span class="codeline" id="line-1435"><code>	return ifMod.Before(lastModified)</code></span>
<span class="codeline" id="line-1436"><code>}</code></span>
<span class="codeline" id="line-1437"><code></code></span>
<span class="codeline" id="line-1438"><code>// NotModified resets response and sets '304 Not Modified' response status code.</code></span>
<span class="codeline" id="line-1439"><code>func (ctx *RequestCtx) NotModified() {</code></span>
<span class="codeline" id="line-1440"><code>	ctx.Response.Reset()</code></span>
<span class="codeline" id="line-1441"><code>	ctx.SetStatusCode(StatusNotModified)</code></span>
<span class="codeline" id="line-1442"><code>}</code></span>
<span class="codeline" id="line-1443"><code></code></span>
<span class="codeline" id="line-1444"><code>// NotFound resets response and sets '404 Not Found' response status code.</code></span>
<span class="codeline" id="line-1445"><code>func (ctx *RequestCtx) NotFound() {</code></span>
<span class="codeline" id="line-1446"><code>	ctx.Response.Reset()</code></span>
<span class="codeline" id="line-1447"><code>	ctx.SetStatusCode(StatusNotFound)</code></span>
<span class="codeline" id="line-1448"><code>	ctx.SetBodyString("404 Page not found")</code></span>
<span class="codeline" id="line-1449"><code>}</code></span>
<span class="codeline" id="line-1450"><code></code></span>
<span class="codeline" id="line-1451"><code>// Write writes p into response body.</code></span>
<span class="codeline" id="line-1452"><code>func (ctx *RequestCtx) Write(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-1453"><code>	ctx.Response.AppendBody(p)</code></span>
<span class="codeline" id="line-1454"><code>	return len(p), nil</code></span>
<span class="codeline" id="line-1455"><code>}</code></span>
<span class="codeline" id="line-1456"><code></code></span>
<span class="codeline" id="line-1457"><code>// WriteString appends s to response body.</code></span>
<span class="codeline" id="line-1458"><code>func (ctx *RequestCtx) WriteString(s string) (int, error) {</code></span>
<span class="codeline" id="line-1459"><code>	ctx.Response.AppendBodyString(s)</code></span>
<span class="codeline" id="line-1460"><code>	return len(s), nil</code></span>
<span class="codeline" id="line-1461"><code>}</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>// PostBody returns POST request body.</code></span>
<span class="codeline" id="line-1464"><code>//</code></span>
<span class="codeline" id="line-1465"><code>// The returned bytes are valid until your request handler returns.</code></span>
<span class="codeline" id="line-1466"><code>func (ctx *RequestCtx) PostBody() []byte {</code></span>
<span class="codeline" id="line-1467"><code>	return ctx.Request.Body()</code></span>
<span class="codeline" id="line-1468"><code>}</code></span>
<span class="codeline" id="line-1469"><code></code></span>
<span class="codeline" id="line-1470"><code>// SetBodyStream sets response body stream and, optionally body size.</code></span>
<span class="codeline" id="line-1471"><code>//</code></span>
<span class="codeline" id="line-1472"><code>// bodyStream.Close() is called after finishing reading all body data</code></span>
<span class="codeline" id="line-1473"><code>// if it implements io.Closer.</code></span>
<span class="codeline" id="line-1474"><code>//</code></span>
<span class="codeline" id="line-1475"><code>// If bodySize is &gt;= 0, then bodySize bytes must be provided by bodyStream</code></span>
<span class="codeline" id="line-1476"><code>// before returning io.EOF.</code></span>
<span class="codeline" id="line-1477"><code>//</code></span>
<span class="codeline" id="line-1478"><code>// If bodySize &lt; 0, then bodyStream is read until io.EOF.</code></span>
<span class="codeline" id="line-1479"><code>//</code></span>
<span class="codeline" id="line-1480"><code>// See also SetBodyStreamWriter.</code></span>
<span class="codeline" id="line-1481"><code>func (ctx *RequestCtx) SetBodyStream(bodyStream io.Reader, bodySize int) {</code></span>
<span class="codeline" id="line-1482"><code>	ctx.Response.SetBodyStream(bodyStream, bodySize)</code></span>
<span class="codeline" id="line-1483"><code>}</code></span>
<span class="codeline" id="line-1484"><code></code></span>
<span class="codeline" id="line-1485"><code>// SetBodyStreamWriter registers the given stream writer for populating</code></span>
<span class="codeline" id="line-1486"><code>// response body.</code></span>
<span class="codeline" id="line-1487"><code>//</code></span>
<span class="codeline" id="line-1488"><code>// Access to RequestCtx and/or its members is forbidden from sw.</code></span>
<span class="codeline" id="line-1489"><code>//</code></span>
<span class="codeline" id="line-1490"><code>// This function may be used in the following cases:</code></span>
<span class="codeline" id="line-1491"><code>//</code></span>
<span class="codeline" id="line-1492"><code>//   - if response body is too big (more than 10MB).</code></span>
<span class="codeline" id="line-1493"><code>//   - if response body is streamed from slow external sources.</code></span>
<span class="codeline" id="line-1494"><code>//   - if response body must be streamed to the client in chunks.</code></span>
<span class="codeline" id="line-1495"><code>//     (aka `http server push`).</code></span>
<span class="codeline" id="line-1496"><code>func (ctx *RequestCtx) SetBodyStreamWriter(sw StreamWriter) {</code></span>
<span class="codeline" id="line-1497"><code>	ctx.Response.SetBodyStreamWriter(sw)</code></span>
<span class="codeline" id="line-1498"><code>}</code></span>
<span class="codeline" id="line-1499"><code></code></span>
<span class="codeline" id="line-1500"><code>// IsBodyStream returns true if response body is set via SetBodyStream*.</code></span>
<span class="codeline" id="line-1501"><code>func (ctx *RequestCtx) IsBodyStream() bool {</code></span>
<span class="codeline" id="line-1502"><code>	return ctx.Response.IsBodyStream()</code></span>
<span class="codeline" id="line-1503"><code>}</code></span>
<span class="codeline" id="line-1504"><code></code></span>
<span class="codeline" id="line-1505"><code>// Logger returns logger, which may be used for logging arbitrary</code></span>
<span class="codeline" id="line-1506"><code>// request-specific messages inside RequestHandler.</code></span>
<span class="codeline" id="line-1507"><code>//</code></span>
<span class="codeline" id="line-1508"><code>// Each message logged via returned logger contains request-specific information</code></span>
<span class="codeline" id="line-1509"><code>// such as request id, request duration, local address, remote address,</code></span>
<span class="codeline" id="line-1510"><code>// request method and request url.</code></span>
<span class="codeline" id="line-1511"><code>//</code></span>
<span class="codeline" id="line-1512"><code>// It is safe re-using returned logger for logging multiple messages</code></span>
<span class="codeline" id="line-1513"><code>// for the current request.</code></span>
<span class="codeline" id="line-1514"><code>//</code></span>
<span class="codeline" id="line-1515"><code>// The returned logger is valid until your request handler returns.</code></span>
<span class="codeline" id="line-1516"><code>func (ctx *RequestCtx) Logger() Logger {</code></span>
<span class="codeline" id="line-1517"><code>	if ctx.logger.ctx == nil {</code></span>
<span class="codeline" id="line-1518"><code>		ctx.logger.ctx = ctx</code></span>
<span class="codeline" id="line-1519"><code>	}</code></span>
<span class="codeline" id="line-1520"><code>	if ctx.logger.logger == nil {</code></span>
<span class="codeline" id="line-1521"><code>		ctx.logger.logger = ctx.s.logger()</code></span>
<span class="codeline" id="line-1522"><code>	}</code></span>
<span class="codeline" id="line-1523"><code>	return &amp;ctx.logger</code></span>
<span class="codeline" id="line-1524"><code>}</code></span>
<span class="codeline" id="line-1525"><code></code></span>
<span class="codeline" id="line-1526"><code>// TimeoutError sets response status code to StatusRequestTimeout and sets</code></span>
<span class="codeline" id="line-1527"><code>// body to the given msg.</code></span>
<span class="codeline" id="line-1528"><code>//</code></span>
<span class="codeline" id="line-1529"><code>// All response modifications after TimeoutError call are ignored.</code></span>
<span class="codeline" id="line-1530"><code>//</code></span>
<span class="codeline" id="line-1531"><code>// TimeoutError MUST be called before returning from RequestHandler if there are</code></span>
<span class="codeline" id="line-1532"><code>// references to ctx and/or its members in other goroutines remain.</code></span>
<span class="codeline" id="line-1533"><code>//</code></span>
<span class="codeline" id="line-1534"><code>// Usage of this function is discouraged. Prefer eliminating ctx references</code></span>
<span class="codeline" id="line-1535"><code>// from pending goroutines instead of using this function.</code></span>
<span class="codeline" id="line-1536"><code>func (ctx *RequestCtx) TimeoutError(msg string) {</code></span>
<span class="codeline" id="line-1537"><code>	ctx.TimeoutErrorWithCode(msg, StatusRequestTimeout)</code></span>
<span class="codeline" id="line-1538"><code>}</code></span>
<span class="codeline" id="line-1539"><code></code></span>
<span class="codeline" id="line-1540"><code>// TimeoutErrorWithCode sets response body to msg and response status</code></span>
<span class="codeline" id="line-1541"><code>// code to statusCode.</code></span>
<span class="codeline" id="line-1542"><code>//</code></span>
<span class="codeline" id="line-1543"><code>// All response modifications after TimeoutErrorWithCode call are ignored.</code></span>
<span class="codeline" id="line-1544"><code>//</code></span>
<span class="codeline" id="line-1545"><code>// TimeoutErrorWithCode MUST be called before returning from RequestHandler</code></span>
<span class="codeline" id="line-1546"><code>// if there are references to ctx and/or its members in other goroutines remain.</code></span>
<span class="codeline" id="line-1547"><code>//</code></span>
<span class="codeline" id="line-1548"><code>// Usage of this function is discouraged. Prefer eliminating ctx references</code></span>
<span class="codeline" id="line-1549"><code>// from pending goroutines instead of using this function.</code></span>
<span class="codeline" id="line-1550"><code>func (ctx *RequestCtx) TimeoutErrorWithCode(msg string, statusCode int) {</code></span>
<span class="codeline" id="line-1551"><code>	var resp Response</code></span>
<span class="codeline" id="line-1552"><code>	resp.SetStatusCode(statusCode)</code></span>
<span class="codeline" id="line-1553"><code>	resp.SetBodyString(msg)</code></span>
<span class="codeline" id="line-1554"><code>	ctx.TimeoutErrorWithResponse(&amp;resp)</code></span>
<span class="codeline" id="line-1555"><code>}</code></span>
<span class="codeline" id="line-1556"><code></code></span>
<span class="codeline" id="line-1557"><code>// TimeoutErrorWithResponse marks the ctx as timed out and sends the given</code></span>
<span class="codeline" id="line-1558"><code>// response to the client.</code></span>
<span class="codeline" id="line-1559"><code>//</code></span>
<span class="codeline" id="line-1560"><code>// All ctx modifications after TimeoutErrorWithResponse call are ignored.</code></span>
<span class="codeline" id="line-1561"><code>//</code></span>
<span class="codeline" id="line-1562"><code>// TimeoutErrorWithResponse MUST be called before returning from RequestHandler</code></span>
<span class="codeline" id="line-1563"><code>// if there are references to ctx and/or its members in other goroutines remain.</code></span>
<span class="codeline" id="line-1564"><code>//</code></span>
<span class="codeline" id="line-1565"><code>// Usage of this function is discouraged. Prefer eliminating ctx references</code></span>
<span class="codeline" id="line-1566"><code>// from pending goroutines instead of using this function.</code></span>
<span class="codeline" id="line-1567"><code>func (ctx *RequestCtx) TimeoutErrorWithResponse(resp *Response) {</code></span>
<span class="codeline" id="line-1568"><code>	respCopy := &amp;Response{}</code></span>
<span class="codeline" id="line-1569"><code>	resp.CopyTo(respCopy)</code></span>
<span class="codeline" id="line-1570"><code>	ctx.timeoutResponse = respCopy</code></span>
<span class="codeline" id="line-1571"><code>}</code></span>
<span class="codeline" id="line-1572"><code></code></span>
<span class="codeline" id="line-1573"><code>// NextProto adds nph to be processed when key is negotiated when TLS</code></span>
<span class="codeline" id="line-1574"><code>// connection is established.</code></span>
<span class="codeline" id="line-1575"><code>//</code></span>
<span class="codeline" id="line-1576"><code>// This function can only be called before the server is started.</code></span>
<span class="codeline" id="line-1577"><code>func (s *Server) NextProto(key string, nph ServeHandler) {</code></span>
<span class="codeline" id="line-1578"><code>	if s.nextProtos == nil {</code></span>
<span class="codeline" id="line-1579"><code>		s.nextProtos = make(map[string]ServeHandler)</code></span>
<span class="codeline" id="line-1580"><code>	}</code></span>
<span class="codeline" id="line-1581"><code></code></span>
<span class="codeline" id="line-1582"><code>	s.configTLS()</code></span>
<span class="codeline" id="line-1583"><code>	s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, key)</code></span>
<span class="codeline" id="line-1584"><code>	s.nextProtos[key] = nph</code></span>
<span class="codeline" id="line-1585"><code>}</code></span>
<span class="codeline" id="line-1586"><code></code></span>
<span class="codeline" id="line-1587"><code>func (s *Server) getNextProto(c net.Conn) (proto string, err error) {</code></span>
<span class="codeline" id="line-1588"><code>	if tlsConn, ok := c.(connTLSer); ok {</code></span>
<span class="codeline" id="line-1589"><code>		if s.ReadTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-1590"><code>			if err := c.SetReadDeadline(time.Now().Add(s.ReadTimeout)); err != nil {</code></span>
<span class="codeline" id="line-1591"><code>				panic(fmt.Sprintf("BUG: error in SetReadDeadline(%v): %v", s.ReadTimeout, err))</code></span>
<span class="codeline" id="line-1592"><code>			}</code></span>
<span class="codeline" id="line-1593"><code>		}</code></span>
<span class="codeline" id="line-1594"><code></code></span>
<span class="codeline" id="line-1595"><code>		if s.WriteTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-1596"><code>			if err := c.SetWriteDeadline(time.Now().Add(s.WriteTimeout)); err != nil {</code></span>
<span class="codeline" id="line-1597"><code>				panic(fmt.Sprintf("BUG: error in SetWriteDeadline(%v): %v", s.WriteTimeout, err))</code></span>
<span class="codeline" id="line-1598"><code>			}</code></span>
<span class="codeline" id="line-1599"><code>		}</code></span>
<span class="codeline" id="line-1600"><code></code></span>
<span class="codeline" id="line-1601"><code>		err = tlsConn.Handshake()</code></span>
<span class="codeline" id="line-1602"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1603"><code>			proto = tlsConn.ConnectionState().NegotiatedProtocol</code></span>
<span class="codeline" id="line-1604"><code>		}</code></span>
<span class="codeline" id="line-1605"><code>	}</code></span>
<span class="codeline" id="line-1606"><code>	return</code></span>
<span class="codeline" id="line-1607"><code>}</code></span>
<span class="codeline" id="line-1608"><code></code></span>
<span class="codeline" id="line-1609"><code>// ListenAndServe serves HTTP requests from the given TCP4 addr.</code></span>
<span class="codeline" id="line-1610"><code>//</code></span>
<span class="codeline" id="line-1611"><code>// Pass custom listener to Serve if you need listening on non-TCP4 media</code></span>
<span class="codeline" id="line-1612"><code>// such as IPv6.</code></span>
<span class="codeline" id="line-1613"><code>//</code></span>
<span class="codeline" id="line-1614"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-1615"><code>func (s *Server) ListenAndServe(addr string) error {</code></span>
<span class="codeline" id="line-1616"><code>	ln, err := net.Listen("tcp4", addr)</code></span>
<span class="codeline" id="line-1617"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1618"><code>		return err</code></span>
<span class="codeline" id="line-1619"><code>	}</code></span>
<span class="codeline" id="line-1620"><code>	return s.Serve(ln)</code></span>
<span class="codeline" id="line-1621"><code>}</code></span>
<span class="codeline" id="line-1622"><code></code></span>
<span class="codeline" id="line-1623"><code>// ListenAndServeUNIX serves HTTP requests from the given UNIX addr.</code></span>
<span class="codeline" id="line-1624"><code>//</code></span>
<span class="codeline" id="line-1625"><code>// The function deletes existing file at addr before starting serving.</code></span>
<span class="codeline" id="line-1626"><code>//</code></span>
<span class="codeline" id="line-1627"><code>// The server sets the given file mode for the UNIX addr.</code></span>
<span class="codeline" id="line-1628"><code>func (s *Server) ListenAndServeUNIX(addr string, mode os.FileMode) error {</code></span>
<span class="codeline" id="line-1629"><code>	if err := os.Remove(addr); err != nil &amp;&amp; !os.IsNotExist(err) {</code></span>
<span class="codeline" id="line-1630"><code>		return fmt.Errorf("unexpected error when trying to remove unix socket file %q: %w", addr, err)</code></span>
<span class="codeline" id="line-1631"><code>	}</code></span>
<span class="codeline" id="line-1632"><code>	ln, err := net.Listen("unix", addr)</code></span>
<span class="codeline" id="line-1633"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1634"><code>		return err</code></span>
<span class="codeline" id="line-1635"><code>	}</code></span>
<span class="codeline" id="line-1636"><code>	if err = os.Chmod(addr, mode); err != nil {</code></span>
<span class="codeline" id="line-1637"><code>		return fmt.Errorf("cannot chmod %#o for %q: %w", mode, addr, err)</code></span>
<span class="codeline" id="line-1638"><code>	}</code></span>
<span class="codeline" id="line-1639"><code>	return s.Serve(ln)</code></span>
<span class="codeline" id="line-1640"><code>}</code></span>
<span class="codeline" id="line-1641"><code></code></span>
<span class="codeline" id="line-1642"><code>// ListenAndServeTLS serves HTTPS requests from the given TCP4 addr.</code></span>
<span class="codeline" id="line-1643"><code>//</code></span>
<span class="codeline" id="line-1644"><code>// certFile and keyFile are paths to TLS certificate and key files.</code></span>
<span class="codeline" id="line-1645"><code>//</code></span>
<span class="codeline" id="line-1646"><code>// Pass custom listener to Serve if you need listening on non-TCP4 media</code></span>
<span class="codeline" id="line-1647"><code>// such as IPv6.</code></span>
<span class="codeline" id="line-1648"><code>//</code></span>
<span class="codeline" id="line-1649"><code>// If the certFile or keyFile has not been provided to the server structure,</code></span>
<span class="codeline" id="line-1650"><code>// the function will use the previously added TLS configuration.</code></span>
<span class="codeline" id="line-1651"><code>//</code></span>
<span class="codeline" id="line-1652"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-1653"><code>func (s *Server) ListenAndServeTLS(addr, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-1654"><code>	ln, err := net.Listen("tcp4", addr)</code></span>
<span class="codeline" id="line-1655"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1656"><code>		return err</code></span>
<span class="codeline" id="line-1657"><code>	}</code></span>
<span class="codeline" id="line-1658"><code>	return s.ServeTLS(ln, certFile, keyFile)</code></span>
<span class="codeline" id="line-1659"><code>}</code></span>
<span class="codeline" id="line-1660"><code></code></span>
<span class="codeline" id="line-1661"><code>// ListenAndServeTLSEmbed serves HTTPS requests from the given TCP4 addr.</code></span>
<span class="codeline" id="line-1662"><code>//</code></span>
<span class="codeline" id="line-1663"><code>// certData and keyData must contain valid TLS certificate and key data.</code></span>
<span class="codeline" id="line-1664"><code>//</code></span>
<span class="codeline" id="line-1665"><code>// Pass custom listener to Serve if you need listening on arbitrary media</code></span>
<span class="codeline" id="line-1666"><code>// such as IPv6.</code></span>
<span class="codeline" id="line-1667"><code>//</code></span>
<span class="codeline" id="line-1668"><code>// If the certFile or keyFile has not been provided the server structure,</code></span>
<span class="codeline" id="line-1669"><code>// the function will use previously added TLS configuration.</code></span>
<span class="codeline" id="line-1670"><code>//</code></span>
<span class="codeline" id="line-1671"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-1672"><code>func (s *Server) ListenAndServeTLSEmbed(addr string, certData, keyData []byte) error {</code></span>
<span class="codeline" id="line-1673"><code>	ln, err := net.Listen("tcp4", addr)</code></span>
<span class="codeline" id="line-1674"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1675"><code>		return err</code></span>
<span class="codeline" id="line-1676"><code>	}</code></span>
<span class="codeline" id="line-1677"><code>	return s.ServeTLSEmbed(ln, certData, keyData)</code></span>
<span class="codeline" id="line-1678"><code>}</code></span>
<span class="codeline" id="line-1679"><code></code></span>
<span class="codeline" id="line-1680"><code>// ServeTLS serves HTTPS requests from the given listener.</code></span>
<span class="codeline" id="line-1681"><code>//</code></span>
<span class="codeline" id="line-1682"><code>// certFile and keyFile are paths to TLS certificate and key files.</code></span>
<span class="codeline" id="line-1683"><code>//</code></span>
<span class="codeline" id="line-1684"><code>// If the certFile or keyFile has not been provided the server structure,</code></span>
<span class="codeline" id="line-1685"><code>// the function will use previously added TLS configuration.</code></span>
<span class="codeline" id="line-1686"><code>func (s *Server) ServeTLS(ln net.Listener, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-1687"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-1688"><code>	s.configTLS()</code></span>
<span class="codeline" id="line-1689"><code>	configHasCert := len(s.TLSConfig.Certificates) &gt; 0 || s.TLSConfig.GetCertificate != nil</code></span>
<span class="codeline" id="line-1690"><code>	if !configHasCert || certFile != "" || keyFile != "" {</code></span>
<span class="codeline" id="line-1691"><code>		if err := s.AppendCert(certFile, keyFile); err != nil {</code></span>
<span class="codeline" id="line-1692"><code>			s.mu.Unlock()</code></span>
<span class="codeline" id="line-1693"><code>			return err</code></span>
<span class="codeline" id="line-1694"><code>		}</code></span>
<span class="codeline" id="line-1695"><code>	}</code></span>
<span class="codeline" id="line-1696"><code></code></span>
<span class="codeline" id="line-1697"><code>	// BuildNameToCertificate has been deprecated since 1.14.</code></span>
<span class="codeline" id="line-1698"><code>	// But since we also support older versions we'll keep this here.</code></span>
<span class="codeline" id="line-1699"><code>	s.TLSConfig.BuildNameToCertificate() //nolint:staticcheck</code></span>
<span class="codeline" id="line-1700"><code></code></span>
<span class="codeline" id="line-1701"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-1702"><code></code></span>
<span class="codeline" id="line-1703"><code>	return s.Serve(</code></span>
<span class="codeline" id="line-1704"><code>		tls.NewListener(ln, s.TLSConfig.Clone()),</code></span>
<span class="codeline" id="line-1705"><code>	)</code></span>
<span class="codeline" id="line-1706"><code>}</code></span>
<span class="codeline" id="line-1707"><code></code></span>
<span class="codeline" id="line-1708"><code>// ServeTLSEmbed serves HTTPS requests from the given listener.</code></span>
<span class="codeline" id="line-1709"><code>//</code></span>
<span class="codeline" id="line-1710"><code>// certData and keyData must contain valid TLS certificate and key data.</code></span>
<span class="codeline" id="line-1711"><code>//</code></span>
<span class="codeline" id="line-1712"><code>// If the certFile or keyFile has not been provided the server structure,</code></span>
<span class="codeline" id="line-1713"><code>// the function will use previously added TLS configuration.</code></span>
<span class="codeline" id="line-1714"><code>func (s *Server) ServeTLSEmbed(ln net.Listener, certData, keyData []byte) error {</code></span>
<span class="codeline" id="line-1715"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-1716"><code>	s.configTLS()</code></span>
<span class="codeline" id="line-1717"><code>	configHasCert := len(s.TLSConfig.Certificates) &gt; 0 || s.TLSConfig.GetCertificate != nil</code></span>
<span class="codeline" id="line-1718"><code>	if !configHasCert || len(certData) != 0 || len(keyData) != 0 {</code></span>
<span class="codeline" id="line-1719"><code>		if err := s.AppendCertEmbed(certData, keyData); err != nil {</code></span>
<span class="codeline" id="line-1720"><code>			s.mu.Unlock()</code></span>
<span class="codeline" id="line-1721"><code>			return err</code></span>
<span class="codeline" id="line-1722"><code>		}</code></span>
<span class="codeline" id="line-1723"><code>	}</code></span>
<span class="codeline" id="line-1724"><code></code></span>
<span class="codeline" id="line-1725"><code>	// BuildNameToCertificate has been deprecated since 1.14.</code></span>
<span class="codeline" id="line-1726"><code>	// But since we also support older versions we'll keep this here.</code></span>
<span class="codeline" id="line-1727"><code>	s.TLSConfig.BuildNameToCertificate() //nolint:staticcheck</code></span>
<span class="codeline" id="line-1728"><code></code></span>
<span class="codeline" id="line-1729"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-1730"><code></code></span>
<span class="codeline" id="line-1731"><code>	return s.Serve(</code></span>
<span class="codeline" id="line-1732"><code>		tls.NewListener(ln, s.TLSConfig.Clone()),</code></span>
<span class="codeline" id="line-1733"><code>	)</code></span>
<span class="codeline" id="line-1734"><code>}</code></span>
<span class="codeline" id="line-1735"><code></code></span>
<span class="codeline" id="line-1736"><code>// AppendCert appends certificate and keyfile to TLS Configuration.</code></span>
<span class="codeline" id="line-1737"><code>//</code></span>
<span class="codeline" id="line-1738"><code>// This function allows programmer to handle multiple domains</code></span>
<span class="codeline" id="line-1739"><code>// in one server structure. See examples/multidomain.</code></span>
<span class="codeline" id="line-1740"><code>func (s *Server) AppendCert(certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-1741"><code>	if certFile == "" &amp;&amp; keyFile == "" {</code></span>
<span class="codeline" id="line-1742"><code>		return errNoCertOrKeyProvided</code></span>
<span class="codeline" id="line-1743"><code>	}</code></span>
<span class="codeline" id="line-1744"><code></code></span>
<span class="codeline" id="line-1745"><code>	cert, err := tls.LoadX509KeyPair(certFile, keyFile)</code></span>
<span class="codeline" id="line-1746"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1747"><code>		return fmt.Errorf("cannot load TLS key pair from certFile=%q and keyFile=%q: %w", certFile, keyFile, err)</code></span>
<span class="codeline" id="line-1748"><code>	}</code></span>
<span class="codeline" id="line-1749"><code></code></span>
<span class="codeline" id="line-1750"><code>	s.configTLS()</code></span>
<span class="codeline" id="line-1751"><code>	s.TLSConfig.Certificates = append(s.TLSConfig.Certificates, cert)</code></span>
<span class="codeline" id="line-1752"><code></code></span>
<span class="codeline" id="line-1753"><code>	return nil</code></span>
<span class="codeline" id="line-1754"><code>}</code></span>
<span class="codeline" id="line-1755"><code></code></span>
<span class="codeline" id="line-1756"><code>// AppendCertEmbed does the same as AppendCert but using in-memory data.</code></span>
<span class="codeline" id="line-1757"><code>func (s *Server) AppendCertEmbed(certData, keyData []byte) error {</code></span>
<span class="codeline" id="line-1758"><code>	if len(certData) == 0 &amp;&amp; len(keyData) == 0 {</code></span>
<span class="codeline" id="line-1759"><code>		return errNoCertOrKeyProvided</code></span>
<span class="codeline" id="line-1760"><code>	}</code></span>
<span class="codeline" id="line-1761"><code></code></span>
<span class="codeline" id="line-1762"><code>	cert, err := tls.X509KeyPair(certData, keyData)</code></span>
<span class="codeline" id="line-1763"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1764"><code>		return fmt.Errorf("cannot load TLS key pair from the provided certData(%d) and keyData(%d): %w",</code></span>
<span class="codeline" id="line-1765"><code>			len(certData), len(keyData), err)</code></span>
<span class="codeline" id="line-1766"><code>	}</code></span>
<span class="codeline" id="line-1767"><code></code></span>
<span class="codeline" id="line-1768"><code>	s.configTLS()</code></span>
<span class="codeline" id="line-1769"><code>	s.TLSConfig.Certificates = append(s.TLSConfig.Certificates, cert)</code></span>
<span class="codeline" id="line-1770"><code></code></span>
<span class="codeline" id="line-1771"><code>	return nil</code></span>
<span class="codeline" id="line-1772"><code>}</code></span>
<span class="codeline" id="line-1773"><code></code></span>
<span class="codeline" id="line-1774"><code>func (s *Server) configTLS() {</code></span>
<span class="codeline" id="line-1775"><code>	if s.TLSConfig == nil {</code></span>
<span class="codeline" id="line-1776"><code>		s.TLSConfig = &amp;tls.Config{}</code></span>
<span class="codeline" id="line-1777"><code>	}</code></span>
<span class="codeline" id="line-1778"><code>}</code></span>
<span class="codeline" id="line-1779"><code></code></span>
<span class="codeline" id="line-1780"><code>// DefaultConcurrency is the maximum number of concurrent connections</code></span>
<span class="codeline" id="line-1781"><code>// the Server may serve by default (i.e. if Server.Concurrency isn't set).</code></span>
<span class="codeline" id="line-1782"><code>const DefaultConcurrency = 256 * 1024</code></span>
<span class="codeline" id="line-1783"><code></code></span>
<span class="codeline" id="line-1784"><code>// Serve serves incoming connections from the given listener.</code></span>
<span class="codeline" id="line-1785"><code>//</code></span>
<span class="codeline" id="line-1786"><code>// Serve blocks until the given listener returns permanent error.</code></span>
<span class="codeline" id="line-1787"><code>func (s *Server) Serve(ln net.Listener) error {</code></span>
<span class="codeline" id="line-1788"><code>	var lastOverflowErrorTime time.Time</code></span>
<span class="codeline" id="line-1789"><code>	var lastPerIPErrorTime time.Time</code></span>
<span class="codeline" id="line-1790"><code></code></span>
<span class="codeline" id="line-1791"><code>	maxWorkersCount := s.getConcurrency()</code></span>
<span class="codeline" id="line-1792"><code></code></span>
<span class="codeline" id="line-1793"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-1794"><code>	s.ln = append(s.ln, ln)</code></span>
<span class="codeline" id="line-1795"><code>	if s.done == nil {</code></span>
<span class="codeline" id="line-1796"><code>		s.done = make(chan struct{})</code></span>
<span class="codeline" id="line-1797"><code>	}</code></span>
<span class="codeline" id="line-1798"><code>	if s.concurrencyCh == nil {</code></span>
<span class="codeline" id="line-1799"><code>		s.concurrencyCh = make(chan struct{}, maxWorkersCount)</code></span>
<span class="codeline" id="line-1800"><code>	}</code></span>
<span class="codeline" id="line-1801"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-1802"><code></code></span>
<span class="codeline" id="line-1803"><code>	wp := &amp;workerPool{</code></span>
<span class="codeline" id="line-1804"><code>		WorkerFunc:            s.serveConn,</code></span>
<span class="codeline" id="line-1805"><code>		MaxWorkersCount:       maxWorkersCount,</code></span>
<span class="codeline" id="line-1806"><code>		LogAllErrors:          s.LogAllErrors,</code></span>
<span class="codeline" id="line-1807"><code>		MaxIdleWorkerDuration: s.MaxIdleWorkerDuration,</code></span>
<span class="codeline" id="line-1808"><code>		Logger:                s.logger(),</code></span>
<span class="codeline" id="line-1809"><code>		connState:             s.setState,</code></span>
<span class="codeline" id="line-1810"><code>	}</code></span>
<span class="codeline" id="line-1811"><code>	wp.Start()</code></span>
<span class="codeline" id="line-1812"><code></code></span>
<span class="codeline" id="line-1813"><code>	// Count our waiting to accept a connection as an open connection.</code></span>
<span class="codeline" id="line-1814"><code>	// This way we can't get into any weird state where just after accepting</code></span>
<span class="codeline" id="line-1815"><code>	// a connection Shutdown is called which reads open as 0 because it isn't</code></span>
<span class="codeline" id="line-1816"><code>	// incremented yet.</code></span>
<span class="codeline" id="line-1817"><code>	atomic.AddInt32(&amp;s.open, 1)</code></span>
<span class="codeline" id="line-1818"><code>	defer atomic.AddInt32(&amp;s.open, -1)</code></span>
<span class="codeline" id="line-1819"><code></code></span>
<span class="codeline" id="line-1820"><code>	for {</code></span>
<span class="codeline" id="line-1821"><code>		c, err := acceptConn(s, ln, &amp;lastPerIPErrorTime)</code></span>
<span class="codeline" id="line-1822"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1823"><code>			wp.Stop()</code></span>
<span class="codeline" id="line-1824"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-1825"><code>				return nil</code></span>
<span class="codeline" id="line-1826"><code>			}</code></span>
<span class="codeline" id="line-1827"><code>			return err</code></span>
<span class="codeline" id="line-1828"><code>		}</code></span>
<span class="codeline" id="line-1829"><code>		s.setState(c, StateNew)</code></span>
<span class="codeline" id="line-1830"><code>		atomic.AddInt32(&amp;s.open, 1)</code></span>
<span class="codeline" id="line-1831"><code>		if !wp.Serve(c) {</code></span>
<span class="codeline" id="line-1832"><code>			atomic.AddInt32(&amp;s.open, -1)</code></span>
<span class="codeline" id="line-1833"><code>			atomic.AddUint32(&amp;s.rejectedRequestsCount, 1)</code></span>
<span class="codeline" id="line-1834"><code>			s.writeFastError(c, StatusServiceUnavailable,</code></span>
<span class="codeline" id="line-1835"><code>				"The connection cannot be served because Server.Concurrency limit exceeded")</code></span>
<span class="codeline" id="line-1836"><code>			c.Close()</code></span>
<span class="codeline" id="line-1837"><code>			s.setState(c, StateClosed)</code></span>
<span class="codeline" id="line-1838"><code>			if time.Since(lastOverflowErrorTime) &gt; time.Minute {</code></span>
<span class="codeline" id="line-1839"><code>				s.logger().Printf("The incoming connection cannot be served, because %d concurrent connections are served. "+</code></span>
<span class="codeline" id="line-1840"><code>					"Try increasing Server.Concurrency", maxWorkersCount)</code></span>
<span class="codeline" id="line-1841"><code>				lastOverflowErrorTime = time.Now()</code></span>
<span class="codeline" id="line-1842"><code>			}</code></span>
<span class="codeline" id="line-1843"><code></code></span>
<span class="codeline" id="line-1844"><code>			// The current server reached concurrency limit,</code></span>
<span class="codeline" id="line-1845"><code>			// so give other concurrently running servers a chance</code></span>
<span class="codeline" id="line-1846"><code>			// accepting incoming connections on the same address.</code></span>
<span class="codeline" id="line-1847"><code>			//</code></span>
<span class="codeline" id="line-1848"><code>			// There is a hope other servers didn't reach their</code></span>
<span class="codeline" id="line-1849"><code>			// concurrency limits yet :)</code></span>
<span class="codeline" id="line-1850"><code>			//</code></span>
<span class="codeline" id="line-1851"><code>			// See also: https://github.com/valyala/fasthttp/pull/485#discussion_r239994990</code></span>
<span class="codeline" id="line-1852"><code>			if s.SleepWhenConcurrencyLimitsExceeded &gt; 0 {</code></span>
<span class="codeline" id="line-1853"><code>				time.Sleep(s.SleepWhenConcurrencyLimitsExceeded)</code></span>
<span class="codeline" id="line-1854"><code>			}</code></span>
<span class="codeline" id="line-1855"><code>		}</code></span>
<span class="codeline" id="line-1856"><code>	}</code></span>
<span class="codeline" id="line-1857"><code>}</code></span>
<span class="codeline" id="line-1858"><code></code></span>
<span class="codeline" id="line-1859"><code>// Shutdown gracefully shuts down the server without interrupting any active connections.</code></span>
<span class="codeline" id="line-1860"><code>// Shutdown works by first closing all open listeners and then waiting indefinitely for all connections</code></span>
<span class="codeline" id="line-1861"><code>// to return to idle and then shut down.</code></span>
<span class="codeline" id="line-1862"><code>//</code></span>
<span class="codeline" id="line-1863"><code>// When Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return nil.</code></span>
<span class="codeline" id="line-1864"><code>// Make sure the program doesn't exit and waits instead for Shutdown to return.</code></span>
<span class="codeline" id="line-1865"><code>//</code></span>
<span class="codeline" id="line-1866"><code>// Shutdown does not close keepalive connections so it's recommended to set ReadTimeout and IdleTimeout to something else than 0.</code></span>
<span class="codeline" id="line-1867"><code>func (s *Server) Shutdown() error {</code></span>
<span class="codeline" id="line-1868"><code>	return s.ShutdownWithContext(context.Background())</code></span>
<span class="codeline" id="line-1869"><code>}</code></span>
<span class="codeline" id="line-1870"><code></code></span>
<span class="codeline" id="line-1871"><code>// ShutdownWithContext gracefully shuts down the server without interrupting any active connections.</code></span>
<span class="codeline" id="line-1872"><code>// ShutdownWithContext works by first closing all open listeners and then waiting for all connections to return to idle</code></span>
<span class="codeline" id="line-1873"><code>// or context timeout and then shut down.</code></span>
<span class="codeline" id="line-1874"><code>//</code></span>
<span class="codeline" id="line-1875"><code>// When ShutdownWithContext is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return nil.</code></span>
<span class="codeline" id="line-1876"><code>// Make sure the program doesn't exit and waits instead for Shutdown to return.</code></span>
<span class="codeline" id="line-1877"><code>//</code></span>
<span class="codeline" id="line-1878"><code>// ShutdownWithContext does not close keepalive connections so it's recommended to set ReadTimeout and IdleTimeout</code></span>
<span class="codeline" id="line-1879"><code>// to something else than 0.</code></span>
<span class="codeline" id="line-1880"><code>func (s *Server) ShutdownWithContext(ctx context.Context) (err error) {</code></span>
<span class="codeline" id="line-1881"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-1882"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-1883"><code></code></span>
<span class="codeline" id="line-1884"><code>	atomic.StoreInt32(&amp;s.stop, 1)</code></span>
<span class="codeline" id="line-1885"><code>	defer atomic.StoreInt32(&amp;s.stop, 0)</code></span>
<span class="codeline" id="line-1886"><code></code></span>
<span class="codeline" id="line-1887"><code>	if s.ln == nil {</code></span>
<span class="codeline" id="line-1888"><code>		return nil</code></span>
<span class="codeline" id="line-1889"><code>	}</code></span>
<span class="codeline" id="line-1890"><code></code></span>
<span class="codeline" id="line-1891"><code>	for _, ln := range s.ln {</code></span>
<span class="codeline" id="line-1892"><code>		if err = ln.Close(); err != nil {</code></span>
<span class="codeline" id="line-1893"><code>			return err</code></span>
<span class="codeline" id="line-1894"><code>		}</code></span>
<span class="codeline" id="line-1895"><code>	}</code></span>
<span class="codeline" id="line-1896"><code></code></span>
<span class="codeline" id="line-1897"><code>	if s.done != nil {</code></span>
<span class="codeline" id="line-1898"><code>		close(s.done)</code></span>
<span class="codeline" id="line-1899"><code>	}</code></span>
<span class="codeline" id="line-1900"><code></code></span>
<span class="codeline" id="line-1901"><code>	// Closing the listener will make Serve() call Stop on the worker pool.</code></span>
<span class="codeline" id="line-1902"><code>	// Setting .stop to 1 will make serveConn() break out of its loop.</code></span>
<span class="codeline" id="line-1903"><code>	// Now we just have to wait until all workers are done or timeout.</code></span>
<span class="codeline" id="line-1904"><code>	ticker := time.NewTicker(time.Millisecond * 100)</code></span>
<span class="codeline" id="line-1905"><code>	defer ticker.Stop()</code></span>
<span class="codeline" id="line-1906"><code>END:</code></span>
<span class="codeline" id="line-1907"><code>	for {</code></span>
<span class="codeline" id="line-1908"><code>		s.closeIdleConns()</code></span>
<span class="codeline" id="line-1909"><code></code></span>
<span class="codeline" id="line-1910"><code>		if open := atomic.LoadInt32(&amp;s.open); open == 0 {</code></span>
<span class="codeline" id="line-1911"><code>			break</code></span>
<span class="codeline" id="line-1912"><code>		}</code></span>
<span class="codeline" id="line-1913"><code>		// This is not an optimal solution but using a sync.WaitGroup</code></span>
<span class="codeline" id="line-1914"><code>		// here causes data races as it's hard to prevent Add() to be called</code></span>
<span class="codeline" id="line-1915"><code>		// while Wait() is waiting.</code></span>
<span class="codeline" id="line-1916"><code>		select {</code></span>
<span class="codeline" id="line-1917"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-1918"><code>			err = ctx.Err()</code></span>
<span class="codeline" id="line-1919"><code>			break END</code></span>
<span class="codeline" id="line-1920"><code>		case &lt;-ticker.C:</code></span>
<span class="codeline" id="line-1921"><code>			continue</code></span>
<span class="codeline" id="line-1922"><code>		}</code></span>
<span class="codeline" id="line-1923"><code>	}</code></span>
<span class="codeline" id="line-1924"><code></code></span>
<span class="codeline" id="line-1925"><code>	s.done = nil</code></span>
<span class="codeline" id="line-1926"><code>	s.ln = nil</code></span>
<span class="codeline" id="line-1927"><code>	return err</code></span>
<span class="codeline" id="line-1928"><code>}</code></span>
<span class="codeline" id="line-1929"><code></code></span>
<span class="codeline" id="line-1930"><code>func acceptConn(s *Server, ln net.Listener, lastPerIPErrorTime *time.Time) (net.Conn, error) {</code></span>
<span class="codeline" id="line-1931"><code>	for {</code></span>
<span class="codeline" id="line-1932"><code>		c, err := ln.Accept()</code></span>
<span class="codeline" id="line-1933"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1934"><code>			if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() {</code></span>
<span class="codeline" id="line-1935"><code>				s.logger().Printf("Timeout error when accepting new connections: %v", netErr)</code></span>
<span class="codeline" id="line-1936"><code>				time.Sleep(time.Second)</code></span>
<span class="codeline" id="line-1937"><code>				continue</code></span>
<span class="codeline" id="line-1938"><code>			}</code></span>
<span class="codeline" id="line-1939"><code>			if err != io.EOF &amp;&amp; !strings.Contains(err.Error(), "use of closed network connection") {</code></span>
<span class="codeline" id="line-1940"><code>				s.logger().Printf("Permanent error when accepting new connections: %v", err)</code></span>
<span class="codeline" id="line-1941"><code>				return nil, err</code></span>
<span class="codeline" id="line-1942"><code>			}</code></span>
<span class="codeline" id="line-1943"><code>			return nil, io.EOF</code></span>
<span class="codeline" id="line-1944"><code>		}</code></span>
<span class="codeline" id="line-1945"><code></code></span>
<span class="codeline" id="line-1946"><code>		if tc, ok := c.(*net.TCPConn); ok &amp;&amp; s.TCPKeepalive {</code></span>
<span class="codeline" id="line-1947"><code>			if err := tc.SetKeepAlive(s.TCPKeepalive); err != nil {</code></span>
<span class="codeline" id="line-1948"><code>				_ = tc.Close()</code></span>
<span class="codeline" id="line-1949"><code>				return nil, err</code></span>
<span class="codeline" id="line-1950"><code>			}</code></span>
<span class="codeline" id="line-1951"><code>			if s.TCPKeepalivePeriod &gt; 0 {</code></span>
<span class="codeline" id="line-1952"><code>				if err := tc.SetKeepAlivePeriod(s.TCPKeepalivePeriod); err != nil {</code></span>
<span class="codeline" id="line-1953"><code>					_ = tc.Close()</code></span>
<span class="codeline" id="line-1954"><code>					return nil, err</code></span>
<span class="codeline" id="line-1955"><code>				}</code></span>
<span class="codeline" id="line-1956"><code>			}</code></span>
<span class="codeline" id="line-1957"><code>		}</code></span>
<span class="codeline" id="line-1958"><code></code></span>
<span class="codeline" id="line-1959"><code>		if s.MaxConnsPerIP &gt; 0 {</code></span>
<span class="codeline" id="line-1960"><code>			pic := wrapPerIPConn(s, c)</code></span>
<span class="codeline" id="line-1961"><code>			if pic == nil {</code></span>
<span class="codeline" id="line-1962"><code>				if time.Since(*lastPerIPErrorTime) &gt; time.Minute {</code></span>
<span class="codeline" id="line-1963"><code>					s.logger().Printf("The number of connections from %s exceeds MaxConnsPerIP=%d",</code></span>
<span class="codeline" id="line-1964"><code>						getConnIP4(c), s.MaxConnsPerIP)</code></span>
<span class="codeline" id="line-1965"><code>					*lastPerIPErrorTime = time.Now()</code></span>
<span class="codeline" id="line-1966"><code>				}</code></span>
<span class="codeline" id="line-1967"><code>				continue</code></span>
<span class="codeline" id="line-1968"><code>			}</code></span>
<span class="codeline" id="line-1969"><code>			c = pic</code></span>
<span class="codeline" id="line-1970"><code>		}</code></span>
<span class="codeline" id="line-1971"><code>		return c, nil</code></span>
<span class="codeline" id="line-1972"><code>	}</code></span>
<span class="codeline" id="line-1973"><code>}</code></span>
<span class="codeline" id="line-1974"><code></code></span>
<span class="codeline" id="line-1975"><code>func wrapPerIPConn(s *Server, c net.Conn) net.Conn {</code></span>
<span class="codeline" id="line-1976"><code>	ip := getUint32IP(c)</code></span>
<span class="codeline" id="line-1977"><code>	if ip == 0 {</code></span>
<span class="codeline" id="line-1978"><code>		return c</code></span>
<span class="codeline" id="line-1979"><code>	}</code></span>
<span class="codeline" id="line-1980"><code>	n := s.perIPConnCounter.Register(ip)</code></span>
<span class="codeline" id="line-1981"><code>	if n &gt; s.MaxConnsPerIP {</code></span>
<span class="codeline" id="line-1982"><code>		s.perIPConnCounter.Unregister(ip)</code></span>
<span class="codeline" id="line-1983"><code>		s.writeFastError(c, StatusTooManyRequests, "The number of connections from your ip exceeds MaxConnsPerIP")</code></span>
<span class="codeline" id="line-1984"><code>		c.Close()</code></span>
<span class="codeline" id="line-1985"><code>		return nil</code></span>
<span class="codeline" id="line-1986"><code>	}</code></span>
<span class="codeline" id="line-1987"><code>	return acquirePerIPConn(c, ip, &amp;s.perIPConnCounter)</code></span>
<span class="codeline" id="line-1988"><code>}</code></span>
<span class="codeline" id="line-1989"><code></code></span>
<span class="codeline" id="line-1990"><code>var defaultLogger = Logger(log.New(os.Stderr, "", log.LstdFlags))</code></span>
<span class="codeline" id="line-1991"><code></code></span>
<span class="codeline" id="line-1992"><code>func (s *Server) logger() Logger {</code></span>
<span class="codeline" id="line-1993"><code>	if s.Logger != nil {</code></span>
<span class="codeline" id="line-1994"><code>		return s.Logger</code></span>
<span class="codeline" id="line-1995"><code>	}</code></span>
<span class="codeline" id="line-1996"><code>	return defaultLogger</code></span>
<span class="codeline" id="line-1997"><code>}</code></span>
<span class="codeline" id="line-1998"><code></code></span>
<span class="codeline" id="line-1999"><code>var (</code></span>
<span class="codeline" id="line-2000"><code>	// ErrPerIPConnLimit may be returned from ServeConn if the number of connections</code></span>
<span class="codeline" id="line-2001"><code>	// per ip exceeds Server.MaxConnsPerIP.</code></span>
<span class="codeline" id="line-2002"><code>	ErrPerIPConnLimit = errors.New("too many connections per ip")</code></span>
<span class="codeline" id="line-2003"><code></code></span>
<span class="codeline" id="line-2004"><code>	// ErrConcurrencyLimit may be returned from ServeConn if the number</code></span>
<span class="codeline" id="line-2005"><code>	// of concurrently served connections exceeds Server.Concurrency.</code></span>
<span class="codeline" id="line-2006"><code>	ErrConcurrencyLimit = errors.New("cannot serve the connection because Server.Concurrency concurrent connections are served")</code></span>
<span class="codeline" id="line-2007"><code>)</code></span>
<span class="codeline" id="line-2008"><code></code></span>
<span class="codeline" id="line-2009"><code>// ServeConn serves HTTP requests from the given connection.</code></span>
<span class="codeline" id="line-2010"><code>//</code></span>
<span class="codeline" id="line-2011"><code>// ServeConn returns nil if all requests from the c are successfully served.</code></span>
<span class="codeline" id="line-2012"><code>// It returns non-nil error otherwise.</code></span>
<span class="codeline" id="line-2013"><code>//</code></span>
<span class="codeline" id="line-2014"><code>// Connection c must immediately propagate all the data passed to Write()</code></span>
<span class="codeline" id="line-2015"><code>// to the client. Otherwise requests' processing may hang.</code></span>
<span class="codeline" id="line-2016"><code>//</code></span>
<span class="codeline" id="line-2017"><code>// ServeConn closes c before returning.</code></span>
<span class="codeline" id="line-2018"><code>func (s *Server) ServeConn(c net.Conn) error {</code></span>
<span class="codeline" id="line-2019"><code>	if s.MaxConnsPerIP &gt; 0 {</code></span>
<span class="codeline" id="line-2020"><code>		pic := wrapPerIPConn(s, c)</code></span>
<span class="codeline" id="line-2021"><code>		if pic == nil {</code></span>
<span class="codeline" id="line-2022"><code>			return ErrPerIPConnLimit</code></span>
<span class="codeline" id="line-2023"><code>		}</code></span>
<span class="codeline" id="line-2024"><code>		c = pic</code></span>
<span class="codeline" id="line-2025"><code>	}</code></span>
<span class="codeline" id="line-2026"><code></code></span>
<span class="codeline" id="line-2027"><code>	n := atomic.AddUint32(&amp;s.concurrency, 1)</code></span>
<span class="codeline" id="line-2028"><code>	if n &gt; uint32(s.getConcurrency()) {</code></span>
<span class="codeline" id="line-2029"><code>		atomic.AddUint32(&amp;s.concurrency, ^uint32(0))</code></span>
<span class="codeline" id="line-2030"><code>		s.writeFastError(c, StatusServiceUnavailable, "The connection cannot be served because Server.Concurrency limit exceeded")</code></span>
<span class="codeline" id="line-2031"><code>		c.Close()</code></span>
<span class="codeline" id="line-2032"><code>		return ErrConcurrencyLimit</code></span>
<span class="codeline" id="line-2033"><code>	}</code></span>
<span class="codeline" id="line-2034"><code></code></span>
<span class="codeline" id="line-2035"><code>	atomic.AddInt32(&amp;s.open, 1)</code></span>
<span class="codeline" id="line-2036"><code></code></span>
<span class="codeline" id="line-2037"><code>	err := s.serveConn(c)</code></span>
<span class="codeline" id="line-2038"><code></code></span>
<span class="codeline" id="line-2039"><code>	atomic.AddUint32(&amp;s.concurrency, ^uint32(0))</code></span>
<span class="codeline" id="line-2040"><code></code></span>
<span class="codeline" id="line-2041"><code>	if err != errHijacked {</code></span>
<span class="codeline" id="line-2042"><code>		err1 := c.Close()</code></span>
<span class="codeline" id="line-2043"><code>		s.setState(c, StateClosed)</code></span>
<span class="codeline" id="line-2044"><code>		if err == nil {</code></span>
<span class="codeline" id="line-2045"><code>			err = err1</code></span>
<span class="codeline" id="line-2046"><code>		}</code></span>
<span class="codeline" id="line-2047"><code>	} else {</code></span>
<span class="codeline" id="line-2048"><code>		err = nil</code></span>
<span class="codeline" id="line-2049"><code>		s.setState(c, StateHijacked)</code></span>
<span class="codeline" id="line-2050"><code>	}</code></span>
<span class="codeline" id="line-2051"><code>	return err</code></span>
<span class="codeline" id="line-2052"><code>}</code></span>
<span class="codeline" id="line-2053"><code></code></span>
<span class="codeline" id="line-2054"><code>var errHijacked = errors.New("connection has been hijacked")</code></span>
<span class="codeline" id="line-2055"><code></code></span>
<span class="codeline" id="line-2056"><code>// GetCurrentConcurrency returns a number of currently served</code></span>
<span class="codeline" id="line-2057"><code>// connections.</code></span>
<span class="codeline" id="line-2058"><code>//</code></span>
<span class="codeline" id="line-2059"><code>// This function is intended be used by monitoring systems.</code></span>
<span class="codeline" id="line-2060"><code>func (s *Server) GetCurrentConcurrency() uint32 {</code></span>
<span class="codeline" id="line-2061"><code>	return atomic.LoadUint32(&amp;s.concurrency)</code></span>
<span class="codeline" id="line-2062"><code>}</code></span>
<span class="codeline" id="line-2063"><code></code></span>
<span class="codeline" id="line-2064"><code>// GetOpenConnectionsCount returns a number of opened connections.</code></span>
<span class="codeline" id="line-2065"><code>//</code></span>
<span class="codeline" id="line-2066"><code>// This function is intended be used by monitoring systems.</code></span>
<span class="codeline" id="line-2067"><code>func (s *Server) GetOpenConnectionsCount() int32 {</code></span>
<span class="codeline" id="line-2068"><code>	if atomic.LoadInt32(&amp;s.stop) == 0 {</code></span>
<span class="codeline" id="line-2069"><code>		// Decrement by one to avoid reporting the extra open value that gets</code></span>
<span class="codeline" id="line-2070"><code>		// counted while the server is listening.</code></span>
<span class="codeline" id="line-2071"><code>		return atomic.LoadInt32(&amp;s.open) - 1</code></span>
<span class="codeline" id="line-2072"><code>	}</code></span>
<span class="codeline" id="line-2073"><code>	// This is not perfect, because s.stop could have changed to zero</code></span>
<span class="codeline" id="line-2074"><code>	// before we load the value of s.open. However, in the common case</code></span>
<span class="codeline" id="line-2075"><code>	// this avoids underreporting open connections by 1 during server shutdown.</code></span>
<span class="codeline" id="line-2076"><code>	return atomic.LoadInt32(&amp;s.open)</code></span>
<span class="codeline" id="line-2077"><code>}</code></span>
<span class="codeline" id="line-2078"><code></code></span>
<span class="codeline" id="line-2079"><code>// GetRejectedConnectionsCount returns a number of rejected connections.</code></span>
<span class="codeline" id="line-2080"><code>//</code></span>
<span class="codeline" id="line-2081"><code>// This function is intended be used by monitoring systems.</code></span>
<span class="codeline" id="line-2082"><code>func (s *Server) GetRejectedConnectionsCount() uint32 {</code></span>
<span class="codeline" id="line-2083"><code>	return atomic.LoadUint32(&amp;s.rejectedRequestsCount)</code></span>
<span class="codeline" id="line-2084"><code>}</code></span>
<span class="codeline" id="line-2085"><code></code></span>
<span class="codeline" id="line-2086"><code>func (s *Server) getConcurrency() int {</code></span>
<span class="codeline" id="line-2087"><code>	n := s.Concurrency</code></span>
<span class="codeline" id="line-2088"><code>	if n &lt;= 0 {</code></span>
<span class="codeline" id="line-2089"><code>		n = DefaultConcurrency</code></span>
<span class="codeline" id="line-2090"><code>	}</code></span>
<span class="codeline" id="line-2091"><code>	return n</code></span>
<span class="codeline" id="line-2092"><code>}</code></span>
<span class="codeline" id="line-2093"><code></code></span>
<span class="codeline" id="line-2094"><code>var globalConnID uint64</code></span>
<span class="codeline" id="line-2095"><code></code></span>
<span class="codeline" id="line-2096"><code>func nextConnID() uint64 {</code></span>
<span class="codeline" id="line-2097"><code>	return atomic.AddUint64(&amp;globalConnID, 1)</code></span>
<span class="codeline" id="line-2098"><code>}</code></span>
<span class="codeline" id="line-2099"><code></code></span>
<span class="codeline" id="line-2100"><code>// DefaultMaxRequestBodySize is the maximum request body size the server</code></span>
<span class="codeline" id="line-2101"><code>// reads by default.</code></span>
<span class="codeline" id="line-2102"><code>//</code></span>
<span class="codeline" id="line-2103"><code>// See Server.MaxRequestBodySize for details.</code></span>
<span class="codeline" id="line-2104"><code>const DefaultMaxRequestBodySize = 4 * 1024 * 1024</code></span>
<span class="codeline" id="line-2105"><code></code></span>
<span class="codeline" id="line-2106"><code>func (s *Server) idleTimeout() time.Duration {</code></span>
<span class="codeline" id="line-2107"><code>	if s.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-2108"><code>		return s.IdleTimeout</code></span>
<span class="codeline" id="line-2109"><code>	}</code></span>
<span class="codeline" id="line-2110"><code>	return s.ReadTimeout</code></span>
<span class="codeline" id="line-2111"><code>}</code></span>
<span class="codeline" id="line-2112"><code></code></span>
<span class="codeline" id="line-2113"><code>func (s *Server) serveConnCleanup() {</code></span>
<span class="codeline" id="line-2114"><code>	atomic.AddInt32(&amp;s.open, -1)</code></span>
<span class="codeline" id="line-2115"><code>	atomic.AddUint32(&amp;s.concurrency, ^uint32(0))</code></span>
<span class="codeline" id="line-2116"><code>}</code></span>
<span class="codeline" id="line-2117"><code></code></span>
<span class="codeline" id="line-2118"><code>func (s *Server) serveConn(c net.Conn) (err error) {</code></span>
<span class="codeline" id="line-2119"><code>	defer s.serveConnCleanup()</code></span>
<span class="codeline" id="line-2120"><code>	atomic.AddUint32(&amp;s.concurrency, 1)</code></span>
<span class="codeline" id="line-2121"><code></code></span>
<span class="codeline" id="line-2122"><code>	var proto string</code></span>
<span class="codeline" id="line-2123"><code>	if proto, err = s.getNextProto(c); err != nil {</code></span>
<span class="codeline" id="line-2124"><code>		return</code></span>
<span class="codeline" id="line-2125"><code>	}</code></span>
<span class="codeline" id="line-2126"><code>	if handler, ok := s.nextProtos[proto]; ok {</code></span>
<span class="codeline" id="line-2127"><code>		// Remove read or write deadlines that might have previously been set.</code></span>
<span class="codeline" id="line-2128"><code>		// The next handler is responsible for setting its own deadlines.</code></span>
<span class="codeline" id="line-2129"><code>		if s.ReadTimeout &gt; 0 || s.WriteTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2130"><code>			if err := c.SetDeadline(zeroTime); err != nil {</code></span>
<span class="codeline" id="line-2131"><code>				panic(fmt.Sprintf("BUG: error in SetDeadline(zeroTime): %v", err))</code></span>
<span class="codeline" id="line-2132"><code>			}</code></span>
<span class="codeline" id="line-2133"><code>		}</code></span>
<span class="codeline" id="line-2134"><code></code></span>
<span class="codeline" id="line-2135"><code>		return handler(c)</code></span>
<span class="codeline" id="line-2136"><code>	}</code></span>
<span class="codeline" id="line-2137"><code></code></span>
<span class="codeline" id="line-2138"><code>	serverName := s.getServerName()</code></span>
<span class="codeline" id="line-2139"><code>	connRequestNum := uint64(0)</code></span>
<span class="codeline" id="line-2140"><code>	connID := nextConnID()</code></span>
<span class="codeline" id="line-2141"><code>	connTime := time.Now()</code></span>
<span class="codeline" id="line-2142"><code>	maxRequestBodySize := s.MaxRequestBodySize</code></span>
<span class="codeline" id="line-2143"><code>	if maxRequestBodySize &lt;= 0 {</code></span>
<span class="codeline" id="line-2144"><code>		maxRequestBodySize = DefaultMaxRequestBodySize</code></span>
<span class="codeline" id="line-2145"><code>	}</code></span>
<span class="codeline" id="line-2146"><code>	writeTimeout := s.WriteTimeout</code></span>
<span class="codeline" id="line-2147"><code>	previousWriteTimeout := time.Duration(0)</code></span>
<span class="codeline" id="line-2148"><code></code></span>
<span class="codeline" id="line-2149"><code>	ctx := s.acquireCtx(c)</code></span>
<span class="codeline" id="line-2150"><code>	ctx.connTime = connTime</code></span>
<span class="codeline" id="line-2151"><code>	isTLS := ctx.IsTLS()</code></span>
<span class="codeline" id="line-2152"><code>	var (</code></span>
<span class="codeline" id="line-2153"><code>		br *bufio.Reader</code></span>
<span class="codeline" id="line-2154"><code>		bw *bufio.Writer</code></span>
<span class="codeline" id="line-2155"><code></code></span>
<span class="codeline" id="line-2156"><code>		timeoutResponse  *Response</code></span>
<span class="codeline" id="line-2157"><code>		hijackHandler    HijackHandler</code></span>
<span class="codeline" id="line-2158"><code>		hijackNoResponse bool</code></span>
<span class="codeline" id="line-2159"><code></code></span>
<span class="codeline" id="line-2160"><code>		connectionClose bool</code></span>
<span class="codeline" id="line-2161"><code></code></span>
<span class="codeline" id="line-2162"><code>		continueReadingRequest = true</code></span>
<span class="codeline" id="line-2163"><code>	)</code></span>
<span class="codeline" id="line-2164"><code>	for {</code></span>
<span class="codeline" id="line-2165"><code>		connRequestNum++</code></span>
<span class="codeline" id="line-2166"><code></code></span>
<span class="codeline" id="line-2167"><code>		// If this is a keep-alive connection set the idle timeout.</code></span>
<span class="codeline" id="line-2168"><code>		if connRequestNum &gt; 1 {</code></span>
<span class="codeline" id="line-2169"><code>			if d := s.idleTimeout(); d &gt; 0 {</code></span>
<span class="codeline" id="line-2170"><code>				if err := c.SetReadDeadline(time.Now().Add(d)); err != nil {</code></span>
<span class="codeline" id="line-2171"><code>					break</code></span>
<span class="codeline" id="line-2172"><code>				}</code></span>
<span class="codeline" id="line-2173"><code>			}</code></span>
<span class="codeline" id="line-2174"><code>		}</code></span>
<span class="codeline" id="line-2175"><code></code></span>
<span class="codeline" id="line-2176"><code>		if !s.ReduceMemoryUsage || br != nil {</code></span>
<span class="codeline" id="line-2177"><code>			if br == nil {</code></span>
<span class="codeline" id="line-2178"><code>				br = acquireReader(ctx)</code></span>
<span class="codeline" id="line-2179"><code>			}</code></span>
<span class="codeline" id="line-2180"><code></code></span>
<span class="codeline" id="line-2181"><code>			// If this is a keep-alive connection we want to try and read the first bytes</code></span>
<span class="codeline" id="line-2182"><code>			// within the idle time.</code></span>
<span class="codeline" id="line-2183"><code>			if connRequestNum &gt; 1 {</code></span>
<span class="codeline" id="line-2184"><code>				var b []byte</code></span>
<span class="codeline" id="line-2185"><code>				b, err = br.Peek(1)</code></span>
<span class="codeline" id="line-2186"><code>				if len(b) == 0 {</code></span>
<span class="codeline" id="line-2187"><code>					// If reading from a keep-alive connection returns nothing it means</code></span>
<span class="codeline" id="line-2188"><code>					// the connection was closed (either timeout or from the other side).</code></span>
<span class="codeline" id="line-2189"><code>					if err != io.EOF {</code></span>
<span class="codeline" id="line-2190"><code>						err = ErrNothingRead{err}</code></span>
<span class="codeline" id="line-2191"><code>					}</code></span>
<span class="codeline" id="line-2192"><code>				}</code></span>
<span class="codeline" id="line-2193"><code>			}</code></span>
<span class="codeline" id="line-2194"><code>		} else {</code></span>
<span class="codeline" id="line-2195"><code>			// If this is a keep-alive connection acquireByteReader will try to peek</code></span>
<span class="codeline" id="line-2196"><code>			// a couple of bytes already so the idle timeout will already be used.</code></span>
<span class="codeline" id="line-2197"><code>			br, err = acquireByteReader(&amp;ctx)</code></span>
<span class="codeline" id="line-2198"><code>		}</code></span>
<span class="codeline" id="line-2199"><code></code></span>
<span class="codeline" id="line-2200"><code>		ctx.Request.isTLS = isTLS</code></span>
<span class="codeline" id="line-2201"><code>		ctx.Response.Header.noDefaultContentType = s.NoDefaultContentType</code></span>
<span class="codeline" id="line-2202"><code>		ctx.Response.Header.noDefaultDate = s.NoDefaultDate</code></span>
<span class="codeline" id="line-2203"><code></code></span>
<span class="codeline" id="line-2204"><code>		// Secure header error logs configuration</code></span>
<span class="codeline" id="line-2205"><code>		ctx.Request.Header.secureErrorLogMessage = s.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-2206"><code>		ctx.Response.Header.secureErrorLogMessage = s.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-2207"><code>		ctx.Request.secureErrorLogMessage = s.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-2208"><code>		ctx.Response.secureErrorLogMessage = s.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-2209"><code></code></span>
<span class="codeline" id="line-2210"><code>		if err == nil {</code></span>
<span class="codeline" id="line-2211"><code>			s.setState(c, StateActive)</code></span>
<span class="codeline" id="line-2212"><code></code></span>
<span class="codeline" id="line-2213"><code>			if s.ReadTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2214"><code>				if err := c.SetReadDeadline(time.Now().Add(s.ReadTimeout)); err != nil {</code></span>
<span class="codeline" id="line-2215"><code>					break</code></span>
<span class="codeline" id="line-2216"><code>				}</code></span>
<span class="codeline" id="line-2217"><code>			} else if s.IdleTimeout &gt; 0 &amp;&amp; connRequestNum &gt; 1 {</code></span>
<span class="codeline" id="line-2218"><code>				// If this was an idle connection and the server has an IdleTimeout but</code></span>
<span class="codeline" id="line-2219"><code>				// no ReadTimeout then we should remove the ReadTimeout.</code></span>
<span class="codeline" id="line-2220"><code>				if err := c.SetReadDeadline(zeroTime); err != nil {</code></span>
<span class="codeline" id="line-2221"><code>					break</code></span>
<span class="codeline" id="line-2222"><code>				}</code></span>
<span class="codeline" id="line-2223"><code>			}</code></span>
<span class="codeline" id="line-2224"><code>			if s.DisableHeaderNamesNormalizing {</code></span>
<span class="codeline" id="line-2225"><code>				ctx.Request.Header.DisableNormalizing()</code></span>
<span class="codeline" id="line-2226"><code>				ctx.Response.Header.DisableNormalizing()</code></span>
<span class="codeline" id="line-2227"><code>			}</code></span>
<span class="codeline" id="line-2228"><code></code></span>
<span class="codeline" id="line-2229"><code>			// Reading Headers.</code></span>
<span class="codeline" id="line-2230"><code>			//</code></span>
<span class="codeline" id="line-2231"><code>			// If we have pipeline response in the outgoing buffer,</code></span>
<span class="codeline" id="line-2232"><code>			// we only want to try and read the next headers once.</code></span>
<span class="codeline" id="line-2233"><code>			// If we have to wait for the next request we flush the</code></span>
<span class="codeline" id="line-2234"><code>			// outgoing buffer first so it doesn't have to wait.</code></span>
<span class="codeline" id="line-2235"><code>			if bw != nil &amp;&amp; bw.Buffered() &gt; 0 {</code></span>
<span class="codeline" id="line-2236"><code>				err = ctx.Request.Header.readLoop(br, false)</code></span>
<span class="codeline" id="line-2237"><code>				if err == errNeedMore {</code></span>
<span class="codeline" id="line-2238"><code>					err = bw.Flush()</code></span>
<span class="codeline" id="line-2239"><code>					if err != nil {</code></span>
<span class="codeline" id="line-2240"><code>						break</code></span>
<span class="codeline" id="line-2241"><code>					}</code></span>
<span class="codeline" id="line-2242"><code></code></span>
<span class="codeline" id="line-2243"><code>					err = ctx.Request.Header.Read(br)</code></span>
<span class="codeline" id="line-2244"><code>				}</code></span>
<span class="codeline" id="line-2245"><code>			} else {</code></span>
<span class="codeline" id="line-2246"><code>				err = ctx.Request.Header.Read(br)</code></span>
<span class="codeline" id="line-2247"><code>			}</code></span>
<span class="codeline" id="line-2248"><code></code></span>
<span class="codeline" id="line-2249"><code>			if err == nil {</code></span>
<span class="codeline" id="line-2250"><code>				if onHdrRecv := s.HeaderReceived; onHdrRecv != nil {</code></span>
<span class="codeline" id="line-2251"><code>					reqConf := onHdrRecv(&amp;ctx.Request.Header)</code></span>
<span class="codeline" id="line-2252"><code>					if reqConf.ReadTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2253"><code>						deadline := time.Now().Add(reqConf.ReadTimeout)</code></span>
<span class="codeline" id="line-2254"><code>						if err := c.SetReadDeadline(deadline); err != nil {</code></span>
<span class="codeline" id="line-2255"><code>							panic(fmt.Sprintf("BUG: error in SetReadDeadline(%v): %v", deadline, err))</code></span>
<span class="codeline" id="line-2256"><code>						}</code></span>
<span class="codeline" id="line-2257"><code>					}</code></span>
<span class="codeline" id="line-2258"><code>					switch {</code></span>
<span class="codeline" id="line-2259"><code>					case reqConf.MaxRequestBodySize &gt; 0:</code></span>
<span class="codeline" id="line-2260"><code>						maxRequestBodySize = reqConf.MaxRequestBodySize</code></span>
<span class="codeline" id="line-2261"><code>					case s.MaxRequestBodySize &gt; 0:</code></span>
<span class="codeline" id="line-2262"><code>						maxRequestBodySize = s.MaxRequestBodySize</code></span>
<span class="codeline" id="line-2263"><code>					default:</code></span>
<span class="codeline" id="line-2264"><code>						maxRequestBodySize = DefaultMaxRequestBodySize</code></span>
<span class="codeline" id="line-2265"><code>					}</code></span>
<span class="codeline" id="line-2266"><code>					if reqConf.WriteTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2267"><code>						writeTimeout = reqConf.WriteTimeout</code></span>
<span class="codeline" id="line-2268"><code>					} else {</code></span>
<span class="codeline" id="line-2269"><code>						writeTimeout = s.WriteTimeout</code></span>
<span class="codeline" id="line-2270"><code>					}</code></span>
<span class="codeline" id="line-2271"><code>				}</code></span>
<span class="codeline" id="line-2272"><code>				// read body</code></span>
<span class="codeline" id="line-2273"><code>				if s.StreamRequestBody {</code></span>
<span class="codeline" id="line-2274"><code>					err = ctx.Request.readBodyStream(br, maxRequestBodySize, s.GetOnly, !s.DisablePreParseMultipartForm)</code></span>
<span class="codeline" id="line-2275"><code>				} else {</code></span>
<span class="codeline" id="line-2276"><code>					err = ctx.Request.readLimitBody(br, maxRequestBodySize, s.GetOnly, !s.DisablePreParseMultipartForm)</code></span>
<span class="codeline" id="line-2277"><code>				}</code></span>
<span class="codeline" id="line-2278"><code>			}</code></span>
<span class="codeline" id="line-2279"><code></code></span>
<span class="codeline" id="line-2280"><code>			if (s.ReduceMemoryUsage &amp;&amp; br.Buffered() == 0) || err != nil {</code></span>
<span class="codeline" id="line-2281"><code>				releaseReader(s, br)</code></span>
<span class="codeline" id="line-2282"><code>				br = nil</code></span>
<span class="codeline" id="line-2283"><code>			}</code></span>
<span class="codeline" id="line-2284"><code>		}</code></span>
<span class="codeline" id="line-2285"><code></code></span>
<span class="codeline" id="line-2286"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2287"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-2288"><code>				err = nil</code></span>
<span class="codeline" id="line-2289"><code>			} else if nr, ok := err.(ErrNothingRead); ok {</code></span>
<span class="codeline" id="line-2290"><code>				if connRequestNum &gt; 1 {</code></span>
<span class="codeline" id="line-2291"><code>					// This is not the first request and we haven't read a single byte</code></span>
<span class="codeline" id="line-2292"><code>					// of a new request yet. This means it's just a keep-alive connection</code></span>
<span class="codeline" id="line-2293"><code>					// closing down either because the remote closed it or because</code></span>
<span class="codeline" id="line-2294"><code>					// or a read timeout on our side. Either way just close the connection</code></span>
<span class="codeline" id="line-2295"><code>					// and don't return any error response.</code></span>
<span class="codeline" id="line-2296"><code>					err = nil</code></span>
<span class="codeline" id="line-2297"><code>				} else {</code></span>
<span class="codeline" id="line-2298"><code>					err = nr.error</code></span>
<span class="codeline" id="line-2299"><code>				}</code></span>
<span class="codeline" id="line-2300"><code>			}</code></span>
<span class="codeline" id="line-2301"><code></code></span>
<span class="codeline" id="line-2302"><code>			if err != nil {</code></span>
<span class="codeline" id="line-2303"><code>				bw = s.writeErrorResponse(bw, ctx, serverName, err)</code></span>
<span class="codeline" id="line-2304"><code>			}</code></span>
<span class="codeline" id="line-2305"><code>			break</code></span>
<span class="codeline" id="line-2306"><code>		}</code></span>
<span class="codeline" id="line-2307"><code></code></span>
<span class="codeline" id="line-2308"><code>		// 'Expect: 100-continue' request handling.</code></span>
<span class="codeline" id="line-2309"><code>		// See https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3 for details.</code></span>
<span class="codeline" id="line-2310"><code>		if ctx.Request.MayContinue() {</code></span>
<span class="codeline" id="line-2311"><code>			// Allow the ability to deny reading the incoming request body</code></span>
<span class="codeline" id="line-2312"><code>			if s.ContinueHandler != nil {</code></span>
<span class="codeline" id="line-2313"><code>				if continueReadingRequest = s.ContinueHandler(&amp;ctx.Request.Header); !continueReadingRequest {</code></span>
<span class="codeline" id="line-2314"><code>					if br != nil {</code></span>
<span class="codeline" id="line-2315"><code>						br.Reset(ctx.c)</code></span>
<span class="codeline" id="line-2316"><code>					}</code></span>
<span class="codeline" id="line-2317"><code></code></span>
<span class="codeline" id="line-2318"><code>					ctx.SetStatusCode(StatusExpectationFailed)</code></span>
<span class="codeline" id="line-2319"><code>				}</code></span>
<span class="codeline" id="line-2320"><code>			}</code></span>
<span class="codeline" id="line-2321"><code></code></span>
<span class="codeline" id="line-2322"><code>			if continueReadingRequest {</code></span>
<span class="codeline" id="line-2323"><code>				if bw == nil {</code></span>
<span class="codeline" id="line-2324"><code>					bw = acquireWriter(ctx)</code></span>
<span class="codeline" id="line-2325"><code>				}</code></span>
<span class="codeline" id="line-2326"><code></code></span>
<span class="codeline" id="line-2327"><code>				// Send 'HTTP/1.1 100 Continue' response.</code></span>
<span class="codeline" id="line-2328"><code>				_, err = bw.Write(strResponseContinue)</code></span>
<span class="codeline" id="line-2329"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2330"><code>					break</code></span>
<span class="codeline" id="line-2331"><code>				}</code></span>
<span class="codeline" id="line-2332"><code>				err = bw.Flush()</code></span>
<span class="codeline" id="line-2333"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2334"><code>					break</code></span>
<span class="codeline" id="line-2335"><code>				}</code></span>
<span class="codeline" id="line-2336"><code>				if s.ReduceMemoryUsage {</code></span>
<span class="codeline" id="line-2337"><code>					releaseWriter(s, bw)</code></span>
<span class="codeline" id="line-2338"><code>					bw = nil</code></span>
<span class="codeline" id="line-2339"><code>				}</code></span>
<span class="codeline" id="line-2340"><code></code></span>
<span class="codeline" id="line-2341"><code>				// Read request body.</code></span>
<span class="codeline" id="line-2342"><code>				if br == nil {</code></span>
<span class="codeline" id="line-2343"><code>					br = acquireReader(ctx)</code></span>
<span class="codeline" id="line-2344"><code>				}</code></span>
<span class="codeline" id="line-2345"><code></code></span>
<span class="codeline" id="line-2346"><code>				if s.StreamRequestBody {</code></span>
<span class="codeline" id="line-2347"><code>					err = ctx.Request.ContinueReadBodyStream(br, maxRequestBodySize, !s.DisablePreParseMultipartForm)</code></span>
<span class="codeline" id="line-2348"><code>				} else {</code></span>
<span class="codeline" id="line-2349"><code>					err = ctx.Request.ContinueReadBody(br, maxRequestBodySize, !s.DisablePreParseMultipartForm)</code></span>
<span class="codeline" id="line-2350"><code>				}</code></span>
<span class="codeline" id="line-2351"><code>				if (s.ReduceMemoryUsage &amp;&amp; br.Buffered() == 0) || err != nil {</code></span>
<span class="codeline" id="line-2352"><code>					releaseReader(s, br)</code></span>
<span class="codeline" id="line-2353"><code>					br = nil</code></span>
<span class="codeline" id="line-2354"><code>				}</code></span>
<span class="codeline" id="line-2355"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2356"><code>					bw = s.writeErrorResponse(bw, ctx, serverName, err)</code></span>
<span class="codeline" id="line-2357"><code>					break</code></span>
<span class="codeline" id="line-2358"><code>				}</code></span>
<span class="codeline" id="line-2359"><code>			}</code></span>
<span class="codeline" id="line-2360"><code>		}</code></span>
<span class="codeline" id="line-2361"><code></code></span>
<span class="codeline" id="line-2362"><code>		// store req.ConnectionClose so even if it was changed inside of handler</code></span>
<span class="codeline" id="line-2363"><code>		connectionClose = s.DisableKeepalive || ctx.Request.Header.ConnectionClose()</code></span>
<span class="codeline" id="line-2364"><code></code></span>
<span class="codeline" id="line-2365"><code>		if serverName != "" {</code></span>
<span class="codeline" id="line-2366"><code>			ctx.Response.Header.SetServer(serverName)</code></span>
<span class="codeline" id="line-2367"><code>		}</code></span>
<span class="codeline" id="line-2368"><code>		ctx.connID = connID</code></span>
<span class="codeline" id="line-2369"><code>		ctx.connRequestNum = connRequestNum</code></span>
<span class="codeline" id="line-2370"><code>		ctx.time = time.Now()</code></span>
<span class="codeline" id="line-2371"><code></code></span>
<span class="codeline" id="line-2372"><code>		// If a client denies a request the handler should not be called</code></span>
<span class="codeline" id="line-2373"><code>		if continueReadingRequest {</code></span>
<span class="codeline" id="line-2374"><code>			s.Handler(ctx)</code></span>
<span class="codeline" id="line-2375"><code>		}</code></span>
<span class="codeline" id="line-2376"><code></code></span>
<span class="codeline" id="line-2377"><code>		timeoutResponse = ctx.timeoutResponse</code></span>
<span class="codeline" id="line-2378"><code>		if timeoutResponse != nil {</code></span>
<span class="codeline" id="line-2379"><code>			// Acquire a new ctx because the old one will still be in use by the timeout out handler.</code></span>
<span class="codeline" id="line-2380"><code>			ctx = s.acquireCtx(c)</code></span>
<span class="codeline" id="line-2381"><code>			timeoutResponse.CopyTo(&amp;ctx.Response)</code></span>
<span class="codeline" id="line-2382"><code>		}</code></span>
<span class="codeline" id="line-2383"><code></code></span>
<span class="codeline" id="line-2384"><code>		if ctx.IsHead() {</code></span>
<span class="codeline" id="line-2385"><code>			ctx.Response.SkipBody = true</code></span>
<span class="codeline" id="line-2386"><code>		}</code></span>
<span class="codeline" id="line-2387"><code></code></span>
<span class="codeline" id="line-2388"><code>		hijackHandler = ctx.hijackHandler</code></span>
<span class="codeline" id="line-2389"><code>		ctx.hijackHandler = nil</code></span>
<span class="codeline" id="line-2390"><code>		hijackNoResponse = ctx.hijackNoResponse &amp;&amp; hijackHandler != nil</code></span>
<span class="codeline" id="line-2391"><code>		ctx.hijackNoResponse = false</code></span>
<span class="codeline" id="line-2392"><code></code></span>
<span class="codeline" id="line-2393"><code>		if writeTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2394"><code>			if err := c.SetWriteDeadline(time.Now().Add(writeTimeout)); err != nil {</code></span>
<span class="codeline" id="line-2395"><code>				panic(fmt.Sprintf("BUG: error in SetWriteDeadline(%v): %v", writeTimeout, err))</code></span>
<span class="codeline" id="line-2396"><code>			}</code></span>
<span class="codeline" id="line-2397"><code>			previousWriteTimeout = writeTimeout</code></span>
<span class="codeline" id="line-2398"><code>		} else if previousWriteTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2399"><code>			// We don't want a write timeout but we previously set one, remove it.</code></span>
<span class="codeline" id="line-2400"><code>			if err := c.SetWriteDeadline(zeroTime); err != nil {</code></span>
<span class="codeline" id="line-2401"><code>				panic(fmt.Sprintf("BUG: error in SetWriteDeadline(zeroTime): %v", err))</code></span>
<span class="codeline" id="line-2402"><code>			}</code></span>
<span class="codeline" id="line-2403"><code>			previousWriteTimeout = 0</code></span>
<span class="codeline" id="line-2404"><code>		}</code></span>
<span class="codeline" id="line-2405"><code></code></span>
<span class="codeline" id="line-2406"><code>		connectionClose = connectionClose ||</code></span>
<span class="codeline" id="line-2407"><code>			(s.MaxRequestsPerConn &gt; 0 &amp;&amp; connRequestNum &gt;= uint64(s.MaxRequestsPerConn)) ||</code></span>
<span class="codeline" id="line-2408"><code>			ctx.Response.Header.ConnectionClose() ||</code></span>
<span class="codeline" id="line-2409"><code>			(s.CloseOnShutdown &amp;&amp; atomic.LoadInt32(&amp;s.stop) == 1)</code></span>
<span class="codeline" id="line-2410"><code>		if connectionClose {</code></span>
<span class="codeline" id="line-2411"><code>			ctx.Response.Header.SetConnectionClose()</code></span>
<span class="codeline" id="line-2412"><code>		} else if !ctx.Request.Header.IsHTTP11() {</code></span>
<span class="codeline" id="line-2413"><code>			// Set 'Connection: keep-alive' response header for HTTP/1.0 request.</code></span>
<span class="codeline" id="line-2414"><code>			// There is no need in setting this header for http/1.1, since in http/1.1</code></span>
<span class="codeline" id="line-2415"><code>			// connections are keep-alive by default.</code></span>
<span class="codeline" id="line-2416"><code>			ctx.Response.Header.setNonSpecial(strConnection, strKeepAlive)</code></span>
<span class="codeline" id="line-2417"><code>		}</code></span>
<span class="codeline" id="line-2418"><code></code></span>
<span class="codeline" id="line-2419"><code>		if serverName != "" &amp;&amp; len(ctx.Response.Header.Server()) == 0 {</code></span>
<span class="codeline" id="line-2420"><code>			ctx.Response.Header.SetServer(serverName)</code></span>
<span class="codeline" id="line-2421"><code>		}</code></span>
<span class="codeline" id="line-2422"><code></code></span>
<span class="codeline" id="line-2423"><code>		if !hijackNoResponse {</code></span>
<span class="codeline" id="line-2424"><code>			if bw == nil {</code></span>
<span class="codeline" id="line-2425"><code>				bw = acquireWriter(ctx)</code></span>
<span class="codeline" id="line-2426"><code>			}</code></span>
<span class="codeline" id="line-2427"><code>			if err = writeResponse(ctx, bw); err != nil {</code></span>
<span class="codeline" id="line-2428"><code>				break</code></span>
<span class="codeline" id="line-2429"><code>			}</code></span>
<span class="codeline" id="line-2430"><code></code></span>
<span class="codeline" id="line-2431"><code>			// Only flush the writer if we don't have another request in the pipeline.</code></span>
<span class="codeline" id="line-2432"><code>			// This is a big of an ugly optimization for https://www.techempower.com/benchmarks/</code></span>
<span class="codeline" id="line-2433"><code>			// This benchmark will send 16 pipelined requests. It is faster to pack as many responses</code></span>
<span class="codeline" id="line-2434"><code>			// in a TCP packet and send it back at once than waiting for a flush every request.</code></span>
<span class="codeline" id="line-2435"><code>			// In real world circumstances this behaviour could be argued as being wrong.</code></span>
<span class="codeline" id="line-2436"><code>			if br == nil || br.Buffered() == 0 || connectionClose || (s.ReduceMemoryUsage &amp;&amp; hijackHandler == nil) {</code></span>
<span class="codeline" id="line-2437"><code>				err = bw.Flush()</code></span>
<span class="codeline" id="line-2438"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2439"><code>					break</code></span>
<span class="codeline" id="line-2440"><code>				}</code></span>
<span class="codeline" id="line-2441"><code>			}</code></span>
<span class="codeline" id="line-2442"><code>			if connectionClose {</code></span>
<span class="codeline" id="line-2443"><code>				break</code></span>
<span class="codeline" id="line-2444"><code>			}</code></span>
<span class="codeline" id="line-2445"><code>			if s.ReduceMemoryUsage &amp;&amp; hijackHandler == nil {</code></span>
<span class="codeline" id="line-2446"><code>				releaseWriter(s, bw)</code></span>
<span class="codeline" id="line-2447"><code>				bw = nil</code></span>
<span class="codeline" id="line-2448"><code>			}</code></span>
<span class="codeline" id="line-2449"><code>		}</code></span>
<span class="codeline" id="line-2450"><code></code></span>
<span class="codeline" id="line-2451"><code>		if hijackHandler != nil {</code></span>
<span class="codeline" id="line-2452"><code>			var hjr io.Reader = c</code></span>
<span class="codeline" id="line-2453"><code>			if br != nil {</code></span>
<span class="codeline" id="line-2454"><code>				hjr = br</code></span>
<span class="codeline" id="line-2455"><code>				br = nil</code></span>
<span class="codeline" id="line-2456"><code>			}</code></span>
<span class="codeline" id="line-2457"><code>			if bw != nil {</code></span>
<span class="codeline" id="line-2458"><code>				err = bw.Flush()</code></span>
<span class="codeline" id="line-2459"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2460"><code>					break</code></span>
<span class="codeline" id="line-2461"><code>				}</code></span>
<span class="codeline" id="line-2462"><code>				releaseWriter(s, bw)</code></span>
<span class="codeline" id="line-2463"><code>				bw = nil</code></span>
<span class="codeline" id="line-2464"><code>			}</code></span>
<span class="codeline" id="line-2465"><code>			err = c.SetDeadline(zeroTime)</code></span>
<span class="codeline" id="line-2466"><code>			if err != nil {</code></span>
<span class="codeline" id="line-2467"><code>				break</code></span>
<span class="codeline" id="line-2468"><code>			}</code></span>
<span class="codeline" id="line-2469"><code>			go hijackConnHandler(ctx, hjr, c, s, hijackHandler)</code></span>
<span class="codeline" id="line-2470"><code>			err = errHijacked</code></span>
<span class="codeline" id="line-2471"><code>			break</code></span>
<span class="codeline" id="line-2472"><code>		}</code></span>
<span class="codeline" id="line-2473"><code></code></span>
<span class="codeline" id="line-2474"><code>		if ctx.Request.bodyStream != nil {</code></span>
<span class="codeline" id="line-2475"><code>			if rs, ok := ctx.Request.bodyStream.(*requestStream); ok {</code></span>
<span class="codeline" id="line-2476"><code>				releaseRequestStream(rs)</code></span>
<span class="codeline" id="line-2477"><code>			}</code></span>
<span class="codeline" id="line-2478"><code>			ctx.Request.bodyStream = nil</code></span>
<span class="codeline" id="line-2479"><code>		}</code></span>
<span class="codeline" id="line-2480"><code></code></span>
<span class="codeline" id="line-2481"><code>		s.setState(c, StateIdle)</code></span>
<span class="codeline" id="line-2482"><code>		ctx.userValues.Reset()</code></span>
<span class="codeline" id="line-2483"><code>		ctx.Request.Reset()</code></span>
<span class="codeline" id="line-2484"><code>		ctx.Response.Reset()</code></span>
<span class="codeline" id="line-2485"><code></code></span>
<span class="codeline" id="line-2486"><code>		if atomic.LoadInt32(&amp;s.stop) == 1 {</code></span>
<span class="codeline" id="line-2487"><code>			err = nil</code></span>
<span class="codeline" id="line-2488"><code>			break</code></span>
<span class="codeline" id="line-2489"><code>		}</code></span>
<span class="codeline" id="line-2490"><code>	}</code></span>
<span class="codeline" id="line-2491"><code></code></span>
<span class="codeline" id="line-2492"><code>	if br != nil {</code></span>
<span class="codeline" id="line-2493"><code>		releaseReader(s, br)</code></span>
<span class="codeline" id="line-2494"><code>	}</code></span>
<span class="codeline" id="line-2495"><code>	if bw != nil {</code></span>
<span class="codeline" id="line-2496"><code>		releaseWriter(s, bw)</code></span>
<span class="codeline" id="line-2497"><code>	}</code></span>
<span class="codeline" id="line-2498"><code>	if hijackHandler == nil {</code></span>
<span class="codeline" id="line-2499"><code>		s.releaseCtx(ctx)</code></span>
<span class="codeline" id="line-2500"><code>	}</code></span>
<span class="codeline" id="line-2501"><code></code></span>
<span class="codeline" id="line-2502"><code>	return</code></span>
<span class="codeline" id="line-2503"><code>}</code></span>
<span class="codeline" id="line-2504"><code></code></span>
<span class="codeline" id="line-2505"><code>func (s *Server) setState(nc net.Conn, state ConnState) {</code></span>
<span class="codeline" id="line-2506"><code>	s.trackConn(nc, state)</code></span>
<span class="codeline" id="line-2507"><code>	if hook := s.ConnState; hook != nil {</code></span>
<span class="codeline" id="line-2508"><code>		hook(nc, state)</code></span>
<span class="codeline" id="line-2509"><code>	}</code></span>
<span class="codeline" id="line-2510"><code>}</code></span>
<span class="codeline" id="line-2511"><code></code></span>
<span class="codeline" id="line-2512"><code>func hijackConnHandler(ctx *RequestCtx, r io.Reader, c net.Conn, s *Server, h HijackHandler) {</code></span>
<span class="codeline" id="line-2513"><code>	hjc := s.acquireHijackConn(r, c)</code></span>
<span class="codeline" id="line-2514"><code>	h(hjc)</code></span>
<span class="codeline" id="line-2515"><code></code></span>
<span class="codeline" id="line-2516"><code>	if br, ok := r.(*bufio.Reader); ok {</code></span>
<span class="codeline" id="line-2517"><code>		releaseReader(s, br)</code></span>
<span class="codeline" id="line-2518"><code>	}</code></span>
<span class="codeline" id="line-2519"><code>	if !s.KeepHijackedConns {</code></span>
<span class="codeline" id="line-2520"><code>		c.Close()</code></span>
<span class="codeline" id="line-2521"><code>		s.releaseHijackConn(hjc)</code></span>
<span class="codeline" id="line-2522"><code>	}</code></span>
<span class="codeline" id="line-2523"><code>	s.releaseCtx(ctx)</code></span>
<span class="codeline" id="line-2524"><code>}</code></span>
<span class="codeline" id="line-2525"><code></code></span>
<span class="codeline" id="line-2526"><code>func (s *Server) acquireHijackConn(r io.Reader, c net.Conn) *hijackConn {</code></span>
<span class="codeline" id="line-2527"><code>	v := s.hijackConnPool.Get()</code></span>
<span class="codeline" id="line-2528"><code>	if v == nil {</code></span>
<span class="codeline" id="line-2529"><code>		hjc := &amp;hijackConn{</code></span>
<span class="codeline" id="line-2530"><code>			Conn: c,</code></span>
<span class="codeline" id="line-2531"><code>			r:    r,</code></span>
<span class="codeline" id="line-2532"><code>			s:    s,</code></span>
<span class="codeline" id="line-2533"><code>		}</code></span>
<span class="codeline" id="line-2534"><code>		return hjc</code></span>
<span class="codeline" id="line-2535"><code>	}</code></span>
<span class="codeline" id="line-2536"><code>	hjc := v.(*hijackConn)</code></span>
<span class="codeline" id="line-2537"><code>	hjc.Conn = c</code></span>
<span class="codeline" id="line-2538"><code>	hjc.r = r</code></span>
<span class="codeline" id="line-2539"><code>	return hjc</code></span>
<span class="codeline" id="line-2540"><code>}</code></span>
<span class="codeline" id="line-2541"><code></code></span>
<span class="codeline" id="line-2542"><code>func (s *Server) releaseHijackConn(hjc *hijackConn) {</code></span>
<span class="codeline" id="line-2543"><code>	hjc.Conn = nil</code></span>
<span class="codeline" id="line-2544"><code>	hjc.r = nil</code></span>
<span class="codeline" id="line-2545"><code>	s.hijackConnPool.Put(hjc)</code></span>
<span class="codeline" id="line-2546"><code>}</code></span>
<span class="codeline" id="line-2547"><code></code></span>
<span class="codeline" id="line-2548"><code>type hijackConn struct {</code></span>
<span class="codeline" id="line-2549"><code>	net.Conn</code></span>
<span class="codeline" id="line-2550"><code>	r io.Reader</code></span>
<span class="codeline" id="line-2551"><code>	s *Server</code></span>
<span class="codeline" id="line-2552"><code>}</code></span>
<span class="codeline" id="line-2553"><code></code></span>
<span class="codeline" id="line-2554"><code>func (c *hijackConn) UnsafeConn() net.Conn {</code></span>
<span class="codeline" id="line-2555"><code>	return c.Conn</code></span>
<span class="codeline" id="line-2556"><code>}</code></span>
<span class="codeline" id="line-2557"><code></code></span>
<span class="codeline" id="line-2558"><code>func (c *hijackConn) Read(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-2559"><code>	return c.r.Read(p)</code></span>
<span class="codeline" id="line-2560"><code>}</code></span>
<span class="codeline" id="line-2561"><code></code></span>
<span class="codeline" id="line-2562"><code>func (c *hijackConn) Close() error {</code></span>
<span class="codeline" id="line-2563"><code>	if !c.s.KeepHijackedConns {</code></span>
<span class="codeline" id="line-2564"><code>		// when we do not keep hijacked connections,</code></span>
<span class="codeline" id="line-2565"><code>		// it is closed in hijackConnHandler.</code></span>
<span class="codeline" id="line-2566"><code>		return nil</code></span>
<span class="codeline" id="line-2567"><code>	}</code></span>
<span class="codeline" id="line-2568"><code></code></span>
<span class="codeline" id="line-2569"><code>	return c.Conn.Close()</code></span>
<span class="codeline" id="line-2570"><code>}</code></span>
<span class="codeline" id="line-2571"><code></code></span>
<span class="codeline" id="line-2572"><code>// LastTimeoutErrorResponse returns the last timeout response set</code></span>
<span class="codeline" id="line-2573"><code>// via TimeoutError* call.</code></span>
<span class="codeline" id="line-2574"><code>//</code></span>
<span class="codeline" id="line-2575"><code>// This function is intended for custom server implementations.</code></span>
<span class="codeline" id="line-2576"><code>func (ctx *RequestCtx) LastTimeoutErrorResponse() *Response {</code></span>
<span class="codeline" id="line-2577"><code>	return ctx.timeoutResponse</code></span>
<span class="codeline" id="line-2578"><code>}</code></span>
<span class="codeline" id="line-2579"><code></code></span>
<span class="codeline" id="line-2580"><code>func writeResponse(ctx *RequestCtx, w *bufio.Writer) error {</code></span>
<span class="codeline" id="line-2581"><code>	if ctx.timeoutResponse != nil {</code></span>
<span class="codeline" id="line-2582"><code>		return errors.New("cannot write timed out response")</code></span>
<span class="codeline" id="line-2583"><code>	}</code></span>
<span class="codeline" id="line-2584"><code>	err := ctx.Response.Write(w)</code></span>
<span class="codeline" id="line-2585"><code></code></span>
<span class="codeline" id="line-2586"><code>	return err</code></span>
<span class="codeline" id="line-2587"><code>}</code></span>
<span class="codeline" id="line-2588"><code></code></span>
<span class="codeline" id="line-2589"><code>const (</code></span>
<span class="codeline" id="line-2590"><code>	defaultReadBufferSize  = 4096</code></span>
<span class="codeline" id="line-2591"><code>	defaultWriteBufferSize = 4096</code></span>
<span class="codeline" id="line-2592"><code>)</code></span>
<span class="codeline" id="line-2593"><code></code></span>
<span class="codeline" id="line-2594"><code>func acquireByteReader(ctxP **RequestCtx) (*bufio.Reader, error) {</code></span>
<span class="codeline" id="line-2595"><code>	ctx := *ctxP</code></span>
<span class="codeline" id="line-2596"><code>	s := ctx.s</code></span>
<span class="codeline" id="line-2597"><code>	c := ctx.c</code></span>
<span class="codeline" id="line-2598"><code>	s.releaseCtx(ctx)</code></span>
<span class="codeline" id="line-2599"><code></code></span>
<span class="codeline" id="line-2600"><code>	//nolint:wastedassign // Make GC happy, so it could garbage collect ctx while we wait for the</code></span>
<span class="codeline" id="line-2601"><code>	// next request.</code></span>
<span class="codeline" id="line-2602"><code>	ctx = nil</code></span>
<span class="codeline" id="line-2603"><code>	*ctxP = nil</code></span>
<span class="codeline" id="line-2604"><code></code></span>
<span class="codeline" id="line-2605"><code>	var b [1]byte</code></span>
<span class="codeline" id="line-2606"><code>	n, err := c.Read(b[:])</code></span>
<span class="codeline" id="line-2607"><code></code></span>
<span class="codeline" id="line-2608"><code>	ctx = s.acquireCtx(c)</code></span>
<span class="codeline" id="line-2609"><code>	*ctxP = ctx</code></span>
<span class="codeline" id="line-2610"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2611"><code>		// Treat all errors as EOF on unsuccessful read</code></span>
<span class="codeline" id="line-2612"><code>		// of the first request byte.</code></span>
<span class="codeline" id="line-2613"><code>		return nil, io.EOF</code></span>
<span class="codeline" id="line-2614"><code>	}</code></span>
<span class="codeline" id="line-2615"><code>	if n != 1 {</code></span>
<span class="codeline" id="line-2616"><code>		// developer sanity-check</code></span>
<span class="codeline" id="line-2617"><code>		panic("BUG: Reader must return at least one byte")</code></span>
<span class="codeline" id="line-2618"><code>	}</code></span>
<span class="codeline" id="line-2619"><code></code></span>
<span class="codeline" id="line-2620"><code>	ctx.fbr.c = c</code></span>
<span class="codeline" id="line-2621"><code>	ctx.fbr.ch = b[0]</code></span>
<span class="codeline" id="line-2622"><code>	ctx.fbr.byteRead = false</code></span>
<span class="codeline" id="line-2623"><code>	r := acquireReader(ctx)</code></span>
<span class="codeline" id="line-2624"><code>	r.Reset(&amp;ctx.fbr)</code></span>
<span class="codeline" id="line-2625"><code>	return r, nil</code></span>
<span class="codeline" id="line-2626"><code>}</code></span>
<span class="codeline" id="line-2627"><code></code></span>
<span class="codeline" id="line-2628"><code>func acquireReader(ctx *RequestCtx) *bufio.Reader {</code></span>
<span class="codeline" id="line-2629"><code>	v := ctx.s.readerPool.Get()</code></span>
<span class="codeline" id="line-2630"><code>	if v == nil {</code></span>
<span class="codeline" id="line-2631"><code>		n := ctx.s.ReadBufferSize</code></span>
<span class="codeline" id="line-2632"><code>		if n &lt;= 0 {</code></span>
<span class="codeline" id="line-2633"><code>			n = defaultReadBufferSize</code></span>
<span class="codeline" id="line-2634"><code>		}</code></span>
<span class="codeline" id="line-2635"><code>		return bufio.NewReaderSize(ctx.c, n)</code></span>
<span class="codeline" id="line-2636"><code>	}</code></span>
<span class="codeline" id="line-2637"><code>	r := v.(*bufio.Reader)</code></span>
<span class="codeline" id="line-2638"><code>	r.Reset(ctx.c)</code></span>
<span class="codeline" id="line-2639"><code>	return r</code></span>
<span class="codeline" id="line-2640"><code>}</code></span>
<span class="codeline" id="line-2641"><code></code></span>
<span class="codeline" id="line-2642"><code>func releaseReader(s *Server, r *bufio.Reader) {</code></span>
<span class="codeline" id="line-2643"><code>	s.readerPool.Put(r)</code></span>
<span class="codeline" id="line-2644"><code>}</code></span>
<span class="codeline" id="line-2645"><code></code></span>
<span class="codeline" id="line-2646"><code>func acquireWriter(ctx *RequestCtx) *bufio.Writer {</code></span>
<span class="codeline" id="line-2647"><code>	v := ctx.s.writerPool.Get()</code></span>
<span class="codeline" id="line-2648"><code>	if v == nil {</code></span>
<span class="codeline" id="line-2649"><code>		n := ctx.s.WriteBufferSize</code></span>
<span class="codeline" id="line-2650"><code>		if n &lt;= 0 {</code></span>
<span class="codeline" id="line-2651"><code>			n = defaultWriteBufferSize</code></span>
<span class="codeline" id="line-2652"><code>		}</code></span>
<span class="codeline" id="line-2653"><code>		return bufio.NewWriterSize(ctx.c, n)</code></span>
<span class="codeline" id="line-2654"><code>	}</code></span>
<span class="codeline" id="line-2655"><code>	w := v.(*bufio.Writer)</code></span>
<span class="codeline" id="line-2656"><code>	w.Reset(ctx.c)</code></span>
<span class="codeline" id="line-2657"><code>	return w</code></span>
<span class="codeline" id="line-2658"><code>}</code></span>
<span class="codeline" id="line-2659"><code></code></span>
<span class="codeline" id="line-2660"><code>func releaseWriter(s *Server, w *bufio.Writer) {</code></span>
<span class="codeline" id="line-2661"><code>	s.writerPool.Put(w)</code></span>
<span class="codeline" id="line-2662"><code>}</code></span>
<span class="codeline" id="line-2663"><code></code></span>
<span class="codeline" id="line-2664"><code>func (s *Server) acquireCtx(c net.Conn) (ctx *RequestCtx) {</code></span>
<span class="codeline" id="line-2665"><code>	v := s.ctxPool.Get()</code></span>
<span class="codeline" id="line-2666"><code>	if v == nil {</code></span>
<span class="codeline" id="line-2667"><code>		keepBodyBuffer := !s.ReduceMemoryUsage</code></span>
<span class="codeline" id="line-2668"><code></code></span>
<span class="codeline" id="line-2669"><code>		ctx = new(RequestCtx)</code></span>
<span class="codeline" id="line-2670"><code>		ctx.Request.keepBodyBuffer = keepBodyBuffer</code></span>
<span class="codeline" id="line-2671"><code>		ctx.Response.keepBodyBuffer = keepBodyBuffer</code></span>
<span class="codeline" id="line-2672"><code>		ctx.s = s</code></span>
<span class="codeline" id="line-2673"><code>	} else {</code></span>
<span class="codeline" id="line-2674"><code>		ctx = v.(*RequestCtx)</code></span>
<span class="codeline" id="line-2675"><code>	}</code></span>
<span class="codeline" id="line-2676"><code>	if s.FormValueFunc != nil {</code></span>
<span class="codeline" id="line-2677"><code>		ctx.formValueFunc = s.FormValueFunc</code></span>
<span class="codeline" id="line-2678"><code>	}</code></span>
<span class="codeline" id="line-2679"><code>	ctx.c = c</code></span>
<span class="codeline" id="line-2680"><code></code></span>
<span class="codeline" id="line-2681"><code>	return ctx</code></span>
<span class="codeline" id="line-2682"><code>}</code></span>
<span class="codeline" id="line-2683"><code></code></span>
<span class="codeline" id="line-2684"><code>// Init2 prepares ctx for passing to RequestHandler.</code></span>
<span class="codeline" id="line-2685"><code>//</code></span>
<span class="codeline" id="line-2686"><code>// conn is used only for determining local and remote addresses.</code></span>
<span class="codeline" id="line-2687"><code>//</code></span>
<span class="codeline" id="line-2688"><code>// This function is intended for custom Server implementations.</code></span>
<span class="codeline" id="line-2689"><code>// See https://github.com/valyala/httpteleport for details.</code></span>
<span class="codeline" id="line-2690"><code>func (ctx *RequestCtx) Init2(conn net.Conn, logger Logger, reduceMemoryUsage bool) {</code></span>
<span class="codeline" id="line-2691"><code>	ctx.c = conn</code></span>
<span class="codeline" id="line-2692"><code>	ctx.remoteAddr = nil</code></span>
<span class="codeline" id="line-2693"><code>	ctx.logger.logger = logger</code></span>
<span class="codeline" id="line-2694"><code>	ctx.connID = nextConnID()</code></span>
<span class="codeline" id="line-2695"><code>	ctx.s = fakeServer</code></span>
<span class="codeline" id="line-2696"><code>	ctx.connRequestNum = 0</code></span>
<span class="codeline" id="line-2697"><code>	ctx.connTime = time.Now()</code></span>
<span class="codeline" id="line-2698"><code></code></span>
<span class="codeline" id="line-2699"><code>	keepBodyBuffer := !reduceMemoryUsage</code></span>
<span class="codeline" id="line-2700"><code>	ctx.Request.keepBodyBuffer = keepBodyBuffer</code></span>
<span class="codeline" id="line-2701"><code>	ctx.Response.keepBodyBuffer = keepBodyBuffer</code></span>
<span class="codeline" id="line-2702"><code>}</code></span>
<span class="codeline" id="line-2703"><code></code></span>
<span class="codeline" id="line-2704"><code>// Init prepares ctx for passing to RequestHandler.</code></span>
<span class="codeline" id="line-2705"><code>//</code></span>
<span class="codeline" id="line-2706"><code>// remoteAddr and logger are optional. They are used by RequestCtx.Logger().</code></span>
<span class="codeline" id="line-2707"><code>//</code></span>
<span class="codeline" id="line-2708"><code>// This function is intended for custom Server implementations.</code></span>
<span class="codeline" id="line-2709"><code>func (ctx *RequestCtx) Init(req *Request, remoteAddr net.Addr, logger Logger) {</code></span>
<span class="codeline" id="line-2710"><code>	if remoteAddr == nil {</code></span>
<span class="codeline" id="line-2711"><code>		remoteAddr = zeroTCPAddr</code></span>
<span class="codeline" id="line-2712"><code>	}</code></span>
<span class="codeline" id="line-2713"><code>	c := &amp;fakeAddrer{</code></span>
<span class="codeline" id="line-2714"><code>		laddr: zeroTCPAddr,</code></span>
<span class="codeline" id="line-2715"><code>		raddr: remoteAddr,</code></span>
<span class="codeline" id="line-2716"><code>	}</code></span>
<span class="codeline" id="line-2717"><code>	if logger == nil {</code></span>
<span class="codeline" id="line-2718"><code>		logger = defaultLogger</code></span>
<span class="codeline" id="line-2719"><code>	}</code></span>
<span class="codeline" id="line-2720"><code>	ctx.Init2(c, logger, true)</code></span>
<span class="codeline" id="line-2721"><code>	req.CopyTo(&amp;ctx.Request)</code></span>
<span class="codeline" id="line-2722"><code>}</code></span>
<span class="codeline" id="line-2723"><code></code></span>
<span class="codeline" id="line-2724"><code>// Deadline returns the time when work done on behalf of this context</code></span>
<span class="codeline" id="line-2725"><code>// should be canceled. Deadline returns ok==false when no deadline is</code></span>
<span class="codeline" id="line-2726"><code>// set. Successive calls to Deadline return the same results.</code></span>
<span class="codeline" id="line-2727"><code>//</code></span>
<span class="codeline" id="line-2728"><code>// This method always returns 0, false and is only present to make</code></span>
<span class="codeline" id="line-2729"><code>// RequestCtx implement the context interface.</code></span>
<span class="codeline" id="line-2730"><code>func (ctx *RequestCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-2731"><code>	return</code></span>
<span class="codeline" id="line-2732"><code>}</code></span>
<span class="codeline" id="line-2733"><code></code></span>
<span class="codeline" id="line-2734"><code>// Done returns a channel that's closed when work done on behalf of this</code></span>
<span class="codeline" id="line-2735"><code>// context should be canceled. Done may return nil if this context can</code></span>
<span class="codeline" id="line-2736"><code>// never be canceled. Successive calls to Done return the same value.</code></span>
<span class="codeline" id="line-2737"><code>//</code></span>
<span class="codeline" id="line-2738"><code>// Note: Because creating a new channel for every request is just too expensive, so</code></span>
<span class="codeline" id="line-2739"><code>// RequestCtx.s.done is only closed when the server is shutting down.</code></span>
<span class="codeline" id="line-2740"><code>func (ctx *RequestCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-2741"><code>	return ctx.s.done</code></span>
<span class="codeline" id="line-2742"><code>}</code></span>
<span class="codeline" id="line-2743"><code></code></span>
<span class="codeline" id="line-2744"><code>// Err returns a non-nil error value after Done is closed,</code></span>
<span class="codeline" id="line-2745"><code>// successive calls to Err return the same error.</code></span>
<span class="codeline" id="line-2746"><code>// If Done is not yet closed, Err returns nil.</code></span>
<span class="codeline" id="line-2747"><code>// If Done is closed, Err returns a non-nil error explaining why:</code></span>
<span class="codeline" id="line-2748"><code>// Canceled if the context was canceled (via server Shutdown)</code></span>
<span class="codeline" id="line-2749"><code>// or DeadlineExceeded if the context's deadline passed.</code></span>
<span class="codeline" id="line-2750"><code>//</code></span>
<span class="codeline" id="line-2751"><code>// Note: Because creating a new channel for every request is just too expensive, so</code></span>
<span class="codeline" id="line-2752"><code>// RequestCtx.s.done is only closed when the server is shutting down.</code></span>
<span class="codeline" id="line-2753"><code>func (ctx *RequestCtx) Err() error {</code></span>
<span class="codeline" id="line-2754"><code>	select {</code></span>
<span class="codeline" id="line-2755"><code>	case &lt;-ctx.s.done:</code></span>
<span class="codeline" id="line-2756"><code>		return context.Canceled</code></span>
<span class="codeline" id="line-2757"><code>	default:</code></span>
<span class="codeline" id="line-2758"><code>		return nil</code></span>
<span class="codeline" id="line-2759"><code>	}</code></span>
<span class="codeline" id="line-2760"><code>}</code></span>
<span class="codeline" id="line-2761"><code></code></span>
<span class="codeline" id="line-2762"><code>// Value returns the value associated with this context for key, or nil</code></span>
<span class="codeline" id="line-2763"><code>// if no value is associated with key. Successive calls to Value with</code></span>
<span class="codeline" id="line-2764"><code>// the same key returns the same result.</code></span>
<span class="codeline" id="line-2765"><code>//</code></span>
<span class="codeline" id="line-2766"><code>// This method is present to make RequestCtx implement the context interface.</code></span>
<span class="codeline" id="line-2767"><code>// This method is the same as calling ctx.UserValue(key).</code></span>
<span class="codeline" id="line-2768"><code>func (ctx *RequestCtx) Value(key any) any {</code></span>
<span class="codeline" id="line-2769"><code>	return ctx.UserValue(key)</code></span>
<span class="codeline" id="line-2770"><code>}</code></span>
<span class="codeline" id="line-2771"><code></code></span>
<span class="codeline" id="line-2772"><code>var fakeServer = &amp;Server{</code></span>
<span class="codeline" id="line-2773"><code>	// Initialize concurrencyCh for TimeoutHandler</code></span>
<span class="codeline" id="line-2774"><code>	concurrencyCh: make(chan struct{}, DefaultConcurrency),</code></span>
<span class="codeline" id="line-2775"><code>}</code></span>
<span class="codeline" id="line-2776"><code></code></span>
<span class="codeline" id="line-2777"><code>type fakeAddrer struct {</code></span>
<span class="codeline" id="line-2778"><code>	net.Conn</code></span>
<span class="codeline" id="line-2779"><code>	laddr net.Addr</code></span>
<span class="codeline" id="line-2780"><code>	raddr net.Addr</code></span>
<span class="codeline" id="line-2781"><code>}</code></span>
<span class="codeline" id="line-2782"><code></code></span>
<span class="codeline" id="line-2783"><code>func (fa *fakeAddrer) RemoteAddr() net.Addr {</code></span>
<span class="codeline" id="line-2784"><code>	return fa.raddr</code></span>
<span class="codeline" id="line-2785"><code>}</code></span>
<span class="codeline" id="line-2786"><code></code></span>
<span class="codeline" id="line-2787"><code>func (fa *fakeAddrer) LocalAddr() net.Addr {</code></span>
<span class="codeline" id="line-2788"><code>	return fa.laddr</code></span>
<span class="codeline" id="line-2789"><code>}</code></span>
<span class="codeline" id="line-2790"><code></code></span>
<span class="codeline" id="line-2791"><code>func (fa *fakeAddrer) Read(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-2792"><code>	// developer sanity-check</code></span>
<span class="codeline" id="line-2793"><code>	panic("BUG: unexpected Read call")</code></span>
<span class="codeline" id="line-2794"><code>}</code></span>
<span class="codeline" id="line-2795"><code></code></span>
<span class="codeline" id="line-2796"><code>func (fa *fakeAddrer) Write(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-2797"><code>	// developer sanity-check</code></span>
<span class="codeline" id="line-2798"><code>	panic("BUG: unexpected Write call")</code></span>
<span class="codeline" id="line-2799"><code>}</code></span>
<span class="codeline" id="line-2800"><code></code></span>
<span class="codeline" id="line-2801"><code>func (fa *fakeAddrer) Close() error {</code></span>
<span class="codeline" id="line-2802"><code>	// developer sanity-check</code></span>
<span class="codeline" id="line-2803"><code>	panic("BUG: unexpected Close call")</code></span>
<span class="codeline" id="line-2804"><code>}</code></span>
<span class="codeline" id="line-2805"><code></code></span>
<span class="codeline" id="line-2806"><code>func (s *Server) releaseCtx(ctx *RequestCtx) {</code></span>
<span class="codeline" id="line-2807"><code>	if ctx.timeoutResponse != nil {</code></span>
<span class="codeline" id="line-2808"><code>		// developer sanity-check</code></span>
<span class="codeline" id="line-2809"><code>		panic("BUG: cannot release timed out RequestCtx")</code></span>
<span class="codeline" id="line-2810"><code>	}</code></span>
<span class="codeline" id="line-2811"><code></code></span>
<span class="codeline" id="line-2812"><code>	ctx.reset()</code></span>
<span class="codeline" id="line-2813"><code>	s.ctxPool.Put(ctx)</code></span>
<span class="codeline" id="line-2814"><code>}</code></span>
<span class="codeline" id="line-2815"><code></code></span>
<span class="codeline" id="line-2816"><code>func (s *Server) getServerName() string {</code></span>
<span class="codeline" id="line-2817"><code>	serverName := s.Name</code></span>
<span class="codeline" id="line-2818"><code>	if serverName == "" {</code></span>
<span class="codeline" id="line-2819"><code>		if !s.NoDefaultServerHeader {</code></span>
<span class="codeline" id="line-2820"><code>			serverName = defaultServerName</code></span>
<span class="codeline" id="line-2821"><code>		}</code></span>
<span class="codeline" id="line-2822"><code>	}</code></span>
<span class="codeline" id="line-2823"><code>	return serverName</code></span>
<span class="codeline" id="line-2824"><code>}</code></span>
<span class="codeline" id="line-2825"><code></code></span>
<span class="codeline" id="line-2826"><code>func (s *Server) writeFastError(w io.Writer, statusCode int, msg string) {</code></span>
<span class="codeline" id="line-2827"><code>	w.Write(formatStatusLine(nil, strHTTP11, statusCode, s2b(StatusMessage(statusCode)))) //nolint:errcheck</code></span>
<span class="codeline" id="line-2828"><code></code></span>
<span class="codeline" id="line-2829"><code>	server := s.getServerName()</code></span>
<span class="codeline" id="line-2830"><code>	if server != "" {</code></span>
<span class="codeline" id="line-2831"><code>		server = fmt.Sprintf("Server: %s\r\n", server)</code></span>
<span class="codeline" id="line-2832"><code>	}</code></span>
<span class="codeline" id="line-2833"><code>	date := ""</code></span>
<span class="codeline" id="line-2834"><code>	if !s.NoDefaultDate {</code></span>
<span class="codeline" id="line-2835"><code>		serverDateOnce.Do(updateServerDate)</code></span>
<span class="codeline" id="line-2836"><code>		date = fmt.Sprintf("Date: %s\r\n", serverDate.Load())</code></span>
<span class="codeline" id="line-2837"><code>	}</code></span>
<span class="codeline" id="line-2838"><code></code></span>
<span class="codeline" id="line-2839"><code>	fmt.Fprintf(w, "Connection: close\r\n"+</code></span>
<span class="codeline" id="line-2840"><code>		server+</code></span>
<span class="codeline" id="line-2841"><code>		date+</code></span>
<span class="codeline" id="line-2842"><code>		"Content-Type: text/plain\r\n"+</code></span>
<span class="codeline" id="line-2843"><code>		"Content-Length: %d\r\n"+</code></span>
<span class="codeline" id="line-2844"><code>		"\r\n"+</code></span>
<span class="codeline" id="line-2845"><code>		"%s",</code></span>
<span class="codeline" id="line-2846"><code>		len(msg), msg)</code></span>
<span class="codeline" id="line-2847"><code>}</code></span>
<span class="codeline" id="line-2848"><code></code></span>
<span class="codeline" id="line-2849"><code>func defaultErrorHandler(ctx *RequestCtx, err error) {</code></span>
<span class="codeline" id="line-2850"><code>	if _, ok := err.(*ErrSmallBuffer); ok {</code></span>
<span class="codeline" id="line-2851"><code>		ctx.Error("Too big request header", StatusRequestHeaderFieldsTooLarge)</code></span>
<span class="codeline" id="line-2852"><code>	} else if netErr, ok := err.(*net.OpError); ok &amp;&amp; netErr.Timeout() {</code></span>
<span class="codeline" id="line-2853"><code>		ctx.Error("Request timeout", StatusRequestTimeout)</code></span>
<span class="codeline" id="line-2854"><code>	} else {</code></span>
<span class="codeline" id="line-2855"><code>		ctx.Error("Error when parsing request", StatusBadRequest)</code></span>
<span class="codeline" id="line-2856"><code>	}</code></span>
<span class="codeline" id="line-2857"><code>}</code></span>
<span class="codeline" id="line-2858"><code></code></span>
<span class="codeline" id="line-2859"><code>func (s *Server) writeErrorResponse(bw *bufio.Writer, ctx *RequestCtx, serverName string, err error) *bufio.Writer {</code></span>
<span class="codeline" id="line-2860"><code>	errorHandler := defaultErrorHandler</code></span>
<span class="codeline" id="line-2861"><code>	if s.ErrorHandler != nil {</code></span>
<span class="codeline" id="line-2862"><code>		errorHandler = s.ErrorHandler</code></span>
<span class="codeline" id="line-2863"><code>	}</code></span>
<span class="codeline" id="line-2864"><code></code></span>
<span class="codeline" id="line-2865"><code>	errorHandler(ctx, err)</code></span>
<span class="codeline" id="line-2866"><code></code></span>
<span class="codeline" id="line-2867"><code>	if serverName != "" {</code></span>
<span class="codeline" id="line-2868"><code>		ctx.Response.Header.SetServer(serverName)</code></span>
<span class="codeline" id="line-2869"><code>	}</code></span>
<span class="codeline" id="line-2870"><code>	ctx.SetConnectionClose()</code></span>
<span class="codeline" id="line-2871"><code>	if bw == nil {</code></span>
<span class="codeline" id="line-2872"><code>		bw = acquireWriter(ctx)</code></span>
<span class="codeline" id="line-2873"><code>	}</code></span>
<span class="codeline" id="line-2874"><code></code></span>
<span class="codeline" id="line-2875"><code>	writeResponse(ctx, bw) //nolint:errcheck</code></span>
<span class="codeline" id="line-2876"><code>	ctx.Response.Reset()</code></span>
<span class="codeline" id="line-2877"><code>	bw.Flush()</code></span>
<span class="codeline" id="line-2878"><code></code></span>
<span class="codeline" id="line-2879"><code>	return bw</code></span>
<span class="codeline" id="line-2880"><code>}</code></span>
<span class="codeline" id="line-2881"><code></code></span>
<span class="codeline" id="line-2882"><code>func (s *Server) trackConn(c net.Conn, state ConnState) {</code></span>
<span class="codeline" id="line-2883"><code>	s.idleConnsMu.Lock()</code></span>
<span class="codeline" id="line-2884"><code>	switch state {</code></span>
<span class="codeline" id="line-2885"><code>	case StateIdle:</code></span>
<span class="codeline" id="line-2886"><code>		if s.idleConns == nil {</code></span>
<span class="codeline" id="line-2887"><code>			s.idleConns = make(map[net.Conn]time.Time)</code></span>
<span class="codeline" id="line-2888"><code>		}</code></span>
<span class="codeline" id="line-2889"><code>		s.idleConns[c] = time.Now()</code></span>
<span class="codeline" id="line-2890"><code>	case StateNew:</code></span>
<span class="codeline" id="line-2891"><code>		if s.idleConns == nil {</code></span>
<span class="codeline" id="line-2892"><code>			s.idleConns = make(map[net.Conn]time.Time)</code></span>
<span class="codeline" id="line-2893"><code>		}</code></span>
<span class="codeline" id="line-2894"><code>		// Count the connection as Idle after 5 seconds.</code></span>
<span class="codeline" id="line-2895"><code>		// Same as net/http.Server:</code></span>
<span class="codeline" id="line-2896"><code>		// https://github.com/golang/go/blob/85d7bab91d9a3ed1f76842e4328973ea75efef54/src/net/http/server.go#L2834-L2836</code></span>
<span class="codeline" id="line-2897"><code>		s.idleConns[c] = time.Now().Add(time.Second * 5)</code></span>
<span class="codeline" id="line-2898"><code></code></span>
<span class="codeline" id="line-2899"><code>	default:</code></span>
<span class="codeline" id="line-2900"><code>		delete(s.idleConns, c)</code></span>
<span class="codeline" id="line-2901"><code>	}</code></span>
<span class="codeline" id="line-2902"><code>	s.idleConnsMu.Unlock()</code></span>
<span class="codeline" id="line-2903"><code>}</code></span>
<span class="codeline" id="line-2904"><code></code></span>
<span class="codeline" id="line-2905"><code>func (s *Server) closeIdleConns() {</code></span>
<span class="codeline" id="line-2906"><code>	s.idleConnsMu.Lock()</code></span>
<span class="codeline" id="line-2907"><code>	now := time.Now()</code></span>
<span class="codeline" id="line-2908"><code>	for c, t := range s.idleConns {</code></span>
<span class="codeline" id="line-2909"><code>		if now.Sub(t) &gt;= 0 {</code></span>
<span class="codeline" id="line-2910"><code>			_ = c.Close()</code></span>
<span class="codeline" id="line-2911"><code>			delete(s.idleConns, c)</code></span>
<span class="codeline" id="line-2912"><code>		}</code></span>
<span class="codeline" id="line-2913"><code>	}</code></span>
<span class="codeline" id="line-2914"><code>	s.idleConnsMu.Unlock()</code></span>
<span class="codeline" id="line-2915"><code>}</code></span>
<span class="codeline" id="line-2916"><code></code></span>
<span class="codeline" id="line-2917"><code>// A ConnState represents the state of a client connection to a server.</code></span>
<span class="codeline" id="line-2918"><code>// It's used by the optional Server.ConnState hook.</code></span>
<span class="codeline" id="line-2919"><code>type ConnState int</code></span>
<span class="codeline" id="line-2920"><code></code></span>
<span class="codeline" id="line-2921"><code>const (</code></span>
<span class="codeline" id="line-2922"><code>	// StateNew represents a new connection that is expected to</code></span>
<span class="codeline" id="line-2923"><code>	// send a request immediately. Connections begin at this</code></span>
<span class="codeline" id="line-2924"><code>	// state and then transition to either StateActive or</code></span>
<span class="codeline" id="line-2925"><code>	// StateClosed.</code></span>
<span class="codeline" id="line-2926"><code>	StateNew ConnState = iota</code></span>
<span class="codeline" id="line-2927"><code></code></span>
<span class="codeline" id="line-2928"><code>	// StateActive represents a connection that has read 1 or more</code></span>
<span class="codeline" id="line-2929"><code>	// bytes of a request. The Server.ConnState hook for</code></span>
<span class="codeline" id="line-2930"><code>	// StateActive fires before the request has entered a handler</code></span>
<span class="codeline" id="line-2931"><code>	// and doesn't fire again until the request has been</code></span>
<span class="codeline" id="line-2932"><code>	// handled. After the request is handled, the state</code></span>
<span class="codeline" id="line-2933"><code>	// transitions to StateClosed, StateHijacked, or StateIdle.</code></span>
<span class="codeline" id="line-2934"><code>	// For HTTP/2, StateActive fires on the transition from zero</code></span>
<span class="codeline" id="line-2935"><code>	// to one active request, and only transitions away once all</code></span>
<span class="codeline" id="line-2936"><code>	// active requests are complete. That means that ConnState</code></span>
<span class="codeline" id="line-2937"><code>	// cannot be used to do per-request work; ConnState only notes</code></span>
<span class="codeline" id="line-2938"><code>	// the overall state of the connection.</code></span>
<span class="codeline" id="line-2939"><code>	StateActive</code></span>
<span class="codeline" id="line-2940"><code></code></span>
<span class="codeline" id="line-2941"><code>	// StateIdle represents a connection that has finished</code></span>
<span class="codeline" id="line-2942"><code>	// handling a request and is in the keep-alive state, waiting</code></span>
<span class="codeline" id="line-2943"><code>	// for a new request. Connections transition from StateIdle</code></span>
<span class="codeline" id="line-2944"><code>	// to either StateActive or StateClosed.</code></span>
<span class="codeline" id="line-2945"><code>	StateIdle</code></span>
<span class="codeline" id="line-2946"><code></code></span>
<span class="codeline" id="line-2947"><code>	// StateHijacked represents a hijacked connection.</code></span>
<span class="codeline" id="line-2948"><code>	// This is a terminal state. It does not transition to StateClosed.</code></span>
<span class="codeline" id="line-2949"><code>	StateHijacked</code></span>
<span class="codeline" id="line-2950"><code></code></span>
<span class="codeline" id="line-2951"><code>	// StateClosed represents a closed connection.</code></span>
<span class="codeline" id="line-2952"><code>	// This is a terminal state. Hijacked connections do not</code></span>
<span class="codeline" id="line-2953"><code>	// transition to StateClosed.</code></span>
<span class="codeline" id="line-2954"><code>	StateClosed</code></span>
<span class="codeline" id="line-2955"><code>)</code></span>
<span class="codeline" id="line-2956"><code></code></span>
<span class="codeline" id="line-2957"><code>var stateName = map[ConnState]string{</code></span>
<span class="codeline" id="line-2958"><code>	StateNew:      "new",</code></span>
<span class="codeline" id="line-2959"><code>	StateActive:   "active",</code></span>
<span class="codeline" id="line-2960"><code>	StateIdle:     "idle",</code></span>
<span class="codeline" id="line-2961"><code>	StateHijacked: "hijacked",</code></span>
<span class="codeline" id="line-2962"><code>	StateClosed:   "closed",</code></span>
<span class="codeline" id="line-2963"><code>}</code></span>
<span class="codeline" id="line-2964"><code></code></span>
<span class="codeline" id="line-2965"><code>func (c ConnState) String() string {</code></span>
<span class="codeline" id="line-2966"><code>	return stateName[c]</code></span>
<span class="codeline" id="line-2967"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>