<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: values.go in package github.com/go-openapi/validate</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	values.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/go-openapi/validate.html">github.com/go-openapi/validate</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2015 go-swagger maintainers</code></span>
<span class="codeline" id="line-2"><code>//</code></span>
<span class="codeline" id="line-3"><code>// Licensed under the Apache License, Version 2.0 (the "License");</code></span>
<span class="codeline" id="line-4"><code>// you may not use this file except in compliance with the License.</code></span>
<span class="codeline" id="line-5"><code>// You may obtain a copy of the License at</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>//    http://www.apache.org/licenses/LICENSE-2.0</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// Unless required by applicable law or agreed to in writing, software</code></span>
<span class="codeline" id="line-10"><code>// distributed under the License is distributed on an "AS IS" BASIS,</code></span>
<span class="codeline" id="line-11"><code>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</code></span>
<span class="codeline" id="line-12"><code>// See the License for the specific language governing permissions and</code></span>
<span class="codeline" id="line-13"><code>// limitations under the License.</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>package validate</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>import (</code></span>
<span class="codeline" id="line-18"><code>	"context"</code></span>
<span class="codeline" id="line-19"><code>	"fmt"</code></span>
<span class="codeline" id="line-20"><code>	"reflect"</code></span>
<span class="codeline" id="line-21"><code>	"strings"</code></span>
<span class="codeline" id="line-22"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>	"github.com/go-openapi/errors"</code></span>
<span class="codeline" id="line-25"><code>	"github.com/go-openapi/strfmt"</code></span>
<span class="codeline" id="line-26"><code>	"github.com/go-openapi/swag"</code></span>
<span class="codeline" id="line-27"><code>)</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// Enum validates if the data is a member of the enum</code></span>
<span class="codeline" id="line-30"><code>func Enum(path, in string, data interface{}, enum interface{}) *errors.Validation {</code></span>
<span class="codeline" id="line-31"><code>	return EnumCase(path, in, data, enum, true)</code></span>
<span class="codeline" id="line-32"><code>}</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// EnumCase validates if the data is a member of the enum and may respect case-sensitivity for strings</code></span>
<span class="codeline" id="line-35"><code>func EnumCase(path, in string, data interface{}, enum interface{}, caseSensitive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-36"><code>	val := reflect.ValueOf(enum)</code></span>
<span class="codeline" id="line-37"><code>	if val.Kind() != reflect.Slice {</code></span>
<span class="codeline" id="line-38"><code>		return nil</code></span>
<span class="codeline" id="line-39"><code>	}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>	dataString := convertEnumCaseStringKind(data, caseSensitive)</code></span>
<span class="codeline" id="line-42"><code>	var values []interface{}</code></span>
<span class="codeline" id="line-43"><code>	for i := 0; i &lt; val.Len(); i++ {</code></span>
<span class="codeline" id="line-44"><code>		ele := val.Index(i)</code></span>
<span class="codeline" id="line-45"><code>		enumValue := ele.Interface()</code></span>
<span class="codeline" id="line-46"><code>		if data != nil {</code></span>
<span class="codeline" id="line-47"><code>			if reflect.DeepEqual(data, enumValue) {</code></span>
<span class="codeline" id="line-48"><code>				return nil</code></span>
<span class="codeline" id="line-49"><code>			}</code></span>
<span class="codeline" id="line-50"><code>			enumString := convertEnumCaseStringKind(enumValue, caseSensitive)</code></span>
<span class="codeline" id="line-51"><code>			if dataString != nil &amp;&amp; enumString != nil &amp;&amp; strings.EqualFold(*dataString, *enumString) {</code></span>
<span class="codeline" id="line-52"><code>				return nil</code></span>
<span class="codeline" id="line-53"><code>			}</code></span>
<span class="codeline" id="line-54"><code>			actualType := reflect.TypeOf(enumValue)</code></span>
<span class="codeline" id="line-55"><code>			if actualType == nil { // Safeguard. Frankly, I don't know how we may get a nil</code></span>
<span class="codeline" id="line-56"><code>				continue</code></span>
<span class="codeline" id="line-57"><code>			}</code></span>
<span class="codeline" id="line-58"><code>			expectedValue := reflect.ValueOf(data)</code></span>
<span class="codeline" id="line-59"><code>			if expectedValue.IsValid() &amp;&amp; expectedValue.Type().ConvertibleTo(actualType) {</code></span>
<span class="codeline" id="line-60"><code>				// Attempt comparison after type conversion</code></span>
<span class="codeline" id="line-61"><code>				if reflect.DeepEqual(expectedValue.Convert(actualType).Interface(), enumValue) {</code></span>
<span class="codeline" id="line-62"><code>					return nil</code></span>
<span class="codeline" id="line-63"><code>				}</code></span>
<span class="codeline" id="line-64"><code>			}</code></span>
<span class="codeline" id="line-65"><code>		}</code></span>
<span class="codeline" id="line-66"><code>		values = append(values, enumValue)</code></span>
<span class="codeline" id="line-67"><code>	}</code></span>
<span class="codeline" id="line-68"><code>	return errors.EnumFail(path, in, data, values)</code></span>
<span class="codeline" id="line-69"><code>}</code></span>
<span class="codeline" id="line-70"><code></code></span>
<span class="codeline" id="line-71"><code>// convertEnumCaseStringKind converts interface if it is kind of string and case insensitivity is set</code></span>
<span class="codeline" id="line-72"><code>func convertEnumCaseStringKind(value interface{}, caseSensitive bool) *string {</code></span>
<span class="codeline" id="line-73"><code>	if caseSensitive {</code></span>
<span class="codeline" id="line-74"><code>		return nil</code></span>
<span class="codeline" id="line-75"><code>	}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>	val := reflect.ValueOf(value)</code></span>
<span class="codeline" id="line-78"><code>	if val.Kind() != reflect.String {</code></span>
<span class="codeline" id="line-79"><code>		return nil</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>	str := fmt.Sprintf("%v", value)</code></span>
<span class="codeline" id="line-83"><code>	return &amp;str</code></span>
<span class="codeline" id="line-84"><code>}</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>// MinItems validates that there are at least n items in a slice</code></span>
<span class="codeline" id="line-87"><code>func MinItems(path, in string, size, min int64) *errors.Validation {</code></span>
<span class="codeline" id="line-88"><code>	if size &lt; min {</code></span>
<span class="codeline" id="line-89"><code>		return errors.TooFewItems(path, in, min, size)</code></span>
<span class="codeline" id="line-90"><code>	}</code></span>
<span class="codeline" id="line-91"><code>	return nil</code></span>
<span class="codeline" id="line-92"><code>}</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>// MaxItems validates that there are at most n items in a slice</code></span>
<span class="codeline" id="line-95"><code>func MaxItems(path, in string, size, max int64) *errors.Validation {</code></span>
<span class="codeline" id="line-96"><code>	if size &gt; max {</code></span>
<span class="codeline" id="line-97"><code>		return errors.TooManyItems(path, in, max, size)</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>	return nil</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>// UniqueItems validates that the provided slice has unique elements</code></span>
<span class="codeline" id="line-103"><code>func UniqueItems(path, in string, data interface{}) *errors.Validation {</code></span>
<span class="codeline" id="line-104"><code>	val := reflect.ValueOf(data)</code></span>
<span class="codeline" id="line-105"><code>	if val.Kind() != reflect.Slice {</code></span>
<span class="codeline" id="line-106"><code>		return nil</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code>	var unique []interface{}</code></span>
<span class="codeline" id="line-109"><code>	for i := 0; i &lt; val.Len(); i++ {</code></span>
<span class="codeline" id="line-110"><code>		v := val.Index(i).Interface()</code></span>
<span class="codeline" id="line-111"><code>		for _, u := range unique {</code></span>
<span class="codeline" id="line-112"><code>			if reflect.DeepEqual(v, u) {</code></span>
<span class="codeline" id="line-113"><code>				return errors.DuplicateItems(path, in)</code></span>
<span class="codeline" id="line-114"><code>			}</code></span>
<span class="codeline" id="line-115"><code>		}</code></span>
<span class="codeline" id="line-116"><code>		unique = append(unique, v)</code></span>
<span class="codeline" id="line-117"><code>	}</code></span>
<span class="codeline" id="line-118"><code>	return nil</code></span>
<span class="codeline" id="line-119"><code>}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>// MinLength validates a string for minimum length</code></span>
<span class="codeline" id="line-122"><code>func MinLength(path, in, data string, minLength int64) *errors.Validation {</code></span>
<span class="codeline" id="line-123"><code>	strLen := int64(utf8.RuneCountInString(data))</code></span>
<span class="codeline" id="line-124"><code>	if strLen &lt; minLength {</code></span>
<span class="codeline" id="line-125"><code>		return errors.TooShort(path, in, minLength, data)</code></span>
<span class="codeline" id="line-126"><code>	}</code></span>
<span class="codeline" id="line-127"><code>	return nil</code></span>
<span class="codeline" id="line-128"><code>}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>// MaxLength validates a string for maximum length</code></span>
<span class="codeline" id="line-131"><code>func MaxLength(path, in, data string, maxLength int64) *errors.Validation {</code></span>
<span class="codeline" id="line-132"><code>	strLen := int64(utf8.RuneCountInString(data))</code></span>
<span class="codeline" id="line-133"><code>	if strLen &gt; maxLength {</code></span>
<span class="codeline" id="line-134"><code>		return errors.TooLong(path, in, maxLength, data)</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code>	return nil</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// ReadOnly validates an interface for readonly</code></span>
<span class="codeline" id="line-140"><code>func ReadOnly(ctx context.Context, path, in string, data interface{}) *errors.Validation {</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	// read only is only validated when operationType is request</code></span>
<span class="codeline" id="line-143"><code>	if op := extractOperationType(ctx); op != request {</code></span>
<span class="codeline" id="line-144"><code>		return nil</code></span>
<span class="codeline" id="line-145"><code>	}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	// data must be of zero value of its type</code></span>
<span class="codeline" id="line-148"><code>	val := reflect.ValueOf(data)</code></span>
<span class="codeline" id="line-149"><code>	if val.IsValid() {</code></span>
<span class="codeline" id="line-150"><code>		if reflect.DeepEqual(reflect.Zero(val.Type()).Interface(), val.Interface()) {</code></span>
<span class="codeline" id="line-151"><code>			return nil</code></span>
<span class="codeline" id="line-152"><code>		}</code></span>
<span class="codeline" id="line-153"><code>	} else {</code></span>
<span class="codeline" id="line-154"><code>		return nil</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>	return errors.ReadOnly(path, in, data)</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// Required validates an interface for requiredness</code></span>
<span class="codeline" id="line-161"><code>func Required(path, in string, data interface{}) *errors.Validation {</code></span>
<span class="codeline" id="line-162"><code>	val := reflect.ValueOf(data)</code></span>
<span class="codeline" id="line-163"><code>	if val.IsValid() {</code></span>
<span class="codeline" id="line-164"><code>		if reflect.DeepEqual(reflect.Zero(val.Type()).Interface(), val.Interface()) {</code></span>
<span class="codeline" id="line-165"><code>			return errors.Required(path, in, data)</code></span>
<span class="codeline" id="line-166"><code>		}</code></span>
<span class="codeline" id="line-167"><code>		return nil</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>	return errors.Required(path, in, data)</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// RequiredString validates a string for requiredness</code></span>
<span class="codeline" id="line-173"><code>func RequiredString(path, in, data string) *errors.Validation {</code></span>
<span class="codeline" id="line-174"><code>	if data == "" {</code></span>
<span class="codeline" id="line-175"><code>		return errors.Required(path, in, data)</code></span>
<span class="codeline" id="line-176"><code>	}</code></span>
<span class="codeline" id="line-177"><code>	return nil</code></span>
<span class="codeline" id="line-178"><code>}</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>// RequiredNumber validates a number for requiredness</code></span>
<span class="codeline" id="line-181"><code>func RequiredNumber(path, in string, data float64) *errors.Validation {</code></span>
<span class="codeline" id="line-182"><code>	if data == 0 {</code></span>
<span class="codeline" id="line-183"><code>		return errors.Required(path, in, data)</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>	return nil</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// Pattern validates a string against a regular expression</code></span>
<span class="codeline" id="line-189"><code>func Pattern(path, in, data, pattern string) *errors.Validation {</code></span>
<span class="codeline" id="line-190"><code>	re, err := compileRegexp(pattern)</code></span>
<span class="codeline" id="line-191"><code>	if err != nil {</code></span>
<span class="codeline" id="line-192"><code>		return errors.FailedPattern(path, in, fmt.Sprintf("%s, but pattern is invalid: %s", pattern, err.Error()), data)</code></span>
<span class="codeline" id="line-193"><code>	}</code></span>
<span class="codeline" id="line-194"><code>	if !re.MatchString(data) {</code></span>
<span class="codeline" id="line-195"><code>		return errors.FailedPattern(path, in, pattern, data)</code></span>
<span class="codeline" id="line-196"><code>	}</code></span>
<span class="codeline" id="line-197"><code>	return nil</code></span>
<span class="codeline" id="line-198"><code>}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>// MaximumInt validates if a number is smaller than a given maximum</code></span>
<span class="codeline" id="line-201"><code>func MaximumInt(path, in string, data, max int64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-202"><code>	if (!exclusive &amp;&amp; data &gt; max) || (exclusive &amp;&amp; data &gt;= max) {</code></span>
<span class="codeline" id="line-203"><code>		return errors.ExceedsMaximumInt(path, in, max, exclusive, data)</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	return nil</code></span>
<span class="codeline" id="line-206"><code>}</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>// MaximumUint validates if a number is smaller than a given maximum</code></span>
<span class="codeline" id="line-209"><code>func MaximumUint(path, in string, data, max uint64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-210"><code>	if (!exclusive &amp;&amp; data &gt; max) || (exclusive &amp;&amp; data &gt;= max) {</code></span>
<span class="codeline" id="line-211"><code>		return errors.ExceedsMaximumUint(path, in, max, exclusive, data)</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code>	return nil</code></span>
<span class="codeline" id="line-214"><code>}</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>// Maximum validates if a number is smaller than a given maximum</code></span>
<span class="codeline" id="line-217"><code>func Maximum(path, in string, data, max float64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-218"><code>	if (!exclusive &amp;&amp; data &gt; max) || (exclusive &amp;&amp; data &gt;= max) {</code></span>
<span class="codeline" id="line-219"><code>		return errors.ExceedsMaximum(path, in, max, exclusive, data)</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code>	return nil</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// Minimum validates if a number is smaller than a given minimum</code></span>
<span class="codeline" id="line-225"><code>func Minimum(path, in string, data, min float64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-226"><code>	if (!exclusive &amp;&amp; data &lt; min) || (exclusive &amp;&amp; data &lt;= min) {</code></span>
<span class="codeline" id="line-227"><code>		return errors.ExceedsMinimum(path, in, min, exclusive, data)</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	return nil</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>// MinimumInt validates if a number is smaller than a given minimum</code></span>
<span class="codeline" id="line-233"><code>func MinimumInt(path, in string, data, min int64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-234"><code>	if (!exclusive &amp;&amp; data &lt; min) || (exclusive &amp;&amp; data &lt;= min) {</code></span>
<span class="codeline" id="line-235"><code>		return errors.ExceedsMinimumInt(path, in, min, exclusive, data)</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code>	return nil</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// MinimumUint validates if a number is smaller than a given minimum</code></span>
<span class="codeline" id="line-241"><code>func MinimumUint(path, in string, data, min uint64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-242"><code>	if (!exclusive &amp;&amp; data &lt; min) || (exclusive &amp;&amp; data &lt;= min) {</code></span>
<span class="codeline" id="line-243"><code>		return errors.ExceedsMinimumUint(path, in, min, exclusive, data)</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	return nil</code></span>
<span class="codeline" id="line-246"><code>}</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>// MultipleOf validates if the provided number is a multiple of the factor</code></span>
<span class="codeline" id="line-249"><code>func MultipleOf(path, in string, data, factor float64) *errors.Validation {</code></span>
<span class="codeline" id="line-250"><code>	// multipleOf factor must be positive</code></span>
<span class="codeline" id="line-251"><code>	if factor &lt;= 0 {</code></span>
<span class="codeline" id="line-252"><code>		return errors.MultipleOfMustBePositive(path, in, factor)</code></span>
<span class="codeline" id="line-253"><code>	}</code></span>
<span class="codeline" id="line-254"><code>	var mult float64</code></span>
<span class="codeline" id="line-255"><code>	if factor &lt; 1 {</code></span>
<span class="codeline" id="line-256"><code>		mult = 1 / factor * data</code></span>
<span class="codeline" id="line-257"><code>	} else {</code></span>
<span class="codeline" id="line-258"><code>		mult = data / factor</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	if !swag.IsFloat64AJSONInteger(mult) {</code></span>
<span class="codeline" id="line-261"><code>		return errors.NotMultipleOf(path, in, factor, data)</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code>	return nil</code></span>
<span class="codeline" id="line-264"><code>}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>// MultipleOfInt validates if the provided integer is a multiple of the factor</code></span>
<span class="codeline" id="line-267"><code>func MultipleOfInt(path, in string, data int64, factor int64) *errors.Validation {</code></span>
<span class="codeline" id="line-268"><code>	// multipleOf factor must be positive</code></span>
<span class="codeline" id="line-269"><code>	if factor &lt;= 0 {</code></span>
<span class="codeline" id="line-270"><code>		return errors.MultipleOfMustBePositive(path, in, factor)</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	mult := data / factor</code></span>
<span class="codeline" id="line-273"><code>	if mult*factor != data {</code></span>
<span class="codeline" id="line-274"><code>		return errors.NotMultipleOf(path, in, factor, data)</code></span>
<span class="codeline" id="line-275"><code>	}</code></span>
<span class="codeline" id="line-276"><code>	return nil</code></span>
<span class="codeline" id="line-277"><code>}</code></span>
<span class="codeline" id="line-278"><code></code></span>
<span class="codeline" id="line-279"><code>// MultipleOfUint validates if the provided unsigned integer is a multiple of the factor</code></span>
<span class="codeline" id="line-280"><code>func MultipleOfUint(path, in string, data, factor uint64) *errors.Validation {</code></span>
<span class="codeline" id="line-281"><code>	// multipleOf factor must be positive</code></span>
<span class="codeline" id="line-282"><code>	if factor == 0 {</code></span>
<span class="codeline" id="line-283"><code>		return errors.MultipleOfMustBePositive(path, in, factor)</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>	mult := data / factor</code></span>
<span class="codeline" id="line-286"><code>	if mult*factor != data {</code></span>
<span class="codeline" id="line-287"><code>		return errors.NotMultipleOf(path, in, factor, data)</code></span>
<span class="codeline" id="line-288"><code>	}</code></span>
<span class="codeline" id="line-289"><code>	return nil</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>// FormatOf validates if a string matches a format in the format registry</code></span>
<span class="codeline" id="line-293"><code>func FormatOf(path, in, format, data string, registry strfmt.Registry) *errors.Validation {</code></span>
<span class="codeline" id="line-294"><code>	if registry == nil {</code></span>
<span class="codeline" id="line-295"><code>		registry = strfmt.Default</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	if ok := registry.ContainsName(format); !ok {</code></span>
<span class="codeline" id="line-298"><code>		return errors.InvalidTypeName(format)</code></span>
<span class="codeline" id="line-299"><code>	}</code></span>
<span class="codeline" id="line-300"><code>	if ok := registry.Validates(format, data); !ok {</code></span>
<span class="codeline" id="line-301"><code>		return errors.InvalidType(path, in, format, data)</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code>	return nil</code></span>
<span class="codeline" id="line-304"><code>}</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>// MaximumNativeType provides native type constraint validation as a facade</code></span>
<span class="codeline" id="line-307"><code>// to various numeric types versions of Maximum constraint check.</code></span>
<span class="codeline" id="line-308"><code>//</code></span>
<span class="codeline" id="line-309"><code>// Assumes that any possible loss conversion during conversion has been</code></span>
<span class="codeline" id="line-310"><code>// checked beforehand.</code></span>
<span class="codeline" id="line-311"><code>//</code></span>
<span class="codeline" id="line-312"><code>// NOTE: currently, the max value is marshalled as a float64, no matter what,</code></span>
<span class="codeline" id="line-313"><code>// which means there may be a loss during conversions (e.g. for very large integers)</code></span>
<span class="codeline" id="line-314"><code>//</code></span>
<span class="codeline" id="line-315"><code>// TODO: Normally, a JSON MAX_SAFE_INTEGER check would ensure conversion remains loss-free</code></span>
<span class="codeline" id="line-316"><code>func MaximumNativeType(path, in string, val interface{}, max float64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-317"><code>	kind := reflect.ValueOf(val).Type().Kind()</code></span>
<span class="codeline" id="line-318"><code>	switch kind { //nolint:exhaustive</code></span>
<span class="codeline" id="line-319"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-320"><code>		value := valueHelp.asInt64(val)</code></span>
<span class="codeline" id="line-321"><code>		return MaximumInt(path, in, value, int64(max), exclusive)</code></span>
<span class="codeline" id="line-322"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:</code></span>
<span class="codeline" id="line-323"><code>		value := valueHelp.asUint64(val)</code></span>
<span class="codeline" id="line-324"><code>		if max &lt; 0 {</code></span>
<span class="codeline" id="line-325"><code>			return errors.ExceedsMaximum(path, in, max, exclusive, val)</code></span>
<span class="codeline" id="line-326"><code>		}</code></span>
<span class="codeline" id="line-327"><code>		return MaximumUint(path, in, value, uint64(max), exclusive)</code></span>
<span class="codeline" id="line-328"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-329"><code>		fallthrough</code></span>
<span class="codeline" id="line-330"><code>	default:</code></span>
<span class="codeline" id="line-331"><code>		value := valueHelp.asFloat64(val)</code></span>
<span class="codeline" id="line-332"><code>		return Maximum(path, in, value, max, exclusive)</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// MinimumNativeType provides native type constraint validation as a facade</code></span>
<span class="codeline" id="line-337"><code>// to various numeric types versions of Minimum constraint check.</code></span>
<span class="codeline" id="line-338"><code>//</code></span>
<span class="codeline" id="line-339"><code>// Assumes that any possible loss conversion during conversion has been</code></span>
<span class="codeline" id="line-340"><code>// checked beforehand.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// NOTE: currently, the min value is marshalled as a float64, no matter what,</code></span>
<span class="codeline" id="line-343"><code>// which means there may be a loss during conversions (e.g. for very large integers)</code></span>
<span class="codeline" id="line-344"><code>//</code></span>
<span class="codeline" id="line-345"><code>// TODO: Normally, a JSON MAX_SAFE_INTEGER check would ensure conversion remains loss-free</code></span>
<span class="codeline" id="line-346"><code>func MinimumNativeType(path, in string, val interface{}, min float64, exclusive bool) *errors.Validation {</code></span>
<span class="codeline" id="line-347"><code>	kind := reflect.ValueOf(val).Type().Kind()</code></span>
<span class="codeline" id="line-348"><code>	switch kind { //nolint:exhaustive</code></span>
<span class="codeline" id="line-349"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-350"><code>		value := valueHelp.asInt64(val)</code></span>
<span class="codeline" id="line-351"><code>		return MinimumInt(path, in, value, int64(min), exclusive)</code></span>
<span class="codeline" id="line-352"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:</code></span>
<span class="codeline" id="line-353"><code>		value := valueHelp.asUint64(val)</code></span>
<span class="codeline" id="line-354"><code>		if min &lt; 0 {</code></span>
<span class="codeline" id="line-355"><code>			return nil</code></span>
<span class="codeline" id="line-356"><code>		}</code></span>
<span class="codeline" id="line-357"><code>		return MinimumUint(path, in, value, uint64(min), exclusive)</code></span>
<span class="codeline" id="line-358"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-359"><code>		fallthrough</code></span>
<span class="codeline" id="line-360"><code>	default:</code></span>
<span class="codeline" id="line-361"><code>		value := valueHelp.asFloat64(val)</code></span>
<span class="codeline" id="line-362"><code>		return Minimum(path, in, value, min, exclusive)</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>// MultipleOfNativeType provides native type constraint validation as a facade</code></span>
<span class="codeline" id="line-367"><code>// to various numeric types version of MultipleOf constraint check.</code></span>
<span class="codeline" id="line-368"><code>//</code></span>
<span class="codeline" id="line-369"><code>// Assumes that any possible loss conversion during conversion has been</code></span>
<span class="codeline" id="line-370"><code>// checked beforehand.</code></span>
<span class="codeline" id="line-371"><code>//</code></span>
<span class="codeline" id="line-372"><code>// NOTE: currently, the multipleOf factor is marshalled as a float64, no matter what,</code></span>
<span class="codeline" id="line-373"><code>// which means there may be a loss during conversions (e.g. for very large integers)</code></span>
<span class="codeline" id="line-374"><code>//</code></span>
<span class="codeline" id="line-375"><code>// TODO: Normally, a JSON MAX_SAFE_INTEGER check would ensure conversion remains loss-free</code></span>
<span class="codeline" id="line-376"><code>func MultipleOfNativeType(path, in string, val interface{}, multipleOf float64) *errors.Validation {</code></span>
<span class="codeline" id="line-377"><code>	kind := reflect.ValueOf(val).Type().Kind()</code></span>
<span class="codeline" id="line-378"><code>	switch kind { //nolint:exhaustive</code></span>
<span class="codeline" id="line-379"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-380"><code>		value := valueHelp.asInt64(val)</code></span>
<span class="codeline" id="line-381"><code>		return MultipleOfInt(path, in, value, int64(multipleOf))</code></span>
<span class="codeline" id="line-382"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:</code></span>
<span class="codeline" id="line-383"><code>		value := valueHelp.asUint64(val)</code></span>
<span class="codeline" id="line-384"><code>		return MultipleOfUint(path, in, value, uint64(multipleOf))</code></span>
<span class="codeline" id="line-385"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-386"><code>		fallthrough</code></span>
<span class="codeline" id="line-387"><code>	default:</code></span>
<span class="codeline" id="line-388"><code>		value := valueHelp.asFloat64(val)</code></span>
<span class="codeline" id="line-389"><code>		return MultipleOf(path, in, value, multipleOf)</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>// IsValueValidAgainstRange checks that a numeric value is compatible with</code></span>
<span class="codeline" id="line-394"><code>// the range defined by Type and Format, that is, may be converted without loss.</code></span>
<span class="codeline" id="line-395"><code>//</code></span>
<span class="codeline" id="line-396"><code>// NOTE: this check is about type capacity and not formal verification such as: 1.0 != 1L</code></span>
<span class="codeline" id="line-397"><code>func IsValueValidAgainstRange(val interface{}, typeName, format, prefix, path string) error {</code></span>
<span class="codeline" id="line-398"><code>	kind := reflect.ValueOf(val).Type().Kind()</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>	// What is the string representation of val</code></span>
<span class="codeline" id="line-401"><code>	var stringRep string</code></span>
<span class="codeline" id="line-402"><code>	switch kind { //nolint:exhaustive</code></span>
<span class="codeline" id="line-403"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:</code></span>
<span class="codeline" id="line-404"><code>		stringRep = swag.FormatUint64(valueHelp.asUint64(val))</code></span>
<span class="codeline" id="line-405"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-406"><code>		stringRep = swag.FormatInt64(valueHelp.asInt64(val))</code></span>
<span class="codeline" id="line-407"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-408"><code>		stringRep = swag.FormatFloat64(valueHelp.asFloat64(val))</code></span>
<span class="codeline" id="line-409"><code>	default:</code></span>
<span class="codeline" id="line-410"><code>		return fmt.Errorf("%s value number range checking called with invalid (non numeric) val type in %s", prefix, path)</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	var errVal error</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>	switch typeName {</code></span>
<span class="codeline" id="line-416"><code>	case integerType:</code></span>
<span class="codeline" id="line-417"><code>		switch format {</code></span>
<span class="codeline" id="line-418"><code>		case integerFormatInt32:</code></span>
<span class="codeline" id="line-419"><code>			_, errVal = swag.ConvertInt32(stringRep)</code></span>
<span class="codeline" id="line-420"><code>		case integerFormatUInt32:</code></span>
<span class="codeline" id="line-421"><code>			_, errVal = swag.ConvertUint32(stringRep)</code></span>
<span class="codeline" id="line-422"><code>		case integerFormatUInt64:</code></span>
<span class="codeline" id="line-423"><code>			_, errVal = swag.ConvertUint64(stringRep)</code></span>
<span class="codeline" id="line-424"><code>		case integerFormatInt64:</code></span>
<span class="codeline" id="line-425"><code>			fallthrough</code></span>
<span class="codeline" id="line-426"><code>		default:</code></span>
<span class="codeline" id="line-427"><code>			_, errVal = swag.ConvertInt64(stringRep)</code></span>
<span class="codeline" id="line-428"><code>		}</code></span>
<span class="codeline" id="line-429"><code>	case numberType:</code></span>
<span class="codeline" id="line-430"><code>		fallthrough</code></span>
<span class="codeline" id="line-431"><code>	default:</code></span>
<span class="codeline" id="line-432"><code>		switch format {</code></span>
<span class="codeline" id="line-433"><code>		case numberFormatFloat, numberFormatFloat32:</code></span>
<span class="codeline" id="line-434"><code>			_, errVal = swag.ConvertFloat32(stringRep)</code></span>
<span class="codeline" id="line-435"><code>		case numberFormatDouble, numberFormatFloat64:</code></span>
<span class="codeline" id="line-436"><code>			fallthrough</code></span>
<span class="codeline" id="line-437"><code>		default:</code></span>
<span class="codeline" id="line-438"><code>			// No check can be performed here since</code></span>
<span class="codeline" id="line-439"><code>			// no number beyond float64 is supported</code></span>
<span class="codeline" id="line-440"><code>		}</code></span>
<span class="codeline" id="line-441"><code>	}</code></span>
<span class="codeline" id="line-442"><code>	if errVal != nil { // We don't report the actual errVal from strconv</code></span>
<span class="codeline" id="line-443"><code>		if format != "" {</code></span>
<span class="codeline" id="line-444"><code>			errVal = fmt.Errorf("%s value must be of type %s with format %s in %s", prefix, typeName, format, path)</code></span>
<span class="codeline" id="line-445"><code>		} else {</code></span>
<span class="codeline" id="line-446"><code>			errVal = fmt.Errorf("%s value must be of type %s (default format) in %s", prefix, typeName, path)</code></span>
<span class="codeline" id="line-447"><code>		}</code></span>
<span class="codeline" id="line-448"><code>	}</code></span>
<span class="codeline" id="line-449"><code>	return errVal</code></span>
<span class="codeline" id="line-450"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>