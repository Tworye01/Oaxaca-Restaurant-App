<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: bisect.go in package internal/bisect</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	bisect.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/internal/bisect.html">internal/bisect</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2023 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package bisect can be used by compilers and other programs</code></span>
<span class="codeline" id="line-6"><code>// to serve as a target for the bisect debugging tool.</code></span>
<span class="codeline" id="line-7"><code>// See [golang.org/x/tools/cmd/bisect] for details about using the tool.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// To be a bisect target, allowing bisect to help determine which of a set of independent</code></span>
<span class="codeline" id="line-10"><code>// changes provokes a failure, a program needs to:</code></span>
<span class="codeline" id="line-11"><code>//</code></span>
<span class="codeline" id="line-12"><code>//  1. Define a way to accept a change pattern on its command line or in its environment.</code></span>
<span class="codeline" id="line-13"><code>//     The most common mechanism is a command-line flag.</code></span>
<span class="codeline" id="line-14"><code>//     The pattern can be passed to [New] to create a [Matcher], the compiled form of a pattern.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>//  2. Assign each change a unique ID. One possibility is to use a sequence number,</code></span>
<span class="codeline" id="line-17"><code>//     but the most common mechanism is to hash some kind of identifying information</code></span>
<span class="codeline" id="line-18"><code>//     like the file and line number where the change might be applied.</code></span>
<span class="codeline" id="line-19"><code>//     [Hash] hashes its arguments to compute an ID.</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>//  3. Enable each change that the pattern says should be enabled.</code></span>
<span class="codeline" id="line-22"><code>//     The [Matcher.ShouldEnable] method answers this question for a given change ID.</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>//  4. Print a report identifying each change that the pattern says should be printed.</code></span>
<span class="codeline" id="line-25"><code>//     The [Matcher.ShouldPrint] method answers this question for a given change ID.</code></span>
<span class="codeline" id="line-26"><code>//     The report consists of one more lines on standard error or standard output</code></span>
<span class="codeline" id="line-27"><code>//     that contain a “match marker”. [Marker] returns the match marker for a given ID.</code></span>
<span class="codeline" id="line-28"><code>//     When bisect reports a change as causing the failure, it identifies the change</code></span>
<span class="codeline" id="line-29"><code>//     by printing the report lines with the match marker removed.</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// # Example Usage</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// A program starts by defining how it receives the pattern. In this example, we will assume a flag.</code></span>
<span class="codeline" id="line-34"><code>// The next step is to compile the pattern:</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>//	m, err := bisect.New(patternFlag)</code></span>
<span class="codeline" id="line-37"><code>//	if err != nil {</code></span>
<span class="codeline" id="line-38"><code>//		log.Fatal(err)</code></span>
<span class="codeline" id="line-39"><code>//	}</code></span>
<span class="codeline" id="line-40"><code>//</code></span>
<span class="codeline" id="line-41"><code>// Then, each time a potential change is considered, the program computes</code></span>
<span class="codeline" id="line-42"><code>// a change ID by hashing identifying information (source file and line, in this case)</code></span>
<span class="codeline" id="line-43"><code>// and then calls m.ShouldPrint and m.ShouldEnable to decide whether to</code></span>
<span class="codeline" id="line-44"><code>// print and enable the change, respectively. The two can return different values</code></span>
<span class="codeline" id="line-45"><code>// depending on whether bisect is trying to find a minimal set of changes to</code></span>
<span class="codeline" id="line-46"><code>// disable or to enable to provoke the failure.</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// It is usually helpful to write a helper function that accepts the identifying information</code></span>
<span class="codeline" id="line-49"><code>// and then takes care of hashing, printing, and reporting whether the identified change</code></span>
<span class="codeline" id="line-50"><code>// should be enabled. For example, a helper for changes identified by a file and line number</code></span>
<span class="codeline" id="line-51"><code>// would be:</code></span>
<span class="codeline" id="line-52"><code>//</code></span>
<span class="codeline" id="line-53"><code>//	func ShouldEnable(file string, line int) {</code></span>
<span class="codeline" id="line-54"><code>//		h := bisect.Hash(file, line)</code></span>
<span class="codeline" id="line-55"><code>//		if m.ShouldPrint(h) {</code></span>
<span class="codeline" id="line-56"><code>//			fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)</code></span>
<span class="codeline" id="line-57"><code>//		}</code></span>
<span class="codeline" id="line-58"><code>//		return m.ShouldEnable(h)</code></span>
<span class="codeline" id="line-59"><code>//	}</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// Finally, note that New returns a nil Matcher when there is no pattern,</code></span>
<span class="codeline" id="line-62"><code>// meaning that the target is not running under bisect at all,</code></span>
<span class="codeline" id="line-63"><code>// so all changes should be enabled and none should be printed.</code></span>
<span class="codeline" id="line-64"><code>// In that common case, the computation of the hash can be avoided entirely</code></span>
<span class="codeline" id="line-65"><code>// by checking for m == nil first:</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>//	func ShouldEnable(file string, line int) bool {</code></span>
<span class="codeline" id="line-68"><code>//		if m == nil {</code></span>
<span class="codeline" id="line-69"><code>//			return true</code></span>
<span class="codeline" id="line-70"><code>//		}</code></span>
<span class="codeline" id="line-71"><code>//		h := bisect.Hash(file, line)</code></span>
<span class="codeline" id="line-72"><code>//		if m.ShouldPrint(h) {</code></span>
<span class="codeline" id="line-73"><code>//			fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)</code></span>
<span class="codeline" id="line-74"><code>//		}</code></span>
<span class="codeline" id="line-75"><code>//		return m.ShouldEnable(h)</code></span>
<span class="codeline" id="line-76"><code>//	}</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>// When the identifying information is expensive to format, this code can call</code></span>
<span class="codeline" id="line-79"><code>// [Matcher.MarkerOnly] to find out whether short report lines containing only the</code></span>
<span class="codeline" id="line-80"><code>// marker are permitted for a given run. (Bisect permits such lines when it is</code></span>
<span class="codeline" id="line-81"><code>// still exploring the space of possible changes and will not be showing the</code></span>
<span class="codeline" id="line-82"><code>// output to the user.) If so, the client can choose to print only the marker:</code></span>
<span class="codeline" id="line-83"><code>//</code></span>
<span class="codeline" id="line-84"><code>//	func ShouldEnable(file string, line int) bool {</code></span>
<span class="codeline" id="line-85"><code>//		if m == nil {</code></span>
<span class="codeline" id="line-86"><code>//			return true</code></span>
<span class="codeline" id="line-87"><code>//		}</code></span>
<span class="codeline" id="line-88"><code>//		h := bisect.Hash(file, line)</code></span>
<span class="codeline" id="line-89"><code>//		if m.ShouldPrint(h) {</code></span>
<span class="codeline" id="line-90"><code>//			if m.MarkerOnly() {</code></span>
<span class="codeline" id="line-91"><code>//				bisect.PrintMarker(os.Stderr, h)</code></span>
<span class="codeline" id="line-92"><code>//			} else {</code></span>
<span class="codeline" id="line-93"><code>//				fmt.Fprintf(os.Stderr, "%v %s:%d\n", bisect.Marker(h), file, line)</code></span>
<span class="codeline" id="line-94"><code>//			}</code></span>
<span class="codeline" id="line-95"><code>//		}</code></span>
<span class="codeline" id="line-96"><code>//		return m.ShouldEnable(h)</code></span>
<span class="codeline" id="line-97"><code>//	}</code></span>
<span class="codeline" id="line-98"><code>//</code></span>
<span class="codeline" id="line-99"><code>// This specific helper – deciding whether to enable a change identified by</code></span>
<span class="codeline" id="line-100"><code>// file and line number and printing about the change when necessary – is</code></span>
<span class="codeline" id="line-101"><code>// provided by the [Matcher.FileLine] method.</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>// Another common usage is deciding whether to make a change in a function</code></span>
<span class="codeline" id="line-104"><code>// based on the caller's stack, to identify the specific calling contexts that the</code></span>
<span class="codeline" id="line-105"><code>// change breaks. The [Matcher.Stack] method takes care of obtaining the stack,</code></span>
<span class="codeline" id="line-106"><code>// printing it when necessary, and reporting whether to enable the change</code></span>
<span class="codeline" id="line-107"><code>// based on that stack.</code></span>
<span class="codeline" id="line-108"><code>//</code></span>
<span class="codeline" id="line-109"><code>// # Pattern Syntax</code></span>
<span class="codeline" id="line-110"><code>//</code></span>
<span class="codeline" id="line-111"><code>// Patterns are generated by the bisect tool and interpreted by [New].</code></span>
<span class="codeline" id="line-112"><code>// Users should not have to understand the patterns except when</code></span>
<span class="codeline" id="line-113"><code>// debugging a target's bisect support or debugging the bisect tool itself.</code></span>
<span class="codeline" id="line-114"><code>//</code></span>
<span class="codeline" id="line-115"><code>// The pattern syntax selecting a change is a sequence of bit strings</code></span>
<span class="codeline" id="line-116"><code>// separated by + and - operators. Each bit string denotes the set of</code></span>
<span class="codeline" id="line-117"><code>// changes with IDs ending in those bits, + is set addition, - is set subtraction,</code></span>
<span class="codeline" id="line-118"><code>// and the expression is evaluated in the usual left-to-right order.</code></span>
<span class="codeline" id="line-119"><code>// The special binary number “y” denotes the set of all changes,</code></span>
<span class="codeline" id="line-120"><code>// standing in for the empty bit string.</code></span>
<span class="codeline" id="line-121"><code>// In the expression, all the + operators must appear before all the - operators.</code></span>
<span class="codeline" id="line-122"><code>// A leading + adds to an empty set. A leading - subtracts from the set of all</code></span>
<span class="codeline" id="line-123"><code>// possible suffixes.</code></span>
<span class="codeline" id="line-124"><code>//</code></span>
<span class="codeline" id="line-125"><code>// For example:</code></span>
<span class="codeline" id="line-126"><code>//</code></span>
<span class="codeline" id="line-127"><code>//   - “01+10” and “+01+10” both denote the set of changes</code></span>
<span class="codeline" id="line-128"><code>//     with IDs ending with the bits 01 or 10.</code></span>
<span class="codeline" id="line-129"><code>//</code></span>
<span class="codeline" id="line-130"><code>//   - “01+10-1001” denotes the set of changes with IDs</code></span>
<span class="codeline" id="line-131"><code>//     ending with the bits 01 or 10, but excluding those ending in 1001.</code></span>
<span class="codeline" id="line-132"><code>//</code></span>
<span class="codeline" id="line-133"><code>//   - “-01-1000” and “y-01-1000 both denote the set of all changes</code></span>
<span class="codeline" id="line-134"><code>//     with IDs not ending in 01 nor 1000.</code></span>
<span class="codeline" id="line-135"><code>//</code></span>
<span class="codeline" id="line-136"><code>//   - “0+1-01+001” is not a valid pattern, because all the + operators do not</code></span>
<span class="codeline" id="line-137"><code>//     appear before all the - operators.</code></span>
<span class="codeline" id="line-138"><code>//</code></span>
<span class="codeline" id="line-139"><code>// In the syntaxes described so far, the pattern specifies the changes to</code></span>
<span class="codeline" id="line-140"><code>// enable and report. If a pattern is prefixed by a “!”, the meaning</code></span>
<span class="codeline" id="line-141"><code>// changes: the pattern specifies the changes to DISABLE and report. This</code></span>
<span class="codeline" id="line-142"><code>// mode of operation is needed when a program passes with all changes</code></span>
<span class="codeline" id="line-143"><code>// enabled but fails with no changes enabled. In this case, bisect</code></span>
<span class="codeline" id="line-144"><code>// searches for minimal sets of changes to disable.</code></span>
<span class="codeline" id="line-145"><code>// Put another way, the leading “!” inverts the result from [Matcher.ShouldEnable]</code></span>
<span class="codeline" id="line-146"><code>// but does not invert the result from [Matcher.ShouldPrint].</code></span>
<span class="codeline" id="line-147"><code>//</code></span>
<span class="codeline" id="line-148"><code>// As a convenience for manual debugging, “n” is an alias for “!y”,</code></span>
<span class="codeline" id="line-149"><code>// meaning to disable and report all changes.</code></span>
<span class="codeline" id="line-150"><code>//</code></span>
<span class="codeline" id="line-151"><code>// Finally, a leading “v” in the pattern indicates that the reports will be shown</code></span>
<span class="codeline" id="line-152"><code>// to the user of bisect to describe the changes involved in a failure.</code></span>
<span class="codeline" id="line-153"><code>// At the API level, the leading “v” causes [Matcher.Visible] to return true.</code></span>
<span class="codeline" id="line-154"><code>// See the next section for details.</code></span>
<span class="codeline" id="line-155"><code>//</code></span>
<span class="codeline" id="line-156"><code>// # Match Reports</code></span>
<span class="codeline" id="line-157"><code>//</code></span>
<span class="codeline" id="line-158"><code>// The target program must enable only those changed matched</code></span>
<span class="codeline" id="line-159"><code>// by the pattern, and it must print a match report for each such change.</code></span>
<span class="codeline" id="line-160"><code>// A match report consists of one or more lines of text that will be</code></span>
<span class="codeline" id="line-161"><code>// printed by the bisect tool to describe a change implicated in causing</code></span>
<span class="codeline" id="line-162"><code>// a failure. Each line in the report for a given change must contain a</code></span>
<span class="codeline" id="line-163"><code>// match marker with that change ID, as returned by [Marker].</code></span>
<span class="codeline" id="line-164"><code>// The markers are elided when displaying the lines to the user.</code></span>
<span class="codeline" id="line-165"><code>//</code></span>
<span class="codeline" id="line-166"><code>// A match marker has the form “[bisect-match 0x1234]” where</code></span>
<span class="codeline" id="line-167"><code>// 0x1234 is the change ID in hexadecimal.</code></span>
<span class="codeline" id="line-168"><code>// An alternate form is “[bisect-match 010101]”, giving the change ID in binary.</code></span>
<span class="codeline" id="line-169"><code>//</code></span>
<span class="codeline" id="line-170"><code>// When [Matcher.Visible] returns false, the match reports are only</code></span>
<span class="codeline" id="line-171"><code>// being processed by bisect to learn the set of enabled changes,</code></span>
<span class="codeline" id="line-172"><code>// not shown to the user, meaning that each report can be a match</code></span>
<span class="codeline" id="line-173"><code>// marker on a line by itself, eliding the usual textual description.</code></span>
<span class="codeline" id="line-174"><code>// When the textual description is expensive to compute,</code></span>
<span class="codeline" id="line-175"><code>// checking [Matcher.Visible] can help the avoid that expense</code></span>
<span class="codeline" id="line-176"><code>// in most runs.</code></span></div><span class="codeline" id="line-177"><code>package bisect</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>import (</code></span>
<span class="codeline" id="line-180"><code>	"runtime"</code></span>
<span class="codeline" id="line-181"><code>	"sync"</code></span>
<span class="codeline" id="line-182"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-183"><code>	"unsafe"</code></span>
<span class="codeline" id="line-184"><code>)</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>// New creates and returns a new Matcher implementing the given pattern.</code></span>
<span class="codeline" id="line-187"><code>// The pattern syntax is defined in the package doc comment.</code></span>
<span class="codeline" id="line-188"><code>//</code></span>
<span class="codeline" id="line-189"><code>// In addition to the pattern syntax syntax, New("") returns nil, nil.</code></span>
<span class="codeline" id="line-190"><code>// The nil *Matcher is valid for use: it returns true from ShouldEnable</code></span>
<span class="codeline" id="line-191"><code>// and false from ShouldPrint for all changes. Callers can avoid calling</code></span>
<span class="codeline" id="line-192"><code>// [Hash], [Matcher.ShouldEnable], and [Matcher.ShouldPrint] entirely</code></span>
<span class="codeline" id="line-193"><code>// when they recognize the nil Matcher.</code></span>
<span class="codeline" id="line-194"><code>func New(pattern string) (*Matcher, error) {</code></span>
<span class="codeline" id="line-195"><code>	if pattern == "" {</code></span>
<span class="codeline" id="line-196"><code>		return nil, nil</code></span>
<span class="codeline" id="line-197"><code>	}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>	m := new(Matcher)</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>	p := pattern</code></span>
<span class="codeline" id="line-202"><code>	// Special case for leading 'q' so that 'qn' quietly disables, e.g. fmahash=qn to disable fma</code></span>
<span class="codeline" id="line-203"><code>	// Any instance of 'v' disables 'q'.</code></span>
<span class="codeline" id="line-204"><code>	if len(p) &gt; 0 &amp;&amp; p[0] == 'q' {</code></span>
<span class="codeline" id="line-205"><code>		m.quiet = true</code></span>
<span class="codeline" id="line-206"><code>		p = p[1:]</code></span>
<span class="codeline" id="line-207"><code>		if p == "" {</code></span>
<span class="codeline" id="line-208"><code>			return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-209"><code>		}</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>	// Allow multiple v, so that “bisect cmd vPATTERN” can force verbose all the time.</code></span>
<span class="codeline" id="line-212"><code>	for len(p) &gt; 0 &amp;&amp; p[0] == 'v' {</code></span>
<span class="codeline" id="line-213"><code>		m.verbose = true</code></span>
<span class="codeline" id="line-214"><code>		m.quiet = false</code></span>
<span class="codeline" id="line-215"><code>		p = p[1:]</code></span>
<span class="codeline" id="line-216"><code>		if p == "" {</code></span>
<span class="codeline" id="line-217"><code>			return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-218"><code>		}</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>	// Allow multiple !, each negating the last, so that “bisect cmd !PATTERN” works</code></span>
<span class="codeline" id="line-222"><code>	// even when bisect chooses to add its own !.</code></span>
<span class="codeline" id="line-223"><code>	m.enable = true</code></span>
<span class="codeline" id="line-224"><code>	for len(p) &gt; 0 &amp;&amp; p[0] == '!' {</code></span>
<span class="codeline" id="line-225"><code>		m.enable = !m.enable</code></span>
<span class="codeline" id="line-226"><code>		p = p[1:]</code></span>
<span class="codeline" id="line-227"><code>		if p == "" {</code></span>
<span class="codeline" id="line-228"><code>			return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-229"><code>		}</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>	if p == "n" {</code></span>
<span class="codeline" id="line-233"><code>		// n is an alias for !y.</code></span>
<span class="codeline" id="line-234"><code>		m.enable = !m.enable</code></span>
<span class="codeline" id="line-235"><code>		p = "y"</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>	// Parse actual pattern syntax.</code></span>
<span class="codeline" id="line-239"><code>	result := true</code></span>
<span class="codeline" id="line-240"><code>	bits := uint64(0)</code></span>
<span class="codeline" id="line-241"><code>	start := 0</code></span>
<span class="codeline" id="line-242"><code>	wid := 1 // 1-bit (binary); sometimes 4-bit (hex)</code></span>
<span class="codeline" id="line-243"><code>	for i := 0; i &lt;= len(p); i++ {</code></span>
<span class="codeline" id="line-244"><code>		// Imagine a trailing - at the end of the pattern to flush final suffix</code></span>
<span class="codeline" id="line-245"><code>		c := byte('-')</code></span>
<span class="codeline" id="line-246"><code>		if i &lt; len(p) {</code></span>
<span class="codeline" id="line-247"><code>			c = p[i]</code></span>
<span class="codeline" id="line-248"><code>		}</code></span>
<span class="codeline" id="line-249"><code>		if i == start &amp;&amp; wid == 1 &amp;&amp; c == 'x' { // leading x for hex</code></span>
<span class="codeline" id="line-250"><code>			start = i + 1</code></span>
<span class="codeline" id="line-251"><code>			wid = 4</code></span>
<span class="codeline" id="line-252"><code>			continue</code></span>
<span class="codeline" id="line-253"><code>		}</code></span>
<span class="codeline" id="line-254"><code>		switch c {</code></span>
<span class="codeline" id="line-255"><code>		default:</code></span>
<span class="codeline" id="line-256"><code>			return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-257"><code>		case '2', '3', '4', '5', '6', '7', '8', '9':</code></span>
<span class="codeline" id="line-258"><code>			if wid != 4 {</code></span>
<span class="codeline" id="line-259"><code>				return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-260"><code>			}</code></span>
<span class="codeline" id="line-261"><code>			fallthrough</code></span>
<span class="codeline" id="line-262"><code>		case '0', '1':</code></span>
<span class="codeline" id="line-263"><code>			bits &lt;&lt;= wid</code></span>
<span class="codeline" id="line-264"><code>			bits |= uint64(c - '0')</code></span>
<span class="codeline" id="line-265"><code>		case 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F':</code></span>
<span class="codeline" id="line-266"><code>			if wid != 4 {</code></span>
<span class="codeline" id="line-267"><code>				return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-268"><code>			}</code></span>
<span class="codeline" id="line-269"><code>			bits &lt;&lt;= 4</code></span>
<span class="codeline" id="line-270"><code>			bits |= uint64(c&amp;^0x20 - 'A' + 10)</code></span>
<span class="codeline" id="line-271"><code>		case 'y':</code></span>
<span class="codeline" id="line-272"><code>			if i+1 &lt; len(p) &amp;&amp; (p[i+1] == '0' || p[i+1] == '1') {</code></span>
<span class="codeline" id="line-273"><code>				return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-274"><code>			}</code></span>
<span class="codeline" id="line-275"><code>			bits = 0</code></span>
<span class="codeline" id="line-276"><code>		case '+', '-':</code></span>
<span class="codeline" id="line-277"><code>			if c == '+' &amp;&amp; result == false {</code></span>
<span class="codeline" id="line-278"><code>				// Have already seen a -. Should be - from here on.</code></span>
<span class="codeline" id="line-279"><code>				return nil, &amp;parseError{"invalid pattern syntax (+ after -): " + pattern}</code></span>
<span class="codeline" id="line-280"><code>			}</code></span>
<span class="codeline" id="line-281"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-282"><code>				n := (i - start) * wid</code></span>
<span class="codeline" id="line-283"><code>				if n &gt; 64 {</code></span>
<span class="codeline" id="line-284"><code>					return nil, &amp;parseError{"pattern bits too long: " + pattern}</code></span>
<span class="codeline" id="line-285"><code>				}</code></span>
<span class="codeline" id="line-286"><code>				if n &lt;= 0 {</code></span>
<span class="codeline" id="line-287"><code>					return nil, &amp;parseError{"invalid pattern syntax: " + pattern}</code></span>
<span class="codeline" id="line-288"><code>				}</code></span>
<span class="codeline" id="line-289"><code>				if p[start] == 'y' {</code></span>
<span class="codeline" id="line-290"><code>					n = 0</code></span>
<span class="codeline" id="line-291"><code>				}</code></span>
<span class="codeline" id="line-292"><code>				mask := uint64(1)&lt;&lt;n - 1</code></span>
<span class="codeline" id="line-293"><code>				m.list = append(m.list, cond{mask, bits, result})</code></span>
<span class="codeline" id="line-294"><code>			} else if c == '-' {</code></span>
<span class="codeline" id="line-295"><code>				// leading - subtracts from complete set</code></span>
<span class="codeline" id="line-296"><code>				m.list = append(m.list, cond{0, 0, true})</code></span>
<span class="codeline" id="line-297"><code>			}</code></span>
<span class="codeline" id="line-298"><code>			bits = 0</code></span>
<span class="codeline" id="line-299"><code>			result = c == '+'</code></span>
<span class="codeline" id="line-300"><code>			start = i + 1</code></span>
<span class="codeline" id="line-301"><code>			wid = 1</code></span>
<span class="codeline" id="line-302"><code>		}</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code>	return m, nil</code></span>
<span class="codeline" id="line-305"><code>}</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>// A Matcher is the parsed, compiled form of a PATTERN string.</code></span>
<span class="codeline" id="line-308"><code>// The nil *Matcher is valid: it has all changes enabled but none reported.</code></span>
<span class="codeline" id="line-309"><code>type Matcher struct {</code></span>
<span class="codeline" id="line-310"><code>	verbose bool   // annotate reporting with human-helpful information</code></span>
<span class="codeline" id="line-311"><code>	quiet   bool   // disables all reporting.  reset if verbose is true. use case is -d=fmahash=qn</code></span>
<span class="codeline" id="line-312"><code>	enable  bool   // when true, list is for “enable and report” (when false, “disable and report”)</code></span>
<span class="codeline" id="line-313"><code>	list    []cond // conditions; later ones win over earlier ones</code></span>
<span class="codeline" id="line-314"><code>	dedup   atomicPointerDedup</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// atomicPointerDedup is an atomic.Pointer[dedup],</code></span>
<span class="codeline" id="line-318"><code>// but we are avoiding using Go 1.19's atomic.Pointer</code></span>
<span class="codeline" id="line-319"><code>// until the bootstrap toolchain can be relied upon to have it.</code></span>
<span class="codeline" id="line-320"><code>type atomicPointerDedup struct {</code></span>
<span class="codeline" id="line-321"><code>	p unsafe.Pointer</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>func (p *atomicPointerDedup) Load() *dedup {</code></span>
<span class="codeline" id="line-325"><code>	return (*dedup)(atomic.LoadPointer(&amp;p.p))</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>func (p *atomicPointerDedup) CompareAndSwap(old, new *dedup) bool {</code></span>
<span class="codeline" id="line-329"><code>	return atomic.CompareAndSwapPointer(&amp;p.p, unsafe.Pointer(old), unsafe.Pointer(new))</code></span>
<span class="codeline" id="line-330"><code>}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>// A cond is a single condition in the matcher.</code></span>
<span class="codeline" id="line-333"><code>// Given an input id, if id&amp;mask == bits, return the result.</code></span>
<span class="codeline" id="line-334"><code>type cond struct {</code></span>
<span class="codeline" id="line-335"><code>	mask   uint64</code></span>
<span class="codeline" id="line-336"><code>	bits   uint64</code></span>
<span class="codeline" id="line-337"><code>	result bool</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// MarkerOnly reports whether it is okay to print only the marker for</code></span>
<span class="codeline" id="line-341"><code>// a given change, omitting the identifying information.</code></span>
<span class="codeline" id="line-342"><code>// MarkerOnly returns true when bisect is using the printed reports</code></span>
<span class="codeline" id="line-343"><code>// only for an intermediate search step, not for showing to users.</code></span>
<span class="codeline" id="line-344"><code>func (m *Matcher) MarkerOnly() bool {</code></span>
<span class="codeline" id="line-345"><code>	return !m.verbose</code></span>
<span class="codeline" id="line-346"><code>}</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>// ShouldEnable reports whether the change with the given id should be enabled.</code></span>
<span class="codeline" id="line-349"><code>func (m *Matcher) ShouldEnable(id uint64) bool {</code></span>
<span class="codeline" id="line-350"><code>	if m == nil {</code></span>
<span class="codeline" id="line-351"><code>		return true</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code>	return m.matchResult(id) == m.enable</code></span>
<span class="codeline" id="line-354"><code>}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>// ShouldPrint reports whether to print identifying information about the change with the given id.</code></span>
<span class="codeline" id="line-357"><code>func (m *Matcher) ShouldPrint(id uint64) bool {</code></span>
<span class="codeline" id="line-358"><code>	if m == nil || m.quiet {</code></span>
<span class="codeline" id="line-359"><code>		return false</code></span>
<span class="codeline" id="line-360"><code>	}</code></span>
<span class="codeline" id="line-361"><code>	return m.matchResult(id)</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>// matchResult returns the result from the first condition that matches id.</code></span>
<span class="codeline" id="line-365"><code>func (m *Matcher) matchResult(id uint64) bool {</code></span>
<span class="codeline" id="line-366"><code>	for i := len(m.list) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-367"><code>		c := &amp;m.list[i]</code></span>
<span class="codeline" id="line-368"><code>		if id&amp;c.mask == c.bits {</code></span>
<span class="codeline" id="line-369"><code>			return c.result</code></span>
<span class="codeline" id="line-370"><code>		}</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code>	return false</code></span>
<span class="codeline" id="line-373"><code>}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>// FileLine reports whether the change identified by file and line should be enabled.</code></span>
<span class="codeline" id="line-376"><code>// If the change should be printed, FileLine prints a one-line report to w.</code></span>
<span class="codeline" id="line-377"><code>func (m *Matcher) FileLine(w Writer, file string, line int) bool {</code></span>
<span class="codeline" id="line-378"><code>	if m == nil {</code></span>
<span class="codeline" id="line-379"><code>		return true</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	return m.fileLine(w, file, line)</code></span>
<span class="codeline" id="line-382"><code>}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>// fileLine does the real work for FileLine.</code></span>
<span class="codeline" id="line-385"><code>// This lets FileLine's body handle m == nil and potentially be inlined.</code></span>
<span class="codeline" id="line-386"><code>func (m *Matcher) fileLine(w Writer, file string, line int) bool {</code></span>
<span class="codeline" id="line-387"><code>	h := Hash(file, line)</code></span>
<span class="codeline" id="line-388"><code>	if m.ShouldPrint(h) {</code></span>
<span class="codeline" id="line-389"><code>		if m.MarkerOnly() {</code></span>
<span class="codeline" id="line-390"><code>			PrintMarker(w, h)</code></span>
<span class="codeline" id="line-391"><code>		} else {</code></span>
<span class="codeline" id="line-392"><code>			printFileLine(w, h, file, line)</code></span>
<span class="codeline" id="line-393"><code>		}</code></span>
<span class="codeline" id="line-394"><code>	}</code></span>
<span class="codeline" id="line-395"><code>	return m.ShouldEnable(h)</code></span>
<span class="codeline" id="line-396"><code>}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>// printFileLine prints a non-marker-only report for file:line to w.</code></span>
<span class="codeline" id="line-399"><code>func printFileLine(w Writer, h uint64, file string, line int) error {</code></span>
<span class="codeline" id="line-400"><code>	const markerLen = 40 // overestimate</code></span>
<span class="codeline" id="line-401"><code>	b := make([]byte, 0, markerLen+len(file)+24)</code></span>
<span class="codeline" id="line-402"><code>	b = AppendMarker(b, h)</code></span>
<span class="codeline" id="line-403"><code>	b = appendFileLine(b, file, line)</code></span>
<span class="codeline" id="line-404"><code>	b = append(b, '\n')</code></span>
<span class="codeline" id="line-405"><code>	_, err := w.Write(b)</code></span>
<span class="codeline" id="line-406"><code>	return err</code></span>
<span class="codeline" id="line-407"><code>}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>// appendFileLine appends file:line to dst, returning the extended slice.</code></span>
<span class="codeline" id="line-410"><code>func appendFileLine(dst []byte, file string, line int) []byte {</code></span>
<span class="codeline" id="line-411"><code>	dst = append(dst, file...)</code></span>
<span class="codeline" id="line-412"><code>	dst = append(dst, ':')</code></span>
<span class="codeline" id="line-413"><code>	u := uint(line)</code></span>
<span class="codeline" id="line-414"><code>	if line &lt; 0 {</code></span>
<span class="codeline" id="line-415"><code>		dst = append(dst, '-')</code></span>
<span class="codeline" id="line-416"><code>		u = -u</code></span>
<span class="codeline" id="line-417"><code>	}</code></span>
<span class="codeline" id="line-418"><code>	var buf [24]byte</code></span>
<span class="codeline" id="line-419"><code>	i := len(buf)</code></span>
<span class="codeline" id="line-420"><code>	for i == len(buf) || u &gt; 0 {</code></span>
<span class="codeline" id="line-421"><code>		i--</code></span>
<span class="codeline" id="line-422"><code>		buf[i] = '0' + byte(u%10)</code></span>
<span class="codeline" id="line-423"><code>		u /= 10</code></span>
<span class="codeline" id="line-424"><code>	}</code></span>
<span class="codeline" id="line-425"><code>	dst = append(dst, buf[i:]...)</code></span>
<span class="codeline" id="line-426"><code>	return dst</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>// MatchStack assigns the current call stack a change ID.</code></span>
<span class="codeline" id="line-430"><code>// If the stack should be printed, MatchStack prints it.</code></span>
<span class="codeline" id="line-431"><code>// Then MatchStack reports whether a change at the current call stack should be enabled.</code></span>
<span class="codeline" id="line-432"><code>func (m *Matcher) Stack(w Writer) bool {</code></span>
<span class="codeline" id="line-433"><code>	if m == nil {</code></span>
<span class="codeline" id="line-434"><code>		return true</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code>	return m.stack(w)</code></span>
<span class="codeline" id="line-437"><code>}</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>// stack does the real work for Stack.</code></span>
<span class="codeline" id="line-440"><code>// This lets stack's body handle m == nil and potentially be inlined.</code></span>
<span class="codeline" id="line-441"><code>func (m *Matcher) stack(w Writer) bool {</code></span>
<span class="codeline" id="line-442"><code>	const maxStack = 16</code></span>
<span class="codeline" id="line-443"><code>	var stk [maxStack]uintptr</code></span>
<span class="codeline" id="line-444"><code>	n := runtime.Callers(2, stk[:])</code></span>
<span class="codeline" id="line-445"><code>	// caller #2 is not for printing; need it to normalize PCs if ASLR.</code></span>
<span class="codeline" id="line-446"><code>	if n &lt;= 1 {</code></span>
<span class="codeline" id="line-447"><code>		return false</code></span>
<span class="codeline" id="line-448"><code>	}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>	base := stk[0]</code></span>
<span class="codeline" id="line-451"><code>	// normalize PCs</code></span>
<span class="codeline" id="line-452"><code>	for i := range stk[:n] {</code></span>
<span class="codeline" id="line-453"><code>		stk[i] -= base</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	h := Hash(stk[:n])</code></span>
<span class="codeline" id="line-457"><code>	if m.ShouldPrint(h) {</code></span>
<span class="codeline" id="line-458"><code>		var d *dedup</code></span>
<span class="codeline" id="line-459"><code>		for {</code></span>
<span class="codeline" id="line-460"><code>			d = m.dedup.Load()</code></span>
<span class="codeline" id="line-461"><code>			if d != nil {</code></span>
<span class="codeline" id="line-462"><code>				break</code></span>
<span class="codeline" id="line-463"><code>			}</code></span>
<span class="codeline" id="line-464"><code>			d = new(dedup)</code></span>
<span class="codeline" id="line-465"><code>			if m.dedup.CompareAndSwap(nil, d) {</code></span>
<span class="codeline" id="line-466"><code>				break</code></span>
<span class="codeline" id="line-467"><code>			}</code></span>
<span class="codeline" id="line-468"><code>		}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>		if m.MarkerOnly() {</code></span>
<span class="codeline" id="line-471"><code>			if !d.seenLossy(h) {</code></span>
<span class="codeline" id="line-472"><code>				PrintMarker(w, h)</code></span>
<span class="codeline" id="line-473"><code>			}</code></span>
<span class="codeline" id="line-474"><code>		} else {</code></span>
<span class="codeline" id="line-475"><code>			if !d.seen(h) {</code></span>
<span class="codeline" id="line-476"><code>				// Restore PCs in stack for printing</code></span>
<span class="codeline" id="line-477"><code>				for i := range stk[:n] {</code></span>
<span class="codeline" id="line-478"><code>					stk[i] += base</code></span>
<span class="codeline" id="line-479"><code>				}</code></span>
<span class="codeline" id="line-480"><code>				printStack(w, h, stk[1:n])</code></span>
<span class="codeline" id="line-481"><code>			}</code></span>
<span class="codeline" id="line-482"><code>		}</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code>	return m.ShouldEnable(h)</code></span>
<span class="codeline" id="line-485"><code>}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>// Writer is the same interface as io.Writer.</code></span>
<span class="codeline" id="line-488"><code>// It is duplicated here to avoid importing io.</code></span>
<span class="codeline" id="line-489"><code>type Writer interface {</code></span>
<span class="codeline" id="line-490"><code>	Write([]byte) (int, error)</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// PrintMarker prints to w a one-line report containing only the marker for h.</code></span>
<span class="codeline" id="line-494"><code>// It is appropriate to use when [Matcher.ShouldPrint] and [Matcher.MarkerOnly] both return true.</code></span>
<span class="codeline" id="line-495"><code>func PrintMarker(w Writer, h uint64) error {</code></span>
<span class="codeline" id="line-496"><code>	var buf [50]byte</code></span>
<span class="codeline" id="line-497"><code>	b := AppendMarker(buf[:0], h)</code></span>
<span class="codeline" id="line-498"><code>	b = append(b, '\n')</code></span>
<span class="codeline" id="line-499"><code>	_, err := w.Write(b)</code></span>
<span class="codeline" id="line-500"><code>	return err</code></span>
<span class="codeline" id="line-501"><code>}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// printStack prints to w a multi-line report containing a formatting of the call stack stk,</code></span>
<span class="codeline" id="line-504"><code>// with each line preceded by the marker for h.</code></span>
<span class="codeline" id="line-505"><code>func printStack(w Writer, h uint64, stk []uintptr) error {</code></span>
<span class="codeline" id="line-506"><code>	buf := make([]byte, 0, 2048)</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>	var prefixBuf [100]byte</code></span>
<span class="codeline" id="line-509"><code>	prefix := AppendMarker(prefixBuf[:0], h)</code></span>
<span class="codeline" id="line-510"><code></code></span>
<span class="codeline" id="line-511"><code>	frames := runtime.CallersFrames(stk)</code></span>
<span class="codeline" id="line-512"><code>	for {</code></span>
<span class="codeline" id="line-513"><code>		f, more := frames.Next()</code></span>
<span class="codeline" id="line-514"><code>		buf = append(buf, prefix...)</code></span>
<span class="codeline" id="line-515"><code>		buf = append(buf, f.Func.Name()...)</code></span>
<span class="codeline" id="line-516"><code>		buf = append(buf, "()\n"...)</code></span>
<span class="codeline" id="line-517"><code>		buf = append(buf, prefix...)</code></span>
<span class="codeline" id="line-518"><code>		buf = append(buf, '\t')</code></span>
<span class="codeline" id="line-519"><code>		buf = appendFileLine(buf, f.File, f.Line)</code></span>
<span class="codeline" id="line-520"><code>		buf = append(buf, '\n')</code></span>
<span class="codeline" id="line-521"><code>		if !more {</code></span>
<span class="codeline" id="line-522"><code>			break</code></span>
<span class="codeline" id="line-523"><code>		}</code></span>
<span class="codeline" id="line-524"><code>	}</code></span>
<span class="codeline" id="line-525"><code>	buf = append(buf, prefix...)</code></span>
<span class="codeline" id="line-526"><code>	buf = append(buf, '\n')</code></span>
<span class="codeline" id="line-527"><code>	_, err := w.Write(buf)</code></span>
<span class="codeline" id="line-528"><code>	return err</code></span>
<span class="codeline" id="line-529"><code>}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>// Marker returns the match marker text to use on any line reporting details</code></span>
<span class="codeline" id="line-532"><code>// about a match of the given ID.</code></span>
<span class="codeline" id="line-533"><code>// It always returns the hexadecimal format.</code></span>
<span class="codeline" id="line-534"><code>func Marker(id uint64) string {</code></span>
<span class="codeline" id="line-535"><code>	return string(AppendMarker(nil, id))</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// AppendMarker is like [Marker] but appends the marker to dst.</code></span>
<span class="codeline" id="line-539"><code>func AppendMarker(dst []byte, id uint64) []byte {</code></span>
<span class="codeline" id="line-540"><code>	const prefix = "[bisect-match 0x"</code></span>
<span class="codeline" id="line-541"><code>	var buf [len(prefix) + 16 + 1]byte</code></span>
<span class="codeline" id="line-542"><code>	copy(buf[:], prefix)</code></span>
<span class="codeline" id="line-543"><code>	for i := 0; i &lt; 16; i++ {</code></span>
<span class="codeline" id="line-544"><code>		buf[len(prefix)+i] = "0123456789abcdef"[id&gt;&gt;60]</code></span>
<span class="codeline" id="line-545"><code>		id &lt;&lt;= 4</code></span>
<span class="codeline" id="line-546"><code>	}</code></span>
<span class="codeline" id="line-547"><code>	buf[len(prefix)+16] = ']'</code></span>
<span class="codeline" id="line-548"><code>	return append(dst, buf[:]...)</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>// CutMarker finds the first match marker in line and removes it,</code></span>
<span class="codeline" id="line-552"><code>// returning the shortened line (with the marker removed),</code></span>
<span class="codeline" id="line-553"><code>// the ID from the match marker,</code></span>
<span class="codeline" id="line-554"><code>// and whether a marker was found at all.</code></span>
<span class="codeline" id="line-555"><code>// If there is no marker, CutMarker returns line, 0, false.</code></span>
<span class="codeline" id="line-556"><code>func CutMarker(line string) (short string, id uint64, ok bool) {</code></span>
<span class="codeline" id="line-557"><code>	// Find first instance of prefix.</code></span>
<span class="codeline" id="line-558"><code>	prefix := "[bisect-match "</code></span>
<span class="codeline" id="line-559"><code>	i := 0</code></span>
<span class="codeline" id="line-560"><code>	for ; ; i++ {</code></span>
<span class="codeline" id="line-561"><code>		if i &gt;= len(line)-len(prefix) {</code></span>
<span class="codeline" id="line-562"><code>			return line, 0, false</code></span>
<span class="codeline" id="line-563"><code>		}</code></span>
<span class="codeline" id="line-564"><code>		if line[i] == '[' &amp;&amp; line[i:i+len(prefix)] == prefix {</code></span>
<span class="codeline" id="line-565"><code>			break</code></span>
<span class="codeline" id="line-566"><code>		}</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	// Scan to ].</code></span>
<span class="codeline" id="line-570"><code>	j := i + len(prefix)</code></span>
<span class="codeline" id="line-571"><code>	for j &lt; len(line) &amp;&amp; line[j] != ']' {</code></span>
<span class="codeline" id="line-572"><code>		j++</code></span>
<span class="codeline" id="line-573"><code>	}</code></span>
<span class="codeline" id="line-574"><code>	if j &gt;= len(line) {</code></span>
<span class="codeline" id="line-575"><code>		return line, 0, false</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>	// Parse id.</code></span>
<span class="codeline" id="line-579"><code>	idstr := line[i+len(prefix) : j]</code></span>
<span class="codeline" id="line-580"><code>	if len(idstr) &gt;= 3 &amp;&amp; idstr[:2] == "0x" {</code></span>
<span class="codeline" id="line-581"><code>		// parse hex</code></span>
<span class="codeline" id="line-582"><code>		if len(idstr) &gt; 2+16 { // max 0x + 16 digits</code></span>
<span class="codeline" id="line-583"><code>			return line, 0, false</code></span>
<span class="codeline" id="line-584"><code>		}</code></span>
<span class="codeline" id="line-585"><code>		for i := 2; i &lt; len(idstr); i++ {</code></span>
<span class="codeline" id="line-586"><code>			id &lt;&lt;= 4</code></span>
<span class="codeline" id="line-587"><code>			switch c := idstr[i]; {</code></span>
<span class="codeline" id="line-588"><code>			case '0' &lt;= c &amp;&amp; c &lt;= '9':</code></span>
<span class="codeline" id="line-589"><code>				id |= uint64(c - '0')</code></span>
<span class="codeline" id="line-590"><code>			case 'a' &lt;= c &amp;&amp; c &lt;= 'f':</code></span>
<span class="codeline" id="line-591"><code>				id |= uint64(c - 'a' + 10)</code></span>
<span class="codeline" id="line-592"><code>			case 'A' &lt;= c &amp;&amp; c &lt;= 'F':</code></span>
<span class="codeline" id="line-593"><code>				id |= uint64(c - 'A' + 10)</code></span>
<span class="codeline" id="line-594"><code>			}</code></span>
<span class="codeline" id="line-595"><code>		}</code></span>
<span class="codeline" id="line-596"><code>	} else {</code></span>
<span class="codeline" id="line-597"><code>		if idstr == "" || len(idstr) &gt; 64 { // min 1 digit, max 64 digits</code></span>
<span class="codeline" id="line-598"><code>			return line, 0, false</code></span>
<span class="codeline" id="line-599"><code>		}</code></span>
<span class="codeline" id="line-600"><code>		// parse binary</code></span>
<span class="codeline" id="line-601"><code>		for i := 0; i &lt; len(idstr); i++ {</code></span>
<span class="codeline" id="line-602"><code>			id &lt;&lt;= 1</code></span>
<span class="codeline" id="line-603"><code>			switch c := idstr[i]; c {</code></span>
<span class="codeline" id="line-604"><code>			default:</code></span>
<span class="codeline" id="line-605"><code>				return line, 0, false</code></span>
<span class="codeline" id="line-606"><code>			case '0', '1':</code></span>
<span class="codeline" id="line-607"><code>				id |= uint64(c - '0')</code></span>
<span class="codeline" id="line-608"><code>			}</code></span>
<span class="codeline" id="line-609"><code>		}</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>	// Construct shortened line.</code></span>
<span class="codeline" id="line-613"><code>	// Remove at most one space from around the marker,</code></span>
<span class="codeline" id="line-614"><code>	// so that "foo [marker] bar" shortens to "foo bar".</code></span>
<span class="codeline" id="line-615"><code>	j++ // skip ]</code></span>
<span class="codeline" id="line-616"><code>	if i &gt; 0 &amp;&amp; line[i-1] == ' ' {</code></span>
<span class="codeline" id="line-617"><code>		i--</code></span>
<span class="codeline" id="line-618"><code>	} else if j &lt; len(line) &amp;&amp; line[j] == ' ' {</code></span>
<span class="codeline" id="line-619"><code>		j++</code></span>
<span class="codeline" id="line-620"><code>	}</code></span>
<span class="codeline" id="line-621"><code>	short = line[:i] + line[j:]</code></span>
<span class="codeline" id="line-622"><code>	return short, id, true</code></span>
<span class="codeline" id="line-623"><code>}</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>// Hash computes a hash of the data arguments,</code></span>
<span class="codeline" id="line-626"><code>// each of which must be of type string, byte, int, uint, int32, uint32, int64, uint64, uintptr, or a slice of one of those types.</code></span>
<span class="codeline" id="line-627"><code>func Hash(data ...any) uint64 {</code></span>
<span class="codeline" id="line-628"><code>	h := offset64</code></span>
<span class="codeline" id="line-629"><code>	for _, v := range data {</code></span>
<span class="codeline" id="line-630"><code>		switch v := v.(type) {</code></span>
<span class="codeline" id="line-631"><code>		default:</code></span>
<span class="codeline" id="line-632"><code>			// Note: Not printing the type, because reflect.ValueOf(v)</code></span>
<span class="codeline" id="line-633"><code>			// would make the interfaces prepared by the caller escape</code></span>
<span class="codeline" id="line-634"><code>			// and therefore allocate. This way, Hash(file, line) runs</code></span>
<span class="codeline" id="line-635"><code>			// without any allocation. It should be clear from the</code></span>
<span class="codeline" id="line-636"><code>			// source code calling Hash what the bad argument was.</code></span>
<span class="codeline" id="line-637"><code>			panic("bisect.Hash: unexpected argument type")</code></span>
<span class="codeline" id="line-638"><code>		case string:</code></span>
<span class="codeline" id="line-639"><code>			h = fnvString(h, v)</code></span>
<span class="codeline" id="line-640"><code>		case byte:</code></span>
<span class="codeline" id="line-641"><code>			h = fnv(h, v)</code></span>
<span class="codeline" id="line-642"><code>		case int:</code></span>
<span class="codeline" id="line-643"><code>			h = fnvUint64(h, uint64(v))</code></span>
<span class="codeline" id="line-644"><code>		case uint:</code></span>
<span class="codeline" id="line-645"><code>			h = fnvUint64(h, uint64(v))</code></span>
<span class="codeline" id="line-646"><code>		case int32:</code></span>
<span class="codeline" id="line-647"><code>			h = fnvUint32(h, uint32(v))</code></span>
<span class="codeline" id="line-648"><code>		case uint32:</code></span>
<span class="codeline" id="line-649"><code>			h = fnvUint32(h, v)</code></span>
<span class="codeline" id="line-650"><code>		case int64:</code></span>
<span class="codeline" id="line-651"><code>			h = fnvUint64(h, uint64(v))</code></span>
<span class="codeline" id="line-652"><code>		case uint64:</code></span>
<span class="codeline" id="line-653"><code>			h = fnvUint64(h, v)</code></span>
<span class="codeline" id="line-654"><code>		case uintptr:</code></span>
<span class="codeline" id="line-655"><code>			h = fnvUint64(h, uint64(v))</code></span>
<span class="codeline" id="line-656"><code>		case []string:</code></span>
<span class="codeline" id="line-657"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-658"><code>				h = fnvString(h, x)</code></span>
<span class="codeline" id="line-659"><code>			}</code></span>
<span class="codeline" id="line-660"><code>		case []byte:</code></span>
<span class="codeline" id="line-661"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-662"><code>				h = fnv(h, x)</code></span>
<span class="codeline" id="line-663"><code>			}</code></span>
<span class="codeline" id="line-664"><code>		case []int:</code></span>
<span class="codeline" id="line-665"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-666"><code>				h = fnvUint64(h, uint64(x))</code></span>
<span class="codeline" id="line-667"><code>			}</code></span>
<span class="codeline" id="line-668"><code>		case []uint:</code></span>
<span class="codeline" id="line-669"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-670"><code>				h = fnvUint64(h, uint64(x))</code></span>
<span class="codeline" id="line-671"><code>			}</code></span>
<span class="codeline" id="line-672"><code>		case []int32:</code></span>
<span class="codeline" id="line-673"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-674"><code>				h = fnvUint32(h, uint32(x))</code></span>
<span class="codeline" id="line-675"><code>			}</code></span>
<span class="codeline" id="line-676"><code>		case []uint32:</code></span>
<span class="codeline" id="line-677"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-678"><code>				h = fnvUint32(h, x)</code></span>
<span class="codeline" id="line-679"><code>			}</code></span>
<span class="codeline" id="line-680"><code>		case []int64:</code></span>
<span class="codeline" id="line-681"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-682"><code>				h = fnvUint64(h, uint64(x))</code></span>
<span class="codeline" id="line-683"><code>			}</code></span>
<span class="codeline" id="line-684"><code>		case []uint64:</code></span>
<span class="codeline" id="line-685"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-686"><code>				h = fnvUint64(h, x)</code></span>
<span class="codeline" id="line-687"><code>			}</code></span>
<span class="codeline" id="line-688"><code>		case []uintptr:</code></span>
<span class="codeline" id="line-689"><code>			for _, x := range v {</code></span>
<span class="codeline" id="line-690"><code>				h = fnvUint64(h, uint64(x))</code></span>
<span class="codeline" id="line-691"><code>			}</code></span>
<span class="codeline" id="line-692"><code>		}</code></span>
<span class="codeline" id="line-693"><code>	}</code></span>
<span class="codeline" id="line-694"><code>	return h</code></span>
<span class="codeline" id="line-695"><code>}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>// Trivial error implementation, here to avoid importing errors.</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// parseError is a trivial error implementation,</code></span>
<span class="codeline" id="line-700"><code>// defined here to avoid importing errors.</code></span>
<span class="codeline" id="line-701"><code>type parseError struct{ text string }</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>func (e *parseError) Error() string { return e.text }</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>// FNV-1a implementation. See Go's hash/fnv/fnv.go.</code></span>
<span class="codeline" id="line-706"><code>// Copied here for simplicity (can handle integers more directly)</code></span>
<span class="codeline" id="line-707"><code>// and to avoid importing hash/fnv.</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>const (</code></span>
<span class="codeline" id="line-710"><code>	offset64 uint64 = 14695981039346656037</code></span>
<span class="codeline" id="line-711"><code>	prime64  uint64 = 1099511628211</code></span>
<span class="codeline" id="line-712"><code>)</code></span>
<span class="codeline" id="line-713"><code></code></span>
<span class="codeline" id="line-714"><code>func fnv(h uint64, x byte) uint64 {</code></span>
<span class="codeline" id="line-715"><code>	h ^= uint64(x)</code></span>
<span class="codeline" id="line-716"><code>	h *= prime64</code></span>
<span class="codeline" id="line-717"><code>	return h</code></span>
<span class="codeline" id="line-718"><code>}</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>func fnvString(h uint64, x string) uint64 {</code></span>
<span class="codeline" id="line-721"><code>	for i := 0; i &lt; len(x); i++ {</code></span>
<span class="codeline" id="line-722"><code>		h ^= uint64(x[i])</code></span>
<span class="codeline" id="line-723"><code>		h *= prime64</code></span>
<span class="codeline" id="line-724"><code>	}</code></span>
<span class="codeline" id="line-725"><code>	return h</code></span>
<span class="codeline" id="line-726"><code>}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>func fnvUint64(h uint64, x uint64) uint64 {</code></span>
<span class="codeline" id="line-729"><code>	for i := 0; i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-730"><code>		h ^= x &amp; 0xFF</code></span>
<span class="codeline" id="line-731"><code>		x &gt;&gt;= 8</code></span>
<span class="codeline" id="line-732"><code>		h *= prime64</code></span>
<span class="codeline" id="line-733"><code>	}</code></span>
<span class="codeline" id="line-734"><code>	return h</code></span>
<span class="codeline" id="line-735"><code>}</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>func fnvUint32(h uint64, x uint32) uint64 {</code></span>
<span class="codeline" id="line-738"><code>	for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-739"><code>		h ^= uint64(x &amp; 0xFF)</code></span>
<span class="codeline" id="line-740"><code>		x &gt;&gt;= 8</code></span>
<span class="codeline" id="line-741"><code>		h *= prime64</code></span>
<span class="codeline" id="line-742"><code>	}</code></span>
<span class="codeline" id="line-743"><code>	return h</code></span>
<span class="codeline" id="line-744"><code>}</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>// A dedup is a deduplicator for call stacks, so that we only print</code></span>
<span class="codeline" id="line-747"><code>// a report for new call stacks, not for call stacks we've already</code></span>
<span class="codeline" id="line-748"><code>// reported.</code></span>
<span class="codeline" id="line-749"><code>//</code></span>
<span class="codeline" id="line-750"><code>// It has two modes: an approximate but lock-free mode that</code></span>
<span class="codeline" id="line-751"><code>// may still emit some duplicates, and a precise mode that uses</code></span>
<span class="codeline" id="line-752"><code>// a lock and never emits duplicates.</code></span>
<span class="codeline" id="line-753"><code>type dedup struct {</code></span>
<span class="codeline" id="line-754"><code>	// 128-entry 4-way, lossy cache for seenLossy</code></span>
<span class="codeline" id="line-755"><code>	recent [128][4]uint64</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>	// complete history for seen</code></span>
<span class="codeline" id="line-758"><code>	mu sync.Mutex</code></span>
<span class="codeline" id="line-759"><code>	m  map[uint64]bool</code></span>
<span class="codeline" id="line-760"><code>}</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>// seen records that h has now been seen and reports whether it was seen before.</code></span>
<span class="codeline" id="line-763"><code>// When seen returns false, the caller is expected to print a report for h.</code></span>
<span class="codeline" id="line-764"><code>func (d *dedup) seen(h uint64) bool {</code></span>
<span class="codeline" id="line-765"><code>	d.mu.Lock()</code></span>
<span class="codeline" id="line-766"><code>	if d.m == nil {</code></span>
<span class="codeline" id="line-767"><code>		d.m = make(map[uint64]bool)</code></span>
<span class="codeline" id="line-768"><code>	}</code></span>
<span class="codeline" id="line-769"><code>	seen := d.m[h]</code></span>
<span class="codeline" id="line-770"><code>	d.m[h] = true</code></span>
<span class="codeline" id="line-771"><code>	d.mu.Unlock()</code></span>
<span class="codeline" id="line-772"><code>	return seen</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>// seenLossy is a variant of seen that avoids a lock by using a cache of recently seen hashes.</code></span>
<span class="codeline" id="line-776"><code>// Each cache entry is N-way set-associative: h can appear in any of the slots.</code></span>
<span class="codeline" id="line-777"><code>// If h does not appear in any of them, then it is inserted into a random slot,</code></span>
<span class="codeline" id="line-778"><code>// overwriting whatever was there before.</code></span>
<span class="codeline" id="line-779"><code>func (d *dedup) seenLossy(h uint64) bool {</code></span>
<span class="codeline" id="line-780"><code>	cache := &amp;d.recent[uint(h)%uint(len(d.recent))]</code></span>
<span class="codeline" id="line-781"><code>	for i := 0; i &lt; len(cache); i++ {</code></span>
<span class="codeline" id="line-782"><code>		if atomic.LoadUint64(&amp;cache[i]) == h {</code></span>
<span class="codeline" id="line-783"><code>			return true</code></span>
<span class="codeline" id="line-784"><code>		}</code></span>
<span class="codeline" id="line-785"><code>	}</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>	// Compute index in set to evict as hash of current set.</code></span>
<span class="codeline" id="line-788"><code>	ch := offset64</code></span>
<span class="codeline" id="line-789"><code>	for _, x := range cache {</code></span>
<span class="codeline" id="line-790"><code>		ch = fnvUint64(ch, x)</code></span>
<span class="codeline" id="line-791"><code>	}</code></span>
<span class="codeline" id="line-792"><code>	atomic.StoreUint64(&amp;cache[uint(ch)%uint(len(cache))], h)</code></span>
<span class="codeline" id="line-793"><code>	return false</code></span>
<span class="codeline" id="line-794"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>