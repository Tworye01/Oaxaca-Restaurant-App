<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: type.go in package internal/abi</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	type.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/internal/abi.html">internal/abi</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2023 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package abi</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"unsafe"</code></span>
<span class="codeline" id="line-9"><code>)</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>// Type is the runtime representation of a Go type.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>// Be careful about accessing this type at build time, as the version</code></span>
<span class="codeline" id="line-14"><code>// of this type in the compiler/linker may not have the same layout</code></span>
<span class="codeline" id="line-15"><code>// as the version in the target binary, due to pointer width</code></span>
<span class="codeline" id="line-16"><code>// differences and any experiments. Use cmd/compile/internal/rttype</code></span>
<span class="codeline" id="line-17"><code>// or the functions in compiletype.go to access this type instead.</code></span>
<span class="codeline" id="line-18"><code>// (TODO: this admonition applies to every type in this package.</code></span>
<span class="codeline" id="line-19"><code>// Put it in some shared location?)</code></span>
<span class="codeline" id="line-20"><code>type Type struct {</code></span>
<span class="codeline" id="line-21"><code>	Size_       uintptr</code></span>
<span class="codeline" id="line-22"><code>	PtrBytes    uintptr // number of (prefix) bytes in the type that can contain pointers</code></span>
<span class="codeline" id="line-23"><code>	Hash        uint32  // hash of type; avoids computation in hash tables</code></span>
<span class="codeline" id="line-24"><code>	TFlag       TFlag   // extra type information flags</code></span>
<span class="codeline" id="line-25"><code>	Align_      uint8   // alignment of variable with this type</code></span>
<span class="codeline" id="line-26"><code>	FieldAlign_ uint8   // alignment of struct field with this type</code></span>
<span class="codeline" id="line-27"><code>	Kind_       uint8   // enumeration for C</code></span>
<span class="codeline" id="line-28"><code>	// function for comparing objects of this type</code></span>
<span class="codeline" id="line-29"><code>	// (ptr to object A, ptr to object B) -&gt; ==?</code></span>
<span class="codeline" id="line-30"><code>	Equal func(unsafe.Pointer, unsafe.Pointer) bool</code></span>
<span class="codeline" id="line-31"><code>	// GCData stores the GC type data for the garbage collector.</code></span>
<span class="codeline" id="line-32"><code>	// If the KindGCProg bit is set in kind, GCData is a GC program.</code></span>
<span class="codeline" id="line-33"><code>	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</code></span>
<span class="codeline" id="line-34"><code>	GCData    *byte</code></span>
<span class="codeline" id="line-35"><code>	Str       NameOff // string form</code></span>
<span class="codeline" id="line-36"><code>	PtrToThis TypeOff // type for pointer to this type, may be zero</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// A Kind represents the specific kind of type that a Type represents.</code></span>
<span class="codeline" id="line-40"><code>// The zero Kind is not a valid kind.</code></span>
<span class="codeline" id="line-41"><code>type Kind uint</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>const (</code></span>
<span class="codeline" id="line-44"><code>	Invalid Kind = iota</code></span>
<span class="codeline" id="line-45"><code>	Bool</code></span>
<span class="codeline" id="line-46"><code>	Int</code></span>
<span class="codeline" id="line-47"><code>	Int8</code></span>
<span class="codeline" id="line-48"><code>	Int16</code></span>
<span class="codeline" id="line-49"><code>	Int32</code></span>
<span class="codeline" id="line-50"><code>	Int64</code></span>
<span class="codeline" id="line-51"><code>	Uint</code></span>
<span class="codeline" id="line-52"><code>	Uint8</code></span>
<span class="codeline" id="line-53"><code>	Uint16</code></span>
<span class="codeline" id="line-54"><code>	Uint32</code></span>
<span class="codeline" id="line-55"><code>	Uint64</code></span>
<span class="codeline" id="line-56"><code>	Uintptr</code></span>
<span class="codeline" id="line-57"><code>	Float32</code></span>
<span class="codeline" id="line-58"><code>	Float64</code></span>
<span class="codeline" id="line-59"><code>	Complex64</code></span>
<span class="codeline" id="line-60"><code>	Complex128</code></span>
<span class="codeline" id="line-61"><code>	Array</code></span>
<span class="codeline" id="line-62"><code>	Chan</code></span>
<span class="codeline" id="line-63"><code>	Func</code></span>
<span class="codeline" id="line-64"><code>	Interface</code></span>
<span class="codeline" id="line-65"><code>	Map</code></span>
<span class="codeline" id="line-66"><code>	Pointer</code></span>
<span class="codeline" id="line-67"><code>	Slice</code></span>
<span class="codeline" id="line-68"><code>	String</code></span>
<span class="codeline" id="line-69"><code>	Struct</code></span>
<span class="codeline" id="line-70"><code>	UnsafePointer</code></span>
<span class="codeline" id="line-71"><code>)</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>const (</code></span>
<span class="codeline" id="line-74"><code>	// TODO (khr, drchase) why aren't these in TFlag?  Investigate, fix if possible.</code></span>
<span class="codeline" id="line-75"><code>	KindDirectIface = 1 &lt;&lt; 5</code></span>
<span class="codeline" id="line-76"><code>	KindGCProg      = 1 &lt;&lt; 6 // Type.gc points to GC program</code></span>
<span class="codeline" id="line-77"><code>	KindMask        = (1 &lt;&lt; 5) - 1</code></span>
<span class="codeline" id="line-78"><code>)</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>// TFlag is used by a Type to signal what extra type information is</code></span>
<span class="codeline" id="line-81"><code>// available in the memory directly following the Type value.</code></span>
<span class="codeline" id="line-82"><code>type TFlag uint8</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>const (</code></span>
<span class="codeline" id="line-85"><code>	// TFlagUncommon means that there is a data with a type, UncommonType,</code></span>
<span class="codeline" id="line-86"><code>	// just beyond the shared-per-type common data.  That is, the data</code></span>
<span class="codeline" id="line-87"><code>	// for struct types will store their UncommonType at one offset, the</code></span>
<span class="codeline" id="line-88"><code>	// data for interface types will store their UncommonType at a different</code></span>
<span class="codeline" id="line-89"><code>	// offset.  UncommonType is always accessed via a pointer that is computed</code></span>
<span class="codeline" id="line-90"><code>	// using trust-us-we-are-the-implementors pointer arithmetic.</code></span>
<span class="codeline" id="line-91"><code>	//</code></span>
<span class="codeline" id="line-92"><code>	// For example, if t.Kind() == Struct and t.tflag&amp;TFlagUncommon != 0,</code></span>
<span class="codeline" id="line-93"><code>	// then t has UncommonType data and it can be accessed as:</code></span>
<span class="codeline" id="line-94"><code>	//</code></span>
<span class="codeline" id="line-95"><code>	//	type structTypeUncommon struct {</code></span>
<span class="codeline" id="line-96"><code>	//		structType</code></span>
<span class="codeline" id="line-97"><code>	//		u UncommonType</code></span>
<span class="codeline" id="line-98"><code>	//	}</code></span>
<span class="codeline" id="line-99"><code>	//	u := &amp;(*structTypeUncommon)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-100"><code>	TFlagUncommon TFlag = 1 &lt;&lt; 0</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>	// TFlagExtraStar means the name in the str field has an</code></span>
<span class="codeline" id="line-103"><code>	// extraneous '*' prefix. This is because for most types T in</code></span>
<span class="codeline" id="line-104"><code>	// a program, the type *T also exists and reusing the str data</code></span>
<span class="codeline" id="line-105"><code>	// saves binary size.</code></span>
<span class="codeline" id="line-106"><code>	TFlagExtraStar TFlag = 1 &lt;&lt; 1</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>	// TFlagNamed means the type has a name.</code></span>
<span class="codeline" id="line-109"><code>	TFlagNamed TFlag = 1 &lt;&lt; 2</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>	// TFlagRegularMemory means that equal and hash functions can treat</code></span>
<span class="codeline" id="line-112"><code>	// this type as a single region of t.size bytes.</code></span>
<span class="codeline" id="line-113"><code>	TFlagRegularMemory TFlag = 1 &lt;&lt; 3</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>	// TFlagUnrolledBitmap marks special types that are unrolled-bitmap</code></span>
<span class="codeline" id="line-116"><code>	// versions of types with GC programs.</code></span>
<span class="codeline" id="line-117"><code>	// These types need to be deallocated when the underlying object</code></span>
<span class="codeline" id="line-118"><code>	// is freed.</code></span>
<span class="codeline" id="line-119"><code>	TFlagUnrolledBitmap TFlag = 1 &lt;&lt; 4</code></span>
<span class="codeline" id="line-120"><code>)</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// NameOff is the offset to a name from moduledata.types.  See resolveNameOff in runtime.</code></span>
<span class="codeline" id="line-123"><code>type NameOff int32</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>// TypeOff is the offset to a type from moduledata.types.  See resolveTypeOff in runtime.</code></span>
<span class="codeline" id="line-126"><code>type TypeOff int32</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>// TextOff is an offset from the top of a text section.  See (rtype).textOff in runtime.</code></span>
<span class="codeline" id="line-129"><code>type TextOff int32</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>// String returns the name of k.</code></span>
<span class="codeline" id="line-132"><code>func (k Kind) String() string {</code></span>
<span class="codeline" id="line-133"><code>	if int(k) &lt; len(kindNames) {</code></span>
<span class="codeline" id="line-134"><code>		return kindNames[k]</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code>	return kindNames[0]</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>var kindNames = []string{</code></span>
<span class="codeline" id="line-140"><code>	Invalid:       "invalid",</code></span>
<span class="codeline" id="line-141"><code>	Bool:          "bool",</code></span>
<span class="codeline" id="line-142"><code>	Int:           "int",</code></span>
<span class="codeline" id="line-143"><code>	Int8:          "int8",</code></span>
<span class="codeline" id="line-144"><code>	Int16:         "int16",</code></span>
<span class="codeline" id="line-145"><code>	Int32:         "int32",</code></span>
<span class="codeline" id="line-146"><code>	Int64:         "int64",</code></span>
<span class="codeline" id="line-147"><code>	Uint:          "uint",</code></span>
<span class="codeline" id="line-148"><code>	Uint8:         "uint8",</code></span>
<span class="codeline" id="line-149"><code>	Uint16:        "uint16",</code></span>
<span class="codeline" id="line-150"><code>	Uint32:        "uint32",</code></span>
<span class="codeline" id="line-151"><code>	Uint64:        "uint64",</code></span>
<span class="codeline" id="line-152"><code>	Uintptr:       "uintptr",</code></span>
<span class="codeline" id="line-153"><code>	Float32:       "float32",</code></span>
<span class="codeline" id="line-154"><code>	Float64:       "float64",</code></span>
<span class="codeline" id="line-155"><code>	Complex64:     "complex64",</code></span>
<span class="codeline" id="line-156"><code>	Complex128:    "complex128",</code></span>
<span class="codeline" id="line-157"><code>	Array:         "array",</code></span>
<span class="codeline" id="line-158"><code>	Chan:          "chan",</code></span>
<span class="codeline" id="line-159"><code>	Func:          "func",</code></span>
<span class="codeline" id="line-160"><code>	Interface:     "interface",</code></span>
<span class="codeline" id="line-161"><code>	Map:           "map",</code></span>
<span class="codeline" id="line-162"><code>	Pointer:       "ptr",</code></span>
<span class="codeline" id="line-163"><code>	Slice:         "slice",</code></span>
<span class="codeline" id="line-164"><code>	String:        "string",</code></span>
<span class="codeline" id="line-165"><code>	Struct:        "struct",</code></span>
<span class="codeline" id="line-166"><code>	UnsafePointer: "unsafe.Pointer",</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>func (t *Type) Kind() Kind { return Kind(t.Kind_ &amp; KindMask) }</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>func (t *Type) HasName() bool {</code></span>
<span class="codeline" id="line-172"><code>	return t.TFlag&amp;TFlagNamed != 0</code></span>
<span class="codeline" id="line-173"><code>}</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>func (t *Type) Pointers() bool { return t.PtrBytes != 0 }</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// IfaceIndir reports whether t is stored indirectly in an interface value.</code></span>
<span class="codeline" id="line-178"><code>func (t *Type) IfaceIndir() bool {</code></span>
<span class="codeline" id="line-179"><code>	return t.Kind_&amp;KindDirectIface == 0</code></span>
<span class="codeline" id="line-180"><code>}</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>// isDirectIface reports whether t is stored directly in an interface value.</code></span>
<span class="codeline" id="line-183"><code>func (t *Type) IsDirectIface() bool {</code></span>
<span class="codeline" id="line-184"><code>	return t.Kind_&amp;KindDirectIface != 0</code></span>
<span class="codeline" id="line-185"><code>}</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>func (t *Type) GcSlice(begin, end uintptr) []byte {</code></span>
<span class="codeline" id="line-188"><code>	return unsafe.Slice(t.GCData, int(end))[begin:]</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// Method on non-interface type</code></span>
<span class="codeline" id="line-192"><code>type Method struct {</code></span>
<span class="codeline" id="line-193"><code>	Name NameOff // name of method</code></span>
<span class="codeline" id="line-194"><code>	Mtyp TypeOff // method type (without receiver)</code></span>
<span class="codeline" id="line-195"><code>	Ifn  TextOff // fn used in interface call (one-word receiver)</code></span>
<span class="codeline" id="line-196"><code>	Tfn  TextOff // fn used for normal method call</code></span>
<span class="codeline" id="line-197"><code>}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>// UncommonType is present only for defined types or types with methods</code></span>
<span class="codeline" id="line-200"><code>// (if T is a defined type, the uncommonTypes for T and *T have methods).</code></span>
<span class="codeline" id="line-201"><code>// Using a pointer to this struct reduces the overall size required</code></span>
<span class="codeline" id="line-202"><code>// to describe a non-defined type with no methods.</code></span>
<span class="codeline" id="line-203"><code>type UncommonType struct {</code></span>
<span class="codeline" id="line-204"><code>	PkgPath NameOff // import path; empty for built-in types like int, string</code></span>
<span class="codeline" id="line-205"><code>	Mcount  uint16  // number of methods</code></span>
<span class="codeline" id="line-206"><code>	Xcount  uint16  // number of exported methods</code></span>
<span class="codeline" id="line-207"><code>	Moff    uint32  // offset from this uncommontype to [mcount]Method</code></span>
<span class="codeline" id="line-208"><code>	_       uint32  // unused</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>func (t *UncommonType) Methods() []Method {</code></span>
<span class="codeline" id="line-212"><code>	if t.Mcount == 0 {</code></span>
<span class="codeline" id="line-213"><code>		return nil</code></span>
<span class="codeline" id="line-214"><code>	}</code></span>
<span class="codeline" id="line-215"><code>	return (*[1 &lt;&lt; 16]Method)(addChecked(unsafe.Pointer(t), uintptr(t.Moff), "t.mcount &gt; 0"))[:t.Mcount:t.Mcount]</code></span>
<span class="codeline" id="line-216"><code>}</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>func (t *UncommonType) ExportedMethods() []Method {</code></span>
<span class="codeline" id="line-219"><code>	if t.Xcount == 0 {</code></span>
<span class="codeline" id="line-220"><code>		return nil</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	return (*[1 &lt;&lt; 16]Method)(addChecked(unsafe.Pointer(t), uintptr(t.Moff), "t.xcount &gt; 0"))[:t.Xcount:t.Xcount]</code></span>
<span class="codeline" id="line-223"><code>}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>// addChecked returns p+x.</code></span>
<span class="codeline" id="line-226"><code>//</code></span>
<span class="codeline" id="line-227"><code>// The whySafe string is ignored, so that the function still inlines</code></span>
<span class="codeline" id="line-228"><code>// as efficiently as p+x, but all call sites should use the string to</code></span>
<span class="codeline" id="line-229"><code>// record why the addition is safe, which is to say why the addition</code></span>
<span class="codeline" id="line-230"><code>// does not cause x to advance to the very end of p's allocation</code></span>
<span class="codeline" id="line-231"><code>// and therefore point incorrectly at the next block in memory.</code></span>
<span class="codeline" id="line-232"><code>func addChecked(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer {</code></span>
<span class="codeline" id="line-233"><code>	return unsafe.Pointer(uintptr(p) + x)</code></span>
<span class="codeline" id="line-234"><code>}</code></span>
<span class="codeline" id="line-235"><code></code></span>
<span class="codeline" id="line-236"><code>// Imethod represents a method on an interface type</code></span>
<span class="codeline" id="line-237"><code>type Imethod struct {</code></span>
<span class="codeline" id="line-238"><code>	Name NameOff // name of method</code></span>
<span class="codeline" id="line-239"><code>	Typ  TypeOff // .(*FuncType) underneath</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>// ArrayType represents a fixed array type.</code></span>
<span class="codeline" id="line-243"><code>type ArrayType struct {</code></span>
<span class="codeline" id="line-244"><code>	Type</code></span>
<span class="codeline" id="line-245"><code>	Elem  *Type // array element type</code></span>
<span class="codeline" id="line-246"><code>	Slice *Type // slice type</code></span>
<span class="codeline" id="line-247"><code>	Len   uintptr</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// Len returns the length of t if t is an array type, otherwise 0</code></span>
<span class="codeline" id="line-251"><code>func (t *Type) Len() int {</code></span>
<span class="codeline" id="line-252"><code>	if t.Kind() == Array {</code></span>
<span class="codeline" id="line-253"><code>		return int((*ArrayType)(unsafe.Pointer(t)).Len)</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code>	return 0</code></span>
<span class="codeline" id="line-256"><code>}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>func (t *Type) Common() *Type {</code></span>
<span class="codeline" id="line-259"><code>	return t</code></span>
<span class="codeline" id="line-260"><code>}</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>type ChanDir int</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>const (</code></span>
<span class="codeline" id="line-265"><code>	RecvDir    ChanDir = 1 &lt;&lt; iota         // &lt;-chan</code></span>
<span class="codeline" id="line-266"><code>	SendDir                                // chan&lt;-</code></span>
<span class="codeline" id="line-267"><code>	BothDir            = RecvDir | SendDir // chan</code></span>
<span class="codeline" id="line-268"><code>	InvalidDir ChanDir = 0</code></span>
<span class="codeline" id="line-269"><code>)</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>// ChanType represents a channel type</code></span>
<span class="codeline" id="line-272"><code>type ChanType struct {</code></span>
<span class="codeline" id="line-273"><code>	Type</code></span>
<span class="codeline" id="line-274"><code>	Elem *Type</code></span>
<span class="codeline" id="line-275"><code>	Dir  ChanDir</code></span>
<span class="codeline" id="line-276"><code>}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>type structTypeUncommon struct {</code></span>
<span class="codeline" id="line-279"><code>	StructType</code></span>
<span class="codeline" id="line-280"><code>	u UncommonType</code></span>
<span class="codeline" id="line-281"><code>}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>// ChanDir returns the direction of t if t is a channel type, otherwise InvalidDir (0).</code></span>
<span class="codeline" id="line-284"><code>func (t *Type) ChanDir() ChanDir {</code></span>
<span class="codeline" id="line-285"><code>	if t.Kind() == Chan {</code></span>
<span class="codeline" id="line-286"><code>		ch := (*ChanType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-287"><code>		return ch.Dir</code></span>
<span class="codeline" id="line-288"><code>	}</code></span>
<span class="codeline" id="line-289"><code>	return InvalidDir</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>// Uncommon returns a pointer to T's "uncommon" data if there is any, otherwise nil</code></span>
<span class="codeline" id="line-293"><code>func (t *Type) Uncommon() *UncommonType {</code></span>
<span class="codeline" id="line-294"><code>	if t.TFlag&amp;TFlagUncommon == 0 {</code></span>
<span class="codeline" id="line-295"><code>		return nil</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	switch t.Kind() {</code></span>
<span class="codeline" id="line-298"><code>	case Struct:</code></span>
<span class="codeline" id="line-299"><code>		return &amp;(*structTypeUncommon)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-300"><code>	case Pointer:</code></span>
<span class="codeline" id="line-301"><code>		type u struct {</code></span>
<span class="codeline" id="line-302"><code>			PtrType</code></span>
<span class="codeline" id="line-303"><code>			u UncommonType</code></span>
<span class="codeline" id="line-304"><code>		}</code></span>
<span class="codeline" id="line-305"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-306"><code>	case Func:</code></span>
<span class="codeline" id="line-307"><code>		type u struct {</code></span>
<span class="codeline" id="line-308"><code>			FuncType</code></span>
<span class="codeline" id="line-309"><code>			u UncommonType</code></span>
<span class="codeline" id="line-310"><code>		}</code></span>
<span class="codeline" id="line-311"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-312"><code>	case Slice:</code></span>
<span class="codeline" id="line-313"><code>		type u struct {</code></span>
<span class="codeline" id="line-314"><code>			SliceType</code></span>
<span class="codeline" id="line-315"><code>			u UncommonType</code></span>
<span class="codeline" id="line-316"><code>		}</code></span>
<span class="codeline" id="line-317"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-318"><code>	case Array:</code></span>
<span class="codeline" id="line-319"><code>		type u struct {</code></span>
<span class="codeline" id="line-320"><code>			ArrayType</code></span>
<span class="codeline" id="line-321"><code>			u UncommonType</code></span>
<span class="codeline" id="line-322"><code>		}</code></span>
<span class="codeline" id="line-323"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-324"><code>	case Chan:</code></span>
<span class="codeline" id="line-325"><code>		type u struct {</code></span>
<span class="codeline" id="line-326"><code>			ChanType</code></span>
<span class="codeline" id="line-327"><code>			u UncommonType</code></span>
<span class="codeline" id="line-328"><code>		}</code></span>
<span class="codeline" id="line-329"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-330"><code>	case Map:</code></span>
<span class="codeline" id="line-331"><code>		type u struct {</code></span>
<span class="codeline" id="line-332"><code>			MapType</code></span>
<span class="codeline" id="line-333"><code>			u UncommonType</code></span>
<span class="codeline" id="line-334"><code>		}</code></span>
<span class="codeline" id="line-335"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-336"><code>	case Interface:</code></span>
<span class="codeline" id="line-337"><code>		type u struct {</code></span>
<span class="codeline" id="line-338"><code>			InterfaceType</code></span>
<span class="codeline" id="line-339"><code>			u UncommonType</code></span>
<span class="codeline" id="line-340"><code>		}</code></span>
<span class="codeline" id="line-341"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-342"><code>	default:</code></span>
<span class="codeline" id="line-343"><code>		type u struct {</code></span>
<span class="codeline" id="line-344"><code>			Type</code></span>
<span class="codeline" id="line-345"><code>			u UncommonType</code></span>
<span class="codeline" id="line-346"><code>		}</code></span>
<span class="codeline" id="line-347"><code>		return &amp;(*u)(unsafe.Pointer(t)).u</code></span>
<span class="codeline" id="line-348"><code>	}</code></span>
<span class="codeline" id="line-349"><code>}</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>// Elem returns the element type for t if t is an array, channel, map, pointer, or slice, otherwise nil.</code></span>
<span class="codeline" id="line-352"><code>func (t *Type) Elem() *Type {</code></span>
<span class="codeline" id="line-353"><code>	switch t.Kind() {</code></span>
<span class="codeline" id="line-354"><code>	case Array:</code></span>
<span class="codeline" id="line-355"><code>		tt := (*ArrayType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-356"><code>		return tt.Elem</code></span>
<span class="codeline" id="line-357"><code>	case Chan:</code></span>
<span class="codeline" id="line-358"><code>		tt := (*ChanType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-359"><code>		return tt.Elem</code></span>
<span class="codeline" id="line-360"><code>	case Map:</code></span>
<span class="codeline" id="line-361"><code>		tt := (*MapType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-362"><code>		return tt.Elem</code></span>
<span class="codeline" id="line-363"><code>	case Pointer:</code></span>
<span class="codeline" id="line-364"><code>		tt := (*PtrType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-365"><code>		return tt.Elem</code></span>
<span class="codeline" id="line-366"><code>	case Slice:</code></span>
<span class="codeline" id="line-367"><code>		tt := (*SliceType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-368"><code>		return tt.Elem</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>	return nil</code></span>
<span class="codeline" id="line-371"><code>}</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>// StructType returns t cast to a *StructType, or nil if its tag does not match.</code></span>
<span class="codeline" id="line-374"><code>func (t *Type) StructType() *StructType {</code></span>
<span class="codeline" id="line-375"><code>	if t.Kind() != Struct {</code></span>
<span class="codeline" id="line-376"><code>		return nil</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	return (*StructType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>// MapType returns t cast to a *MapType, or nil if its tag does not match.</code></span>
<span class="codeline" id="line-382"><code>func (t *Type) MapType() *MapType {</code></span>
<span class="codeline" id="line-383"><code>	if t.Kind() != Map {</code></span>
<span class="codeline" id="line-384"><code>		return nil</code></span>
<span class="codeline" id="line-385"><code>	}</code></span>
<span class="codeline" id="line-386"><code>	return (*MapType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>// ArrayType returns t cast to a *ArrayType, or nil if its tag does not match.</code></span>
<span class="codeline" id="line-390"><code>func (t *Type) ArrayType() *ArrayType {</code></span>
<span class="codeline" id="line-391"><code>	if t.Kind() != Array {</code></span>
<span class="codeline" id="line-392"><code>		return nil</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	return (*ArrayType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-395"><code>}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>// FuncType returns t cast to a *FuncType, or nil if its tag does not match.</code></span>
<span class="codeline" id="line-398"><code>func (t *Type) FuncType() *FuncType {</code></span>
<span class="codeline" id="line-399"><code>	if t.Kind() != Func {</code></span>
<span class="codeline" id="line-400"><code>		return nil</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code>	return (*FuncType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>// InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not match.</code></span>
<span class="codeline" id="line-406"><code>func (t *Type) InterfaceType() *InterfaceType {</code></span>
<span class="codeline" id="line-407"><code>	if t.Kind() != Interface {</code></span>
<span class="codeline" id="line-408"><code>		return nil</code></span>
<span class="codeline" id="line-409"><code>	}</code></span>
<span class="codeline" id="line-410"><code>	return (*InterfaceType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>// Size returns the size of data with type t.</code></span>
<span class="codeline" id="line-414"><code>func (t *Type) Size() uintptr { return t.Size_ }</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>// Align returns the alignment of data with type t.</code></span>
<span class="codeline" id="line-417"><code>func (t *Type) Align() int { return int(t.Align_) }</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>func (t *Type) FieldAlign() int { return int(t.FieldAlign_) }</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>type InterfaceType struct {</code></span>
<span class="codeline" id="line-422"><code>	Type</code></span>
<span class="codeline" id="line-423"><code>	PkgPath Name      // import path</code></span>
<span class="codeline" id="line-424"><code>	Methods []Imethod // sorted by hash</code></span>
<span class="codeline" id="line-425"><code>}</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>func (t *Type) ExportedMethods() []Method {</code></span>
<span class="codeline" id="line-428"><code>	ut := t.Uncommon()</code></span>
<span class="codeline" id="line-429"><code>	if ut == nil {</code></span>
<span class="codeline" id="line-430"><code>		return nil</code></span>
<span class="codeline" id="line-431"><code>	}</code></span>
<span class="codeline" id="line-432"><code>	return ut.ExportedMethods()</code></span>
<span class="codeline" id="line-433"><code>}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>func (t *Type) NumMethod() int {</code></span>
<span class="codeline" id="line-436"><code>	if t.Kind() == Interface {</code></span>
<span class="codeline" id="line-437"><code>		tt := (*InterfaceType)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-438"><code>		return tt.NumMethod()</code></span>
<span class="codeline" id="line-439"><code>	}</code></span>
<span class="codeline" id="line-440"><code>	return len(t.ExportedMethods())</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>// NumMethod returns the number of interface methods in the type's method set.</code></span>
<span class="codeline" id="line-444"><code>func (t *InterfaceType) NumMethod() int { return len(t.Methods) }</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>type MapType struct {</code></span>
<span class="codeline" id="line-447"><code>	Type</code></span>
<span class="codeline" id="line-448"><code>	Key    *Type</code></span>
<span class="codeline" id="line-449"><code>	Elem   *Type</code></span>
<span class="codeline" id="line-450"><code>	Bucket *Type // internal type representing a hash bucket</code></span>
<span class="codeline" id="line-451"><code>	// function for hashing keys (ptr to key, seed) -&gt; hash</code></span>
<span class="codeline" id="line-452"><code>	Hasher     func(unsafe.Pointer, uintptr) uintptr</code></span>
<span class="codeline" id="line-453"><code>	KeySize    uint8  // size of key slot</code></span>
<span class="codeline" id="line-454"><code>	ValueSize  uint8  // size of elem slot</code></span>
<span class="codeline" id="line-455"><code>	BucketSize uint16 // size of bucket</code></span>
<span class="codeline" id="line-456"><code>	Flags      uint32</code></span>
<span class="codeline" id="line-457"><code>}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>// Note: flag values must match those used in the TMAP case</code></span>
<span class="codeline" id="line-460"><code>// in ../cmd/compile/internal/reflectdata/reflect.go:writeType.</code></span>
<span class="codeline" id="line-461"><code>func (mt *MapType) IndirectKey() bool { // store ptr to key instead of key itself</code></span>
<span class="codeline" id="line-462"><code>	return mt.Flags&amp;1 != 0</code></span>
<span class="codeline" id="line-463"><code>}</code></span>
<span class="codeline" id="line-464"><code>func (mt *MapType) IndirectElem() bool { // store ptr to elem instead of elem itself</code></span>
<span class="codeline" id="line-465"><code>	return mt.Flags&amp;2 != 0</code></span>
<span class="codeline" id="line-466"><code>}</code></span>
<span class="codeline" id="line-467"><code>func (mt *MapType) ReflexiveKey() bool { // true if k==k for all keys</code></span>
<span class="codeline" id="line-468"><code>	return mt.Flags&amp;4 != 0</code></span>
<span class="codeline" id="line-469"><code>}</code></span>
<span class="codeline" id="line-470"><code>func (mt *MapType) NeedKeyUpdate() bool { // true if we need to update key on an overwrite</code></span>
<span class="codeline" id="line-471"><code>	return mt.Flags&amp;8 != 0</code></span>
<span class="codeline" id="line-472"><code>}</code></span>
<span class="codeline" id="line-473"><code>func (mt *MapType) HashMightPanic() bool { // true if hash function might panic</code></span>
<span class="codeline" id="line-474"><code>	return mt.Flags&amp;16 != 0</code></span>
<span class="codeline" id="line-475"><code>}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>func (t *Type) Key() *Type {</code></span>
<span class="codeline" id="line-478"><code>	if t.Kind() == Map {</code></span>
<span class="codeline" id="line-479"><code>		return (*MapType)(unsafe.Pointer(t)).Key</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code>	return nil</code></span>
<span class="codeline" id="line-482"><code>}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>type SliceType struct {</code></span>
<span class="codeline" id="line-485"><code>	Type</code></span>
<span class="codeline" id="line-486"><code>	Elem *Type // slice element type</code></span>
<span class="codeline" id="line-487"><code>}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>// funcType represents a function type.</code></span>
<span class="codeline" id="line-490"><code>//</code></span>
<span class="codeline" id="line-491"><code>// A *Type for each in and out parameter is stored in an array that</code></span>
<span class="codeline" id="line-492"><code>// directly follows the funcType (and possibly its uncommonType). So</code></span>
<span class="codeline" id="line-493"><code>// a function type with one method, one input, and one output is:</code></span>
<span class="codeline" id="line-494"><code>//</code></span>
<span class="codeline" id="line-495"><code>//	struct {</code></span>
<span class="codeline" id="line-496"><code>//		funcType</code></span>
<span class="codeline" id="line-497"><code>//		uncommonType</code></span>
<span class="codeline" id="line-498"><code>//		[2]*rtype    // [0] is in, [1] is out</code></span>
<span class="codeline" id="line-499"><code>//	}</code></span>
<span class="codeline" id="line-500"><code>type FuncType struct {</code></span>
<span class="codeline" id="line-501"><code>	Type</code></span>
<span class="codeline" id="line-502"><code>	InCount  uint16</code></span>
<span class="codeline" id="line-503"><code>	OutCount uint16 // top bit is set if last input parameter is ...</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>func (t *FuncType) In(i int) *Type {</code></span>
<span class="codeline" id="line-507"><code>	return t.InSlice()[i]</code></span>
<span class="codeline" id="line-508"><code>}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>func (t *FuncType) NumIn() int {</code></span>
<span class="codeline" id="line-511"><code>	return int(t.InCount)</code></span>
<span class="codeline" id="line-512"><code>}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>func (t *FuncType) NumOut() int {</code></span>
<span class="codeline" id="line-515"><code>	return int(t.OutCount &amp; (1&lt;&lt;15 - 1))</code></span>
<span class="codeline" id="line-516"><code>}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>func (t *FuncType) Out(i int) *Type {</code></span>
<span class="codeline" id="line-519"><code>	return (t.OutSlice()[i])</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>func (t *FuncType) InSlice() []*Type {</code></span>
<span class="codeline" id="line-523"><code>	uadd := unsafe.Sizeof(*t)</code></span>
<span class="codeline" id="line-524"><code>	if t.TFlag&amp;TFlagUncommon != 0 {</code></span>
<span class="codeline" id="line-525"><code>		uadd += unsafe.Sizeof(UncommonType{})</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code>	if t.InCount == 0 {</code></span>
<span class="codeline" id="line-528"><code>		return nil</code></span>
<span class="codeline" id="line-529"><code>	}</code></span>
<span class="codeline" id="line-530"><code>	return (*[1 &lt;&lt; 16]*Type)(addChecked(unsafe.Pointer(t), uadd, "t.inCount &gt; 0"))[:t.InCount:t.InCount]</code></span>
<span class="codeline" id="line-531"><code>}</code></span>
<span class="codeline" id="line-532"><code>func (t *FuncType) OutSlice() []*Type {</code></span>
<span class="codeline" id="line-533"><code>	outCount := uint16(t.NumOut())</code></span>
<span class="codeline" id="line-534"><code>	if outCount == 0 {</code></span>
<span class="codeline" id="line-535"><code>		return nil</code></span>
<span class="codeline" id="line-536"><code>	}</code></span>
<span class="codeline" id="line-537"><code>	uadd := unsafe.Sizeof(*t)</code></span>
<span class="codeline" id="line-538"><code>	if t.TFlag&amp;TFlagUncommon != 0 {</code></span>
<span class="codeline" id="line-539"><code>		uadd += unsafe.Sizeof(UncommonType{})</code></span>
<span class="codeline" id="line-540"><code>	}</code></span>
<span class="codeline" id="line-541"><code>	return (*[1 &lt;&lt; 17]*Type)(addChecked(unsafe.Pointer(t), uadd, "outCount &gt; 0"))[t.InCount : t.InCount+outCount : t.InCount+outCount]</code></span>
<span class="codeline" id="line-542"><code>}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>func (t *FuncType) IsVariadic() bool {</code></span>
<span class="codeline" id="line-545"><code>	return t.OutCount&amp;(1&lt;&lt;15) != 0</code></span>
<span class="codeline" id="line-546"><code>}</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>type PtrType struct {</code></span>
<span class="codeline" id="line-549"><code>	Type</code></span>
<span class="codeline" id="line-550"><code>	Elem *Type // pointer element (pointed at) type</code></span>
<span class="codeline" id="line-551"><code>}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>type StructField struct {</code></span>
<span class="codeline" id="line-554"><code>	Name   Name    // name is always non-empty</code></span>
<span class="codeline" id="line-555"><code>	Typ    *Type   // type of field</code></span>
<span class="codeline" id="line-556"><code>	Offset uintptr // byte offset of field</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>func (f *StructField) Embedded() bool {</code></span>
<span class="codeline" id="line-560"><code>	return f.Name.IsEmbedded()</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>type StructType struct {</code></span>
<span class="codeline" id="line-564"><code>	Type</code></span>
<span class="codeline" id="line-565"><code>	PkgPath Name</code></span>
<span class="codeline" id="line-566"><code>	Fields  []StructField</code></span>
<span class="codeline" id="line-567"><code>}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>// Name is an encoded type Name with optional extra data.</code></span>
<span class="codeline" id="line-570"><code>//</code></span>
<span class="codeline" id="line-571"><code>// The first byte is a bit field containing:</code></span>
<span class="codeline" id="line-572"><code>//</code></span>
<span class="codeline" id="line-573"><code>//	1&lt;&lt;0 the name is exported</code></span>
<span class="codeline" id="line-574"><code>//	1&lt;&lt;1 tag data follows the name</code></span>
<span class="codeline" id="line-575"><code>//	1&lt;&lt;2 pkgPath nameOff follows the name and tag</code></span>
<span class="codeline" id="line-576"><code>//	1&lt;&lt;3 the name is of an embedded (a.k.a. anonymous) field</code></span>
<span class="codeline" id="line-577"><code>//</code></span>
<span class="codeline" id="line-578"><code>// Following that, there is a varint-encoded length of the name,</code></span>
<span class="codeline" id="line-579"><code>// followed by the name itself.</code></span>
<span class="codeline" id="line-580"><code>//</code></span>
<span class="codeline" id="line-581"><code>// If tag data is present, it also has a varint-encoded length</code></span>
<span class="codeline" id="line-582"><code>// followed by the tag itself.</code></span>
<span class="codeline" id="line-583"><code>//</code></span>
<span class="codeline" id="line-584"><code>// If the import path follows, then 4 bytes at the end of</code></span>
<span class="codeline" id="line-585"><code>// the data form a nameOff. The import path is only set for concrete</code></span>
<span class="codeline" id="line-586"><code>// methods that are defined in a different package than their type.</code></span>
<span class="codeline" id="line-587"><code>//</code></span>
<span class="codeline" id="line-588"><code>// If a name starts with "*", then the exported bit represents</code></span>
<span class="codeline" id="line-589"><code>// whether the pointed to type is exported.</code></span>
<span class="codeline" id="line-590"><code>//</code></span>
<span class="codeline" id="line-591"><code>// Note: this encoding must match here and in:</code></span>
<span class="codeline" id="line-592"><code>//   cmd/compile/internal/reflectdata/reflect.go</code></span>
<span class="codeline" id="line-593"><code>//   cmd/link/internal/ld/decodesym.go</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>type Name struct {</code></span>
<span class="codeline" id="line-596"><code>	Bytes *byte</code></span>
<span class="codeline" id="line-597"><code>}</code></span>
<span class="codeline" id="line-598"><code></code></span>
<span class="codeline" id="line-599"><code>// DataChecked does pointer arithmetic on n's Bytes, and that arithmetic is asserted to</code></span>
<span class="codeline" id="line-600"><code>// be safe for the reason in whySafe (which can appear in a backtrace, etc.)</code></span>
<span class="codeline" id="line-601"><code>func (n Name) DataChecked(off int, whySafe string) *byte {</code></span>
<span class="codeline" id="line-602"><code>	return (*byte)(addChecked(unsafe.Pointer(n.Bytes), uintptr(off), whySafe))</code></span>
<span class="codeline" id="line-603"><code>}</code></span>
<span class="codeline" id="line-604"><code></code></span>
<span class="codeline" id="line-605"><code>// Data does pointer arithmetic on n's Bytes, and that arithmetic is asserted to</code></span>
<span class="codeline" id="line-606"><code>// be safe because the runtime made the call (other packages use DataChecked)</code></span>
<span class="codeline" id="line-607"><code>func (n Name) Data(off int) *byte {</code></span>
<span class="codeline" id="line-608"><code>	return (*byte)(addChecked(unsafe.Pointer(n.Bytes), uintptr(off), "the runtime doesn't need to give you a reason"))</code></span>
<span class="codeline" id="line-609"><code>}</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>// IsExported returns "is n exported?"</code></span>
<span class="codeline" id="line-612"><code>func (n Name) IsExported() bool {</code></span>
<span class="codeline" id="line-613"><code>	return (*n.Bytes)&amp;(1&lt;&lt;0) != 0</code></span>
<span class="codeline" id="line-614"><code>}</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>// HasTag returns true iff there is tag data following this name</code></span>
<span class="codeline" id="line-617"><code>func (n Name) HasTag() bool {</code></span>
<span class="codeline" id="line-618"><code>	return (*n.Bytes)&amp;(1&lt;&lt;1) != 0</code></span>
<span class="codeline" id="line-619"><code>}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>// IsEmbedded returns true iff n is embedded (an anonymous field).</code></span>
<span class="codeline" id="line-622"><code>func (n Name) IsEmbedded() bool {</code></span>
<span class="codeline" id="line-623"><code>	return (*n.Bytes)&amp;(1&lt;&lt;3) != 0</code></span>
<span class="codeline" id="line-624"><code>}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>// ReadVarint parses a varint as encoded by encoding/binary.</code></span>
<span class="codeline" id="line-627"><code>// It returns the number of encoded bytes and the encoded value.</code></span>
<span class="codeline" id="line-628"><code>func (n Name) ReadVarint(off int) (int, int) {</code></span>
<span class="codeline" id="line-629"><code>	v := 0</code></span>
<span class="codeline" id="line-630"><code>	for i := 0; ; i++ {</code></span>
<span class="codeline" id="line-631"><code>		x := *n.DataChecked(off+i, "read varint")</code></span>
<span class="codeline" id="line-632"><code>		v += int(x&amp;0x7f) &lt;&lt; (7 * i)</code></span>
<span class="codeline" id="line-633"><code>		if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-634"><code>			return i + 1, v</code></span>
<span class="codeline" id="line-635"><code>		}</code></span>
<span class="codeline" id="line-636"><code>	}</code></span>
<span class="codeline" id="line-637"><code>}</code></span>
<span class="codeline" id="line-638"><code></code></span>
<span class="codeline" id="line-639"><code>// IsBlank indicates whether n is "_".</code></span>
<span class="codeline" id="line-640"><code>func (n Name) IsBlank() bool {</code></span>
<span class="codeline" id="line-641"><code>	if n.Bytes == nil {</code></span>
<span class="codeline" id="line-642"><code>		return false</code></span>
<span class="codeline" id="line-643"><code>	}</code></span>
<span class="codeline" id="line-644"><code>	_, l := n.ReadVarint(1)</code></span>
<span class="codeline" id="line-645"><code>	return l == 1 &amp;&amp; *n.Data(2) == '_'</code></span>
<span class="codeline" id="line-646"><code>}</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>// writeVarint writes n to buf in varint form. Returns the</code></span>
<span class="codeline" id="line-649"><code>// number of bytes written. n must be nonnegative.</code></span>
<span class="codeline" id="line-650"><code>// Writes at most 10 bytes.</code></span>
<span class="codeline" id="line-651"><code>func writeVarint(buf []byte, n int) int {</code></span>
<span class="codeline" id="line-652"><code>	for i := 0; ; i++ {</code></span>
<span class="codeline" id="line-653"><code>		b := byte(n &amp; 0x7f)</code></span>
<span class="codeline" id="line-654"><code>		n &gt;&gt;= 7</code></span>
<span class="codeline" id="line-655"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-656"><code>			buf[i] = b</code></span>
<span class="codeline" id="line-657"><code>			return i + 1</code></span>
<span class="codeline" id="line-658"><code>		}</code></span>
<span class="codeline" id="line-659"><code>		buf[i] = b | 0x80</code></span>
<span class="codeline" id="line-660"><code>	}</code></span>
<span class="codeline" id="line-661"><code>}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>// Name returns the tag string for n, or empty if there is none.</code></span>
<span class="codeline" id="line-664"><code>func (n Name) Name() string {</code></span>
<span class="codeline" id="line-665"><code>	if n.Bytes == nil {</code></span>
<span class="codeline" id="line-666"><code>		return ""</code></span>
<span class="codeline" id="line-667"><code>	}</code></span>
<span class="codeline" id="line-668"><code>	i, l := n.ReadVarint(1)</code></span>
<span class="codeline" id="line-669"><code>	return unsafe.String(n.DataChecked(1+i, "non-empty string"), l)</code></span>
<span class="codeline" id="line-670"><code>}</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>// Tag returns the tag string for n, or empty if there is none.</code></span>
<span class="codeline" id="line-673"><code>func (n Name) Tag() string {</code></span>
<span class="codeline" id="line-674"><code>	if !n.HasTag() {</code></span>
<span class="codeline" id="line-675"><code>		return ""</code></span>
<span class="codeline" id="line-676"><code>	}</code></span>
<span class="codeline" id="line-677"><code>	i, l := n.ReadVarint(1)</code></span>
<span class="codeline" id="line-678"><code>	i2, l2 := n.ReadVarint(1 + i + l)</code></span>
<span class="codeline" id="line-679"><code>	return unsafe.String(n.DataChecked(1+i+l+i2, "non-empty string"), l2)</code></span>
<span class="codeline" id="line-680"><code>}</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>func NewName(n, tag string, exported, embedded bool) Name {</code></span>
<span class="codeline" id="line-683"><code>	if len(n) &gt;= 1&lt;&lt;29 {</code></span>
<span class="codeline" id="line-684"><code>		panic("abi.NewName: name too long: " + n[:1024] + "...")</code></span>
<span class="codeline" id="line-685"><code>	}</code></span>
<span class="codeline" id="line-686"><code>	if len(tag) &gt;= 1&lt;&lt;29 {</code></span>
<span class="codeline" id="line-687"><code>		panic("abi.NewName: tag too long: " + tag[:1024] + "...")</code></span>
<span class="codeline" id="line-688"><code>	}</code></span>
<span class="codeline" id="line-689"><code>	var nameLen [10]byte</code></span>
<span class="codeline" id="line-690"><code>	var tagLen [10]byte</code></span>
<span class="codeline" id="line-691"><code>	nameLenLen := writeVarint(nameLen[:], len(n))</code></span>
<span class="codeline" id="line-692"><code>	tagLenLen := writeVarint(tagLen[:], len(tag))</code></span>
<span class="codeline" id="line-693"><code></code></span>
<span class="codeline" id="line-694"><code>	var bits byte</code></span>
<span class="codeline" id="line-695"><code>	l := 1 + nameLenLen + len(n)</code></span>
<span class="codeline" id="line-696"><code>	if exported {</code></span>
<span class="codeline" id="line-697"><code>		bits |= 1 &lt;&lt; 0</code></span>
<span class="codeline" id="line-698"><code>	}</code></span>
<span class="codeline" id="line-699"><code>	if len(tag) &gt; 0 {</code></span>
<span class="codeline" id="line-700"><code>		l += tagLenLen + len(tag)</code></span>
<span class="codeline" id="line-701"><code>		bits |= 1 &lt;&lt; 1</code></span>
<span class="codeline" id="line-702"><code>	}</code></span>
<span class="codeline" id="line-703"><code>	if embedded {</code></span>
<span class="codeline" id="line-704"><code>		bits |= 1 &lt;&lt; 3</code></span>
<span class="codeline" id="line-705"><code>	}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>	b := make([]byte, l)</code></span>
<span class="codeline" id="line-708"><code>	b[0] = bits</code></span>
<span class="codeline" id="line-709"><code>	copy(b[1:], nameLen[:nameLenLen])</code></span>
<span class="codeline" id="line-710"><code>	copy(b[1+nameLenLen:], n)</code></span>
<span class="codeline" id="line-711"><code>	if len(tag) &gt; 0 {</code></span>
<span class="codeline" id="line-712"><code>		tb := b[1+nameLenLen+len(n):]</code></span>
<span class="codeline" id="line-713"><code>		copy(tb, tagLen[:tagLenLen])</code></span>
<span class="codeline" id="line-714"><code>		copy(tb[tagLenLen:], tag)</code></span>
<span class="codeline" id="line-715"><code>	}</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>	return Name{Bytes: &amp;b[0]}</code></span>
<span class="codeline" id="line-718"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>