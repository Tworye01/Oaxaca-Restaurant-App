<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: driver.go in package database/sql/driver</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	driver.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/database/sql/driver.html">database/sql/driver</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package driver defines interfaces to be implemented by database</code></span>
<span class="codeline" id="line-6"><code>// drivers as used by package sql.</code></span>
<span class="codeline" id="line-7"><code>//</code></span>
<span class="codeline" id="line-8"><code>// Most code should use the [database/sql] package.</code></span>
<span class="codeline" id="line-9"><code>//</code></span>
<span class="codeline" id="line-10"><code>// The driver interface has evolved over time. Drivers should implement</code></span>
<span class="codeline" id="line-11"><code>// [Connector] and [DriverContext] interfaces.</code></span>
<span class="codeline" id="line-12"><code>// The Connector.Connect and Driver.Open methods should never return [ErrBadConn].</code></span>
<span class="codeline" id="line-13"><code>// [ErrBadConn] should only be returned from [Validator], [SessionResetter], or</code></span>
<span class="codeline" id="line-14"><code>// a query method if the connection is already in an invalid (e.g. closed) state.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// All [Conn] implementations should implement the following interfaces:</code></span>
<span class="codeline" id="line-17"><code>// [Pinger], [SessionResetter], and [Validator].</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// If named parameters or context are supported, the driver's [Conn] should implement:</code></span>
<span class="codeline" id="line-20"><code>// [ExecerContext], [QueryerContext], [ConnPrepareContext], and [ConnBeginTx].</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// To support custom data types, implement [NamedValueChecker]. [NamedValueChecker]</code></span>
<span class="codeline" id="line-23"><code>// also allows queries to accept per-query options as a parameter by returning</code></span>
<span class="codeline" id="line-24"><code>// [ErrRemoveArgument] from CheckNamedValue.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// If multiple result sets are supported, [Rows] should implement [RowsNextResultSet].</code></span>
<span class="codeline" id="line-27"><code>// If the driver knows how to describe the types present in the returned result</code></span>
<span class="codeline" id="line-28"><code>// it should implement the following interfaces: [RowsColumnTypeScanType],</code></span>
<span class="codeline" id="line-29"><code>// [RowsColumnTypeDatabaseTypeName], [RowsColumnTypeLength], [RowsColumnTypeNullable],</code></span>
<span class="codeline" id="line-30"><code>// and [RowsColumnTypePrecisionScale]. A given row value may also return a [Rows]</code></span>
<span class="codeline" id="line-31"><code>// type, which may represent a database cursor value.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// If a [Conn] implements [Validator], then the IsValid method is called</code></span>
<span class="codeline" id="line-34"><code>// before returning the connection to the connection pool. If an entry in the</code></span>
<span class="codeline" id="line-35"><code>// connection pool implements [SessionResetter], then ResetSession</code></span>
<span class="codeline" id="line-36"><code>// is called before reusing the connection for another query. If a connection is</code></span>
<span class="codeline" id="line-37"><code>// never returned to the connection pool but is immediately reused, then</code></span>
<span class="codeline" id="line-38"><code>// ResetSession is called prior to reuse but IsValid is not called.</code></span></div><span class="codeline" id="line-39"><code>package driver</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>import (</code></span>
<span class="codeline" id="line-42"><code>	"context"</code></span>
<span class="codeline" id="line-43"><code>	"errors"</code></span>
<span class="codeline" id="line-44"><code>	"reflect"</code></span>
<span class="codeline" id="line-45"><code>)</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code>// Value is a value that drivers must be able to handle.</code></span>
<span class="codeline" id="line-48"><code>// It is either nil, a type handled by a database driver's [NamedValueChecker]</code></span>
<span class="codeline" id="line-49"><code>// interface, or an instance of one of these types:</code></span>
<span class="codeline" id="line-50"><code>//</code></span>
<span class="codeline" id="line-51"><code>//	int64</code></span>
<span class="codeline" id="line-52"><code>//	float64</code></span>
<span class="codeline" id="line-53"><code>//	bool</code></span>
<span class="codeline" id="line-54"><code>//	[]byte</code></span>
<span class="codeline" id="line-55"><code>//	string</code></span>
<span class="codeline" id="line-56"><code>//	time.Time</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// If the driver supports cursors, a returned Value may also implement the [Rows] interface</code></span>
<span class="codeline" id="line-59"><code>// in this package. This is used, for example, when a user selects a cursor</code></span>
<span class="codeline" id="line-60"><code>// such as "select cursor(select * from my_table) from dual". If the [Rows]</code></span>
<span class="codeline" id="line-61"><code>// from the select is closed, the cursor [Rows] will also be closed.</code></span>
<span class="codeline" id="line-62"><code>type Value any</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// NamedValue holds both the value name and value.</code></span>
<span class="codeline" id="line-65"><code>type NamedValue struct {</code></span>
<span class="codeline" id="line-66"><code>	// If the Name is not empty it should be used for the parameter identifier and</code></span>
<span class="codeline" id="line-67"><code>	// not the ordinal position.</code></span>
<span class="codeline" id="line-68"><code>	//</code></span>
<span class="codeline" id="line-69"><code>	// Name will not have a symbol prefix.</code></span>
<span class="codeline" id="line-70"><code>	Name string</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>	// Ordinal position of the parameter starting from one and is always set.</code></span>
<span class="codeline" id="line-73"><code>	Ordinal int</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>	// Value is the parameter value.</code></span>
<span class="codeline" id="line-76"><code>	Value Value</code></span>
<span class="codeline" id="line-77"><code>}</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// Driver is the interface that must be implemented by a database</code></span>
<span class="codeline" id="line-80"><code>// driver.</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// Database drivers may implement [DriverContext] for access</code></span>
<span class="codeline" id="line-83"><code>// to contexts and to parse the name only once for a pool of connections,</code></span>
<span class="codeline" id="line-84"><code>// instead of once per connection.</code></span>
<span class="codeline" id="line-85"><code>type Driver interface {</code></span>
<span class="codeline" id="line-86"><code>	// Open returns a new connection to the database.</code></span>
<span class="codeline" id="line-87"><code>	// The name is a string in a driver-specific format.</code></span>
<span class="codeline" id="line-88"><code>	//</code></span>
<span class="codeline" id="line-89"><code>	// Open may return a cached connection (one previously</code></span>
<span class="codeline" id="line-90"><code>	// closed), but doing so is unnecessary; the sql package</code></span>
<span class="codeline" id="line-91"><code>	// maintains a pool of idle connections for efficient re-use.</code></span>
<span class="codeline" id="line-92"><code>	//</code></span>
<span class="codeline" id="line-93"><code>	// The returned connection is only used by one goroutine at a</code></span>
<span class="codeline" id="line-94"><code>	// time.</code></span>
<span class="codeline" id="line-95"><code>	Open(name string) (Conn, error)</code></span>
<span class="codeline" id="line-96"><code>}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>// If a [Driver] implements DriverContext, then [database/sql.DB] will call</code></span>
<span class="codeline" id="line-99"><code>// OpenConnector to obtain a [Connector] and then invoke</code></span>
<span class="codeline" id="line-100"><code>// that [Connector]'s Connect method to obtain each needed connection,</code></span>
<span class="codeline" id="line-101"><code>// instead of invoking the [Driver]'s Open method for each connection.</code></span>
<span class="codeline" id="line-102"><code>// The two-step sequence allows drivers to parse the name just once</code></span>
<span class="codeline" id="line-103"><code>// and also provides access to per-[Conn] contexts.</code></span>
<span class="codeline" id="line-104"><code>type DriverContext interface {</code></span>
<span class="codeline" id="line-105"><code>	// OpenConnector must parse the name in the same format that Driver.Open</code></span>
<span class="codeline" id="line-106"><code>	// parses the name parameter.</code></span>
<span class="codeline" id="line-107"><code>	OpenConnector(name string) (Connector, error)</code></span>
<span class="codeline" id="line-108"><code>}</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// A Connector represents a driver in a fixed configuration</code></span>
<span class="codeline" id="line-111"><code>// and can create any number of equivalent Conns for use</code></span>
<span class="codeline" id="line-112"><code>// by multiple goroutines.</code></span>
<span class="codeline" id="line-113"><code>//</code></span>
<span class="codeline" id="line-114"><code>// A Connector can be passed to [database/sql.OpenDB], to allow drivers</code></span>
<span class="codeline" id="line-115"><code>// to implement their own [database/sql.DB] constructors, or returned by</code></span>
<span class="codeline" id="line-116"><code>// [DriverContext]'s OpenConnector method, to allow drivers</code></span>
<span class="codeline" id="line-117"><code>// access to context and to avoid repeated parsing of driver</code></span>
<span class="codeline" id="line-118"><code>// configuration.</code></span>
<span class="codeline" id="line-119"><code>//</code></span>
<span class="codeline" id="line-120"><code>// If a Connector implements [io.Closer], the [database/sql.DB.Close]</code></span>
<span class="codeline" id="line-121"><code>// method will call the Close method and return error (if any).</code></span>
<span class="codeline" id="line-122"><code>type Connector interface {</code></span>
<span class="codeline" id="line-123"><code>	// Connect returns a connection to the database.</code></span>
<span class="codeline" id="line-124"><code>	// Connect may return a cached connection (one previously</code></span>
<span class="codeline" id="line-125"><code>	// closed), but doing so is unnecessary; the sql package</code></span>
<span class="codeline" id="line-126"><code>	// maintains a pool of idle connections for efficient re-use.</code></span>
<span class="codeline" id="line-127"><code>	//</code></span>
<span class="codeline" id="line-128"><code>	// The provided context.Context is for dialing purposes only</code></span>
<span class="codeline" id="line-129"><code>	// (see net.DialContext) and should not be stored or used for</code></span>
<span class="codeline" id="line-130"><code>	// other purposes. A default timeout should still be used</code></span>
<span class="codeline" id="line-131"><code>	// when dialing as a connection pool may call Connect</code></span>
<span class="codeline" id="line-132"><code>	// asynchronously to any query.</code></span>
<span class="codeline" id="line-133"><code>	//</code></span>
<span class="codeline" id="line-134"><code>	// The returned connection is only used by one goroutine at a</code></span>
<span class="codeline" id="line-135"><code>	// time.</code></span>
<span class="codeline" id="line-136"><code>	Connect(context.Context) (Conn, error)</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>	// Driver returns the underlying Driver of the Connector,</code></span>
<span class="codeline" id="line-139"><code>	// mainly to maintain compatibility with the Driver method</code></span>
<span class="codeline" id="line-140"><code>	// on sql.DB.</code></span>
<span class="codeline" id="line-141"><code>	Driver() Driver</code></span>
<span class="codeline" id="line-142"><code>}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>// ErrSkip may be returned by some optional interfaces' methods to</code></span>
<span class="codeline" id="line-145"><code>// indicate at runtime that the fast path is unavailable and the sql</code></span>
<span class="codeline" id="line-146"><code>// package should continue as if the optional interface was not</code></span>
<span class="codeline" id="line-147"><code>// implemented. ErrSkip is only supported where explicitly</code></span>
<span class="codeline" id="line-148"><code>// documented.</code></span>
<span class="codeline" id="line-149"><code>var ErrSkip = errors.New("driver: skip fast-path; continue as if unimplemented")</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// ErrBadConn should be returned by a driver to signal to the [database/sql]</code></span>
<span class="codeline" id="line-152"><code>// package that a driver.[Conn] is in a bad state (such as the server</code></span>
<span class="codeline" id="line-153"><code>// having earlier closed the connection) and the [database/sql] package should</code></span>
<span class="codeline" id="line-154"><code>// retry on a new connection.</code></span>
<span class="codeline" id="line-155"><code>//</code></span>
<span class="codeline" id="line-156"><code>// To prevent duplicate operations, ErrBadConn should NOT be returned</code></span>
<span class="codeline" id="line-157"><code>// if there's a possibility that the database server might have</code></span>
<span class="codeline" id="line-158"><code>// performed the operation. Even if the server sends back an error,</code></span>
<span class="codeline" id="line-159"><code>// you shouldn't return ErrBadConn.</code></span>
<span class="codeline" id="line-160"><code>//</code></span>
<span class="codeline" id="line-161"><code>// Errors will be checked using [errors.Is]. An error may</code></span>
<span class="codeline" id="line-162"><code>// wrap ErrBadConn or implement the Is(error) bool method.</code></span>
<span class="codeline" id="line-163"><code>var ErrBadConn = errors.New("driver: bad connection")</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>// Pinger is an optional interface that may be implemented by a [Conn].</code></span>
<span class="codeline" id="line-166"><code>//</code></span>
<span class="codeline" id="line-167"><code>// If a [Conn] does not implement Pinger, the [database/sql.DB.Ping] and</code></span>
<span class="codeline" id="line-168"><code>// [database/sql.DB.PingContext] will check if there is at least one [Conn] available.</code></span>
<span class="codeline" id="line-169"><code>//</code></span>
<span class="codeline" id="line-170"><code>// If Conn.Ping returns [ErrBadConn], [database/sql.DB.Ping] and [database/sql.DB.PingContext] will remove</code></span>
<span class="codeline" id="line-171"><code>// the [Conn] from pool.</code></span>
<span class="codeline" id="line-172"><code>type Pinger interface {</code></span>
<span class="codeline" id="line-173"><code>	Ping(ctx context.Context) error</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// Execer is an optional interface that may be implemented by a [Conn].</code></span>
<span class="codeline" id="line-177"><code>//</code></span>
<span class="codeline" id="line-178"><code>// If a [Conn] implements neither [ExecerContext] nor [Execer],</code></span>
<span class="codeline" id="line-179"><code>// the [database/sql.DB.Exec] will first prepare a query, execute the statement,</code></span>
<span class="codeline" id="line-180"><code>// and then close the statement.</code></span>
<span class="codeline" id="line-181"><code>//</code></span>
<span class="codeline" id="line-182"><code>// Exec may return [ErrSkip].</code></span>
<span class="codeline" id="line-183"><code>//</code></span>
<span class="codeline" id="line-184"><code>// Deprecated: Drivers should implement [ExecerContext] instead.</code></span>
<span class="codeline" id="line-185"><code>type Execer interface {</code></span>
<span class="codeline" id="line-186"><code>	Exec(query string, args []Value) (Result, error)</code></span>
<span class="codeline" id="line-187"><code>}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>// ExecerContext is an optional interface that may be implemented by a [Conn].</code></span>
<span class="codeline" id="line-190"><code>//</code></span>
<span class="codeline" id="line-191"><code>// If a [Conn] does not implement [ExecerContext], the [database/sql.DB.Exec]</code></span>
<span class="codeline" id="line-192"><code>// will fall back to [Execer]; if the Conn does not implement Execer either,</code></span>
<span class="codeline" id="line-193"><code>// [database/sql.DB.Exec] will first prepare a query, execute the statement, and then</code></span>
<span class="codeline" id="line-194"><code>// close the statement.</code></span>
<span class="codeline" id="line-195"><code>//</code></span>
<span class="codeline" id="line-196"><code>// ExecContext may return [ErrSkip].</code></span>
<span class="codeline" id="line-197"><code>//</code></span>
<span class="codeline" id="line-198"><code>// ExecContext must honor the context timeout and return when the context is canceled.</code></span>
<span class="codeline" id="line-199"><code>type ExecerContext interface {</code></span>
<span class="codeline" id="line-200"><code>	ExecContext(ctx context.Context, query string, args []NamedValue) (Result, error)</code></span>
<span class="codeline" id="line-201"><code>}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// Queryer is an optional interface that may be implemented by a [Conn].</code></span>
<span class="codeline" id="line-204"><code>//</code></span>
<span class="codeline" id="line-205"><code>// If a [Conn] implements neither [QueryerContext] nor [Queryer],</code></span>
<span class="codeline" id="line-206"><code>// the [database/sql.DB.Query] will first prepare a query, execute the statement,</code></span>
<span class="codeline" id="line-207"><code>// and then close the statement.</code></span>
<span class="codeline" id="line-208"><code>//</code></span>
<span class="codeline" id="line-209"><code>// Query may return [ErrSkip].</code></span>
<span class="codeline" id="line-210"><code>//</code></span>
<span class="codeline" id="line-211"><code>// Deprecated: Drivers should implement [QueryerContext] instead.</code></span>
<span class="codeline" id="line-212"><code>type Queryer interface {</code></span>
<span class="codeline" id="line-213"><code>	Query(query string, args []Value) (Rows, error)</code></span>
<span class="codeline" id="line-214"><code>}</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>// QueryerContext is an optional interface that may be implemented by a [Conn].</code></span>
<span class="codeline" id="line-217"><code>//</code></span>
<span class="codeline" id="line-218"><code>// If a [Conn] does not implement QueryerContext, the [database/sql.DB.Query]</code></span>
<span class="codeline" id="line-219"><code>// will fall back to [Queryer]; if the [Conn] does not implement [Queryer] either,</code></span>
<span class="codeline" id="line-220"><code>// [database/sql.DB.Query] will first prepare a query, execute the statement, and then</code></span>
<span class="codeline" id="line-221"><code>// close the statement.</code></span>
<span class="codeline" id="line-222"><code>//</code></span>
<span class="codeline" id="line-223"><code>// QueryContext may return [ErrSkip].</code></span>
<span class="codeline" id="line-224"><code>//</code></span>
<span class="codeline" id="line-225"><code>// QueryContext must honor the context timeout and return when the context is canceled.</code></span>
<span class="codeline" id="line-226"><code>type QueryerContext interface {</code></span>
<span class="codeline" id="line-227"><code>	QueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error)</code></span>
<span class="codeline" id="line-228"><code>}</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>// Conn is a connection to a database. It is not used concurrently</code></span>
<span class="codeline" id="line-231"><code>// by multiple goroutines.</code></span>
<span class="codeline" id="line-232"><code>//</code></span>
<span class="codeline" id="line-233"><code>// Conn is assumed to be stateful.</code></span>
<span class="codeline" id="line-234"><code>type Conn interface {</code></span>
<span class="codeline" id="line-235"><code>	// Prepare returns a prepared statement, bound to this connection.</code></span>
<span class="codeline" id="line-236"><code>	Prepare(query string) (Stmt, error)</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>	// Close invalidates and potentially stops any current</code></span>
<span class="codeline" id="line-239"><code>	// prepared statements and transactions, marking this</code></span>
<span class="codeline" id="line-240"><code>	// connection as no longer in use.</code></span>
<span class="codeline" id="line-241"><code>	//</code></span>
<span class="codeline" id="line-242"><code>	// Because the sql package maintains a free pool of</code></span>
<span class="codeline" id="line-243"><code>	// connections and only calls Close when there's a surplus of</code></span>
<span class="codeline" id="line-244"><code>	// idle connections, it shouldn't be necessary for drivers to</code></span>
<span class="codeline" id="line-245"><code>	// do their own connection caching.</code></span>
<span class="codeline" id="line-246"><code>	//</code></span>
<span class="codeline" id="line-247"><code>	// Drivers must ensure all network calls made by Close</code></span>
<span class="codeline" id="line-248"><code>	// do not block indefinitely (e.g. apply a timeout).</code></span>
<span class="codeline" id="line-249"><code>	Close() error</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>	// Begin starts and returns a new transaction.</code></span>
<span class="codeline" id="line-252"><code>	//</code></span>
<span class="codeline" id="line-253"><code>	// Deprecated: Drivers should implement ConnBeginTx instead (or additionally).</code></span>
<span class="codeline" id="line-254"><code>	Begin() (Tx, error)</code></span>
<span class="codeline" id="line-255"><code>}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>// ConnPrepareContext enhances the [Conn] interface with context.</code></span>
<span class="codeline" id="line-258"><code>type ConnPrepareContext interface {</code></span>
<span class="codeline" id="line-259"><code>	// PrepareContext returns a prepared statement, bound to this connection.</code></span>
<span class="codeline" id="line-260"><code>	// context is for the preparation of the statement,</code></span>
<span class="codeline" id="line-261"><code>	// it must not store the context within the statement itself.</code></span>
<span class="codeline" id="line-262"><code>	PrepareContext(ctx context.Context, query string) (Stmt, error)</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// IsolationLevel is the transaction isolation level stored in [TxOptions].</code></span>
<span class="codeline" id="line-266"><code>//</code></span>
<span class="codeline" id="line-267"><code>// This type should be considered identical to [database/sql.IsolationLevel] along</code></span>
<span class="codeline" id="line-268"><code>// with any values defined on it.</code></span>
<span class="codeline" id="line-269"><code>type IsolationLevel int</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>// TxOptions holds the transaction options.</code></span>
<span class="codeline" id="line-272"><code>//</code></span>
<span class="codeline" id="line-273"><code>// This type should be considered identical to [database/sql.TxOptions].</code></span>
<span class="codeline" id="line-274"><code>type TxOptions struct {</code></span>
<span class="codeline" id="line-275"><code>	Isolation IsolationLevel</code></span>
<span class="codeline" id="line-276"><code>	ReadOnly  bool</code></span>
<span class="codeline" id="line-277"><code>}</code></span>
<span class="codeline" id="line-278"><code></code></span>
<span class="codeline" id="line-279"><code>// ConnBeginTx enhances the [Conn] interface with context and [TxOptions].</code></span>
<span class="codeline" id="line-280"><code>type ConnBeginTx interface {</code></span>
<span class="codeline" id="line-281"><code>	// BeginTx starts and returns a new transaction.</code></span>
<span class="codeline" id="line-282"><code>	// If the context is canceled by the user the sql package will</code></span>
<span class="codeline" id="line-283"><code>	// call Tx.Rollback before discarding and closing the connection.</code></span>
<span class="codeline" id="line-284"><code>	//</code></span>
<span class="codeline" id="line-285"><code>	// This must check opts.Isolation to determine if there is a set</code></span>
<span class="codeline" id="line-286"><code>	// isolation level. If the driver does not support a non-default</code></span>
<span class="codeline" id="line-287"><code>	// level and one is set or if there is a non-default isolation level</code></span>
<span class="codeline" id="line-288"><code>	// that is not supported, an error must be returned.</code></span>
<span class="codeline" id="line-289"><code>	//</code></span>
<span class="codeline" id="line-290"><code>	// This must also check opts.ReadOnly to determine if the read-only</code></span>
<span class="codeline" id="line-291"><code>	// value is true to either set the read-only transaction property if supported</code></span>
<span class="codeline" id="line-292"><code>	// or return an error if it is not supported.</code></span>
<span class="codeline" id="line-293"><code>	BeginTx(ctx context.Context, opts TxOptions) (Tx, error)</code></span>
<span class="codeline" id="line-294"><code>}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>// SessionResetter may be implemented by [Conn] to allow drivers to reset the</code></span>
<span class="codeline" id="line-297"><code>// session state associated with the connection and to signal a bad connection.</code></span>
<span class="codeline" id="line-298"><code>type SessionResetter interface {</code></span>
<span class="codeline" id="line-299"><code>	// ResetSession is called prior to executing a query on the connection</code></span>
<span class="codeline" id="line-300"><code>	// if the connection has been used before. If the driver returns ErrBadConn</code></span>
<span class="codeline" id="line-301"><code>	// the connection is discarded.</code></span>
<span class="codeline" id="line-302"><code>	ResetSession(ctx context.Context) error</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>// Validator may be implemented by [Conn] to allow drivers to</code></span>
<span class="codeline" id="line-306"><code>// signal if a connection is valid or if it should be discarded.</code></span>
<span class="codeline" id="line-307"><code>//</code></span>
<span class="codeline" id="line-308"><code>// If implemented, drivers may return the underlying error from queries,</code></span>
<span class="codeline" id="line-309"><code>// even if the connection should be discarded by the connection pool.</code></span>
<span class="codeline" id="line-310"><code>type Validator interface {</code></span>
<span class="codeline" id="line-311"><code>	// IsValid is called prior to placing the connection into the</code></span>
<span class="codeline" id="line-312"><code>	// connection pool. The connection will be discarded if false is returned.</code></span>
<span class="codeline" id="line-313"><code>	IsValid() bool</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>// Result is the result of a query execution.</code></span>
<span class="codeline" id="line-317"><code>type Result interface {</code></span>
<span class="codeline" id="line-318"><code>	// LastInsertId returns the database's auto-generated ID</code></span>
<span class="codeline" id="line-319"><code>	// after, for example, an INSERT into a table with primary</code></span>
<span class="codeline" id="line-320"><code>	// key.</code></span>
<span class="codeline" id="line-321"><code>	LastInsertId() (int64, error)</code></span>
<span class="codeline" id="line-322"><code></code></span>
<span class="codeline" id="line-323"><code>	// RowsAffected returns the number of rows affected by the</code></span>
<span class="codeline" id="line-324"><code>	// query.</code></span>
<span class="codeline" id="line-325"><code>	RowsAffected() (int64, error)</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// Stmt is a prepared statement. It is bound to a [Conn] and not</code></span>
<span class="codeline" id="line-329"><code>// used by multiple goroutines concurrently.</code></span>
<span class="codeline" id="line-330"><code>type Stmt interface {</code></span>
<span class="codeline" id="line-331"><code>	// Close closes the statement.</code></span>
<span class="codeline" id="line-332"><code>	//</code></span>
<span class="codeline" id="line-333"><code>	// As of Go 1.1, a Stmt will not be closed if it's in use</code></span>
<span class="codeline" id="line-334"><code>	// by any queries.</code></span>
<span class="codeline" id="line-335"><code>	//</code></span>
<span class="codeline" id="line-336"><code>	// Drivers must ensure all network calls made by Close</code></span>
<span class="codeline" id="line-337"><code>	// do not block indefinitely (e.g. apply a timeout).</code></span>
<span class="codeline" id="line-338"><code>	Close() error</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>	// NumInput returns the number of placeholder parameters.</code></span>
<span class="codeline" id="line-341"><code>	//</code></span>
<span class="codeline" id="line-342"><code>	// If NumInput returns &gt;= 0, the sql package will sanity check</code></span>
<span class="codeline" id="line-343"><code>	// argument counts from callers and return errors to the caller</code></span>
<span class="codeline" id="line-344"><code>	// before the statement's Exec or Query methods are called.</code></span>
<span class="codeline" id="line-345"><code>	//</code></span>
<span class="codeline" id="line-346"><code>	// NumInput may also return -1, if the driver doesn't know</code></span>
<span class="codeline" id="line-347"><code>	// its number of placeholders. In that case, the sql package</code></span>
<span class="codeline" id="line-348"><code>	// will not sanity check Exec or Query argument counts.</code></span>
<span class="codeline" id="line-349"><code>	NumInput() int</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>	// Exec executes a query that doesn't return rows, such</code></span>
<span class="codeline" id="line-352"><code>	// as an INSERT or UPDATE.</code></span>
<span class="codeline" id="line-353"><code>	//</code></span>
<span class="codeline" id="line-354"><code>	// Deprecated: Drivers should implement StmtExecContext instead (or additionally).</code></span>
<span class="codeline" id="line-355"><code>	Exec(args []Value) (Result, error)</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	// Query executes a query that may return rows, such as a</code></span>
<span class="codeline" id="line-358"><code>	// SELECT.</code></span>
<span class="codeline" id="line-359"><code>	//</code></span>
<span class="codeline" id="line-360"><code>	// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).</code></span>
<span class="codeline" id="line-361"><code>	Query(args []Value) (Rows, error)</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>// StmtExecContext enhances the [Stmt] interface by providing Exec with context.</code></span>
<span class="codeline" id="line-365"><code>type StmtExecContext interface {</code></span>
<span class="codeline" id="line-366"><code>	// ExecContext executes a query that doesn't return rows, such</code></span>
<span class="codeline" id="line-367"><code>	// as an INSERT or UPDATE.</code></span>
<span class="codeline" id="line-368"><code>	//</code></span>
<span class="codeline" id="line-369"><code>	// ExecContext must honor the context timeout and return when it is canceled.</code></span>
<span class="codeline" id="line-370"><code>	ExecContext(ctx context.Context, args []NamedValue) (Result, error)</code></span>
<span class="codeline" id="line-371"><code>}</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>// StmtQueryContext enhances the [Stmt] interface by providing Query with context.</code></span>
<span class="codeline" id="line-374"><code>type StmtQueryContext interface {</code></span>
<span class="codeline" id="line-375"><code>	// QueryContext executes a query that may return rows, such as a</code></span>
<span class="codeline" id="line-376"><code>	// SELECT.</code></span>
<span class="codeline" id="line-377"><code>	//</code></span>
<span class="codeline" id="line-378"><code>	// QueryContext must honor the context timeout and return when it is canceled.</code></span>
<span class="codeline" id="line-379"><code>	QueryContext(ctx context.Context, args []NamedValue) (Rows, error)</code></span>
<span class="codeline" id="line-380"><code>}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>// ErrRemoveArgument may be returned from [NamedValueChecker] to instruct the</code></span>
<span class="codeline" id="line-383"><code>// [database/sql] package to not pass the argument to the driver query interface.</code></span>
<span class="codeline" id="line-384"><code>// Return when accepting query specific options or structures that aren't</code></span>
<span class="codeline" id="line-385"><code>// SQL query arguments.</code></span>
<span class="codeline" id="line-386"><code>var ErrRemoveArgument = errors.New("driver: remove argument from query")</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>// NamedValueChecker may be optionally implemented by [Conn] or [Stmt]. It provides</code></span>
<span class="codeline" id="line-389"><code>// the driver more control to handle Go and database types beyond the default</code></span>
<span class="codeline" id="line-390"><code>// [Value] types allowed.</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>// The [database/sql] package checks for value checkers in the following order,</code></span>
<span class="codeline" id="line-393"><code>// stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker,</code></span>
<span class="codeline" id="line-394"><code>// Stmt.ColumnConverter, [DefaultParameterConverter].</code></span>
<span class="codeline" id="line-395"><code>//</code></span>
<span class="codeline" id="line-396"><code>// If CheckNamedValue returns [ErrRemoveArgument], the [NamedValue] will not be included in</code></span>
<span class="codeline" id="line-397"><code>// the final query arguments. This may be used to pass special options to</code></span>
<span class="codeline" id="line-398"><code>// the query itself.</code></span>
<span class="codeline" id="line-399"><code>//</code></span>
<span class="codeline" id="line-400"><code>// If [ErrSkip] is returned the column converter error checking</code></span>
<span class="codeline" id="line-401"><code>// path is used for the argument. Drivers may wish to return [ErrSkip] after</code></span>
<span class="codeline" id="line-402"><code>// they have exhausted their own special cases.</code></span>
<span class="codeline" id="line-403"><code>type NamedValueChecker interface {</code></span>
<span class="codeline" id="line-404"><code>	// CheckNamedValue is called before passing arguments to the driver</code></span>
<span class="codeline" id="line-405"><code>	// and is called in place of any ColumnConverter. CheckNamedValue must do type</code></span>
<span class="codeline" id="line-406"><code>	// validation and conversion as appropriate for the driver.</code></span>
<span class="codeline" id="line-407"><code>	CheckNamedValue(*NamedValue) error</code></span>
<span class="codeline" id="line-408"><code>}</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>// ColumnConverter may be optionally implemented by [Stmt] if the</code></span>
<span class="codeline" id="line-411"><code>// statement is aware of its own columns' types and can convert from</code></span>
<span class="codeline" id="line-412"><code>// any type to a driver [Value].</code></span>
<span class="codeline" id="line-413"><code>//</code></span>
<span class="codeline" id="line-414"><code>// Deprecated: Drivers should implement [NamedValueChecker].</code></span>
<span class="codeline" id="line-415"><code>type ColumnConverter interface {</code></span>
<span class="codeline" id="line-416"><code>	// ColumnConverter returns a ValueConverter for the provided</code></span>
<span class="codeline" id="line-417"><code>	// column index. If the type of a specific column isn't known</code></span>
<span class="codeline" id="line-418"><code>	// or shouldn't be handled specially, DefaultValueConverter</code></span>
<span class="codeline" id="line-419"><code>	// can be returned.</code></span>
<span class="codeline" id="line-420"><code>	ColumnConverter(idx int) ValueConverter</code></span>
<span class="codeline" id="line-421"><code>}</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>// Rows is an iterator over an executed query's results.</code></span>
<span class="codeline" id="line-424"><code>type Rows interface {</code></span>
<span class="codeline" id="line-425"><code>	// Columns returns the names of the columns. The number of</code></span>
<span class="codeline" id="line-426"><code>	// columns of the result is inferred from the length of the</code></span>
<span class="codeline" id="line-427"><code>	// slice. If a particular column name isn't known, an empty</code></span>
<span class="codeline" id="line-428"><code>	// string should be returned for that entry.</code></span>
<span class="codeline" id="line-429"><code>	Columns() []string</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>	// Close closes the rows iterator.</code></span>
<span class="codeline" id="line-432"><code>	Close() error</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>	// Next is called to populate the next row of data into</code></span>
<span class="codeline" id="line-435"><code>	// the provided slice. The provided slice will be the same</code></span>
<span class="codeline" id="line-436"><code>	// size as the Columns() are wide.</code></span>
<span class="codeline" id="line-437"><code>	//</code></span>
<span class="codeline" id="line-438"><code>	// Next should return io.EOF when there are no more rows.</code></span>
<span class="codeline" id="line-439"><code>	//</code></span>
<span class="codeline" id="line-440"><code>	// The dest should not be written to outside of Next. Care</code></span>
<span class="codeline" id="line-441"><code>	// should be taken when closing Rows not to modify</code></span>
<span class="codeline" id="line-442"><code>	// a buffer held in dest.</code></span>
<span class="codeline" id="line-443"><code>	Next(dest []Value) error</code></span>
<span class="codeline" id="line-444"><code>}</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>// RowsNextResultSet extends the [Rows] interface by providing a way to signal</code></span>
<span class="codeline" id="line-447"><code>// the driver to advance to the next result set.</code></span>
<span class="codeline" id="line-448"><code>type RowsNextResultSet interface {</code></span>
<span class="codeline" id="line-449"><code>	Rows</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>	// HasNextResultSet is called at the end of the current result set and</code></span>
<span class="codeline" id="line-452"><code>	// reports whether there is another result set after the current one.</code></span>
<span class="codeline" id="line-453"><code>	HasNextResultSet() bool</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>	// NextResultSet advances the driver to the next result set even</code></span>
<span class="codeline" id="line-456"><code>	// if there are remaining rows in the current result set.</code></span>
<span class="codeline" id="line-457"><code>	//</code></span>
<span class="codeline" id="line-458"><code>	// NextResultSet should return io.EOF when there are no more result sets.</code></span>
<span class="codeline" id="line-459"><code>	NextResultSet() error</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>// RowsColumnTypeScanType may be implemented by [Rows]. It should return</code></span>
<span class="codeline" id="line-463"><code>// the value type that can be used to scan types into. For example, the database</code></span>
<span class="codeline" id="line-464"><code>// column type "bigint" this should return "[reflect.TypeOf](int64(0))".</code></span>
<span class="codeline" id="line-465"><code>type RowsColumnTypeScanType interface {</code></span>
<span class="codeline" id="line-466"><code>	Rows</code></span>
<span class="codeline" id="line-467"><code>	ColumnTypeScanType(index int) reflect.Type</code></span>
<span class="codeline" id="line-468"><code>}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>// RowsColumnTypeDatabaseTypeName may be implemented by [Rows]. It should return the</code></span>
<span class="codeline" id="line-471"><code>// database system type name without the length. Type names should be uppercase.</code></span>
<span class="codeline" id="line-472"><code>// Examples of returned types: "VARCHAR", "NVARCHAR", "VARCHAR2", "CHAR", "TEXT",</code></span>
<span class="codeline" id="line-473"><code>// "DECIMAL", "SMALLINT", "INT", "BIGINT", "BOOL", "[]BIGINT", "JSONB", "XML",</code></span>
<span class="codeline" id="line-474"><code>// "TIMESTAMP".</code></span>
<span class="codeline" id="line-475"><code>type RowsColumnTypeDatabaseTypeName interface {</code></span>
<span class="codeline" id="line-476"><code>	Rows</code></span>
<span class="codeline" id="line-477"><code>	ColumnTypeDatabaseTypeName(index int) string</code></span>
<span class="codeline" id="line-478"><code>}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>// RowsColumnTypeLength may be implemented by [Rows]. It should return the length</code></span>
<span class="codeline" id="line-481"><code>// of the column type if the column is a variable length type. If the column is</code></span>
<span class="codeline" id="line-482"><code>// not a variable length type ok should return false.</code></span>
<span class="codeline" id="line-483"><code>// If length is not limited other than system limits, it should return [math.MaxInt64].</code></span>
<span class="codeline" id="line-484"><code>// The following are examples of returned values for various types:</code></span>
<span class="codeline" id="line-485"><code>//</code></span>
<span class="codeline" id="line-486"><code>//	TEXT          (math.MaxInt64, true)</code></span>
<span class="codeline" id="line-487"><code>//	varchar(10)   (10, true)</code></span>
<span class="codeline" id="line-488"><code>//	nvarchar(10)  (10, true)</code></span>
<span class="codeline" id="line-489"><code>//	decimal       (0, false)</code></span>
<span class="codeline" id="line-490"><code>//	int           (0, false)</code></span>
<span class="codeline" id="line-491"><code>//	bytea(30)     (30, true)</code></span>
<span class="codeline" id="line-492"><code>type RowsColumnTypeLength interface {</code></span>
<span class="codeline" id="line-493"><code>	Rows</code></span>
<span class="codeline" id="line-494"><code>	ColumnTypeLength(index int) (length int64, ok bool)</code></span>
<span class="codeline" id="line-495"><code>}</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>// RowsColumnTypeNullable may be implemented by [Rows]. The nullable value should</code></span>
<span class="codeline" id="line-498"><code>// be true if it is known the column may be null, or false if the column is known</code></span>
<span class="codeline" id="line-499"><code>// to be not nullable.</code></span>
<span class="codeline" id="line-500"><code>// If the column nullability is unknown, ok should be false.</code></span>
<span class="codeline" id="line-501"><code>type RowsColumnTypeNullable interface {</code></span>
<span class="codeline" id="line-502"><code>	Rows</code></span>
<span class="codeline" id="line-503"><code>	ColumnTypeNullable(index int) (nullable, ok bool)</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>// RowsColumnTypePrecisionScale may be implemented by [Rows]. It should return</code></span>
<span class="codeline" id="line-507"><code>// the precision and scale for decimal types. If not applicable, ok should be false.</code></span>
<span class="codeline" id="line-508"><code>// The following are examples of returned values for various types:</code></span>
<span class="codeline" id="line-509"><code>//</code></span>
<span class="codeline" id="line-510"><code>//	decimal(38, 4)    (38, 4, true)</code></span>
<span class="codeline" id="line-511"><code>//	int               (0, 0, false)</code></span>
<span class="codeline" id="line-512"><code>//	decimal           (math.MaxInt64, math.MaxInt64, true)</code></span>
<span class="codeline" id="line-513"><code>type RowsColumnTypePrecisionScale interface {</code></span>
<span class="codeline" id="line-514"><code>	Rows</code></span>
<span class="codeline" id="line-515"><code>	ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool)</code></span>
<span class="codeline" id="line-516"><code>}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>// Tx is a transaction.</code></span>
<span class="codeline" id="line-519"><code>type Tx interface {</code></span>
<span class="codeline" id="line-520"><code>	Commit() error</code></span>
<span class="codeline" id="line-521"><code>	Rollback() error</code></span>
<span class="codeline" id="line-522"><code>}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>// RowsAffected implements [Result] for an INSERT or UPDATE operation</code></span>
<span class="codeline" id="line-525"><code>// which mutates a number of rows.</code></span>
<span class="codeline" id="line-526"><code>type RowsAffected int64</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>var _ Result = RowsAffected(0)</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>func (RowsAffected) LastInsertId() (int64, error) {</code></span>
<span class="codeline" id="line-531"><code>	return 0, errors.New("LastInsertId is not supported by this driver")</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>func (v RowsAffected) RowsAffected() (int64, error) {</code></span>
<span class="codeline" id="line-535"><code>	return int64(v), nil</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// ResultNoRows is a pre-defined [Result] for drivers to return when a DDL</code></span>
<span class="codeline" id="line-539"><code>// command (such as a CREATE TABLE) succeeds. It returns an error for both</code></span>
<span class="codeline" id="line-540"><code>// LastInsertId and [RowsAffected].</code></span>
<span class="codeline" id="line-541"><code>var ResultNoRows noRows</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>type noRows struct{}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>var _ Result = noRows{}</code></span>
<span class="codeline" id="line-546"><code></code></span>
<span class="codeline" id="line-547"><code>func (noRows) LastInsertId() (int64, error) {</code></span>
<span class="codeline" id="line-548"><code>	return 0, errors.New("no LastInsertId available after DDL statement")</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>func (noRows) RowsAffected() (int64, error) {</code></span>
<span class="codeline" id="line-552"><code>	return 0, errors.New("no RowsAffected available after DDL statement")</code></span>
<span class="codeline" id="line-553"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>