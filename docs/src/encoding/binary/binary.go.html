<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: binary.go in package encoding/binary</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	binary.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/binary.html">encoding/binary</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package binary implements simple translation between numbers and byte</code></span>
<span class="codeline" id="line-6"><code>// sequences and encoding and decoding of varints.</code></span>
<span class="codeline" id="line-7"><code>//</code></span>
<span class="codeline" id="line-8"><code>// Numbers are translated by reading and writing fixed-size values.</code></span>
<span class="codeline" id="line-9"><code>// A fixed-size value is either a fixed-size arithmetic</code></span>
<span class="codeline" id="line-10"><code>// type (bool, int8, uint8, int16, float32, complex64, ...)</code></span>
<span class="codeline" id="line-11"><code>// or an array or struct containing only fixed-size values.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>// The varint functions encode and decode single integer values using</code></span>
<span class="codeline" id="line-14"><code>// a variable-length encoding; smaller values require fewer bytes.</code></span>
<span class="codeline" id="line-15"><code>// For a specification, see</code></span>
<span class="codeline" id="line-16"><code>// https://developers.google.com/protocol-buffers/docs/encoding.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// This package favors simplicity over efficiency. Clients that require</code></span>
<span class="codeline" id="line-19"><code>// high-performance serialization, especially for large data structures,</code></span>
<span class="codeline" id="line-20"><code>// should look at more advanced solutions such as the [encoding/gob]</code></span>
<span class="codeline" id="line-21"><code>// package or [google.golang.org/protobuf] for protocol buffers.</code></span></div><span class="codeline" id="line-22"><code>package binary</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>import (</code></span>
<span class="codeline" id="line-25"><code>	"errors"</code></span>
<span class="codeline" id="line-26"><code>	"io"</code></span>
<span class="codeline" id="line-27"><code>	"math"</code></span>
<span class="codeline" id="line-28"><code>	"reflect"</code></span>
<span class="codeline" id="line-29"><code>	"sync"</code></span>
<span class="codeline" id="line-30"><code>)</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// A ByteOrder specifies how to convert byte slices into</code></span>
<span class="codeline" id="line-33"><code>// 16-, 32-, or 64-bit unsigned integers.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// It is implemented by [LittleEndian], [BigEndian], and [NativeEndian].</code></span>
<span class="codeline" id="line-36"><code>type ByteOrder interface {</code></span>
<span class="codeline" id="line-37"><code>	Uint16([]byte) uint16</code></span>
<span class="codeline" id="line-38"><code>	Uint32([]byte) uint32</code></span>
<span class="codeline" id="line-39"><code>	Uint64([]byte) uint64</code></span>
<span class="codeline" id="line-40"><code>	PutUint16([]byte, uint16)</code></span>
<span class="codeline" id="line-41"><code>	PutUint32([]byte, uint32)</code></span>
<span class="codeline" id="line-42"><code>	PutUint64([]byte, uint64)</code></span>
<span class="codeline" id="line-43"><code>	String() string</code></span>
<span class="codeline" id="line-44"><code>}</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>// AppendByteOrder specifies how to append 16-, 32-, or 64-bit unsigned integers</code></span>
<span class="codeline" id="line-47"><code>// into a byte slice.</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// It is implemented by [LittleEndian], [BigEndian], and [NativeEndian].</code></span>
<span class="codeline" id="line-50"><code>type AppendByteOrder interface {</code></span>
<span class="codeline" id="line-51"><code>	AppendUint16([]byte, uint16) []byte</code></span>
<span class="codeline" id="line-52"><code>	AppendUint32([]byte, uint32) []byte</code></span>
<span class="codeline" id="line-53"><code>	AppendUint64([]byte, uint64) []byte</code></span>
<span class="codeline" id="line-54"><code>	String() string</code></span>
<span class="codeline" id="line-55"><code>}</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>// LittleEndian is the little-endian implementation of [ByteOrder] and [AppendByteOrder].</code></span>
<span class="codeline" id="line-58"><code>var LittleEndian littleEndian</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// BigEndian is the big-endian implementation of [ByteOrder] and [AppendByteOrder].</code></span>
<span class="codeline" id="line-61"><code>var BigEndian bigEndian</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>type littleEndian struct{}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>func (littleEndian) Uint16(b []byte) uint16 {</code></span>
<span class="codeline" id="line-66"><code>	_ = b[1] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-67"><code>	return uint16(b[0]) | uint16(b[1])&lt;&lt;8</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>func (littleEndian) PutUint16(b []byte, v uint16) {</code></span>
<span class="codeline" id="line-71"><code>	_ = b[1] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-72"><code>	b[0] = byte(v)</code></span>
<span class="codeline" id="line-73"><code>	b[1] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-74"><code>}</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>func (littleEndian) AppendUint16(b []byte, v uint16) []byte {</code></span>
<span class="codeline" id="line-77"><code>	return append(b,</code></span>
<span class="codeline" id="line-78"><code>		byte(v),</code></span>
<span class="codeline" id="line-79"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-80"><code>	)</code></span>
<span class="codeline" id="line-81"><code>}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>func (littleEndian) Uint32(b []byte) uint32 {</code></span>
<span class="codeline" id="line-84"><code>	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-85"><code>	return uint32(b[0]) | uint32(b[1])&lt;&lt;8 | uint32(b[2])&lt;&lt;16 | uint32(b[3])&lt;&lt;24</code></span>
<span class="codeline" id="line-86"><code>}</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>func (littleEndian) PutUint32(b []byte, v uint32) {</code></span>
<span class="codeline" id="line-89"><code>	_ = b[3] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-90"><code>	b[0] = byte(v)</code></span>
<span class="codeline" id="line-91"><code>	b[1] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-92"><code>	b[2] = byte(v &gt;&gt; 16)</code></span>
<span class="codeline" id="line-93"><code>	b[3] = byte(v &gt;&gt; 24)</code></span>
<span class="codeline" id="line-94"><code>}</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>func (littleEndian) AppendUint32(b []byte, v uint32) []byte {</code></span>
<span class="codeline" id="line-97"><code>	return append(b,</code></span>
<span class="codeline" id="line-98"><code>		byte(v),</code></span>
<span class="codeline" id="line-99"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-100"><code>		byte(v&gt;&gt;16),</code></span>
<span class="codeline" id="line-101"><code>		byte(v&gt;&gt;24),</code></span>
<span class="codeline" id="line-102"><code>	)</code></span>
<span class="codeline" id="line-103"><code>}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>func (littleEndian) Uint64(b []byte) uint64 {</code></span>
<span class="codeline" id="line-106"><code>	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-107"><code>	return uint64(b[0]) | uint64(b[1])&lt;&lt;8 | uint64(b[2])&lt;&lt;16 | uint64(b[3])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-108"><code>		uint64(b[4])&lt;&lt;32 | uint64(b[5])&lt;&lt;40 | uint64(b[6])&lt;&lt;48 | uint64(b[7])&lt;&lt;56</code></span>
<span class="codeline" id="line-109"><code>}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>func (littleEndian) PutUint64(b []byte, v uint64) {</code></span>
<span class="codeline" id="line-112"><code>	_ = b[7] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-113"><code>	b[0] = byte(v)</code></span>
<span class="codeline" id="line-114"><code>	b[1] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-115"><code>	b[2] = byte(v &gt;&gt; 16)</code></span>
<span class="codeline" id="line-116"><code>	b[3] = byte(v &gt;&gt; 24)</code></span>
<span class="codeline" id="line-117"><code>	b[4] = byte(v &gt;&gt; 32)</code></span>
<span class="codeline" id="line-118"><code>	b[5] = byte(v &gt;&gt; 40)</code></span>
<span class="codeline" id="line-119"><code>	b[6] = byte(v &gt;&gt; 48)</code></span>
<span class="codeline" id="line-120"><code>	b[7] = byte(v &gt;&gt; 56)</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>func (littleEndian) AppendUint64(b []byte, v uint64) []byte {</code></span>
<span class="codeline" id="line-124"><code>	return append(b,</code></span>
<span class="codeline" id="line-125"><code>		byte(v),</code></span>
<span class="codeline" id="line-126"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-127"><code>		byte(v&gt;&gt;16),</code></span>
<span class="codeline" id="line-128"><code>		byte(v&gt;&gt;24),</code></span>
<span class="codeline" id="line-129"><code>		byte(v&gt;&gt;32),</code></span>
<span class="codeline" id="line-130"><code>		byte(v&gt;&gt;40),</code></span>
<span class="codeline" id="line-131"><code>		byte(v&gt;&gt;48),</code></span>
<span class="codeline" id="line-132"><code>		byte(v&gt;&gt;56),</code></span>
<span class="codeline" id="line-133"><code>	)</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>func (littleEndian) String() string { return "LittleEndian" }</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>func (littleEndian) GoString() string { return "binary.LittleEndian" }</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>type bigEndian struct{}</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>func (bigEndian) Uint16(b []byte) uint16 {</code></span>
<span class="codeline" id="line-143"><code>	_ = b[1] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-144"><code>	return uint16(b[1]) | uint16(b[0])&lt;&lt;8</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>func (bigEndian) PutUint16(b []byte, v uint16) {</code></span>
<span class="codeline" id="line-148"><code>	_ = b[1] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-149"><code>	b[0] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-150"><code>	b[1] = byte(v)</code></span>
<span class="codeline" id="line-151"><code>}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>func (bigEndian) AppendUint16(b []byte, v uint16) []byte {</code></span>
<span class="codeline" id="line-154"><code>	return append(b,</code></span>
<span class="codeline" id="line-155"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-156"><code>		byte(v),</code></span>
<span class="codeline" id="line-157"><code>	)</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>func (bigEndian) Uint32(b []byte) uint32 {</code></span>
<span class="codeline" id="line-161"><code>	_ = b[3] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-162"><code>	return uint32(b[3]) | uint32(b[2])&lt;&lt;8 | uint32(b[1])&lt;&lt;16 | uint32(b[0])&lt;&lt;24</code></span>
<span class="codeline" id="line-163"><code>}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>func (bigEndian) PutUint32(b []byte, v uint32) {</code></span>
<span class="codeline" id="line-166"><code>	_ = b[3] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-167"><code>	b[0] = byte(v &gt;&gt; 24)</code></span>
<span class="codeline" id="line-168"><code>	b[1] = byte(v &gt;&gt; 16)</code></span>
<span class="codeline" id="line-169"><code>	b[2] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-170"><code>	b[3] = byte(v)</code></span>
<span class="codeline" id="line-171"><code>}</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>func (bigEndian) AppendUint32(b []byte, v uint32) []byte {</code></span>
<span class="codeline" id="line-174"><code>	return append(b,</code></span>
<span class="codeline" id="line-175"><code>		byte(v&gt;&gt;24),</code></span>
<span class="codeline" id="line-176"><code>		byte(v&gt;&gt;16),</code></span>
<span class="codeline" id="line-177"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-178"><code>		byte(v),</code></span>
<span class="codeline" id="line-179"><code>	)</code></span>
<span class="codeline" id="line-180"><code>}</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>func (bigEndian) Uint64(b []byte) uint64 {</code></span>
<span class="codeline" id="line-183"><code>	_ = b[7] // bounds check hint to compiler; see golang.org/issue/14808</code></span>
<span class="codeline" id="line-184"><code>	return uint64(b[7]) | uint64(b[6])&lt;&lt;8 | uint64(b[5])&lt;&lt;16 | uint64(b[4])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-185"><code>		uint64(b[3])&lt;&lt;32 | uint64(b[2])&lt;&lt;40 | uint64(b[1])&lt;&lt;48 | uint64(b[0])&lt;&lt;56</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>func (bigEndian) PutUint64(b []byte, v uint64) {</code></span>
<span class="codeline" id="line-189"><code>	_ = b[7] // early bounds check to guarantee safety of writes below</code></span>
<span class="codeline" id="line-190"><code>	b[0] = byte(v &gt;&gt; 56)</code></span>
<span class="codeline" id="line-191"><code>	b[1] = byte(v &gt;&gt; 48)</code></span>
<span class="codeline" id="line-192"><code>	b[2] = byte(v &gt;&gt; 40)</code></span>
<span class="codeline" id="line-193"><code>	b[3] = byte(v &gt;&gt; 32)</code></span>
<span class="codeline" id="line-194"><code>	b[4] = byte(v &gt;&gt; 24)</code></span>
<span class="codeline" id="line-195"><code>	b[5] = byte(v &gt;&gt; 16)</code></span>
<span class="codeline" id="line-196"><code>	b[6] = byte(v &gt;&gt; 8)</code></span>
<span class="codeline" id="line-197"><code>	b[7] = byte(v)</code></span>
<span class="codeline" id="line-198"><code>}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>func (bigEndian) AppendUint64(b []byte, v uint64) []byte {</code></span>
<span class="codeline" id="line-201"><code>	return append(b,</code></span>
<span class="codeline" id="line-202"><code>		byte(v&gt;&gt;56),</code></span>
<span class="codeline" id="line-203"><code>		byte(v&gt;&gt;48),</code></span>
<span class="codeline" id="line-204"><code>		byte(v&gt;&gt;40),</code></span>
<span class="codeline" id="line-205"><code>		byte(v&gt;&gt;32),</code></span>
<span class="codeline" id="line-206"><code>		byte(v&gt;&gt;24),</code></span>
<span class="codeline" id="line-207"><code>		byte(v&gt;&gt;16),</code></span>
<span class="codeline" id="line-208"><code>		byte(v&gt;&gt;8),</code></span>
<span class="codeline" id="line-209"><code>		byte(v),</code></span>
<span class="codeline" id="line-210"><code>	)</code></span>
<span class="codeline" id="line-211"><code>}</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>func (bigEndian) String() string { return "BigEndian" }</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>func (bigEndian) GoString() string { return "binary.BigEndian" }</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>func (nativeEndian) String() string { return "NativeEndian" }</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>func (nativeEndian) GoString() string { return "binary.NativeEndian" }</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>// Read reads structured binary data from r into data.</code></span>
<span class="codeline" id="line-222"><code>// Data must be a pointer to a fixed-size value or a slice</code></span>
<span class="codeline" id="line-223"><code>// of fixed-size values.</code></span>
<span class="codeline" id="line-224"><code>// Bytes read from r are decoded using the specified byte order</code></span>
<span class="codeline" id="line-225"><code>// and written to successive fields of the data.</code></span>
<span class="codeline" id="line-226"><code>// When decoding boolean values, a zero byte is decoded as false, and</code></span>
<span class="codeline" id="line-227"><code>// any other non-zero byte is decoded as true.</code></span>
<span class="codeline" id="line-228"><code>// When reading into structs, the field data for fields with</code></span>
<span class="codeline" id="line-229"><code>// blank (_) field names is skipped; i.e., blank field names</code></span>
<span class="codeline" id="line-230"><code>// may be used for padding.</code></span>
<span class="codeline" id="line-231"><code>// When reading into a struct, all non-blank fields must be exported</code></span>
<span class="codeline" id="line-232"><code>// or Read may panic.</code></span>
<span class="codeline" id="line-233"><code>//</code></span>
<span class="codeline" id="line-234"><code>// The error is [io.EOF] only if no bytes were read.</code></span>
<span class="codeline" id="line-235"><code>// If an [io.EOF] happens after reading some but not all the bytes,</code></span>
<span class="codeline" id="line-236"><code>// Read returns [io.ErrUnexpectedEOF].</code></span>
<span class="codeline" id="line-237"><code>func Read(r io.Reader, order ByteOrder, data any) error {</code></span>
<span class="codeline" id="line-238"><code>	// Fast path for basic types and slices.</code></span>
<span class="codeline" id="line-239"><code>	if n := intDataSize(data); n != 0 {</code></span>
<span class="codeline" id="line-240"><code>		bs := make([]byte, n)</code></span>
<span class="codeline" id="line-241"><code>		if _, err := io.ReadFull(r, bs); err != nil {</code></span>
<span class="codeline" id="line-242"><code>			return err</code></span>
<span class="codeline" id="line-243"><code>		}</code></span>
<span class="codeline" id="line-244"><code>		switch data := data.(type) {</code></span>
<span class="codeline" id="line-245"><code>		case *bool:</code></span>
<span class="codeline" id="line-246"><code>			*data = bs[0] != 0</code></span>
<span class="codeline" id="line-247"><code>		case *int8:</code></span>
<span class="codeline" id="line-248"><code>			*data = int8(bs[0])</code></span>
<span class="codeline" id="line-249"><code>		case *uint8:</code></span>
<span class="codeline" id="line-250"><code>			*data = bs[0]</code></span>
<span class="codeline" id="line-251"><code>		case *int16:</code></span>
<span class="codeline" id="line-252"><code>			*data = int16(order.Uint16(bs))</code></span>
<span class="codeline" id="line-253"><code>		case *uint16:</code></span>
<span class="codeline" id="line-254"><code>			*data = order.Uint16(bs)</code></span>
<span class="codeline" id="line-255"><code>		case *int32:</code></span>
<span class="codeline" id="line-256"><code>			*data = int32(order.Uint32(bs))</code></span>
<span class="codeline" id="line-257"><code>		case *uint32:</code></span>
<span class="codeline" id="line-258"><code>			*data = order.Uint32(bs)</code></span>
<span class="codeline" id="line-259"><code>		case *int64:</code></span>
<span class="codeline" id="line-260"><code>			*data = int64(order.Uint64(bs))</code></span>
<span class="codeline" id="line-261"><code>		case *uint64:</code></span>
<span class="codeline" id="line-262"><code>			*data = order.Uint64(bs)</code></span>
<span class="codeline" id="line-263"><code>		case *float32:</code></span>
<span class="codeline" id="line-264"><code>			*data = math.Float32frombits(order.Uint32(bs))</code></span>
<span class="codeline" id="line-265"><code>		case *float64:</code></span>
<span class="codeline" id="line-266"><code>			*data = math.Float64frombits(order.Uint64(bs))</code></span>
<span class="codeline" id="line-267"><code>		case []bool:</code></span>
<span class="codeline" id="line-268"><code>			for i, x := range bs { // Easier to loop over the input for 8-bit values.</code></span>
<span class="codeline" id="line-269"><code>				data[i] = x != 0</code></span>
<span class="codeline" id="line-270"><code>			}</code></span>
<span class="codeline" id="line-271"><code>		case []int8:</code></span>
<span class="codeline" id="line-272"><code>			for i, x := range bs {</code></span>
<span class="codeline" id="line-273"><code>				data[i] = int8(x)</code></span>
<span class="codeline" id="line-274"><code>			}</code></span>
<span class="codeline" id="line-275"><code>		case []uint8:</code></span>
<span class="codeline" id="line-276"><code>			copy(data, bs)</code></span>
<span class="codeline" id="line-277"><code>		case []int16:</code></span>
<span class="codeline" id="line-278"><code>			for i := range data {</code></span>
<span class="codeline" id="line-279"><code>				data[i] = int16(order.Uint16(bs[2*i:]))</code></span>
<span class="codeline" id="line-280"><code>			}</code></span>
<span class="codeline" id="line-281"><code>		case []uint16:</code></span>
<span class="codeline" id="line-282"><code>			for i := range data {</code></span>
<span class="codeline" id="line-283"><code>				data[i] = order.Uint16(bs[2*i:])</code></span>
<span class="codeline" id="line-284"><code>			}</code></span>
<span class="codeline" id="line-285"><code>		case []int32:</code></span>
<span class="codeline" id="line-286"><code>			for i := range data {</code></span>
<span class="codeline" id="line-287"><code>				data[i] = int32(order.Uint32(bs[4*i:]))</code></span>
<span class="codeline" id="line-288"><code>			}</code></span>
<span class="codeline" id="line-289"><code>		case []uint32:</code></span>
<span class="codeline" id="line-290"><code>			for i := range data {</code></span>
<span class="codeline" id="line-291"><code>				data[i] = order.Uint32(bs[4*i:])</code></span>
<span class="codeline" id="line-292"><code>			}</code></span>
<span class="codeline" id="line-293"><code>		case []int64:</code></span>
<span class="codeline" id="line-294"><code>			for i := range data {</code></span>
<span class="codeline" id="line-295"><code>				data[i] = int64(order.Uint64(bs[8*i:]))</code></span>
<span class="codeline" id="line-296"><code>			}</code></span>
<span class="codeline" id="line-297"><code>		case []uint64:</code></span>
<span class="codeline" id="line-298"><code>			for i := range data {</code></span>
<span class="codeline" id="line-299"><code>				data[i] = order.Uint64(bs[8*i:])</code></span>
<span class="codeline" id="line-300"><code>			}</code></span>
<span class="codeline" id="line-301"><code>		case []float32:</code></span>
<span class="codeline" id="line-302"><code>			for i := range data {</code></span>
<span class="codeline" id="line-303"><code>				data[i] = math.Float32frombits(order.Uint32(bs[4*i:]))</code></span>
<span class="codeline" id="line-304"><code>			}</code></span>
<span class="codeline" id="line-305"><code>		case []float64:</code></span>
<span class="codeline" id="line-306"><code>			for i := range data {</code></span>
<span class="codeline" id="line-307"><code>				data[i] = math.Float64frombits(order.Uint64(bs[8*i:]))</code></span>
<span class="codeline" id="line-308"><code>			}</code></span>
<span class="codeline" id="line-309"><code>		default:</code></span>
<span class="codeline" id="line-310"><code>			n = 0 // fast path doesn't apply</code></span>
<span class="codeline" id="line-311"><code>		}</code></span>
<span class="codeline" id="line-312"><code>		if n != 0 {</code></span>
<span class="codeline" id="line-313"><code>			return nil</code></span>
<span class="codeline" id="line-314"><code>		}</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>	// Fallback to reflect-based decoding.</code></span>
<span class="codeline" id="line-318"><code>	v := reflect.ValueOf(data)</code></span>
<span class="codeline" id="line-319"><code>	size := -1</code></span>
<span class="codeline" id="line-320"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-321"><code>	case reflect.Pointer:</code></span>
<span class="codeline" id="line-322"><code>		v = v.Elem()</code></span>
<span class="codeline" id="line-323"><code>		size = dataSize(v)</code></span>
<span class="codeline" id="line-324"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-325"><code>		size = dataSize(v)</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>	if size &lt; 0 {</code></span>
<span class="codeline" id="line-328"><code>		return errors.New("binary.Read: invalid type " + reflect.TypeOf(data).String())</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	d := &amp;decoder{order: order, buf: make([]byte, size)}</code></span>
<span class="codeline" id="line-331"><code>	if _, err := io.ReadFull(r, d.buf); err != nil {</code></span>
<span class="codeline" id="line-332"><code>		return err</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code>	d.value(v)</code></span>
<span class="codeline" id="line-335"><code>	return nil</code></span>
<span class="codeline" id="line-336"><code>}</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>// Write writes the binary representation of data into w.</code></span>
<span class="codeline" id="line-339"><code>// Data must be a fixed-size value or a slice of fixed-size</code></span>
<span class="codeline" id="line-340"><code>// values, or a pointer to such data.</code></span>
<span class="codeline" id="line-341"><code>// Boolean values encode as one byte: 1 for true, and 0 for false.</code></span>
<span class="codeline" id="line-342"><code>// Bytes written to w are encoded using the specified byte order</code></span>
<span class="codeline" id="line-343"><code>// and read from successive fields of the data.</code></span>
<span class="codeline" id="line-344"><code>// When writing structs, zero values are written for fields</code></span>
<span class="codeline" id="line-345"><code>// with blank (_) field names.</code></span>
<span class="codeline" id="line-346"><code>func Write(w io.Writer, order ByteOrder, data any) error {</code></span>
<span class="codeline" id="line-347"><code>	// Fast path for basic types and slices.</code></span>
<span class="codeline" id="line-348"><code>	if n := intDataSize(data); n != 0 {</code></span>
<span class="codeline" id="line-349"><code>		bs := make([]byte, n)</code></span>
<span class="codeline" id="line-350"><code>		switch v := data.(type) {</code></span>
<span class="codeline" id="line-351"><code>		case *bool:</code></span>
<span class="codeline" id="line-352"><code>			if *v {</code></span>
<span class="codeline" id="line-353"><code>				bs[0] = 1</code></span>
<span class="codeline" id="line-354"><code>			} else {</code></span>
<span class="codeline" id="line-355"><code>				bs[0] = 0</code></span>
<span class="codeline" id="line-356"><code>			}</code></span>
<span class="codeline" id="line-357"><code>		case bool:</code></span>
<span class="codeline" id="line-358"><code>			if v {</code></span>
<span class="codeline" id="line-359"><code>				bs[0] = 1</code></span>
<span class="codeline" id="line-360"><code>			} else {</code></span>
<span class="codeline" id="line-361"><code>				bs[0] = 0</code></span>
<span class="codeline" id="line-362"><code>			}</code></span>
<span class="codeline" id="line-363"><code>		case []bool:</code></span>
<span class="codeline" id="line-364"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-365"><code>				if x {</code></span>
<span class="codeline" id="line-366"><code>					bs[i] = 1</code></span>
<span class="codeline" id="line-367"><code>				} else {</code></span>
<span class="codeline" id="line-368"><code>					bs[i] = 0</code></span>
<span class="codeline" id="line-369"><code>				}</code></span>
<span class="codeline" id="line-370"><code>			}</code></span>
<span class="codeline" id="line-371"><code>		case *int8:</code></span>
<span class="codeline" id="line-372"><code>			bs[0] = byte(*v)</code></span>
<span class="codeline" id="line-373"><code>		case int8:</code></span>
<span class="codeline" id="line-374"><code>			bs[0] = byte(v)</code></span>
<span class="codeline" id="line-375"><code>		case []int8:</code></span>
<span class="codeline" id="line-376"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-377"><code>				bs[i] = byte(x)</code></span>
<span class="codeline" id="line-378"><code>			}</code></span>
<span class="codeline" id="line-379"><code>		case *uint8:</code></span>
<span class="codeline" id="line-380"><code>			bs[0] = *v</code></span>
<span class="codeline" id="line-381"><code>		case uint8:</code></span>
<span class="codeline" id="line-382"><code>			bs[0] = v</code></span>
<span class="codeline" id="line-383"><code>		case []uint8:</code></span>
<span class="codeline" id="line-384"><code>			bs = v</code></span>
<span class="codeline" id="line-385"><code>		case *int16:</code></span>
<span class="codeline" id="line-386"><code>			order.PutUint16(bs, uint16(*v))</code></span>
<span class="codeline" id="line-387"><code>		case int16:</code></span>
<span class="codeline" id="line-388"><code>			order.PutUint16(bs, uint16(v))</code></span>
<span class="codeline" id="line-389"><code>		case []int16:</code></span>
<span class="codeline" id="line-390"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-391"><code>				order.PutUint16(bs[2*i:], uint16(x))</code></span>
<span class="codeline" id="line-392"><code>			}</code></span>
<span class="codeline" id="line-393"><code>		case *uint16:</code></span>
<span class="codeline" id="line-394"><code>			order.PutUint16(bs, *v)</code></span>
<span class="codeline" id="line-395"><code>		case uint16:</code></span>
<span class="codeline" id="line-396"><code>			order.PutUint16(bs, v)</code></span>
<span class="codeline" id="line-397"><code>		case []uint16:</code></span>
<span class="codeline" id="line-398"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-399"><code>				order.PutUint16(bs[2*i:], x)</code></span>
<span class="codeline" id="line-400"><code>			}</code></span>
<span class="codeline" id="line-401"><code>		case *int32:</code></span>
<span class="codeline" id="line-402"><code>			order.PutUint32(bs, uint32(*v))</code></span>
<span class="codeline" id="line-403"><code>		case int32:</code></span>
<span class="codeline" id="line-404"><code>			order.PutUint32(bs, uint32(v))</code></span>
<span class="codeline" id="line-405"><code>		case []int32:</code></span>
<span class="codeline" id="line-406"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-407"><code>				order.PutUint32(bs[4*i:], uint32(x))</code></span>
<span class="codeline" id="line-408"><code>			}</code></span>
<span class="codeline" id="line-409"><code>		case *uint32:</code></span>
<span class="codeline" id="line-410"><code>			order.PutUint32(bs, *v)</code></span>
<span class="codeline" id="line-411"><code>		case uint32:</code></span>
<span class="codeline" id="line-412"><code>			order.PutUint32(bs, v)</code></span>
<span class="codeline" id="line-413"><code>		case []uint32:</code></span>
<span class="codeline" id="line-414"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-415"><code>				order.PutUint32(bs[4*i:], x)</code></span>
<span class="codeline" id="line-416"><code>			}</code></span>
<span class="codeline" id="line-417"><code>		case *int64:</code></span>
<span class="codeline" id="line-418"><code>			order.PutUint64(bs, uint64(*v))</code></span>
<span class="codeline" id="line-419"><code>		case int64:</code></span>
<span class="codeline" id="line-420"><code>			order.PutUint64(bs, uint64(v))</code></span>
<span class="codeline" id="line-421"><code>		case []int64:</code></span>
<span class="codeline" id="line-422"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-423"><code>				order.PutUint64(bs[8*i:], uint64(x))</code></span>
<span class="codeline" id="line-424"><code>			}</code></span>
<span class="codeline" id="line-425"><code>		case *uint64:</code></span>
<span class="codeline" id="line-426"><code>			order.PutUint64(bs, *v)</code></span>
<span class="codeline" id="line-427"><code>		case uint64:</code></span>
<span class="codeline" id="line-428"><code>			order.PutUint64(bs, v)</code></span>
<span class="codeline" id="line-429"><code>		case []uint64:</code></span>
<span class="codeline" id="line-430"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-431"><code>				order.PutUint64(bs[8*i:], x)</code></span>
<span class="codeline" id="line-432"><code>			}</code></span>
<span class="codeline" id="line-433"><code>		case *float32:</code></span>
<span class="codeline" id="line-434"><code>			order.PutUint32(bs, math.Float32bits(*v))</code></span>
<span class="codeline" id="line-435"><code>		case float32:</code></span>
<span class="codeline" id="line-436"><code>			order.PutUint32(bs, math.Float32bits(v))</code></span>
<span class="codeline" id="line-437"><code>		case []float32:</code></span>
<span class="codeline" id="line-438"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-439"><code>				order.PutUint32(bs[4*i:], math.Float32bits(x))</code></span>
<span class="codeline" id="line-440"><code>			}</code></span>
<span class="codeline" id="line-441"><code>		case *float64:</code></span>
<span class="codeline" id="line-442"><code>			order.PutUint64(bs, math.Float64bits(*v))</code></span>
<span class="codeline" id="line-443"><code>		case float64:</code></span>
<span class="codeline" id="line-444"><code>			order.PutUint64(bs, math.Float64bits(v))</code></span>
<span class="codeline" id="line-445"><code>		case []float64:</code></span>
<span class="codeline" id="line-446"><code>			for i, x := range v {</code></span>
<span class="codeline" id="line-447"><code>				order.PutUint64(bs[8*i:], math.Float64bits(x))</code></span>
<span class="codeline" id="line-448"><code>			}</code></span>
<span class="codeline" id="line-449"><code>		}</code></span>
<span class="codeline" id="line-450"><code>		_, err := w.Write(bs)</code></span>
<span class="codeline" id="line-451"><code>		return err</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>	// Fallback to reflect-based encoding.</code></span>
<span class="codeline" id="line-455"><code>	v := reflect.Indirect(reflect.ValueOf(data))</code></span>
<span class="codeline" id="line-456"><code>	size := dataSize(v)</code></span>
<span class="codeline" id="line-457"><code>	if size &lt; 0 {</code></span>
<span class="codeline" id="line-458"><code>		return errors.New("binary.Write: some values are not fixed-sized in type " + reflect.TypeOf(data).String())</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code>	buf := make([]byte, size)</code></span>
<span class="codeline" id="line-461"><code>	e := &amp;encoder{order: order, buf: buf}</code></span>
<span class="codeline" id="line-462"><code>	e.value(v)</code></span>
<span class="codeline" id="line-463"><code>	_, err := w.Write(buf)</code></span>
<span class="codeline" id="line-464"><code>	return err</code></span>
<span class="codeline" id="line-465"><code>}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>// Size returns how many bytes [Write] would generate to encode the value v, which</code></span>
<span class="codeline" id="line-468"><code>// must be a fixed-size value or a slice of fixed-size values, or a pointer to such data.</code></span>
<span class="codeline" id="line-469"><code>// If v is neither of these, Size returns -1.</code></span>
<span class="codeline" id="line-470"><code>func Size(v any) int {</code></span>
<span class="codeline" id="line-471"><code>	return dataSize(reflect.Indirect(reflect.ValueOf(v)))</code></span>
<span class="codeline" id="line-472"><code>}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>var structSize sync.Map // map[reflect.Type]int</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>// dataSize returns the number of bytes the actual data represented by v occupies in memory.</code></span>
<span class="codeline" id="line-477"><code>// For compound structures, it sums the sizes of the elements. Thus, for instance, for a slice</code></span>
<span class="codeline" id="line-478"><code>// it returns the length of the slice times the element size and does not count the memory</code></span>
<span class="codeline" id="line-479"><code>// occupied by the header. If the type of v is not acceptable, dataSize returns -1.</code></span>
<span class="codeline" id="line-480"><code>func dataSize(v reflect.Value) int {</code></span>
<span class="codeline" id="line-481"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-482"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-483"><code>		if s := sizeof(v.Type().Elem()); s &gt;= 0 {</code></span>
<span class="codeline" id="line-484"><code>			return s * v.Len()</code></span>
<span class="codeline" id="line-485"><code>		}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-488"><code>		t := v.Type()</code></span>
<span class="codeline" id="line-489"><code>		if size, ok := structSize.Load(t); ok {</code></span>
<span class="codeline" id="line-490"><code>			return size.(int)</code></span>
<span class="codeline" id="line-491"><code>		}</code></span>
<span class="codeline" id="line-492"><code>		size := sizeof(t)</code></span>
<span class="codeline" id="line-493"><code>		structSize.Store(t, size)</code></span>
<span class="codeline" id="line-494"><code>		return size</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>	default:</code></span>
<span class="codeline" id="line-497"><code>		if v.IsValid() {</code></span>
<span class="codeline" id="line-498"><code>			return sizeof(v.Type())</code></span>
<span class="codeline" id="line-499"><code>		}</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>	return -1</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>// sizeof returns the size &gt;= 0 of variables for the given type or -1 if the type is not acceptable.</code></span>
<span class="codeline" id="line-506"><code>func sizeof(t reflect.Type) int {</code></span>
<span class="codeline" id="line-507"><code>	switch t.Kind() {</code></span>
<span class="codeline" id="line-508"><code>	case reflect.Array:</code></span>
<span class="codeline" id="line-509"><code>		if s := sizeof(t.Elem()); s &gt;= 0 {</code></span>
<span class="codeline" id="line-510"><code>			return s * t.Len()</code></span>
<span class="codeline" id="line-511"><code>		}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-514"><code>		sum := 0</code></span>
<span class="codeline" id="line-515"><code>		for i, n := 0, t.NumField(); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-516"><code>			s := sizeof(t.Field(i).Type)</code></span>
<span class="codeline" id="line-517"><code>			if s &lt; 0 {</code></span>
<span class="codeline" id="line-518"><code>				return -1</code></span>
<span class="codeline" id="line-519"><code>			}</code></span>
<span class="codeline" id="line-520"><code>			sum += s</code></span>
<span class="codeline" id="line-521"><code>		}</code></span>
<span class="codeline" id="line-522"><code>		return sum</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	case reflect.Bool,</code></span>
<span class="codeline" id="line-525"><code>		reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,</code></span>
<span class="codeline" id="line-526"><code>		reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-527"><code>		reflect.Float32, reflect.Float64, reflect.Complex64, reflect.Complex128:</code></span>
<span class="codeline" id="line-528"><code>		return int(t.Size())</code></span>
<span class="codeline" id="line-529"><code>	}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>	return -1</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>type coder struct {</code></span>
<span class="codeline" id="line-535"><code>	order  ByteOrder</code></span>
<span class="codeline" id="line-536"><code>	buf    []byte</code></span>
<span class="codeline" id="line-537"><code>	offset int</code></span>
<span class="codeline" id="line-538"><code>}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>type decoder coder</code></span>
<span class="codeline" id="line-541"><code>type encoder coder</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>func (d *decoder) bool() bool {</code></span>
<span class="codeline" id="line-544"><code>	x := d.buf[d.offset]</code></span>
<span class="codeline" id="line-545"><code>	d.offset++</code></span>
<span class="codeline" id="line-546"><code>	return x != 0</code></span>
<span class="codeline" id="line-547"><code>}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>func (e *encoder) bool(x bool) {</code></span>
<span class="codeline" id="line-550"><code>	if x {</code></span>
<span class="codeline" id="line-551"><code>		e.buf[e.offset] = 1</code></span>
<span class="codeline" id="line-552"><code>	} else {</code></span>
<span class="codeline" id="line-553"><code>		e.buf[e.offset] = 0</code></span>
<span class="codeline" id="line-554"><code>	}</code></span>
<span class="codeline" id="line-555"><code>	e.offset++</code></span>
<span class="codeline" id="line-556"><code>}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>func (d *decoder) uint8() uint8 {</code></span>
<span class="codeline" id="line-559"><code>	x := d.buf[d.offset]</code></span>
<span class="codeline" id="line-560"><code>	d.offset++</code></span>
<span class="codeline" id="line-561"><code>	return x</code></span>
<span class="codeline" id="line-562"><code>}</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>func (e *encoder) uint8(x uint8) {</code></span>
<span class="codeline" id="line-565"><code>	e.buf[e.offset] = x</code></span>
<span class="codeline" id="line-566"><code>	e.offset++</code></span>
<span class="codeline" id="line-567"><code>}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>func (d *decoder) uint16() uint16 {</code></span>
<span class="codeline" id="line-570"><code>	x := d.order.Uint16(d.buf[d.offset : d.offset+2])</code></span>
<span class="codeline" id="line-571"><code>	d.offset += 2</code></span>
<span class="codeline" id="line-572"><code>	return x</code></span>
<span class="codeline" id="line-573"><code>}</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>func (e *encoder) uint16(x uint16) {</code></span>
<span class="codeline" id="line-576"><code>	e.order.PutUint16(e.buf[e.offset:e.offset+2], x)</code></span>
<span class="codeline" id="line-577"><code>	e.offset += 2</code></span>
<span class="codeline" id="line-578"><code>}</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>func (d *decoder) uint32() uint32 {</code></span>
<span class="codeline" id="line-581"><code>	x := d.order.Uint32(d.buf[d.offset : d.offset+4])</code></span>
<span class="codeline" id="line-582"><code>	d.offset += 4</code></span>
<span class="codeline" id="line-583"><code>	return x</code></span>
<span class="codeline" id="line-584"><code>}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>func (e *encoder) uint32(x uint32) {</code></span>
<span class="codeline" id="line-587"><code>	e.order.PutUint32(e.buf[e.offset:e.offset+4], x)</code></span>
<span class="codeline" id="line-588"><code>	e.offset += 4</code></span>
<span class="codeline" id="line-589"><code>}</code></span>
<span class="codeline" id="line-590"><code></code></span>
<span class="codeline" id="line-591"><code>func (d *decoder) uint64() uint64 {</code></span>
<span class="codeline" id="line-592"><code>	x := d.order.Uint64(d.buf[d.offset : d.offset+8])</code></span>
<span class="codeline" id="line-593"><code>	d.offset += 8</code></span>
<span class="codeline" id="line-594"><code>	return x</code></span>
<span class="codeline" id="line-595"><code>}</code></span>
<span class="codeline" id="line-596"><code></code></span>
<span class="codeline" id="line-597"><code>func (e *encoder) uint64(x uint64) {</code></span>
<span class="codeline" id="line-598"><code>	e.order.PutUint64(e.buf[e.offset:e.offset+8], x)</code></span>
<span class="codeline" id="line-599"><code>	e.offset += 8</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>func (d *decoder) int8() int8 { return int8(d.uint8()) }</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>func (e *encoder) int8(x int8) { e.uint8(uint8(x)) }</code></span>
<span class="codeline" id="line-605"><code></code></span>
<span class="codeline" id="line-606"><code>func (d *decoder) int16() int16 { return int16(d.uint16()) }</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>func (e *encoder) int16(x int16) { e.uint16(uint16(x)) }</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>func (d *decoder) int32() int32 { return int32(d.uint32()) }</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>func (e *encoder) int32(x int32) { e.uint32(uint32(x)) }</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>func (d *decoder) int64() int64 { return int64(d.uint64()) }</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>func (e *encoder) int64(x int64) { e.uint64(uint64(x)) }</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>func (d *decoder) value(v reflect.Value) {</code></span>
<span class="codeline" id="line-619"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-620"><code>	case reflect.Array:</code></span>
<span class="codeline" id="line-621"><code>		l := v.Len()</code></span>
<span class="codeline" id="line-622"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-623"><code>			d.value(v.Index(i))</code></span>
<span class="codeline" id="line-624"><code>		}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-627"><code>		t := v.Type()</code></span>
<span class="codeline" id="line-628"><code>		l := v.NumField()</code></span>
<span class="codeline" id="line-629"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-630"><code>			// Note: Calling v.CanSet() below is an optimization.</code></span>
<span class="codeline" id="line-631"><code>			// It would be sufficient to check the field name,</code></span>
<span class="codeline" id="line-632"><code>			// but creating the StructField info for each field is</code></span>
<span class="codeline" id="line-633"><code>			// costly (run "go test -bench=ReadStruct" and compare</code></span>
<span class="codeline" id="line-634"><code>			// results when making changes to this code).</code></span>
<span class="codeline" id="line-635"><code>			if v := v.Field(i); v.CanSet() || t.Field(i).Name != "_" {</code></span>
<span class="codeline" id="line-636"><code>				d.value(v)</code></span>
<span class="codeline" id="line-637"><code>			} else {</code></span>
<span class="codeline" id="line-638"><code>				d.skip(v)</code></span>
<span class="codeline" id="line-639"><code>			}</code></span>
<span class="codeline" id="line-640"><code>		}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-643"><code>		l := v.Len()</code></span>
<span class="codeline" id="line-644"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-645"><code>			d.value(v.Index(i))</code></span>
<span class="codeline" id="line-646"><code>		}</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-649"><code>		v.SetBool(d.bool())</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>	case reflect.Int8:</code></span>
<span class="codeline" id="line-652"><code>		v.SetInt(int64(d.int8()))</code></span>
<span class="codeline" id="line-653"><code>	case reflect.Int16:</code></span>
<span class="codeline" id="line-654"><code>		v.SetInt(int64(d.int16()))</code></span>
<span class="codeline" id="line-655"><code>	case reflect.Int32:</code></span>
<span class="codeline" id="line-656"><code>		v.SetInt(int64(d.int32()))</code></span>
<span class="codeline" id="line-657"><code>	case reflect.Int64:</code></span>
<span class="codeline" id="line-658"><code>		v.SetInt(d.int64())</code></span>
<span class="codeline" id="line-659"><code></code></span>
<span class="codeline" id="line-660"><code>	case reflect.Uint8:</code></span>
<span class="codeline" id="line-661"><code>		v.SetUint(uint64(d.uint8()))</code></span>
<span class="codeline" id="line-662"><code>	case reflect.Uint16:</code></span>
<span class="codeline" id="line-663"><code>		v.SetUint(uint64(d.uint16()))</code></span>
<span class="codeline" id="line-664"><code>	case reflect.Uint32:</code></span>
<span class="codeline" id="line-665"><code>		v.SetUint(uint64(d.uint32()))</code></span>
<span class="codeline" id="line-666"><code>	case reflect.Uint64:</code></span>
<span class="codeline" id="line-667"><code>		v.SetUint(d.uint64())</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>	case reflect.Float32:</code></span>
<span class="codeline" id="line-670"><code>		v.SetFloat(float64(math.Float32frombits(d.uint32())))</code></span>
<span class="codeline" id="line-671"><code>	case reflect.Float64:</code></span>
<span class="codeline" id="line-672"><code>		v.SetFloat(math.Float64frombits(d.uint64()))</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	case reflect.Complex64:</code></span>
<span class="codeline" id="line-675"><code>		v.SetComplex(complex(</code></span>
<span class="codeline" id="line-676"><code>			float64(math.Float32frombits(d.uint32())),</code></span>
<span class="codeline" id="line-677"><code>			float64(math.Float32frombits(d.uint32())),</code></span>
<span class="codeline" id="line-678"><code>		))</code></span>
<span class="codeline" id="line-679"><code>	case reflect.Complex128:</code></span>
<span class="codeline" id="line-680"><code>		v.SetComplex(complex(</code></span>
<span class="codeline" id="line-681"><code>			math.Float64frombits(d.uint64()),</code></span>
<span class="codeline" id="line-682"><code>			math.Float64frombits(d.uint64()),</code></span>
<span class="codeline" id="line-683"><code>		))</code></span>
<span class="codeline" id="line-684"><code>	}</code></span>
<span class="codeline" id="line-685"><code>}</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>func (e *encoder) value(v reflect.Value) {</code></span>
<span class="codeline" id="line-688"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-689"><code>	case reflect.Array:</code></span>
<span class="codeline" id="line-690"><code>		l := v.Len()</code></span>
<span class="codeline" id="line-691"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-692"><code>			e.value(v.Index(i))</code></span>
<span class="codeline" id="line-693"><code>		}</code></span>
<span class="codeline" id="line-694"><code></code></span>
<span class="codeline" id="line-695"><code>	case reflect.Struct:</code></span>
<span class="codeline" id="line-696"><code>		t := v.Type()</code></span>
<span class="codeline" id="line-697"><code>		l := v.NumField()</code></span>
<span class="codeline" id="line-698"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-699"><code>			// see comment for corresponding code in decoder.value()</code></span>
<span class="codeline" id="line-700"><code>			if v := v.Field(i); v.CanSet() || t.Field(i).Name != "_" {</code></span>
<span class="codeline" id="line-701"><code>				e.value(v)</code></span>
<span class="codeline" id="line-702"><code>			} else {</code></span>
<span class="codeline" id="line-703"><code>				e.skip(v)</code></span>
<span class="codeline" id="line-704"><code>			}</code></span>
<span class="codeline" id="line-705"><code>		}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-708"><code>		l := v.Len()</code></span>
<span class="codeline" id="line-709"><code>		for i := 0; i &lt; l; i++ {</code></span>
<span class="codeline" id="line-710"><code>			e.value(v.Index(i))</code></span>
<span class="codeline" id="line-711"><code>		}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-714"><code>		e.bool(v.Bool())</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-717"><code>		switch v.Type().Kind() {</code></span>
<span class="codeline" id="line-718"><code>		case reflect.Int8:</code></span>
<span class="codeline" id="line-719"><code>			e.int8(int8(v.Int()))</code></span>
<span class="codeline" id="line-720"><code>		case reflect.Int16:</code></span>
<span class="codeline" id="line-721"><code>			e.int16(int16(v.Int()))</code></span>
<span class="codeline" id="line-722"><code>		case reflect.Int32:</code></span>
<span class="codeline" id="line-723"><code>			e.int32(int32(v.Int()))</code></span>
<span class="codeline" id="line-724"><code>		case reflect.Int64:</code></span>
<span class="codeline" id="line-725"><code>			e.int64(v.Int())</code></span>
<span class="codeline" id="line-726"><code>		}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-729"><code>		switch v.Type().Kind() {</code></span>
<span class="codeline" id="line-730"><code>		case reflect.Uint8:</code></span>
<span class="codeline" id="line-731"><code>			e.uint8(uint8(v.Uint()))</code></span>
<span class="codeline" id="line-732"><code>		case reflect.Uint16:</code></span>
<span class="codeline" id="line-733"><code>			e.uint16(uint16(v.Uint()))</code></span>
<span class="codeline" id="line-734"><code>		case reflect.Uint32:</code></span>
<span class="codeline" id="line-735"><code>			e.uint32(uint32(v.Uint()))</code></span>
<span class="codeline" id="line-736"><code>		case reflect.Uint64:</code></span>
<span class="codeline" id="line-737"><code>			e.uint64(v.Uint())</code></span>
<span class="codeline" id="line-738"><code>		}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-741"><code>		switch v.Type().Kind() {</code></span>
<span class="codeline" id="line-742"><code>		case reflect.Float32:</code></span>
<span class="codeline" id="line-743"><code>			e.uint32(math.Float32bits(float32(v.Float())))</code></span>
<span class="codeline" id="line-744"><code>		case reflect.Float64:</code></span>
<span class="codeline" id="line-745"><code>			e.uint64(math.Float64bits(v.Float()))</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>	case reflect.Complex64, reflect.Complex128:</code></span>
<span class="codeline" id="line-749"><code>		switch v.Type().Kind() {</code></span>
<span class="codeline" id="line-750"><code>		case reflect.Complex64:</code></span>
<span class="codeline" id="line-751"><code>			x := v.Complex()</code></span>
<span class="codeline" id="line-752"><code>			e.uint32(math.Float32bits(float32(real(x))))</code></span>
<span class="codeline" id="line-753"><code>			e.uint32(math.Float32bits(float32(imag(x))))</code></span>
<span class="codeline" id="line-754"><code>		case reflect.Complex128:</code></span>
<span class="codeline" id="line-755"><code>			x := v.Complex()</code></span>
<span class="codeline" id="line-756"><code>			e.uint64(math.Float64bits(real(x)))</code></span>
<span class="codeline" id="line-757"><code>			e.uint64(math.Float64bits(imag(x)))</code></span>
<span class="codeline" id="line-758"><code>		}</code></span>
<span class="codeline" id="line-759"><code>	}</code></span>
<span class="codeline" id="line-760"><code>}</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>func (d *decoder) skip(v reflect.Value) {</code></span>
<span class="codeline" id="line-763"><code>	d.offset += dataSize(v)</code></span>
<span class="codeline" id="line-764"><code>}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>func (e *encoder) skip(v reflect.Value) {</code></span>
<span class="codeline" id="line-767"><code>	n := dataSize(v)</code></span>
<span class="codeline" id="line-768"><code>	zero := e.buf[e.offset : e.offset+n]</code></span>
<span class="codeline" id="line-769"><code>	for i := range zero {</code></span>
<span class="codeline" id="line-770"><code>		zero[i] = 0</code></span>
<span class="codeline" id="line-771"><code>	}</code></span>
<span class="codeline" id="line-772"><code>	e.offset += n</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>// intDataSize returns the size of the data required to represent the data when encoded.</code></span>
<span class="codeline" id="line-776"><code>// It returns zero if the type cannot be implemented by the fast path in Read or Write.</code></span>
<span class="codeline" id="line-777"><code>func intDataSize(data any) int {</code></span>
<span class="codeline" id="line-778"><code>	switch data := data.(type) {</code></span>
<span class="codeline" id="line-779"><code>	case bool, int8, uint8, *bool, *int8, *uint8:</code></span>
<span class="codeline" id="line-780"><code>		return 1</code></span>
<span class="codeline" id="line-781"><code>	case []bool:</code></span>
<span class="codeline" id="line-782"><code>		return len(data)</code></span>
<span class="codeline" id="line-783"><code>	case []int8:</code></span>
<span class="codeline" id="line-784"><code>		return len(data)</code></span>
<span class="codeline" id="line-785"><code>	case []uint8:</code></span>
<span class="codeline" id="line-786"><code>		return len(data)</code></span>
<span class="codeline" id="line-787"><code>	case int16, uint16, *int16, *uint16:</code></span>
<span class="codeline" id="line-788"><code>		return 2</code></span>
<span class="codeline" id="line-789"><code>	case []int16:</code></span>
<span class="codeline" id="line-790"><code>		return 2 * len(data)</code></span>
<span class="codeline" id="line-791"><code>	case []uint16:</code></span>
<span class="codeline" id="line-792"><code>		return 2 * len(data)</code></span>
<span class="codeline" id="line-793"><code>	case int32, uint32, *int32, *uint32:</code></span>
<span class="codeline" id="line-794"><code>		return 4</code></span>
<span class="codeline" id="line-795"><code>	case []int32:</code></span>
<span class="codeline" id="line-796"><code>		return 4 * len(data)</code></span>
<span class="codeline" id="line-797"><code>	case []uint32:</code></span>
<span class="codeline" id="line-798"><code>		return 4 * len(data)</code></span>
<span class="codeline" id="line-799"><code>	case int64, uint64, *int64, *uint64:</code></span>
<span class="codeline" id="line-800"><code>		return 8</code></span>
<span class="codeline" id="line-801"><code>	case []int64:</code></span>
<span class="codeline" id="line-802"><code>		return 8 * len(data)</code></span>
<span class="codeline" id="line-803"><code>	case []uint64:</code></span>
<span class="codeline" id="line-804"><code>		return 8 * len(data)</code></span>
<span class="codeline" id="line-805"><code>	case float32, *float32:</code></span>
<span class="codeline" id="line-806"><code>		return 4</code></span>
<span class="codeline" id="line-807"><code>	case float64, *float64:</code></span>
<span class="codeline" id="line-808"><code>		return 8</code></span>
<span class="codeline" id="line-809"><code>	case []float32:</code></span>
<span class="codeline" id="line-810"><code>		return 4 * len(data)</code></span>
<span class="codeline" id="line-811"><code>	case []float64:</code></span>
<span class="codeline" id="line-812"><code>		return 8 * len(data)</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>	return 0</code></span>
<span class="codeline" id="line-815"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>