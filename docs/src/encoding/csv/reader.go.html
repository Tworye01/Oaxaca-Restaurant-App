<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: reader.go in package encoding/csv</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	reader.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/csv.html">encoding/csv</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package csv reads and writes comma-separated values (CSV) files.</code></span>
<span class="codeline" id="line-6"><code>// There are many kinds of CSV files; this package supports the format</code></span>
<span class="codeline" id="line-7"><code>// described in RFC 4180.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// A csv file contains zero or more records of one or more fields per record.</code></span>
<span class="codeline" id="line-10"><code>// Each record is separated by the newline character. The final record may</code></span>
<span class="codeline" id="line-11"><code>// optionally be followed by a newline character.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>//	field1,field2,field3</code></span>
<span class="codeline" id="line-14"><code>//</code></span>
<span class="codeline" id="line-15"><code>// White space is considered part of a field.</code></span>
<span class="codeline" id="line-16"><code>//</code></span>
<span class="codeline" id="line-17"><code>// Carriage returns before newline characters are silently removed.</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// Blank lines are ignored. A line with only whitespace characters (excluding</code></span>
<span class="codeline" id="line-20"><code>// the ending newline character) is not considered a blank line.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// Fields which start and stop with the quote character " are called</code></span>
<span class="codeline" id="line-23"><code>// quoted-fields. The beginning and ending quote are not part of the</code></span>
<span class="codeline" id="line-24"><code>// field.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// The source:</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>//	normal string,"quoted-field"</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// results in the fields</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>//	{`normal string`, `quoted-field`}</code></span>
<span class="codeline" id="line-33"><code>//</code></span>
<span class="codeline" id="line-34"><code>// Within a quoted-field a quote character followed by a second quote</code></span>
<span class="codeline" id="line-35"><code>// character is considered a single quote.</code></span>
<span class="codeline" id="line-36"><code>//</code></span>
<span class="codeline" id="line-37"><code>//	"the ""word"" is true","a ""quoted-field"""</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// results in</code></span>
<span class="codeline" id="line-40"><code>//</code></span>
<span class="codeline" id="line-41"><code>//	{`the "word" is true`, `a "quoted-field"`}</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>// Newlines and commas may be included in a quoted-field</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>//	"Multi-line</code></span>
<span class="codeline" id="line-46"><code>//	field","comma is ,"</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// results in</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>//	{`Multi-line</code></span>
<span class="codeline" id="line-51"><code>//	field`, `comma is ,`}</code></span></div><span class="codeline" id="line-52"><code>package csv</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>import (</code></span>
<span class="codeline" id="line-55"><code>	"bufio"</code></span>
<span class="codeline" id="line-56"><code>	"bytes"</code></span>
<span class="codeline" id="line-57"><code>	"errors"</code></span>
<span class="codeline" id="line-58"><code>	"fmt"</code></span>
<span class="codeline" id="line-59"><code>	"io"</code></span>
<span class="codeline" id="line-60"><code>	"unicode"</code></span>
<span class="codeline" id="line-61"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-62"><code>)</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// A ParseError is returned for parsing errors.</code></span>
<span class="codeline" id="line-65"><code>// Line and column numbers are 1-indexed.</code></span>
<span class="codeline" id="line-66"><code>type ParseError struct {</code></span>
<span class="codeline" id="line-67"><code>	StartLine int   // Line where the record starts</code></span>
<span class="codeline" id="line-68"><code>	Line      int   // Line where the error occurred</code></span>
<span class="codeline" id="line-69"><code>	Column    int   // Column (1-based byte index) where the error occurred</code></span>
<span class="codeline" id="line-70"><code>	Err       error // The actual error</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>func (e *ParseError) Error() string {</code></span>
<span class="codeline" id="line-74"><code>	if e.Err == ErrFieldCount {</code></span>
<span class="codeline" id="line-75"><code>		return fmt.Sprintf("record on line %d: %v", e.Line, e.Err)</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code>	if e.StartLine != e.Line {</code></span>
<span class="codeline" id="line-78"><code>		return fmt.Sprintf("record on line %d; parse error on line %d, column %d: %v", e.StartLine, e.Line, e.Column, e.Err)</code></span>
<span class="codeline" id="line-79"><code>	}</code></span>
<span class="codeline" id="line-80"><code>	return fmt.Sprintf("parse error on line %d, column %d: %v", e.Line, e.Column, e.Err)</code></span>
<span class="codeline" id="line-81"><code>}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>func (e *ParseError) Unwrap() error { return e.Err }</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>// These are the errors that can be returned in [ParseError.Err].</code></span>
<span class="codeline" id="line-86"><code>var (</code></span>
<span class="codeline" id="line-87"><code>	ErrBareQuote  = errors.New("bare \" in non-quoted-field")</code></span>
<span class="codeline" id="line-88"><code>	ErrQuote      = errors.New("extraneous or missing \" in quoted-field")</code></span>
<span class="codeline" id="line-89"><code>	ErrFieldCount = errors.New("wrong number of fields")</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>	// Deprecated: ErrTrailingComma is no longer used.</code></span>
<span class="codeline" id="line-92"><code>	ErrTrailingComma = errors.New("extra delimiter at end of line")</code></span>
<span class="codeline" id="line-93"><code>)</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>var errInvalidDelim = errors.New("csv: invalid field or comment delimiter")</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>func validDelim(r rune) bool {</code></span>
<span class="codeline" id="line-98"><code>	return r != 0 &amp;&amp; r != '"' &amp;&amp; r != '\r' &amp;&amp; r != '\n' &amp;&amp; utf8.ValidRune(r) &amp;&amp; r != utf8.RuneError</code></span>
<span class="codeline" id="line-99"><code>}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>// A Reader reads records from a CSV-encoded file.</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>// As returned by [NewReader], a Reader expects input conforming to RFC 4180.</code></span>
<span class="codeline" id="line-104"><code>// The exported fields can be changed to customize the details before the</code></span>
<span class="codeline" id="line-105"><code>// first call to [Reader.Read] or [Reader.ReadAll].</code></span>
<span class="codeline" id="line-106"><code>//</code></span>
<span class="codeline" id="line-107"><code>// The Reader converts all \r\n sequences in its input to plain \n,</code></span>
<span class="codeline" id="line-108"><code>// including in multiline field values, so that the returned data does</code></span>
<span class="codeline" id="line-109"><code>// not depend on which line-ending convention an input file uses.</code></span>
<span class="codeline" id="line-110"><code>type Reader struct {</code></span>
<span class="codeline" id="line-111"><code>	// Comma is the field delimiter.</code></span>
<span class="codeline" id="line-112"><code>	// It is set to comma (',') by NewReader.</code></span>
<span class="codeline" id="line-113"><code>	// Comma must be a valid rune and must not be \r, \n,</code></span>
<span class="codeline" id="line-114"><code>	// or the Unicode replacement character (0xFFFD).</code></span>
<span class="codeline" id="line-115"><code>	Comma rune</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// Comment, if not 0, is the comment character. Lines beginning with the</code></span>
<span class="codeline" id="line-118"><code>	// Comment character without preceding whitespace are ignored.</code></span>
<span class="codeline" id="line-119"><code>	// With leading whitespace the Comment character becomes part of the</code></span>
<span class="codeline" id="line-120"><code>	// field, even if TrimLeadingSpace is true.</code></span>
<span class="codeline" id="line-121"><code>	// Comment must be a valid rune and must not be \r, \n,</code></span>
<span class="codeline" id="line-122"><code>	// or the Unicode replacement character (0xFFFD).</code></span>
<span class="codeline" id="line-123"><code>	// It must also not be equal to Comma.</code></span>
<span class="codeline" id="line-124"><code>	Comment rune</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>	// FieldsPerRecord is the number of expected fields per record.</code></span>
<span class="codeline" id="line-127"><code>	// If FieldsPerRecord is positive, Read requires each record to</code></span>
<span class="codeline" id="line-128"><code>	// have the given number of fields. If FieldsPerRecord is 0, Read sets it to</code></span>
<span class="codeline" id="line-129"><code>	// the number of fields in the first record, so that future records must</code></span>
<span class="codeline" id="line-130"><code>	// have the same field count. If FieldsPerRecord is negative, no check is</code></span>
<span class="codeline" id="line-131"><code>	// made and records may have a variable number of fields.</code></span>
<span class="codeline" id="line-132"><code>	FieldsPerRecord int</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>	// If LazyQuotes is true, a quote may appear in an unquoted field and a</code></span>
<span class="codeline" id="line-135"><code>	// non-doubled quote may appear in a quoted field.</code></span>
<span class="codeline" id="line-136"><code>	LazyQuotes bool</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>	// If TrimLeadingSpace is true, leading white space in a field is ignored.</code></span>
<span class="codeline" id="line-139"><code>	// This is done even if the field delimiter, Comma, is white space.</code></span>
<span class="codeline" id="line-140"><code>	TrimLeadingSpace bool</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>	// ReuseRecord controls whether calls to Read may return a slice sharing</code></span>
<span class="codeline" id="line-143"><code>	// the backing array of the previous call's returned slice for performance.</code></span>
<span class="codeline" id="line-144"><code>	// By default, each call to Read returns newly allocated memory owned by the caller.</code></span>
<span class="codeline" id="line-145"><code>	ReuseRecord bool</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	// Deprecated: TrailingComma is no longer used.</code></span>
<span class="codeline" id="line-148"><code>	TrailingComma bool</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	r *bufio.Reader</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>	// numLine is the current line being read in the CSV file.</code></span>
<span class="codeline" id="line-153"><code>	numLine int</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// offset is the input stream byte offset of the current reader position.</code></span>
<span class="codeline" id="line-156"><code>	offset int64</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>	// rawBuffer is a line buffer only used by the readLine method.</code></span>
<span class="codeline" id="line-159"><code>	rawBuffer []byte</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	// recordBuffer holds the unescaped fields, one after another.</code></span>
<span class="codeline" id="line-162"><code>	// The fields can be accessed by using the indexes in fieldIndexes.</code></span>
<span class="codeline" id="line-163"><code>	// E.g., For the row `a,"b","c""d",e`, recordBuffer will contain `abc"de`</code></span>
<span class="codeline" id="line-164"><code>	// and fieldIndexes will contain the indexes [1, 2, 5, 6].</code></span>
<span class="codeline" id="line-165"><code>	recordBuffer []byte</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	// fieldIndexes is an index of fields inside recordBuffer.</code></span>
<span class="codeline" id="line-168"><code>	// The i'th field ends at offset fieldIndexes[i] in recordBuffer.</code></span>
<span class="codeline" id="line-169"><code>	fieldIndexes []int</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>	// fieldPositions is an index of field positions for the</code></span>
<span class="codeline" id="line-172"><code>	// last record returned by Read.</code></span>
<span class="codeline" id="line-173"><code>	fieldPositions []position</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>	// lastRecord is a record cache and only used when ReuseRecord == true.</code></span>
<span class="codeline" id="line-176"><code>	lastRecord []string</code></span>
<span class="codeline" id="line-177"><code>}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>// NewReader returns a new Reader that reads from r.</code></span>
<span class="codeline" id="line-180"><code>func NewReader(r io.Reader) *Reader {</code></span>
<span class="codeline" id="line-181"><code>	return &amp;Reader{</code></span>
<span class="codeline" id="line-182"><code>		Comma: ',',</code></span>
<span class="codeline" id="line-183"><code>		r:     bufio.NewReader(r),</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>}</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>// Read reads one record (a slice of fields) from r.</code></span>
<span class="codeline" id="line-188"><code>// If the record has an unexpected number of fields,</code></span>
<span class="codeline" id="line-189"><code>// Read returns the record along with the error [ErrFieldCount].</code></span>
<span class="codeline" id="line-190"><code>// If the record contains a field that cannot be parsed,</code></span>
<span class="codeline" id="line-191"><code>// Read returns a partial record along with the parse error.</code></span>
<span class="codeline" id="line-192"><code>// The partial record contains all fields read before the error.</code></span>
<span class="codeline" id="line-193"><code>// If there is no data left to be read, Read returns nil, [io.EOF].</code></span>
<span class="codeline" id="line-194"><code>// If [Reader.ReuseRecord] is true, the returned slice may be shared</code></span>
<span class="codeline" id="line-195"><code>// between multiple calls to Read.</code></span>
<span class="codeline" id="line-196"><code>func (r *Reader) Read() (record []string, err error) {</code></span>
<span class="codeline" id="line-197"><code>	if r.ReuseRecord {</code></span>
<span class="codeline" id="line-198"><code>		record, err = r.readRecord(r.lastRecord)</code></span>
<span class="codeline" id="line-199"><code>		r.lastRecord = record</code></span>
<span class="codeline" id="line-200"><code>	} else {</code></span>
<span class="codeline" id="line-201"><code>		record, err = r.readRecord(nil)</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	return record, err</code></span>
<span class="codeline" id="line-204"><code>}</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>// FieldPos returns the line and column corresponding to</code></span>
<span class="codeline" id="line-207"><code>// the start of the field with the given index in the slice most recently</code></span>
<span class="codeline" id="line-208"><code>// returned by [Reader.Read]. Numbering of lines and columns starts at 1;</code></span>
<span class="codeline" id="line-209"><code>// columns are counted in bytes, not runes.</code></span>
<span class="codeline" id="line-210"><code>//</code></span>
<span class="codeline" id="line-211"><code>// If this is called with an out-of-bounds index, it panics.</code></span>
<span class="codeline" id="line-212"><code>func (r *Reader) FieldPos(field int) (line, column int) {</code></span>
<span class="codeline" id="line-213"><code>	if field &lt; 0 || field &gt;= len(r.fieldPositions) {</code></span>
<span class="codeline" id="line-214"><code>		panic("out of range index passed to FieldPos")</code></span>
<span class="codeline" id="line-215"><code>	}</code></span>
<span class="codeline" id="line-216"><code>	p := &amp;r.fieldPositions[field]</code></span>
<span class="codeline" id="line-217"><code>	return p.line, p.col</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// InputOffset returns the input stream byte offset of the current reader</code></span>
<span class="codeline" id="line-221"><code>// position. The offset gives the location of the end of the most recently</code></span>
<span class="codeline" id="line-222"><code>// read row and the beginning of the next row.</code></span>
<span class="codeline" id="line-223"><code>func (r *Reader) InputOffset() int64 {</code></span>
<span class="codeline" id="line-224"><code>	return r.offset</code></span>
<span class="codeline" id="line-225"><code>}</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>// pos holds the position of a field in the current line.</code></span>
<span class="codeline" id="line-228"><code>type position struct {</code></span>
<span class="codeline" id="line-229"><code>	line, col int</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>// ReadAll reads all the remaining records from r.</code></span>
<span class="codeline" id="line-233"><code>// Each record is a slice of fields.</code></span>
<span class="codeline" id="line-234"><code>// A successful call returns err == nil, not err == [io.EOF]. Because ReadAll is</code></span>
<span class="codeline" id="line-235"><code>// defined to read until EOF, it does not treat end of file as an error to be</code></span>
<span class="codeline" id="line-236"><code>// reported.</code></span>
<span class="codeline" id="line-237"><code>func (r *Reader) ReadAll() (records [][]string, err error) {</code></span>
<span class="codeline" id="line-238"><code>	for {</code></span>
<span class="codeline" id="line-239"><code>		record, err := r.readRecord(nil)</code></span>
<span class="codeline" id="line-240"><code>		if err == io.EOF {</code></span>
<span class="codeline" id="line-241"><code>			return records, nil</code></span>
<span class="codeline" id="line-242"><code>		}</code></span>
<span class="codeline" id="line-243"><code>		if err != nil {</code></span>
<span class="codeline" id="line-244"><code>			return nil, err</code></span>
<span class="codeline" id="line-245"><code>		}</code></span>
<span class="codeline" id="line-246"><code>		records = append(records, record)</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// readLine reads the next line (with the trailing endline).</code></span>
<span class="codeline" id="line-251"><code>// If EOF is hit without a trailing endline, it will be omitted.</code></span>
<span class="codeline" id="line-252"><code>// If some bytes were read, then the error is never [io.EOF].</code></span>
<span class="codeline" id="line-253"><code>// The result is only valid until the next call to readLine.</code></span>
<span class="codeline" id="line-254"><code>func (r *Reader) readLine() ([]byte, error) {</code></span>
<span class="codeline" id="line-255"><code>	line, err := r.r.ReadSlice('\n')</code></span>
<span class="codeline" id="line-256"><code>	if err == bufio.ErrBufferFull {</code></span>
<span class="codeline" id="line-257"><code>		r.rawBuffer = append(r.rawBuffer[:0], line...)</code></span>
<span class="codeline" id="line-258"><code>		for err == bufio.ErrBufferFull {</code></span>
<span class="codeline" id="line-259"><code>			line, err = r.r.ReadSlice('\n')</code></span>
<span class="codeline" id="line-260"><code>			r.rawBuffer = append(r.rawBuffer, line...)</code></span>
<span class="codeline" id="line-261"><code>		}</code></span>
<span class="codeline" id="line-262"><code>		line = r.rawBuffer</code></span>
<span class="codeline" id="line-263"><code>	}</code></span>
<span class="codeline" id="line-264"><code>	readSize := len(line)</code></span>
<span class="codeline" id="line-265"><code>	if readSize &gt; 0 &amp;&amp; err == io.EOF {</code></span>
<span class="codeline" id="line-266"><code>		err = nil</code></span>
<span class="codeline" id="line-267"><code>		// For backwards compatibility, drop trailing \r before EOF.</code></span>
<span class="codeline" id="line-268"><code>		if line[readSize-1] == '\r' {</code></span>
<span class="codeline" id="line-269"><code>			line = line[:readSize-1]</code></span>
<span class="codeline" id="line-270"><code>		}</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	r.numLine++</code></span>
<span class="codeline" id="line-273"><code>	r.offset += int64(readSize)</code></span>
<span class="codeline" id="line-274"><code>	// Normalize \r\n to \n on all input lines.</code></span>
<span class="codeline" id="line-275"><code>	if n := len(line); n &gt;= 2 &amp;&amp; line[n-2] == '\r' &amp;&amp; line[n-1] == '\n' {</code></span>
<span class="codeline" id="line-276"><code>		line[n-2] = '\n'</code></span>
<span class="codeline" id="line-277"><code>		line = line[:n-1]</code></span>
<span class="codeline" id="line-278"><code>	}</code></span>
<span class="codeline" id="line-279"><code>	return line, err</code></span>
<span class="codeline" id="line-280"><code>}</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>// lengthNL reports the number of bytes for the trailing \n.</code></span>
<span class="codeline" id="line-283"><code>func lengthNL(b []byte) int {</code></span>
<span class="codeline" id="line-284"><code>	if len(b) &gt; 0 &amp;&amp; b[len(b)-1] == '\n' {</code></span>
<span class="codeline" id="line-285"><code>		return 1</code></span>
<span class="codeline" id="line-286"><code>	}</code></span>
<span class="codeline" id="line-287"><code>	return 0</code></span>
<span class="codeline" id="line-288"><code>}</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>// nextRune returns the next rune in b or utf8.RuneError.</code></span>
<span class="codeline" id="line-291"><code>func nextRune(b []byte) rune {</code></span>
<span class="codeline" id="line-292"><code>	r, _ := utf8.DecodeRune(b)</code></span>
<span class="codeline" id="line-293"><code>	return r</code></span>
<span class="codeline" id="line-294"><code>}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>func (r *Reader) readRecord(dst []string) ([]string, error) {</code></span>
<span class="codeline" id="line-297"><code>	if r.Comma == r.Comment || !validDelim(r.Comma) || (r.Comment != 0 &amp;&amp; !validDelim(r.Comment)) {</code></span>
<span class="codeline" id="line-298"><code>		return nil, errInvalidDelim</code></span>
<span class="codeline" id="line-299"><code>	}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>	// Read line (automatically skipping past empty lines and any comments).</code></span>
<span class="codeline" id="line-302"><code>	var line []byte</code></span>
<span class="codeline" id="line-303"><code>	var errRead error</code></span>
<span class="codeline" id="line-304"><code>	for errRead == nil {</code></span>
<span class="codeline" id="line-305"><code>		line, errRead = r.readLine()</code></span>
<span class="codeline" id="line-306"><code>		if r.Comment != 0 &amp;&amp; nextRune(line) == r.Comment {</code></span>
<span class="codeline" id="line-307"><code>			line = nil</code></span>
<span class="codeline" id="line-308"><code>			continue // Skip comment lines</code></span>
<span class="codeline" id="line-309"><code>		}</code></span>
<span class="codeline" id="line-310"><code>		if errRead == nil &amp;&amp; len(line) == lengthNL(line) {</code></span>
<span class="codeline" id="line-311"><code>			line = nil</code></span>
<span class="codeline" id="line-312"><code>			continue // Skip empty lines</code></span>
<span class="codeline" id="line-313"><code>		}</code></span>
<span class="codeline" id="line-314"><code>		break</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code>	if errRead == io.EOF {</code></span>
<span class="codeline" id="line-317"><code>		return nil, errRead</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code></code></span>
<span class="codeline" id="line-320"><code>	// Parse each field in the record.</code></span>
<span class="codeline" id="line-321"><code>	var err error</code></span>
<span class="codeline" id="line-322"><code>	const quoteLen = len(`"`)</code></span>
<span class="codeline" id="line-323"><code>	commaLen := utf8.RuneLen(r.Comma)</code></span>
<span class="codeline" id="line-324"><code>	recLine := r.numLine // Starting line for record</code></span>
<span class="codeline" id="line-325"><code>	r.recordBuffer = r.recordBuffer[:0]</code></span>
<span class="codeline" id="line-326"><code>	r.fieldIndexes = r.fieldIndexes[:0]</code></span>
<span class="codeline" id="line-327"><code>	r.fieldPositions = r.fieldPositions[:0]</code></span>
<span class="codeline" id="line-328"><code>	pos := position{line: r.numLine, col: 1}</code></span>
<span class="codeline" id="line-329"><code>parseField:</code></span>
<span class="codeline" id="line-330"><code>	for {</code></span>
<span class="codeline" id="line-331"><code>		if r.TrimLeadingSpace {</code></span>
<span class="codeline" id="line-332"><code>			i := bytes.IndexFunc(line, func(r rune) bool {</code></span>
<span class="codeline" id="line-333"><code>				return !unicode.IsSpace(r)</code></span>
<span class="codeline" id="line-334"><code>			})</code></span>
<span class="codeline" id="line-335"><code>			if i &lt; 0 {</code></span>
<span class="codeline" id="line-336"><code>				i = len(line)</code></span>
<span class="codeline" id="line-337"><code>				pos.col -= lengthNL(line)</code></span>
<span class="codeline" id="line-338"><code>			}</code></span>
<span class="codeline" id="line-339"><code>			line = line[i:]</code></span>
<span class="codeline" id="line-340"><code>			pos.col += i</code></span>
<span class="codeline" id="line-341"><code>		}</code></span>
<span class="codeline" id="line-342"><code>		if len(line) == 0 || line[0] != '"' {</code></span>
<span class="codeline" id="line-343"><code>			// Non-quoted string field</code></span>
<span class="codeline" id="line-344"><code>			i := bytes.IndexRune(line, r.Comma)</code></span>
<span class="codeline" id="line-345"><code>			field := line</code></span>
<span class="codeline" id="line-346"><code>			if i &gt;= 0 {</code></span>
<span class="codeline" id="line-347"><code>				field = field[:i]</code></span>
<span class="codeline" id="line-348"><code>			} else {</code></span>
<span class="codeline" id="line-349"><code>				field = field[:len(field)-lengthNL(field)]</code></span>
<span class="codeline" id="line-350"><code>			}</code></span>
<span class="codeline" id="line-351"><code>			// Check to make sure a quote does not appear in field.</code></span>
<span class="codeline" id="line-352"><code>			if !r.LazyQuotes {</code></span>
<span class="codeline" id="line-353"><code>				if j := bytes.IndexByte(field, '"'); j &gt;= 0 {</code></span>
<span class="codeline" id="line-354"><code>					col := pos.col + j</code></span>
<span class="codeline" id="line-355"><code>					err = &amp;ParseError{StartLine: recLine, Line: r.numLine, Column: col, Err: ErrBareQuote}</code></span>
<span class="codeline" id="line-356"><code>					break parseField</code></span>
<span class="codeline" id="line-357"><code>				}</code></span>
<span class="codeline" id="line-358"><code>			}</code></span>
<span class="codeline" id="line-359"><code>			r.recordBuffer = append(r.recordBuffer, field...)</code></span>
<span class="codeline" id="line-360"><code>			r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))</code></span>
<span class="codeline" id="line-361"><code>			r.fieldPositions = append(r.fieldPositions, pos)</code></span>
<span class="codeline" id="line-362"><code>			if i &gt;= 0 {</code></span>
<span class="codeline" id="line-363"><code>				line = line[i+commaLen:]</code></span>
<span class="codeline" id="line-364"><code>				pos.col += i + commaLen</code></span>
<span class="codeline" id="line-365"><code>				continue parseField</code></span>
<span class="codeline" id="line-366"><code>			}</code></span>
<span class="codeline" id="line-367"><code>			break parseField</code></span>
<span class="codeline" id="line-368"><code>		} else {</code></span>
<span class="codeline" id="line-369"><code>			// Quoted string field</code></span>
<span class="codeline" id="line-370"><code>			fieldPos := pos</code></span>
<span class="codeline" id="line-371"><code>			line = line[quoteLen:]</code></span>
<span class="codeline" id="line-372"><code>			pos.col += quoteLen</code></span>
<span class="codeline" id="line-373"><code>			for {</code></span>
<span class="codeline" id="line-374"><code>				i := bytes.IndexByte(line, '"')</code></span>
<span class="codeline" id="line-375"><code>				if i &gt;= 0 {</code></span>
<span class="codeline" id="line-376"><code>					// Hit next quote.</code></span>
<span class="codeline" id="line-377"><code>					r.recordBuffer = append(r.recordBuffer, line[:i]...)</code></span>
<span class="codeline" id="line-378"><code>					line = line[i+quoteLen:]</code></span>
<span class="codeline" id="line-379"><code>					pos.col += i + quoteLen</code></span>
<span class="codeline" id="line-380"><code>					switch rn := nextRune(line); {</code></span>
<span class="codeline" id="line-381"><code>					case rn == '"':</code></span>
<span class="codeline" id="line-382"><code>						// `""` sequence (append quote).</code></span>
<span class="codeline" id="line-383"><code>						r.recordBuffer = append(r.recordBuffer, '"')</code></span>
<span class="codeline" id="line-384"><code>						line = line[quoteLen:]</code></span>
<span class="codeline" id="line-385"><code>						pos.col += quoteLen</code></span>
<span class="codeline" id="line-386"><code>					case rn == r.Comma:</code></span>
<span class="codeline" id="line-387"><code>						// `",` sequence (end of field).</code></span>
<span class="codeline" id="line-388"><code>						line = line[commaLen:]</code></span>
<span class="codeline" id="line-389"><code>						pos.col += commaLen</code></span>
<span class="codeline" id="line-390"><code>						r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))</code></span>
<span class="codeline" id="line-391"><code>						r.fieldPositions = append(r.fieldPositions, fieldPos)</code></span>
<span class="codeline" id="line-392"><code>						continue parseField</code></span>
<span class="codeline" id="line-393"><code>					case lengthNL(line) == len(line):</code></span>
<span class="codeline" id="line-394"><code>						// `"\n` sequence (end of line).</code></span>
<span class="codeline" id="line-395"><code>						r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))</code></span>
<span class="codeline" id="line-396"><code>						r.fieldPositions = append(r.fieldPositions, fieldPos)</code></span>
<span class="codeline" id="line-397"><code>						break parseField</code></span>
<span class="codeline" id="line-398"><code>					case r.LazyQuotes:</code></span>
<span class="codeline" id="line-399"><code>						// `"` sequence (bare quote).</code></span>
<span class="codeline" id="line-400"><code>						r.recordBuffer = append(r.recordBuffer, '"')</code></span>
<span class="codeline" id="line-401"><code>					default:</code></span>
<span class="codeline" id="line-402"><code>						// `"*` sequence (invalid non-escaped quote).</code></span>
<span class="codeline" id="line-403"><code>						err = &amp;ParseError{StartLine: recLine, Line: r.numLine, Column: pos.col - quoteLen, Err: ErrQuote}</code></span>
<span class="codeline" id="line-404"><code>						break parseField</code></span>
<span class="codeline" id="line-405"><code>					}</code></span>
<span class="codeline" id="line-406"><code>				} else if len(line) &gt; 0 {</code></span>
<span class="codeline" id="line-407"><code>					// Hit end of line (copy all data so far).</code></span>
<span class="codeline" id="line-408"><code>					r.recordBuffer = append(r.recordBuffer, line...)</code></span>
<span class="codeline" id="line-409"><code>					if errRead != nil {</code></span>
<span class="codeline" id="line-410"><code>						break parseField</code></span>
<span class="codeline" id="line-411"><code>					}</code></span>
<span class="codeline" id="line-412"><code>					pos.col += len(line)</code></span>
<span class="codeline" id="line-413"><code>					line, errRead = r.readLine()</code></span>
<span class="codeline" id="line-414"><code>					if len(line) &gt; 0 {</code></span>
<span class="codeline" id="line-415"><code>						pos.line++</code></span>
<span class="codeline" id="line-416"><code>						pos.col = 1</code></span>
<span class="codeline" id="line-417"><code>					}</code></span>
<span class="codeline" id="line-418"><code>					if errRead == io.EOF {</code></span>
<span class="codeline" id="line-419"><code>						errRead = nil</code></span>
<span class="codeline" id="line-420"><code>					}</code></span>
<span class="codeline" id="line-421"><code>				} else {</code></span>
<span class="codeline" id="line-422"><code>					// Abrupt end of file (EOF or error).</code></span>
<span class="codeline" id="line-423"><code>					if !r.LazyQuotes &amp;&amp; errRead == nil {</code></span>
<span class="codeline" id="line-424"><code>						err = &amp;ParseError{StartLine: recLine, Line: pos.line, Column: pos.col, Err: ErrQuote}</code></span>
<span class="codeline" id="line-425"><code>						break parseField</code></span>
<span class="codeline" id="line-426"><code>					}</code></span>
<span class="codeline" id="line-427"><code>					r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))</code></span>
<span class="codeline" id="line-428"><code>					r.fieldPositions = append(r.fieldPositions, fieldPos)</code></span>
<span class="codeline" id="line-429"><code>					break parseField</code></span>
<span class="codeline" id="line-430"><code>				}</code></span>
<span class="codeline" id="line-431"><code>			}</code></span>
<span class="codeline" id="line-432"><code>		}</code></span>
<span class="codeline" id="line-433"><code>	}</code></span>
<span class="codeline" id="line-434"><code>	if err == nil {</code></span>
<span class="codeline" id="line-435"><code>		err = errRead</code></span>
<span class="codeline" id="line-436"><code>	}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>	// Create a single string and create slices out of it.</code></span>
<span class="codeline" id="line-439"><code>	// This pins the memory of the fields together, but allocates once.</code></span>
<span class="codeline" id="line-440"><code>	str := string(r.recordBuffer) // Convert to string once to batch allocations</code></span>
<span class="codeline" id="line-441"><code>	dst = dst[:0]</code></span>
<span class="codeline" id="line-442"><code>	if cap(dst) &lt; len(r.fieldIndexes) {</code></span>
<span class="codeline" id="line-443"><code>		dst = make([]string, len(r.fieldIndexes))</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code>	dst = dst[:len(r.fieldIndexes)]</code></span>
<span class="codeline" id="line-446"><code>	var preIdx int</code></span>
<span class="codeline" id="line-447"><code>	for i, idx := range r.fieldIndexes {</code></span>
<span class="codeline" id="line-448"><code>		dst[i] = str[preIdx:idx]</code></span>
<span class="codeline" id="line-449"><code>		preIdx = idx</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>	// Check or update the expected fields per record.</code></span>
<span class="codeline" id="line-453"><code>	if r.FieldsPerRecord &gt; 0 {</code></span>
<span class="codeline" id="line-454"><code>		if len(dst) != r.FieldsPerRecord &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-455"><code>			err = &amp;ParseError{</code></span>
<span class="codeline" id="line-456"><code>				StartLine: recLine,</code></span>
<span class="codeline" id="line-457"><code>				Line:      recLine,</code></span>
<span class="codeline" id="line-458"><code>				Column:    1,</code></span>
<span class="codeline" id="line-459"><code>				Err:       ErrFieldCount,</code></span>
<span class="codeline" id="line-460"><code>			}</code></span>
<span class="codeline" id="line-461"><code>		}</code></span>
<span class="codeline" id="line-462"><code>	} else if r.FieldsPerRecord == 0 {</code></span>
<span class="codeline" id="line-463"><code>		r.FieldsPerRecord = len(dst)</code></span>
<span class="codeline" id="line-464"><code>	}</code></span>
<span class="codeline" id="line-465"><code>	return dst, err</code></span>
<span class="codeline" id="line-466"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>