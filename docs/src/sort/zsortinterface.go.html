<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: zsortinterface.go in package sort</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	zsortinterface.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/sort.html">sort</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by gen_sort_variants.go; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2022 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package sort</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>// insertionSort sorts data[a:b] using insertion sort.</code></span>
<span class="codeline" id="line-10"><code>func insertionSort(data Interface, a, b int) {</code></span>
<span class="codeline" id="line-11"><code>	for i := a + 1; i &lt; b; i++ {</code></span>
<span class="codeline" id="line-12"><code>		for j := i; j &gt; a &amp;&amp; data.Less(j, j-1); j-- {</code></span>
<span class="codeline" id="line-13"><code>			data.Swap(j, j-1)</code></span>
<span class="codeline" id="line-14"><code>		}</code></span>
<span class="codeline" id="line-15"><code>	}</code></span>
<span class="codeline" id="line-16"><code>}</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// siftDown implements the heap property on data[lo:hi].</code></span>
<span class="codeline" id="line-19"><code>// first is an offset into the array where the root of the heap lies.</code></span>
<span class="codeline" id="line-20"><code>func siftDown(data Interface, lo, hi, first int) {</code></span>
<span class="codeline" id="line-21"><code>	root := lo</code></span>
<span class="codeline" id="line-22"><code>	for {</code></span>
<span class="codeline" id="line-23"><code>		child := 2*root + 1</code></span>
<span class="codeline" id="line-24"><code>		if child &gt;= hi {</code></span>
<span class="codeline" id="line-25"><code>			break</code></span>
<span class="codeline" id="line-26"><code>		}</code></span>
<span class="codeline" id="line-27"><code>		if child+1 &lt; hi &amp;&amp; data.Less(first+child, first+child+1) {</code></span>
<span class="codeline" id="line-28"><code>			child++</code></span>
<span class="codeline" id="line-29"><code>		}</code></span>
<span class="codeline" id="line-30"><code>		if !data.Less(first+root, first+child) {</code></span>
<span class="codeline" id="line-31"><code>			return</code></span>
<span class="codeline" id="line-32"><code>		}</code></span>
<span class="codeline" id="line-33"><code>		data.Swap(first+root, first+child)</code></span>
<span class="codeline" id="line-34"><code>		root = child</code></span>
<span class="codeline" id="line-35"><code>	}</code></span>
<span class="codeline" id="line-36"><code>}</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>func heapSort(data Interface, a, b int) {</code></span>
<span class="codeline" id="line-39"><code>	first := a</code></span>
<span class="codeline" id="line-40"><code>	lo := 0</code></span>
<span class="codeline" id="line-41"><code>	hi := b - a</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>	// Build heap with greatest element at top.</code></span>
<span class="codeline" id="line-44"><code>	for i := (hi - 1) / 2; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-45"><code>		siftDown(data, i, hi, first)</code></span>
<span class="codeline" id="line-46"><code>	}</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>	// Pop elements, largest first, into end of data.</code></span>
<span class="codeline" id="line-49"><code>	for i := hi - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-50"><code>		data.Swap(first, first+i)</code></span>
<span class="codeline" id="line-51"><code>		siftDown(data, lo, i, first)</code></span>
<span class="codeline" id="line-52"><code>	}</code></span>
<span class="codeline" id="line-53"><code>}</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>// pdqsort sorts data[a:b].</code></span>
<span class="codeline" id="line-56"><code>// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.</code></span>
<span class="codeline" id="line-57"><code>// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf</code></span>
<span class="codeline" id="line-58"><code>// C++ implementation: https://github.com/orlp/pdqsort</code></span>
<span class="codeline" id="line-59"><code>// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/</code></span>
<span class="codeline" id="line-60"><code>// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.</code></span>
<span class="codeline" id="line-61"><code>func pdqsort(data Interface, a, b, limit int) {</code></span>
<span class="codeline" id="line-62"><code>	const maxInsertion = 12</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>	var (</code></span>
<span class="codeline" id="line-65"><code>		wasBalanced    = true // whether the last partitioning was reasonably balanced</code></span>
<span class="codeline" id="line-66"><code>		wasPartitioned = true // whether the slice was already partitioned</code></span>
<span class="codeline" id="line-67"><code>	)</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>	for {</code></span>
<span class="codeline" id="line-70"><code>		length := b - a</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>		if length &lt;= maxInsertion {</code></span>
<span class="codeline" id="line-73"><code>			insertionSort(data, a, b)</code></span>
<span class="codeline" id="line-74"><code>			return</code></span>
<span class="codeline" id="line-75"><code>		}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>		// Fall back to heapsort if too many bad choices were made.</code></span>
<span class="codeline" id="line-78"><code>		if limit == 0 {</code></span>
<span class="codeline" id="line-79"><code>			heapSort(data, a, b)</code></span>
<span class="codeline" id="line-80"><code>			return</code></span>
<span class="codeline" id="line-81"><code>		}</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>		// If the last partitioning was imbalanced, we need to breaking patterns.</code></span>
<span class="codeline" id="line-84"><code>		if !wasBalanced {</code></span>
<span class="codeline" id="line-85"><code>			breakPatterns(data, a, b)</code></span>
<span class="codeline" id="line-86"><code>			limit--</code></span>
<span class="codeline" id="line-87"><code>		}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>		pivot, hint := choosePivot(data, a, b)</code></span>
<span class="codeline" id="line-90"><code>		if hint == decreasingHint {</code></span>
<span class="codeline" id="line-91"><code>			reverseRange(data, a, b)</code></span>
<span class="codeline" id="line-92"><code>			// The chosen pivot was pivot-a elements after the start of the array.</code></span>
<span class="codeline" id="line-93"><code>			// After reversing it is pivot-a elements before the end of the array.</code></span>
<span class="codeline" id="line-94"><code>			// The idea came from Rust's implementation.</code></span>
<span class="codeline" id="line-95"><code>			pivot = (b - 1) - (pivot - a)</code></span>
<span class="codeline" id="line-96"><code>			hint = increasingHint</code></span>
<span class="codeline" id="line-97"><code>		}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>		// The slice is likely already sorted.</code></span>
<span class="codeline" id="line-100"><code>		if wasBalanced &amp;&amp; wasPartitioned &amp;&amp; hint == increasingHint {</code></span>
<span class="codeline" id="line-101"><code>			if partialInsertionSort(data, a, b) {</code></span>
<span class="codeline" id="line-102"><code>				return</code></span>
<span class="codeline" id="line-103"><code>			}</code></span>
<span class="codeline" id="line-104"><code>		}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>		// Probably the slice contains many duplicate elements, partition the slice into</code></span>
<span class="codeline" id="line-107"><code>		// elements equal to and elements greater than the pivot.</code></span>
<span class="codeline" id="line-108"><code>		if a &gt; 0 &amp;&amp; !data.Less(a-1, pivot) {</code></span>
<span class="codeline" id="line-109"><code>			mid := partitionEqual(data, a, b, pivot)</code></span>
<span class="codeline" id="line-110"><code>			a = mid</code></span>
<span class="codeline" id="line-111"><code>			continue</code></span>
<span class="codeline" id="line-112"><code>		}</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>		mid, alreadyPartitioned := partition(data, a, b, pivot)</code></span>
<span class="codeline" id="line-115"><code>		wasPartitioned = alreadyPartitioned</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>		leftLen, rightLen := mid-a, b-mid</code></span>
<span class="codeline" id="line-118"><code>		balanceThreshold := length / 8</code></span>
<span class="codeline" id="line-119"><code>		if leftLen &lt; rightLen {</code></span>
<span class="codeline" id="line-120"><code>			wasBalanced = leftLen &gt;= balanceThreshold</code></span>
<span class="codeline" id="line-121"><code>			pdqsort(data, a, mid, limit)</code></span>
<span class="codeline" id="line-122"><code>			a = mid + 1</code></span>
<span class="codeline" id="line-123"><code>		} else {</code></span>
<span class="codeline" id="line-124"><code>			wasBalanced = rightLen &gt;= balanceThreshold</code></span>
<span class="codeline" id="line-125"><code>			pdqsort(data, mid+1, b, limit)</code></span>
<span class="codeline" id="line-126"><code>			b = mid</code></span>
<span class="codeline" id="line-127"><code>		}</code></span>
<span class="codeline" id="line-128"><code>	}</code></span>
<span class="codeline" id="line-129"><code>}</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>// partition does one quicksort partition.</code></span>
<span class="codeline" id="line-132"><code>// Let p = data[pivot]</code></span>
<span class="codeline" id="line-133"><code>// Moves elements in data[a:b] around, so that data[i]&lt;p and data[j]&gt;=p for i&lt;newpivot and j&gt;newpivot.</code></span>
<span class="codeline" id="line-134"><code>// On return, data[newpivot] = p</code></span>
<span class="codeline" id="line-135"><code>func partition(data Interface, a, b, pivot int) (newpivot int, alreadyPartitioned bool) {</code></span>
<span class="codeline" id="line-136"><code>	data.Swap(a, pivot)</code></span>
<span class="codeline" id="line-137"><code>	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>	for i &lt;= j &amp;&amp; data.Less(i, a) {</code></span>
<span class="codeline" id="line-140"><code>		i++</code></span>
<span class="codeline" id="line-141"><code>	}</code></span>
<span class="codeline" id="line-142"><code>	for i &lt;= j &amp;&amp; !data.Less(j, a) {</code></span>
<span class="codeline" id="line-143"><code>		j--</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code>	if i &gt; j {</code></span>
<span class="codeline" id="line-146"><code>		data.Swap(j, a)</code></span>
<span class="codeline" id="line-147"><code>		return j, true</code></span>
<span class="codeline" id="line-148"><code>	}</code></span>
<span class="codeline" id="line-149"><code>	data.Swap(i, j)</code></span>
<span class="codeline" id="line-150"><code>	i++</code></span>
<span class="codeline" id="line-151"><code>	j--</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>	for {</code></span>
<span class="codeline" id="line-154"><code>		for i &lt;= j &amp;&amp; data.Less(i, a) {</code></span>
<span class="codeline" id="line-155"><code>			i++</code></span>
<span class="codeline" id="line-156"><code>		}</code></span>
<span class="codeline" id="line-157"><code>		for i &lt;= j &amp;&amp; !data.Less(j, a) {</code></span>
<span class="codeline" id="line-158"><code>			j--</code></span>
<span class="codeline" id="line-159"><code>		}</code></span>
<span class="codeline" id="line-160"><code>		if i &gt; j {</code></span>
<span class="codeline" id="line-161"><code>			break</code></span>
<span class="codeline" id="line-162"><code>		}</code></span>
<span class="codeline" id="line-163"><code>		data.Swap(i, j)</code></span>
<span class="codeline" id="line-164"><code>		i++</code></span>
<span class="codeline" id="line-165"><code>		j--</code></span>
<span class="codeline" id="line-166"><code>	}</code></span>
<span class="codeline" id="line-167"><code>	data.Swap(j, a)</code></span>
<span class="codeline" id="line-168"><code>	return j, false</code></span>
<span class="codeline" id="line-169"><code>}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>// partitionEqual partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].</code></span>
<span class="codeline" id="line-172"><code>// It assumed that data[a:b] does not contain elements smaller than the data[pivot].</code></span>
<span class="codeline" id="line-173"><code>func partitionEqual(data Interface, a, b, pivot int) (newpivot int) {</code></span>
<span class="codeline" id="line-174"><code>	data.Swap(a, pivot)</code></span>
<span class="codeline" id="line-175"><code>	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	for {</code></span>
<span class="codeline" id="line-178"><code>		for i &lt;= j &amp;&amp; !data.Less(a, i) {</code></span>
<span class="codeline" id="line-179"><code>			i++</code></span>
<span class="codeline" id="line-180"><code>		}</code></span>
<span class="codeline" id="line-181"><code>		for i &lt;= j &amp;&amp; data.Less(a, j) {</code></span>
<span class="codeline" id="line-182"><code>			j--</code></span>
<span class="codeline" id="line-183"><code>		}</code></span>
<span class="codeline" id="line-184"><code>		if i &gt; j {</code></span>
<span class="codeline" id="line-185"><code>			break</code></span>
<span class="codeline" id="line-186"><code>		}</code></span>
<span class="codeline" id="line-187"><code>		data.Swap(i, j)</code></span>
<span class="codeline" id="line-188"><code>		i++</code></span>
<span class="codeline" id="line-189"><code>		j--</code></span>
<span class="codeline" id="line-190"><code>	}</code></span>
<span class="codeline" id="line-191"><code>	return i</code></span>
<span class="codeline" id="line-192"><code>}</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>// partialInsertionSort partially sorts a slice, returns true if the slice is sorted at the end.</code></span>
<span class="codeline" id="line-195"><code>func partialInsertionSort(data Interface, a, b int) bool {</code></span>
<span class="codeline" id="line-196"><code>	const (</code></span>
<span class="codeline" id="line-197"><code>		maxSteps         = 5  // maximum number of adjacent out-of-order pairs that will get shifted</code></span>
<span class="codeline" id="line-198"><code>		shortestShifting = 50 // don't shift any elements on short arrays</code></span>
<span class="codeline" id="line-199"><code>	)</code></span>
<span class="codeline" id="line-200"><code>	i := a + 1</code></span>
<span class="codeline" id="line-201"><code>	for j := 0; j &lt; maxSteps; j++ {</code></span>
<span class="codeline" id="line-202"><code>		for i &lt; b &amp;&amp; !data.Less(i, i-1) {</code></span>
<span class="codeline" id="line-203"><code>			i++</code></span>
<span class="codeline" id="line-204"><code>		}</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>		if i == b {</code></span>
<span class="codeline" id="line-207"><code>			return true</code></span>
<span class="codeline" id="line-208"><code>		}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>		if b-a &lt; shortestShifting {</code></span>
<span class="codeline" id="line-211"><code>			return false</code></span>
<span class="codeline" id="line-212"><code>		}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>		data.Swap(i, i-1)</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>		// Shift the smaller one to the left.</code></span>
<span class="codeline" id="line-217"><code>		if i-a &gt;= 2 {</code></span>
<span class="codeline" id="line-218"><code>			for j := i - 1; j &gt;= 1; j-- {</code></span>
<span class="codeline" id="line-219"><code>				if !data.Less(j, j-1) {</code></span>
<span class="codeline" id="line-220"><code>					break</code></span>
<span class="codeline" id="line-221"><code>				}</code></span>
<span class="codeline" id="line-222"><code>				data.Swap(j, j-1)</code></span>
<span class="codeline" id="line-223"><code>			}</code></span>
<span class="codeline" id="line-224"><code>		}</code></span>
<span class="codeline" id="line-225"><code>		// Shift the greater one to the right.</code></span>
<span class="codeline" id="line-226"><code>		if b-i &gt;= 2 {</code></span>
<span class="codeline" id="line-227"><code>			for j := i + 1; j &lt; b; j++ {</code></span>
<span class="codeline" id="line-228"><code>				if !data.Less(j, j-1) {</code></span>
<span class="codeline" id="line-229"><code>					break</code></span>
<span class="codeline" id="line-230"><code>				}</code></span>
<span class="codeline" id="line-231"><code>				data.Swap(j, j-1)</code></span>
<span class="codeline" id="line-232"><code>			}</code></span>
<span class="codeline" id="line-233"><code>		}</code></span>
<span class="codeline" id="line-234"><code>	}</code></span>
<span class="codeline" id="line-235"><code>	return false</code></span>
<span class="codeline" id="line-236"><code>}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>// breakPatterns scatters some elements around in an attempt to break some patterns</code></span>
<span class="codeline" id="line-239"><code>// that might cause imbalanced partitions in quicksort.</code></span>
<span class="codeline" id="line-240"><code>func breakPatterns(data Interface, a, b int) {</code></span>
<span class="codeline" id="line-241"><code>	length := b - a</code></span>
<span class="codeline" id="line-242"><code>	if length &gt;= 8 {</code></span>
<span class="codeline" id="line-243"><code>		random := xorshift(length)</code></span>
<span class="codeline" id="line-244"><code>		modulus := nextPowerOfTwo(length)</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>		for idx := a + (length/4)*2 - 1; idx &lt;= a+(length/4)*2+1; idx++ {</code></span>
<span class="codeline" id="line-247"><code>			other := int(uint(random.Next()) &amp; (modulus - 1))</code></span>
<span class="codeline" id="line-248"><code>			if other &gt;= length {</code></span>
<span class="codeline" id="line-249"><code>				other -= length</code></span>
<span class="codeline" id="line-250"><code>			}</code></span>
<span class="codeline" id="line-251"><code>			data.Swap(idx, a+other)</code></span>
<span class="codeline" id="line-252"><code>		}</code></span>
<span class="codeline" id="line-253"><code>	}</code></span>
<span class="codeline" id="line-254"><code>}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// choosePivot chooses a pivot in data[a:b].</code></span>
<span class="codeline" id="line-257"><code>//</code></span>
<span class="codeline" id="line-258"><code>// [0,8): chooses a static pivot.</code></span>
<span class="codeline" id="line-259"><code>// [8,shortestNinther): uses the simple median-of-three method.</code></span>
<span class="codeline" id="line-260"><code>// [shortestNinther,∞): uses the Tukey ninther method.</code></span>
<span class="codeline" id="line-261"><code>func choosePivot(data Interface, a, b int) (pivot int, hint sortedHint) {</code></span>
<span class="codeline" id="line-262"><code>	const (</code></span>
<span class="codeline" id="line-263"><code>		shortestNinther = 50</code></span>
<span class="codeline" id="line-264"><code>		maxSwaps        = 4 * 3</code></span>
<span class="codeline" id="line-265"><code>	)</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>	l := b - a</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>	var (</code></span>
<span class="codeline" id="line-270"><code>		swaps int</code></span>
<span class="codeline" id="line-271"><code>		i     = a + l/4*1</code></span>
<span class="codeline" id="line-272"><code>		j     = a + l/4*2</code></span>
<span class="codeline" id="line-273"><code>		k     = a + l/4*3</code></span>
<span class="codeline" id="line-274"><code>	)</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	if l &gt;= 8 {</code></span>
<span class="codeline" id="line-277"><code>		if l &gt;= shortestNinther {</code></span>
<span class="codeline" id="line-278"><code>			// Tukey ninther method, the idea came from Rust's implementation.</code></span>
<span class="codeline" id="line-279"><code>			i = medianAdjacent(data, i, &amp;swaps)</code></span>
<span class="codeline" id="line-280"><code>			j = medianAdjacent(data, j, &amp;swaps)</code></span>
<span class="codeline" id="line-281"><code>			k = medianAdjacent(data, k, &amp;swaps)</code></span>
<span class="codeline" id="line-282"><code>		}</code></span>
<span class="codeline" id="line-283"><code>		// Find the median among i, j, k and stores it into j.</code></span>
<span class="codeline" id="line-284"><code>		j = median(data, i, j, k, &amp;swaps)</code></span>
<span class="codeline" id="line-285"><code>	}</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	switch swaps {</code></span>
<span class="codeline" id="line-288"><code>	case 0:</code></span>
<span class="codeline" id="line-289"><code>		return j, increasingHint</code></span>
<span class="codeline" id="line-290"><code>	case maxSwaps:</code></span>
<span class="codeline" id="line-291"><code>		return j, decreasingHint</code></span>
<span class="codeline" id="line-292"><code>	default:</code></span>
<span class="codeline" id="line-293"><code>		return j, unknownHint</code></span>
<span class="codeline" id="line-294"><code>	}</code></span>
<span class="codeline" id="line-295"><code>}</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>// order2 returns x,y where data[x] &lt;= data[y], where x,y=a,b or x,y=b,a.</code></span>
<span class="codeline" id="line-298"><code>func order2(data Interface, a, b int, swaps *int) (int, int) {</code></span>
<span class="codeline" id="line-299"><code>	if data.Less(b, a) {</code></span>
<span class="codeline" id="line-300"><code>		*swaps++</code></span>
<span class="codeline" id="line-301"><code>		return b, a</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code>	return a, b</code></span>
<span class="codeline" id="line-304"><code>}</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>// median returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.</code></span>
<span class="codeline" id="line-307"><code>func median(data Interface, a, b, c int, swaps *int) int {</code></span>
<span class="codeline" id="line-308"><code>	a, b = order2(data, a, b, swaps)</code></span>
<span class="codeline" id="line-309"><code>	b, c = order2(data, b, c, swaps)</code></span>
<span class="codeline" id="line-310"><code>	a, b = order2(data, a, b, swaps)</code></span>
<span class="codeline" id="line-311"><code>	return b</code></span>
<span class="codeline" id="line-312"><code>}</code></span>
<span class="codeline" id="line-313"><code></code></span>
<span class="codeline" id="line-314"><code>// medianAdjacent finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.</code></span>
<span class="codeline" id="line-315"><code>func medianAdjacent(data Interface, a int, swaps *int) int {</code></span>
<span class="codeline" id="line-316"><code>	return median(data, a-1, a, a+1, swaps)</code></span>
<span class="codeline" id="line-317"><code>}</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>func reverseRange(data Interface, a, b int) {</code></span>
<span class="codeline" id="line-320"><code>	i := a</code></span>
<span class="codeline" id="line-321"><code>	j := b - 1</code></span>
<span class="codeline" id="line-322"><code>	for i &lt; j {</code></span>
<span class="codeline" id="line-323"><code>		data.Swap(i, j)</code></span>
<span class="codeline" id="line-324"><code>		i++</code></span>
<span class="codeline" id="line-325"><code>		j--</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>func swapRange(data Interface, a, b, n int) {</code></span>
<span class="codeline" id="line-330"><code>	for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-331"><code>		data.Swap(a+i, b+i)</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>func stable(data Interface, n int) {</code></span>
<span class="codeline" id="line-336"><code>	blockSize := 20 // must be &gt; 0</code></span>
<span class="codeline" id="line-337"><code>	a, b := 0, blockSize</code></span>
<span class="codeline" id="line-338"><code>	for b &lt;= n {</code></span>
<span class="codeline" id="line-339"><code>		insertionSort(data, a, b)</code></span>
<span class="codeline" id="line-340"><code>		a = b</code></span>
<span class="codeline" id="line-341"><code>		b += blockSize</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code>	insertionSort(data, a, n)</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>	for blockSize &lt; n {</code></span>
<span class="codeline" id="line-346"><code>		a, b = 0, 2*blockSize</code></span>
<span class="codeline" id="line-347"><code>		for b &lt;= n {</code></span>
<span class="codeline" id="line-348"><code>			symMerge(data, a, a+blockSize, b)</code></span>
<span class="codeline" id="line-349"><code>			a = b</code></span>
<span class="codeline" id="line-350"><code>			b += 2 * blockSize</code></span>
<span class="codeline" id="line-351"><code>		}</code></span>
<span class="codeline" id="line-352"><code>		if m := a + blockSize; m &lt; n {</code></span>
<span class="codeline" id="line-353"><code>			symMerge(data, a, m, n)</code></span>
<span class="codeline" id="line-354"><code>		}</code></span>
<span class="codeline" id="line-355"><code>		blockSize *= 2</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>// symMerge merges the two sorted subsequences data[a:m] and data[m:b] using</code></span>
<span class="codeline" id="line-360"><code>// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum</code></span>
<span class="codeline" id="line-361"><code>// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz</code></span>
<span class="codeline" id="line-362"><code>// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in</code></span>
<span class="codeline" id="line-363"><code>// Computer Science, pages 714-723. Springer, 2004.</code></span>
<span class="codeline" id="line-364"><code>//</code></span>
<span class="codeline" id="line-365"><code>// Let M = m-a and N = b-n. Wolog M &lt; N.</code></span>
<span class="codeline" id="line-366"><code>// The recursion depth is bound by ceil(log(N+M)).</code></span>
<span class="codeline" id="line-367"><code>// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.</code></span>
<span class="codeline" id="line-368"><code>// The algorithm needs O((M+N)*log(M)) calls to data.Swap.</code></span>
<span class="codeline" id="line-369"><code>//</code></span>
<span class="codeline" id="line-370"><code>// The paper gives O((M+N)*log(M)) as the number of assignments assuming a</code></span>
<span class="codeline" id="line-371"><code>// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation</code></span>
<span class="codeline" id="line-372"><code>// in the paper carries through for Swap operations, especially as the block</code></span>
<span class="codeline" id="line-373"><code>// swapping rotate uses only O(M+N) Swaps.</code></span>
<span class="codeline" id="line-374"><code>//</code></span>
<span class="codeline" id="line-375"><code>// symMerge assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.</code></span>
<span class="codeline" id="line-376"><code>// Having the caller check this condition eliminates many leaf recursion calls,</code></span>
<span class="codeline" id="line-377"><code>// which improves performance.</code></span>
<span class="codeline" id="line-378"><code>func symMerge(data Interface, a, m, b int) {</code></span>
<span class="codeline" id="line-379"><code>	// Avoid unnecessary recursions of symMerge</code></span>
<span class="codeline" id="line-380"><code>	// by direct insertion of data[a] into data[m:b]</code></span>
<span class="codeline" id="line-381"><code>	// if data[a:m] only contains one element.</code></span>
<span class="codeline" id="line-382"><code>	if m-a == 1 {</code></span>
<span class="codeline" id="line-383"><code>		// Use binary search to find the lowest index i</code></span>
<span class="codeline" id="line-384"><code>		// such that data[i] &gt;= data[a] for m &lt;= i &lt; b.</code></span>
<span class="codeline" id="line-385"><code>		// Exit the search loop with i == b in case no such index exists.</code></span>
<span class="codeline" id="line-386"><code>		i := m</code></span>
<span class="codeline" id="line-387"><code>		j := b</code></span>
<span class="codeline" id="line-388"><code>		for i &lt; j {</code></span>
<span class="codeline" id="line-389"><code>			h := int(uint(i+j) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-390"><code>			if data.Less(h, a) {</code></span>
<span class="codeline" id="line-391"><code>				i = h + 1</code></span>
<span class="codeline" id="line-392"><code>			} else {</code></span>
<span class="codeline" id="line-393"><code>				j = h</code></span>
<span class="codeline" id="line-394"><code>			}</code></span>
<span class="codeline" id="line-395"><code>		}</code></span>
<span class="codeline" id="line-396"><code>		// Swap values until data[a] reaches the position before i.</code></span>
<span class="codeline" id="line-397"><code>		for k := a; k &lt; i-1; k++ {</code></span>
<span class="codeline" id="line-398"><code>			data.Swap(k, k+1)</code></span>
<span class="codeline" id="line-399"><code>		}</code></span>
<span class="codeline" id="line-400"><code>		return</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>	// Avoid unnecessary recursions of symMerge</code></span>
<span class="codeline" id="line-404"><code>	// by direct insertion of data[m] into data[a:m]</code></span>
<span class="codeline" id="line-405"><code>	// if data[m:b] only contains one element.</code></span>
<span class="codeline" id="line-406"><code>	if b-m == 1 {</code></span>
<span class="codeline" id="line-407"><code>		// Use binary search to find the lowest index i</code></span>
<span class="codeline" id="line-408"><code>		// such that data[i] &gt; data[m] for a &lt;= i &lt; m.</code></span>
<span class="codeline" id="line-409"><code>		// Exit the search loop with i == m in case no such index exists.</code></span>
<span class="codeline" id="line-410"><code>		i := a</code></span>
<span class="codeline" id="line-411"><code>		j := m</code></span>
<span class="codeline" id="line-412"><code>		for i &lt; j {</code></span>
<span class="codeline" id="line-413"><code>			h := int(uint(i+j) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-414"><code>			if !data.Less(m, h) {</code></span>
<span class="codeline" id="line-415"><code>				i = h + 1</code></span>
<span class="codeline" id="line-416"><code>			} else {</code></span>
<span class="codeline" id="line-417"><code>				j = h</code></span>
<span class="codeline" id="line-418"><code>			}</code></span>
<span class="codeline" id="line-419"><code>		}</code></span>
<span class="codeline" id="line-420"><code>		// Swap values until data[m] reaches the position i.</code></span>
<span class="codeline" id="line-421"><code>		for k := m; k &gt; i; k-- {</code></span>
<span class="codeline" id="line-422"><code>			data.Swap(k, k-1)</code></span>
<span class="codeline" id="line-423"><code>		}</code></span>
<span class="codeline" id="line-424"><code>		return</code></span>
<span class="codeline" id="line-425"><code>	}</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>	mid := int(uint(a+b) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-428"><code>	n := mid + m</code></span>
<span class="codeline" id="line-429"><code>	var start, r int</code></span>
<span class="codeline" id="line-430"><code>	if m &gt; mid {</code></span>
<span class="codeline" id="line-431"><code>		start = n - b</code></span>
<span class="codeline" id="line-432"><code>		r = mid</code></span>
<span class="codeline" id="line-433"><code>	} else {</code></span>
<span class="codeline" id="line-434"><code>		start = a</code></span>
<span class="codeline" id="line-435"><code>		r = m</code></span>
<span class="codeline" id="line-436"><code>	}</code></span>
<span class="codeline" id="line-437"><code>	p := n - 1</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>	for start &lt; r {</code></span>
<span class="codeline" id="line-440"><code>		c := int(uint(start+r) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-441"><code>		if !data.Less(p-c, c) {</code></span>
<span class="codeline" id="line-442"><code>			start = c + 1</code></span>
<span class="codeline" id="line-443"><code>		} else {</code></span>
<span class="codeline" id="line-444"><code>			r = c</code></span>
<span class="codeline" id="line-445"><code>		}</code></span>
<span class="codeline" id="line-446"><code>	}</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>	end := n - start</code></span>
<span class="codeline" id="line-449"><code>	if start &lt; m &amp;&amp; m &lt; end {</code></span>
<span class="codeline" id="line-450"><code>		rotate(data, start, m, end)</code></span>
<span class="codeline" id="line-451"><code>	}</code></span>
<span class="codeline" id="line-452"><code>	if a &lt; start &amp;&amp; start &lt; mid {</code></span>
<span class="codeline" id="line-453"><code>		symMerge(data, a, start, mid)</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	if mid &lt; end &amp;&amp; end &lt; b {</code></span>
<span class="codeline" id="line-456"><code>		symMerge(data, mid, end, b)</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code>}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>// rotate rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:</code></span>
<span class="codeline" id="line-461"><code>// Data of the form 'x u v y' is changed to 'x v u y'.</code></span>
<span class="codeline" id="line-462"><code>// rotate performs at most b-a many calls to data.Swap,</code></span>
<span class="codeline" id="line-463"><code>// and it assumes non-degenerate arguments: a &lt; m &amp;&amp; m &lt; b.</code></span>
<span class="codeline" id="line-464"><code>func rotate(data Interface, a, m, b int) {</code></span>
<span class="codeline" id="line-465"><code>	i := m - a</code></span>
<span class="codeline" id="line-466"><code>	j := b - m</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>	for i != j {</code></span>
<span class="codeline" id="line-469"><code>		if i &gt; j {</code></span>
<span class="codeline" id="line-470"><code>			swapRange(data, m-i, m, j)</code></span>
<span class="codeline" id="line-471"><code>			i -= j</code></span>
<span class="codeline" id="line-472"><code>		} else {</code></span>
<span class="codeline" id="line-473"><code>			swapRange(data, m-i, m+j-i, i)</code></span>
<span class="codeline" id="line-474"><code>			j -= i</code></span>
<span class="codeline" id="line-475"><code>		}</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code>	// i == j</code></span>
<span class="codeline" id="line-478"><code>	swapRange(data, m-i, m, i)</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>