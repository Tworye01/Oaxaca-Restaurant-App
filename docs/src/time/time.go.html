<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: time.go in package time</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	time.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/time.html">time</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package time provides functionality for measuring and displaying time.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The calendrical calculations always assume a Gregorian calendar, with</code></span>
<span class="codeline" id="line-8"><code>// no leap seconds.</code></span>
<span class="codeline" id="line-9"><code>//</code></span>
<span class="codeline" id="line-10"><code>// # Monotonic Clocks</code></span>
<span class="codeline" id="line-11"><code>//</code></span>
<span class="codeline" id="line-12"><code>// Operating systems provide both a “wall clock,” which is subject to</code></span>
<span class="codeline" id="line-13"><code>// changes for clock synchronization, and a “monotonic clock,” which is</code></span>
<span class="codeline" id="line-14"><code>// not. The general rule is that the wall clock is for telling time and</code></span>
<span class="codeline" id="line-15"><code>// the monotonic clock is for measuring time. Rather than split the API,</code></span>
<span class="codeline" id="line-16"><code>// in this package the Time returned by time.Now contains both a wall</code></span>
<span class="codeline" id="line-17"><code>// clock reading and a monotonic clock reading; later time-telling</code></span>
<span class="codeline" id="line-18"><code>// operations use the wall clock reading, but later time-measuring</code></span>
<span class="codeline" id="line-19"><code>// operations, specifically comparisons and subtractions, use the</code></span>
<span class="codeline" id="line-20"><code>// monotonic clock reading.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// For example, this code always computes a positive elapsed time of</code></span>
<span class="codeline" id="line-23"><code>// approximately 20 milliseconds, even if the wall clock is changed during</code></span>
<span class="codeline" id="line-24"><code>// the operation being timed:</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>//	start := time.Now()</code></span>
<span class="codeline" id="line-27"><code>//	... operation that takes 20 milliseconds ...</code></span>
<span class="codeline" id="line-28"><code>//	t := time.Now()</code></span>
<span class="codeline" id="line-29"><code>//	elapsed := t.Sub(start)</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// Other idioms, such as time.Since(start), time.Until(deadline), and</code></span>
<span class="codeline" id="line-32"><code>// time.Now().Before(deadline), are similarly robust against wall clock</code></span>
<span class="codeline" id="line-33"><code>// resets.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// The rest of this section gives the precise details of how operations</code></span>
<span class="codeline" id="line-36"><code>// use monotonic clocks, but understanding those details is not required</code></span>
<span class="codeline" id="line-37"><code>// to use this package.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// The Time returned by time.Now contains a monotonic clock reading.</code></span>
<span class="codeline" id="line-40"><code>// If Time t has a monotonic clock reading, t.Add adds the same duration to</code></span>
<span class="codeline" id="line-41"><code>// both the wall clock and monotonic clock readings to compute the result.</code></span>
<span class="codeline" id="line-42"><code>// Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time</code></span>
<span class="codeline" id="line-43"><code>// computations, they always strip any monotonic clock reading from their results.</code></span>
<span class="codeline" id="line-44"><code>// Because t.In, t.Local, and t.UTC are used for their effect on the interpretation</code></span>
<span class="codeline" id="line-45"><code>// of the wall time, they also strip any monotonic clock reading from their results.</code></span>
<span class="codeline" id="line-46"><code>// The canonical way to strip a monotonic clock reading is to use t = t.Round(0).</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// If Times t and u both contain monotonic clock readings, the operations</code></span>
<span class="codeline" id="line-49"><code>// t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out</code></span>
<span class="codeline" id="line-50"><code>// using the monotonic clock readings alone, ignoring the wall clock</code></span>
<span class="codeline" id="line-51"><code>// readings. If either t or u contains no monotonic clock reading, these</code></span>
<span class="codeline" id="line-52"><code>// operations fall back to using the wall clock readings.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// On some systems the monotonic clock will stop if the computer goes to sleep.</code></span>
<span class="codeline" id="line-55"><code>// On such a system, t.Sub(u) may not accurately reflect the actual</code></span>
<span class="codeline" id="line-56"><code>// time that passed between t and u.</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// Because the monotonic clock reading has no meaning outside</code></span>
<span class="codeline" id="line-59"><code>// the current process, the serialized forms generated by t.GobEncode,</code></span>
<span class="codeline" id="line-60"><code>// t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic</code></span>
<span class="codeline" id="line-61"><code>// clock reading, and t.Format provides no format for it. Similarly, the</code></span>
<span class="codeline" id="line-62"><code>// constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,</code></span>
<span class="codeline" id="line-63"><code>// as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.</code></span>
<span class="codeline" id="line-64"><code>// t.UnmarshalJSON, and t.UnmarshalText always create times with</code></span>
<span class="codeline" id="line-65"><code>// no monotonic clock reading.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// The monotonic clock reading exists only in Time values. It is not</code></span>
<span class="codeline" id="line-68"><code>// a part of Duration values or the Unix times returned by t.Unix and</code></span>
<span class="codeline" id="line-69"><code>// friends.</code></span>
<span class="codeline" id="line-70"><code>//</code></span>
<span class="codeline" id="line-71"><code>// Note that the Go == operator compares not just the time instant but</code></span>
<span class="codeline" id="line-72"><code>// also the Location and the monotonic clock reading. See the</code></span>
<span class="codeline" id="line-73"><code>// documentation for the Time type for a discussion of equality</code></span>
<span class="codeline" id="line-74"><code>// testing for Time values.</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>// For debugging, the result of t.String does include the monotonic</code></span>
<span class="codeline" id="line-77"><code>// clock reading if present. If t != u because of different monotonic clock readings,</code></span>
<span class="codeline" id="line-78"><code>// that difference will be visible when printing t.String() and u.String().</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>// # Timer Resolution</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// Timer resolution varies depending on the Go runtime, the operating system</code></span>
<span class="codeline" id="line-83"><code>// and the underlying hardware.</code></span>
<span class="codeline" id="line-84"><code>// On Unix, the resolution is approximately 1ms.</code></span>
<span class="codeline" id="line-85"><code>// On Windows, the default resolution is approximately 16ms, but</code></span>
<span class="codeline" id="line-86"><code>// a higher resolution may be requested using [golang.org/x/sys/windows.TimeBeginPeriod].</code></span></div><span class="codeline" id="line-87"><code>package time</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>import (</code></span>
<span class="codeline" id="line-90"><code>	"errors"</code></span>
<span class="codeline" id="line-91"><code>	_ "unsafe" // for go:linkname</code></span>
<span class="codeline" id="line-92"><code>)</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>// A Time represents an instant in time with nanosecond precision.</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// Programs using times should typically store and pass them as values,</code></span>
<span class="codeline" id="line-97"><code>// not pointers. That is, time variables and struct fields should be of</code></span>
<span class="codeline" id="line-98"><code>// type time.Time, not *time.Time.</code></span>
<span class="codeline" id="line-99"><code>//</code></span>
<span class="codeline" id="line-100"><code>// A Time value can be used by multiple goroutines simultaneously except</code></span>
<span class="codeline" id="line-101"><code>// that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and</code></span>
<span class="codeline" id="line-102"><code>// UnmarshalText are not concurrency-safe.</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>// Time instants can be compared using the Before, After, and Equal methods.</code></span>
<span class="codeline" id="line-105"><code>// The Sub method subtracts two instants, producing a Duration.</code></span>
<span class="codeline" id="line-106"><code>// The Add method adds a Time and a Duration, producing a Time.</code></span>
<span class="codeline" id="line-107"><code>//</code></span>
<span class="codeline" id="line-108"><code>// The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.</code></span>
<span class="codeline" id="line-109"><code>// As this time is unlikely to come up in practice, the IsZero method gives</code></span>
<span class="codeline" id="line-110"><code>// a simple way of detecting a time that has not been initialized explicitly.</code></span>
<span class="codeline" id="line-111"><code>//</code></span>
<span class="codeline" id="line-112"><code>// Each time has an associated Location. The methods Local, UTC, and In return a</code></span>
<span class="codeline" id="line-113"><code>// Time with a specific Location. Changing the Location of a Time value with</code></span>
<span class="codeline" id="line-114"><code>// these methods does not change the actual instant it represents, only the time</code></span>
<span class="codeline" id="line-115"><code>// zone in which to interpret it.</code></span>
<span class="codeline" id="line-116"><code>//</code></span>
<span class="codeline" id="line-117"><code>// Representations of a Time value saved by the GobEncode, MarshalBinary,</code></span>
<span class="codeline" id="line-118"><code>// MarshalJSON, and MarshalText methods store the Time.Location's offset, but not</code></span>
<span class="codeline" id="line-119"><code>// the location name. They therefore lose information about Daylight Saving Time.</code></span>
<span class="codeline" id="line-120"><code>//</code></span>
<span class="codeline" id="line-121"><code>// In addition to the required “wall clock” reading, a Time may contain an optional</code></span>
<span class="codeline" id="line-122"><code>// reading of the current process's monotonic clock, to provide additional precision</code></span>
<span class="codeline" id="line-123"><code>// for comparison or subtraction.</code></span>
<span class="codeline" id="line-124"><code>// See the “Monotonic Clocks” section in the package documentation for details.</code></span>
<span class="codeline" id="line-125"><code>//</code></span>
<span class="codeline" id="line-126"><code>// Note that the Go == operator compares not just the time instant but also the</code></span>
<span class="codeline" id="line-127"><code>// Location and the monotonic clock reading. Therefore, Time values should not</code></span>
<span class="codeline" id="line-128"><code>// be used as map or database keys without first guaranteeing that the</code></span>
<span class="codeline" id="line-129"><code>// identical Location has been set for all values, which can be achieved</code></span>
<span class="codeline" id="line-130"><code>// through use of the UTC or Local method, and that the monotonic clock reading</code></span>
<span class="codeline" id="line-131"><code>// has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)</code></span>
<span class="codeline" id="line-132"><code>// to t == u, since t.Equal uses the most accurate comparison available and</code></span>
<span class="codeline" id="line-133"><code>// correctly handles the case when only one of its arguments has a monotonic</code></span>
<span class="codeline" id="line-134"><code>// clock reading.</code></span>
<span class="codeline" id="line-135"><code>type Time struct {</code></span>
<span class="codeline" id="line-136"><code>	// wall and ext encode the wall time seconds, wall time nanoseconds,</code></span>
<span class="codeline" id="line-137"><code>	// and optional monotonic clock reading in nanoseconds.</code></span>
<span class="codeline" id="line-138"><code>	//</code></span>
<span class="codeline" id="line-139"><code>	// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),</code></span>
<span class="codeline" id="line-140"><code>	// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.</code></span>
<span class="codeline" id="line-141"><code>	// The nanoseconds field is in the range [0, 999999999].</code></span>
<span class="codeline" id="line-142"><code>	// If the hasMonotonic bit is 0, then the 33-bit field must be zero</code></span>
<span class="codeline" id="line-143"><code>	// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.</code></span>
<span class="codeline" id="line-144"><code>	// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit</code></span>
<span class="codeline" id="line-145"><code>	// unsigned wall seconds since Jan 1 year 1885, and ext holds a</code></span>
<span class="codeline" id="line-146"><code>	// signed 64-bit monotonic clock reading, nanoseconds since process start.</code></span>
<span class="codeline" id="line-147"><code>	wall uint64</code></span>
<span class="codeline" id="line-148"><code>	ext  int64</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	// loc specifies the Location that should be used to</code></span>
<span class="codeline" id="line-151"><code>	// determine the minute, hour, month, day, and year</code></span>
<span class="codeline" id="line-152"><code>	// that correspond to this Time.</code></span>
<span class="codeline" id="line-153"><code>	// The nil location means UTC.</code></span>
<span class="codeline" id="line-154"><code>	// All UTC times are represented with loc==nil, never loc==&amp;utcLoc.</code></span>
<span class="codeline" id="line-155"><code>	loc *Location</code></span>
<span class="codeline" id="line-156"><code>}</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>const (</code></span>
<span class="codeline" id="line-159"><code>	hasMonotonic = 1 &lt;&lt; 63</code></span>
<span class="codeline" id="line-160"><code>	maxWall      = wallToInternal + (1&lt;&lt;33 - 1) // year 2157</code></span>
<span class="codeline" id="line-161"><code>	minWall      = wallToInternal               // year 1885</code></span>
<span class="codeline" id="line-162"><code>	nsecMask     = 1&lt;&lt;30 - 1</code></span>
<span class="codeline" id="line-163"><code>	nsecShift    = 30</code></span>
<span class="codeline" id="line-164"><code>)</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>// These helpers for manipulating the wall and monotonic clock readings</code></span>
<span class="codeline" id="line-167"><code>// take pointer receivers, even when they don't modify the time,</code></span>
<span class="codeline" id="line-168"><code>// to make them cheaper to call.</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>// nsec returns the time's nanoseconds.</code></span>
<span class="codeline" id="line-171"><code>func (t *Time) nsec() int32 {</code></span>
<span class="codeline" id="line-172"><code>	return int32(t.wall &amp; nsecMask)</code></span>
<span class="codeline" id="line-173"><code>}</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>// sec returns the time's seconds since Jan 1 year 1.</code></span>
<span class="codeline" id="line-176"><code>func (t *Time) sec() int64 {</code></span>
<span class="codeline" id="line-177"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-178"><code>		return wallToInternal + int64(t.wall&lt;&lt;1&gt;&gt;(nsecShift+1))</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>	return t.ext</code></span>
<span class="codeline" id="line-181"><code>}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>// unixSec returns the time's seconds since Jan 1 1970 (Unix time).</code></span>
<span class="codeline" id="line-184"><code>func (t *Time) unixSec() int64 { return t.sec() + internalToUnix }</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>// addSec adds d seconds to the time.</code></span>
<span class="codeline" id="line-187"><code>func (t *Time) addSec(d int64) {</code></span>
<span class="codeline" id="line-188"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-189"><code>		sec := int64(t.wall &lt;&lt; 1 &gt;&gt; (nsecShift + 1))</code></span>
<span class="codeline" id="line-190"><code>		dsec := sec + d</code></span>
<span class="codeline" id="line-191"><code>		if 0 &lt;= dsec &amp;&amp; dsec &lt;= 1&lt;&lt;33-1 {</code></span>
<span class="codeline" id="line-192"><code>			t.wall = t.wall&amp;nsecMask | uint64(dsec)&lt;&lt;nsecShift | hasMonotonic</code></span>
<span class="codeline" id="line-193"><code>			return</code></span>
<span class="codeline" id="line-194"><code>		}</code></span>
<span class="codeline" id="line-195"><code>		// Wall second now out of range for packed field.</code></span>
<span class="codeline" id="line-196"><code>		// Move to ext.</code></span>
<span class="codeline" id="line-197"><code>		t.stripMono()</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>	// Check if the sum of t.ext and d overflows and handle it properly.</code></span>
<span class="codeline" id="line-201"><code>	sum := t.ext + d</code></span>
<span class="codeline" id="line-202"><code>	if (sum &gt; t.ext) == (d &gt; 0) {</code></span>
<span class="codeline" id="line-203"><code>		t.ext = sum</code></span>
<span class="codeline" id="line-204"><code>	} else if d &gt; 0 {</code></span>
<span class="codeline" id="line-205"><code>		t.ext = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-206"><code>	} else {</code></span>
<span class="codeline" id="line-207"><code>		t.ext = -(1&lt;&lt;63 - 1)</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>// setLoc sets the location associated with the time.</code></span>
<span class="codeline" id="line-212"><code>func (t *Time) setLoc(loc *Location) {</code></span>
<span class="codeline" id="line-213"><code>	if loc == &amp;utcLoc {</code></span>
<span class="codeline" id="line-214"><code>		loc = nil</code></span>
<span class="codeline" id="line-215"><code>	}</code></span>
<span class="codeline" id="line-216"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-217"><code>	t.loc = loc</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// stripMono strips the monotonic clock reading in t.</code></span>
<span class="codeline" id="line-221"><code>func (t *Time) stripMono() {</code></span>
<span class="codeline" id="line-222"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-223"><code>		t.ext = t.sec()</code></span>
<span class="codeline" id="line-224"><code>		t.wall &amp;= nsecMask</code></span>
<span class="codeline" id="line-225"><code>	}</code></span>
<span class="codeline" id="line-226"><code>}</code></span>
<span class="codeline" id="line-227"><code></code></span>
<span class="codeline" id="line-228"><code>// setMono sets the monotonic clock reading in t.</code></span>
<span class="codeline" id="line-229"><code>// If t cannot hold a monotonic clock reading,</code></span>
<span class="codeline" id="line-230"><code>// because its wall time is too large,</code></span>
<span class="codeline" id="line-231"><code>// setMono is a no-op.</code></span>
<span class="codeline" id="line-232"><code>func (t *Time) setMono(m int64) {</code></span>
<span class="codeline" id="line-233"><code>	if t.wall&amp;hasMonotonic == 0 {</code></span>
<span class="codeline" id="line-234"><code>		sec := t.ext</code></span>
<span class="codeline" id="line-235"><code>		if sec &lt; minWall || maxWall &lt; sec {</code></span>
<span class="codeline" id="line-236"><code>			return</code></span>
<span class="codeline" id="line-237"><code>		}</code></span>
<span class="codeline" id="line-238"><code>		t.wall |= hasMonotonic | uint64(sec-minWall)&lt;&lt;nsecShift</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code>	t.ext = m</code></span>
<span class="codeline" id="line-241"><code>}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>// mono returns t's monotonic clock reading.</code></span>
<span class="codeline" id="line-244"><code>// It returns 0 for a missing reading.</code></span>
<span class="codeline" id="line-245"><code>// This function is used only for testing,</code></span>
<span class="codeline" id="line-246"><code>// so it's OK that technically 0 is a valid</code></span>
<span class="codeline" id="line-247"><code>// monotonic clock reading as well.</code></span>
<span class="codeline" id="line-248"><code>func (t *Time) mono() int64 {</code></span>
<span class="codeline" id="line-249"><code>	if t.wall&amp;hasMonotonic == 0 {</code></span>
<span class="codeline" id="line-250"><code>		return 0</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code>	return t.ext</code></span>
<span class="codeline" id="line-253"><code>}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>// After reports whether the time instant t is after u.</code></span>
<span class="codeline" id="line-256"><code>func (t Time) After(u Time) bool {</code></span>
<span class="codeline" id="line-257"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-258"><code>		return t.ext &gt; u.ext</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	ts := t.sec()</code></span>
<span class="codeline" id="line-261"><code>	us := u.sec()</code></span>
<span class="codeline" id="line-262"><code>	return ts &gt; us || ts == us &amp;&amp; t.nsec() &gt; u.nsec()</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// Before reports whether the time instant t is before u.</code></span>
<span class="codeline" id="line-266"><code>func (t Time) Before(u Time) bool {</code></span>
<span class="codeline" id="line-267"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-268"><code>		return t.ext &lt; u.ext</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	ts := t.sec()</code></span>
<span class="codeline" id="line-271"><code>	us := u.sec()</code></span>
<span class="codeline" id="line-272"><code>	return ts &lt; us || ts == us &amp;&amp; t.nsec() &lt; u.nsec()</code></span>
<span class="codeline" id="line-273"><code>}</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>// Compare compares the time instant t with u. If t is before u, it returns -1;</code></span>
<span class="codeline" id="line-276"><code>// if t is after u, it returns +1; if they're the same, it returns 0.</code></span>
<span class="codeline" id="line-277"><code>func (t Time) Compare(u Time) int {</code></span>
<span class="codeline" id="line-278"><code>	var tc, uc int64</code></span>
<span class="codeline" id="line-279"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-280"><code>		tc, uc = t.ext, u.ext</code></span>
<span class="codeline" id="line-281"><code>	} else {</code></span>
<span class="codeline" id="line-282"><code>		tc, uc = t.sec(), u.sec()</code></span>
<span class="codeline" id="line-283"><code>		if tc == uc {</code></span>
<span class="codeline" id="line-284"><code>			tc, uc = int64(t.nsec()), int64(u.nsec())</code></span>
<span class="codeline" id="line-285"><code>		}</code></span>
<span class="codeline" id="line-286"><code>	}</code></span>
<span class="codeline" id="line-287"><code>	switch {</code></span>
<span class="codeline" id="line-288"><code>	case tc &lt; uc:</code></span>
<span class="codeline" id="line-289"><code>		return -1</code></span>
<span class="codeline" id="line-290"><code>	case tc &gt; uc:</code></span>
<span class="codeline" id="line-291"><code>		return +1</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	return 0</code></span>
<span class="codeline" id="line-294"><code>}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>// Equal reports whether t and u represent the same time instant.</code></span>
<span class="codeline" id="line-297"><code>// Two times can be equal even if they are in different locations.</code></span>
<span class="codeline" id="line-298"><code>// For example, 6:00 +0200 and 4:00 UTC are Equal.</code></span>
<span class="codeline" id="line-299"><code>// See the documentation on the Time type for the pitfalls of using == with</code></span>
<span class="codeline" id="line-300"><code>// Time values; most code should use Equal instead.</code></span>
<span class="codeline" id="line-301"><code>func (t Time) Equal(u Time) bool {</code></span>
<span class="codeline" id="line-302"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-303"><code>		return t.ext == u.ext</code></span>
<span class="codeline" id="line-304"><code>	}</code></span>
<span class="codeline" id="line-305"><code>	return t.sec() == u.sec() &amp;&amp; t.nsec() == u.nsec()</code></span>
<span class="codeline" id="line-306"><code>}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>// A Month specifies a month of the year (January = 1, ...).</code></span>
<span class="codeline" id="line-309"><code>type Month int</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>const (</code></span>
<span class="codeline" id="line-312"><code>	January Month = 1 + iota</code></span>
<span class="codeline" id="line-313"><code>	February</code></span>
<span class="codeline" id="line-314"><code>	March</code></span>
<span class="codeline" id="line-315"><code>	April</code></span>
<span class="codeline" id="line-316"><code>	May</code></span>
<span class="codeline" id="line-317"><code>	June</code></span>
<span class="codeline" id="line-318"><code>	July</code></span>
<span class="codeline" id="line-319"><code>	August</code></span>
<span class="codeline" id="line-320"><code>	September</code></span>
<span class="codeline" id="line-321"><code>	October</code></span>
<span class="codeline" id="line-322"><code>	November</code></span>
<span class="codeline" id="line-323"><code>	December</code></span>
<span class="codeline" id="line-324"><code>)</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>// String returns the English name of the month ("January", "February", ...).</code></span>
<span class="codeline" id="line-327"><code>func (m Month) String() string {</code></span>
<span class="codeline" id="line-328"><code>	if January &lt;= m &amp;&amp; m &lt;= December {</code></span>
<span class="codeline" id="line-329"><code>		return longMonthNames[m-1]</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	buf := make([]byte, 20)</code></span>
<span class="codeline" id="line-332"><code>	n := fmtInt(buf, uint64(m))</code></span>
<span class="codeline" id="line-333"><code>	return "%!Month(" + string(buf[n:]) + ")"</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// A Weekday specifies a day of the week (Sunday = 0, ...).</code></span>
<span class="codeline" id="line-337"><code>type Weekday int</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>const (</code></span>
<span class="codeline" id="line-340"><code>	Sunday Weekday = iota</code></span>
<span class="codeline" id="line-341"><code>	Monday</code></span>
<span class="codeline" id="line-342"><code>	Tuesday</code></span>
<span class="codeline" id="line-343"><code>	Wednesday</code></span>
<span class="codeline" id="line-344"><code>	Thursday</code></span>
<span class="codeline" id="line-345"><code>	Friday</code></span>
<span class="codeline" id="line-346"><code>	Saturday</code></span>
<span class="codeline" id="line-347"><code>)</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>// String returns the English name of the day ("Sunday", "Monday", ...).</code></span>
<span class="codeline" id="line-350"><code>func (d Weekday) String() string {</code></span>
<span class="codeline" id="line-351"><code>	if Sunday &lt;= d &amp;&amp; d &lt;= Saturday {</code></span>
<span class="codeline" id="line-352"><code>		return longDayNames[d]</code></span>
<span class="codeline" id="line-353"><code>	}</code></span>
<span class="codeline" id="line-354"><code>	buf := make([]byte, 20)</code></span>
<span class="codeline" id="line-355"><code>	n := fmtInt(buf, uint64(d))</code></span>
<span class="codeline" id="line-356"><code>	return "%!Weekday(" + string(buf[n:]) + ")"</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>// Computations on time.</code></span>
<span class="codeline" id="line-360"><code>//</code></span>
<span class="codeline" id="line-361"><code>// The zero value for a Time is defined to be</code></span>
<span class="codeline" id="line-362"><code>//	January 1, year 1, 00:00:00.000000000 UTC</code></span>
<span class="codeline" id="line-363"><code>// which (1) looks like a zero, or as close as you can get in a date</code></span>
<span class="codeline" id="line-364"><code>// (1-1-1 00:00:00 UTC), (2) is unlikely enough to arise in practice to</code></span>
<span class="codeline" id="line-365"><code>// be a suitable "not set" sentinel, unlike Jan 1 1970, and (3) has a</code></span>
<span class="codeline" id="line-366"><code>// non-negative year even in time zones west of UTC, unlike 1-1-0</code></span>
<span class="codeline" id="line-367"><code>// 00:00:00 UTC, which would be 12-31-(-1) 19:00:00 in New York.</code></span>
<span class="codeline" id="line-368"><code>//</code></span>
<span class="codeline" id="line-369"><code>// The zero Time value does not force a specific epoch for the time</code></span>
<span class="codeline" id="line-370"><code>// representation. For example, to use the Unix epoch internally, we</code></span>
<span class="codeline" id="line-371"><code>// could define that to distinguish a zero value from Jan 1 1970, that</code></span>
<span class="codeline" id="line-372"><code>// time would be represented by sec=-1, nsec=1e9. However, it does</code></span>
<span class="codeline" id="line-373"><code>// suggest a representation, namely using 1-1-1 00:00:00 UTC as the</code></span>
<span class="codeline" id="line-374"><code>// epoch, and that's what we do.</code></span>
<span class="codeline" id="line-375"><code>//</code></span>
<span class="codeline" id="line-376"><code>// The Add and Sub computations are oblivious to the choice of epoch.</code></span>
<span class="codeline" id="line-377"><code>//</code></span>
<span class="codeline" id="line-378"><code>// The presentation computations - year, month, minute, and so on - all</code></span>
<span class="codeline" id="line-379"><code>// rely heavily on division and modulus by positive constants. For</code></span>
<span class="codeline" id="line-380"><code>// calendrical calculations we want these divisions to round down, even</code></span>
<span class="codeline" id="line-381"><code>// for negative values, so that the remainder is always positive, but</code></span>
<span class="codeline" id="line-382"><code>// Go's division (like most hardware division instructions) rounds to</code></span>
<span class="codeline" id="line-383"><code>// zero. We can still do those computations and then adjust the result</code></span>
<span class="codeline" id="line-384"><code>// for a negative numerator, but it's annoying to write the adjustment</code></span>
<span class="codeline" id="line-385"><code>// over and over. Instead, we can change to a different epoch so long</code></span>
<span class="codeline" id="line-386"><code>// ago that all the times we care about will be positive, and then round</code></span>
<span class="codeline" id="line-387"><code>// to zero and round down coincide. These presentation routines already</code></span>
<span class="codeline" id="line-388"><code>// have to add the zone offset, so adding the translation to the</code></span>
<span class="codeline" id="line-389"><code>// alternate epoch is cheap. For example, having a non-negative time t</code></span>
<span class="codeline" id="line-390"><code>// means that we can write</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>//	sec = t % 60</code></span>
<span class="codeline" id="line-393"><code>//</code></span>
<span class="codeline" id="line-394"><code>// instead of</code></span>
<span class="codeline" id="line-395"><code>//</code></span>
<span class="codeline" id="line-396"><code>//	sec = t % 60</code></span>
<span class="codeline" id="line-397"><code>//	if sec &lt; 0 {</code></span>
<span class="codeline" id="line-398"><code>//		sec += 60</code></span>
<span class="codeline" id="line-399"><code>//	}</code></span>
<span class="codeline" id="line-400"><code>//</code></span>
<span class="codeline" id="line-401"><code>// everywhere.</code></span>
<span class="codeline" id="line-402"><code>//</code></span>
<span class="codeline" id="line-403"><code>// The calendar runs on an exact 400 year cycle: a 400-year calendar</code></span>
<span class="codeline" id="line-404"><code>// printed for 1970-2369 will apply as well to 2370-2769. Even the days</code></span>
<span class="codeline" id="line-405"><code>// of the week match up. It simplifies the computations to choose the</code></span>
<span class="codeline" id="line-406"><code>// cycle boundaries so that the exceptional years are always delayed as</code></span>
<span class="codeline" id="line-407"><code>// long as possible. That means choosing a year equal to 1 mod 400, so</code></span>
<span class="codeline" id="line-408"><code>// that the first leap year is the 4th year, the first missed leap year</code></span>
<span class="codeline" id="line-409"><code>// is the 100th year, and the missed missed leap year is the 400th year.</code></span>
<span class="codeline" id="line-410"><code>// So we'd prefer instead to print a calendar for 2001-2400 and reuse it</code></span>
<span class="codeline" id="line-411"><code>// for 2401-2800.</code></span>
<span class="codeline" id="line-412"><code>//</code></span>
<span class="codeline" id="line-413"><code>// Finally, it's convenient if the delta between the Unix epoch and</code></span>
<span class="codeline" id="line-414"><code>// long-ago epoch is representable by an int64 constant.</code></span>
<span class="codeline" id="line-415"><code>//</code></span>
<span class="codeline" id="line-416"><code>// These three considerations—choose an epoch as early as possible, that</code></span>
<span class="codeline" id="line-417"><code>// uses a year equal to 1 mod 400, and that is no more than 2⁶³ seconds</code></span>
<span class="codeline" id="line-418"><code>// earlier than 1970—bring us to the year -292277022399. We refer to</code></span>
<span class="codeline" id="line-419"><code>// this year as the absolute zero year, and to times measured as a uint64</code></span>
<span class="codeline" id="line-420"><code>// seconds since this year as absolute times.</code></span>
<span class="codeline" id="line-421"><code>//</code></span>
<span class="codeline" id="line-422"><code>// Times measured as an int64 seconds since the year 1—the representation</code></span>
<span class="codeline" id="line-423"><code>// used for Time's sec field—are called internal times.</code></span>
<span class="codeline" id="line-424"><code>//</code></span>
<span class="codeline" id="line-425"><code>// Times measured as an int64 seconds since the year 1970 are called Unix</code></span>
<span class="codeline" id="line-426"><code>// times.</code></span>
<span class="codeline" id="line-427"><code>//</code></span>
<span class="codeline" id="line-428"><code>// It is tempting to just use the year 1 as the absolute epoch, defining</code></span>
<span class="codeline" id="line-429"><code>// that the routines are only valid for years &gt;= 1. However, the</code></span>
<span class="codeline" id="line-430"><code>// routines would then be invalid when displaying the epoch in time zones</code></span>
<span class="codeline" id="line-431"><code>// west of UTC, since it is year 0. It doesn't seem tenable to say that</code></span>
<span class="codeline" id="line-432"><code>// printing the zero time correctly isn't supported in half the time</code></span>
<span class="codeline" id="line-433"><code>// zones. By comparison, it's reasonable to mishandle some times in</code></span>
<span class="codeline" id="line-434"><code>// the year -292277022399.</code></span>
<span class="codeline" id="line-435"><code>//</code></span>
<span class="codeline" id="line-436"><code>// All this is opaque to clients of the API and can be changed if a</code></span>
<span class="codeline" id="line-437"><code>// better implementation presents itself.</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>const (</code></span>
<span class="codeline" id="line-440"><code>	// The unsigned zero year for internal calculations.</code></span>
<span class="codeline" id="line-441"><code>	// Must be 1 mod 400, and times before it will not compute correctly,</code></span>
<span class="codeline" id="line-442"><code>	// but otherwise can be changed at will.</code></span>
<span class="codeline" id="line-443"><code>	absoluteZeroYear = -292277022399</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>	// The year of the zero Time.</code></span>
<span class="codeline" id="line-446"><code>	// Assumed by the unixToInternal computation below.</code></span>
<span class="codeline" id="line-447"><code>	internalYear = 1</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>	// Offsets to convert between internal and absolute or Unix times.</code></span>
<span class="codeline" id="line-450"><code>	absoluteToInternal int64 = (absoluteZeroYear - internalYear) * 365.2425 * secondsPerDay</code></span>
<span class="codeline" id="line-451"><code>	internalToAbsolute       = -absoluteToInternal</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>	unixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay</code></span>
<span class="codeline" id="line-454"><code>	internalToUnix int64 = -unixToInternal</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	wallToInternal int64 = (1884*365 + 1884/4 - 1884/100 + 1884/400) * secondsPerDay</code></span>
<span class="codeline" id="line-457"><code>)</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>// IsZero reports whether t represents the zero time instant,</code></span>
<span class="codeline" id="line-460"><code>// January 1, year 1, 00:00:00 UTC.</code></span>
<span class="codeline" id="line-461"><code>func (t Time) IsZero() bool {</code></span>
<span class="codeline" id="line-462"><code>	return t.sec() == 0 &amp;&amp; t.nsec() == 0</code></span>
<span class="codeline" id="line-463"><code>}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>// abs returns the time t as an absolute time, adjusted by the zone offset.</code></span>
<span class="codeline" id="line-466"><code>// It is called when computing a presentation property like Month or Hour.</code></span>
<span class="codeline" id="line-467"><code>func (t Time) abs() uint64 {</code></span>
<span class="codeline" id="line-468"><code>	l := t.loc</code></span>
<span class="codeline" id="line-469"><code>	// Avoid function calls when possible.</code></span>
<span class="codeline" id="line-470"><code>	if l == nil || l == &amp;localLoc {</code></span>
<span class="codeline" id="line-471"><code>		l = l.get()</code></span>
<span class="codeline" id="line-472"><code>	}</code></span>
<span class="codeline" id="line-473"><code>	sec := t.unixSec()</code></span>
<span class="codeline" id="line-474"><code>	if l != &amp;utcLoc {</code></span>
<span class="codeline" id="line-475"><code>		if l.cacheZone != nil &amp;&amp; l.cacheStart &lt;= sec &amp;&amp; sec &lt; l.cacheEnd {</code></span>
<span class="codeline" id="line-476"><code>			sec += int64(l.cacheZone.offset)</code></span>
<span class="codeline" id="line-477"><code>		} else {</code></span>
<span class="codeline" id="line-478"><code>			_, offset, _, _, _ := l.lookup(sec)</code></span>
<span class="codeline" id="line-479"><code>			sec += int64(offset)</code></span>
<span class="codeline" id="line-480"><code>		}</code></span>
<span class="codeline" id="line-481"><code>	}</code></span>
<span class="codeline" id="line-482"><code>	return uint64(sec + (unixToInternal + internalToAbsolute))</code></span>
<span class="codeline" id="line-483"><code>}</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>// locabs is a combination of the Zone and abs methods,</code></span>
<span class="codeline" id="line-486"><code>// extracting both return values from a single zone lookup.</code></span>
<span class="codeline" id="line-487"><code>func (t Time) locabs() (name string, offset int, abs uint64) {</code></span>
<span class="codeline" id="line-488"><code>	l := t.loc</code></span>
<span class="codeline" id="line-489"><code>	if l == nil || l == &amp;localLoc {</code></span>
<span class="codeline" id="line-490"><code>		l = l.get()</code></span>
<span class="codeline" id="line-491"><code>	}</code></span>
<span class="codeline" id="line-492"><code>	// Avoid function call if we hit the local time cache.</code></span>
<span class="codeline" id="line-493"><code>	sec := t.unixSec()</code></span>
<span class="codeline" id="line-494"><code>	if l != &amp;utcLoc {</code></span>
<span class="codeline" id="line-495"><code>		if l.cacheZone != nil &amp;&amp; l.cacheStart &lt;= sec &amp;&amp; sec &lt; l.cacheEnd {</code></span>
<span class="codeline" id="line-496"><code>			name = l.cacheZone.name</code></span>
<span class="codeline" id="line-497"><code>			offset = l.cacheZone.offset</code></span>
<span class="codeline" id="line-498"><code>		} else {</code></span>
<span class="codeline" id="line-499"><code>			name, offset, _, _, _ = l.lookup(sec)</code></span>
<span class="codeline" id="line-500"><code>		}</code></span>
<span class="codeline" id="line-501"><code>		sec += int64(offset)</code></span>
<span class="codeline" id="line-502"><code>	} else {</code></span>
<span class="codeline" id="line-503"><code>		name = "UTC"</code></span>
<span class="codeline" id="line-504"><code>	}</code></span>
<span class="codeline" id="line-505"><code>	abs = uint64(sec + (unixToInternal + internalToAbsolute))</code></span>
<span class="codeline" id="line-506"><code>	return</code></span>
<span class="codeline" id="line-507"><code>}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>// Date returns the year, month, and day in which t occurs.</code></span>
<span class="codeline" id="line-510"><code>func (t Time) Date() (year int, month Month, day int) {</code></span>
<span class="codeline" id="line-511"><code>	year, month, day, _ = t.date(true)</code></span>
<span class="codeline" id="line-512"><code>	return</code></span>
<span class="codeline" id="line-513"><code>}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>// Year returns the year in which t occurs.</code></span>
<span class="codeline" id="line-516"><code>func (t Time) Year() int {</code></span>
<span class="codeline" id="line-517"><code>	year, _, _, _ := t.date(false)</code></span>
<span class="codeline" id="line-518"><code>	return year</code></span>
<span class="codeline" id="line-519"><code>}</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>// Month returns the month of the year specified by t.</code></span>
<span class="codeline" id="line-522"><code>func (t Time) Month() Month {</code></span>
<span class="codeline" id="line-523"><code>	_, month, _, _ := t.date(true)</code></span>
<span class="codeline" id="line-524"><code>	return month</code></span>
<span class="codeline" id="line-525"><code>}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>// Day returns the day of the month specified by t.</code></span>
<span class="codeline" id="line-528"><code>func (t Time) Day() int {</code></span>
<span class="codeline" id="line-529"><code>	_, _, day, _ := t.date(true)</code></span>
<span class="codeline" id="line-530"><code>	return day</code></span>
<span class="codeline" id="line-531"><code>}</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>// Weekday returns the day of the week specified by t.</code></span>
<span class="codeline" id="line-534"><code>func (t Time) Weekday() Weekday {</code></span>
<span class="codeline" id="line-535"><code>	return absWeekday(t.abs())</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// absWeekday is like Weekday but operates on an absolute time.</code></span>
<span class="codeline" id="line-539"><code>func absWeekday(abs uint64) Weekday {</code></span>
<span class="codeline" id="line-540"><code>	// January 1 of the absolute year, like January 1 of 2001, was a Monday.</code></span>
<span class="codeline" id="line-541"><code>	sec := (abs + uint64(Monday)*secondsPerDay) % secondsPerWeek</code></span>
<span class="codeline" id="line-542"><code>	return Weekday(int(sec) / secondsPerDay)</code></span>
<span class="codeline" id="line-543"><code>}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>// ISOWeek returns the ISO 8601 year and week number in which t occurs.</code></span>
<span class="codeline" id="line-546"><code>// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to</code></span>
<span class="codeline" id="line-547"><code>// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1</code></span>
<span class="codeline" id="line-548"><code>// of year n+1.</code></span>
<span class="codeline" id="line-549"><code>func (t Time) ISOWeek() (year, week int) {</code></span>
<span class="codeline" id="line-550"><code>	// According to the rule that the first calendar week of a calendar year is</code></span>
<span class="codeline" id="line-551"><code>	// the week including the first Thursday of that year, and that the last one is</code></span>
<span class="codeline" id="line-552"><code>	// the week immediately preceding the first calendar week of the next calendar year.</code></span>
<span class="codeline" id="line-553"><code>	// See https://www.iso.org/obp/ui#iso:std:iso:8601:-1:ed-1:v1:en:term:3.1.1.23 for details.</code></span>
<span class="codeline" id="line-554"><code></code></span>
<span class="codeline" id="line-555"><code>	// weeks start with Monday</code></span>
<span class="codeline" id="line-556"><code>	// Monday Tuesday Wednesday Thursday Friday Saturday Sunday</code></span>
<span class="codeline" id="line-557"><code>	// 1      2       3         4        5      6        7</code></span>
<span class="codeline" id="line-558"><code>	// +3     +2      +1        0        -1     -2       -3</code></span>
<span class="codeline" id="line-559"><code>	// the offset to Thursday</code></span>
<span class="codeline" id="line-560"><code>	abs := t.abs()</code></span>
<span class="codeline" id="line-561"><code>	d := Thursday - absWeekday(abs)</code></span>
<span class="codeline" id="line-562"><code>	// handle Sunday</code></span>
<span class="codeline" id="line-563"><code>	if d == 4 {</code></span>
<span class="codeline" id="line-564"><code>		d = -3</code></span>
<span class="codeline" id="line-565"><code>	}</code></span>
<span class="codeline" id="line-566"><code>	// find the Thursday of the calendar week</code></span>
<span class="codeline" id="line-567"><code>	abs += uint64(d) * secondsPerDay</code></span>
<span class="codeline" id="line-568"><code>	year, _, _, yday := absDate(abs, false)</code></span>
<span class="codeline" id="line-569"><code>	return year, yday/7 + 1</code></span>
<span class="codeline" id="line-570"><code>}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>// Clock returns the hour, minute, and second within the day specified by t.</code></span>
<span class="codeline" id="line-573"><code>func (t Time) Clock() (hour, min, sec int) {</code></span>
<span class="codeline" id="line-574"><code>	return absClock(t.abs())</code></span>
<span class="codeline" id="line-575"><code>}</code></span>
<span class="codeline" id="line-576"><code></code></span>
<span class="codeline" id="line-577"><code>// absClock is like clock but operates on an absolute time.</code></span>
<span class="codeline" id="line-578"><code>func absClock(abs uint64) (hour, min, sec int) {</code></span>
<span class="codeline" id="line-579"><code>	sec = int(abs % secondsPerDay)</code></span>
<span class="codeline" id="line-580"><code>	hour = sec / secondsPerHour</code></span>
<span class="codeline" id="line-581"><code>	sec -= hour * secondsPerHour</code></span>
<span class="codeline" id="line-582"><code>	min = sec / secondsPerMinute</code></span>
<span class="codeline" id="line-583"><code>	sec -= min * secondsPerMinute</code></span>
<span class="codeline" id="line-584"><code>	return</code></span>
<span class="codeline" id="line-585"><code>}</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>// Hour returns the hour within the day specified by t, in the range [0, 23].</code></span>
<span class="codeline" id="line-588"><code>func (t Time) Hour() int {</code></span>
<span class="codeline" id="line-589"><code>	return int(t.abs()%secondsPerDay) / secondsPerHour</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>// Minute returns the minute offset within the hour specified by t, in the range [0, 59].</code></span>
<span class="codeline" id="line-593"><code>func (t Time) Minute() int {</code></span>
<span class="codeline" id="line-594"><code>	return int(t.abs()%secondsPerHour) / secondsPerMinute</code></span>
<span class="codeline" id="line-595"><code>}</code></span>
<span class="codeline" id="line-596"><code></code></span>
<span class="codeline" id="line-597"><code>// Second returns the second offset within the minute specified by t, in the range [0, 59].</code></span>
<span class="codeline" id="line-598"><code>func (t Time) Second() int {</code></span>
<span class="codeline" id="line-599"><code>	return int(t.abs() % secondsPerMinute)</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>// Nanosecond returns the nanosecond offset within the second specified by t,</code></span>
<span class="codeline" id="line-603"><code>// in the range [0, 999999999].</code></span>
<span class="codeline" id="line-604"><code>func (t Time) Nanosecond() int {</code></span>
<span class="codeline" id="line-605"><code>	return int(t.nsec())</code></span>
<span class="codeline" id="line-606"><code>}</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>// YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,</code></span>
<span class="codeline" id="line-609"><code>// and [1,366] in leap years.</code></span>
<span class="codeline" id="line-610"><code>func (t Time) YearDay() int {</code></span>
<span class="codeline" id="line-611"><code>	_, _, _, yday := t.date(false)</code></span>
<span class="codeline" id="line-612"><code>	return yday + 1</code></span>
<span class="codeline" id="line-613"><code>}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>// A Duration represents the elapsed time between two instants</code></span>
<span class="codeline" id="line-616"><code>// as an int64 nanosecond count. The representation limits the</code></span>
<span class="codeline" id="line-617"><code>// largest representable duration to approximately 290 years.</code></span>
<span class="codeline" id="line-618"><code>type Duration int64</code></span>
<span class="codeline" id="line-619"><code></code></span>
<span class="codeline" id="line-620"><code>const (</code></span>
<span class="codeline" id="line-621"><code>	minDuration Duration = -1 &lt;&lt; 63</code></span>
<span class="codeline" id="line-622"><code>	maxDuration Duration = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-623"><code>)</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>// Common durations. There is no definition for units of Day or larger</code></span>
<span class="codeline" id="line-626"><code>// to avoid confusion across daylight savings time zone transitions.</code></span>
<span class="codeline" id="line-627"><code>//</code></span>
<span class="codeline" id="line-628"><code>// To count the number of units in a Duration, divide:</code></span>
<span class="codeline" id="line-629"><code>//</code></span>
<span class="codeline" id="line-630"><code>//	second := time.Second</code></span>
<span class="codeline" id="line-631"><code>//	fmt.Print(int64(second/time.Millisecond)) // prints 1000</code></span>
<span class="codeline" id="line-632"><code>//</code></span>
<span class="codeline" id="line-633"><code>// To convert an integer number of units to a Duration, multiply:</code></span>
<span class="codeline" id="line-634"><code>//</code></span>
<span class="codeline" id="line-635"><code>//	seconds := 10</code></span>
<span class="codeline" id="line-636"><code>//	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</code></span>
<span class="codeline" id="line-637"><code>const (</code></span>
<span class="codeline" id="line-638"><code>	Nanosecond  Duration = 1</code></span>
<span class="codeline" id="line-639"><code>	Microsecond          = 1000 * Nanosecond</code></span>
<span class="codeline" id="line-640"><code>	Millisecond          = 1000 * Microsecond</code></span>
<span class="codeline" id="line-641"><code>	Second               = 1000 * Millisecond</code></span>
<span class="codeline" id="line-642"><code>	Minute               = 60 * Second</code></span>
<span class="codeline" id="line-643"><code>	Hour                 = 60 * Minute</code></span>
<span class="codeline" id="line-644"><code>)</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>// String returns a string representing the duration in the form "72h3m0.5s".</code></span>
<span class="codeline" id="line-647"><code>// Leading zero units are omitted. As a special case, durations less than one</code></span>
<span class="codeline" id="line-648"><code>// second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure</code></span>
<span class="codeline" id="line-649"><code>// that the leading digit is non-zero. The zero duration formats as 0s.</code></span>
<span class="codeline" id="line-650"><code>func (d Duration) String() string {</code></span>
<span class="codeline" id="line-651"><code>	// This is inlinable to take advantage of "function outlining".</code></span>
<span class="codeline" id="line-652"><code>	// Thus, the caller can decide whether a string must be heap allocated.</code></span>
<span class="codeline" id="line-653"><code>	var arr [32]byte</code></span>
<span class="codeline" id="line-654"><code>	n := d.format(&amp;arr)</code></span>
<span class="codeline" id="line-655"><code>	return string(arr[n:])</code></span>
<span class="codeline" id="line-656"><code>}</code></span>
<span class="codeline" id="line-657"><code></code></span>
<span class="codeline" id="line-658"><code>// format formats the representation of d into the end of buf and</code></span>
<span class="codeline" id="line-659"><code>// returns the offset of the first character.</code></span>
<span class="codeline" id="line-660"><code>func (d Duration) format(buf *[32]byte) int {</code></span>
<span class="codeline" id="line-661"><code>	// Largest time is 2540400h10m10.000000000s</code></span>
<span class="codeline" id="line-662"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>	u := uint64(d)</code></span>
<span class="codeline" id="line-665"><code>	neg := d &lt; 0</code></span>
<span class="codeline" id="line-666"><code>	if neg {</code></span>
<span class="codeline" id="line-667"><code>		u = -u</code></span>
<span class="codeline" id="line-668"><code>	}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>	if u &lt; uint64(Second) {</code></span>
<span class="codeline" id="line-671"><code>		// Special case: if duration is smaller than a second,</code></span>
<span class="codeline" id="line-672"><code>		// use smaller units, like 1.2ms</code></span>
<span class="codeline" id="line-673"><code>		var prec int</code></span>
<span class="codeline" id="line-674"><code>		w--</code></span>
<span class="codeline" id="line-675"><code>		buf[w] = 's'</code></span>
<span class="codeline" id="line-676"><code>		w--</code></span>
<span class="codeline" id="line-677"><code>		switch {</code></span>
<span class="codeline" id="line-678"><code>		case u == 0:</code></span>
<span class="codeline" id="line-679"><code>			buf[w] = '0'</code></span>
<span class="codeline" id="line-680"><code>			return w</code></span>
<span class="codeline" id="line-681"><code>		case u &lt; uint64(Microsecond):</code></span>
<span class="codeline" id="line-682"><code>			// print nanoseconds</code></span>
<span class="codeline" id="line-683"><code>			prec = 0</code></span>
<span class="codeline" id="line-684"><code>			buf[w] = 'n'</code></span>
<span class="codeline" id="line-685"><code>		case u &lt; uint64(Millisecond):</code></span>
<span class="codeline" id="line-686"><code>			// print microseconds</code></span>
<span class="codeline" id="line-687"><code>			prec = 3</code></span>
<span class="codeline" id="line-688"><code>			// U+00B5 'µ' micro sign == 0xC2 0xB5</code></span>
<span class="codeline" id="line-689"><code>			w-- // Need room for two bytes.</code></span>
<span class="codeline" id="line-690"><code>			copy(buf[w:], "µ")</code></span>
<span class="codeline" id="line-691"><code>		default:</code></span>
<span class="codeline" id="line-692"><code>			// print milliseconds</code></span>
<span class="codeline" id="line-693"><code>			prec = 6</code></span>
<span class="codeline" id="line-694"><code>			buf[w] = 'm'</code></span>
<span class="codeline" id="line-695"><code>		}</code></span>
<span class="codeline" id="line-696"><code>		w, u = fmtFrac(buf[:w], u, prec)</code></span>
<span class="codeline" id="line-697"><code>		w = fmtInt(buf[:w], u)</code></span>
<span class="codeline" id="line-698"><code>	} else {</code></span>
<span class="codeline" id="line-699"><code>		w--</code></span>
<span class="codeline" id="line-700"><code>		buf[w] = 's'</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>		w, u = fmtFrac(buf[:w], u, 9)</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>		// u is now integer seconds</code></span>
<span class="codeline" id="line-705"><code>		w = fmtInt(buf[:w], u%60)</code></span>
<span class="codeline" id="line-706"><code>		u /= 60</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>		// u is now integer minutes</code></span>
<span class="codeline" id="line-709"><code>		if u &gt; 0 {</code></span>
<span class="codeline" id="line-710"><code>			w--</code></span>
<span class="codeline" id="line-711"><code>			buf[w] = 'm'</code></span>
<span class="codeline" id="line-712"><code>			w = fmtInt(buf[:w], u%60)</code></span>
<span class="codeline" id="line-713"><code>			u /= 60</code></span>
<span class="codeline" id="line-714"><code></code></span>
<span class="codeline" id="line-715"><code>			// u is now integer hours</code></span>
<span class="codeline" id="line-716"><code>			// Stop at hours because days can be different lengths.</code></span>
<span class="codeline" id="line-717"><code>			if u &gt; 0 {</code></span>
<span class="codeline" id="line-718"><code>				w--</code></span>
<span class="codeline" id="line-719"><code>				buf[w] = 'h'</code></span>
<span class="codeline" id="line-720"><code>				w = fmtInt(buf[:w], u)</code></span>
<span class="codeline" id="line-721"><code>			}</code></span>
<span class="codeline" id="line-722"><code>		}</code></span>
<span class="codeline" id="line-723"><code>	}</code></span>
<span class="codeline" id="line-724"><code></code></span>
<span class="codeline" id="line-725"><code>	if neg {</code></span>
<span class="codeline" id="line-726"><code>		w--</code></span>
<span class="codeline" id="line-727"><code>		buf[w] = '-'</code></span>
<span class="codeline" id="line-728"><code>	}</code></span>
<span class="codeline" id="line-729"><code></code></span>
<span class="codeline" id="line-730"><code>	return w</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>// fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the</code></span>
<span class="codeline" id="line-734"><code>// tail of buf, omitting trailing zeros. It omits the decimal</code></span>
<span class="codeline" id="line-735"><code>// point too when the fraction is 0. It returns the index where the</code></span>
<span class="codeline" id="line-736"><code>// output bytes begin and the value v/10**prec.</code></span>
<span class="codeline" id="line-737"><code>func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64) {</code></span>
<span class="codeline" id="line-738"><code>	// Omit trailing zeros up to and including decimal point.</code></span>
<span class="codeline" id="line-739"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-740"><code>	print := false</code></span>
<span class="codeline" id="line-741"><code>	for i := 0; i &lt; prec; i++ {</code></span>
<span class="codeline" id="line-742"><code>		digit := v % 10</code></span>
<span class="codeline" id="line-743"><code>		print = print || digit != 0</code></span>
<span class="codeline" id="line-744"><code>		if print {</code></span>
<span class="codeline" id="line-745"><code>			w--</code></span>
<span class="codeline" id="line-746"><code>			buf[w] = byte(digit) + '0'</code></span>
<span class="codeline" id="line-747"><code>		}</code></span>
<span class="codeline" id="line-748"><code>		v /= 10</code></span>
<span class="codeline" id="line-749"><code>	}</code></span>
<span class="codeline" id="line-750"><code>	if print {</code></span>
<span class="codeline" id="line-751"><code>		w--</code></span>
<span class="codeline" id="line-752"><code>		buf[w] = '.'</code></span>
<span class="codeline" id="line-753"><code>	}</code></span>
<span class="codeline" id="line-754"><code>	return w, v</code></span>
<span class="codeline" id="line-755"><code>}</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>// fmtInt formats v into the tail of buf.</code></span>
<span class="codeline" id="line-758"><code>// It returns the index where the output begins.</code></span>
<span class="codeline" id="line-759"><code>func fmtInt(buf []byte, v uint64) int {</code></span>
<span class="codeline" id="line-760"><code>	w := len(buf)</code></span>
<span class="codeline" id="line-761"><code>	if v == 0 {</code></span>
<span class="codeline" id="line-762"><code>		w--</code></span>
<span class="codeline" id="line-763"><code>		buf[w] = '0'</code></span>
<span class="codeline" id="line-764"><code>	} else {</code></span>
<span class="codeline" id="line-765"><code>		for v &gt; 0 {</code></span>
<span class="codeline" id="line-766"><code>			w--</code></span>
<span class="codeline" id="line-767"><code>			buf[w] = byte(v%10) + '0'</code></span>
<span class="codeline" id="line-768"><code>			v /= 10</code></span>
<span class="codeline" id="line-769"><code>		}</code></span>
<span class="codeline" id="line-770"><code>	}</code></span>
<span class="codeline" id="line-771"><code>	return w</code></span>
<span class="codeline" id="line-772"><code>}</code></span>
<span class="codeline" id="line-773"><code></code></span>
<span class="codeline" id="line-774"><code>// Nanoseconds returns the duration as an integer nanosecond count.</code></span>
<span class="codeline" id="line-775"><code>func (d Duration) Nanoseconds() int64 { return int64(d) }</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>// Microseconds returns the duration as an integer microsecond count.</code></span>
<span class="codeline" id="line-778"><code>func (d Duration) Microseconds() int64 { return int64(d) / 1e3 }</code></span>
<span class="codeline" id="line-779"><code></code></span>
<span class="codeline" id="line-780"><code>// Milliseconds returns the duration as an integer millisecond count.</code></span>
<span class="codeline" id="line-781"><code>func (d Duration) Milliseconds() int64 { return int64(d) / 1e6 }</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>// These methods return float64 because the dominant</code></span>
<span class="codeline" id="line-784"><code>// use case is for printing a floating point number like 1.5s, and</code></span>
<span class="codeline" id="line-785"><code>// a truncation to integer would make them not useful in those cases.</code></span>
<span class="codeline" id="line-786"><code>// Splitting the integer and fraction ourselves guarantees that</code></span>
<span class="codeline" id="line-787"><code>// converting the returned float64 to an integer rounds the same</code></span>
<span class="codeline" id="line-788"><code>// way that a pure integer conversion would have, even in cases</code></span>
<span class="codeline" id="line-789"><code>// where, say, float64(d.Nanoseconds())/1e9 would have rounded</code></span>
<span class="codeline" id="line-790"><code>// differently.</code></span>
<span class="codeline" id="line-791"><code></code></span>
<span class="codeline" id="line-792"><code>// Seconds returns the duration as a floating point number of seconds.</code></span>
<span class="codeline" id="line-793"><code>func (d Duration) Seconds() float64 {</code></span>
<span class="codeline" id="line-794"><code>	sec := d / Second</code></span>
<span class="codeline" id="line-795"><code>	nsec := d % Second</code></span>
<span class="codeline" id="line-796"><code>	return float64(sec) + float64(nsec)/1e9</code></span>
<span class="codeline" id="line-797"><code>}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>// Minutes returns the duration as a floating point number of minutes.</code></span>
<span class="codeline" id="line-800"><code>func (d Duration) Minutes() float64 {</code></span>
<span class="codeline" id="line-801"><code>	min := d / Minute</code></span>
<span class="codeline" id="line-802"><code>	nsec := d % Minute</code></span>
<span class="codeline" id="line-803"><code>	return float64(min) + float64(nsec)/(60*1e9)</code></span>
<span class="codeline" id="line-804"><code>}</code></span>
<span class="codeline" id="line-805"><code></code></span>
<span class="codeline" id="line-806"><code>// Hours returns the duration as a floating point number of hours.</code></span>
<span class="codeline" id="line-807"><code>func (d Duration) Hours() float64 {</code></span>
<span class="codeline" id="line-808"><code>	hour := d / Hour</code></span>
<span class="codeline" id="line-809"><code>	nsec := d % Hour</code></span>
<span class="codeline" id="line-810"><code>	return float64(hour) + float64(nsec)/(60*60*1e9)</code></span>
<span class="codeline" id="line-811"><code>}</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>// Truncate returns the result of rounding d toward zero to a multiple of m.</code></span>
<span class="codeline" id="line-814"><code>// If m &lt;= 0, Truncate returns d unchanged.</code></span>
<span class="codeline" id="line-815"><code>func (d Duration) Truncate(m Duration) Duration {</code></span>
<span class="codeline" id="line-816"><code>	if m &lt;= 0 {</code></span>
<span class="codeline" id="line-817"><code>		return d</code></span>
<span class="codeline" id="line-818"><code>	}</code></span>
<span class="codeline" id="line-819"><code>	return d - d%m</code></span>
<span class="codeline" id="line-820"><code>}</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>// lessThanHalf reports whether x+x &lt; y but avoids overflow,</code></span>
<span class="codeline" id="line-823"><code>// assuming x and y are both positive (Duration is signed).</code></span>
<span class="codeline" id="line-824"><code>func lessThanHalf(x, y Duration) bool {</code></span>
<span class="codeline" id="line-825"><code>	return uint64(x)+uint64(x) &lt; uint64(y)</code></span>
<span class="codeline" id="line-826"><code>}</code></span>
<span class="codeline" id="line-827"><code></code></span>
<span class="codeline" id="line-828"><code>// Round returns the result of rounding d to the nearest multiple of m.</code></span>
<span class="codeline" id="line-829"><code>// The rounding behavior for halfway values is to round away from zero.</code></span>
<span class="codeline" id="line-830"><code>// If the result exceeds the maximum (or minimum)</code></span>
<span class="codeline" id="line-831"><code>// value that can be stored in a Duration,</code></span>
<span class="codeline" id="line-832"><code>// Round returns the maximum (or minimum) duration.</code></span>
<span class="codeline" id="line-833"><code>// If m &lt;= 0, Round returns d unchanged.</code></span>
<span class="codeline" id="line-834"><code>func (d Duration) Round(m Duration) Duration {</code></span>
<span class="codeline" id="line-835"><code>	if m &lt;= 0 {</code></span>
<span class="codeline" id="line-836"><code>		return d</code></span>
<span class="codeline" id="line-837"><code>	}</code></span>
<span class="codeline" id="line-838"><code>	r := d % m</code></span>
<span class="codeline" id="line-839"><code>	if d &lt; 0 {</code></span>
<span class="codeline" id="line-840"><code>		r = -r</code></span>
<span class="codeline" id="line-841"><code>		if lessThanHalf(r, m) {</code></span>
<span class="codeline" id="line-842"><code>			return d + r</code></span>
<span class="codeline" id="line-843"><code>		}</code></span>
<span class="codeline" id="line-844"><code>		if d1 := d - m + r; d1 &lt; d {</code></span>
<span class="codeline" id="line-845"><code>			return d1</code></span>
<span class="codeline" id="line-846"><code>		}</code></span>
<span class="codeline" id="line-847"><code>		return minDuration // overflow</code></span>
<span class="codeline" id="line-848"><code>	}</code></span>
<span class="codeline" id="line-849"><code>	if lessThanHalf(r, m) {</code></span>
<span class="codeline" id="line-850"><code>		return d - r</code></span>
<span class="codeline" id="line-851"><code>	}</code></span>
<span class="codeline" id="line-852"><code>	if d1 := d + m - r; d1 &gt; d {</code></span>
<span class="codeline" id="line-853"><code>		return d1</code></span>
<span class="codeline" id="line-854"><code>	}</code></span>
<span class="codeline" id="line-855"><code>	return maxDuration // overflow</code></span>
<span class="codeline" id="line-856"><code>}</code></span>
<span class="codeline" id="line-857"><code></code></span>
<span class="codeline" id="line-858"><code>// Abs returns the absolute value of d.</code></span>
<span class="codeline" id="line-859"><code>// As a special case, math.MinInt64 is converted to math.MaxInt64.</code></span>
<span class="codeline" id="line-860"><code>func (d Duration) Abs() Duration {</code></span>
<span class="codeline" id="line-861"><code>	switch {</code></span>
<span class="codeline" id="line-862"><code>	case d &gt;= 0:</code></span>
<span class="codeline" id="line-863"><code>		return d</code></span>
<span class="codeline" id="line-864"><code>	case d == minDuration:</code></span>
<span class="codeline" id="line-865"><code>		return maxDuration</code></span>
<span class="codeline" id="line-866"><code>	default:</code></span>
<span class="codeline" id="line-867"><code>		return -d</code></span>
<span class="codeline" id="line-868"><code>	}</code></span>
<span class="codeline" id="line-869"><code>}</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>// Add returns the time t+d.</code></span>
<span class="codeline" id="line-872"><code>func (t Time) Add(d Duration) Time {</code></span>
<span class="codeline" id="line-873"><code>	dsec := int64(d / 1e9)</code></span>
<span class="codeline" id="line-874"><code>	nsec := t.nsec() + int32(d%1e9)</code></span>
<span class="codeline" id="line-875"><code>	if nsec &gt;= 1e9 {</code></span>
<span class="codeline" id="line-876"><code>		dsec++</code></span>
<span class="codeline" id="line-877"><code>		nsec -= 1e9</code></span>
<span class="codeline" id="line-878"><code>	} else if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-879"><code>		dsec--</code></span>
<span class="codeline" id="line-880"><code>		nsec += 1e9</code></span>
<span class="codeline" id="line-881"><code>	}</code></span>
<span class="codeline" id="line-882"><code>	t.wall = t.wall&amp;^nsecMask | uint64(nsec) // update nsec</code></span>
<span class="codeline" id="line-883"><code>	t.addSec(dsec)</code></span>
<span class="codeline" id="line-884"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-885"><code>		te := t.ext + int64(d)</code></span>
<span class="codeline" id="line-886"><code>		if d &lt; 0 &amp;&amp; te &gt; t.ext || d &gt; 0 &amp;&amp; te &lt; t.ext {</code></span>
<span class="codeline" id="line-887"><code>			// Monotonic clock reading now out of range; degrade to wall-only.</code></span>
<span class="codeline" id="line-888"><code>			t.stripMono()</code></span>
<span class="codeline" id="line-889"><code>		} else {</code></span>
<span class="codeline" id="line-890"><code>			t.ext = te</code></span>
<span class="codeline" id="line-891"><code>		}</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code>	return t</code></span>
<span class="codeline" id="line-894"><code>}</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>// Sub returns the duration t-u. If the result exceeds the maximum (or minimum)</code></span>
<span class="codeline" id="line-897"><code>// value that can be stored in a Duration, the maximum (or minimum) duration</code></span>
<span class="codeline" id="line-898"><code>// will be returned.</code></span>
<span class="codeline" id="line-899"><code>// To compute t-d for a duration d, use t.Add(-d).</code></span>
<span class="codeline" id="line-900"><code>func (t Time) Sub(u Time) Duration {</code></span>
<span class="codeline" id="line-901"><code>	if t.wall&amp;u.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-902"><code>		return subMono(t.ext, u.ext)</code></span>
<span class="codeline" id="line-903"><code>	}</code></span>
<span class="codeline" id="line-904"><code>	d := Duration(t.sec()-u.sec())*Second + Duration(t.nsec()-u.nsec())</code></span>
<span class="codeline" id="line-905"><code>	// Check for overflow or underflow.</code></span>
<span class="codeline" id="line-906"><code>	switch {</code></span>
<span class="codeline" id="line-907"><code>	case u.Add(d).Equal(t):</code></span>
<span class="codeline" id="line-908"><code>		return d // d is correct</code></span>
<span class="codeline" id="line-909"><code>	case t.Before(u):</code></span>
<span class="codeline" id="line-910"><code>		return minDuration // t - u is negative out of range</code></span>
<span class="codeline" id="line-911"><code>	default:</code></span>
<span class="codeline" id="line-912"><code>		return maxDuration // t - u is positive out of range</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code>}</code></span>
<span class="codeline" id="line-915"><code></code></span>
<span class="codeline" id="line-916"><code>func subMono(t, u int64) Duration {</code></span>
<span class="codeline" id="line-917"><code>	d := Duration(t - u)</code></span>
<span class="codeline" id="line-918"><code>	if d &lt; 0 &amp;&amp; t &gt; u {</code></span>
<span class="codeline" id="line-919"><code>		return maxDuration // t - u is positive out of range</code></span>
<span class="codeline" id="line-920"><code>	}</code></span>
<span class="codeline" id="line-921"><code>	if d &gt; 0 &amp;&amp; t &lt; u {</code></span>
<span class="codeline" id="line-922"><code>		return minDuration // t - u is negative out of range</code></span>
<span class="codeline" id="line-923"><code>	}</code></span>
<span class="codeline" id="line-924"><code>	return d</code></span>
<span class="codeline" id="line-925"><code>}</code></span>
<span class="codeline" id="line-926"><code></code></span>
<span class="codeline" id="line-927"><code>// Since returns the time elapsed since t.</code></span>
<span class="codeline" id="line-928"><code>// It is shorthand for time.Now().Sub(t).</code></span>
<span class="codeline" id="line-929"><code>func Since(t Time) Duration {</code></span>
<span class="codeline" id="line-930"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-931"><code>		// Common case optimization: if t has monotonic time, then Sub will use only it.</code></span>
<span class="codeline" id="line-932"><code>		return subMono(runtimeNano()-startNano, t.ext)</code></span>
<span class="codeline" id="line-933"><code>	}</code></span>
<span class="codeline" id="line-934"><code>	return Now().Sub(t)</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>// Until returns the duration until t.</code></span>
<span class="codeline" id="line-938"><code>// It is shorthand for t.Sub(time.Now()).</code></span>
<span class="codeline" id="line-939"><code>func Until(t Time) Duration {</code></span>
<span class="codeline" id="line-940"><code>	if t.wall&amp;hasMonotonic != 0 {</code></span>
<span class="codeline" id="line-941"><code>		// Common case optimization: if t has monotonic time, then Sub will use only it.</code></span>
<span class="codeline" id="line-942"><code>		return subMono(t.ext, runtimeNano()-startNano)</code></span>
<span class="codeline" id="line-943"><code>	}</code></span>
<span class="codeline" id="line-944"><code>	return t.Sub(Now())</code></span>
<span class="codeline" id="line-945"><code>}</code></span>
<span class="codeline" id="line-946"><code></code></span>
<span class="codeline" id="line-947"><code>// AddDate returns the time corresponding to adding the</code></span>
<span class="codeline" id="line-948"><code>// given number of years, months, and days to t.</code></span>
<span class="codeline" id="line-949"><code>// For example, AddDate(-1, 2, 3) applied to January 1, 2011</code></span>
<span class="codeline" id="line-950"><code>// returns March 4, 2010.</code></span>
<span class="codeline" id="line-951"><code>//</code></span>
<span class="codeline" id="line-952"><code>// Note that dates are fundamentally coupled to timezones, and calendrical</code></span>
<span class="codeline" id="line-953"><code>// periods like days don't have fixed durations. AddDate uses the Location of</code></span>
<span class="codeline" id="line-954"><code>// the Time value to determine these durations. That means that the same</code></span>
<span class="codeline" id="line-955"><code>// AddDate arguments can produce a different shift in absolute time depending on</code></span>
<span class="codeline" id="line-956"><code>// the base Time value and its Location. For example, AddDate(0, 0, 1) applied</code></span>
<span class="codeline" id="line-957"><code>// to 12:00 on March 27 always returns 12:00 on March 28. At some locations and</code></span>
<span class="codeline" id="line-958"><code>// in some years this is a 24 hour shift. In others it's a 23 hour shift due to</code></span>
<span class="codeline" id="line-959"><code>// daylight savings time transitions.</code></span>
<span class="codeline" id="line-960"><code>//</code></span>
<span class="codeline" id="line-961"><code>// AddDate normalizes its result in the same way that Date does,</code></span>
<span class="codeline" id="line-962"><code>// so, for example, adding one month to October 31 yields</code></span>
<span class="codeline" id="line-963"><code>// December 1, the normalized form for November 31.</code></span>
<span class="codeline" id="line-964"><code>func (t Time) AddDate(years int, months int, days int) Time {</code></span>
<span class="codeline" id="line-965"><code>	year, month, day := t.Date()</code></span>
<span class="codeline" id="line-966"><code>	hour, min, sec := t.Clock()</code></span>
<span class="codeline" id="line-967"><code>	return Date(year+years, month+Month(months), day+days, hour, min, sec, int(t.nsec()), t.Location())</code></span>
<span class="codeline" id="line-968"><code>}</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>const (</code></span>
<span class="codeline" id="line-971"><code>	secondsPerMinute = 60</code></span>
<span class="codeline" id="line-972"><code>	secondsPerHour   = 60 * secondsPerMinute</code></span>
<span class="codeline" id="line-973"><code>	secondsPerDay    = 24 * secondsPerHour</code></span>
<span class="codeline" id="line-974"><code>	secondsPerWeek   = 7 * secondsPerDay</code></span>
<span class="codeline" id="line-975"><code>	daysPer400Years  = 365*400 + 97</code></span>
<span class="codeline" id="line-976"><code>	daysPer100Years  = 365*100 + 24</code></span>
<span class="codeline" id="line-977"><code>	daysPer4Years    = 365*4 + 1</code></span>
<span class="codeline" id="line-978"><code>)</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>// date computes the year, day of year, and when full=true,</code></span>
<span class="codeline" id="line-981"><code>// the month and day in which t occurs.</code></span>
<span class="codeline" id="line-982"><code>func (t Time) date(full bool) (year int, month Month, day int, yday int) {</code></span>
<span class="codeline" id="line-983"><code>	return absDate(t.abs(), full)</code></span>
<span class="codeline" id="line-984"><code>}</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>// absDate is like date but operates on an absolute time.</code></span>
<span class="codeline" id="line-987"><code>func absDate(abs uint64, full bool) (year int, month Month, day int, yday int) {</code></span>
<span class="codeline" id="line-988"><code>	// Split into time and day.</code></span>
<span class="codeline" id="line-989"><code>	d := abs / secondsPerDay</code></span>
<span class="codeline" id="line-990"><code></code></span>
<span class="codeline" id="line-991"><code>	// Account for 400 year cycles.</code></span>
<span class="codeline" id="line-992"><code>	n := d / daysPer400Years</code></span>
<span class="codeline" id="line-993"><code>	y := 400 * n</code></span>
<span class="codeline" id="line-994"><code>	d -= daysPer400Years * n</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>	// Cut off 100-year cycles.</code></span>
<span class="codeline" id="line-997"><code>	// The last cycle has one extra leap year, so on the last day</code></span>
<span class="codeline" id="line-998"><code>	// of that year, day / daysPer100Years will be 4 instead of 3.</code></span>
<span class="codeline" id="line-999"><code>	// Cut it back down to 3 by subtracting n&gt;&gt;2.</code></span>
<span class="codeline" id="line-1000"><code>	n = d / daysPer100Years</code></span>
<span class="codeline" id="line-1001"><code>	n -= n &gt;&gt; 2</code></span>
<span class="codeline" id="line-1002"><code>	y += 100 * n</code></span>
<span class="codeline" id="line-1003"><code>	d -= daysPer100Years * n</code></span>
<span class="codeline" id="line-1004"><code></code></span>
<span class="codeline" id="line-1005"><code>	// Cut off 4-year cycles.</code></span>
<span class="codeline" id="line-1006"><code>	// The last cycle has a missing leap year, which does not</code></span>
<span class="codeline" id="line-1007"><code>	// affect the computation.</code></span>
<span class="codeline" id="line-1008"><code>	n = d / daysPer4Years</code></span>
<span class="codeline" id="line-1009"><code>	y += 4 * n</code></span>
<span class="codeline" id="line-1010"><code>	d -= daysPer4Years * n</code></span>
<span class="codeline" id="line-1011"><code></code></span>
<span class="codeline" id="line-1012"><code>	// Cut off years within a 4-year cycle.</code></span>
<span class="codeline" id="line-1013"><code>	// The last year is a leap year, so on the last day of that year,</code></span>
<span class="codeline" id="line-1014"><code>	// day / 365 will be 4 instead of 3. Cut it back down to 3</code></span>
<span class="codeline" id="line-1015"><code>	// by subtracting n&gt;&gt;2.</code></span>
<span class="codeline" id="line-1016"><code>	n = d / 365</code></span>
<span class="codeline" id="line-1017"><code>	n -= n &gt;&gt; 2</code></span>
<span class="codeline" id="line-1018"><code>	y += n</code></span>
<span class="codeline" id="line-1019"><code>	d -= 365 * n</code></span>
<span class="codeline" id="line-1020"><code></code></span>
<span class="codeline" id="line-1021"><code>	year = int(int64(y) + absoluteZeroYear)</code></span>
<span class="codeline" id="line-1022"><code>	yday = int(d)</code></span>
<span class="codeline" id="line-1023"><code></code></span>
<span class="codeline" id="line-1024"><code>	if !full {</code></span>
<span class="codeline" id="line-1025"><code>		return</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>	day = yday</code></span>
<span class="codeline" id="line-1029"><code>	if isLeap(year) {</code></span>
<span class="codeline" id="line-1030"><code>		// Leap year</code></span>
<span class="codeline" id="line-1031"><code>		switch {</code></span>
<span class="codeline" id="line-1032"><code>		case day &gt; 31+29-1:</code></span>
<span class="codeline" id="line-1033"><code>			// After leap day; pretend it wasn't there.</code></span>
<span class="codeline" id="line-1034"><code>			day--</code></span>
<span class="codeline" id="line-1035"><code>		case day == 31+29-1:</code></span>
<span class="codeline" id="line-1036"><code>			// Leap day.</code></span>
<span class="codeline" id="line-1037"><code>			month = February</code></span>
<span class="codeline" id="line-1038"><code>			day = 29</code></span>
<span class="codeline" id="line-1039"><code>			return</code></span>
<span class="codeline" id="line-1040"><code>		}</code></span>
<span class="codeline" id="line-1041"><code>	}</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>	// Estimate month on assumption that every month has 31 days.</code></span>
<span class="codeline" id="line-1044"><code>	// The estimate may be too low by at most one month, so adjust.</code></span>
<span class="codeline" id="line-1045"><code>	month = Month(day / 31)</code></span>
<span class="codeline" id="line-1046"><code>	end := int(daysBefore[month+1])</code></span>
<span class="codeline" id="line-1047"><code>	var begin int</code></span>
<span class="codeline" id="line-1048"><code>	if day &gt;= end {</code></span>
<span class="codeline" id="line-1049"><code>		month++</code></span>
<span class="codeline" id="line-1050"><code>		begin = end</code></span>
<span class="codeline" id="line-1051"><code>	} else {</code></span>
<span class="codeline" id="line-1052"><code>		begin = int(daysBefore[month])</code></span>
<span class="codeline" id="line-1053"><code>	}</code></span>
<span class="codeline" id="line-1054"><code></code></span>
<span class="codeline" id="line-1055"><code>	month++ // because January is 1</code></span>
<span class="codeline" id="line-1056"><code>	day = day - begin + 1</code></span>
<span class="codeline" id="line-1057"><code>	return</code></span>
<span class="codeline" id="line-1058"><code>}</code></span>
<span class="codeline" id="line-1059"><code></code></span>
<span class="codeline" id="line-1060"><code>// daysBefore[m] counts the number of days in a non-leap year</code></span>
<span class="codeline" id="line-1061"><code>// before month m begins. There is an entry for m=12, counting</code></span>
<span class="codeline" id="line-1062"><code>// the number of days before January of next year (365).</code></span>
<span class="codeline" id="line-1063"><code>var daysBefore = [...]int32{</code></span>
<span class="codeline" id="line-1064"><code>	0,</code></span>
<span class="codeline" id="line-1065"><code>	31,</code></span>
<span class="codeline" id="line-1066"><code>	31 + 28,</code></span>
<span class="codeline" id="line-1067"><code>	31 + 28 + 31,</code></span>
<span class="codeline" id="line-1068"><code>	31 + 28 + 31 + 30,</code></span>
<span class="codeline" id="line-1069"><code>	31 + 28 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1070"><code>	31 + 28 + 31 + 30 + 31 + 30,</code></span>
<span class="codeline" id="line-1071"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1072"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,</code></span>
<span class="codeline" id="line-1073"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,</code></span>
<span class="codeline" id="line-1074"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1075"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,</code></span>
<span class="codeline" id="line-1076"><code>	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,</code></span>
<span class="codeline" id="line-1077"><code>}</code></span>
<span class="codeline" id="line-1078"><code></code></span>
<span class="codeline" id="line-1079"><code>func daysIn(m Month, year int) int {</code></span>
<span class="codeline" id="line-1080"><code>	if m == February &amp;&amp; isLeap(year) {</code></span>
<span class="codeline" id="line-1081"><code>		return 29</code></span>
<span class="codeline" id="line-1082"><code>	}</code></span>
<span class="codeline" id="line-1083"><code>	return int(daysBefore[m] - daysBefore[m-1])</code></span>
<span class="codeline" id="line-1084"><code>}</code></span>
<span class="codeline" id="line-1085"><code></code></span>
<span class="codeline" id="line-1086"><code>// daysSinceEpoch takes a year and returns the number of days from</code></span>
<span class="codeline" id="line-1087"><code>// the absolute epoch to the start of that year.</code></span>
<span class="codeline" id="line-1088"><code>// This is basically (year - zeroYear) * 365, but accounting for leap days.</code></span>
<span class="codeline" id="line-1089"><code>func daysSinceEpoch(year int) uint64 {</code></span>
<span class="codeline" id="line-1090"><code>	y := uint64(int64(year) - absoluteZeroYear)</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>	// Add in days from 400-year cycles.</code></span>
<span class="codeline" id="line-1093"><code>	n := y / 400</code></span>
<span class="codeline" id="line-1094"><code>	y -= 400 * n</code></span>
<span class="codeline" id="line-1095"><code>	d := daysPer400Years * n</code></span>
<span class="codeline" id="line-1096"><code></code></span>
<span class="codeline" id="line-1097"><code>	// Add in 100-year cycles.</code></span>
<span class="codeline" id="line-1098"><code>	n = y / 100</code></span>
<span class="codeline" id="line-1099"><code>	y -= 100 * n</code></span>
<span class="codeline" id="line-1100"><code>	d += daysPer100Years * n</code></span>
<span class="codeline" id="line-1101"><code></code></span>
<span class="codeline" id="line-1102"><code>	// Add in 4-year cycles.</code></span>
<span class="codeline" id="line-1103"><code>	n = y / 4</code></span>
<span class="codeline" id="line-1104"><code>	y -= 4 * n</code></span>
<span class="codeline" id="line-1105"><code>	d += daysPer4Years * n</code></span>
<span class="codeline" id="line-1106"><code></code></span>
<span class="codeline" id="line-1107"><code>	// Add in non-leap years.</code></span>
<span class="codeline" id="line-1108"><code>	n = y</code></span>
<span class="codeline" id="line-1109"><code>	d += 365 * n</code></span>
<span class="codeline" id="line-1110"><code></code></span>
<span class="codeline" id="line-1111"><code>	return d</code></span>
<span class="codeline" id="line-1112"><code>}</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>// Provided by package runtime.</code></span>
<span class="codeline" id="line-1115"><code>func now() (sec int64, nsec int32, mono int64)</code></span>
<span class="codeline" id="line-1116"><code></code></span>
<span class="codeline" id="line-1117"><code>// runtimeNano returns the current value of the runtime clock in nanoseconds.</code></span>
<span class="codeline" id="line-1118"><code>//</code></span>
<span class="codeline" id="line-1119"><code>//go:linkname runtimeNano runtime.nanotime</code></span>
<span class="codeline" id="line-1120"><code>func runtimeNano() int64</code></span>
<span class="codeline" id="line-1121"><code></code></span>
<span class="codeline" id="line-1122"><code>// Monotonic times are reported as offsets from startNano.</code></span>
<span class="codeline" id="line-1123"><code>// We initialize startNano to runtimeNano() - 1 so that on systems where</code></span>
<span class="codeline" id="line-1124"><code>// monotonic time resolution is fairly low (e.g. Windows 2008</code></span>
<span class="codeline" id="line-1125"><code>// which appears to have a default resolution of 15ms),</code></span>
<span class="codeline" id="line-1126"><code>// we avoid ever reporting a monotonic time of 0.</code></span>
<span class="codeline" id="line-1127"><code>// (Callers may want to use 0 as "time not set".)</code></span>
<span class="codeline" id="line-1128"><code>var startNano int64 = runtimeNano() - 1</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>// Now returns the current local time.</code></span>
<span class="codeline" id="line-1131"><code>func Now() Time {</code></span>
<span class="codeline" id="line-1132"><code>	sec, nsec, mono := now()</code></span>
<span class="codeline" id="line-1133"><code>	mono -= startNano</code></span>
<span class="codeline" id="line-1134"><code>	sec += unixToInternal - minWall</code></span>
<span class="codeline" id="line-1135"><code>	if uint64(sec)&gt;&gt;33 != 0 {</code></span>
<span class="codeline" id="line-1136"><code>		// Seconds field overflowed the 33 bits available when</code></span>
<span class="codeline" id="line-1137"><code>		// storing a monotonic time. This will be true after</code></span>
<span class="codeline" id="line-1138"><code>		// March 16, 2157.</code></span>
<span class="codeline" id="line-1139"><code>		return Time{uint64(nsec), sec + minWall, Local}</code></span>
<span class="codeline" id="line-1140"><code>	}</code></span>
<span class="codeline" id="line-1141"><code>	return Time{hasMonotonic | uint64(sec)&lt;&lt;nsecShift | uint64(nsec), mono, Local}</code></span>
<span class="codeline" id="line-1142"><code>}</code></span>
<span class="codeline" id="line-1143"><code></code></span>
<span class="codeline" id="line-1144"><code>func unixTime(sec int64, nsec int32) Time {</code></span>
<span class="codeline" id="line-1145"><code>	return Time{uint64(nsec), sec + unixToInternal, Local}</code></span>
<span class="codeline" id="line-1146"><code>}</code></span>
<span class="codeline" id="line-1147"><code></code></span>
<span class="codeline" id="line-1148"><code>// UTC returns t with the location set to UTC.</code></span>
<span class="codeline" id="line-1149"><code>func (t Time) UTC() Time {</code></span>
<span class="codeline" id="line-1150"><code>	t.setLoc(&amp;utcLoc)</code></span>
<span class="codeline" id="line-1151"><code>	return t</code></span>
<span class="codeline" id="line-1152"><code>}</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>// Local returns t with the location set to local time.</code></span>
<span class="codeline" id="line-1155"><code>func (t Time) Local() Time {</code></span>
<span class="codeline" id="line-1156"><code>	t.setLoc(Local)</code></span>
<span class="codeline" id="line-1157"><code>	return t</code></span>
<span class="codeline" id="line-1158"><code>}</code></span>
<span class="codeline" id="line-1159"><code></code></span>
<span class="codeline" id="line-1160"><code>// In returns a copy of t representing the same time instant, but</code></span>
<span class="codeline" id="line-1161"><code>// with the copy's location information set to loc for display</code></span>
<span class="codeline" id="line-1162"><code>// purposes.</code></span>
<span class="codeline" id="line-1163"><code>//</code></span>
<span class="codeline" id="line-1164"><code>// In panics if loc is nil.</code></span>
<span class="codeline" id="line-1165"><code>func (t Time) In(loc *Location) Time {</code></span>
<span class="codeline" id="line-1166"><code>	if loc == nil {</code></span>
<span class="codeline" id="line-1167"><code>		panic("time: missing Location in call to Time.In")</code></span>
<span class="codeline" id="line-1168"><code>	}</code></span>
<span class="codeline" id="line-1169"><code>	t.setLoc(loc)</code></span>
<span class="codeline" id="line-1170"><code>	return t</code></span>
<span class="codeline" id="line-1171"><code>}</code></span>
<span class="codeline" id="line-1172"><code></code></span>
<span class="codeline" id="line-1173"><code>// Location returns the time zone information associated with t.</code></span>
<span class="codeline" id="line-1174"><code>func (t Time) Location() *Location {</code></span>
<span class="codeline" id="line-1175"><code>	l := t.loc</code></span>
<span class="codeline" id="line-1176"><code>	if l == nil {</code></span>
<span class="codeline" id="line-1177"><code>		l = UTC</code></span>
<span class="codeline" id="line-1178"><code>	}</code></span>
<span class="codeline" id="line-1179"><code>	return l</code></span>
<span class="codeline" id="line-1180"><code>}</code></span>
<span class="codeline" id="line-1181"><code></code></span>
<span class="codeline" id="line-1182"><code>// Zone computes the time zone in effect at time t, returning the abbreviated</code></span>
<span class="codeline" id="line-1183"><code>// name of the zone (such as "CET") and its offset in seconds east of UTC.</code></span>
<span class="codeline" id="line-1184"><code>func (t Time) Zone() (name string, offset int) {</code></span>
<span class="codeline" id="line-1185"><code>	name, offset, _, _, _ = t.loc.lookup(t.unixSec())</code></span>
<span class="codeline" id="line-1186"><code>	return</code></span>
<span class="codeline" id="line-1187"><code>}</code></span>
<span class="codeline" id="line-1188"><code></code></span>
<span class="codeline" id="line-1189"><code>// ZoneBounds returns the bounds of the time zone in effect at time t.</code></span>
<span class="codeline" id="line-1190"><code>// The zone begins at start and the next zone begins at end.</code></span>
<span class="codeline" id="line-1191"><code>// If the zone begins at the beginning of time, start will be returned as a zero Time.</code></span>
<span class="codeline" id="line-1192"><code>// If the zone goes on forever, end will be returned as a zero Time.</code></span>
<span class="codeline" id="line-1193"><code>// The Location of the returned times will be the same as t.</code></span>
<span class="codeline" id="line-1194"><code>func (t Time) ZoneBounds() (start, end Time) {</code></span>
<span class="codeline" id="line-1195"><code>	_, _, startSec, endSec, _ := t.loc.lookup(t.unixSec())</code></span>
<span class="codeline" id="line-1196"><code>	if startSec != alpha {</code></span>
<span class="codeline" id="line-1197"><code>		start = unixTime(startSec, 0)</code></span>
<span class="codeline" id="line-1198"><code>		start.setLoc(t.loc)</code></span>
<span class="codeline" id="line-1199"><code>	}</code></span>
<span class="codeline" id="line-1200"><code>	if endSec != omega {</code></span>
<span class="codeline" id="line-1201"><code>		end = unixTime(endSec, 0)</code></span>
<span class="codeline" id="line-1202"><code>		end.setLoc(t.loc)</code></span>
<span class="codeline" id="line-1203"><code>	}</code></span>
<span class="codeline" id="line-1204"><code>	return</code></span>
<span class="codeline" id="line-1205"><code>}</code></span>
<span class="codeline" id="line-1206"><code></code></span>
<span class="codeline" id="line-1207"><code>// Unix returns t as a Unix time, the number of seconds elapsed</code></span>
<span class="codeline" id="line-1208"><code>// since January 1, 1970 UTC. The result does not depend on the</code></span>
<span class="codeline" id="line-1209"><code>// location associated with t.</code></span>
<span class="codeline" id="line-1210"><code>// Unix-like operating systems often record time as a 32-bit</code></span>
<span class="codeline" id="line-1211"><code>// count of seconds, but since the method here returns a 64-bit</code></span>
<span class="codeline" id="line-1212"><code>// value it is valid for billions of years into the past or future.</code></span>
<span class="codeline" id="line-1213"><code>func (t Time) Unix() int64 {</code></span>
<span class="codeline" id="line-1214"><code>	return t.unixSec()</code></span>
<span class="codeline" id="line-1215"><code>}</code></span>
<span class="codeline" id="line-1216"><code></code></span>
<span class="codeline" id="line-1217"><code>// UnixMilli returns t as a Unix time, the number of milliseconds elapsed since</code></span>
<span class="codeline" id="line-1218"><code>// January 1, 1970 UTC. The result is undefined if the Unix time in</code></span>
<span class="codeline" id="line-1219"><code>// milliseconds cannot be represented by an int64 (a date more than 292 million</code></span>
<span class="codeline" id="line-1220"><code>// years before or after 1970). The result does not depend on the</code></span>
<span class="codeline" id="line-1221"><code>// location associated with t.</code></span>
<span class="codeline" id="line-1222"><code>func (t Time) UnixMilli() int64 {</code></span>
<span class="codeline" id="line-1223"><code>	return t.unixSec()*1e3 + int64(t.nsec())/1e6</code></span>
<span class="codeline" id="line-1224"><code>}</code></span>
<span class="codeline" id="line-1225"><code></code></span>
<span class="codeline" id="line-1226"><code>// UnixMicro returns t as a Unix time, the number of microseconds elapsed since</code></span>
<span class="codeline" id="line-1227"><code>// January 1, 1970 UTC. The result is undefined if the Unix time in</code></span>
<span class="codeline" id="line-1228"><code>// microseconds cannot be represented by an int64 (a date before year -290307 or</code></span>
<span class="codeline" id="line-1229"><code>// after year 294246). The result does not depend on the location associated</code></span>
<span class="codeline" id="line-1230"><code>// with t.</code></span>
<span class="codeline" id="line-1231"><code>func (t Time) UnixMicro() int64 {</code></span>
<span class="codeline" id="line-1232"><code>	return t.unixSec()*1e6 + int64(t.nsec())/1e3</code></span>
<span class="codeline" id="line-1233"><code>}</code></span>
<span class="codeline" id="line-1234"><code></code></span>
<span class="codeline" id="line-1235"><code>// UnixNano returns t as a Unix time, the number of nanoseconds elapsed</code></span>
<span class="codeline" id="line-1236"><code>// since January 1, 1970 UTC. The result is undefined if the Unix time</code></span>
<span class="codeline" id="line-1237"><code>// in nanoseconds cannot be represented by an int64 (a date before the year</code></span>
<span class="codeline" id="line-1238"><code>// 1678 or after 2262). Note that this means the result of calling UnixNano</code></span>
<span class="codeline" id="line-1239"><code>// on the zero Time is undefined. The result does not depend on the</code></span>
<span class="codeline" id="line-1240"><code>// location associated with t.</code></span>
<span class="codeline" id="line-1241"><code>func (t Time) UnixNano() int64 {</code></span>
<span class="codeline" id="line-1242"><code>	return (t.unixSec())*1e9 + int64(t.nsec())</code></span>
<span class="codeline" id="line-1243"><code>}</code></span>
<span class="codeline" id="line-1244"><code></code></span>
<span class="codeline" id="line-1245"><code>const (</code></span>
<span class="codeline" id="line-1246"><code>	timeBinaryVersionV1 byte = iota + 1 // For general situation</code></span>
<span class="codeline" id="line-1247"><code>	timeBinaryVersionV2                 // For LMT only</code></span>
<span class="codeline" id="line-1248"><code>)</code></span>
<span class="codeline" id="line-1249"><code></code></span>
<span class="codeline" id="line-1250"><code>// MarshalBinary implements the encoding.BinaryMarshaler interface.</code></span>
<span class="codeline" id="line-1251"><code>func (t Time) MarshalBinary() ([]byte, error) {</code></span>
<span class="codeline" id="line-1252"><code>	var offsetMin int16 // minutes east of UTC. -1 is UTC.</code></span>
<span class="codeline" id="line-1253"><code>	var offsetSec int8</code></span>
<span class="codeline" id="line-1254"><code>	version := timeBinaryVersionV1</code></span>
<span class="codeline" id="line-1255"><code></code></span>
<span class="codeline" id="line-1256"><code>	if t.Location() == UTC {</code></span>
<span class="codeline" id="line-1257"><code>		offsetMin = -1</code></span>
<span class="codeline" id="line-1258"><code>	} else {</code></span>
<span class="codeline" id="line-1259"><code>		_, offset := t.Zone()</code></span>
<span class="codeline" id="line-1260"><code>		if offset%60 != 0 {</code></span>
<span class="codeline" id="line-1261"><code>			version = timeBinaryVersionV2</code></span>
<span class="codeline" id="line-1262"><code>			offsetSec = int8(offset % 60)</code></span>
<span class="codeline" id="line-1263"><code>		}</code></span>
<span class="codeline" id="line-1264"><code></code></span>
<span class="codeline" id="line-1265"><code>		offset /= 60</code></span>
<span class="codeline" id="line-1266"><code>		if offset &lt; -32768 || offset == -1 || offset &gt; 32767 {</code></span>
<span class="codeline" id="line-1267"><code>			return nil, errors.New("Time.MarshalBinary: unexpected zone offset")</code></span>
<span class="codeline" id="line-1268"><code>		}</code></span>
<span class="codeline" id="line-1269"><code>		offsetMin = int16(offset)</code></span>
<span class="codeline" id="line-1270"><code>	}</code></span>
<span class="codeline" id="line-1271"><code></code></span>
<span class="codeline" id="line-1272"><code>	sec := t.sec()</code></span>
<span class="codeline" id="line-1273"><code>	nsec := t.nsec()</code></span>
<span class="codeline" id="line-1274"><code>	enc := []byte{</code></span>
<span class="codeline" id="line-1275"><code>		version,         // byte 0 : version</code></span>
<span class="codeline" id="line-1276"><code>		byte(sec &gt;&gt; 56), // bytes 1-8: seconds</code></span>
<span class="codeline" id="line-1277"><code>		byte(sec &gt;&gt; 48),</code></span>
<span class="codeline" id="line-1278"><code>		byte(sec &gt;&gt; 40),</code></span>
<span class="codeline" id="line-1279"><code>		byte(sec &gt;&gt; 32),</code></span>
<span class="codeline" id="line-1280"><code>		byte(sec &gt;&gt; 24),</code></span>
<span class="codeline" id="line-1281"><code>		byte(sec &gt;&gt; 16),</code></span>
<span class="codeline" id="line-1282"><code>		byte(sec &gt;&gt; 8),</code></span>
<span class="codeline" id="line-1283"><code>		byte(sec),</code></span>
<span class="codeline" id="line-1284"><code>		byte(nsec &gt;&gt; 24), // bytes 9-12: nanoseconds</code></span>
<span class="codeline" id="line-1285"><code>		byte(nsec &gt;&gt; 16),</code></span>
<span class="codeline" id="line-1286"><code>		byte(nsec &gt;&gt; 8),</code></span>
<span class="codeline" id="line-1287"><code>		byte(nsec),</code></span>
<span class="codeline" id="line-1288"><code>		byte(offsetMin &gt;&gt; 8), // bytes 13-14: zone offset in minutes</code></span>
<span class="codeline" id="line-1289"><code>		byte(offsetMin),</code></span>
<span class="codeline" id="line-1290"><code>	}</code></span>
<span class="codeline" id="line-1291"><code>	if version == timeBinaryVersionV2 {</code></span>
<span class="codeline" id="line-1292"><code>		enc = append(enc, byte(offsetSec))</code></span>
<span class="codeline" id="line-1293"><code>	}</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>	return enc, nil</code></span>
<span class="codeline" id="line-1296"><code>}</code></span>
<span class="codeline" id="line-1297"><code></code></span>
<span class="codeline" id="line-1298"><code>// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.</code></span>
<span class="codeline" id="line-1299"><code>func (t *Time) UnmarshalBinary(data []byte) error {</code></span>
<span class="codeline" id="line-1300"><code>	buf := data</code></span>
<span class="codeline" id="line-1301"><code>	if len(buf) == 0 {</code></span>
<span class="codeline" id="line-1302"><code>		return errors.New("Time.UnmarshalBinary: no data")</code></span>
<span class="codeline" id="line-1303"><code>	}</code></span>
<span class="codeline" id="line-1304"><code></code></span>
<span class="codeline" id="line-1305"><code>	version := buf[0]</code></span>
<span class="codeline" id="line-1306"><code>	if version != timeBinaryVersionV1 &amp;&amp; version != timeBinaryVersionV2 {</code></span>
<span class="codeline" id="line-1307"><code>		return errors.New("Time.UnmarshalBinary: unsupported version")</code></span>
<span class="codeline" id="line-1308"><code>	}</code></span>
<span class="codeline" id="line-1309"><code></code></span>
<span class="codeline" id="line-1310"><code>	wantLen := /*version*/ 1 + /*sec*/ 8 + /*nsec*/ 4 + /*zone offset*/ 2</code></span>
<span class="codeline" id="line-1311"><code>	if version == timeBinaryVersionV2 {</code></span>
<span class="codeline" id="line-1312"><code>		wantLen++</code></span>
<span class="codeline" id="line-1313"><code>	}</code></span>
<span class="codeline" id="line-1314"><code>	if len(buf) != wantLen {</code></span>
<span class="codeline" id="line-1315"><code>		return errors.New("Time.UnmarshalBinary: invalid length")</code></span>
<span class="codeline" id="line-1316"><code>	}</code></span>
<span class="codeline" id="line-1317"><code></code></span>
<span class="codeline" id="line-1318"><code>	buf = buf[1:]</code></span>
<span class="codeline" id="line-1319"><code>	sec := int64(buf[7]) | int64(buf[6])&lt;&lt;8 | int64(buf[5])&lt;&lt;16 | int64(buf[4])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-1320"><code>		int64(buf[3])&lt;&lt;32 | int64(buf[2])&lt;&lt;40 | int64(buf[1])&lt;&lt;48 | int64(buf[0])&lt;&lt;56</code></span>
<span class="codeline" id="line-1321"><code></code></span>
<span class="codeline" id="line-1322"><code>	buf = buf[8:]</code></span>
<span class="codeline" id="line-1323"><code>	nsec := int32(buf[3]) | int32(buf[2])&lt;&lt;8 | int32(buf[1])&lt;&lt;16 | int32(buf[0])&lt;&lt;24</code></span>
<span class="codeline" id="line-1324"><code></code></span>
<span class="codeline" id="line-1325"><code>	buf = buf[4:]</code></span>
<span class="codeline" id="line-1326"><code>	offset := int(int16(buf[1])|int16(buf[0])&lt;&lt;8) * 60</code></span>
<span class="codeline" id="line-1327"><code>	if version == timeBinaryVersionV2 {</code></span>
<span class="codeline" id="line-1328"><code>		offset += int(buf[2])</code></span>
<span class="codeline" id="line-1329"><code>	}</code></span>
<span class="codeline" id="line-1330"><code></code></span>
<span class="codeline" id="line-1331"><code>	*t = Time{}</code></span>
<span class="codeline" id="line-1332"><code>	t.wall = uint64(nsec)</code></span>
<span class="codeline" id="line-1333"><code>	t.ext = sec</code></span>
<span class="codeline" id="line-1334"><code></code></span>
<span class="codeline" id="line-1335"><code>	if offset == -1*60 {</code></span>
<span class="codeline" id="line-1336"><code>		t.setLoc(&amp;utcLoc)</code></span>
<span class="codeline" id="line-1337"><code>	} else if _, localoff, _, _, _ := Local.lookup(t.unixSec()); offset == localoff {</code></span>
<span class="codeline" id="line-1338"><code>		t.setLoc(Local)</code></span>
<span class="codeline" id="line-1339"><code>	} else {</code></span>
<span class="codeline" id="line-1340"><code>		t.setLoc(FixedZone("", offset))</code></span>
<span class="codeline" id="line-1341"><code>	}</code></span>
<span class="codeline" id="line-1342"><code></code></span>
<span class="codeline" id="line-1343"><code>	return nil</code></span>
<span class="codeline" id="line-1344"><code>}</code></span>
<span class="codeline" id="line-1345"><code></code></span>
<span class="codeline" id="line-1346"><code>// TODO(rsc): Remove GobEncoder, GobDecoder, MarshalJSON, UnmarshalJSON in Go 2.</code></span>
<span class="codeline" id="line-1347"><code>// The same semantics will be provided by the generic MarshalBinary, MarshalText,</code></span>
<span class="codeline" id="line-1348"><code>// UnmarshalBinary, UnmarshalText.</code></span>
<span class="codeline" id="line-1349"><code></code></span>
<span class="codeline" id="line-1350"><code>// GobEncode implements the gob.GobEncoder interface.</code></span>
<span class="codeline" id="line-1351"><code>func (t Time) GobEncode() ([]byte, error) {</code></span>
<span class="codeline" id="line-1352"><code>	return t.MarshalBinary()</code></span>
<span class="codeline" id="line-1353"><code>}</code></span>
<span class="codeline" id="line-1354"><code></code></span>
<span class="codeline" id="line-1355"><code>// GobDecode implements the gob.GobDecoder interface.</code></span>
<span class="codeline" id="line-1356"><code>func (t *Time) GobDecode(data []byte) error {</code></span>
<span class="codeline" id="line-1357"><code>	return t.UnmarshalBinary(data)</code></span>
<span class="codeline" id="line-1358"><code>}</code></span>
<span class="codeline" id="line-1359"><code></code></span>
<span class="codeline" id="line-1360"><code>// MarshalJSON implements the json.Marshaler interface.</code></span>
<span class="codeline" id="line-1361"><code>// The time is a quoted string in the RFC 3339 format with sub-second precision.</code></span>
<span class="codeline" id="line-1362"><code>// If the timestamp cannot be represented as valid RFC 3339</code></span>
<span class="codeline" id="line-1363"><code>// (e.g., the year is out of range), then an error is reported.</code></span>
<span class="codeline" id="line-1364"><code>func (t Time) MarshalJSON() ([]byte, error) {</code></span>
<span class="codeline" id="line-1365"><code>	b := make([]byte, 0, len(RFC3339Nano)+len(`""`))</code></span>
<span class="codeline" id="line-1366"><code>	b = append(b, '"')</code></span>
<span class="codeline" id="line-1367"><code>	b, err := t.appendStrictRFC3339(b)</code></span>
<span class="codeline" id="line-1368"><code>	b = append(b, '"')</code></span>
<span class="codeline" id="line-1369"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1370"><code>		return nil, errors.New("Time.MarshalJSON: " + err.Error())</code></span>
<span class="codeline" id="line-1371"><code>	}</code></span>
<span class="codeline" id="line-1372"><code>	return b, nil</code></span>
<span class="codeline" id="line-1373"><code>}</code></span>
<span class="codeline" id="line-1374"><code></code></span>
<span class="codeline" id="line-1375"><code>// UnmarshalJSON implements the json.Unmarshaler interface.</code></span>
<span class="codeline" id="line-1376"><code>// The time must be a quoted string in the RFC 3339 format.</code></span>
<span class="codeline" id="line-1377"><code>func (t *Time) UnmarshalJSON(data []byte) error {</code></span>
<span class="codeline" id="line-1378"><code>	if string(data) == "null" {</code></span>
<span class="codeline" id="line-1379"><code>		return nil</code></span>
<span class="codeline" id="line-1380"><code>	}</code></span>
<span class="codeline" id="line-1381"><code>	// TODO(https://go.dev/issue/47353): Properly unescape a JSON string.</code></span>
<span class="codeline" id="line-1382"><code>	if len(data) &lt; 2 || data[0] != '"' || data[len(data)-1] != '"' {</code></span>
<span class="codeline" id="line-1383"><code>		return errors.New("Time.UnmarshalJSON: input is not a JSON string")</code></span>
<span class="codeline" id="line-1384"><code>	}</code></span>
<span class="codeline" id="line-1385"><code>	data = data[len(`"`) : len(data)-len(`"`)]</code></span>
<span class="codeline" id="line-1386"><code>	var err error</code></span>
<span class="codeline" id="line-1387"><code>	*t, err = parseStrictRFC3339(data)</code></span>
<span class="codeline" id="line-1388"><code>	return err</code></span>
<span class="codeline" id="line-1389"><code>}</code></span>
<span class="codeline" id="line-1390"><code></code></span>
<span class="codeline" id="line-1391"><code>// MarshalText implements the encoding.TextMarshaler interface.</code></span>
<span class="codeline" id="line-1392"><code>// The time is formatted in RFC 3339 format with sub-second precision.</code></span>
<span class="codeline" id="line-1393"><code>// If the timestamp cannot be represented as valid RFC 3339</code></span>
<span class="codeline" id="line-1394"><code>// (e.g., the year is out of range), then an error is reported.</code></span>
<span class="codeline" id="line-1395"><code>func (t Time) MarshalText() ([]byte, error) {</code></span>
<span class="codeline" id="line-1396"><code>	b := make([]byte, 0, len(RFC3339Nano))</code></span>
<span class="codeline" id="line-1397"><code>	b, err := t.appendStrictRFC3339(b)</code></span>
<span class="codeline" id="line-1398"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1399"><code>		return nil, errors.New("Time.MarshalText: " + err.Error())</code></span>
<span class="codeline" id="line-1400"><code>	}</code></span>
<span class="codeline" id="line-1401"><code>	return b, nil</code></span>
<span class="codeline" id="line-1402"><code>}</code></span>
<span class="codeline" id="line-1403"><code></code></span>
<span class="codeline" id="line-1404"><code>// UnmarshalText implements the encoding.TextUnmarshaler interface.</code></span>
<span class="codeline" id="line-1405"><code>// The time must be in the RFC 3339 format.</code></span>
<span class="codeline" id="line-1406"><code>func (t *Time) UnmarshalText(data []byte) error {</code></span>
<span class="codeline" id="line-1407"><code>	var err error</code></span>
<span class="codeline" id="line-1408"><code>	*t, err = parseStrictRFC3339(data)</code></span>
<span class="codeline" id="line-1409"><code>	return err</code></span>
<span class="codeline" id="line-1410"><code>}</code></span>
<span class="codeline" id="line-1411"><code></code></span>
<span class="codeline" id="line-1412"><code>// Unix returns the local Time corresponding to the given Unix time,</code></span>
<span class="codeline" id="line-1413"><code>// sec seconds and nsec nanoseconds since January 1, 1970 UTC.</code></span>
<span class="codeline" id="line-1414"><code>// It is valid to pass nsec outside the range [0, 999999999].</code></span>
<span class="codeline" id="line-1415"><code>// Not all sec values have a corresponding time value. One such</code></span>
<span class="codeline" id="line-1416"><code>// value is 1&lt;&lt;63-1 (the largest int64 value).</code></span>
<span class="codeline" id="line-1417"><code>func Unix(sec int64, nsec int64) Time {</code></span>
<span class="codeline" id="line-1418"><code>	if nsec &lt; 0 || nsec &gt;= 1e9 {</code></span>
<span class="codeline" id="line-1419"><code>		n := nsec / 1e9</code></span>
<span class="codeline" id="line-1420"><code>		sec += n</code></span>
<span class="codeline" id="line-1421"><code>		nsec -= n * 1e9</code></span>
<span class="codeline" id="line-1422"><code>		if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-1423"><code>			nsec += 1e9</code></span>
<span class="codeline" id="line-1424"><code>			sec--</code></span>
<span class="codeline" id="line-1425"><code>		}</code></span>
<span class="codeline" id="line-1426"><code>	}</code></span>
<span class="codeline" id="line-1427"><code>	return unixTime(sec, int32(nsec))</code></span>
<span class="codeline" id="line-1428"><code>}</code></span>
<span class="codeline" id="line-1429"><code></code></span>
<span class="codeline" id="line-1430"><code>// UnixMilli returns the local Time corresponding to the given Unix time,</code></span>
<span class="codeline" id="line-1431"><code>// msec milliseconds since January 1, 1970 UTC.</code></span>
<span class="codeline" id="line-1432"><code>func UnixMilli(msec int64) Time {</code></span>
<span class="codeline" id="line-1433"><code>	return Unix(msec/1e3, (msec%1e3)*1e6)</code></span>
<span class="codeline" id="line-1434"><code>}</code></span>
<span class="codeline" id="line-1435"><code></code></span>
<span class="codeline" id="line-1436"><code>// UnixMicro returns the local Time corresponding to the given Unix time,</code></span>
<span class="codeline" id="line-1437"><code>// usec microseconds since January 1, 1970 UTC.</code></span>
<span class="codeline" id="line-1438"><code>func UnixMicro(usec int64) Time {</code></span>
<span class="codeline" id="line-1439"><code>	return Unix(usec/1e6, (usec%1e6)*1e3)</code></span>
<span class="codeline" id="line-1440"><code>}</code></span>
<span class="codeline" id="line-1441"><code></code></span>
<span class="codeline" id="line-1442"><code>// IsDST reports whether the time in the configured location is in Daylight Savings Time.</code></span>
<span class="codeline" id="line-1443"><code>func (t Time) IsDST() bool {</code></span>
<span class="codeline" id="line-1444"><code>	_, _, _, _, isDST := t.loc.lookup(t.Unix())</code></span>
<span class="codeline" id="line-1445"><code>	return isDST</code></span>
<span class="codeline" id="line-1446"><code>}</code></span>
<span class="codeline" id="line-1447"><code></code></span>
<span class="codeline" id="line-1448"><code>func isLeap(year int) bool {</code></span>
<span class="codeline" id="line-1449"><code>	return year%4 == 0 &amp;&amp; (year%100 != 0 || year%400 == 0)</code></span>
<span class="codeline" id="line-1450"><code>}</code></span>
<span class="codeline" id="line-1451"><code></code></span>
<span class="codeline" id="line-1452"><code>// norm returns nhi, nlo such that</code></span>
<span class="codeline" id="line-1453"><code>//</code></span>
<span class="codeline" id="line-1454"><code>//	hi * base + lo == nhi * base + nlo</code></span>
<span class="codeline" id="line-1455"><code>//	0 &lt;= nlo &lt; base</code></span>
<span class="codeline" id="line-1456"><code>func norm(hi, lo, base int) (nhi, nlo int) {</code></span>
<span class="codeline" id="line-1457"><code>	if lo &lt; 0 {</code></span>
<span class="codeline" id="line-1458"><code>		n := (-lo-1)/base + 1</code></span>
<span class="codeline" id="line-1459"><code>		hi -= n</code></span>
<span class="codeline" id="line-1460"><code>		lo += n * base</code></span>
<span class="codeline" id="line-1461"><code>	}</code></span>
<span class="codeline" id="line-1462"><code>	if lo &gt;= base {</code></span>
<span class="codeline" id="line-1463"><code>		n := lo / base</code></span>
<span class="codeline" id="line-1464"><code>		hi += n</code></span>
<span class="codeline" id="line-1465"><code>		lo -= n * base</code></span>
<span class="codeline" id="line-1466"><code>	}</code></span>
<span class="codeline" id="line-1467"><code>	return hi, lo</code></span>
<span class="codeline" id="line-1468"><code>}</code></span>
<span class="codeline" id="line-1469"><code></code></span>
<span class="codeline" id="line-1470"><code>// Date returns the Time corresponding to</code></span>
<span class="codeline" id="line-1471"><code>//</code></span>
<span class="codeline" id="line-1472"><code>//	yyyy-mm-dd hh:mm:ss + nsec nanoseconds</code></span>
<span class="codeline" id="line-1473"><code>//</code></span>
<span class="codeline" id="line-1474"><code>// in the appropriate zone for that time in the given location.</code></span>
<span class="codeline" id="line-1475"><code>//</code></span>
<span class="codeline" id="line-1476"><code>// The month, day, hour, min, sec, and nsec values may be outside</code></span>
<span class="codeline" id="line-1477"><code>// their usual ranges and will be normalized during the conversion.</code></span>
<span class="codeline" id="line-1478"><code>// For example, October 32 converts to November 1.</code></span>
<span class="codeline" id="line-1479"><code>//</code></span>
<span class="codeline" id="line-1480"><code>// A daylight savings time transition skips or repeats times.</code></span>
<span class="codeline" id="line-1481"><code>// For example, in the United States, March 13, 2011 2:15am never occurred,</code></span>
<span class="codeline" id="line-1482"><code>// while November 6, 2011 1:15am occurred twice. In such cases, the</code></span>
<span class="codeline" id="line-1483"><code>// choice of time zone, and therefore the time, is not well-defined.</code></span>
<span class="codeline" id="line-1484"><code>// Date returns a time that is correct in one of the two zones involved</code></span>
<span class="codeline" id="line-1485"><code>// in the transition, but it does not guarantee which.</code></span>
<span class="codeline" id="line-1486"><code>//</code></span>
<span class="codeline" id="line-1487"><code>// Date panics if loc is nil.</code></span>
<span class="codeline" id="line-1488"><code>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {</code></span>
<span class="codeline" id="line-1489"><code>	if loc == nil {</code></span>
<span class="codeline" id="line-1490"><code>		panic("time: missing Location in call to Date")</code></span>
<span class="codeline" id="line-1491"><code>	}</code></span>
<span class="codeline" id="line-1492"><code></code></span>
<span class="codeline" id="line-1493"><code>	// Normalize month, overflowing into year.</code></span>
<span class="codeline" id="line-1494"><code>	m := int(month) - 1</code></span>
<span class="codeline" id="line-1495"><code>	year, m = norm(year, m, 12)</code></span>
<span class="codeline" id="line-1496"><code>	month = Month(m) + 1</code></span>
<span class="codeline" id="line-1497"><code></code></span>
<span class="codeline" id="line-1498"><code>	// Normalize nsec, sec, min, hour, overflowing into day.</code></span>
<span class="codeline" id="line-1499"><code>	sec, nsec = norm(sec, nsec, 1e9)</code></span>
<span class="codeline" id="line-1500"><code>	min, sec = norm(min, sec, 60)</code></span>
<span class="codeline" id="line-1501"><code>	hour, min = norm(hour, min, 60)</code></span>
<span class="codeline" id="line-1502"><code>	day, hour = norm(day, hour, 24)</code></span>
<span class="codeline" id="line-1503"><code></code></span>
<span class="codeline" id="line-1504"><code>	// Compute days since the absolute epoch.</code></span>
<span class="codeline" id="line-1505"><code>	d := daysSinceEpoch(year)</code></span>
<span class="codeline" id="line-1506"><code></code></span>
<span class="codeline" id="line-1507"><code>	// Add in days before this month.</code></span>
<span class="codeline" id="line-1508"><code>	d += uint64(daysBefore[month-1])</code></span>
<span class="codeline" id="line-1509"><code>	if isLeap(year) &amp;&amp; month &gt;= March {</code></span>
<span class="codeline" id="line-1510"><code>		d++ // February 29</code></span>
<span class="codeline" id="line-1511"><code>	}</code></span>
<span class="codeline" id="line-1512"><code></code></span>
<span class="codeline" id="line-1513"><code>	// Add in days before today.</code></span>
<span class="codeline" id="line-1514"><code>	d += uint64(day - 1)</code></span>
<span class="codeline" id="line-1515"><code></code></span>
<span class="codeline" id="line-1516"><code>	// Add in time elapsed today.</code></span>
<span class="codeline" id="line-1517"><code>	abs := d * secondsPerDay</code></span>
<span class="codeline" id="line-1518"><code>	abs += uint64(hour*secondsPerHour + min*secondsPerMinute + sec)</code></span>
<span class="codeline" id="line-1519"><code></code></span>
<span class="codeline" id="line-1520"><code>	unix := int64(abs) + (absoluteToInternal + internalToUnix)</code></span>
<span class="codeline" id="line-1521"><code></code></span>
<span class="codeline" id="line-1522"><code>	// Look for zone offset for expected time, so we can adjust to UTC.</code></span>
<span class="codeline" id="line-1523"><code>	// The lookup function expects UTC, so first we pass unix in the</code></span>
<span class="codeline" id="line-1524"><code>	// hope that it will not be too close to a zone transition,</code></span>
<span class="codeline" id="line-1525"><code>	// and then adjust if it is.</code></span>
<span class="codeline" id="line-1526"><code>	_, offset, start, end, _ := loc.lookup(unix)</code></span>
<span class="codeline" id="line-1527"><code>	if offset != 0 {</code></span>
<span class="codeline" id="line-1528"><code>		utc := unix - int64(offset)</code></span>
<span class="codeline" id="line-1529"><code>		// If utc is valid for the time zone we found, then we have the right offset.</code></span>
<span class="codeline" id="line-1530"><code>		// If not, we get the correct offset by looking up utc in the location.</code></span>
<span class="codeline" id="line-1531"><code>		if utc &lt; start || utc &gt;= end {</code></span>
<span class="codeline" id="line-1532"><code>			_, offset, _, _, _ = loc.lookup(utc)</code></span>
<span class="codeline" id="line-1533"><code>		}</code></span>
<span class="codeline" id="line-1534"><code>		unix -= int64(offset)</code></span>
<span class="codeline" id="line-1535"><code>	}</code></span>
<span class="codeline" id="line-1536"><code></code></span>
<span class="codeline" id="line-1537"><code>	t := unixTime(unix, int32(nsec))</code></span>
<span class="codeline" id="line-1538"><code>	t.setLoc(loc)</code></span>
<span class="codeline" id="line-1539"><code>	return t</code></span>
<span class="codeline" id="line-1540"><code>}</code></span>
<span class="codeline" id="line-1541"><code></code></span>
<span class="codeline" id="line-1542"><code>// Truncate returns the result of rounding t down to a multiple of d (since the zero time).</code></span>
<span class="codeline" id="line-1543"><code>// If d &lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.</code></span>
<span class="codeline" id="line-1544"><code>//</code></span>
<span class="codeline" id="line-1545"><code>// Truncate operates on the time as an absolute duration since the</code></span>
<span class="codeline" id="line-1546"><code>// zero time; it does not operate on the presentation form of the</code></span>
<span class="codeline" id="line-1547"><code>// time. Thus, Truncate(Hour) may return a time with a non-zero</code></span>
<span class="codeline" id="line-1548"><code>// minute, depending on the time's Location.</code></span>
<span class="codeline" id="line-1549"><code>func (t Time) Truncate(d Duration) Time {</code></span>
<span class="codeline" id="line-1550"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-1551"><code>	if d &lt;= 0 {</code></span>
<span class="codeline" id="line-1552"><code>		return t</code></span>
<span class="codeline" id="line-1553"><code>	}</code></span>
<span class="codeline" id="line-1554"><code>	_, r := div(t, d)</code></span>
<span class="codeline" id="line-1555"><code>	return t.Add(-r)</code></span>
<span class="codeline" id="line-1556"><code>}</code></span>
<span class="codeline" id="line-1557"><code></code></span>
<span class="codeline" id="line-1558"><code>// Round returns the result of rounding t to the nearest multiple of d (since the zero time).</code></span>
<span class="codeline" id="line-1559"><code>// The rounding behavior for halfway values is to round up.</code></span>
<span class="codeline" id="line-1560"><code>// If d &lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.</code></span>
<span class="codeline" id="line-1561"><code>//</code></span>
<span class="codeline" id="line-1562"><code>// Round operates on the time as an absolute duration since the</code></span>
<span class="codeline" id="line-1563"><code>// zero time; it does not operate on the presentation form of the</code></span>
<span class="codeline" id="line-1564"><code>// time. Thus, Round(Hour) may return a time with a non-zero</code></span>
<span class="codeline" id="line-1565"><code>// minute, depending on the time's Location.</code></span>
<span class="codeline" id="line-1566"><code>func (t Time) Round(d Duration) Time {</code></span>
<span class="codeline" id="line-1567"><code>	t.stripMono()</code></span>
<span class="codeline" id="line-1568"><code>	if d &lt;= 0 {</code></span>
<span class="codeline" id="line-1569"><code>		return t</code></span>
<span class="codeline" id="line-1570"><code>	}</code></span>
<span class="codeline" id="line-1571"><code>	_, r := div(t, d)</code></span>
<span class="codeline" id="line-1572"><code>	if lessThanHalf(r, d) {</code></span>
<span class="codeline" id="line-1573"><code>		return t.Add(-r)</code></span>
<span class="codeline" id="line-1574"><code>	}</code></span>
<span class="codeline" id="line-1575"><code>	return t.Add(d - r)</code></span>
<span class="codeline" id="line-1576"><code>}</code></span>
<span class="codeline" id="line-1577"><code></code></span>
<span class="codeline" id="line-1578"><code>// div divides t by d and returns the quotient parity and remainder.</code></span>
<span class="codeline" id="line-1579"><code>// We don't use the quotient parity anymore (round half up instead of round to even)</code></span>
<span class="codeline" id="line-1580"><code>// but it's still here in case we change our minds.</code></span>
<span class="codeline" id="line-1581"><code>func div(t Time, d Duration) (qmod2 int, r Duration) {</code></span>
<span class="codeline" id="line-1582"><code>	neg := false</code></span>
<span class="codeline" id="line-1583"><code>	nsec := t.nsec()</code></span>
<span class="codeline" id="line-1584"><code>	sec := t.sec()</code></span>
<span class="codeline" id="line-1585"><code>	if sec &lt; 0 {</code></span>
<span class="codeline" id="line-1586"><code>		// Operate on absolute value.</code></span>
<span class="codeline" id="line-1587"><code>		neg = true</code></span>
<span class="codeline" id="line-1588"><code>		sec = -sec</code></span>
<span class="codeline" id="line-1589"><code>		nsec = -nsec</code></span>
<span class="codeline" id="line-1590"><code>		if nsec &lt; 0 {</code></span>
<span class="codeline" id="line-1591"><code>			nsec += 1e9</code></span>
<span class="codeline" id="line-1592"><code>			sec-- // sec &gt;= 1 before the -- so safe</code></span>
<span class="codeline" id="line-1593"><code>		}</code></span>
<span class="codeline" id="line-1594"><code>	}</code></span>
<span class="codeline" id="line-1595"><code></code></span>
<span class="codeline" id="line-1596"><code>	switch {</code></span>
<span class="codeline" id="line-1597"><code>	// Special case: 2d divides 1 second.</code></span>
<span class="codeline" id="line-1598"><code>	case d &lt; Second &amp;&amp; Second%(d+d) == 0:</code></span>
<span class="codeline" id="line-1599"><code>		qmod2 = int(nsec/int32(d)) &amp; 1</code></span>
<span class="codeline" id="line-1600"><code>		r = Duration(nsec % int32(d))</code></span>
<span class="codeline" id="line-1601"><code></code></span>
<span class="codeline" id="line-1602"><code>	// Special case: d is a multiple of 1 second.</code></span>
<span class="codeline" id="line-1603"><code>	case d%Second == 0:</code></span>
<span class="codeline" id="line-1604"><code>		d1 := int64(d / Second)</code></span>
<span class="codeline" id="line-1605"><code>		qmod2 = int(sec/d1) &amp; 1</code></span>
<span class="codeline" id="line-1606"><code>		r = Duration(sec%d1)*Second + Duration(nsec)</code></span>
<span class="codeline" id="line-1607"><code></code></span>
<span class="codeline" id="line-1608"><code>	// General case.</code></span>
<span class="codeline" id="line-1609"><code>	// This could be faster if more cleverness were applied,</code></span>
<span class="codeline" id="line-1610"><code>	// but it's really only here to avoid special case restrictions in the API.</code></span>
<span class="codeline" id="line-1611"><code>	// No one will care about these cases.</code></span>
<span class="codeline" id="line-1612"><code>	default:</code></span>
<span class="codeline" id="line-1613"><code>		// Compute nanoseconds as 128-bit number.</code></span>
<span class="codeline" id="line-1614"><code>		sec := uint64(sec)</code></span>
<span class="codeline" id="line-1615"><code>		tmp := (sec &gt;&gt; 32) * 1e9</code></span>
<span class="codeline" id="line-1616"><code>		u1 := tmp &gt;&gt; 32</code></span>
<span class="codeline" id="line-1617"><code>		u0 := tmp &lt;&lt; 32</code></span>
<span class="codeline" id="line-1618"><code>		tmp = (sec &amp; 0xFFFFFFFF) * 1e9</code></span>
<span class="codeline" id="line-1619"><code>		u0x, u0 := u0, u0+tmp</code></span>
<span class="codeline" id="line-1620"><code>		if u0 &lt; u0x {</code></span>
<span class="codeline" id="line-1621"><code>			u1++</code></span>
<span class="codeline" id="line-1622"><code>		}</code></span>
<span class="codeline" id="line-1623"><code>		u0x, u0 = u0, u0+uint64(nsec)</code></span>
<span class="codeline" id="line-1624"><code>		if u0 &lt; u0x {</code></span>
<span class="codeline" id="line-1625"><code>			u1++</code></span>
<span class="codeline" id="line-1626"><code>		}</code></span>
<span class="codeline" id="line-1627"><code></code></span>
<span class="codeline" id="line-1628"><code>		// Compute remainder by subtracting r&lt;&lt;k for decreasing k.</code></span>
<span class="codeline" id="line-1629"><code>		// Quotient parity is whether we subtract on last round.</code></span>
<span class="codeline" id="line-1630"><code>		d1 := uint64(d)</code></span>
<span class="codeline" id="line-1631"><code>		for d1&gt;&gt;63 != 1 {</code></span>
<span class="codeline" id="line-1632"><code>			d1 &lt;&lt;= 1</code></span>
<span class="codeline" id="line-1633"><code>		}</code></span>
<span class="codeline" id="line-1634"><code>		d0 := uint64(0)</code></span>
<span class="codeline" id="line-1635"><code>		for {</code></span>
<span class="codeline" id="line-1636"><code>			qmod2 = 0</code></span>
<span class="codeline" id="line-1637"><code>			if u1 &gt; d1 || u1 == d1 &amp;&amp; u0 &gt;= d0 {</code></span>
<span class="codeline" id="line-1638"><code>				// subtract</code></span>
<span class="codeline" id="line-1639"><code>				qmod2 = 1</code></span>
<span class="codeline" id="line-1640"><code>				u0x, u0 = u0, u0-d0</code></span>
<span class="codeline" id="line-1641"><code>				if u0 &gt; u0x {</code></span>
<span class="codeline" id="line-1642"><code>					u1--</code></span>
<span class="codeline" id="line-1643"><code>				}</code></span>
<span class="codeline" id="line-1644"><code>				u1 -= d1</code></span>
<span class="codeline" id="line-1645"><code>			}</code></span>
<span class="codeline" id="line-1646"><code>			if d1 == 0 &amp;&amp; d0 == uint64(d) {</code></span>
<span class="codeline" id="line-1647"><code>				break</code></span>
<span class="codeline" id="line-1648"><code>			}</code></span>
<span class="codeline" id="line-1649"><code>			d0 &gt;&gt;= 1</code></span>
<span class="codeline" id="line-1650"><code>			d0 |= (d1 &amp; 1) &lt;&lt; 63</code></span>
<span class="codeline" id="line-1651"><code>			d1 &gt;&gt;= 1</code></span>
<span class="codeline" id="line-1652"><code>		}</code></span>
<span class="codeline" id="line-1653"><code>		r = Duration(u0)</code></span>
<span class="codeline" id="line-1654"><code>	}</code></span>
<span class="codeline" id="line-1655"><code></code></span>
<span class="codeline" id="line-1656"><code>	if neg &amp;&amp; r != 0 {</code></span>
<span class="codeline" id="line-1657"><code>		// If input was negative and not an exact multiple of d, we computed q, r such that</code></span>
<span class="codeline" id="line-1658"><code>		//	q*d + r = -t</code></span>
<span class="codeline" id="line-1659"><code>		// But the right answers are given by -(q-1), d-r:</code></span>
<span class="codeline" id="line-1660"><code>		//	q*d + r = -t</code></span>
<span class="codeline" id="line-1661"><code>		//	-q*d - r = t</code></span>
<span class="codeline" id="line-1662"><code>		//	-(q-1)*d + (d - r) = t</code></span>
<span class="codeline" id="line-1663"><code>		qmod2 ^= 1</code></span>
<span class="codeline" id="line-1664"><code>		r = d - r</code></span>
<span class="codeline" id="line-1665"><code>	}</code></span>
<span class="codeline" id="line-1666"><code>	return</code></span>
<span class="codeline" id="line-1667"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>