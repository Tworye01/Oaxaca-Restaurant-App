<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: parse.go in package text/template/parse</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	parse.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/text/template/parse.html">text/template/parse</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package parse builds parse trees for templates as defined by text/template</code></span>
<span class="codeline" id="line-6"><code>// and html/template. Clients should use those packages to construct templates</code></span>
<span class="codeline" id="line-7"><code>// rather than this one, which provides shared internal data structures not</code></span>
<span class="codeline" id="line-8"><code>// intended for general use.</code></span></div><span class="codeline" id="line-9"><code>package parse</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"bytes"</code></span>
<span class="codeline" id="line-13"><code>	"fmt"</code></span>
<span class="codeline" id="line-14"><code>	"runtime"</code></span>
<span class="codeline" id="line-15"><code>	"strconv"</code></span>
<span class="codeline" id="line-16"><code>	"strings"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// Tree is the representation of a single parsed template.</code></span>
<span class="codeline" id="line-20"><code>type Tree struct {</code></span>
<span class="codeline" id="line-21"><code>	Name      string    // name of the template represented by the tree.</code></span>
<span class="codeline" id="line-22"><code>	ParseName string    // name of the top-level template during parsing, for error messages.</code></span>
<span class="codeline" id="line-23"><code>	Root      *ListNode // top-level root of the tree.</code></span>
<span class="codeline" id="line-24"><code>	Mode      Mode      // parsing mode.</code></span>
<span class="codeline" id="line-25"><code>	text      string    // text parsed to create the template (or its parent)</code></span>
<span class="codeline" id="line-26"><code>	// Parsing only; cleared after parse.</code></span>
<span class="codeline" id="line-27"><code>	funcs      []map[string]any</code></span>
<span class="codeline" id="line-28"><code>	lex        *lexer</code></span>
<span class="codeline" id="line-29"><code>	token      [3]item // three-token lookahead for parser.</code></span>
<span class="codeline" id="line-30"><code>	peekCount  int</code></span>
<span class="codeline" id="line-31"><code>	vars       []string // variables defined at the moment.</code></span>
<span class="codeline" id="line-32"><code>	treeSet    map[string]*Tree</code></span>
<span class="codeline" id="line-33"><code>	actionLine int // line of left delim starting action</code></span>
<span class="codeline" id="line-34"><code>	rangeDepth int</code></span>
<span class="codeline" id="line-35"><code>}</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>// A mode value is a set of flags (or 0). Modes control parser behavior.</code></span>
<span class="codeline" id="line-38"><code>type Mode uint</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>const (</code></span>
<span class="codeline" id="line-41"><code>	ParseComments Mode = 1 &lt;&lt; iota // parse comments and add them to AST</code></span>
<span class="codeline" id="line-42"><code>	SkipFuncCheck                  // do not check that functions are defined</code></span>
<span class="codeline" id="line-43"><code>)</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>// Copy returns a copy of the Tree. Any parsing state is discarded.</code></span>
<span class="codeline" id="line-46"><code>func (t *Tree) Copy() *Tree {</code></span>
<span class="codeline" id="line-47"><code>	if t == nil {</code></span>
<span class="codeline" id="line-48"><code>		return nil</code></span>
<span class="codeline" id="line-49"><code>	}</code></span>
<span class="codeline" id="line-50"><code>	return &amp;Tree{</code></span>
<span class="codeline" id="line-51"><code>		Name:      t.Name,</code></span>
<span class="codeline" id="line-52"><code>		ParseName: t.ParseName,</code></span>
<span class="codeline" id="line-53"><code>		Root:      t.Root.CopyList(),</code></span>
<span class="codeline" id="line-54"><code>		text:      t.text,</code></span>
<span class="codeline" id="line-55"><code>	}</code></span>
<span class="codeline" id="line-56"><code>}</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>// Parse returns a map from template name to parse.Tree, created by parsing the</code></span>
<span class="codeline" id="line-59"><code>// templates described in the argument string. The top-level template will be</code></span>
<span class="codeline" id="line-60"><code>// given the specified name. If an error is encountered, parsing stops and an</code></span>
<span class="codeline" id="line-61"><code>// empty map is returned with the error.</code></span>
<span class="codeline" id="line-62"><code>func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error) {</code></span>
<span class="codeline" id="line-63"><code>	treeSet := make(map[string]*Tree)</code></span>
<span class="codeline" id="line-64"><code>	t := New(name)</code></span>
<span class="codeline" id="line-65"><code>	t.text = text</code></span>
<span class="codeline" id="line-66"><code>	_, err := t.Parse(text, leftDelim, rightDelim, treeSet, funcs...)</code></span>
<span class="codeline" id="line-67"><code>	return treeSet, err</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// next returns the next token.</code></span>
<span class="codeline" id="line-71"><code>func (t *Tree) next() item {</code></span>
<span class="codeline" id="line-72"><code>	if t.peekCount &gt; 0 {</code></span>
<span class="codeline" id="line-73"><code>		t.peekCount--</code></span>
<span class="codeline" id="line-74"><code>	} else {</code></span>
<span class="codeline" id="line-75"><code>		t.token[0] = t.lex.nextItem()</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code>	return t.token[t.peekCount]</code></span>
<span class="codeline" id="line-78"><code>}</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>// backup backs the input stream up one token.</code></span>
<span class="codeline" id="line-81"><code>func (t *Tree) backup() {</code></span>
<span class="codeline" id="line-82"><code>	t.peekCount++</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>// backup2 backs the input stream up two tokens.</code></span>
<span class="codeline" id="line-86"><code>// The zeroth token is already there.</code></span>
<span class="codeline" id="line-87"><code>func (t *Tree) backup2(t1 item) {</code></span>
<span class="codeline" id="line-88"><code>	t.token[1] = t1</code></span>
<span class="codeline" id="line-89"><code>	t.peekCount = 2</code></span>
<span class="codeline" id="line-90"><code>}</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// backup3 backs the input stream up three tokens</code></span>
<span class="codeline" id="line-93"><code>// The zeroth token is already there.</code></span>
<span class="codeline" id="line-94"><code>func (t *Tree) backup3(t2, t1 item) { // Reverse order: we're pushing back.</code></span>
<span class="codeline" id="line-95"><code>	t.token[1] = t1</code></span>
<span class="codeline" id="line-96"><code>	t.token[2] = t2</code></span>
<span class="codeline" id="line-97"><code>	t.peekCount = 3</code></span>
<span class="codeline" id="line-98"><code>}</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>// peek returns but does not consume the next token.</code></span>
<span class="codeline" id="line-101"><code>func (t *Tree) peek() item {</code></span>
<span class="codeline" id="line-102"><code>	if t.peekCount &gt; 0 {</code></span>
<span class="codeline" id="line-103"><code>		return t.token[t.peekCount-1]</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code>	t.peekCount = 1</code></span>
<span class="codeline" id="line-106"><code>	t.token[0] = t.lex.nextItem()</code></span>
<span class="codeline" id="line-107"><code>	return t.token[0]</code></span>
<span class="codeline" id="line-108"><code>}</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>// nextNonSpace returns the next non-space token.</code></span>
<span class="codeline" id="line-111"><code>func (t *Tree) nextNonSpace() (token item) {</code></span>
<span class="codeline" id="line-112"><code>	for {</code></span>
<span class="codeline" id="line-113"><code>		token = t.next()</code></span>
<span class="codeline" id="line-114"><code>		if token.typ != itemSpace {</code></span>
<span class="codeline" id="line-115"><code>			break</code></span>
<span class="codeline" id="line-116"><code>		}</code></span>
<span class="codeline" id="line-117"><code>	}</code></span>
<span class="codeline" id="line-118"><code>	return token</code></span>
<span class="codeline" id="line-119"><code>}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>// peekNonSpace returns but does not consume the next non-space token.</code></span>
<span class="codeline" id="line-122"><code>func (t *Tree) peekNonSpace() item {</code></span>
<span class="codeline" id="line-123"><code>	token := t.nextNonSpace()</code></span>
<span class="codeline" id="line-124"><code>	t.backup()</code></span>
<span class="codeline" id="line-125"><code>	return token</code></span>
<span class="codeline" id="line-126"><code>}</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>// Parsing.</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>// New allocates a new parse tree with the given name.</code></span>
<span class="codeline" id="line-131"><code>func New(name string, funcs ...map[string]any) *Tree {</code></span>
<span class="codeline" id="line-132"><code>	return &amp;Tree{</code></span>
<span class="codeline" id="line-133"><code>		Name:  name,</code></span>
<span class="codeline" id="line-134"><code>		funcs: funcs,</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code>}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>// ErrorContext returns a textual representation of the location of the node in the input text.</code></span>
<span class="codeline" id="line-139"><code>// The receiver is only used when the node does not have a pointer to the tree inside,</code></span>
<span class="codeline" id="line-140"><code>// which can occur in old code.</code></span>
<span class="codeline" id="line-141"><code>func (t *Tree) ErrorContext(n Node) (location, context string) {</code></span>
<span class="codeline" id="line-142"><code>	pos := int(n.Position())</code></span>
<span class="codeline" id="line-143"><code>	tree := n.tree()</code></span>
<span class="codeline" id="line-144"><code>	if tree == nil {</code></span>
<span class="codeline" id="line-145"><code>		tree = t</code></span>
<span class="codeline" id="line-146"><code>	}</code></span>
<span class="codeline" id="line-147"><code>	text := tree.text[:pos]</code></span>
<span class="codeline" id="line-148"><code>	byteNum := strings.LastIndex(text, "\n")</code></span>
<span class="codeline" id="line-149"><code>	if byteNum == -1 {</code></span>
<span class="codeline" id="line-150"><code>		byteNum = pos // On first line.</code></span>
<span class="codeline" id="line-151"><code>	} else {</code></span>
<span class="codeline" id="line-152"><code>		byteNum++ // After the newline.</code></span>
<span class="codeline" id="line-153"><code>		byteNum = pos - byteNum</code></span>
<span class="codeline" id="line-154"><code>	}</code></span>
<span class="codeline" id="line-155"><code>	lineNum := 1 + strings.Count(text, "\n")</code></span>
<span class="codeline" id="line-156"><code>	context = n.String()</code></span>
<span class="codeline" id="line-157"><code>	return fmt.Sprintf("%s:%d:%d", tree.ParseName, lineNum, byteNum), context</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// errorf formats the error and terminates processing.</code></span>
<span class="codeline" id="line-161"><code>func (t *Tree) errorf(format string, args ...any) {</code></span>
<span class="codeline" id="line-162"><code>	t.Root = nil</code></span>
<span class="codeline" id="line-163"><code>	format = fmt.Sprintf("template: %s:%d: %s", t.ParseName, t.token[0].line, format)</code></span>
<span class="codeline" id="line-164"><code>	panic(fmt.Errorf(format, args...))</code></span>
<span class="codeline" id="line-165"><code>}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// error terminates processing.</code></span>
<span class="codeline" id="line-168"><code>func (t *Tree) error(err error) {</code></span>
<span class="codeline" id="line-169"><code>	t.errorf("%s", err)</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// expect consumes the next token and guarantees it has the required type.</code></span>
<span class="codeline" id="line-173"><code>func (t *Tree) expect(expected itemType, context string) item {</code></span>
<span class="codeline" id="line-174"><code>	token := t.nextNonSpace()</code></span>
<span class="codeline" id="line-175"><code>	if token.typ != expected {</code></span>
<span class="codeline" id="line-176"><code>		t.unexpected(token, context)</code></span>
<span class="codeline" id="line-177"><code>	}</code></span>
<span class="codeline" id="line-178"><code>	return token</code></span>
<span class="codeline" id="line-179"><code>}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>// expectOneOf consumes the next token and guarantees it has one of the required types.</code></span>
<span class="codeline" id="line-182"><code>func (t *Tree) expectOneOf(expected1, expected2 itemType, context string) item {</code></span>
<span class="codeline" id="line-183"><code>	token := t.nextNonSpace()</code></span>
<span class="codeline" id="line-184"><code>	if token.typ != expected1 &amp;&amp; token.typ != expected2 {</code></span>
<span class="codeline" id="line-185"><code>		t.unexpected(token, context)</code></span>
<span class="codeline" id="line-186"><code>	}</code></span>
<span class="codeline" id="line-187"><code>	return token</code></span>
<span class="codeline" id="line-188"><code>}</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>// unexpected complains about the token and terminates processing.</code></span>
<span class="codeline" id="line-191"><code>func (t *Tree) unexpected(token item, context string) {</code></span>
<span class="codeline" id="line-192"><code>	if token.typ == itemError {</code></span>
<span class="codeline" id="line-193"><code>		extra := ""</code></span>
<span class="codeline" id="line-194"><code>		if t.actionLine != 0 &amp;&amp; t.actionLine != token.line {</code></span>
<span class="codeline" id="line-195"><code>			extra = fmt.Sprintf(" in action started at %s:%d", t.ParseName, t.actionLine)</code></span>
<span class="codeline" id="line-196"><code>			if strings.HasSuffix(token.val, " action") {</code></span>
<span class="codeline" id="line-197"><code>				extra = extra[len(" in action"):] // avoid "action in action"</code></span>
<span class="codeline" id="line-198"><code>			}</code></span>
<span class="codeline" id="line-199"><code>		}</code></span>
<span class="codeline" id="line-200"><code>		t.errorf("%s%s", token, extra)</code></span>
<span class="codeline" id="line-201"><code>	}</code></span>
<span class="codeline" id="line-202"><code>	t.errorf("unexpected %s in %s", token, context)</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>// recover is the handler that turns panics into returns from the top level of Parse.</code></span>
<span class="codeline" id="line-206"><code>func (t *Tree) recover(errp *error) {</code></span>
<span class="codeline" id="line-207"><code>	e := recover()</code></span>
<span class="codeline" id="line-208"><code>	if e != nil {</code></span>
<span class="codeline" id="line-209"><code>		if _, ok := e.(runtime.Error); ok {</code></span>
<span class="codeline" id="line-210"><code>			panic(e)</code></span>
<span class="codeline" id="line-211"><code>		}</code></span>
<span class="codeline" id="line-212"><code>		if t != nil {</code></span>
<span class="codeline" id="line-213"><code>			t.stopParse()</code></span>
<span class="codeline" id="line-214"><code>		}</code></span>
<span class="codeline" id="line-215"><code>		*errp = e.(error)</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code>}</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>// startParse initializes the parser, using the lexer.</code></span>
<span class="codeline" id="line-220"><code>func (t *Tree) startParse(funcs []map[string]any, lex *lexer, treeSet map[string]*Tree) {</code></span>
<span class="codeline" id="line-221"><code>	t.Root = nil</code></span>
<span class="codeline" id="line-222"><code>	t.lex = lex</code></span>
<span class="codeline" id="line-223"><code>	t.vars = []string{"$"}</code></span>
<span class="codeline" id="line-224"><code>	t.funcs = funcs</code></span>
<span class="codeline" id="line-225"><code>	t.treeSet = treeSet</code></span>
<span class="codeline" id="line-226"><code>	lex.options = lexOptions{</code></span>
<span class="codeline" id="line-227"><code>		emitComment: t.Mode&amp;ParseComments != 0,</code></span>
<span class="codeline" id="line-228"><code>		breakOK:     !t.hasFunction("break"),</code></span>
<span class="codeline" id="line-229"><code>		continueOK:  !t.hasFunction("continue"),</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// stopParse terminates parsing.</code></span>
<span class="codeline" id="line-234"><code>func (t *Tree) stopParse() {</code></span>
<span class="codeline" id="line-235"><code>	t.lex = nil</code></span>
<span class="codeline" id="line-236"><code>	t.vars = nil</code></span>
<span class="codeline" id="line-237"><code>	t.funcs = nil</code></span>
<span class="codeline" id="line-238"><code>	t.treeSet = nil</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>// Parse parses the template definition string to construct a representation of</code></span>
<span class="codeline" id="line-242"><code>// the template for execution. If either action delimiter string is empty, the</code></span>
<span class="codeline" id="line-243"><code>// default ("{{" or "}}") is used. Embedded template definitions are added to</code></span>
<span class="codeline" id="line-244"><code>// the treeSet map.</code></span>
<span class="codeline" id="line-245"><code>func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error) {</code></span>
<span class="codeline" id="line-246"><code>	defer t.recover(&amp;err)</code></span>
<span class="codeline" id="line-247"><code>	t.ParseName = t.Name</code></span>
<span class="codeline" id="line-248"><code>	lexer := lex(t.Name, text, leftDelim, rightDelim)</code></span>
<span class="codeline" id="line-249"><code>	t.startParse(funcs, lexer, treeSet)</code></span>
<span class="codeline" id="line-250"><code>	t.text = text</code></span>
<span class="codeline" id="line-251"><code>	t.parse()</code></span>
<span class="codeline" id="line-252"><code>	t.add()</code></span>
<span class="codeline" id="line-253"><code>	t.stopParse()</code></span>
<span class="codeline" id="line-254"><code>	return t, nil</code></span>
<span class="codeline" id="line-255"><code>}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>// add adds tree to t.treeSet.</code></span>
<span class="codeline" id="line-258"><code>func (t *Tree) add() {</code></span>
<span class="codeline" id="line-259"><code>	tree := t.treeSet[t.Name]</code></span>
<span class="codeline" id="line-260"><code>	if tree == nil || IsEmptyTree(tree.Root) {</code></span>
<span class="codeline" id="line-261"><code>		t.treeSet[t.Name] = t</code></span>
<span class="codeline" id="line-262"><code>		return</code></span>
<span class="codeline" id="line-263"><code>	}</code></span>
<span class="codeline" id="line-264"><code>	if !IsEmptyTree(t.Root) {</code></span>
<span class="codeline" id="line-265"><code>		t.errorf("template: multiple definition of template %q", t.Name)</code></span>
<span class="codeline" id="line-266"><code>	}</code></span>
<span class="codeline" id="line-267"><code>}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.</code></span>
<span class="codeline" id="line-270"><code>func IsEmptyTree(n Node) bool {</code></span>
<span class="codeline" id="line-271"><code>	switch n := n.(type) {</code></span>
<span class="codeline" id="line-272"><code>	case nil:</code></span>
<span class="codeline" id="line-273"><code>		return true</code></span>
<span class="codeline" id="line-274"><code>	case *ActionNode:</code></span>
<span class="codeline" id="line-275"><code>	case *CommentNode:</code></span>
<span class="codeline" id="line-276"><code>		return true</code></span>
<span class="codeline" id="line-277"><code>	case *IfNode:</code></span>
<span class="codeline" id="line-278"><code>	case *ListNode:</code></span>
<span class="codeline" id="line-279"><code>		for _, node := range n.Nodes {</code></span>
<span class="codeline" id="line-280"><code>			if !IsEmptyTree(node) {</code></span>
<span class="codeline" id="line-281"><code>				return false</code></span>
<span class="codeline" id="line-282"><code>			}</code></span>
<span class="codeline" id="line-283"><code>		}</code></span>
<span class="codeline" id="line-284"><code>		return true</code></span>
<span class="codeline" id="line-285"><code>	case *RangeNode:</code></span>
<span class="codeline" id="line-286"><code>	case *TemplateNode:</code></span>
<span class="codeline" id="line-287"><code>	case *TextNode:</code></span>
<span class="codeline" id="line-288"><code>		return len(bytes.TrimSpace(n.Text)) == 0</code></span>
<span class="codeline" id="line-289"><code>	case *WithNode:</code></span>
<span class="codeline" id="line-290"><code>	default:</code></span>
<span class="codeline" id="line-291"><code>		panic("unknown node: " + n.String())</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	return false</code></span>
<span class="codeline" id="line-294"><code>}</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>// parse is the top-level parser for a template, essentially the same</code></span>
<span class="codeline" id="line-297"><code>// as itemList except it also parses {{define}} actions.</code></span>
<span class="codeline" id="line-298"><code>// It runs to EOF.</code></span>
<span class="codeline" id="line-299"><code>func (t *Tree) parse() {</code></span>
<span class="codeline" id="line-300"><code>	t.Root = t.newList(t.peek().pos)</code></span>
<span class="codeline" id="line-301"><code>	for t.peek().typ != itemEOF {</code></span>
<span class="codeline" id="line-302"><code>		if t.peek().typ == itemLeftDelim {</code></span>
<span class="codeline" id="line-303"><code>			delim := t.next()</code></span>
<span class="codeline" id="line-304"><code>			if t.nextNonSpace().typ == itemDefine {</code></span>
<span class="codeline" id="line-305"><code>				newT := New("definition") // name will be updated once we know it.</code></span>
<span class="codeline" id="line-306"><code>				newT.text = t.text</code></span>
<span class="codeline" id="line-307"><code>				newT.Mode = t.Mode</code></span>
<span class="codeline" id="line-308"><code>				newT.ParseName = t.ParseName</code></span>
<span class="codeline" id="line-309"><code>				newT.startParse(t.funcs, t.lex, t.treeSet)</code></span>
<span class="codeline" id="line-310"><code>				newT.parseDefinition()</code></span>
<span class="codeline" id="line-311"><code>				continue</code></span>
<span class="codeline" id="line-312"><code>			}</code></span>
<span class="codeline" id="line-313"><code>			t.backup2(delim)</code></span>
<span class="codeline" id="line-314"><code>		}</code></span>
<span class="codeline" id="line-315"><code>		switch n := t.textOrAction(); n.Type() {</code></span>
<span class="codeline" id="line-316"><code>		case nodeEnd, nodeElse:</code></span>
<span class="codeline" id="line-317"><code>			t.errorf("unexpected %s", n)</code></span>
<span class="codeline" id="line-318"><code>		default:</code></span>
<span class="codeline" id="line-319"><code>			t.Root.append(n)</code></span>
<span class="codeline" id="line-320"><code>		}</code></span>
<span class="codeline" id="line-321"><code>	}</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// parseDefinition parses a {{define}} ...  {{end}} template definition and</code></span>
<span class="codeline" id="line-325"><code>// installs the definition in t.treeSet. The "define" keyword has already</code></span>
<span class="codeline" id="line-326"><code>// been scanned.</code></span>
<span class="codeline" id="line-327"><code>func (t *Tree) parseDefinition() {</code></span>
<span class="codeline" id="line-328"><code>	const context = "define clause"</code></span>
<span class="codeline" id="line-329"><code>	name := t.expectOneOf(itemString, itemRawString, context)</code></span>
<span class="codeline" id="line-330"><code>	var err error</code></span>
<span class="codeline" id="line-331"><code>	t.Name, err = strconv.Unquote(name.val)</code></span>
<span class="codeline" id="line-332"><code>	if err != nil {</code></span>
<span class="codeline" id="line-333"><code>		t.error(err)</code></span>
<span class="codeline" id="line-334"><code>	}</code></span>
<span class="codeline" id="line-335"><code>	t.expect(itemRightDelim, context)</code></span>
<span class="codeline" id="line-336"><code>	var end Node</code></span>
<span class="codeline" id="line-337"><code>	t.Root, end = t.itemList()</code></span>
<span class="codeline" id="line-338"><code>	if end.Type() != nodeEnd {</code></span>
<span class="codeline" id="line-339"><code>		t.errorf("unexpected %s in %s", end, context)</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code>	t.add()</code></span>
<span class="codeline" id="line-342"><code>	t.stopParse()</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>// itemList:</code></span>
<span class="codeline" id="line-346"><code>//</code></span>
<span class="codeline" id="line-347"><code>//	textOrAction*</code></span>
<span class="codeline" id="line-348"><code>//</code></span>
<span class="codeline" id="line-349"><code>// Terminates at {{end}} or {{else}}, returned separately.</code></span>
<span class="codeline" id="line-350"><code>func (t *Tree) itemList() (list *ListNode, next Node) {</code></span>
<span class="codeline" id="line-351"><code>	list = t.newList(t.peekNonSpace().pos)</code></span>
<span class="codeline" id="line-352"><code>	for t.peekNonSpace().typ != itemEOF {</code></span>
<span class="codeline" id="line-353"><code>		n := t.textOrAction()</code></span>
<span class="codeline" id="line-354"><code>		switch n.Type() {</code></span>
<span class="codeline" id="line-355"><code>		case nodeEnd, nodeElse:</code></span>
<span class="codeline" id="line-356"><code>			return list, n</code></span>
<span class="codeline" id="line-357"><code>		}</code></span>
<span class="codeline" id="line-358"><code>		list.append(n)</code></span>
<span class="codeline" id="line-359"><code>	}</code></span>
<span class="codeline" id="line-360"><code>	t.errorf("unexpected EOF")</code></span>
<span class="codeline" id="line-361"><code>	return</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>// textOrAction:</code></span>
<span class="codeline" id="line-365"><code>//</code></span>
<span class="codeline" id="line-366"><code>//	text | comment | action</code></span>
<span class="codeline" id="line-367"><code>func (t *Tree) textOrAction() Node {</code></span>
<span class="codeline" id="line-368"><code>	switch token := t.nextNonSpace(); token.typ {</code></span>
<span class="codeline" id="line-369"><code>	case itemText:</code></span>
<span class="codeline" id="line-370"><code>		return t.newText(token.pos, token.val)</code></span>
<span class="codeline" id="line-371"><code>	case itemLeftDelim:</code></span>
<span class="codeline" id="line-372"><code>		t.actionLine = token.line</code></span>
<span class="codeline" id="line-373"><code>		defer t.clearActionLine()</code></span>
<span class="codeline" id="line-374"><code>		return t.action()</code></span>
<span class="codeline" id="line-375"><code>	case itemComment:</code></span>
<span class="codeline" id="line-376"><code>		return t.newComment(token.pos, token.val)</code></span>
<span class="codeline" id="line-377"><code>	default:</code></span>
<span class="codeline" id="line-378"><code>		t.unexpected(token, "input")</code></span>
<span class="codeline" id="line-379"><code>	}</code></span>
<span class="codeline" id="line-380"><code>	return nil</code></span>
<span class="codeline" id="line-381"><code>}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>func (t *Tree) clearActionLine() {</code></span>
<span class="codeline" id="line-384"><code>	t.actionLine = 0</code></span>
<span class="codeline" id="line-385"><code>}</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>// Action:</code></span>
<span class="codeline" id="line-388"><code>//</code></span>
<span class="codeline" id="line-389"><code>//	control</code></span>
<span class="codeline" id="line-390"><code>//	command ("|" command)*</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>// Left delim is past. Now get actions.</code></span>
<span class="codeline" id="line-393"><code>// First word could be a keyword such as range.</code></span>
<span class="codeline" id="line-394"><code>func (t *Tree) action() (n Node) {</code></span>
<span class="codeline" id="line-395"><code>	switch token := t.nextNonSpace(); token.typ {</code></span>
<span class="codeline" id="line-396"><code>	case itemBlock:</code></span>
<span class="codeline" id="line-397"><code>		return t.blockControl()</code></span>
<span class="codeline" id="line-398"><code>	case itemBreak:</code></span>
<span class="codeline" id="line-399"><code>		return t.breakControl(token.pos, token.line)</code></span>
<span class="codeline" id="line-400"><code>	case itemContinue:</code></span>
<span class="codeline" id="line-401"><code>		return t.continueControl(token.pos, token.line)</code></span>
<span class="codeline" id="line-402"><code>	case itemElse:</code></span>
<span class="codeline" id="line-403"><code>		return t.elseControl()</code></span>
<span class="codeline" id="line-404"><code>	case itemEnd:</code></span>
<span class="codeline" id="line-405"><code>		return t.endControl()</code></span>
<span class="codeline" id="line-406"><code>	case itemIf:</code></span>
<span class="codeline" id="line-407"><code>		return t.ifControl()</code></span>
<span class="codeline" id="line-408"><code>	case itemRange:</code></span>
<span class="codeline" id="line-409"><code>		return t.rangeControl()</code></span>
<span class="codeline" id="line-410"><code>	case itemTemplate:</code></span>
<span class="codeline" id="line-411"><code>		return t.templateControl()</code></span>
<span class="codeline" id="line-412"><code>	case itemWith:</code></span>
<span class="codeline" id="line-413"><code>		return t.withControl()</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>	t.backup()</code></span>
<span class="codeline" id="line-416"><code>	token := t.peek()</code></span>
<span class="codeline" id="line-417"><code>	// Do not pop variables; they persist until "end".</code></span>
<span class="codeline" id="line-418"><code>	return t.newAction(token.pos, token.line, t.pipeline("command", itemRightDelim))</code></span>
<span class="codeline" id="line-419"><code>}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>// Break:</code></span>
<span class="codeline" id="line-422"><code>//</code></span>
<span class="codeline" id="line-423"><code>//	{{break}}</code></span>
<span class="codeline" id="line-424"><code>//</code></span>
<span class="codeline" id="line-425"><code>// Break keyword is past.</code></span>
<span class="codeline" id="line-426"><code>func (t *Tree) breakControl(pos Pos, line int) Node {</code></span>
<span class="codeline" id="line-427"><code>	if token := t.nextNonSpace(); token.typ != itemRightDelim {</code></span>
<span class="codeline" id="line-428"><code>		t.unexpected(token, "{{break}}")</code></span>
<span class="codeline" id="line-429"><code>	}</code></span>
<span class="codeline" id="line-430"><code>	if t.rangeDepth == 0 {</code></span>
<span class="codeline" id="line-431"><code>		t.errorf("{{break}} outside {{range}}")</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code>	return t.newBreak(pos, line)</code></span>
<span class="codeline" id="line-434"><code>}</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>// Continue:</code></span>
<span class="codeline" id="line-437"><code>//</code></span>
<span class="codeline" id="line-438"><code>//	{{continue}}</code></span>
<span class="codeline" id="line-439"><code>//</code></span>
<span class="codeline" id="line-440"><code>// Continue keyword is past.</code></span>
<span class="codeline" id="line-441"><code>func (t *Tree) continueControl(pos Pos, line int) Node {</code></span>
<span class="codeline" id="line-442"><code>	if token := t.nextNonSpace(); token.typ != itemRightDelim {</code></span>
<span class="codeline" id="line-443"><code>		t.unexpected(token, "{{continue}}")</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code>	if t.rangeDepth == 0 {</code></span>
<span class="codeline" id="line-446"><code>		t.errorf("{{continue}} outside {{range}}")</code></span>
<span class="codeline" id="line-447"><code>	}</code></span>
<span class="codeline" id="line-448"><code>	return t.newContinue(pos, line)</code></span>
<span class="codeline" id="line-449"><code>}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>// Pipeline:</code></span>
<span class="codeline" id="line-452"><code>//</code></span>
<span class="codeline" id="line-453"><code>//	declarations? command ('|' command)*</code></span>
<span class="codeline" id="line-454"><code>func (t *Tree) pipeline(context string, end itemType) (pipe *PipeNode) {</code></span>
<span class="codeline" id="line-455"><code>	token := t.peekNonSpace()</code></span>
<span class="codeline" id="line-456"><code>	pipe = t.newPipeline(token.pos, token.line, nil)</code></span>
<span class="codeline" id="line-457"><code>	// Are there declarations or assignments?</code></span>
<span class="codeline" id="line-458"><code>decls:</code></span>
<span class="codeline" id="line-459"><code>	if v := t.peekNonSpace(); v.typ == itemVariable {</code></span>
<span class="codeline" id="line-460"><code>		t.next()</code></span>
<span class="codeline" id="line-461"><code>		// Since space is a token, we need 3-token look-ahead here in the worst case:</code></span>
<span class="codeline" id="line-462"><code>		// in "$x foo" we need to read "foo" (as opposed to ":=") to know that $x is an</code></span>
<span class="codeline" id="line-463"><code>		// argument variable rather than a declaration. So remember the token</code></span>
<span class="codeline" id="line-464"><code>		// adjacent to the variable so we can push it back if necessary.</code></span>
<span class="codeline" id="line-465"><code>		tokenAfterVariable := t.peek()</code></span>
<span class="codeline" id="line-466"><code>		next := t.peekNonSpace()</code></span>
<span class="codeline" id="line-467"><code>		switch {</code></span>
<span class="codeline" id="line-468"><code>		case next.typ == itemAssign, next.typ == itemDeclare:</code></span>
<span class="codeline" id="line-469"><code>			pipe.IsAssign = next.typ == itemAssign</code></span>
<span class="codeline" id="line-470"><code>			t.nextNonSpace()</code></span>
<span class="codeline" id="line-471"><code>			pipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))</code></span>
<span class="codeline" id="line-472"><code>			t.vars = append(t.vars, v.val)</code></span>
<span class="codeline" id="line-473"><code>		case next.typ == itemChar &amp;&amp; next.val == ",":</code></span>
<span class="codeline" id="line-474"><code>			t.nextNonSpace()</code></span>
<span class="codeline" id="line-475"><code>			pipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))</code></span>
<span class="codeline" id="line-476"><code>			t.vars = append(t.vars, v.val)</code></span>
<span class="codeline" id="line-477"><code>			if context == "range" &amp;&amp; len(pipe.Decl) &lt; 2 {</code></span>
<span class="codeline" id="line-478"><code>				switch t.peekNonSpace().typ {</code></span>
<span class="codeline" id="line-479"><code>				case itemVariable, itemRightDelim, itemRightParen:</code></span>
<span class="codeline" id="line-480"><code>					// second initialized variable in a range pipeline</code></span>
<span class="codeline" id="line-481"><code>					goto decls</code></span>
<span class="codeline" id="line-482"><code>				default:</code></span>
<span class="codeline" id="line-483"><code>					t.errorf("range can only initialize variables")</code></span>
<span class="codeline" id="line-484"><code>				}</code></span>
<span class="codeline" id="line-485"><code>			}</code></span>
<span class="codeline" id="line-486"><code>			t.errorf("too many declarations in %s", context)</code></span>
<span class="codeline" id="line-487"><code>		case tokenAfterVariable.typ == itemSpace:</code></span>
<span class="codeline" id="line-488"><code>			t.backup3(v, tokenAfterVariable)</code></span>
<span class="codeline" id="line-489"><code>		default:</code></span>
<span class="codeline" id="line-490"><code>			t.backup2(v)</code></span>
<span class="codeline" id="line-491"><code>		}</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code>	for {</code></span>
<span class="codeline" id="line-494"><code>		switch token := t.nextNonSpace(); token.typ {</code></span>
<span class="codeline" id="line-495"><code>		case end:</code></span>
<span class="codeline" id="line-496"><code>			// At this point, the pipeline is complete</code></span>
<span class="codeline" id="line-497"><code>			t.checkPipeline(pipe, context)</code></span>
<span class="codeline" id="line-498"><code>			return</code></span>
<span class="codeline" id="line-499"><code>		case itemBool, itemCharConstant, itemComplex, itemDot, itemField, itemIdentifier,</code></span>
<span class="codeline" id="line-500"><code>			itemNumber, itemNil, itemRawString, itemString, itemVariable, itemLeftParen:</code></span>
<span class="codeline" id="line-501"><code>			t.backup()</code></span>
<span class="codeline" id="line-502"><code>			pipe.append(t.command())</code></span>
<span class="codeline" id="line-503"><code>		default:</code></span>
<span class="codeline" id="line-504"><code>			t.unexpected(token, context)</code></span>
<span class="codeline" id="line-505"><code>		}</code></span>
<span class="codeline" id="line-506"><code>	}</code></span>
<span class="codeline" id="line-507"><code>}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>func (t *Tree) checkPipeline(pipe *PipeNode, context string) {</code></span>
<span class="codeline" id="line-510"><code>	// Reject empty pipelines</code></span>
<span class="codeline" id="line-511"><code>	if len(pipe.Cmds) == 0 {</code></span>
<span class="codeline" id="line-512"><code>		t.errorf("missing value for %s", context)</code></span>
<span class="codeline" id="line-513"><code>	}</code></span>
<span class="codeline" id="line-514"><code>	// Only the first command of a pipeline can start with a non executable operand</code></span>
<span class="codeline" id="line-515"><code>	for i, c := range pipe.Cmds[1:] {</code></span>
<span class="codeline" id="line-516"><code>		switch c.Args[0].Type() {</code></span>
<span class="codeline" id="line-517"><code>		case NodeBool, NodeDot, NodeNil, NodeNumber, NodeString:</code></span>
<span class="codeline" id="line-518"><code>			// With A|B|C, pipeline stage 2 is B</code></span>
<span class="codeline" id="line-519"><code>			t.errorf("non executable command in pipeline stage %d", i+2)</code></span>
<span class="codeline" id="line-520"><code>		}</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code>}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) {</code></span>
<span class="codeline" id="line-525"><code>	defer t.popVars(len(t.vars))</code></span>
<span class="codeline" id="line-526"><code>	pipe = t.pipeline(context, itemRightDelim)</code></span>
<span class="codeline" id="line-527"><code>	if context == "range" {</code></span>
<span class="codeline" id="line-528"><code>		t.rangeDepth++</code></span>
<span class="codeline" id="line-529"><code>	}</code></span>
<span class="codeline" id="line-530"><code>	var next Node</code></span>
<span class="codeline" id="line-531"><code>	list, next = t.itemList()</code></span>
<span class="codeline" id="line-532"><code>	if context == "range" {</code></span>
<span class="codeline" id="line-533"><code>		t.rangeDepth--</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>	switch next.Type() {</code></span>
<span class="codeline" id="line-536"><code>	case nodeEnd: //done</code></span>
<span class="codeline" id="line-537"><code>	case nodeElse:</code></span>
<span class="codeline" id="line-538"><code>		if allowElseIf {</code></span>
<span class="codeline" id="line-539"><code>			// Special case for "else if". If the "else" is followed immediately by an "if",</code></span>
<span class="codeline" id="line-540"><code>			// the elseControl will have left the "if" token pending. Treat</code></span>
<span class="codeline" id="line-541"><code>			//	{{if a}}_{{else if b}}_{{end}}</code></span>
<span class="codeline" id="line-542"><code>			// as</code></span>
<span class="codeline" id="line-543"><code>			//	{{if a}}_{{else}}{{if b}}_{{end}}{{end}}.</code></span>
<span class="codeline" id="line-544"><code>			// To do this, parse the if as usual and stop at it {{end}}; the subsequent{{end}}</code></span>
<span class="codeline" id="line-545"><code>			// is assumed. This technique works even for long if-else-if chains.</code></span>
<span class="codeline" id="line-546"><code>			// TODO: Should we allow else-if in with and range?</code></span>
<span class="codeline" id="line-547"><code>			if t.peek().typ == itemIf {</code></span>
<span class="codeline" id="line-548"><code>				t.next() // Consume the "if" token.</code></span>
<span class="codeline" id="line-549"><code>				elseList = t.newList(next.Position())</code></span>
<span class="codeline" id="line-550"><code>				elseList.append(t.ifControl())</code></span>
<span class="codeline" id="line-551"><code>				// Do not consume the next item - only one {{end}} required.</code></span>
<span class="codeline" id="line-552"><code>				break</code></span>
<span class="codeline" id="line-553"><code>			}</code></span>
<span class="codeline" id="line-554"><code>		}</code></span>
<span class="codeline" id="line-555"><code>		elseList, next = t.itemList()</code></span>
<span class="codeline" id="line-556"><code>		if next.Type() != nodeEnd {</code></span>
<span class="codeline" id="line-557"><code>			t.errorf("expected end; found %s", next)</code></span>
<span class="codeline" id="line-558"><code>		}</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code>	return pipe.Position(), pipe.Line, pipe, list, elseList</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>// If:</code></span>
<span class="codeline" id="line-564"><code>//</code></span>
<span class="codeline" id="line-565"><code>//	{{if pipeline}} itemList {{end}}</code></span>
<span class="codeline" id="line-566"><code>//	{{if pipeline}} itemList {{else}} itemList {{end}}</code></span>
<span class="codeline" id="line-567"><code>//</code></span>
<span class="codeline" id="line-568"><code>// If keyword is past.</code></span>
<span class="codeline" id="line-569"><code>func (t *Tree) ifControl() Node {</code></span>
<span class="codeline" id="line-570"><code>	return t.newIf(t.parseControl(true, "if"))</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// Range:</code></span>
<span class="codeline" id="line-574"><code>//</code></span>
<span class="codeline" id="line-575"><code>//	{{range pipeline}} itemList {{end}}</code></span>
<span class="codeline" id="line-576"><code>//	{{range pipeline}} itemList {{else}} itemList {{end}}</code></span>
<span class="codeline" id="line-577"><code>//</code></span>
<span class="codeline" id="line-578"><code>// Range keyword is past.</code></span>
<span class="codeline" id="line-579"><code>func (t *Tree) rangeControl() Node {</code></span>
<span class="codeline" id="line-580"><code>	r := t.newRange(t.parseControl(false, "range"))</code></span>
<span class="codeline" id="line-581"><code>	return r</code></span>
<span class="codeline" id="line-582"><code>}</code></span>
<span class="codeline" id="line-583"><code></code></span>
<span class="codeline" id="line-584"><code>// With:</code></span>
<span class="codeline" id="line-585"><code>//</code></span>
<span class="codeline" id="line-586"><code>//	{{with pipeline}} itemList {{end}}</code></span>
<span class="codeline" id="line-587"><code>//	{{with pipeline}} itemList {{else}} itemList {{end}}</code></span>
<span class="codeline" id="line-588"><code>//</code></span>
<span class="codeline" id="line-589"><code>// If keyword is past.</code></span>
<span class="codeline" id="line-590"><code>func (t *Tree) withControl() Node {</code></span>
<span class="codeline" id="line-591"><code>	return t.newWith(t.parseControl(false, "with"))</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>// End:</code></span>
<span class="codeline" id="line-595"><code>//</code></span>
<span class="codeline" id="line-596"><code>//	{{end}}</code></span>
<span class="codeline" id="line-597"><code>//</code></span>
<span class="codeline" id="line-598"><code>// End keyword is past.</code></span>
<span class="codeline" id="line-599"><code>func (t *Tree) endControl() Node {</code></span>
<span class="codeline" id="line-600"><code>	return t.newEnd(t.expect(itemRightDelim, "end").pos)</code></span>
<span class="codeline" id="line-601"><code>}</code></span>
<span class="codeline" id="line-602"><code></code></span>
<span class="codeline" id="line-603"><code>// Else:</code></span>
<span class="codeline" id="line-604"><code>//</code></span>
<span class="codeline" id="line-605"><code>//	{{else}}</code></span>
<span class="codeline" id="line-606"><code>//</code></span>
<span class="codeline" id="line-607"><code>// Else keyword is past.</code></span>
<span class="codeline" id="line-608"><code>func (t *Tree) elseControl() Node {</code></span>
<span class="codeline" id="line-609"><code>	// Special case for "else if".</code></span>
<span class="codeline" id="line-610"><code>	peek := t.peekNonSpace()</code></span>
<span class="codeline" id="line-611"><code>	if peek.typ == itemIf {</code></span>
<span class="codeline" id="line-612"><code>		// We see "{{else if ... " but in effect rewrite it to {{else}}{{if ... ".</code></span>
<span class="codeline" id="line-613"><code>		return t.newElse(peek.pos, peek.line)</code></span>
<span class="codeline" id="line-614"><code>	}</code></span>
<span class="codeline" id="line-615"><code>	token := t.expect(itemRightDelim, "else")</code></span>
<span class="codeline" id="line-616"><code>	return t.newElse(token.pos, token.line)</code></span>
<span class="codeline" id="line-617"><code>}</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>// Block:</code></span>
<span class="codeline" id="line-620"><code>//</code></span>
<span class="codeline" id="line-621"><code>//	{{block stringValue pipeline}}</code></span>
<span class="codeline" id="line-622"><code>//</code></span>
<span class="codeline" id="line-623"><code>// Block keyword is past.</code></span>
<span class="codeline" id="line-624"><code>// The name must be something that can evaluate to a string.</code></span>
<span class="codeline" id="line-625"><code>// The pipeline is mandatory.</code></span>
<span class="codeline" id="line-626"><code>func (t *Tree) blockControl() Node {</code></span>
<span class="codeline" id="line-627"><code>	const context = "block clause"</code></span>
<span class="codeline" id="line-628"><code></code></span>
<span class="codeline" id="line-629"><code>	token := t.nextNonSpace()</code></span>
<span class="codeline" id="line-630"><code>	name := t.parseTemplateName(token, context)</code></span>
<span class="codeline" id="line-631"><code>	pipe := t.pipeline(context, itemRightDelim)</code></span>
<span class="codeline" id="line-632"><code></code></span>
<span class="codeline" id="line-633"><code>	block := New(name) // name will be updated once we know it.</code></span>
<span class="codeline" id="line-634"><code>	block.text = t.text</code></span>
<span class="codeline" id="line-635"><code>	block.Mode = t.Mode</code></span>
<span class="codeline" id="line-636"><code>	block.ParseName = t.ParseName</code></span>
<span class="codeline" id="line-637"><code>	block.startParse(t.funcs, t.lex, t.treeSet)</code></span>
<span class="codeline" id="line-638"><code>	var end Node</code></span>
<span class="codeline" id="line-639"><code>	block.Root, end = block.itemList()</code></span>
<span class="codeline" id="line-640"><code>	if end.Type() != nodeEnd {</code></span>
<span class="codeline" id="line-641"><code>		t.errorf("unexpected %s in %s", end, context)</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code>	block.add()</code></span>
<span class="codeline" id="line-644"><code>	block.stopParse()</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>	return t.newTemplate(token.pos, token.line, name, pipe)</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>// Template:</code></span>
<span class="codeline" id="line-650"><code>//</code></span>
<span class="codeline" id="line-651"><code>//	{{template stringValue pipeline}}</code></span>
<span class="codeline" id="line-652"><code>//</code></span>
<span class="codeline" id="line-653"><code>// Template keyword is past. The name must be something that can evaluate</code></span>
<span class="codeline" id="line-654"><code>// to a string.</code></span>
<span class="codeline" id="line-655"><code>func (t *Tree) templateControl() Node {</code></span>
<span class="codeline" id="line-656"><code>	const context = "template clause"</code></span>
<span class="codeline" id="line-657"><code>	token := t.nextNonSpace()</code></span>
<span class="codeline" id="line-658"><code>	name := t.parseTemplateName(token, context)</code></span>
<span class="codeline" id="line-659"><code>	var pipe *PipeNode</code></span>
<span class="codeline" id="line-660"><code>	if t.nextNonSpace().typ != itemRightDelim {</code></span>
<span class="codeline" id="line-661"><code>		t.backup()</code></span>
<span class="codeline" id="line-662"><code>		// Do not pop variables; they persist until "end".</code></span>
<span class="codeline" id="line-663"><code>		pipe = t.pipeline(context, itemRightDelim)</code></span>
<span class="codeline" id="line-664"><code>	}</code></span>
<span class="codeline" id="line-665"><code>	return t.newTemplate(token.pos, token.line, name, pipe)</code></span>
<span class="codeline" id="line-666"><code>}</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>func (t *Tree) parseTemplateName(token item, context string) (name string) {</code></span>
<span class="codeline" id="line-669"><code>	switch token.typ {</code></span>
<span class="codeline" id="line-670"><code>	case itemString, itemRawString:</code></span>
<span class="codeline" id="line-671"><code>		s, err := strconv.Unquote(token.val)</code></span>
<span class="codeline" id="line-672"><code>		if err != nil {</code></span>
<span class="codeline" id="line-673"><code>			t.error(err)</code></span>
<span class="codeline" id="line-674"><code>		}</code></span>
<span class="codeline" id="line-675"><code>		name = s</code></span>
<span class="codeline" id="line-676"><code>	default:</code></span>
<span class="codeline" id="line-677"><code>		t.unexpected(token, context)</code></span>
<span class="codeline" id="line-678"><code>	}</code></span>
<span class="codeline" id="line-679"><code>	return</code></span>
<span class="codeline" id="line-680"><code>}</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>// command:</code></span>
<span class="codeline" id="line-683"><code>//</code></span>
<span class="codeline" id="line-684"><code>//	operand (space operand)*</code></span>
<span class="codeline" id="line-685"><code>//</code></span>
<span class="codeline" id="line-686"><code>// space-separated arguments up to a pipeline character or right delimiter.</code></span>
<span class="codeline" id="line-687"><code>// we consume the pipe character but leave the right delim to terminate the action.</code></span>
<span class="codeline" id="line-688"><code>func (t *Tree) command() *CommandNode {</code></span>
<span class="codeline" id="line-689"><code>	cmd := t.newCommand(t.peekNonSpace().pos)</code></span>
<span class="codeline" id="line-690"><code>	for {</code></span>
<span class="codeline" id="line-691"><code>		t.peekNonSpace() // skip leading spaces.</code></span>
<span class="codeline" id="line-692"><code>		operand := t.operand()</code></span>
<span class="codeline" id="line-693"><code>		if operand != nil {</code></span>
<span class="codeline" id="line-694"><code>			cmd.append(operand)</code></span>
<span class="codeline" id="line-695"><code>		}</code></span>
<span class="codeline" id="line-696"><code>		switch token := t.next(); token.typ {</code></span>
<span class="codeline" id="line-697"><code>		case itemSpace:</code></span>
<span class="codeline" id="line-698"><code>			continue</code></span>
<span class="codeline" id="line-699"><code>		case itemRightDelim, itemRightParen:</code></span>
<span class="codeline" id="line-700"><code>			t.backup()</code></span>
<span class="codeline" id="line-701"><code>		case itemPipe:</code></span>
<span class="codeline" id="line-702"><code>			// nothing here; break loop below</code></span>
<span class="codeline" id="line-703"><code>		default:</code></span>
<span class="codeline" id="line-704"><code>			t.unexpected(token, "operand")</code></span>
<span class="codeline" id="line-705"><code>		}</code></span>
<span class="codeline" id="line-706"><code>		break</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	if len(cmd.Args) == 0 {</code></span>
<span class="codeline" id="line-709"><code>		t.errorf("empty command")</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>	return cmd</code></span>
<span class="codeline" id="line-712"><code>}</code></span>
<span class="codeline" id="line-713"><code></code></span>
<span class="codeline" id="line-714"><code>// operand:</code></span>
<span class="codeline" id="line-715"><code>//</code></span>
<span class="codeline" id="line-716"><code>//	term .Field*</code></span>
<span class="codeline" id="line-717"><code>//</code></span>
<span class="codeline" id="line-718"><code>// An operand is a space-separated component of a command,</code></span>
<span class="codeline" id="line-719"><code>// a term possibly followed by field accesses.</code></span>
<span class="codeline" id="line-720"><code>// A nil return means the next item is not an operand.</code></span>
<span class="codeline" id="line-721"><code>func (t *Tree) operand() Node {</code></span>
<span class="codeline" id="line-722"><code>	node := t.term()</code></span>
<span class="codeline" id="line-723"><code>	if node == nil {</code></span>
<span class="codeline" id="line-724"><code>		return nil</code></span>
<span class="codeline" id="line-725"><code>	}</code></span>
<span class="codeline" id="line-726"><code>	if t.peek().typ == itemField {</code></span>
<span class="codeline" id="line-727"><code>		chain := t.newChain(t.peek().pos, node)</code></span>
<span class="codeline" id="line-728"><code>		for t.peek().typ == itemField {</code></span>
<span class="codeline" id="line-729"><code>			chain.Add(t.next().val)</code></span>
<span class="codeline" id="line-730"><code>		}</code></span>
<span class="codeline" id="line-731"><code>		// Compatibility with original API: If the term is of type NodeField</code></span>
<span class="codeline" id="line-732"><code>		// or NodeVariable, just put more fields on the original.</code></span>
<span class="codeline" id="line-733"><code>		// Otherwise, keep the Chain node.</code></span>
<span class="codeline" id="line-734"><code>		// Obvious parsing errors involving literal values are detected here.</code></span>
<span class="codeline" id="line-735"><code>		// More complex error cases will have to be handled at execution time.</code></span>
<span class="codeline" id="line-736"><code>		switch node.Type() {</code></span>
<span class="codeline" id="line-737"><code>		case NodeField:</code></span>
<span class="codeline" id="line-738"><code>			node = t.newField(chain.Position(), chain.String())</code></span>
<span class="codeline" id="line-739"><code>		case NodeVariable:</code></span>
<span class="codeline" id="line-740"><code>			node = t.newVariable(chain.Position(), chain.String())</code></span>
<span class="codeline" id="line-741"><code>		case NodeBool, NodeString, NodeNumber, NodeNil, NodeDot:</code></span>
<span class="codeline" id="line-742"><code>			t.errorf("unexpected . after term %q", node.String())</code></span>
<span class="codeline" id="line-743"><code>		default:</code></span>
<span class="codeline" id="line-744"><code>			node = chain</code></span>
<span class="codeline" id="line-745"><code>		}</code></span>
<span class="codeline" id="line-746"><code>	}</code></span>
<span class="codeline" id="line-747"><code>	return node</code></span>
<span class="codeline" id="line-748"><code>}</code></span>
<span class="codeline" id="line-749"><code></code></span>
<span class="codeline" id="line-750"><code>// term:</code></span>
<span class="codeline" id="line-751"><code>//</code></span>
<span class="codeline" id="line-752"><code>//	literal (number, string, nil, boolean)</code></span>
<span class="codeline" id="line-753"><code>//	function (identifier)</code></span>
<span class="codeline" id="line-754"><code>//	.</code></span>
<span class="codeline" id="line-755"><code>//	.Field</code></span>
<span class="codeline" id="line-756"><code>//	$</code></span>
<span class="codeline" id="line-757"><code>//	'(' pipeline ')'</code></span>
<span class="codeline" id="line-758"><code>//</code></span>
<span class="codeline" id="line-759"><code>// A term is a simple "expression".</code></span>
<span class="codeline" id="line-760"><code>// A nil return means the next item is not a term.</code></span>
<span class="codeline" id="line-761"><code>func (t *Tree) term() Node {</code></span>
<span class="codeline" id="line-762"><code>	switch token := t.nextNonSpace(); token.typ {</code></span>
<span class="codeline" id="line-763"><code>	case itemIdentifier:</code></span>
<span class="codeline" id="line-764"><code>		checkFunc := t.Mode&amp;SkipFuncCheck == 0</code></span>
<span class="codeline" id="line-765"><code>		if checkFunc &amp;&amp; !t.hasFunction(token.val) {</code></span>
<span class="codeline" id="line-766"><code>			t.errorf("function %q not defined", token.val)</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code>		return NewIdentifier(token.val).SetTree(t).SetPos(token.pos)</code></span>
<span class="codeline" id="line-769"><code>	case itemDot:</code></span>
<span class="codeline" id="line-770"><code>		return t.newDot(token.pos)</code></span>
<span class="codeline" id="line-771"><code>	case itemNil:</code></span>
<span class="codeline" id="line-772"><code>		return t.newNil(token.pos)</code></span>
<span class="codeline" id="line-773"><code>	case itemVariable:</code></span>
<span class="codeline" id="line-774"><code>		return t.useVar(token.pos, token.val)</code></span>
<span class="codeline" id="line-775"><code>	case itemField:</code></span>
<span class="codeline" id="line-776"><code>		return t.newField(token.pos, token.val)</code></span>
<span class="codeline" id="line-777"><code>	case itemBool:</code></span>
<span class="codeline" id="line-778"><code>		return t.newBool(token.pos, token.val == "true")</code></span>
<span class="codeline" id="line-779"><code>	case itemCharConstant, itemComplex, itemNumber:</code></span>
<span class="codeline" id="line-780"><code>		number, err := t.newNumber(token.pos, token.val, token.typ)</code></span>
<span class="codeline" id="line-781"><code>		if err != nil {</code></span>
<span class="codeline" id="line-782"><code>			t.error(err)</code></span>
<span class="codeline" id="line-783"><code>		}</code></span>
<span class="codeline" id="line-784"><code>		return number</code></span>
<span class="codeline" id="line-785"><code>	case itemLeftParen:</code></span>
<span class="codeline" id="line-786"><code>		return t.pipeline("parenthesized pipeline", itemRightParen)</code></span>
<span class="codeline" id="line-787"><code>	case itemString, itemRawString:</code></span>
<span class="codeline" id="line-788"><code>		s, err := strconv.Unquote(token.val)</code></span>
<span class="codeline" id="line-789"><code>		if err != nil {</code></span>
<span class="codeline" id="line-790"><code>			t.error(err)</code></span>
<span class="codeline" id="line-791"><code>		}</code></span>
<span class="codeline" id="line-792"><code>		return t.newString(token.pos, token.val, s)</code></span>
<span class="codeline" id="line-793"><code>	}</code></span>
<span class="codeline" id="line-794"><code>	t.backup()</code></span>
<span class="codeline" id="line-795"><code>	return nil</code></span>
<span class="codeline" id="line-796"><code>}</code></span>
<span class="codeline" id="line-797"><code></code></span>
<span class="codeline" id="line-798"><code>// hasFunction reports if a function name exists in the Tree's maps.</code></span>
<span class="codeline" id="line-799"><code>func (t *Tree) hasFunction(name string) bool {</code></span>
<span class="codeline" id="line-800"><code>	for _, funcMap := range t.funcs {</code></span>
<span class="codeline" id="line-801"><code>		if funcMap == nil {</code></span>
<span class="codeline" id="line-802"><code>			continue</code></span>
<span class="codeline" id="line-803"><code>		}</code></span>
<span class="codeline" id="line-804"><code>		if funcMap[name] != nil {</code></span>
<span class="codeline" id="line-805"><code>			return true</code></span>
<span class="codeline" id="line-806"><code>		}</code></span>
<span class="codeline" id="line-807"><code>	}</code></span>
<span class="codeline" id="line-808"><code>	return false</code></span>
<span class="codeline" id="line-809"><code>}</code></span>
<span class="codeline" id="line-810"><code></code></span>
<span class="codeline" id="line-811"><code>// popVars trims the variable list to the specified length</code></span>
<span class="codeline" id="line-812"><code>func (t *Tree) popVars(n int) {</code></span>
<span class="codeline" id="line-813"><code>	t.vars = t.vars[:n]</code></span>
<span class="codeline" id="line-814"><code>}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>// useVar returns a node for a variable reference. It errors if the</code></span>
<span class="codeline" id="line-817"><code>// variable is not defined.</code></span>
<span class="codeline" id="line-818"><code>func (t *Tree) useVar(pos Pos, name string) Node {</code></span>
<span class="codeline" id="line-819"><code>	v := t.newVariable(pos, name)</code></span>
<span class="codeline" id="line-820"><code>	for _, varName := range t.vars {</code></span>
<span class="codeline" id="line-821"><code>		if varName == v.Ident[0] {</code></span>
<span class="codeline" id="line-822"><code>			return v</code></span>
<span class="codeline" id="line-823"><code>		}</code></span>
<span class="codeline" id="line-824"><code>	}</code></span>
<span class="codeline" id="line-825"><code>	t.errorf("undefined variable %q", v.Ident[0])</code></span>
<span class="codeline" id="line-826"><code>	return nil</code></span>
<span class="codeline" id="line-827"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>