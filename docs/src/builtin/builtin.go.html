<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: builtin.go in package builtin</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	builtin.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/builtin.html">builtin</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>Package builtin provides documentation for Go's predeclared identifiers.</code></span>
<span class="codeline" id="line-7"><code>The items documented here are not actually in package builtin</code></span>
<span class="codeline" id="line-8"><code>but their descriptions here allow godoc to present documentation</code></span>
<span class="codeline" id="line-9"><code>for the language's special identifiers.</code></span>
<span class="codeline" id="line-10"><code>*/</code></span></div><span class="codeline" id="line-11"><code>package builtin</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>import "cmp"</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// bool is the set of boolean values, true and false.</code></span>
<span class="codeline" id="line-16"><code>type bool bool</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// true and false are the two untyped boolean values.</code></span>
<span class="codeline" id="line-19"><code>const (</code></span>
<span class="codeline" id="line-20"><code>	true  = 0 == 0 // Untyped bool.</code></span>
<span class="codeline" id="line-21"><code>	false = 0 != 0 // Untyped bool.</code></span>
<span class="codeline" id="line-22"><code>)</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>// uint8 is the set of all unsigned 8-bit integers.</code></span>
<span class="codeline" id="line-25"><code>// Range: 0 through 255.</code></span>
<span class="codeline" id="line-26"><code>type uint8 uint8</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>// uint16 is the set of all unsigned 16-bit integers.</code></span>
<span class="codeline" id="line-29"><code>// Range: 0 through 65535.</code></span>
<span class="codeline" id="line-30"><code>type uint16 uint16</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// uint32 is the set of all unsigned 32-bit integers.</code></span>
<span class="codeline" id="line-33"><code>// Range: 0 through 4294967295.</code></span>
<span class="codeline" id="line-34"><code>type uint32 uint32</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// uint64 is the set of all unsigned 64-bit integers.</code></span>
<span class="codeline" id="line-37"><code>// Range: 0 through 18446744073709551615.</code></span>
<span class="codeline" id="line-38"><code>type uint64 uint64</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>// int8 is the set of all signed 8-bit integers.</code></span>
<span class="codeline" id="line-41"><code>// Range: -128 through 127.</code></span>
<span class="codeline" id="line-42"><code>type int8 int8</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>// int16 is the set of all signed 16-bit integers.</code></span>
<span class="codeline" id="line-45"><code>// Range: -32768 through 32767.</code></span>
<span class="codeline" id="line-46"><code>type int16 int16</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>// int32 is the set of all signed 32-bit integers.</code></span>
<span class="codeline" id="line-49"><code>// Range: -2147483648 through 2147483647.</code></span>
<span class="codeline" id="line-50"><code>type int32 int32</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>// int64 is the set of all signed 64-bit integers.</code></span>
<span class="codeline" id="line-53"><code>// Range: -9223372036854775808 through 9223372036854775807.</code></span>
<span class="codeline" id="line-54"><code>type int64 int64</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>// float32 is the set of all IEEE-754 32-bit floating-point numbers.</code></span>
<span class="codeline" id="line-57"><code>type float32 float32</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>// float64 is the set of all IEEE-754 64-bit floating-point numbers.</code></span>
<span class="codeline" id="line-60"><code>type float64 float64</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// complex64 is the set of all complex numbers with float32 real and</code></span>
<span class="codeline" id="line-63"><code>// imaginary parts.</code></span>
<span class="codeline" id="line-64"><code>type complex64 complex64</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// complex128 is the set of all complex numbers with float64 real and</code></span>
<span class="codeline" id="line-67"><code>// imaginary parts.</code></span>
<span class="codeline" id="line-68"><code>type complex128 complex128</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// string is the set of all strings of 8-bit bytes, conventionally but not</code></span>
<span class="codeline" id="line-71"><code>// necessarily representing UTF-8-encoded text. A string may be empty, but</code></span>
<span class="codeline" id="line-72"><code>// not nil. Values of string type are immutable.</code></span>
<span class="codeline" id="line-73"><code>type string string</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>// int is a signed integer type that is at least 32 bits in size. It is a</code></span>
<span class="codeline" id="line-76"><code>// distinct type, however, and not an alias for, say, int32.</code></span>
<span class="codeline" id="line-77"><code>type int int</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// uint is an unsigned integer type that is at least 32 bits in size. It is a</code></span>
<span class="codeline" id="line-80"><code>// distinct type, however, and not an alias for, say, uint32.</code></span>
<span class="codeline" id="line-81"><code>type uint uint</code></span>
<span class="codeline" id="line-82"><code></code></span>
<span class="codeline" id="line-83"><code>// uintptr is an integer type that is large enough to hold the bit pattern of</code></span>
<span class="codeline" id="line-84"><code>// any pointer.</code></span>
<span class="codeline" id="line-85"><code>type uintptr uintptr</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</code></span>
<span class="codeline" id="line-88"><code>// used, by convention, to distinguish byte values from 8-bit unsigned</code></span>
<span class="codeline" id="line-89"><code>// integer values.</code></span>
<span class="codeline" id="line-90"><code>type byte = uint8</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// rune is an alias for int32 and is equivalent to int32 in all ways. It is</code></span>
<span class="codeline" id="line-93"><code>// used, by convention, to distinguish character values from integer values.</code></span>
<span class="codeline" id="line-94"><code>type rune = int32</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>// any is an alias for interface{} and is equivalent to interface{} in all ways.</code></span>
<span class="codeline" id="line-97"><code>type any = interface{}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>// comparable is an interface that is implemented by all comparable types</code></span>
<span class="codeline" id="line-100"><code>// (booleans, numbers, strings, pointers, channels, arrays of comparable types,</code></span>
<span class="codeline" id="line-101"><code>// structs whose fields are all comparable types).</code></span>
<span class="codeline" id="line-102"><code>// The comparable interface may only be used as a type parameter constraint,</code></span>
<span class="codeline" id="line-103"><code>// not as the type of a variable.</code></span>
<span class="codeline" id="line-104"><code>type comparable interface{ comparable }</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>// iota is a predeclared identifier representing the untyped integer ordinal</code></span>
<span class="codeline" id="line-107"><code>// number of the current const specification in a (usually parenthesized)</code></span>
<span class="codeline" id="line-108"><code>// const declaration. It is zero-indexed.</code></span>
<span class="codeline" id="line-109"><code>const iota = 0 // Untyped int.</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>// nil is a predeclared identifier representing the zero value for a</code></span>
<span class="codeline" id="line-112"><code>// pointer, channel, func, interface, map, or slice type.</code></span>
<span class="codeline" id="line-113"><code>var nil Type // Type must be a pointer, channel, func, interface, map, or slice type</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// Type is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-116"><code>// for any Go type, but represents the same type for any given function</code></span>
<span class="codeline" id="line-117"><code>// invocation.</code></span>
<span class="codeline" id="line-118"><code>type Type int</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>// Type1 is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-121"><code>// for any Go type, but represents the same type for any given function</code></span>
<span class="codeline" id="line-122"><code>// invocation.</code></span>
<span class="codeline" id="line-123"><code>type Type1 int</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>// IntegerType is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-126"><code>// for any integer type: int, uint, int8 etc.</code></span>
<span class="codeline" id="line-127"><code>type IntegerType int</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// FloatType is here for the purposes of documentation only. It is a stand-in</code></span>
<span class="codeline" id="line-130"><code>// for either float type: float32 or float64.</code></span>
<span class="codeline" id="line-131"><code>type FloatType float32</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>// ComplexType is here for the purposes of documentation only. It is a</code></span>
<span class="codeline" id="line-134"><code>// stand-in for either complex type: complex64 or complex128.</code></span>
<span class="codeline" id="line-135"><code>type ComplexType complex64</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>// The append built-in function appends elements to the end of a slice. If</code></span>
<span class="codeline" id="line-138"><code>// it has sufficient capacity, the destination is resliced to accommodate the</code></span>
<span class="codeline" id="line-139"><code>// new elements. If it does not, a new underlying array will be allocated.</code></span>
<span class="codeline" id="line-140"><code>// Append returns the updated slice. It is therefore necessary to store the</code></span>
<span class="codeline" id="line-141"><code>// result of append, often in the variable holding the slice itself:</code></span>
<span class="codeline" id="line-142"><code>//</code></span>
<span class="codeline" id="line-143"><code>//	slice = append(slice, elem1, elem2)</code></span>
<span class="codeline" id="line-144"><code>//	slice = append(slice, anotherSlice...)</code></span>
<span class="codeline" id="line-145"><code>//</code></span>
<span class="codeline" id="line-146"><code>// As a special case, it is legal to append a string to a byte slice, like this:</code></span>
<span class="codeline" id="line-147"><code>//</code></span>
<span class="codeline" id="line-148"><code>//	slice = append([]byte("hello "), "world"...)</code></span>
<span class="codeline" id="line-149"><code>func append(slice []Type, elems ...Type) []Type</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// The copy built-in function copies elements from a source slice into a</code></span>
<span class="codeline" id="line-152"><code>// destination slice. (As a special case, it also will copy bytes from a</code></span>
<span class="codeline" id="line-153"><code>// string to a slice of bytes.) The source and destination may overlap. Copy</code></span>
<span class="codeline" id="line-154"><code>// returns the number of elements copied, which will be the minimum of</code></span>
<span class="codeline" id="line-155"><code>// len(src) and len(dst).</code></span>
<span class="codeline" id="line-156"><code>func copy(dst, src []Type) int</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>// The delete built-in function deletes the element with the specified key</code></span>
<span class="codeline" id="line-159"><code>// (m[key]) from the map. If m is nil or there is no such element, delete</code></span>
<span class="codeline" id="line-160"><code>// is a no-op.</code></span>
<span class="codeline" id="line-161"><code>func delete(m map[Type]Type1, key Type)</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// The len built-in function returns the length of v, according to its type:</code></span>
<span class="codeline" id="line-164"><code>//</code></span>
<span class="codeline" id="line-165"><code>//	Array: the number of elements in v.</code></span>
<span class="codeline" id="line-166"><code>//	Pointer to array: the number of elements in *v (even if v is nil).</code></span>
<span class="codeline" id="line-167"><code>//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.</code></span>
<span class="codeline" id="line-168"><code>//	String: the number of bytes in v.</code></span>
<span class="codeline" id="line-169"><code>//	Channel: the number of elements queued (unread) in the channel buffer;</code></span>
<span class="codeline" id="line-170"><code>//	         if v is nil, len(v) is zero.</code></span>
<span class="codeline" id="line-171"><code>//</code></span>
<span class="codeline" id="line-172"><code>// For some arguments, such as a string literal or a simple array expression, the</code></span>
<span class="codeline" id="line-173"><code>// result can be a constant. See the Go language specification's "Length and</code></span>
<span class="codeline" id="line-174"><code>// capacity" section for details.</code></span>
<span class="codeline" id="line-175"><code>func len(v Type) int</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// The cap built-in function returns the capacity of v, according to its type:</code></span>
<span class="codeline" id="line-178"><code>//</code></span>
<span class="codeline" id="line-179"><code>//	Array: the number of elements in v (same as len(v)).</code></span>
<span class="codeline" id="line-180"><code>//	Pointer to array: the number of elements in *v (same as len(v)).</code></span>
<span class="codeline" id="line-181"><code>//	Slice: the maximum length the slice can reach when resliced;</code></span>
<span class="codeline" id="line-182"><code>//	if v is nil, cap(v) is zero.</code></span>
<span class="codeline" id="line-183"><code>//	Channel: the channel buffer capacity, in units of elements;</code></span>
<span class="codeline" id="line-184"><code>//	if v is nil, cap(v) is zero.</code></span>
<span class="codeline" id="line-185"><code>//</code></span>
<span class="codeline" id="line-186"><code>// For some arguments, such as a simple array expression, the result can be a</code></span>
<span class="codeline" id="line-187"><code>// constant. See the Go language specification's "Length and capacity" section for</code></span>
<span class="codeline" id="line-188"><code>// details.</code></span>
<span class="codeline" id="line-189"><code>func cap(v Type) int</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// The make built-in function allocates and initializes an object of type</code></span>
<span class="codeline" id="line-192"><code>// slice, map, or chan (only). Like new, the first argument is a type, not a</code></span>
<span class="codeline" id="line-193"><code>// value. Unlike new, make's return type is the same as the type of its</code></span>
<span class="codeline" id="line-194"><code>// argument, not a pointer to it. The specification of the result depends on</code></span>
<span class="codeline" id="line-195"><code>// the type:</code></span>
<span class="codeline" id="line-196"><code>//</code></span>
<span class="codeline" id="line-197"><code>//	Slice: The size specifies the length. The capacity of the slice is</code></span>
<span class="codeline" id="line-198"><code>//	equal to its length. A second integer argument may be provided to</code></span>
<span class="codeline" id="line-199"><code>//	specify a different capacity; it must be no smaller than the</code></span>
<span class="codeline" id="line-200"><code>//	length. For example, make([]int, 0, 10) allocates an underlying array</code></span>
<span class="codeline" id="line-201"><code>//	of size 10 and returns a slice of length 0 and capacity 10 that is</code></span>
<span class="codeline" id="line-202"><code>//	backed by this underlying array.</code></span>
<span class="codeline" id="line-203"><code>//	Map: An empty map is allocated with enough space to hold the</code></span>
<span class="codeline" id="line-204"><code>//	specified number of elements. The size may be omitted, in which case</code></span>
<span class="codeline" id="line-205"><code>//	a small starting size is allocated.</code></span>
<span class="codeline" id="line-206"><code>//	Channel: The channel's buffer is initialized with the specified</code></span>
<span class="codeline" id="line-207"><code>//	buffer capacity. If zero, or the size is omitted, the channel is</code></span>
<span class="codeline" id="line-208"><code>//	unbuffered.</code></span>
<span class="codeline" id="line-209"><code>func make(t Type, size ...IntegerType) Type</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>// The max built-in function returns the largest value of a fixed number of</code></span>
<span class="codeline" id="line-212"><code>// arguments of [cmp.Ordered] types. There must be at least one argument.</code></span>
<span class="codeline" id="line-213"><code>// If T is a floating-point type and any of the arguments are NaNs,</code></span>
<span class="codeline" id="line-214"><code>// max will return NaN.</code></span>
<span class="codeline" id="line-215"><code>func max[T cmp.Ordered](x T, y ...T) T</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>// The min built-in function returns the smallest value of a fixed number of</code></span>
<span class="codeline" id="line-218"><code>// arguments of [cmp.Ordered] types. There must be at least one argument.</code></span>
<span class="codeline" id="line-219"><code>// If T is a floating-point type and any of the arguments are NaNs,</code></span>
<span class="codeline" id="line-220"><code>// min will return NaN.</code></span>
<span class="codeline" id="line-221"><code>func min[T cmp.Ordered](x T, y ...T) T</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>// The new built-in function allocates memory. The first argument is a type,</code></span>
<span class="codeline" id="line-224"><code>// not a value, and the value returned is a pointer to a newly</code></span>
<span class="codeline" id="line-225"><code>// allocated zero value of that type.</code></span>
<span class="codeline" id="line-226"><code>func new(Type) *Type</code></span>
<span class="codeline" id="line-227"><code></code></span>
<span class="codeline" id="line-228"><code>// The complex built-in function constructs a complex value from two</code></span>
<span class="codeline" id="line-229"><code>// floating-point values. The real and imaginary parts must be of the same</code></span>
<span class="codeline" id="line-230"><code>// size, either float32 or float64 (or assignable to them), and the return</code></span>
<span class="codeline" id="line-231"><code>// value will be the corresponding complex type (complex64 for float32,</code></span>
<span class="codeline" id="line-232"><code>// complex128 for float64).</code></span>
<span class="codeline" id="line-233"><code>func complex(r, i FloatType) ComplexType</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>// The real built-in function returns the real part of the complex number c.</code></span>
<span class="codeline" id="line-236"><code>// The return value will be floating point type corresponding to the type of c.</code></span>
<span class="codeline" id="line-237"><code>func real(c ComplexType) FloatType</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>// The imag built-in function returns the imaginary part of the complex</code></span>
<span class="codeline" id="line-240"><code>// number c. The return value will be floating point type corresponding to</code></span>
<span class="codeline" id="line-241"><code>// the type of c.</code></span>
<span class="codeline" id="line-242"><code>func imag(c ComplexType) FloatType</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// The clear built-in function clears maps and slices.</code></span>
<span class="codeline" id="line-245"><code>// For maps, clear deletes all entries, resulting in an empty map.</code></span>
<span class="codeline" id="line-246"><code>// For slices, clear sets all elements up to the length of the slice</code></span>
<span class="codeline" id="line-247"><code>// to the zero value of the respective element type. If the argument</code></span>
<span class="codeline" id="line-248"><code>// type is a type parameter, the type parameter's type set must</code></span>
<span class="codeline" id="line-249"><code>// contain only map or slice types, and clear performs the operation</code></span>
<span class="codeline" id="line-250"><code>// implied by the type argument.</code></span>
<span class="codeline" id="line-251"><code>func clear[T ~[]Type | ~map[Type]Type1](t T)</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>// The close built-in function closes a channel, which must be either</code></span>
<span class="codeline" id="line-254"><code>// bidirectional or send-only. It should be executed only by the sender,</code></span>
<span class="codeline" id="line-255"><code>// never the receiver, and has the effect of shutting down the channel after</code></span>
<span class="codeline" id="line-256"><code>// the last sent value is received. After the last value has been received</code></span>
<span class="codeline" id="line-257"><code>// from a closed channel c, any receive from c will succeed without</code></span>
<span class="codeline" id="line-258"><code>// blocking, returning the zero value for the channel element. The form</code></span>
<span class="codeline" id="line-259"><code>//</code></span>
<span class="codeline" id="line-260"><code>//	x, ok := &lt;-c</code></span>
<span class="codeline" id="line-261"><code>//</code></span>
<span class="codeline" id="line-262"><code>// will also set ok to false for a closed and empty channel.</code></span>
<span class="codeline" id="line-263"><code>func close(c chan&lt;- Type)</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// The panic built-in function stops normal execution of the current</code></span>
<span class="codeline" id="line-266"><code>// goroutine. When a function F calls panic, normal execution of F stops</code></span>
<span class="codeline" id="line-267"><code>// immediately. Any functions whose execution was deferred by F are run in</code></span>
<span class="codeline" id="line-268"><code>// the usual way, and then F returns to its caller. To the caller G, the</code></span>
<span class="codeline" id="line-269"><code>// invocation of F then behaves like a call to panic, terminating G's</code></span>
<span class="codeline" id="line-270"><code>// execution and running any deferred functions. This continues until all</code></span>
<span class="codeline" id="line-271"><code>// functions in the executing goroutine have stopped, in reverse order. At</code></span>
<span class="codeline" id="line-272"><code>// that point, the program is terminated with a non-zero exit code. This</code></span>
<span class="codeline" id="line-273"><code>// termination sequence is called panicking and can be controlled by the</code></span>
<span class="codeline" id="line-274"><code>// built-in function recover.</code></span>
<span class="codeline" id="line-275"><code>//</code></span>
<span class="codeline" id="line-276"><code>// Starting in Go 1.21, calling panic with a nil interface value or an</code></span>
<span class="codeline" id="line-277"><code>// untyped nil causes a run-time error (a different panic).</code></span>
<span class="codeline" id="line-278"><code>// The GODEBUG setting panicnil=1 disables the run-time error.</code></span>
<span class="codeline" id="line-279"><code>func panic(v any)</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>// The recover built-in function allows a program to manage behavior of a</code></span>
<span class="codeline" id="line-282"><code>// panicking goroutine. Executing a call to recover inside a deferred</code></span>
<span class="codeline" id="line-283"><code>// function (but not any function called by it) stops the panicking sequence</code></span>
<span class="codeline" id="line-284"><code>// by restoring normal execution and retrieves the error value passed to the</code></span>
<span class="codeline" id="line-285"><code>// call of panic. If recover is called outside the deferred function it will</code></span>
<span class="codeline" id="line-286"><code>// not stop a panicking sequence. In this case, or when the goroutine is not</code></span>
<span class="codeline" id="line-287"><code>// panicking, recover returns nil.</code></span>
<span class="codeline" id="line-288"><code>//</code></span>
<span class="codeline" id="line-289"><code>// Prior to Go 1.21, recover would also return nil if panic is called with</code></span>
<span class="codeline" id="line-290"><code>// a nil argument. See [panic] for details.</code></span>
<span class="codeline" id="line-291"><code>func recover() any</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>// The print built-in function formats its arguments in an</code></span>
<span class="codeline" id="line-294"><code>// implementation-specific way and writes the result to standard error.</code></span>
<span class="codeline" id="line-295"><code>// Print is useful for bootstrapping and debugging; it is not guaranteed</code></span>
<span class="codeline" id="line-296"><code>// to stay in the language.</code></span>
<span class="codeline" id="line-297"><code>func print(args ...Type)</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>// The println built-in function formats its arguments in an</code></span>
<span class="codeline" id="line-300"><code>// implementation-specific way and writes the result to standard error.</code></span>
<span class="codeline" id="line-301"><code>// Spaces are always added between arguments and a newline is appended.</code></span>
<span class="codeline" id="line-302"><code>// Println is useful for bootstrapping and debugging; it is not guaranteed</code></span>
<span class="codeline" id="line-303"><code>// to stay in the language.</code></span>
<span class="codeline" id="line-304"><code>func println(args ...Type)</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>// The error built-in interface type is the conventional interface for</code></span>
<span class="codeline" id="line-307"><code>// representing an error condition, with the nil value representing no error.</code></span>
<span class="codeline" id="line-308"><code>type error interface {</code></span>
<span class="codeline" id="line-309"><code>	Error() string</code></span>
<span class="codeline" id="line-310"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>