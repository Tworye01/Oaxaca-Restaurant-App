<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: punycode.go in package vendor/golang.org/x/net/idna</title>
<link href="../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	punycode.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../pkg/vendor/golang.org/x/net/idna.html">vendor/golang.org/x/net/idna</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by running "go generate" in golang.org/x/text. DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2016 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package idna</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>// This file implements the Punycode algorithm from RFC 3492.</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"math"</code></span>
<span class="codeline" id="line-13"><code>	"strings"</code></span>
<span class="codeline" id="line-14"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-15"><code>)</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>// These parameter values are specified in section 5.</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// All computation is done with int32s, so that overflow behavior is identical</code></span>
<span class="codeline" id="line-20"><code>// regardless of whether int is 32-bit or 64-bit.</code></span>
<span class="codeline" id="line-21"><code>const (</code></span>
<span class="codeline" id="line-22"><code>	base        int32 = 36</code></span>
<span class="codeline" id="line-23"><code>	damp        int32 = 700</code></span>
<span class="codeline" id="line-24"><code>	initialBias int32 = 72</code></span>
<span class="codeline" id="line-25"><code>	initialN    int32 = 128</code></span>
<span class="codeline" id="line-26"><code>	skew        int32 = 38</code></span>
<span class="codeline" id="line-27"><code>	tmax        int32 = 26</code></span>
<span class="codeline" id="line-28"><code>	tmin        int32 = 1</code></span>
<span class="codeline" id="line-29"><code>)</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>func punyError(s string) error { return &amp;labelError{s, "A3"} }</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>// decode decodes a string as specified in section 6.2.</code></span>
<span class="codeline" id="line-34"><code>func decode(encoded string) (string, error) {</code></span>
<span class="codeline" id="line-35"><code>	if encoded == "" {</code></span>
<span class="codeline" id="line-36"><code>		return "", nil</code></span>
<span class="codeline" id="line-37"><code>	}</code></span>
<span class="codeline" id="line-38"><code>	pos := 1 + strings.LastIndex(encoded, "-")</code></span>
<span class="codeline" id="line-39"><code>	if pos == 1 {</code></span>
<span class="codeline" id="line-40"><code>		return "", punyError(encoded)</code></span>
<span class="codeline" id="line-41"><code>	}</code></span>
<span class="codeline" id="line-42"><code>	if pos == len(encoded) {</code></span>
<span class="codeline" id="line-43"><code>		return encoded[:len(encoded)-1], nil</code></span>
<span class="codeline" id="line-44"><code>	}</code></span>
<span class="codeline" id="line-45"><code>	output := make([]rune, 0, len(encoded))</code></span>
<span class="codeline" id="line-46"><code>	if pos != 0 {</code></span>
<span class="codeline" id="line-47"><code>		for _, r := range encoded[:pos-1] {</code></span>
<span class="codeline" id="line-48"><code>			output = append(output, r)</code></span>
<span class="codeline" id="line-49"><code>		}</code></span>
<span class="codeline" id="line-50"><code>	}</code></span>
<span class="codeline" id="line-51"><code>	i, n, bias := int32(0), initialN, initialBias</code></span>
<span class="codeline" id="line-52"><code>	overflow := false</code></span>
<span class="codeline" id="line-53"><code>	for pos &lt; len(encoded) {</code></span>
<span class="codeline" id="line-54"><code>		oldI, w := i, int32(1)</code></span>
<span class="codeline" id="line-55"><code>		for k := base; ; k += base {</code></span>
<span class="codeline" id="line-56"><code>			if pos == len(encoded) {</code></span>
<span class="codeline" id="line-57"><code>				return "", punyError(encoded)</code></span>
<span class="codeline" id="line-58"><code>			}</code></span>
<span class="codeline" id="line-59"><code>			digit, ok := decodeDigit(encoded[pos])</code></span>
<span class="codeline" id="line-60"><code>			if !ok {</code></span>
<span class="codeline" id="line-61"><code>				return "", punyError(encoded)</code></span>
<span class="codeline" id="line-62"><code>			}</code></span>
<span class="codeline" id="line-63"><code>			pos++</code></span>
<span class="codeline" id="line-64"><code>			i, overflow = madd(i, digit, w)</code></span>
<span class="codeline" id="line-65"><code>			if overflow {</code></span>
<span class="codeline" id="line-66"><code>				return "", punyError(encoded)</code></span>
<span class="codeline" id="line-67"><code>			}</code></span>
<span class="codeline" id="line-68"><code>			t := k - bias</code></span>
<span class="codeline" id="line-69"><code>			if k &lt;= bias {</code></span>
<span class="codeline" id="line-70"><code>				t = tmin</code></span>
<span class="codeline" id="line-71"><code>			} else if k &gt;= bias+tmax {</code></span>
<span class="codeline" id="line-72"><code>				t = tmax</code></span>
<span class="codeline" id="line-73"><code>			}</code></span>
<span class="codeline" id="line-74"><code>			if digit &lt; t {</code></span>
<span class="codeline" id="line-75"><code>				break</code></span>
<span class="codeline" id="line-76"><code>			}</code></span>
<span class="codeline" id="line-77"><code>			w, overflow = madd(0, w, base-t)</code></span>
<span class="codeline" id="line-78"><code>			if overflow {</code></span>
<span class="codeline" id="line-79"><code>				return "", punyError(encoded)</code></span>
<span class="codeline" id="line-80"><code>			}</code></span>
<span class="codeline" id="line-81"><code>		}</code></span>
<span class="codeline" id="line-82"><code>		if len(output) &gt;= 1024 {</code></span>
<span class="codeline" id="line-83"><code>			return "", punyError(encoded)</code></span>
<span class="codeline" id="line-84"><code>		}</code></span>
<span class="codeline" id="line-85"><code>		x := int32(len(output) + 1)</code></span>
<span class="codeline" id="line-86"><code>		bias = adapt(i-oldI, x, oldI == 0)</code></span>
<span class="codeline" id="line-87"><code>		n += i / x</code></span>
<span class="codeline" id="line-88"><code>		i %= x</code></span>
<span class="codeline" id="line-89"><code>		if n &lt; 0 || n &gt; utf8.MaxRune {</code></span>
<span class="codeline" id="line-90"><code>			return "", punyError(encoded)</code></span>
<span class="codeline" id="line-91"><code>		}</code></span>
<span class="codeline" id="line-92"><code>		output = append(output, 0)</code></span>
<span class="codeline" id="line-93"><code>		copy(output[i+1:], output[i:])</code></span>
<span class="codeline" id="line-94"><code>		output[i] = n</code></span>
<span class="codeline" id="line-95"><code>		i++</code></span>
<span class="codeline" id="line-96"><code>	}</code></span>
<span class="codeline" id="line-97"><code>	return string(output), nil</code></span>
<span class="codeline" id="line-98"><code>}</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>// encode encodes a string as specified in section 6.3 and prepends prefix to</code></span>
<span class="codeline" id="line-101"><code>// the result.</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>// The "while h &lt; length(input)" line in the specification becomes "for</code></span>
<span class="codeline" id="line-104"><code>// remaining != 0" in the Go code, because len(s) in Go is in bytes, not runes.</code></span>
<span class="codeline" id="line-105"><code>func encode(prefix, s string) (string, error) {</code></span>
<span class="codeline" id="line-106"><code>	output := make([]byte, len(prefix), len(prefix)+1+2*len(s))</code></span>
<span class="codeline" id="line-107"><code>	copy(output, prefix)</code></span>
<span class="codeline" id="line-108"><code>	delta, n, bias := int32(0), initialN, initialBias</code></span>
<span class="codeline" id="line-109"><code>	b, remaining := int32(0), int32(0)</code></span>
<span class="codeline" id="line-110"><code>	for _, r := range s {</code></span>
<span class="codeline" id="line-111"><code>		if r &lt; 0x80 {</code></span>
<span class="codeline" id="line-112"><code>			b++</code></span>
<span class="codeline" id="line-113"><code>			output = append(output, byte(r))</code></span>
<span class="codeline" id="line-114"><code>		} else {</code></span>
<span class="codeline" id="line-115"><code>			remaining++</code></span>
<span class="codeline" id="line-116"><code>		}</code></span>
<span class="codeline" id="line-117"><code>	}</code></span>
<span class="codeline" id="line-118"><code>	h := b</code></span>
<span class="codeline" id="line-119"><code>	if b &gt; 0 {</code></span>
<span class="codeline" id="line-120"><code>		output = append(output, '-')</code></span>
<span class="codeline" id="line-121"><code>	}</code></span>
<span class="codeline" id="line-122"><code>	overflow := false</code></span>
<span class="codeline" id="line-123"><code>	for remaining != 0 {</code></span>
<span class="codeline" id="line-124"><code>		m := int32(0x7fffffff)</code></span>
<span class="codeline" id="line-125"><code>		for _, r := range s {</code></span>
<span class="codeline" id="line-126"><code>			if m &gt; r &amp;&amp; r &gt;= n {</code></span>
<span class="codeline" id="line-127"><code>				m = r</code></span>
<span class="codeline" id="line-128"><code>			}</code></span>
<span class="codeline" id="line-129"><code>		}</code></span>
<span class="codeline" id="line-130"><code>		delta, overflow = madd(delta, m-n, h+1)</code></span>
<span class="codeline" id="line-131"><code>		if overflow {</code></span>
<span class="codeline" id="line-132"><code>			return "", punyError(s)</code></span>
<span class="codeline" id="line-133"><code>		}</code></span>
<span class="codeline" id="line-134"><code>		n = m</code></span>
<span class="codeline" id="line-135"><code>		for _, r := range s {</code></span>
<span class="codeline" id="line-136"><code>			if r &lt; n {</code></span>
<span class="codeline" id="line-137"><code>				delta++</code></span>
<span class="codeline" id="line-138"><code>				if delta &lt; 0 {</code></span>
<span class="codeline" id="line-139"><code>					return "", punyError(s)</code></span>
<span class="codeline" id="line-140"><code>				}</code></span>
<span class="codeline" id="line-141"><code>				continue</code></span>
<span class="codeline" id="line-142"><code>			}</code></span>
<span class="codeline" id="line-143"><code>			if r &gt; n {</code></span>
<span class="codeline" id="line-144"><code>				continue</code></span>
<span class="codeline" id="line-145"><code>			}</code></span>
<span class="codeline" id="line-146"><code>			q := delta</code></span>
<span class="codeline" id="line-147"><code>			for k := base; ; k += base {</code></span>
<span class="codeline" id="line-148"><code>				t := k - bias</code></span>
<span class="codeline" id="line-149"><code>				if k &lt;= bias {</code></span>
<span class="codeline" id="line-150"><code>					t = tmin</code></span>
<span class="codeline" id="line-151"><code>				} else if k &gt;= bias+tmax {</code></span>
<span class="codeline" id="line-152"><code>					t = tmax</code></span>
<span class="codeline" id="line-153"><code>				}</code></span>
<span class="codeline" id="line-154"><code>				if q &lt; t {</code></span>
<span class="codeline" id="line-155"><code>					break</code></span>
<span class="codeline" id="line-156"><code>				}</code></span>
<span class="codeline" id="line-157"><code>				output = append(output, encodeDigit(t+(q-t)%(base-t)))</code></span>
<span class="codeline" id="line-158"><code>				q = (q - t) / (base - t)</code></span>
<span class="codeline" id="line-159"><code>			}</code></span>
<span class="codeline" id="line-160"><code>			output = append(output, encodeDigit(q))</code></span>
<span class="codeline" id="line-161"><code>			bias = adapt(delta, h+1, h == b)</code></span>
<span class="codeline" id="line-162"><code>			delta = 0</code></span>
<span class="codeline" id="line-163"><code>			h++</code></span>
<span class="codeline" id="line-164"><code>			remaining--</code></span>
<span class="codeline" id="line-165"><code>		}</code></span>
<span class="codeline" id="line-166"><code>		delta++</code></span>
<span class="codeline" id="line-167"><code>		n++</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>	return string(output), nil</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// madd computes a + (b * c), detecting overflow.</code></span>
<span class="codeline" id="line-173"><code>func madd(a, b, c int32) (next int32, overflow bool) {</code></span>
<span class="codeline" id="line-174"><code>	p := int64(b) * int64(c)</code></span>
<span class="codeline" id="line-175"><code>	if p &gt; math.MaxInt32-int64(a) {</code></span>
<span class="codeline" id="line-176"><code>		return 0, true</code></span>
<span class="codeline" id="line-177"><code>	}</code></span>
<span class="codeline" id="line-178"><code>	return a + int32(p), false</code></span>
<span class="codeline" id="line-179"><code>}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>func decodeDigit(x byte) (digit int32, ok bool) {</code></span>
<span class="codeline" id="line-182"><code>	switch {</code></span>
<span class="codeline" id="line-183"><code>	case '0' &lt;= x &amp;&amp; x &lt;= '9':</code></span>
<span class="codeline" id="line-184"><code>		return int32(x - ('0' - 26)), true</code></span>
<span class="codeline" id="line-185"><code>	case 'A' &lt;= x &amp;&amp; x &lt;= 'Z':</code></span>
<span class="codeline" id="line-186"><code>		return int32(x - 'A'), true</code></span>
<span class="codeline" id="line-187"><code>	case 'a' &lt;= x &amp;&amp; x &lt;= 'z':</code></span>
<span class="codeline" id="line-188"><code>		return int32(x - 'a'), true</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>	return 0, false</code></span>
<span class="codeline" id="line-191"><code>}</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>func encodeDigit(digit int32) byte {</code></span>
<span class="codeline" id="line-194"><code>	switch {</code></span>
<span class="codeline" id="line-195"><code>	case 0 &lt;= digit &amp;&amp; digit &lt; 26:</code></span>
<span class="codeline" id="line-196"><code>		return byte(digit + 'a')</code></span>
<span class="codeline" id="line-197"><code>	case 26 &lt;= digit &amp;&amp; digit &lt; 36:</code></span>
<span class="codeline" id="line-198"><code>		return byte(digit + ('0' - 26))</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	panic("idna: internal error in punycode encoding")</code></span>
<span class="codeline" id="line-201"><code>}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// adapt is the bias adaptation function specified in section 6.1.</code></span>
<span class="codeline" id="line-204"><code>func adapt(delta, numPoints int32, firstTime bool) int32 {</code></span>
<span class="codeline" id="line-205"><code>	if firstTime {</code></span>
<span class="codeline" id="line-206"><code>		delta /= damp</code></span>
<span class="codeline" id="line-207"><code>	} else {</code></span>
<span class="codeline" id="line-208"><code>		delta /= 2</code></span>
<span class="codeline" id="line-209"><code>	}</code></span>
<span class="codeline" id="line-210"><code>	delta += delta / numPoints</code></span>
<span class="codeline" id="line-211"><code>	k := int32(0)</code></span>
<span class="codeline" id="line-212"><code>	for delta &gt; ((base-tmin)*tmax)/2 {</code></span>
<span class="codeline" id="line-213"><code>		delta /= base - tmin</code></span>
<span class="codeline" id="line-214"><code>		k += base</code></span>
<span class="codeline" id="line-215"><code>	}</code></span>
<span class="codeline" id="line-216"><code>	return k + (base-tmin+1)*delta/(delta+skew)</code></span>
<span class="codeline" id="line-217"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>