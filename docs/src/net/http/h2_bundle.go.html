<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: h2_bundle.go in package net/http</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	h2_bundle.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/http.html">net/http</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>//go:build !nethttpomithttp2</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.</code></span>
<span class="codeline" id="line-4"><code>//   $ bundle -o=h2_bundle.go -prefix=http2 -tags=!nethttpomithttp2 golang.org/x/net/http2</code></span>
<span class="codeline" id="line-5"><code></code></span>
<span class="codeline" id="line-6"><code>// Package http2 implements the HTTP/2 protocol.</code></span>
<span class="codeline" id="line-7"><code>//</code></span>
<span class="codeline" id="line-8"><code>// This package is low-level and intended to be used directly by very</code></span>
<span class="codeline" id="line-9"><code>// few people. Most users will use it indirectly through the automatic</code></span>
<span class="codeline" id="line-10"><code>// use by the net/http package (from Go 1.6 and later).</code></span>
<span class="codeline" id="line-11"><code>// For use in earlier Go versions see ConfigureServer. (Transport support</code></span>
<span class="codeline" id="line-12"><code>// requires Go 1.6 or later)</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// See https://http2.github.io/ for more information on HTTP/2.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// See https://http2.golang.org/ for a test server running this code.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>package http</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>import (</code></span>
<span class="codeline" id="line-22"><code>	"bufio"</code></span>
<span class="codeline" id="line-23"><code>	"bytes"</code></span>
<span class="codeline" id="line-24"><code>	"compress/gzip"</code></span>
<span class="codeline" id="line-25"><code>	"context"</code></span>
<span class="codeline" id="line-26"><code>	"crypto/rand"</code></span>
<span class="codeline" id="line-27"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-28"><code>	"encoding/binary"</code></span>
<span class="codeline" id="line-29"><code>	"errors"</code></span>
<span class="codeline" id="line-30"><code>	"fmt"</code></span>
<span class="codeline" id="line-31"><code>	"io"</code></span>
<span class="codeline" id="line-32"><code>	"io/fs"</code></span>
<span class="codeline" id="line-33"><code>	"log"</code></span>
<span class="codeline" id="line-34"><code>	"math"</code></span>
<span class="codeline" id="line-35"><code>	"math/bits"</code></span>
<span class="codeline" id="line-36"><code>	mathrand "math/rand"</code></span>
<span class="codeline" id="line-37"><code>	"net"</code></span>
<span class="codeline" id="line-38"><code>	"net/http/httptrace"</code></span>
<span class="codeline" id="line-39"><code>	"net/textproto"</code></span>
<span class="codeline" id="line-40"><code>	"net/url"</code></span>
<span class="codeline" id="line-41"><code>	"os"</code></span>
<span class="codeline" id="line-42"><code>	"reflect"</code></span>
<span class="codeline" id="line-43"><code>	"runtime"</code></span>
<span class="codeline" id="line-44"><code>	"sort"</code></span>
<span class="codeline" id="line-45"><code>	"strconv"</code></span>
<span class="codeline" id="line-46"><code>	"strings"</code></span>
<span class="codeline" id="line-47"><code>	"sync"</code></span>
<span class="codeline" id="line-48"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-49"><code>	"time"</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>	"golang.org/x/net/http/httpguts"</code></span>
<span class="codeline" id="line-52"><code>	"golang.org/x/net/http2/hpack"</code></span>
<span class="codeline" id="line-53"><code>	"golang.org/x/net/idna"</code></span>
<span class="codeline" id="line-54"><code>)</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>// The HTTP protocols are defined in terms of ASCII, not Unicode. This file</code></span>
<span class="codeline" id="line-57"><code>// contains helper functions which may use Unicode-aware functions which would</code></span>
<span class="codeline" id="line-58"><code>// otherwise be unsafe and could introduce vulnerabilities if used improperly.</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// asciiEqualFold is strings.EqualFold, ASCII only. It reports whether s and t</code></span>
<span class="codeline" id="line-61"><code>// are equal, ASCII-case-insensitively.</code></span>
<span class="codeline" id="line-62"><code>func http2asciiEqualFold(s, t string) bool {</code></span>
<span class="codeline" id="line-63"><code>	if len(s) != len(t) {</code></span>
<span class="codeline" id="line-64"><code>		return false</code></span>
<span class="codeline" id="line-65"><code>	}</code></span>
<span class="codeline" id="line-66"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-67"><code>		if http2lower(s[i]) != http2lower(t[i]) {</code></span>
<span class="codeline" id="line-68"><code>			return false</code></span>
<span class="codeline" id="line-69"><code>		}</code></span>
<span class="codeline" id="line-70"><code>	}</code></span>
<span class="codeline" id="line-71"><code>	return true</code></span>
<span class="codeline" id="line-72"><code>}</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>// lower returns the ASCII lowercase version of b.</code></span>
<span class="codeline" id="line-75"><code>func http2lower(b byte) byte {</code></span>
<span class="codeline" id="line-76"><code>	if 'A' &lt;= b &amp;&amp; b &lt;= 'Z' {</code></span>
<span class="codeline" id="line-77"><code>		return b + ('a' - 'A')</code></span>
<span class="codeline" id="line-78"><code>	}</code></span>
<span class="codeline" id="line-79"><code>	return b</code></span>
<span class="codeline" id="line-80"><code>}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>// isASCIIPrint returns whether s is ASCII and printable according to</code></span>
<span class="codeline" id="line-83"><code>// https://tools.ietf.org/html/rfc20#section-4.2.</code></span>
<span class="codeline" id="line-84"><code>func http2isASCIIPrint(s string) bool {</code></span>
<span class="codeline" id="line-85"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-86"><code>		if s[i] &lt; ' ' || s[i] &gt; '~' {</code></span>
<span class="codeline" id="line-87"><code>			return false</code></span>
<span class="codeline" id="line-88"><code>		}</code></span>
<span class="codeline" id="line-89"><code>	}</code></span>
<span class="codeline" id="line-90"><code>	return true</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>// asciiToLower returns the lowercase version of s if s is ASCII and printable,</code></span>
<span class="codeline" id="line-94"><code>// and whether or not it was.</code></span>
<span class="codeline" id="line-95"><code>func http2asciiToLower(s string) (lower string, ok bool) {</code></span>
<span class="codeline" id="line-96"><code>	if !http2isASCIIPrint(s) {</code></span>
<span class="codeline" id="line-97"><code>		return "", false</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>	return strings.ToLower(s), true</code></span>
<span class="codeline" id="line-100"><code>}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>// A list of the possible cipher suite ids. Taken from</code></span>
<span class="codeline" id="line-103"><code>// https://www.iana.org/assignments/tls-parameters/tls-parameters.txt</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>const (</code></span>
<span class="codeline" id="line-106"><code>	http2cipher_TLS_NULL_WITH_NULL_NULL               uint16 = 0x0000</code></span>
<span class="codeline" id="line-107"><code>	http2cipher_TLS_RSA_WITH_NULL_MD5                 uint16 = 0x0001</code></span>
<span class="codeline" id="line-108"><code>	http2cipher_TLS_RSA_WITH_NULL_SHA                 uint16 = 0x0002</code></span>
<span class="codeline" id="line-109"><code>	http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5        uint16 = 0x0003</code></span>
<span class="codeline" id="line-110"><code>	http2cipher_TLS_RSA_WITH_RC4_128_MD5              uint16 = 0x0004</code></span>
<span class="codeline" id="line-111"><code>	http2cipher_TLS_RSA_WITH_RC4_128_SHA              uint16 = 0x0005</code></span>
<span class="codeline" id="line-112"><code>	http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    uint16 = 0x0006</code></span>
<span class="codeline" id="line-113"><code>	http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA             uint16 = 0x0007</code></span>
<span class="codeline" id="line-114"><code>	http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     uint16 = 0x0008</code></span>
<span class="codeline" id="line-115"><code>	http2cipher_TLS_RSA_WITH_DES_CBC_SHA              uint16 = 0x0009</code></span>
<span class="codeline" id="line-116"><code>	http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA         uint16 = 0x000A</code></span>
<span class="codeline" id="line-117"><code>	http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  uint16 = 0x000B</code></span>
<span class="codeline" id="line-118"><code>	http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA           uint16 = 0x000C</code></span>
<span class="codeline" id="line-119"><code>	http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      uint16 = 0x000D</code></span>
<span class="codeline" id="line-120"><code>	http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  uint16 = 0x000E</code></span>
<span class="codeline" id="line-121"><code>	http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA           uint16 = 0x000F</code></span>
<span class="codeline" id="line-122"><code>	http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      uint16 = 0x0010</code></span>
<span class="codeline" id="line-123"><code>	http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0011</code></span>
<span class="codeline" id="line-124"><code>	http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA          uint16 = 0x0012</code></span>
<span class="codeline" id="line-125"><code>	http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     uint16 = 0x0013</code></span>
<span class="codeline" id="line-126"><code>	http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0014</code></span>
<span class="codeline" id="line-127"><code>	http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA          uint16 = 0x0015</code></span>
<span class="codeline" id="line-128"><code>	http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     uint16 = 0x0016</code></span>
<span class="codeline" id="line-129"><code>	http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    uint16 = 0x0017</code></span>
<span class="codeline" id="line-130"><code>	http2cipher_TLS_DH_anon_WITH_RC4_128_MD5          uint16 = 0x0018</code></span>
<span class="codeline" id="line-131"><code>	http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0019</code></span>
<span class="codeline" id="line-132"><code>	http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA          uint16 = 0x001A</code></span>
<span class="codeline" id="line-133"><code>	http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     uint16 = 0x001B</code></span>
<span class="codeline" id="line-134"><code>	// Reserved uint16 =  0x001C-1D</code></span>
<span class="codeline" id="line-135"><code>	http2cipher_TLS_KRB5_WITH_DES_CBC_SHA             uint16 = 0x001E</code></span>
<span class="codeline" id="line-136"><code>	http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA        uint16 = 0x001F</code></span>
<span class="codeline" id="line-137"><code>	http2cipher_TLS_KRB5_WITH_RC4_128_SHA             uint16 = 0x0020</code></span>
<span class="codeline" id="line-138"><code>	http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA            uint16 = 0x0021</code></span>
<span class="codeline" id="line-139"><code>	http2cipher_TLS_KRB5_WITH_DES_CBC_MD5             uint16 = 0x0022</code></span>
<span class="codeline" id="line-140"><code>	http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5        uint16 = 0x0023</code></span>
<span class="codeline" id="line-141"><code>	http2cipher_TLS_KRB5_WITH_RC4_128_MD5             uint16 = 0x0024</code></span>
<span class="codeline" id="line-142"><code>	http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5            uint16 = 0x0025</code></span>
<span class="codeline" id="line-143"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA   uint16 = 0x0026</code></span>
<span class="codeline" id="line-144"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA   uint16 = 0x0027</code></span>
<span class="codeline" id="line-145"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA       uint16 = 0x0028</code></span>
<span class="codeline" id="line-146"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5   uint16 = 0x0029</code></span>
<span class="codeline" id="line-147"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5   uint16 = 0x002A</code></span>
<span class="codeline" id="line-148"><code>	http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5       uint16 = 0x002B</code></span>
<span class="codeline" id="line-149"><code>	http2cipher_TLS_PSK_WITH_NULL_SHA                 uint16 = 0x002C</code></span>
<span class="codeline" id="line-150"><code>	http2cipher_TLS_DHE_PSK_WITH_NULL_SHA             uint16 = 0x002D</code></span>
<span class="codeline" id="line-151"><code>	http2cipher_TLS_RSA_PSK_WITH_NULL_SHA             uint16 = 0x002E</code></span>
<span class="codeline" id="line-152"><code>	http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA          uint16 = 0x002F</code></span>
<span class="codeline" id="line-153"><code>	http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA       uint16 = 0x0030</code></span>
<span class="codeline" id="line-154"><code>	http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA       uint16 = 0x0031</code></span>
<span class="codeline" id="line-155"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA      uint16 = 0x0032</code></span>
<span class="codeline" id="line-156"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA      uint16 = 0x0033</code></span>
<span class="codeline" id="line-157"><code>	http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA      uint16 = 0x0034</code></span>
<span class="codeline" id="line-158"><code>	http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA          uint16 = 0x0035</code></span>
<span class="codeline" id="line-159"><code>	http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA       uint16 = 0x0036</code></span>
<span class="codeline" id="line-160"><code>	http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA       uint16 = 0x0037</code></span>
<span class="codeline" id="line-161"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA      uint16 = 0x0038</code></span>
<span class="codeline" id="line-162"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA      uint16 = 0x0039</code></span>
<span class="codeline" id="line-163"><code>	http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA      uint16 = 0x003A</code></span>
<span class="codeline" id="line-164"><code>	http2cipher_TLS_RSA_WITH_NULL_SHA256              uint16 = 0x003B</code></span>
<span class="codeline" id="line-165"><code>	http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256       uint16 = 0x003C</code></span>
<span class="codeline" id="line-166"><code>	http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256       uint16 = 0x003D</code></span>
<span class="codeline" id="line-167"><code>	http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256    uint16 = 0x003E</code></span>
<span class="codeline" id="line-168"><code>	http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256    uint16 = 0x003F</code></span>
<span class="codeline" id="line-169"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   uint16 = 0x0040</code></span>
<span class="codeline" id="line-170"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA     uint16 = 0x0041</code></span>
<span class="codeline" id="line-171"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA  uint16 = 0x0042</code></span>
<span class="codeline" id="line-172"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA  uint16 = 0x0043</code></span>
<span class="codeline" id="line-173"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0044</code></span>
<span class="codeline" id="line-174"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0045</code></span>
<span class="codeline" id="line-175"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0046</code></span>
<span class="codeline" id="line-176"><code>	// Reserved uint16 =  0x0047-4F</code></span>
<span class="codeline" id="line-177"><code>	// Reserved uint16 =  0x0050-58</code></span>
<span class="codeline" id="line-178"><code>	// Reserved uint16 =  0x0059-5C</code></span>
<span class="codeline" id="line-179"><code>	// Unassigned uint16 =  0x005D-5F</code></span>
<span class="codeline" id="line-180"><code>	// Reserved uint16 =  0x0060-66</code></span>
<span class="codeline" id="line-181"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x0067</code></span>
<span class="codeline" id="line-182"><code>	http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256  uint16 = 0x0068</code></span>
<span class="codeline" id="line-183"><code>	http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256  uint16 = 0x0069</code></span>
<span class="codeline" id="line-184"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x006A</code></span>
<span class="codeline" id="line-185"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x006B</code></span>
<span class="codeline" id="line-186"><code>	http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 uint16 = 0x006C</code></span>
<span class="codeline" id="line-187"><code>	http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 uint16 = 0x006D</code></span>
<span class="codeline" id="line-188"><code>	// Unassigned uint16 =  0x006E-83</code></span>
<span class="codeline" id="line-189"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA        uint16 = 0x0084</code></span>
<span class="codeline" id="line-190"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA     uint16 = 0x0085</code></span>
<span class="codeline" id="line-191"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA     uint16 = 0x0086</code></span>
<span class="codeline" id="line-192"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0087</code></span>
<span class="codeline" id="line-193"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0088</code></span>
<span class="codeline" id="line-194"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA    uint16 = 0x0089</code></span>
<span class="codeline" id="line-195"><code>	http2cipher_TLS_PSK_WITH_RC4_128_SHA                 uint16 = 0x008A</code></span>
<span class="codeline" id="line-196"><code>	http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA            uint16 = 0x008B</code></span>
<span class="codeline" id="line-197"><code>	http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA             uint16 = 0x008C</code></span>
<span class="codeline" id="line-198"><code>	http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA             uint16 = 0x008D</code></span>
<span class="codeline" id="line-199"><code>	http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA             uint16 = 0x008E</code></span>
<span class="codeline" id="line-200"><code>	http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA        uint16 = 0x008F</code></span>
<span class="codeline" id="line-201"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA         uint16 = 0x0090</code></span>
<span class="codeline" id="line-202"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA         uint16 = 0x0091</code></span>
<span class="codeline" id="line-203"><code>	http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA             uint16 = 0x0092</code></span>
<span class="codeline" id="line-204"><code>	http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA        uint16 = 0x0093</code></span>
<span class="codeline" id="line-205"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA         uint16 = 0x0094</code></span>
<span class="codeline" id="line-206"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA         uint16 = 0x0095</code></span>
<span class="codeline" id="line-207"><code>	http2cipher_TLS_RSA_WITH_SEED_CBC_SHA                uint16 = 0x0096</code></span>
<span class="codeline" id="line-208"><code>	http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA             uint16 = 0x0097</code></span>
<span class="codeline" id="line-209"><code>	http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA             uint16 = 0x0098</code></span>
<span class="codeline" id="line-210"><code>	http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA            uint16 = 0x0099</code></span>
<span class="codeline" id="line-211"><code>	http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA            uint16 = 0x009A</code></span>
<span class="codeline" id="line-212"><code>	http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA            uint16 = 0x009B</code></span>
<span class="codeline" id="line-213"><code>	http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256          uint16 = 0x009C</code></span>
<span class="codeline" id="line-214"><code>	http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384          uint16 = 0x009D</code></span>
<span class="codeline" id="line-215"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256      uint16 = 0x009E</code></span>
<span class="codeline" id="line-216"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384      uint16 = 0x009F</code></span>
<span class="codeline" id="line-217"><code>	http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256       uint16 = 0x00A0</code></span>
<span class="codeline" id="line-218"><code>	http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384       uint16 = 0x00A1</code></span>
<span class="codeline" id="line-219"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256      uint16 = 0x00A2</code></span>
<span class="codeline" id="line-220"><code>	http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384      uint16 = 0x00A3</code></span>
<span class="codeline" id="line-221"><code>	http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256       uint16 = 0x00A4</code></span>
<span class="codeline" id="line-222"><code>	http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384       uint16 = 0x00A5</code></span>
<span class="codeline" id="line-223"><code>	http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256      uint16 = 0x00A6</code></span>
<span class="codeline" id="line-224"><code>	http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384      uint16 = 0x00A7</code></span>
<span class="codeline" id="line-225"><code>	http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256          uint16 = 0x00A8</code></span>
<span class="codeline" id="line-226"><code>	http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384          uint16 = 0x00A9</code></span>
<span class="codeline" id="line-227"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256      uint16 = 0x00AA</code></span>
<span class="codeline" id="line-228"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384      uint16 = 0x00AB</code></span>
<span class="codeline" id="line-229"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256      uint16 = 0x00AC</code></span>
<span class="codeline" id="line-230"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384      uint16 = 0x00AD</code></span>
<span class="codeline" id="line-231"><code>	http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256          uint16 = 0x00AE</code></span>
<span class="codeline" id="line-232"><code>	http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384          uint16 = 0x00AF</code></span>
<span class="codeline" id="line-233"><code>	http2cipher_TLS_PSK_WITH_NULL_SHA256                 uint16 = 0x00B0</code></span>
<span class="codeline" id="line-234"><code>	http2cipher_TLS_PSK_WITH_NULL_SHA384                 uint16 = 0x00B1</code></span>
<span class="codeline" id="line-235"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256      uint16 = 0x00B2</code></span>
<span class="codeline" id="line-236"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384      uint16 = 0x00B3</code></span>
<span class="codeline" id="line-237"><code>	http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256             uint16 = 0x00B4</code></span>
<span class="codeline" id="line-238"><code>	http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384             uint16 = 0x00B5</code></span>
<span class="codeline" id="line-239"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256      uint16 = 0x00B6</code></span>
<span class="codeline" id="line-240"><code>	http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384      uint16 = 0x00B7</code></span>
<span class="codeline" id="line-241"><code>	http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256             uint16 = 0x00B8</code></span>
<span class="codeline" id="line-242"><code>	http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384             uint16 = 0x00B9</code></span>
<span class="codeline" id="line-243"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0x00BA</code></span>
<span class="codeline" id="line-244"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0x00BB</code></span>
<span class="codeline" id="line-245"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0x00BC</code></span>
<span class="codeline" id="line-246"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BD</code></span>
<span class="codeline" id="line-247"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BE</code></span>
<span class="codeline" id="line-248"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BF</code></span>
<span class="codeline" id="line-249"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256     uint16 = 0x00C0</code></span>
<span class="codeline" id="line-250"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256  uint16 = 0x00C1</code></span>
<span class="codeline" id="line-251"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256  uint16 = 0x00C2</code></span>
<span class="codeline" id="line-252"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C3</code></span>
<span class="codeline" id="line-253"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C4</code></span>
<span class="codeline" id="line-254"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C5</code></span>
<span class="codeline" id="line-255"><code>	// Unassigned uint16 =  0x00C6-FE</code></span>
<span class="codeline" id="line-256"><code>	http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV uint16 = 0x00FF</code></span>
<span class="codeline" id="line-257"><code>	// Unassigned uint16 =  0x01-55,*</code></span>
<span class="codeline" id="line-258"><code>	http2cipher_TLS_FALLBACK_SCSV uint16 = 0x5600</code></span>
<span class="codeline" id="line-259"><code>	// Unassigned                                   uint16 = 0x5601 - 0xC000</code></span>
<span class="codeline" id="line-260"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA                 uint16 = 0xC001</code></span>
<span class="codeline" id="line-261"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA              uint16 = 0xC002</code></span>
<span class="codeline" id="line-262"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA         uint16 = 0xC003</code></span>
<span class="codeline" id="line-263"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xC004</code></span>
<span class="codeline" id="line-264"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xC005</code></span>
<span class="codeline" id="line-265"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA                uint16 = 0xC006</code></span>
<span class="codeline" id="line-266"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA             uint16 = 0xC007</code></span>
<span class="codeline" id="line-267"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC008</code></span>
<span class="codeline" id="line-268"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA         uint16 = 0xC009</code></span>
<span class="codeline" id="line-269"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA         uint16 = 0xC00A</code></span>
<span class="codeline" id="line-270"><code>	http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA                   uint16 = 0xC00B</code></span>
<span class="codeline" id="line-271"><code>	http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA                uint16 = 0xC00C</code></span>
<span class="codeline" id="line-272"><code>	http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xC00D</code></span>
<span class="codeline" id="line-273"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xC00E</code></span>
<span class="codeline" id="line-274"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xC00F</code></span>
<span class="codeline" id="line-275"><code>	http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA                  uint16 = 0xC010</code></span>
<span class="codeline" id="line-276"><code>	http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA               uint16 = 0xC011</code></span>
<span class="codeline" id="line-277"><code>	http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC012</code></span>
<span class="codeline" id="line-278"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA           uint16 = 0xC013</code></span>
<span class="codeline" id="line-279"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA           uint16 = 0xC014</code></span>
<span class="codeline" id="line-280"><code>	http2cipher_TLS_ECDH_anon_WITH_NULL_SHA                  uint16 = 0xC015</code></span>
<span class="codeline" id="line-281"><code>	http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA               uint16 = 0xC016</code></span>
<span class="codeline" id="line-282"><code>	http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC017</code></span>
<span class="codeline" id="line-283"><code>	http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA           uint16 = 0xC018</code></span>
<span class="codeline" id="line-284"><code>	http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA           uint16 = 0xC019</code></span>
<span class="codeline" id="line-285"><code>	http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA            uint16 = 0xC01A</code></span>
<span class="codeline" id="line-286"><code>	http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC01B</code></span>
<span class="codeline" id="line-287"><code>	http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA        uint16 = 0xC01C</code></span>
<span class="codeline" id="line-288"><code>	http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA             uint16 = 0xC01D</code></span>
<span class="codeline" id="line-289"><code>	http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA         uint16 = 0xC01E</code></span>
<span class="codeline" id="line-290"><code>	http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA         uint16 = 0xC01F</code></span>
<span class="codeline" id="line-291"><code>	http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA             uint16 = 0xC020</code></span>
<span class="codeline" id="line-292"><code>	http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA         uint16 = 0xC021</code></span>
<span class="codeline" id="line-293"><code>	http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA         uint16 = 0xC022</code></span>
<span class="codeline" id="line-294"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256      uint16 = 0xC023</code></span>
<span class="codeline" id="line-295"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384      uint16 = 0xC024</code></span>
<span class="codeline" id="line-296"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256       uint16 = 0xC025</code></span>
<span class="codeline" id="line-297"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384       uint16 = 0xC026</code></span>
<span class="codeline" id="line-298"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256        uint16 = 0xC027</code></span>
<span class="codeline" id="line-299"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384        uint16 = 0xC028</code></span>
<span class="codeline" id="line-300"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0xC029</code></span>
<span class="codeline" id="line-301"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384         uint16 = 0xC02A</code></span>
<span class="codeline" id="line-302"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256      uint16 = 0xC02B</code></span>
<span class="codeline" id="line-303"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384      uint16 = 0xC02C</code></span>
<span class="codeline" id="line-304"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xC02D</code></span>
<span class="codeline" id="line-305"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384       uint16 = 0xC02E</code></span>
<span class="codeline" id="line-306"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256        uint16 = 0xC02F</code></span>
<span class="codeline" id="line-307"><code>	http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384        uint16 = 0xC030</code></span>
<span class="codeline" id="line-308"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xC031</code></span>
<span class="codeline" id="line-309"><code>	http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0xC032</code></span>
<span class="codeline" id="line-310"><code>	http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA               uint16 = 0xC033</code></span>
<span class="codeline" id="line-311"><code>	http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA          uint16 = 0xC034</code></span>
<span class="codeline" id="line-312"><code>	http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA           uint16 = 0xC035</code></span>
<span class="codeline" id="line-313"><code>	http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA           uint16 = 0xC036</code></span>
<span class="codeline" id="line-314"><code>	http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256        uint16 = 0xC037</code></span>
<span class="codeline" id="line-315"><code>	http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384        uint16 = 0xC038</code></span>
<span class="codeline" id="line-316"><code>	http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA                  uint16 = 0xC039</code></span>
<span class="codeline" id="line-317"><code>	http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256               uint16 = 0xC03A</code></span>
<span class="codeline" id="line-318"><code>	http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384               uint16 = 0xC03B</code></span>
<span class="codeline" id="line-319"><code>	http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256             uint16 = 0xC03C</code></span>
<span class="codeline" id="line-320"><code>	http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384             uint16 = 0xC03D</code></span>
<span class="codeline" id="line-321"><code>	http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256          uint16 = 0xC03E</code></span>
<span class="codeline" id="line-322"><code>	http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384          uint16 = 0xC03F</code></span>
<span class="codeline" id="line-323"><code>	http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256          uint16 = 0xC040</code></span>
<span class="codeline" id="line-324"><code>	http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384          uint16 = 0xC041</code></span>
<span class="codeline" id="line-325"><code>	http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC042</code></span>
<span class="codeline" id="line-326"><code>	http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC043</code></span>
<span class="codeline" id="line-327"><code>	http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC044</code></span>
<span class="codeline" id="line-328"><code>	http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC045</code></span>
<span class="codeline" id="line-329"><code>	http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC046</code></span>
<span class="codeline" id="line-330"><code>	http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC047</code></span>
<span class="codeline" id="line-331"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256     uint16 = 0xC048</code></span>
<span class="codeline" id="line-332"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384     uint16 = 0xC049</code></span>
<span class="codeline" id="line-333"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256      uint16 = 0xC04A</code></span>
<span class="codeline" id="line-334"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384      uint16 = 0xC04B</code></span>
<span class="codeline" id="line-335"><code>	http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256       uint16 = 0xC04C</code></span>
<span class="codeline" id="line-336"><code>	http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384       uint16 = 0xC04D</code></span>
<span class="codeline" id="line-337"><code>	http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256        uint16 = 0xC04E</code></span>
<span class="codeline" id="line-338"><code>	http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384        uint16 = 0xC04F</code></span>
<span class="codeline" id="line-339"><code>	http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256             uint16 = 0xC050</code></span>
<span class="codeline" id="line-340"><code>	http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384             uint16 = 0xC051</code></span>
<span class="codeline" id="line-341"><code>	http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC052</code></span>
<span class="codeline" id="line-342"><code>	http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC053</code></span>
<span class="codeline" id="line-343"><code>	http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256          uint16 = 0xC054</code></span>
<span class="codeline" id="line-344"><code>	http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384          uint16 = 0xC055</code></span>
<span class="codeline" id="line-345"><code>	http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC056</code></span>
<span class="codeline" id="line-346"><code>	http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC057</code></span>
<span class="codeline" id="line-347"><code>	http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256          uint16 = 0xC058</code></span>
<span class="codeline" id="line-348"><code>	http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384          uint16 = 0xC059</code></span>
<span class="codeline" id="line-349"><code>	http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC05A</code></span>
<span class="codeline" id="line-350"><code>	http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC05B</code></span>
<span class="codeline" id="line-351"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256     uint16 = 0xC05C</code></span>
<span class="codeline" id="line-352"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384     uint16 = 0xC05D</code></span>
<span class="codeline" id="line-353"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256      uint16 = 0xC05E</code></span>
<span class="codeline" id="line-354"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384      uint16 = 0xC05F</code></span>
<span class="codeline" id="line-355"><code>	http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256       uint16 = 0xC060</code></span>
<span class="codeline" id="line-356"><code>	http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384       uint16 = 0xC061</code></span>
<span class="codeline" id="line-357"><code>	http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256        uint16 = 0xC062</code></span>
<span class="codeline" id="line-358"><code>	http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384        uint16 = 0xC063</code></span>
<span class="codeline" id="line-359"><code>	http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256             uint16 = 0xC064</code></span>
<span class="codeline" id="line-360"><code>	http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384             uint16 = 0xC065</code></span>
<span class="codeline" id="line-361"><code>	http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC066</code></span>
<span class="codeline" id="line-362"><code>	http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC067</code></span>
<span class="codeline" id="line-363"><code>	http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256         uint16 = 0xC068</code></span>
<span class="codeline" id="line-364"><code>	http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384         uint16 = 0xC069</code></span>
<span class="codeline" id="line-365"><code>	http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256             uint16 = 0xC06A</code></span>
<span class="codeline" id="line-366"><code>	http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384             uint16 = 0xC06B</code></span>
<span class="codeline" id="line-367"><code>	http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC06C</code></span>
<span class="codeline" id="line-368"><code>	http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC06D</code></span>
<span class="codeline" id="line-369"><code>	http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256         uint16 = 0xC06E</code></span>
<span class="codeline" id="line-370"><code>	http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384         uint16 = 0xC06F</code></span>
<span class="codeline" id="line-371"><code>	http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256       uint16 = 0xC070</code></span>
<span class="codeline" id="line-372"><code>	http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384       uint16 = 0xC071</code></span>
<span class="codeline" id="line-373"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC072</code></span>
<span class="codeline" id="line-374"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC073</code></span>
<span class="codeline" id="line-375"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256  uint16 = 0xC074</code></span>
<span class="codeline" id="line-376"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384  uint16 = 0xC075</code></span>
<span class="codeline" id="line-377"><code>	http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256   uint16 = 0xC076</code></span>
<span class="codeline" id="line-378"><code>	http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384   uint16 = 0xC077</code></span>
<span class="codeline" id="line-379"><code>	http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256    uint16 = 0xC078</code></span>
<span class="codeline" id="line-380"><code>	http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384    uint16 = 0xC079</code></span>
<span class="codeline" id="line-381"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256         uint16 = 0xC07A</code></span>
<span class="codeline" id="line-382"><code>	http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384         uint16 = 0xC07B</code></span>
<span class="codeline" id="line-383"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC07C</code></span>
<span class="codeline" id="line-384"><code>	http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC07D</code></span>
<span class="codeline" id="line-385"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256      uint16 = 0xC07E</code></span>
<span class="codeline" id="line-386"><code>	http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384      uint16 = 0xC07F</code></span>
<span class="codeline" id="line-387"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC080</code></span>
<span class="codeline" id="line-388"><code>	http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC081</code></span>
<span class="codeline" id="line-389"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256      uint16 = 0xC082</code></span>
<span class="codeline" id="line-390"><code>	http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384      uint16 = 0xC083</code></span>
<span class="codeline" id="line-391"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC084</code></span>
<span class="codeline" id="line-392"><code>	http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC085</code></span>
<span class="codeline" id="line-393"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC086</code></span>
<span class="codeline" id="line-394"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC087</code></span>
<span class="codeline" id="line-395"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256  uint16 = 0xC088</code></span>
<span class="codeline" id="line-396"><code>	http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384  uint16 = 0xC089</code></span>
<span class="codeline" id="line-397"><code>	http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256   uint16 = 0xC08A</code></span>
<span class="codeline" id="line-398"><code>	http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384   uint16 = 0xC08B</code></span>
<span class="codeline" id="line-399"><code>	http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256    uint16 = 0xC08C</code></span>
<span class="codeline" id="line-400"><code>	http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384    uint16 = 0xC08D</code></span>
<span class="codeline" id="line-401"><code>	http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256         uint16 = 0xC08E</code></span>
<span class="codeline" id="line-402"><code>	http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384         uint16 = 0xC08F</code></span>
<span class="codeline" id="line-403"><code>	http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC090</code></span>
<span class="codeline" id="line-404"><code>	http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC091</code></span>
<span class="codeline" id="line-405"><code>	http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256     uint16 = 0xC092</code></span>
<span class="codeline" id="line-406"><code>	http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384     uint16 = 0xC093</code></span>
<span class="codeline" id="line-407"><code>	http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256         uint16 = 0xC094</code></span>
<span class="codeline" id="line-408"><code>	http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384         uint16 = 0xC095</code></span>
<span class="codeline" id="line-409"><code>	http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0xC096</code></span>
<span class="codeline" id="line-410"><code>	http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384     uint16 = 0xC097</code></span>
<span class="codeline" id="line-411"><code>	http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256     uint16 = 0xC098</code></span>
<span class="codeline" id="line-412"><code>	http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384     uint16 = 0xC099</code></span>
<span class="codeline" id="line-413"><code>	http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256   uint16 = 0xC09A</code></span>
<span class="codeline" id="line-414"><code>	http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384   uint16 = 0xC09B</code></span>
<span class="codeline" id="line-415"><code>	http2cipher_TLS_RSA_WITH_AES_128_CCM                     uint16 = 0xC09C</code></span>
<span class="codeline" id="line-416"><code>	http2cipher_TLS_RSA_WITH_AES_256_CCM                     uint16 = 0xC09D</code></span>
<span class="codeline" id="line-417"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM                 uint16 = 0xC09E</code></span>
<span class="codeline" id="line-418"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM                 uint16 = 0xC09F</code></span>
<span class="codeline" id="line-419"><code>	http2cipher_TLS_RSA_WITH_AES_128_CCM_8                   uint16 = 0xC0A0</code></span>
<span class="codeline" id="line-420"><code>	http2cipher_TLS_RSA_WITH_AES_256_CCM_8                   uint16 = 0xC0A1</code></span>
<span class="codeline" id="line-421"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8               uint16 = 0xC0A2</code></span>
<span class="codeline" id="line-422"><code>	http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8               uint16 = 0xC0A3</code></span>
<span class="codeline" id="line-423"><code>	http2cipher_TLS_PSK_WITH_AES_128_CCM                     uint16 = 0xC0A4</code></span>
<span class="codeline" id="line-424"><code>	http2cipher_TLS_PSK_WITH_AES_256_CCM                     uint16 = 0xC0A5</code></span>
<span class="codeline" id="line-425"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM                 uint16 = 0xC0A6</code></span>
<span class="codeline" id="line-426"><code>	http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM                 uint16 = 0xC0A7</code></span>
<span class="codeline" id="line-427"><code>	http2cipher_TLS_PSK_WITH_AES_128_CCM_8                   uint16 = 0xC0A8</code></span>
<span class="codeline" id="line-428"><code>	http2cipher_TLS_PSK_WITH_AES_256_CCM_8                   uint16 = 0xC0A9</code></span>
<span class="codeline" id="line-429"><code>	http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8               uint16 = 0xC0AA</code></span>
<span class="codeline" id="line-430"><code>	http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8               uint16 = 0xC0AB</code></span>
<span class="codeline" id="line-431"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM             uint16 = 0xC0AC</code></span>
<span class="codeline" id="line-432"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM             uint16 = 0xC0AD</code></span>
<span class="codeline" id="line-433"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8           uint16 = 0xC0AE</code></span>
<span class="codeline" id="line-434"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8           uint16 = 0xC0AF</code></span>
<span class="codeline" id="line-435"><code>	// Unassigned uint16 =  0xC0B0-FF</code></span>
<span class="codeline" id="line-436"><code>	// Unassigned uint16 =  0xC1-CB,*</code></span>
<span class="codeline" id="line-437"><code>	// Unassigned uint16 =  0xCC00-A7</code></span>
<span class="codeline" id="line-438"><code>	http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xCCA8</code></span>
<span class="codeline" id="line-439"><code>	http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA9</code></span>
<span class="codeline" id="line-440"><code>	http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAA</code></span>
<span class="codeline" id="line-441"><code>	http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256         uint16 = 0xCCAB</code></span>
<span class="codeline" id="line-442"><code>	http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xCCAC</code></span>
<span class="codeline" id="line-443"><code>	http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAD</code></span>
<span class="codeline" id="line-444"><code>	http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256     uint16 = 0xCCAE</code></span>
<span class="codeline" id="line-445"><code>)</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>// isBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec.</code></span>
<span class="codeline" id="line-448"><code>// References:</code></span>
<span class="codeline" id="line-449"><code>// https://tools.ietf.org/html/rfc7540#appendix-A</code></span>
<span class="codeline" id="line-450"><code>// Reject cipher suites from Appendix A.</code></span>
<span class="codeline" id="line-451"><code>// "This list includes those cipher suites that do not</code></span>
<span class="codeline" id="line-452"><code>// offer an ephemeral key exchange and those that are</code></span>
<span class="codeline" id="line-453"><code>// based on the TLS null, stream or block cipher type"</code></span>
<span class="codeline" id="line-454"><code>func http2isBadCipher(cipher uint16) bool {</code></span>
<span class="codeline" id="line-455"><code>	switch cipher {</code></span>
<span class="codeline" id="line-456"><code>	case http2cipher_TLS_NULL_WITH_NULL_NULL,</code></span>
<span class="codeline" id="line-457"><code>		http2cipher_TLS_RSA_WITH_NULL_MD5,</code></span>
<span class="codeline" id="line-458"><code>		http2cipher_TLS_RSA_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-459"><code>		http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5,</code></span>
<span class="codeline" id="line-460"><code>		http2cipher_TLS_RSA_WITH_RC4_128_MD5,</code></span>
<span class="codeline" id="line-461"><code>		http2cipher_TLS_RSA_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-462"><code>		http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5,</code></span>
<span class="codeline" id="line-463"><code>		http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA,</code></span>
<span class="codeline" id="line-464"><code>		http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-465"><code>		http2cipher_TLS_RSA_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-466"><code>		http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-467"><code>		http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-468"><code>		http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-469"><code>		http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-470"><code>		http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-471"><code>		http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-472"><code>		http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-473"><code>		http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-474"><code>		http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-475"><code>		http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-476"><code>		http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-477"><code>		http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-478"><code>		http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-479"><code>		http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5,</code></span>
<span class="codeline" id="line-480"><code>		http2cipher_TLS_DH_anon_WITH_RC4_128_MD5,</code></span>
<span class="codeline" id="line-481"><code>		http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA,</code></span>
<span class="codeline" id="line-482"><code>		http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-483"><code>		http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-484"><code>		http2cipher_TLS_KRB5_WITH_DES_CBC_SHA,</code></span>
<span class="codeline" id="line-485"><code>		http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-486"><code>		http2cipher_TLS_KRB5_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-487"><code>		http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA,</code></span>
<span class="codeline" id="line-488"><code>		http2cipher_TLS_KRB5_WITH_DES_CBC_MD5,</code></span>
<span class="codeline" id="line-489"><code>		http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5,</code></span>
<span class="codeline" id="line-490"><code>		http2cipher_TLS_KRB5_WITH_RC4_128_MD5,</code></span>
<span class="codeline" id="line-491"><code>		http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5,</code></span>
<span class="codeline" id="line-492"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA,</code></span>
<span class="codeline" id="line-493"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA,</code></span>
<span class="codeline" id="line-494"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA,</code></span>
<span class="codeline" id="line-495"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5,</code></span>
<span class="codeline" id="line-496"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5,</code></span>
<span class="codeline" id="line-497"><code>		http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5,</code></span>
<span class="codeline" id="line-498"><code>		http2cipher_TLS_PSK_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-499"><code>		http2cipher_TLS_DHE_PSK_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-500"><code>		http2cipher_TLS_RSA_PSK_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-501"><code>		http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-502"><code>		http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-503"><code>		http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-504"><code>		http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-505"><code>		http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-506"><code>		http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-507"><code>		http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-508"><code>		http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-509"><code>		http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-510"><code>		http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-511"><code>		http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-512"><code>		http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-513"><code>		http2cipher_TLS_RSA_WITH_NULL_SHA256,</code></span>
<span class="codeline" id="line-514"><code>		http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-515"><code>		http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-516"><code>		http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-517"><code>		http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-518"><code>		http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-519"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-520"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-521"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-522"><code>		http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-523"><code>		http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-524"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA,</code></span>
<span class="codeline" id="line-525"><code>		http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-526"><code>		http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-527"><code>		http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-528"><code>		http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-529"><code>		http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-530"><code>		http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-531"><code>		http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-532"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-533"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-534"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-535"><code>		http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-536"><code>		http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-537"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA,</code></span>
<span class="codeline" id="line-538"><code>		http2cipher_TLS_PSK_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-539"><code>		http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-540"><code>		http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-541"><code>		http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-542"><code>		http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-543"><code>		http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-544"><code>		http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-545"><code>		http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-546"><code>		http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-547"><code>		http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-548"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-549"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-550"><code>		http2cipher_TLS_RSA_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-551"><code>		http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-552"><code>		http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-553"><code>		http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-554"><code>		http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-555"><code>		http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA,</code></span>
<span class="codeline" id="line-556"><code>		http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-557"><code>		http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-558"><code>		http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-559"><code>		http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-560"><code>		http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-561"><code>		http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-562"><code>		http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-563"><code>		http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-564"><code>		http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-565"><code>		http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-566"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-567"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-568"><code>		http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-569"><code>		http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-570"><code>		http2cipher_TLS_PSK_WITH_NULL_SHA256,</code></span>
<span class="codeline" id="line-571"><code>		http2cipher_TLS_PSK_WITH_NULL_SHA384,</code></span>
<span class="codeline" id="line-572"><code>		http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-573"><code>		http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-574"><code>		http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256,</code></span>
<span class="codeline" id="line-575"><code>		http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384,</code></span>
<span class="codeline" id="line-576"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-577"><code>		http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-578"><code>		http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256,</code></span>
<span class="codeline" id="line-579"><code>		http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384,</code></span>
<span class="codeline" id="line-580"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-581"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-582"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-583"><code>		http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-584"><code>		http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-585"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-586"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-587"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-588"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-589"><code>		http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-590"><code>		http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-591"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256,</code></span>
<span class="codeline" id="line-592"><code>		http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV,</code></span>
<span class="codeline" id="line-593"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-594"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-595"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-596"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-597"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-598"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-599"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-600"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-601"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-602"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-603"><code>		http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-604"><code>		http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-605"><code>		http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-606"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-607"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-608"><code>		http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-609"><code>		http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-610"><code>		http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-611"><code>		http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-612"><code>		http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-613"><code>		http2cipher_TLS_ECDH_anon_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-614"><code>		http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-615"><code>		http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-616"><code>		http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-617"><code>		http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-618"><code>		http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-619"><code>		http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-620"><code>		http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-621"><code>		http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-622"><code>		http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-623"><code>		http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-624"><code>		http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-625"><code>		http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-626"><code>		http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-627"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-628"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-629"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-630"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-631"><code>		http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-632"><code>		http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-633"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-634"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-635"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-636"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-637"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-638"><code>		http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-639"><code>		http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA,</code></span>
<span class="codeline" id="line-640"><code>		http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA,</code></span>
<span class="codeline" id="line-641"><code>		http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,</code></span>
<span class="codeline" id="line-642"><code>		http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,</code></span>
<span class="codeline" id="line-643"><code>		http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-644"><code>		http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-645"><code>		http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA,</code></span>
<span class="codeline" id="line-646"><code>		http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256,</code></span>
<span class="codeline" id="line-647"><code>		http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384,</code></span>
<span class="codeline" id="line-648"><code>		http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-649"><code>		http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-650"><code>		http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-651"><code>		http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-652"><code>		http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-653"><code>		http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-654"><code>		http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-655"><code>		http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-656"><code>		http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-657"><code>		http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-658"><code>		http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-659"><code>		http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-660"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-661"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-662"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-663"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-664"><code>		http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-665"><code>		http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-666"><code>		http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-667"><code>		http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-668"><code>		http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-669"><code>		http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-670"><code>		http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-671"><code>		http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-672"><code>		http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-673"><code>		http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-674"><code>		http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-675"><code>		http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-676"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-677"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-678"><code>		http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-679"><code>		http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-680"><code>		http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-681"><code>		http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-682"><code>		http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-683"><code>		http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-684"><code>		http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-685"><code>		http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-686"><code>		http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-687"><code>		http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-688"><code>		http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-689"><code>		http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-690"><code>		http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-691"><code>		http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-692"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-693"><code>		http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-694"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-695"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-696"><code>		http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-697"><code>		http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-698"><code>		http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-699"><code>		http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-700"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-701"><code>		http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-702"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-703"><code>		http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-704"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-705"><code>		http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-706"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-707"><code>		http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-708"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-709"><code>		http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-710"><code>		http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-711"><code>		http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-712"><code>		http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-713"><code>		http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-714"><code>		http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-715"><code>		http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384,</code></span>
<span class="codeline" id="line-716"><code>		http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-717"><code>		http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-718"><code>		http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-719"><code>		http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-720"><code>		http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-721"><code>		http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-722"><code>		http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,</code></span>
<span class="codeline" id="line-723"><code>		http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,</code></span>
<span class="codeline" id="line-724"><code>		http2cipher_TLS_RSA_WITH_AES_128_CCM,</code></span>
<span class="codeline" id="line-725"><code>		http2cipher_TLS_RSA_WITH_AES_256_CCM,</code></span>
<span class="codeline" id="line-726"><code>		http2cipher_TLS_RSA_WITH_AES_128_CCM_8,</code></span>
<span class="codeline" id="line-727"><code>		http2cipher_TLS_RSA_WITH_AES_256_CCM_8,</code></span>
<span class="codeline" id="line-728"><code>		http2cipher_TLS_PSK_WITH_AES_128_CCM,</code></span>
<span class="codeline" id="line-729"><code>		http2cipher_TLS_PSK_WITH_AES_256_CCM,</code></span>
<span class="codeline" id="line-730"><code>		http2cipher_TLS_PSK_WITH_AES_128_CCM_8,</code></span>
<span class="codeline" id="line-731"><code>		http2cipher_TLS_PSK_WITH_AES_256_CCM_8:</code></span>
<span class="codeline" id="line-732"><code>		return true</code></span>
<span class="codeline" id="line-733"><code>	default:</code></span>
<span class="codeline" id="line-734"><code>		return false</code></span>
<span class="codeline" id="line-735"><code>	}</code></span>
<span class="codeline" id="line-736"><code>}</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>// ClientConnPool manages a pool of HTTP/2 client connections.</code></span>
<span class="codeline" id="line-739"><code>type http2ClientConnPool interface {</code></span>
<span class="codeline" id="line-740"><code>	// GetClientConn returns a specific HTTP/2 connection (usually</code></span>
<span class="codeline" id="line-741"><code>	// a TLS-TCP connection) to an HTTP/2 server. On success, the</code></span>
<span class="codeline" id="line-742"><code>	// returned ClientConn accounts for the upcoming RoundTrip</code></span>
<span class="codeline" id="line-743"><code>	// call, so the caller should not omit it. If the caller needs</code></span>
<span class="codeline" id="line-744"><code>	// to, ClientConn.RoundTrip can be called with a bogus</code></span>
<span class="codeline" id="line-745"><code>	// new(http.Request) to release the stream reservation.</code></span>
<span class="codeline" id="line-746"><code>	GetClientConn(req *Request, addr string) (*http2ClientConn, error)</code></span>
<span class="codeline" id="line-747"><code>	MarkDead(*http2ClientConn)</code></span>
<span class="codeline" id="line-748"><code>}</code></span>
<span class="codeline" id="line-749"><code></code></span>
<span class="codeline" id="line-750"><code>// clientConnPoolIdleCloser is the interface implemented by ClientConnPool</code></span>
<span class="codeline" id="line-751"><code>// implementations which can close their idle connections.</code></span>
<span class="codeline" id="line-752"><code>type http2clientConnPoolIdleCloser interface {</code></span>
<span class="codeline" id="line-753"><code>	http2ClientConnPool</code></span>
<span class="codeline" id="line-754"><code>	closeIdleConnections()</code></span>
<span class="codeline" id="line-755"><code>}</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>var (</code></span>
<span class="codeline" id="line-758"><code>	_ http2clientConnPoolIdleCloser = (*http2clientConnPool)(nil)</code></span>
<span class="codeline" id="line-759"><code>	_ http2clientConnPoolIdleCloser = http2noDialClientConnPool{}</code></span>
<span class="codeline" id="line-760"><code>)</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>// TODO: use singleflight for dialing and addConnCalls?</code></span>
<span class="codeline" id="line-763"><code>type http2clientConnPool struct {</code></span>
<span class="codeline" id="line-764"><code>	t *http2Transport</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>	mu sync.Mutex // TODO: maybe switch to RWMutex</code></span>
<span class="codeline" id="line-767"><code>	// TODO: add support for sharing conns based on cert names</code></span>
<span class="codeline" id="line-768"><code>	// (e.g. share conn for googleapis.com and appspot.com)</code></span>
<span class="codeline" id="line-769"><code>	conns        map[string][]*http2ClientConn // key is host:port</code></span>
<span class="codeline" id="line-770"><code>	dialing      map[string]*http2dialCall     // currently in-flight dials</code></span>
<span class="codeline" id="line-771"><code>	keys         map[*http2ClientConn][]string</code></span>
<span class="codeline" id="line-772"><code>	addConnCalls map[string]*http2addConnCall // in-flight addConnIfNeeded calls</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>func (p *http2clientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-776"><code>	return p.getClientConn(req, addr, http2dialOnMiss)</code></span>
<span class="codeline" id="line-777"><code>}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>const (</code></span>
<span class="codeline" id="line-780"><code>	http2dialOnMiss   = true</code></span>
<span class="codeline" id="line-781"><code>	http2noDialOnMiss = false</code></span>
<span class="codeline" id="line-782"><code>)</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>func (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-785"><code>	// TODO(dneil): Dial a new connection when t.DisableKeepAlives is set?</code></span>
<span class="codeline" id="line-786"><code>	if http2isConnectionCloseRequest(req) &amp;&amp; dialOnMiss {</code></span>
<span class="codeline" id="line-787"><code>		// It gets its own connection.</code></span>
<span class="codeline" id="line-788"><code>		http2traceGetConn(req, addr)</code></span>
<span class="codeline" id="line-789"><code>		const singleUse = true</code></span>
<span class="codeline" id="line-790"><code>		cc, err := p.t.dialClientConn(req.Context(), addr, singleUse)</code></span>
<span class="codeline" id="line-791"><code>		if err != nil {</code></span>
<span class="codeline" id="line-792"><code>			return nil, err</code></span>
<span class="codeline" id="line-793"><code>		}</code></span>
<span class="codeline" id="line-794"><code>		return cc, nil</code></span>
<span class="codeline" id="line-795"><code>	}</code></span>
<span class="codeline" id="line-796"><code>	for {</code></span>
<span class="codeline" id="line-797"><code>		p.mu.Lock()</code></span>
<span class="codeline" id="line-798"><code>		for _, cc := range p.conns[addr] {</code></span>
<span class="codeline" id="line-799"><code>			if cc.ReserveNewRequest() {</code></span>
<span class="codeline" id="line-800"><code>				// When a connection is presented to us by the net/http package,</code></span>
<span class="codeline" id="line-801"><code>				// the GetConn hook has already been called.</code></span>
<span class="codeline" id="line-802"><code>				// Don't call it a second time here.</code></span>
<span class="codeline" id="line-803"><code>				if !cc.getConnCalled {</code></span>
<span class="codeline" id="line-804"><code>					http2traceGetConn(req, addr)</code></span>
<span class="codeline" id="line-805"><code>				}</code></span>
<span class="codeline" id="line-806"><code>				cc.getConnCalled = false</code></span>
<span class="codeline" id="line-807"><code>				p.mu.Unlock()</code></span>
<span class="codeline" id="line-808"><code>				return cc, nil</code></span>
<span class="codeline" id="line-809"><code>			}</code></span>
<span class="codeline" id="line-810"><code>		}</code></span>
<span class="codeline" id="line-811"><code>		if !dialOnMiss {</code></span>
<span class="codeline" id="line-812"><code>			p.mu.Unlock()</code></span>
<span class="codeline" id="line-813"><code>			return nil, http2ErrNoCachedConn</code></span>
<span class="codeline" id="line-814"><code>		}</code></span>
<span class="codeline" id="line-815"><code>		http2traceGetConn(req, addr)</code></span>
<span class="codeline" id="line-816"><code>		call := p.getStartDialLocked(req.Context(), addr)</code></span>
<span class="codeline" id="line-817"><code>		p.mu.Unlock()</code></span>
<span class="codeline" id="line-818"><code>		&lt;-call.done</code></span>
<span class="codeline" id="line-819"><code>		if http2shouldRetryDial(call, req) {</code></span>
<span class="codeline" id="line-820"><code>			continue</code></span>
<span class="codeline" id="line-821"><code>		}</code></span>
<span class="codeline" id="line-822"><code>		cc, err := call.res, call.err</code></span>
<span class="codeline" id="line-823"><code>		if err != nil {</code></span>
<span class="codeline" id="line-824"><code>			return nil, err</code></span>
<span class="codeline" id="line-825"><code>		}</code></span>
<span class="codeline" id="line-826"><code>		if cc.ReserveNewRequest() {</code></span>
<span class="codeline" id="line-827"><code>			return cc, nil</code></span>
<span class="codeline" id="line-828"><code>		}</code></span>
<span class="codeline" id="line-829"><code>	}</code></span>
<span class="codeline" id="line-830"><code>}</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>// dialCall is an in-flight Transport dial call to a host.</code></span>
<span class="codeline" id="line-833"><code>type http2dialCall struct {</code></span>
<span class="codeline" id="line-834"><code>	_ http2incomparable</code></span>
<span class="codeline" id="line-835"><code>	p *http2clientConnPool</code></span>
<span class="codeline" id="line-836"><code>	// the context associated with the request</code></span>
<span class="codeline" id="line-837"><code>	// that created this dialCall</code></span>
<span class="codeline" id="line-838"><code>	ctx  context.Context</code></span>
<span class="codeline" id="line-839"><code>	done chan struct{}    // closed when done</code></span>
<span class="codeline" id="line-840"><code>	res  *http2ClientConn // valid after done is closed</code></span>
<span class="codeline" id="line-841"><code>	err  error            // valid after done is closed</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>// requires p.mu is held.</code></span>
<span class="codeline" id="line-845"><code>func (p *http2clientConnPool) getStartDialLocked(ctx context.Context, addr string) *http2dialCall {</code></span>
<span class="codeline" id="line-846"><code>	if call, ok := p.dialing[addr]; ok {</code></span>
<span class="codeline" id="line-847"><code>		// A dial is already in-flight. Don't start another.</code></span>
<span class="codeline" id="line-848"><code>		return call</code></span>
<span class="codeline" id="line-849"><code>	}</code></span>
<span class="codeline" id="line-850"><code>	call := &amp;http2dialCall{p: p, done: make(chan struct{}), ctx: ctx}</code></span>
<span class="codeline" id="line-851"><code>	if p.dialing == nil {</code></span>
<span class="codeline" id="line-852"><code>		p.dialing = make(map[string]*http2dialCall)</code></span>
<span class="codeline" id="line-853"><code>	}</code></span>
<span class="codeline" id="line-854"><code>	p.dialing[addr] = call</code></span>
<span class="codeline" id="line-855"><code>	go call.dial(call.ctx, addr)</code></span>
<span class="codeline" id="line-856"><code>	return call</code></span>
<span class="codeline" id="line-857"><code>}</code></span>
<span class="codeline" id="line-858"><code></code></span>
<span class="codeline" id="line-859"><code>// run in its own goroutine.</code></span>
<span class="codeline" id="line-860"><code>func (c *http2dialCall) dial(ctx context.Context, addr string) {</code></span>
<span class="codeline" id="line-861"><code>	const singleUse = false // shared conn</code></span>
<span class="codeline" id="line-862"><code>	c.res, c.err = c.p.t.dialClientConn(ctx, addr, singleUse)</code></span>
<span class="codeline" id="line-863"><code></code></span>
<span class="codeline" id="line-864"><code>	c.p.mu.Lock()</code></span>
<span class="codeline" id="line-865"><code>	delete(c.p.dialing, addr)</code></span>
<span class="codeline" id="line-866"><code>	if c.err == nil {</code></span>
<span class="codeline" id="line-867"><code>		c.p.addConnLocked(addr, c.res)</code></span>
<span class="codeline" id="line-868"><code>	}</code></span>
<span class="codeline" id="line-869"><code>	c.p.mu.Unlock()</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>	close(c.done)</code></span>
<span class="codeline" id="line-872"><code>}</code></span>
<span class="codeline" id="line-873"><code></code></span>
<span class="codeline" id="line-874"><code>// addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't</code></span>
<span class="codeline" id="line-875"><code>// already exist. It coalesces concurrent calls with the same key.</code></span>
<span class="codeline" id="line-876"><code>// This is used by the http1 Transport code when it creates a new connection. Because</code></span>
<span class="codeline" id="line-877"><code>// the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know</code></span>
<span class="codeline" id="line-878"><code>// the protocol), it can get into a situation where it has multiple TLS connections.</code></span>
<span class="codeline" id="line-879"><code>// This code decides which ones live or die.</code></span>
<span class="codeline" id="line-880"><code>// The return value used is whether c was used.</code></span>
<span class="codeline" id="line-881"><code>// c is never closed.</code></span>
<span class="codeline" id="line-882"><code>func (p *http2clientConnPool) addConnIfNeeded(key string, t *http2Transport, c *tls.Conn) (used bool, err error) {</code></span>
<span class="codeline" id="line-883"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-884"><code>	for _, cc := range p.conns[key] {</code></span>
<span class="codeline" id="line-885"><code>		if cc.CanTakeNewRequest() {</code></span>
<span class="codeline" id="line-886"><code>			p.mu.Unlock()</code></span>
<span class="codeline" id="line-887"><code>			return false, nil</code></span>
<span class="codeline" id="line-888"><code>		}</code></span>
<span class="codeline" id="line-889"><code>	}</code></span>
<span class="codeline" id="line-890"><code>	call, dup := p.addConnCalls[key]</code></span>
<span class="codeline" id="line-891"><code>	if !dup {</code></span>
<span class="codeline" id="line-892"><code>		if p.addConnCalls == nil {</code></span>
<span class="codeline" id="line-893"><code>			p.addConnCalls = make(map[string]*http2addConnCall)</code></span>
<span class="codeline" id="line-894"><code>		}</code></span>
<span class="codeline" id="line-895"><code>		call = &amp;http2addConnCall{</code></span>
<span class="codeline" id="line-896"><code>			p:    p,</code></span>
<span class="codeline" id="line-897"><code>			done: make(chan struct{}),</code></span>
<span class="codeline" id="line-898"><code>		}</code></span>
<span class="codeline" id="line-899"><code>		p.addConnCalls[key] = call</code></span>
<span class="codeline" id="line-900"><code>		go call.run(t, key, c)</code></span>
<span class="codeline" id="line-901"><code>	}</code></span>
<span class="codeline" id="line-902"><code>	p.mu.Unlock()</code></span>
<span class="codeline" id="line-903"><code></code></span>
<span class="codeline" id="line-904"><code>	&lt;-call.done</code></span>
<span class="codeline" id="line-905"><code>	if call.err != nil {</code></span>
<span class="codeline" id="line-906"><code>		return false, call.err</code></span>
<span class="codeline" id="line-907"><code>	}</code></span>
<span class="codeline" id="line-908"><code>	return !dup, nil</code></span>
<span class="codeline" id="line-909"><code>}</code></span>
<span class="codeline" id="line-910"><code></code></span>
<span class="codeline" id="line-911"><code>type http2addConnCall struct {</code></span>
<span class="codeline" id="line-912"><code>	_    http2incomparable</code></span>
<span class="codeline" id="line-913"><code>	p    *http2clientConnPool</code></span>
<span class="codeline" id="line-914"><code>	done chan struct{} // closed when done</code></span>
<span class="codeline" id="line-915"><code>	err  error</code></span>
<span class="codeline" id="line-916"><code>}</code></span>
<span class="codeline" id="line-917"><code></code></span>
<span class="codeline" id="line-918"><code>func (c *http2addConnCall) run(t *http2Transport, key string, tc *tls.Conn) {</code></span>
<span class="codeline" id="line-919"><code>	cc, err := t.NewClientConn(tc)</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>	p := c.p</code></span>
<span class="codeline" id="line-922"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-923"><code>	if err != nil {</code></span>
<span class="codeline" id="line-924"><code>		c.err = err</code></span>
<span class="codeline" id="line-925"><code>	} else {</code></span>
<span class="codeline" id="line-926"><code>		cc.getConnCalled = true // already called by the net/http package</code></span>
<span class="codeline" id="line-927"><code>		p.addConnLocked(key, cc)</code></span>
<span class="codeline" id="line-928"><code>	}</code></span>
<span class="codeline" id="line-929"><code>	delete(p.addConnCalls, key)</code></span>
<span class="codeline" id="line-930"><code>	p.mu.Unlock()</code></span>
<span class="codeline" id="line-931"><code>	close(c.done)</code></span>
<span class="codeline" id="line-932"><code>}</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>// p.mu must be held</code></span>
<span class="codeline" id="line-935"><code>func (p *http2clientConnPool) addConnLocked(key string, cc *http2ClientConn) {</code></span>
<span class="codeline" id="line-936"><code>	for _, v := range p.conns[key] {</code></span>
<span class="codeline" id="line-937"><code>		if v == cc {</code></span>
<span class="codeline" id="line-938"><code>			return</code></span>
<span class="codeline" id="line-939"><code>		}</code></span>
<span class="codeline" id="line-940"><code>	}</code></span>
<span class="codeline" id="line-941"><code>	if p.conns == nil {</code></span>
<span class="codeline" id="line-942"><code>		p.conns = make(map[string][]*http2ClientConn)</code></span>
<span class="codeline" id="line-943"><code>	}</code></span>
<span class="codeline" id="line-944"><code>	if p.keys == nil {</code></span>
<span class="codeline" id="line-945"><code>		p.keys = make(map[*http2ClientConn][]string)</code></span>
<span class="codeline" id="line-946"><code>	}</code></span>
<span class="codeline" id="line-947"><code>	p.conns[key] = append(p.conns[key], cc)</code></span>
<span class="codeline" id="line-948"><code>	p.keys[cc] = append(p.keys[cc], key)</code></span>
<span class="codeline" id="line-949"><code>}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>func (p *http2clientConnPool) MarkDead(cc *http2ClientConn) {</code></span>
<span class="codeline" id="line-952"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-953"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-954"><code>	for _, key := range p.keys[cc] {</code></span>
<span class="codeline" id="line-955"><code>		vv, ok := p.conns[key]</code></span>
<span class="codeline" id="line-956"><code>		if !ok {</code></span>
<span class="codeline" id="line-957"><code>			continue</code></span>
<span class="codeline" id="line-958"><code>		}</code></span>
<span class="codeline" id="line-959"><code>		newList := http2filterOutClientConn(vv, cc)</code></span>
<span class="codeline" id="line-960"><code>		if len(newList) &gt; 0 {</code></span>
<span class="codeline" id="line-961"><code>			p.conns[key] = newList</code></span>
<span class="codeline" id="line-962"><code>		} else {</code></span>
<span class="codeline" id="line-963"><code>			delete(p.conns, key)</code></span>
<span class="codeline" id="line-964"><code>		}</code></span>
<span class="codeline" id="line-965"><code>	}</code></span>
<span class="codeline" id="line-966"><code>	delete(p.keys, cc)</code></span>
<span class="codeline" id="line-967"><code>}</code></span>
<span class="codeline" id="line-968"><code></code></span>
<span class="codeline" id="line-969"><code>func (p *http2clientConnPool) closeIdleConnections() {</code></span>
<span class="codeline" id="line-970"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-971"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-972"><code>	// TODO: don't close a cc if it was just added to the pool</code></span>
<span class="codeline" id="line-973"><code>	// milliseconds ago and has never been used. There's currently</code></span>
<span class="codeline" id="line-974"><code>	// a small race window with the HTTP/1 Transport's integration</code></span>
<span class="codeline" id="line-975"><code>	// where it can add an idle conn just before using it, and</code></span>
<span class="codeline" id="line-976"><code>	// somebody else can concurrently call CloseIdleConns and</code></span>
<span class="codeline" id="line-977"><code>	// break some caller's RoundTrip.</code></span>
<span class="codeline" id="line-978"><code>	for _, vv := range p.conns {</code></span>
<span class="codeline" id="line-979"><code>		for _, cc := range vv {</code></span>
<span class="codeline" id="line-980"><code>			cc.closeIfIdle()</code></span>
<span class="codeline" id="line-981"><code>		}</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>}</code></span>
<span class="codeline" id="line-984"><code></code></span>
<span class="codeline" id="line-985"><code>func http2filterOutClientConn(in []*http2ClientConn, exclude *http2ClientConn) []*http2ClientConn {</code></span>
<span class="codeline" id="line-986"><code>	out := in[:0]</code></span>
<span class="codeline" id="line-987"><code>	for _, v := range in {</code></span>
<span class="codeline" id="line-988"><code>		if v != exclude {</code></span>
<span class="codeline" id="line-989"><code>			out = append(out, v)</code></span>
<span class="codeline" id="line-990"><code>		}</code></span>
<span class="codeline" id="line-991"><code>	}</code></span>
<span class="codeline" id="line-992"><code>	// If we filtered it out, zero out the last item to prevent</code></span>
<span class="codeline" id="line-993"><code>	// the GC from seeing it.</code></span>
<span class="codeline" id="line-994"><code>	if len(in) != len(out) {</code></span>
<span class="codeline" id="line-995"><code>		in[len(in)-1] = nil</code></span>
<span class="codeline" id="line-996"><code>	}</code></span>
<span class="codeline" id="line-997"><code>	return out</code></span>
<span class="codeline" id="line-998"><code>}</code></span>
<span class="codeline" id="line-999"><code></code></span>
<span class="codeline" id="line-1000"><code>// noDialClientConnPool is an implementation of http2.ClientConnPool</code></span>
<span class="codeline" id="line-1001"><code>// which never dials. We let the HTTP/1.1 client dial and use its TLS</code></span>
<span class="codeline" id="line-1002"><code>// connection instead.</code></span>
<span class="codeline" id="line-1003"><code>type http2noDialClientConnPool struct{ *http2clientConnPool }</code></span>
<span class="codeline" id="line-1004"><code></code></span>
<span class="codeline" id="line-1005"><code>func (p http2noDialClientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-1006"><code>	return p.getClientConn(req, addr, http2noDialOnMiss)</code></span>
<span class="codeline" id="line-1007"><code>}</code></span>
<span class="codeline" id="line-1008"><code></code></span>
<span class="codeline" id="line-1009"><code>// shouldRetryDial reports whether the current request should</code></span>
<span class="codeline" id="line-1010"><code>// retry dialing after the call finished unsuccessfully, for example</code></span>
<span class="codeline" id="line-1011"><code>// if the dial was canceled because of a context cancellation or</code></span>
<span class="codeline" id="line-1012"><code>// deadline expiry.</code></span>
<span class="codeline" id="line-1013"><code>func http2shouldRetryDial(call *http2dialCall, req *Request) bool {</code></span>
<span class="codeline" id="line-1014"><code>	if call.err == nil {</code></span>
<span class="codeline" id="line-1015"><code>		// No error, no need to retry</code></span>
<span class="codeline" id="line-1016"><code>		return false</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code>	if call.ctx == req.Context() {</code></span>
<span class="codeline" id="line-1019"><code>		// If the call has the same context as the request, the dial</code></span>
<span class="codeline" id="line-1020"><code>		// should not be retried, since any cancellation will have come</code></span>
<span class="codeline" id="line-1021"><code>		// from this request.</code></span>
<span class="codeline" id="line-1022"><code>		return false</code></span>
<span class="codeline" id="line-1023"><code>	}</code></span>
<span class="codeline" id="line-1024"><code>	if !errors.Is(call.err, context.Canceled) &amp;&amp; !errors.Is(call.err, context.DeadlineExceeded) {</code></span>
<span class="codeline" id="line-1025"><code>		// If the call error is not because of a context cancellation or a deadline expiry,</code></span>
<span class="codeline" id="line-1026"><code>		// the dial should not be retried.</code></span>
<span class="codeline" id="line-1027"><code>		return false</code></span>
<span class="codeline" id="line-1028"><code>	}</code></span>
<span class="codeline" id="line-1029"><code>	// Only retry if the error is a context cancellation error or deadline expiry</code></span>
<span class="codeline" id="line-1030"><code>	// and the context associated with the call was canceled or expired.</code></span>
<span class="codeline" id="line-1031"><code>	return call.ctx.Err() != nil</code></span>
<span class="codeline" id="line-1032"><code>}</code></span>
<span class="codeline" id="line-1033"><code></code></span>
<span class="codeline" id="line-1034"><code>// Buffer chunks are allocated from a pool to reduce pressure on GC.</code></span>
<span class="codeline" id="line-1035"><code>// The maximum wasted space per dataBuffer is 2x the largest size class,</code></span>
<span class="codeline" id="line-1036"><code>// which happens when the dataBuffer has multiple chunks and there is</code></span>
<span class="codeline" id="line-1037"><code>// one unread byte in both the first and last chunks. We use a few size</code></span>
<span class="codeline" id="line-1038"><code>// classes to minimize overheads for servers that typically receive very</code></span>
<span class="codeline" id="line-1039"><code>// small request bodies.</code></span>
<span class="codeline" id="line-1040"><code>//</code></span>
<span class="codeline" id="line-1041"><code>// TODO: Benchmark to determine if the pools are necessary. The GC may have</code></span>
<span class="codeline" id="line-1042"><code>// improved enough that we can instead allocate chunks like this:</code></span>
<span class="codeline" id="line-1043"><code>// make([]byte, max(16&lt;&lt;10, expectedBytesRemaining))</code></span>
<span class="codeline" id="line-1044"><code>var http2dataChunkPools = [...]sync.Pool{</code></span>
<span class="codeline" id="line-1045"><code>	{New: func() interface{} { return new([1 &lt;&lt; 10]byte) }},</code></span>
<span class="codeline" id="line-1046"><code>	{New: func() interface{} { return new([2 &lt;&lt; 10]byte) }},</code></span>
<span class="codeline" id="line-1047"><code>	{New: func() interface{} { return new([4 &lt;&lt; 10]byte) }},</code></span>
<span class="codeline" id="line-1048"><code>	{New: func() interface{} { return new([8 &lt;&lt; 10]byte) }},</code></span>
<span class="codeline" id="line-1049"><code>	{New: func() interface{} { return new([16 &lt;&lt; 10]byte) }},</code></span>
<span class="codeline" id="line-1050"><code>}</code></span>
<span class="codeline" id="line-1051"><code></code></span>
<span class="codeline" id="line-1052"><code>func http2getDataBufferChunk(size int64) []byte {</code></span>
<span class="codeline" id="line-1053"><code>	switch {</code></span>
<span class="codeline" id="line-1054"><code>	case size &lt;= 1&lt;&lt;10:</code></span>
<span class="codeline" id="line-1055"><code>		return http2dataChunkPools[0].Get().(*[1 &lt;&lt; 10]byte)[:]</code></span>
<span class="codeline" id="line-1056"><code>	case size &lt;= 2&lt;&lt;10:</code></span>
<span class="codeline" id="line-1057"><code>		return http2dataChunkPools[1].Get().(*[2 &lt;&lt; 10]byte)[:]</code></span>
<span class="codeline" id="line-1058"><code>	case size &lt;= 4&lt;&lt;10:</code></span>
<span class="codeline" id="line-1059"><code>		return http2dataChunkPools[2].Get().(*[4 &lt;&lt; 10]byte)[:]</code></span>
<span class="codeline" id="line-1060"><code>	case size &lt;= 8&lt;&lt;10:</code></span>
<span class="codeline" id="line-1061"><code>		return http2dataChunkPools[3].Get().(*[8 &lt;&lt; 10]byte)[:]</code></span>
<span class="codeline" id="line-1062"><code>	default:</code></span>
<span class="codeline" id="line-1063"><code>		return http2dataChunkPools[4].Get().(*[16 &lt;&lt; 10]byte)[:]</code></span>
<span class="codeline" id="line-1064"><code>	}</code></span>
<span class="codeline" id="line-1065"><code>}</code></span>
<span class="codeline" id="line-1066"><code></code></span>
<span class="codeline" id="line-1067"><code>func http2putDataBufferChunk(p []byte) {</code></span>
<span class="codeline" id="line-1068"><code>	switch len(p) {</code></span>
<span class="codeline" id="line-1069"><code>	case 1 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-1070"><code>		http2dataChunkPools[0].Put((*[1 &lt;&lt; 10]byte)(p))</code></span>
<span class="codeline" id="line-1071"><code>	case 2 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-1072"><code>		http2dataChunkPools[1].Put((*[2 &lt;&lt; 10]byte)(p))</code></span>
<span class="codeline" id="line-1073"><code>	case 4 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-1074"><code>		http2dataChunkPools[2].Put((*[4 &lt;&lt; 10]byte)(p))</code></span>
<span class="codeline" id="line-1075"><code>	case 8 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-1076"><code>		http2dataChunkPools[3].Put((*[8 &lt;&lt; 10]byte)(p))</code></span>
<span class="codeline" id="line-1077"><code>	case 16 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-1078"><code>		http2dataChunkPools[4].Put((*[16 &lt;&lt; 10]byte)(p))</code></span>
<span class="codeline" id="line-1079"><code>	default:</code></span>
<span class="codeline" id="line-1080"><code>		panic(fmt.Sprintf("unexpected buffer len=%v", len(p)))</code></span>
<span class="codeline" id="line-1081"><code>	}</code></span>
<span class="codeline" id="line-1082"><code>}</code></span>
<span class="codeline" id="line-1083"><code></code></span>
<span class="codeline" id="line-1084"><code>// dataBuffer is an io.ReadWriter backed by a list of data chunks.</code></span>
<span class="codeline" id="line-1085"><code>// Each dataBuffer is used to read DATA frames on a single stream.</code></span>
<span class="codeline" id="line-1086"><code>// The buffer is divided into chunks so the server can limit the</code></span>
<span class="codeline" id="line-1087"><code>// total memory used by a single connection without limiting the</code></span>
<span class="codeline" id="line-1088"><code>// request body size on any single stream.</code></span>
<span class="codeline" id="line-1089"><code>type http2dataBuffer struct {</code></span>
<span class="codeline" id="line-1090"><code>	chunks   [][]byte</code></span>
<span class="codeline" id="line-1091"><code>	r        int   // next byte to read is chunks[0][r]</code></span>
<span class="codeline" id="line-1092"><code>	w        int   // next byte to write is chunks[len(chunks)-1][w]</code></span>
<span class="codeline" id="line-1093"><code>	size     int   // total buffered bytes</code></span>
<span class="codeline" id="line-1094"><code>	expected int64 // we expect at least this many bytes in future Write calls (ignored if &lt;= 0)</code></span>
<span class="codeline" id="line-1095"><code>}</code></span>
<span class="codeline" id="line-1096"><code></code></span>
<span class="codeline" id="line-1097"><code>var http2errReadEmpty = errors.New("read from empty dataBuffer")</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>// Read copies bytes from the buffer into p.</code></span>
<span class="codeline" id="line-1100"><code>// It is an error to read when no data is available.</code></span>
<span class="codeline" id="line-1101"><code>func (b *http2dataBuffer) Read(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-1102"><code>	if b.size == 0 {</code></span>
<span class="codeline" id="line-1103"><code>		return 0, http2errReadEmpty</code></span>
<span class="codeline" id="line-1104"><code>	}</code></span>
<span class="codeline" id="line-1105"><code>	var ntotal int</code></span>
<span class="codeline" id="line-1106"><code>	for len(p) &gt; 0 &amp;&amp; b.size &gt; 0 {</code></span>
<span class="codeline" id="line-1107"><code>		readFrom := b.bytesFromFirstChunk()</code></span>
<span class="codeline" id="line-1108"><code>		n := copy(p, readFrom)</code></span>
<span class="codeline" id="line-1109"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-1110"><code>		ntotal += n</code></span>
<span class="codeline" id="line-1111"><code>		b.r += n</code></span>
<span class="codeline" id="line-1112"><code>		b.size -= n</code></span>
<span class="codeline" id="line-1113"><code>		// If the first chunk has been consumed, advance to the next chunk.</code></span>
<span class="codeline" id="line-1114"><code>		if b.r == len(b.chunks[0]) {</code></span>
<span class="codeline" id="line-1115"><code>			http2putDataBufferChunk(b.chunks[0])</code></span>
<span class="codeline" id="line-1116"><code>			end := len(b.chunks) - 1</code></span>
<span class="codeline" id="line-1117"><code>			copy(b.chunks[:end], b.chunks[1:])</code></span>
<span class="codeline" id="line-1118"><code>			b.chunks[end] = nil</code></span>
<span class="codeline" id="line-1119"><code>			b.chunks = b.chunks[:end]</code></span>
<span class="codeline" id="line-1120"><code>			b.r = 0</code></span>
<span class="codeline" id="line-1121"><code>		}</code></span>
<span class="codeline" id="line-1122"><code>	}</code></span>
<span class="codeline" id="line-1123"><code>	return ntotal, nil</code></span>
<span class="codeline" id="line-1124"><code>}</code></span>
<span class="codeline" id="line-1125"><code></code></span>
<span class="codeline" id="line-1126"><code>func (b *http2dataBuffer) bytesFromFirstChunk() []byte {</code></span>
<span class="codeline" id="line-1127"><code>	if len(b.chunks) == 1 {</code></span>
<span class="codeline" id="line-1128"><code>		return b.chunks[0][b.r:b.w]</code></span>
<span class="codeline" id="line-1129"><code>	}</code></span>
<span class="codeline" id="line-1130"><code>	return b.chunks[0][b.r:]</code></span>
<span class="codeline" id="line-1131"><code>}</code></span>
<span class="codeline" id="line-1132"><code></code></span>
<span class="codeline" id="line-1133"><code>// Len returns the number of bytes of the unread portion of the buffer.</code></span>
<span class="codeline" id="line-1134"><code>func (b *http2dataBuffer) Len() int {</code></span>
<span class="codeline" id="line-1135"><code>	return b.size</code></span>
<span class="codeline" id="line-1136"><code>}</code></span>
<span class="codeline" id="line-1137"><code></code></span>
<span class="codeline" id="line-1138"><code>// Write appends p to the buffer.</code></span>
<span class="codeline" id="line-1139"><code>func (b *http2dataBuffer) Write(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-1140"><code>	ntotal := len(p)</code></span>
<span class="codeline" id="line-1141"><code>	for len(p) &gt; 0 {</code></span>
<span class="codeline" id="line-1142"><code>		// If the last chunk is empty, allocate a new chunk. Try to allocate</code></span>
<span class="codeline" id="line-1143"><code>		// enough to fully copy p plus any additional bytes we expect to</code></span>
<span class="codeline" id="line-1144"><code>		// receive. However, this may allocate less than len(p).</code></span>
<span class="codeline" id="line-1145"><code>		want := int64(len(p))</code></span>
<span class="codeline" id="line-1146"><code>		if b.expected &gt; want {</code></span>
<span class="codeline" id="line-1147"><code>			want = b.expected</code></span>
<span class="codeline" id="line-1148"><code>		}</code></span>
<span class="codeline" id="line-1149"><code>		chunk := b.lastChunkOrAlloc(want)</code></span>
<span class="codeline" id="line-1150"><code>		n := copy(chunk[b.w:], p)</code></span>
<span class="codeline" id="line-1151"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-1152"><code>		b.w += n</code></span>
<span class="codeline" id="line-1153"><code>		b.size += n</code></span>
<span class="codeline" id="line-1154"><code>		b.expected -= int64(n)</code></span>
<span class="codeline" id="line-1155"><code>	}</code></span>
<span class="codeline" id="line-1156"><code>	return ntotal, nil</code></span>
<span class="codeline" id="line-1157"><code>}</code></span>
<span class="codeline" id="line-1158"><code></code></span>
<span class="codeline" id="line-1159"><code>func (b *http2dataBuffer) lastChunkOrAlloc(want int64) []byte {</code></span>
<span class="codeline" id="line-1160"><code>	if len(b.chunks) != 0 {</code></span>
<span class="codeline" id="line-1161"><code>		last := b.chunks[len(b.chunks)-1]</code></span>
<span class="codeline" id="line-1162"><code>		if b.w &lt; len(last) {</code></span>
<span class="codeline" id="line-1163"><code>			return last</code></span>
<span class="codeline" id="line-1164"><code>		}</code></span>
<span class="codeline" id="line-1165"><code>	}</code></span>
<span class="codeline" id="line-1166"><code>	chunk := http2getDataBufferChunk(want)</code></span>
<span class="codeline" id="line-1167"><code>	b.chunks = append(b.chunks, chunk)</code></span>
<span class="codeline" id="line-1168"><code>	b.w = 0</code></span>
<span class="codeline" id="line-1169"><code>	return chunk</code></span>
<span class="codeline" id="line-1170"><code>}</code></span>
<span class="codeline" id="line-1171"><code></code></span>
<span class="codeline" id="line-1172"><code>// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.</code></span>
<span class="codeline" id="line-1173"><code>type http2ErrCode uint32</code></span>
<span class="codeline" id="line-1174"><code></code></span>
<span class="codeline" id="line-1175"><code>const (</code></span>
<span class="codeline" id="line-1176"><code>	http2ErrCodeNo                 http2ErrCode = 0x0</code></span>
<span class="codeline" id="line-1177"><code>	http2ErrCodeProtocol           http2ErrCode = 0x1</code></span>
<span class="codeline" id="line-1178"><code>	http2ErrCodeInternal           http2ErrCode = 0x2</code></span>
<span class="codeline" id="line-1179"><code>	http2ErrCodeFlowControl        http2ErrCode = 0x3</code></span>
<span class="codeline" id="line-1180"><code>	http2ErrCodeSettingsTimeout    http2ErrCode = 0x4</code></span>
<span class="codeline" id="line-1181"><code>	http2ErrCodeStreamClosed       http2ErrCode = 0x5</code></span>
<span class="codeline" id="line-1182"><code>	http2ErrCodeFrameSize          http2ErrCode = 0x6</code></span>
<span class="codeline" id="line-1183"><code>	http2ErrCodeRefusedStream      http2ErrCode = 0x7</code></span>
<span class="codeline" id="line-1184"><code>	http2ErrCodeCancel             http2ErrCode = 0x8</code></span>
<span class="codeline" id="line-1185"><code>	http2ErrCodeCompression        http2ErrCode = 0x9</code></span>
<span class="codeline" id="line-1186"><code>	http2ErrCodeConnect            http2ErrCode = 0xa</code></span>
<span class="codeline" id="line-1187"><code>	http2ErrCodeEnhanceYourCalm    http2ErrCode = 0xb</code></span>
<span class="codeline" id="line-1188"><code>	http2ErrCodeInadequateSecurity http2ErrCode = 0xc</code></span>
<span class="codeline" id="line-1189"><code>	http2ErrCodeHTTP11Required     http2ErrCode = 0xd</code></span>
<span class="codeline" id="line-1190"><code>)</code></span>
<span class="codeline" id="line-1191"><code></code></span>
<span class="codeline" id="line-1192"><code>var http2errCodeName = map[http2ErrCode]string{</code></span>
<span class="codeline" id="line-1193"><code>	http2ErrCodeNo:                 "NO_ERROR",</code></span>
<span class="codeline" id="line-1194"><code>	http2ErrCodeProtocol:           "PROTOCOL_ERROR",</code></span>
<span class="codeline" id="line-1195"><code>	http2ErrCodeInternal:           "INTERNAL_ERROR",</code></span>
<span class="codeline" id="line-1196"><code>	http2ErrCodeFlowControl:        "FLOW_CONTROL_ERROR",</code></span>
<span class="codeline" id="line-1197"><code>	http2ErrCodeSettingsTimeout:    "SETTINGS_TIMEOUT",</code></span>
<span class="codeline" id="line-1198"><code>	http2ErrCodeStreamClosed:       "STREAM_CLOSED",</code></span>
<span class="codeline" id="line-1199"><code>	http2ErrCodeFrameSize:          "FRAME_SIZE_ERROR",</code></span>
<span class="codeline" id="line-1200"><code>	http2ErrCodeRefusedStream:      "REFUSED_STREAM",</code></span>
<span class="codeline" id="line-1201"><code>	http2ErrCodeCancel:             "CANCEL",</code></span>
<span class="codeline" id="line-1202"><code>	http2ErrCodeCompression:        "COMPRESSION_ERROR",</code></span>
<span class="codeline" id="line-1203"><code>	http2ErrCodeConnect:            "CONNECT_ERROR",</code></span>
<span class="codeline" id="line-1204"><code>	http2ErrCodeEnhanceYourCalm:    "ENHANCE_YOUR_CALM",</code></span>
<span class="codeline" id="line-1205"><code>	http2ErrCodeInadequateSecurity: "INADEQUATE_SECURITY",</code></span>
<span class="codeline" id="line-1206"><code>	http2ErrCodeHTTP11Required:     "HTTP_1_1_REQUIRED",</code></span>
<span class="codeline" id="line-1207"><code>}</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>func (e http2ErrCode) String() string {</code></span>
<span class="codeline" id="line-1210"><code>	if s, ok := http2errCodeName[e]; ok {</code></span>
<span class="codeline" id="line-1211"><code>		return s</code></span>
<span class="codeline" id="line-1212"><code>	}</code></span>
<span class="codeline" id="line-1213"><code>	return fmt.Sprintf("unknown error code 0x%x", uint32(e))</code></span>
<span class="codeline" id="line-1214"><code>}</code></span>
<span class="codeline" id="line-1215"><code></code></span>
<span class="codeline" id="line-1216"><code>func (e http2ErrCode) stringToken() string {</code></span>
<span class="codeline" id="line-1217"><code>	if s, ok := http2errCodeName[e]; ok {</code></span>
<span class="codeline" id="line-1218"><code>		return s</code></span>
<span class="codeline" id="line-1219"><code>	}</code></span>
<span class="codeline" id="line-1220"><code>	return fmt.Sprintf("ERR_UNKNOWN_%d", uint32(e))</code></span>
<span class="codeline" id="line-1221"><code>}</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>// ConnectionError is an error that results in the termination of the</code></span>
<span class="codeline" id="line-1224"><code>// entire connection.</code></span>
<span class="codeline" id="line-1225"><code>type http2ConnectionError http2ErrCode</code></span>
<span class="codeline" id="line-1226"><code></code></span>
<span class="codeline" id="line-1227"><code>func (e http2ConnectionError) Error() string {</code></span>
<span class="codeline" id="line-1228"><code>	return fmt.Sprintf("connection error: %s", http2ErrCode(e))</code></span>
<span class="codeline" id="line-1229"><code>}</code></span>
<span class="codeline" id="line-1230"><code></code></span>
<span class="codeline" id="line-1231"><code>// StreamError is an error that only affects one stream within an</code></span>
<span class="codeline" id="line-1232"><code>// HTTP/2 connection.</code></span>
<span class="codeline" id="line-1233"><code>type http2StreamError struct {</code></span>
<span class="codeline" id="line-1234"><code>	StreamID uint32</code></span>
<span class="codeline" id="line-1235"><code>	Code     http2ErrCode</code></span>
<span class="codeline" id="line-1236"><code>	Cause    error // optional additional detail</code></span>
<span class="codeline" id="line-1237"><code>}</code></span>
<span class="codeline" id="line-1238"><code></code></span>
<span class="codeline" id="line-1239"><code>// errFromPeer is a sentinel error value for StreamError.Cause to</code></span>
<span class="codeline" id="line-1240"><code>// indicate that the StreamError was sent from the peer over the wire</code></span>
<span class="codeline" id="line-1241"><code>// and wasn't locally generated in the Transport.</code></span>
<span class="codeline" id="line-1242"><code>var http2errFromPeer = errors.New("received from peer")</code></span>
<span class="codeline" id="line-1243"><code></code></span>
<span class="codeline" id="line-1244"><code>func http2streamError(id uint32, code http2ErrCode) http2StreamError {</code></span>
<span class="codeline" id="line-1245"><code>	return http2StreamError{StreamID: id, Code: code}</code></span>
<span class="codeline" id="line-1246"><code>}</code></span>
<span class="codeline" id="line-1247"><code></code></span>
<span class="codeline" id="line-1248"><code>func (e http2StreamError) Error() string {</code></span>
<span class="codeline" id="line-1249"><code>	if e.Cause != nil {</code></span>
<span class="codeline" id="line-1250"><code>		return fmt.Sprintf("stream error: stream ID %d; %v; %v", e.StreamID, e.Code, e.Cause)</code></span>
<span class="codeline" id="line-1251"><code>	}</code></span>
<span class="codeline" id="line-1252"><code>	return fmt.Sprintf("stream error: stream ID %d; %v", e.StreamID, e.Code)</code></span>
<span class="codeline" id="line-1253"><code>}</code></span>
<span class="codeline" id="line-1254"><code></code></span>
<span class="codeline" id="line-1255"><code>// 6.9.1 The Flow Control Window</code></span>
<span class="codeline" id="line-1256"><code>// "If a sender receives a WINDOW_UPDATE that causes a flow control</code></span>
<span class="codeline" id="line-1257"><code>// window to exceed this maximum it MUST terminate either the stream</code></span>
<span class="codeline" id="line-1258"><code>// or the connection, as appropriate. For streams, [...]; for the</code></span>
<span class="codeline" id="line-1259"><code>// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."</code></span>
<span class="codeline" id="line-1260"><code>type http2goAwayFlowError struct{}</code></span>
<span class="codeline" id="line-1261"><code></code></span>
<span class="codeline" id="line-1262"><code>func (http2goAwayFlowError) Error() string { return "connection exceeded flow control window size" }</code></span>
<span class="codeline" id="line-1263"><code></code></span>
<span class="codeline" id="line-1264"><code>// connError represents an HTTP/2 ConnectionError error code, along</code></span>
<span class="codeline" id="line-1265"><code>// with a string (for debugging) explaining why.</code></span>
<span class="codeline" id="line-1266"><code>//</code></span>
<span class="codeline" id="line-1267"><code>// Errors of this type are only returned by the frame parser functions</code></span>
<span class="codeline" id="line-1268"><code>// and converted into ConnectionError(Code), after stashing away</code></span>
<span class="codeline" id="line-1269"><code>// the Reason into the Framer's errDetail field, accessible via</code></span>
<span class="codeline" id="line-1270"><code>// the (*Framer).ErrorDetail method.</code></span>
<span class="codeline" id="line-1271"><code>type http2connError struct {</code></span>
<span class="codeline" id="line-1272"><code>	Code   http2ErrCode // the ConnectionError error code</code></span>
<span class="codeline" id="line-1273"><code>	Reason string       // additional reason</code></span>
<span class="codeline" id="line-1274"><code>}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>func (e http2connError) Error() string {</code></span>
<span class="codeline" id="line-1277"><code>	return fmt.Sprintf("http2: connection error: %v: %v", e.Code, e.Reason)</code></span>
<span class="codeline" id="line-1278"><code>}</code></span>
<span class="codeline" id="line-1279"><code></code></span>
<span class="codeline" id="line-1280"><code>type http2pseudoHeaderError string</code></span>
<span class="codeline" id="line-1281"><code></code></span>
<span class="codeline" id="line-1282"><code>func (e http2pseudoHeaderError) Error() string {</code></span>
<span class="codeline" id="line-1283"><code>	return fmt.Sprintf("invalid pseudo-header %q", string(e))</code></span>
<span class="codeline" id="line-1284"><code>}</code></span>
<span class="codeline" id="line-1285"><code></code></span>
<span class="codeline" id="line-1286"><code>type http2duplicatePseudoHeaderError string</code></span>
<span class="codeline" id="line-1287"><code></code></span>
<span class="codeline" id="line-1288"><code>func (e http2duplicatePseudoHeaderError) Error() string {</code></span>
<span class="codeline" id="line-1289"><code>	return fmt.Sprintf("duplicate pseudo-header %q", string(e))</code></span>
<span class="codeline" id="line-1290"><code>}</code></span>
<span class="codeline" id="line-1291"><code></code></span>
<span class="codeline" id="line-1292"><code>type http2headerFieldNameError string</code></span>
<span class="codeline" id="line-1293"><code></code></span>
<span class="codeline" id="line-1294"><code>func (e http2headerFieldNameError) Error() string {</code></span>
<span class="codeline" id="line-1295"><code>	return fmt.Sprintf("invalid header field name %q", string(e))</code></span>
<span class="codeline" id="line-1296"><code>}</code></span>
<span class="codeline" id="line-1297"><code></code></span>
<span class="codeline" id="line-1298"><code>type http2headerFieldValueError string</code></span>
<span class="codeline" id="line-1299"><code></code></span>
<span class="codeline" id="line-1300"><code>func (e http2headerFieldValueError) Error() string {</code></span>
<span class="codeline" id="line-1301"><code>	return fmt.Sprintf("invalid header field value for %q", string(e))</code></span>
<span class="codeline" id="line-1302"><code>}</code></span>
<span class="codeline" id="line-1303"><code></code></span>
<span class="codeline" id="line-1304"><code>var (</code></span>
<span class="codeline" id="line-1305"><code>	http2errMixPseudoHeaderTypes = errors.New("mix of request and response pseudo headers")</code></span>
<span class="codeline" id="line-1306"><code>	http2errPseudoAfterRegular   = errors.New("pseudo header field after regular")</code></span>
<span class="codeline" id="line-1307"><code>)</code></span>
<span class="codeline" id="line-1308"><code></code></span>
<span class="codeline" id="line-1309"><code>// inflowMinRefresh is the minimum number of bytes we'll send for a</code></span>
<span class="codeline" id="line-1310"><code>// flow control window update.</code></span>
<span class="codeline" id="line-1311"><code>const http2inflowMinRefresh = 4 &lt;&lt; 10</code></span>
<span class="codeline" id="line-1312"><code></code></span>
<span class="codeline" id="line-1313"><code>// inflow accounts for an inbound flow control window.</code></span>
<span class="codeline" id="line-1314"><code>// It tracks both the latest window sent to the peer (used for enforcement)</code></span>
<span class="codeline" id="line-1315"><code>// and the accumulated unsent window.</code></span>
<span class="codeline" id="line-1316"><code>type http2inflow struct {</code></span>
<span class="codeline" id="line-1317"><code>	avail  int32</code></span>
<span class="codeline" id="line-1318"><code>	unsent int32</code></span>
<span class="codeline" id="line-1319"><code>}</code></span>
<span class="codeline" id="line-1320"><code></code></span>
<span class="codeline" id="line-1321"><code>// init sets the initial window.</code></span>
<span class="codeline" id="line-1322"><code>func (f *http2inflow) init(n int32) {</code></span>
<span class="codeline" id="line-1323"><code>	f.avail = n</code></span>
<span class="codeline" id="line-1324"><code>}</code></span>
<span class="codeline" id="line-1325"><code></code></span>
<span class="codeline" id="line-1326"><code>// add adds n bytes to the window, with a maximum window size of max,</code></span>
<span class="codeline" id="line-1327"><code>// indicating that the peer can now send us more data.</code></span>
<span class="codeline" id="line-1328"><code>// For example, the user read from a {Request,Response} body and consumed</code></span>
<span class="codeline" id="line-1329"><code>// some of the buffered data, so the peer can now send more.</code></span>
<span class="codeline" id="line-1330"><code>// It returns the number of bytes to send in a WINDOW_UPDATE frame to the peer.</code></span>
<span class="codeline" id="line-1331"><code>// Window updates are accumulated and sent when the unsent capacity</code></span>
<span class="codeline" id="line-1332"><code>// is at least inflowMinRefresh or will at least double the peer's available window.</code></span>
<span class="codeline" id="line-1333"><code>func (f *http2inflow) add(n int) (connAdd int32) {</code></span>
<span class="codeline" id="line-1334"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1335"><code>		panic("negative update")</code></span>
<span class="codeline" id="line-1336"><code>	}</code></span>
<span class="codeline" id="line-1337"><code>	unsent := int64(f.unsent) + int64(n)</code></span>
<span class="codeline" id="line-1338"><code>	// "A sender MUST NOT allow a flow-control window to exceed 2^31-1 octets."</code></span>
<span class="codeline" id="line-1339"><code>	// RFC 7540 Section 6.9.1.</code></span>
<span class="codeline" id="line-1340"><code>	const maxWindow = 1&lt;&lt;31 - 1</code></span>
<span class="codeline" id="line-1341"><code>	if unsent+int64(f.avail) &gt; maxWindow {</code></span>
<span class="codeline" id="line-1342"><code>		panic("flow control update exceeds maximum window size")</code></span>
<span class="codeline" id="line-1343"><code>	}</code></span>
<span class="codeline" id="line-1344"><code>	f.unsent = int32(unsent)</code></span>
<span class="codeline" id="line-1345"><code>	if f.unsent &lt; http2inflowMinRefresh &amp;&amp; f.unsent &lt; f.avail {</code></span>
<span class="codeline" id="line-1346"><code>		// If there aren't at least inflowMinRefresh bytes of window to send,</code></span>
<span class="codeline" id="line-1347"><code>		// and this update won't at least double the window, buffer the update for later.</code></span>
<span class="codeline" id="line-1348"><code>		return 0</code></span>
<span class="codeline" id="line-1349"><code>	}</code></span>
<span class="codeline" id="line-1350"><code>	f.avail += f.unsent</code></span>
<span class="codeline" id="line-1351"><code>	f.unsent = 0</code></span>
<span class="codeline" id="line-1352"><code>	return int32(unsent)</code></span>
<span class="codeline" id="line-1353"><code>}</code></span>
<span class="codeline" id="line-1354"><code></code></span>
<span class="codeline" id="line-1355"><code>// take attempts to take n bytes from the peer's flow control window.</code></span>
<span class="codeline" id="line-1356"><code>// It reports whether the window has available capacity.</code></span>
<span class="codeline" id="line-1357"><code>func (f *http2inflow) take(n uint32) bool {</code></span>
<span class="codeline" id="line-1358"><code>	if n &gt; uint32(f.avail) {</code></span>
<span class="codeline" id="line-1359"><code>		return false</code></span>
<span class="codeline" id="line-1360"><code>	}</code></span>
<span class="codeline" id="line-1361"><code>	f.avail -= int32(n)</code></span>
<span class="codeline" id="line-1362"><code>	return true</code></span>
<span class="codeline" id="line-1363"><code>}</code></span>
<span class="codeline" id="line-1364"><code></code></span>
<span class="codeline" id="line-1365"><code>// takeInflows attempts to take n bytes from two inflows,</code></span>
<span class="codeline" id="line-1366"><code>// typically connection-level and stream-level flows.</code></span>
<span class="codeline" id="line-1367"><code>// It reports whether both windows have available capacity.</code></span>
<span class="codeline" id="line-1368"><code>func http2takeInflows(f1, f2 *http2inflow, n uint32) bool {</code></span>
<span class="codeline" id="line-1369"><code>	if n &gt; uint32(f1.avail) || n &gt; uint32(f2.avail) {</code></span>
<span class="codeline" id="line-1370"><code>		return false</code></span>
<span class="codeline" id="line-1371"><code>	}</code></span>
<span class="codeline" id="line-1372"><code>	f1.avail -= int32(n)</code></span>
<span class="codeline" id="line-1373"><code>	f2.avail -= int32(n)</code></span>
<span class="codeline" id="line-1374"><code>	return true</code></span>
<span class="codeline" id="line-1375"><code>}</code></span>
<span class="codeline" id="line-1376"><code></code></span>
<span class="codeline" id="line-1377"><code>// outflow is the outbound flow control window's size.</code></span>
<span class="codeline" id="line-1378"><code>type http2outflow struct {</code></span>
<span class="codeline" id="line-1379"><code>	_ http2incomparable</code></span>
<span class="codeline" id="line-1380"><code></code></span>
<span class="codeline" id="line-1381"><code>	// n is the number of DATA bytes we're allowed to send.</code></span>
<span class="codeline" id="line-1382"><code>	// An outflow is kept both on a conn and a per-stream.</code></span>
<span class="codeline" id="line-1383"><code>	n int32</code></span>
<span class="codeline" id="line-1384"><code></code></span>
<span class="codeline" id="line-1385"><code>	// conn points to the shared connection-level outflow that is</code></span>
<span class="codeline" id="line-1386"><code>	// shared by all streams on that conn. It is nil for the outflow</code></span>
<span class="codeline" id="line-1387"><code>	// that's on the conn directly.</code></span>
<span class="codeline" id="line-1388"><code>	conn *http2outflow</code></span>
<span class="codeline" id="line-1389"><code>}</code></span>
<span class="codeline" id="line-1390"><code></code></span>
<span class="codeline" id="line-1391"><code>func (f *http2outflow) setConnFlow(cf *http2outflow) { f.conn = cf }</code></span>
<span class="codeline" id="line-1392"><code></code></span>
<span class="codeline" id="line-1393"><code>func (f *http2outflow) available() int32 {</code></span>
<span class="codeline" id="line-1394"><code>	n := f.n</code></span>
<span class="codeline" id="line-1395"><code>	if f.conn != nil &amp;&amp; f.conn.n &lt; n {</code></span>
<span class="codeline" id="line-1396"><code>		n = f.conn.n</code></span>
<span class="codeline" id="line-1397"><code>	}</code></span>
<span class="codeline" id="line-1398"><code>	return n</code></span>
<span class="codeline" id="line-1399"><code>}</code></span>
<span class="codeline" id="line-1400"><code></code></span>
<span class="codeline" id="line-1401"><code>func (f *http2outflow) take(n int32) {</code></span>
<span class="codeline" id="line-1402"><code>	if n &gt; f.available() {</code></span>
<span class="codeline" id="line-1403"><code>		panic("internal error: took too much")</code></span>
<span class="codeline" id="line-1404"><code>	}</code></span>
<span class="codeline" id="line-1405"><code>	f.n -= n</code></span>
<span class="codeline" id="line-1406"><code>	if f.conn != nil {</code></span>
<span class="codeline" id="line-1407"><code>		f.conn.n -= n</code></span>
<span class="codeline" id="line-1408"><code>	}</code></span>
<span class="codeline" id="line-1409"><code>}</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>// add adds n bytes (positive or negative) to the flow control window.</code></span>
<span class="codeline" id="line-1412"><code>// It returns false if the sum would exceed 2^31-1.</code></span>
<span class="codeline" id="line-1413"><code>func (f *http2outflow) add(n int32) bool {</code></span>
<span class="codeline" id="line-1414"><code>	sum := f.n + n</code></span>
<span class="codeline" id="line-1415"><code>	if (sum &gt; n) == (f.n &gt; 0) {</code></span>
<span class="codeline" id="line-1416"><code>		f.n = sum</code></span>
<span class="codeline" id="line-1417"><code>		return true</code></span>
<span class="codeline" id="line-1418"><code>	}</code></span>
<span class="codeline" id="line-1419"><code>	return false</code></span>
<span class="codeline" id="line-1420"><code>}</code></span>
<span class="codeline" id="line-1421"><code></code></span>
<span class="codeline" id="line-1422"><code>const http2frameHeaderLen = 9</code></span>
<span class="codeline" id="line-1423"><code></code></span>
<span class="codeline" id="line-1424"><code>var http2padZeros = make([]byte, 255) // zeros for padding</code></span>
<span class="codeline" id="line-1425"><code></code></span>
<span class="codeline" id="line-1426"><code>// A FrameType is a registered frame type as defined in</code></span>
<span class="codeline" id="line-1427"><code>// https://httpwg.org/specs/rfc7540.html#rfc.section.11.2</code></span>
<span class="codeline" id="line-1428"><code>type http2FrameType uint8</code></span>
<span class="codeline" id="line-1429"><code></code></span>
<span class="codeline" id="line-1430"><code>const (</code></span>
<span class="codeline" id="line-1431"><code>	http2FrameData         http2FrameType = 0x0</code></span>
<span class="codeline" id="line-1432"><code>	http2FrameHeaders      http2FrameType = 0x1</code></span>
<span class="codeline" id="line-1433"><code>	http2FramePriority     http2FrameType = 0x2</code></span>
<span class="codeline" id="line-1434"><code>	http2FrameRSTStream    http2FrameType = 0x3</code></span>
<span class="codeline" id="line-1435"><code>	http2FrameSettings     http2FrameType = 0x4</code></span>
<span class="codeline" id="line-1436"><code>	http2FramePushPromise  http2FrameType = 0x5</code></span>
<span class="codeline" id="line-1437"><code>	http2FramePing         http2FrameType = 0x6</code></span>
<span class="codeline" id="line-1438"><code>	http2FrameGoAway       http2FrameType = 0x7</code></span>
<span class="codeline" id="line-1439"><code>	http2FrameWindowUpdate http2FrameType = 0x8</code></span>
<span class="codeline" id="line-1440"><code>	http2FrameContinuation http2FrameType = 0x9</code></span>
<span class="codeline" id="line-1441"><code>)</code></span>
<span class="codeline" id="line-1442"><code></code></span>
<span class="codeline" id="line-1443"><code>var http2frameName = map[http2FrameType]string{</code></span>
<span class="codeline" id="line-1444"><code>	http2FrameData:         "DATA",</code></span>
<span class="codeline" id="line-1445"><code>	http2FrameHeaders:      "HEADERS",</code></span>
<span class="codeline" id="line-1446"><code>	http2FramePriority:     "PRIORITY",</code></span>
<span class="codeline" id="line-1447"><code>	http2FrameRSTStream:    "RST_STREAM",</code></span>
<span class="codeline" id="line-1448"><code>	http2FrameSettings:     "SETTINGS",</code></span>
<span class="codeline" id="line-1449"><code>	http2FramePushPromise:  "PUSH_PROMISE",</code></span>
<span class="codeline" id="line-1450"><code>	http2FramePing:         "PING",</code></span>
<span class="codeline" id="line-1451"><code>	http2FrameGoAway:       "GOAWAY",</code></span>
<span class="codeline" id="line-1452"><code>	http2FrameWindowUpdate: "WINDOW_UPDATE",</code></span>
<span class="codeline" id="line-1453"><code>	http2FrameContinuation: "CONTINUATION",</code></span>
<span class="codeline" id="line-1454"><code>}</code></span>
<span class="codeline" id="line-1455"><code></code></span>
<span class="codeline" id="line-1456"><code>func (t http2FrameType) String() string {</code></span>
<span class="codeline" id="line-1457"><code>	if s, ok := http2frameName[t]; ok {</code></span>
<span class="codeline" id="line-1458"><code>		return s</code></span>
<span class="codeline" id="line-1459"><code>	}</code></span>
<span class="codeline" id="line-1460"><code>	return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t))</code></span>
<span class="codeline" id="line-1461"><code>}</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>// Flags is a bitmask of HTTP/2 flags.</code></span>
<span class="codeline" id="line-1464"><code>// The meaning of flags varies depending on the frame type.</code></span>
<span class="codeline" id="line-1465"><code>type http2Flags uint8</code></span>
<span class="codeline" id="line-1466"><code></code></span>
<span class="codeline" id="line-1467"><code>// Has reports whether f contains all (0 or more) flags in v.</code></span>
<span class="codeline" id="line-1468"><code>func (f http2Flags) Has(v http2Flags) bool {</code></span>
<span class="codeline" id="line-1469"><code>	return (f &amp; v) == v</code></span>
<span class="codeline" id="line-1470"><code>}</code></span>
<span class="codeline" id="line-1471"><code></code></span>
<span class="codeline" id="line-1472"><code>// Frame-specific FrameHeader flag bits.</code></span>
<span class="codeline" id="line-1473"><code>const (</code></span>
<span class="codeline" id="line-1474"><code>	// Data Frame</code></span>
<span class="codeline" id="line-1475"><code>	http2FlagDataEndStream http2Flags = 0x1</code></span>
<span class="codeline" id="line-1476"><code>	http2FlagDataPadded    http2Flags = 0x8</code></span>
<span class="codeline" id="line-1477"><code></code></span>
<span class="codeline" id="line-1478"><code>	// Headers Frame</code></span>
<span class="codeline" id="line-1479"><code>	http2FlagHeadersEndStream  http2Flags = 0x1</code></span>
<span class="codeline" id="line-1480"><code>	http2FlagHeadersEndHeaders http2Flags = 0x4</code></span>
<span class="codeline" id="line-1481"><code>	http2FlagHeadersPadded     http2Flags = 0x8</code></span>
<span class="codeline" id="line-1482"><code>	http2FlagHeadersPriority   http2Flags = 0x20</code></span>
<span class="codeline" id="line-1483"><code></code></span>
<span class="codeline" id="line-1484"><code>	// Settings Frame</code></span>
<span class="codeline" id="line-1485"><code>	http2FlagSettingsAck http2Flags = 0x1</code></span>
<span class="codeline" id="line-1486"><code></code></span>
<span class="codeline" id="line-1487"><code>	// Ping Frame</code></span>
<span class="codeline" id="line-1488"><code>	http2FlagPingAck http2Flags = 0x1</code></span>
<span class="codeline" id="line-1489"><code></code></span>
<span class="codeline" id="line-1490"><code>	// Continuation Frame</code></span>
<span class="codeline" id="line-1491"><code>	http2FlagContinuationEndHeaders http2Flags = 0x4</code></span>
<span class="codeline" id="line-1492"><code></code></span>
<span class="codeline" id="line-1493"><code>	http2FlagPushPromiseEndHeaders http2Flags = 0x4</code></span>
<span class="codeline" id="line-1494"><code>	http2FlagPushPromisePadded     http2Flags = 0x8</code></span>
<span class="codeline" id="line-1495"><code>)</code></span>
<span class="codeline" id="line-1496"><code></code></span>
<span class="codeline" id="line-1497"><code>var http2flagName = map[http2FrameType]map[http2Flags]string{</code></span>
<span class="codeline" id="line-1498"><code>	http2FrameData: {</code></span>
<span class="codeline" id="line-1499"><code>		http2FlagDataEndStream: "END_STREAM",</code></span>
<span class="codeline" id="line-1500"><code>		http2FlagDataPadded:    "PADDED",</code></span>
<span class="codeline" id="line-1501"><code>	},</code></span>
<span class="codeline" id="line-1502"><code>	http2FrameHeaders: {</code></span>
<span class="codeline" id="line-1503"><code>		http2FlagHeadersEndStream:  "END_STREAM",</code></span>
<span class="codeline" id="line-1504"><code>		http2FlagHeadersEndHeaders: "END_HEADERS",</code></span>
<span class="codeline" id="line-1505"><code>		http2FlagHeadersPadded:     "PADDED",</code></span>
<span class="codeline" id="line-1506"><code>		http2FlagHeadersPriority:   "PRIORITY",</code></span>
<span class="codeline" id="line-1507"><code>	},</code></span>
<span class="codeline" id="line-1508"><code>	http2FrameSettings: {</code></span>
<span class="codeline" id="line-1509"><code>		http2FlagSettingsAck: "ACK",</code></span>
<span class="codeline" id="line-1510"><code>	},</code></span>
<span class="codeline" id="line-1511"><code>	http2FramePing: {</code></span>
<span class="codeline" id="line-1512"><code>		http2FlagPingAck: "ACK",</code></span>
<span class="codeline" id="line-1513"><code>	},</code></span>
<span class="codeline" id="line-1514"><code>	http2FrameContinuation: {</code></span>
<span class="codeline" id="line-1515"><code>		http2FlagContinuationEndHeaders: "END_HEADERS",</code></span>
<span class="codeline" id="line-1516"><code>	},</code></span>
<span class="codeline" id="line-1517"><code>	http2FramePushPromise: {</code></span>
<span class="codeline" id="line-1518"><code>		http2FlagPushPromiseEndHeaders: "END_HEADERS",</code></span>
<span class="codeline" id="line-1519"><code>		http2FlagPushPromisePadded:     "PADDED",</code></span>
<span class="codeline" id="line-1520"><code>	},</code></span>
<span class="codeline" id="line-1521"><code>}</code></span>
<span class="codeline" id="line-1522"><code></code></span>
<span class="codeline" id="line-1523"><code>// a frameParser parses a frame given its FrameHeader and payload</code></span>
<span class="codeline" id="line-1524"><code>// bytes. The length of payload will always equal fh.Length (which</code></span>
<span class="codeline" id="line-1525"><code>// might be 0).</code></span>
<span class="codeline" id="line-1526"><code>type http2frameParser func(fc *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error)</code></span>
<span class="codeline" id="line-1527"><code></code></span>
<span class="codeline" id="line-1528"><code>var http2frameParsers = map[http2FrameType]http2frameParser{</code></span>
<span class="codeline" id="line-1529"><code>	http2FrameData:         http2parseDataFrame,</code></span>
<span class="codeline" id="line-1530"><code>	http2FrameHeaders:      http2parseHeadersFrame,</code></span>
<span class="codeline" id="line-1531"><code>	http2FramePriority:     http2parsePriorityFrame,</code></span>
<span class="codeline" id="line-1532"><code>	http2FrameRSTStream:    http2parseRSTStreamFrame,</code></span>
<span class="codeline" id="line-1533"><code>	http2FrameSettings:     http2parseSettingsFrame,</code></span>
<span class="codeline" id="line-1534"><code>	http2FramePushPromise:  http2parsePushPromise,</code></span>
<span class="codeline" id="line-1535"><code>	http2FramePing:         http2parsePingFrame,</code></span>
<span class="codeline" id="line-1536"><code>	http2FrameGoAway:       http2parseGoAwayFrame,</code></span>
<span class="codeline" id="line-1537"><code>	http2FrameWindowUpdate: http2parseWindowUpdateFrame,</code></span>
<span class="codeline" id="line-1538"><code>	http2FrameContinuation: http2parseContinuationFrame,</code></span>
<span class="codeline" id="line-1539"><code>}</code></span>
<span class="codeline" id="line-1540"><code></code></span>
<span class="codeline" id="line-1541"><code>func http2typeFrameParser(t http2FrameType) http2frameParser {</code></span>
<span class="codeline" id="line-1542"><code>	if f := http2frameParsers[t]; f != nil {</code></span>
<span class="codeline" id="line-1543"><code>		return f</code></span>
<span class="codeline" id="line-1544"><code>	}</code></span>
<span class="codeline" id="line-1545"><code>	return http2parseUnknownFrame</code></span>
<span class="codeline" id="line-1546"><code>}</code></span>
<span class="codeline" id="line-1547"><code></code></span>
<span class="codeline" id="line-1548"><code>// A FrameHeader is the 9 byte header of all HTTP/2 frames.</code></span>
<span class="codeline" id="line-1549"><code>//</code></span>
<span class="codeline" id="line-1550"><code>// See https://httpwg.org/specs/rfc7540.html#FrameHeader</code></span>
<span class="codeline" id="line-1551"><code>type http2FrameHeader struct {</code></span>
<span class="codeline" id="line-1552"><code>	valid bool // caller can access []byte fields in the Frame</code></span>
<span class="codeline" id="line-1553"><code></code></span>
<span class="codeline" id="line-1554"><code>	// Type is the 1 byte frame type. There are ten standard frame</code></span>
<span class="codeline" id="line-1555"><code>	// types, but extension frame types may be written by WriteRawFrame</code></span>
<span class="codeline" id="line-1556"><code>	// and will be returned by ReadFrame (as UnknownFrame).</code></span>
<span class="codeline" id="line-1557"><code>	Type http2FrameType</code></span>
<span class="codeline" id="line-1558"><code></code></span>
<span class="codeline" id="line-1559"><code>	// Flags are the 1 byte of 8 potential bit flags per frame.</code></span>
<span class="codeline" id="line-1560"><code>	// They are specific to the frame type.</code></span>
<span class="codeline" id="line-1561"><code>	Flags http2Flags</code></span>
<span class="codeline" id="line-1562"><code></code></span>
<span class="codeline" id="line-1563"><code>	// Length is the length of the frame, not including the 9 byte header.</code></span>
<span class="codeline" id="line-1564"><code>	// The maximum size is one byte less than 16MB (uint24), but only</code></span>
<span class="codeline" id="line-1565"><code>	// frames up to 16KB are allowed without peer agreement.</code></span>
<span class="codeline" id="line-1566"><code>	Length uint32</code></span>
<span class="codeline" id="line-1567"><code></code></span>
<span class="codeline" id="line-1568"><code>	// StreamID is which stream this frame is for. Certain frames</code></span>
<span class="codeline" id="line-1569"><code>	// are not stream-specific, in which case this field is 0.</code></span>
<span class="codeline" id="line-1570"><code>	StreamID uint32</code></span>
<span class="codeline" id="line-1571"><code>}</code></span>
<span class="codeline" id="line-1572"><code></code></span>
<span class="codeline" id="line-1573"><code>// Header returns h. It exists so FrameHeaders can be embedded in other</code></span>
<span class="codeline" id="line-1574"><code>// specific frame types and implement the Frame interface.</code></span>
<span class="codeline" id="line-1575"><code>func (h http2FrameHeader) Header() http2FrameHeader { return h }</code></span>
<span class="codeline" id="line-1576"><code></code></span>
<span class="codeline" id="line-1577"><code>func (h http2FrameHeader) String() string {</code></span>
<span class="codeline" id="line-1578"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-1579"><code>	buf.WriteString("[FrameHeader ")</code></span>
<span class="codeline" id="line-1580"><code>	h.writeDebug(&amp;buf)</code></span>
<span class="codeline" id="line-1581"><code>	buf.WriteByte(']')</code></span>
<span class="codeline" id="line-1582"><code>	return buf.String()</code></span>
<span class="codeline" id="line-1583"><code>}</code></span>
<span class="codeline" id="line-1584"><code></code></span>
<span class="codeline" id="line-1585"><code>func (h http2FrameHeader) writeDebug(buf *bytes.Buffer) {</code></span>
<span class="codeline" id="line-1586"><code>	buf.WriteString(h.Type.String())</code></span>
<span class="codeline" id="line-1587"><code>	if h.Flags != 0 {</code></span>
<span class="codeline" id="line-1588"><code>		buf.WriteString(" flags=")</code></span>
<span class="codeline" id="line-1589"><code>		set := 0</code></span>
<span class="codeline" id="line-1590"><code>		for i := uint8(0); i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-1591"><code>			if h.Flags&amp;(1&lt;&lt;i) == 0 {</code></span>
<span class="codeline" id="line-1592"><code>				continue</code></span>
<span class="codeline" id="line-1593"><code>			}</code></span>
<span class="codeline" id="line-1594"><code>			set++</code></span>
<span class="codeline" id="line-1595"><code>			if set &gt; 1 {</code></span>
<span class="codeline" id="line-1596"><code>				buf.WriteByte('|')</code></span>
<span class="codeline" id="line-1597"><code>			}</code></span>
<span class="codeline" id="line-1598"><code>			name := http2flagName[h.Type][http2Flags(1&lt;&lt;i)]</code></span>
<span class="codeline" id="line-1599"><code>			if name != "" {</code></span>
<span class="codeline" id="line-1600"><code>				buf.WriteString(name)</code></span>
<span class="codeline" id="line-1601"><code>			} else {</code></span>
<span class="codeline" id="line-1602"><code>				fmt.Fprintf(buf, "0x%x", 1&lt;&lt;i)</code></span>
<span class="codeline" id="line-1603"><code>			}</code></span>
<span class="codeline" id="line-1604"><code>		}</code></span>
<span class="codeline" id="line-1605"><code>	}</code></span>
<span class="codeline" id="line-1606"><code>	if h.StreamID != 0 {</code></span>
<span class="codeline" id="line-1607"><code>		fmt.Fprintf(buf, " stream=%d", h.StreamID)</code></span>
<span class="codeline" id="line-1608"><code>	}</code></span>
<span class="codeline" id="line-1609"><code>	fmt.Fprintf(buf, " len=%d", h.Length)</code></span>
<span class="codeline" id="line-1610"><code>}</code></span>
<span class="codeline" id="line-1611"><code></code></span>
<span class="codeline" id="line-1612"><code>func (h *http2FrameHeader) checkValid() {</code></span>
<span class="codeline" id="line-1613"><code>	if !h.valid {</code></span>
<span class="codeline" id="line-1614"><code>		panic("Frame accessor called on non-owned Frame")</code></span>
<span class="codeline" id="line-1615"><code>	}</code></span>
<span class="codeline" id="line-1616"><code>}</code></span>
<span class="codeline" id="line-1617"><code></code></span>
<span class="codeline" id="line-1618"><code>func (h *http2FrameHeader) invalidate() { h.valid = false }</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>// frame header bytes.</code></span>
<span class="codeline" id="line-1621"><code>// Used only by ReadFrameHeader.</code></span>
<span class="codeline" id="line-1622"><code>var http2fhBytes = sync.Pool{</code></span>
<span class="codeline" id="line-1623"><code>	New: func() interface{} {</code></span>
<span class="codeline" id="line-1624"><code>		buf := make([]byte, http2frameHeaderLen)</code></span>
<span class="codeline" id="line-1625"><code>		return &amp;buf</code></span>
<span class="codeline" id="line-1626"><code>	},</code></span>
<span class="codeline" id="line-1627"><code>}</code></span>
<span class="codeline" id="line-1628"><code></code></span>
<span class="codeline" id="line-1629"><code>// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.</code></span>
<span class="codeline" id="line-1630"><code>// Most users should use Framer.ReadFrame instead.</code></span>
<span class="codeline" id="line-1631"><code>func http2ReadFrameHeader(r io.Reader) (http2FrameHeader, error) {</code></span>
<span class="codeline" id="line-1632"><code>	bufp := http2fhBytes.Get().(*[]byte)</code></span>
<span class="codeline" id="line-1633"><code>	defer http2fhBytes.Put(bufp)</code></span>
<span class="codeline" id="line-1634"><code>	return http2readFrameHeader(*bufp, r)</code></span>
<span class="codeline" id="line-1635"><code>}</code></span>
<span class="codeline" id="line-1636"><code></code></span>
<span class="codeline" id="line-1637"><code>func http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error) {</code></span>
<span class="codeline" id="line-1638"><code>	_, err := io.ReadFull(r, buf[:http2frameHeaderLen])</code></span>
<span class="codeline" id="line-1639"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1640"><code>		return http2FrameHeader{}, err</code></span>
<span class="codeline" id="line-1641"><code>	}</code></span>
<span class="codeline" id="line-1642"><code>	return http2FrameHeader{</code></span>
<span class="codeline" id="line-1643"><code>		Length:   (uint32(buf[0])&lt;&lt;16 | uint32(buf[1])&lt;&lt;8 | uint32(buf[2])),</code></span>
<span class="codeline" id="line-1644"><code>		Type:     http2FrameType(buf[3]),</code></span>
<span class="codeline" id="line-1645"><code>		Flags:    http2Flags(buf[4]),</code></span>
<span class="codeline" id="line-1646"><code>		StreamID: binary.BigEndian.Uint32(buf[5:]) &amp; (1&lt;&lt;31 - 1),</code></span>
<span class="codeline" id="line-1647"><code>		valid:    true,</code></span>
<span class="codeline" id="line-1648"><code>	}, nil</code></span>
<span class="codeline" id="line-1649"><code>}</code></span>
<span class="codeline" id="line-1650"><code></code></span>
<span class="codeline" id="line-1651"><code>// A Frame is the base interface implemented by all frame types.</code></span>
<span class="codeline" id="line-1652"><code>// Callers will generally type-assert the specific frame type:</code></span>
<span class="codeline" id="line-1653"><code>// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.</code></span>
<span class="codeline" id="line-1654"><code>//</code></span>
<span class="codeline" id="line-1655"><code>// Frames are only valid until the next call to Framer.ReadFrame.</code></span>
<span class="codeline" id="line-1656"><code>type http2Frame interface {</code></span>
<span class="codeline" id="line-1657"><code>	Header() http2FrameHeader</code></span>
<span class="codeline" id="line-1658"><code></code></span>
<span class="codeline" id="line-1659"><code>	// invalidate is called by Framer.ReadFrame to make this</code></span>
<span class="codeline" id="line-1660"><code>	// frame's buffers as being invalid, since the subsequent</code></span>
<span class="codeline" id="line-1661"><code>	// frame will reuse them.</code></span>
<span class="codeline" id="line-1662"><code>	invalidate()</code></span>
<span class="codeline" id="line-1663"><code>}</code></span>
<span class="codeline" id="line-1664"><code></code></span>
<span class="codeline" id="line-1665"><code>// A Framer reads and writes Frames.</code></span>
<span class="codeline" id="line-1666"><code>type http2Framer struct {</code></span>
<span class="codeline" id="line-1667"><code>	r         io.Reader</code></span>
<span class="codeline" id="line-1668"><code>	lastFrame http2Frame</code></span>
<span class="codeline" id="line-1669"><code>	errDetail error</code></span>
<span class="codeline" id="line-1670"><code></code></span>
<span class="codeline" id="line-1671"><code>	// countError is a non-nil func that's called on a frame parse</code></span>
<span class="codeline" id="line-1672"><code>	// error with some unique error path token. It's initialized</code></span>
<span class="codeline" id="line-1673"><code>	// from Transport.CountError or Server.CountError.</code></span>
<span class="codeline" id="line-1674"><code>	countError func(errToken string)</code></span>
<span class="codeline" id="line-1675"><code></code></span>
<span class="codeline" id="line-1676"><code>	// lastHeaderStream is non-zero if the last frame was an</code></span>
<span class="codeline" id="line-1677"><code>	// unfinished HEADERS/CONTINUATION.</code></span>
<span class="codeline" id="line-1678"><code>	lastHeaderStream uint32</code></span>
<span class="codeline" id="line-1679"><code></code></span>
<span class="codeline" id="line-1680"><code>	maxReadSize uint32</code></span>
<span class="codeline" id="line-1681"><code>	headerBuf   [http2frameHeaderLen]byte</code></span>
<span class="codeline" id="line-1682"><code></code></span>
<span class="codeline" id="line-1683"><code>	// TODO: let getReadBuf be configurable, and use a less memory-pinning</code></span>
<span class="codeline" id="line-1684"><code>	// allocator in server.go to minimize memory pinned for many idle conns.</code></span>
<span class="codeline" id="line-1685"><code>	// Will probably also need to make frame invalidation have a hook too.</code></span>
<span class="codeline" id="line-1686"><code>	getReadBuf func(size uint32) []byte</code></span>
<span class="codeline" id="line-1687"><code>	readBuf    []byte // cache for default getReadBuf</code></span>
<span class="codeline" id="line-1688"><code></code></span>
<span class="codeline" id="line-1689"><code>	maxWriteSize uint32 // zero means unlimited; TODO: implement</code></span>
<span class="codeline" id="line-1690"><code></code></span>
<span class="codeline" id="line-1691"><code>	w    io.Writer</code></span>
<span class="codeline" id="line-1692"><code>	wbuf []byte</code></span>
<span class="codeline" id="line-1693"><code></code></span>
<span class="codeline" id="line-1694"><code>	// AllowIllegalWrites permits the Framer's Write methods to</code></span>
<span class="codeline" id="line-1695"><code>	// write frames that do not conform to the HTTP/2 spec. This</code></span>
<span class="codeline" id="line-1696"><code>	// permits using the Framer to test other HTTP/2</code></span>
<span class="codeline" id="line-1697"><code>	// implementations' conformance to the spec.</code></span>
<span class="codeline" id="line-1698"><code>	// If false, the Write methods will prefer to return an error</code></span>
<span class="codeline" id="line-1699"><code>	// rather than comply.</code></span>
<span class="codeline" id="line-1700"><code>	AllowIllegalWrites bool</code></span>
<span class="codeline" id="line-1701"><code></code></span>
<span class="codeline" id="line-1702"><code>	// AllowIllegalReads permits the Framer's ReadFrame method</code></span>
<span class="codeline" id="line-1703"><code>	// to return non-compliant frames or frame orders.</code></span>
<span class="codeline" id="line-1704"><code>	// This is for testing and permits using the Framer to test</code></span>
<span class="codeline" id="line-1705"><code>	// other HTTP/2 implementations' conformance to the spec.</code></span>
<span class="codeline" id="line-1706"><code>	// It is not compatible with ReadMetaHeaders.</code></span>
<span class="codeline" id="line-1707"><code>	AllowIllegalReads bool</code></span>
<span class="codeline" id="line-1708"><code></code></span>
<span class="codeline" id="line-1709"><code>	// ReadMetaHeaders if non-nil causes ReadFrame to merge</code></span>
<span class="codeline" id="line-1710"><code>	// HEADERS and CONTINUATION frames together and return</code></span>
<span class="codeline" id="line-1711"><code>	// MetaHeadersFrame instead.</code></span>
<span class="codeline" id="line-1712"><code>	ReadMetaHeaders *hpack.Decoder</code></span>
<span class="codeline" id="line-1713"><code></code></span>
<span class="codeline" id="line-1714"><code>	// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.</code></span>
<span class="codeline" id="line-1715"><code>	// It's used only if ReadMetaHeaders is set; 0 means a sane default</code></span>
<span class="codeline" id="line-1716"><code>	// (currently 16MB)</code></span>
<span class="codeline" id="line-1717"><code>	// If the limit is hit, MetaHeadersFrame.Truncated is set true.</code></span>
<span class="codeline" id="line-1718"><code>	MaxHeaderListSize uint32</code></span>
<span class="codeline" id="line-1719"><code></code></span>
<span class="codeline" id="line-1720"><code>	// TODO: track which type of frame &amp; with which flags was sent</code></span>
<span class="codeline" id="line-1721"><code>	// last. Then return an error (unless AllowIllegalWrites) if</code></span>
<span class="codeline" id="line-1722"><code>	// we're in the middle of a header block and a</code></span>
<span class="codeline" id="line-1723"><code>	// non-Continuation or Continuation on a different stream is</code></span>
<span class="codeline" id="line-1724"><code>	// attempted to be written.</code></span>
<span class="codeline" id="line-1725"><code></code></span>
<span class="codeline" id="line-1726"><code>	logReads, logWrites bool</code></span>
<span class="codeline" id="line-1727"><code></code></span>
<span class="codeline" id="line-1728"><code>	debugFramer       *http2Framer // only use for logging written writes</code></span>
<span class="codeline" id="line-1729"><code>	debugFramerBuf    *bytes.Buffer</code></span>
<span class="codeline" id="line-1730"><code>	debugReadLoggerf  func(string, ...interface{})</code></span>
<span class="codeline" id="line-1731"><code>	debugWriteLoggerf func(string, ...interface{})</code></span>
<span class="codeline" id="line-1732"><code></code></span>
<span class="codeline" id="line-1733"><code>	frameCache *http2frameCache // nil if frames aren't reused (default)</code></span>
<span class="codeline" id="line-1734"><code>}</code></span>
<span class="codeline" id="line-1735"><code></code></span>
<span class="codeline" id="line-1736"><code>func (fr *http2Framer) maxHeaderListSize() uint32 {</code></span>
<span class="codeline" id="line-1737"><code>	if fr.MaxHeaderListSize == 0 {</code></span>
<span class="codeline" id="line-1738"><code>		return 16 &lt;&lt; 20 // sane default, per docs</code></span>
<span class="codeline" id="line-1739"><code>	}</code></span>
<span class="codeline" id="line-1740"><code>	return fr.MaxHeaderListSize</code></span>
<span class="codeline" id="line-1741"><code>}</code></span>
<span class="codeline" id="line-1742"><code></code></span>
<span class="codeline" id="line-1743"><code>func (f *http2Framer) startWrite(ftype http2FrameType, flags http2Flags, streamID uint32) {</code></span>
<span class="codeline" id="line-1744"><code>	// Write the FrameHeader.</code></span>
<span class="codeline" id="line-1745"><code>	f.wbuf = append(f.wbuf[:0],</code></span>
<span class="codeline" id="line-1746"><code>		0, // 3 bytes of length, filled in in endWrite</code></span>
<span class="codeline" id="line-1747"><code>		0,</code></span>
<span class="codeline" id="line-1748"><code>		0,</code></span>
<span class="codeline" id="line-1749"><code>		byte(ftype),</code></span>
<span class="codeline" id="line-1750"><code>		byte(flags),</code></span>
<span class="codeline" id="line-1751"><code>		byte(streamID&gt;&gt;24),</code></span>
<span class="codeline" id="line-1752"><code>		byte(streamID&gt;&gt;16),</code></span>
<span class="codeline" id="line-1753"><code>		byte(streamID&gt;&gt;8),</code></span>
<span class="codeline" id="line-1754"><code>		byte(streamID))</code></span>
<span class="codeline" id="line-1755"><code>}</code></span>
<span class="codeline" id="line-1756"><code></code></span>
<span class="codeline" id="line-1757"><code>func (f *http2Framer) endWrite() error {</code></span>
<span class="codeline" id="line-1758"><code>	// Now that we know the final size, fill in the FrameHeader in</code></span>
<span class="codeline" id="line-1759"><code>	// the space previously reserved for it. Abuse append.</code></span>
<span class="codeline" id="line-1760"><code>	length := len(f.wbuf) - http2frameHeaderLen</code></span>
<span class="codeline" id="line-1761"><code>	if length &gt;= (1 &lt;&lt; 24) {</code></span>
<span class="codeline" id="line-1762"><code>		return http2ErrFrameTooLarge</code></span>
<span class="codeline" id="line-1763"><code>	}</code></span>
<span class="codeline" id="line-1764"><code>	_ = append(f.wbuf[:0],</code></span>
<span class="codeline" id="line-1765"><code>		byte(length&gt;&gt;16),</code></span>
<span class="codeline" id="line-1766"><code>		byte(length&gt;&gt;8),</code></span>
<span class="codeline" id="line-1767"><code>		byte(length))</code></span>
<span class="codeline" id="line-1768"><code>	if f.logWrites {</code></span>
<span class="codeline" id="line-1769"><code>		f.logWrite()</code></span>
<span class="codeline" id="line-1770"><code>	}</code></span>
<span class="codeline" id="line-1771"><code></code></span>
<span class="codeline" id="line-1772"><code>	n, err := f.w.Write(f.wbuf)</code></span>
<span class="codeline" id="line-1773"><code>	if err == nil &amp;&amp; n != len(f.wbuf) {</code></span>
<span class="codeline" id="line-1774"><code>		err = io.ErrShortWrite</code></span>
<span class="codeline" id="line-1775"><code>	}</code></span>
<span class="codeline" id="line-1776"><code>	return err</code></span>
<span class="codeline" id="line-1777"><code>}</code></span>
<span class="codeline" id="line-1778"><code></code></span>
<span class="codeline" id="line-1779"><code>func (f *http2Framer) logWrite() {</code></span>
<span class="codeline" id="line-1780"><code>	if f.debugFramer == nil {</code></span>
<span class="codeline" id="line-1781"><code>		f.debugFramerBuf = new(bytes.Buffer)</code></span>
<span class="codeline" id="line-1782"><code>		f.debugFramer = http2NewFramer(nil, f.debugFramerBuf)</code></span>
<span class="codeline" id="line-1783"><code>		f.debugFramer.logReads = false // we log it ourselves, saying "wrote" below</code></span>
<span class="codeline" id="line-1784"><code>		// Let us read anything, even if we accidentally wrote it</code></span>
<span class="codeline" id="line-1785"><code>		// in the wrong order:</code></span>
<span class="codeline" id="line-1786"><code>		f.debugFramer.AllowIllegalReads = true</code></span>
<span class="codeline" id="line-1787"><code>	}</code></span>
<span class="codeline" id="line-1788"><code>	f.debugFramerBuf.Write(f.wbuf)</code></span>
<span class="codeline" id="line-1789"><code>	fr, err := f.debugFramer.ReadFrame()</code></span>
<span class="codeline" id="line-1790"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1791"><code>		f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f)</code></span>
<span class="codeline" id="line-1792"><code>		return</code></span>
<span class="codeline" id="line-1793"><code>	}</code></span>
<span class="codeline" id="line-1794"><code>	f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, http2summarizeFrame(fr))</code></span>
<span class="codeline" id="line-1795"><code>}</code></span>
<span class="codeline" id="line-1796"><code></code></span>
<span class="codeline" id="line-1797"><code>func (f *http2Framer) writeByte(v byte) { f.wbuf = append(f.wbuf, v) }</code></span>
<span class="codeline" id="line-1798"><code></code></span>
<span class="codeline" id="line-1799"><code>func (f *http2Framer) writeBytes(v []byte) { f.wbuf = append(f.wbuf, v...) }</code></span>
<span class="codeline" id="line-1800"><code></code></span>
<span class="codeline" id="line-1801"><code>func (f *http2Framer) writeUint16(v uint16) { f.wbuf = append(f.wbuf, byte(v&gt;&gt;8), byte(v)) }</code></span>
<span class="codeline" id="line-1802"><code></code></span>
<span class="codeline" id="line-1803"><code>func (f *http2Framer) writeUint32(v uint32) {</code></span>
<span class="codeline" id="line-1804"><code>	f.wbuf = append(f.wbuf, byte(v&gt;&gt;24), byte(v&gt;&gt;16), byte(v&gt;&gt;8), byte(v))</code></span>
<span class="codeline" id="line-1805"><code>}</code></span>
<span class="codeline" id="line-1806"><code></code></span>
<span class="codeline" id="line-1807"><code>const (</code></span>
<span class="codeline" id="line-1808"><code>	http2minMaxFrameSize = 1 &lt;&lt; 14</code></span>
<span class="codeline" id="line-1809"><code>	http2maxFrameSize    = 1&lt;&lt;24 - 1</code></span>
<span class="codeline" id="line-1810"><code>)</code></span>
<span class="codeline" id="line-1811"><code></code></span>
<span class="codeline" id="line-1812"><code>// SetReuseFrames allows the Framer to reuse Frames.</code></span>
<span class="codeline" id="line-1813"><code>// If called on a Framer, Frames returned by calls to ReadFrame are only</code></span>
<span class="codeline" id="line-1814"><code>// valid until the next call to ReadFrame.</code></span>
<span class="codeline" id="line-1815"><code>func (fr *http2Framer) SetReuseFrames() {</code></span>
<span class="codeline" id="line-1816"><code>	if fr.frameCache != nil {</code></span>
<span class="codeline" id="line-1817"><code>		return</code></span>
<span class="codeline" id="line-1818"><code>	}</code></span>
<span class="codeline" id="line-1819"><code>	fr.frameCache = &amp;http2frameCache{}</code></span>
<span class="codeline" id="line-1820"><code>}</code></span>
<span class="codeline" id="line-1821"><code></code></span>
<span class="codeline" id="line-1822"><code>type http2frameCache struct {</code></span>
<span class="codeline" id="line-1823"><code>	dataFrame http2DataFrame</code></span>
<span class="codeline" id="line-1824"><code>}</code></span>
<span class="codeline" id="line-1825"><code></code></span>
<span class="codeline" id="line-1826"><code>func (fc *http2frameCache) getDataFrame() *http2DataFrame {</code></span>
<span class="codeline" id="line-1827"><code>	if fc == nil {</code></span>
<span class="codeline" id="line-1828"><code>		return &amp;http2DataFrame{}</code></span>
<span class="codeline" id="line-1829"><code>	}</code></span>
<span class="codeline" id="line-1830"><code>	return &amp;fc.dataFrame</code></span>
<span class="codeline" id="line-1831"><code>}</code></span>
<span class="codeline" id="line-1832"><code></code></span>
<span class="codeline" id="line-1833"><code>// NewFramer returns a Framer that writes frames to w and reads them from r.</code></span>
<span class="codeline" id="line-1834"><code>func http2NewFramer(w io.Writer, r io.Reader) *http2Framer {</code></span>
<span class="codeline" id="line-1835"><code>	fr := &amp;http2Framer{</code></span>
<span class="codeline" id="line-1836"><code>		w:                 w,</code></span>
<span class="codeline" id="line-1837"><code>		r:                 r,</code></span>
<span class="codeline" id="line-1838"><code>		countError:        func(string) {},</code></span>
<span class="codeline" id="line-1839"><code>		logReads:          http2logFrameReads,</code></span>
<span class="codeline" id="line-1840"><code>		logWrites:         http2logFrameWrites,</code></span>
<span class="codeline" id="line-1841"><code>		debugReadLoggerf:  log.Printf,</code></span>
<span class="codeline" id="line-1842"><code>		debugWriteLoggerf: log.Printf,</code></span>
<span class="codeline" id="line-1843"><code>	}</code></span>
<span class="codeline" id="line-1844"><code>	fr.getReadBuf = func(size uint32) []byte {</code></span>
<span class="codeline" id="line-1845"><code>		if cap(fr.readBuf) &gt;= int(size) {</code></span>
<span class="codeline" id="line-1846"><code>			return fr.readBuf[:size]</code></span>
<span class="codeline" id="line-1847"><code>		}</code></span>
<span class="codeline" id="line-1848"><code>		fr.readBuf = make([]byte, size)</code></span>
<span class="codeline" id="line-1849"><code>		return fr.readBuf</code></span>
<span class="codeline" id="line-1850"><code>	}</code></span>
<span class="codeline" id="line-1851"><code>	fr.SetMaxReadFrameSize(http2maxFrameSize)</code></span>
<span class="codeline" id="line-1852"><code>	return fr</code></span>
<span class="codeline" id="line-1853"><code>}</code></span>
<span class="codeline" id="line-1854"><code></code></span>
<span class="codeline" id="line-1855"><code>// SetMaxReadFrameSize sets the maximum size of a frame</code></span>
<span class="codeline" id="line-1856"><code>// that will be read by a subsequent call to ReadFrame.</code></span>
<span class="codeline" id="line-1857"><code>// It is the caller's responsibility to advertise this</code></span>
<span class="codeline" id="line-1858"><code>// limit with a SETTINGS frame.</code></span>
<span class="codeline" id="line-1859"><code>func (fr *http2Framer) SetMaxReadFrameSize(v uint32) {</code></span>
<span class="codeline" id="line-1860"><code>	if v &gt; http2maxFrameSize {</code></span>
<span class="codeline" id="line-1861"><code>		v = http2maxFrameSize</code></span>
<span class="codeline" id="line-1862"><code>	}</code></span>
<span class="codeline" id="line-1863"><code>	fr.maxReadSize = v</code></span>
<span class="codeline" id="line-1864"><code>}</code></span>
<span class="codeline" id="line-1865"><code></code></span>
<span class="codeline" id="line-1866"><code>// ErrorDetail returns a more detailed error of the last error</code></span>
<span class="codeline" id="line-1867"><code>// returned by Framer.ReadFrame. For instance, if ReadFrame</code></span>
<span class="codeline" id="line-1868"><code>// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail</code></span>
<span class="codeline" id="line-1869"><code>// will say exactly what was invalid. ErrorDetail is not guaranteed</code></span>
<span class="codeline" id="line-1870"><code>// to return a non-nil value and like the rest of the http2 package,</code></span>
<span class="codeline" id="line-1871"><code>// its return value is not protected by an API compatibility promise.</code></span>
<span class="codeline" id="line-1872"><code>// ErrorDetail is reset after the next call to ReadFrame.</code></span>
<span class="codeline" id="line-1873"><code>func (fr *http2Framer) ErrorDetail() error {</code></span>
<span class="codeline" id="line-1874"><code>	return fr.errDetail</code></span>
<span class="codeline" id="line-1875"><code>}</code></span>
<span class="codeline" id="line-1876"><code></code></span>
<span class="codeline" id="line-1877"><code>// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer</code></span>
<span class="codeline" id="line-1878"><code>// sends a frame that is larger than declared with SetMaxReadFrameSize.</code></span>
<span class="codeline" id="line-1879"><code>var http2ErrFrameTooLarge = errors.New("http2: frame too large")</code></span>
<span class="codeline" id="line-1880"><code></code></span>
<span class="codeline" id="line-1881"><code>// terminalReadFrameError reports whether err is an unrecoverable</code></span>
<span class="codeline" id="line-1882"><code>// error from ReadFrame and no other frames should be read.</code></span>
<span class="codeline" id="line-1883"><code>func http2terminalReadFrameError(err error) bool {</code></span>
<span class="codeline" id="line-1884"><code>	if _, ok := err.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-1885"><code>		return false</code></span>
<span class="codeline" id="line-1886"><code>	}</code></span>
<span class="codeline" id="line-1887"><code>	return err != nil</code></span>
<span class="codeline" id="line-1888"><code>}</code></span>
<span class="codeline" id="line-1889"><code></code></span>
<span class="codeline" id="line-1890"><code>// ReadFrame reads a single frame. The returned Frame is only valid</code></span>
<span class="codeline" id="line-1891"><code>// until the next call to ReadFrame.</code></span>
<span class="codeline" id="line-1892"><code>//</code></span>
<span class="codeline" id="line-1893"><code>// If the frame is larger than previously set with SetMaxReadFrameSize, the</code></span>
<span class="codeline" id="line-1894"><code>// returned error is ErrFrameTooLarge. Other errors may be of type</code></span>
<span class="codeline" id="line-1895"><code>// ConnectionError, StreamError, or anything else from the underlying</code></span>
<span class="codeline" id="line-1896"><code>// reader.</code></span>
<span class="codeline" id="line-1897"><code>//</code></span>
<span class="codeline" id="line-1898"><code>// If ReadFrame returns an error and a non-nil Frame, the Frame's StreamID</code></span>
<span class="codeline" id="line-1899"><code>// indicates the stream responsible for the error.</code></span>
<span class="codeline" id="line-1900"><code>func (fr *http2Framer) ReadFrame() (http2Frame, error) {</code></span>
<span class="codeline" id="line-1901"><code>	fr.errDetail = nil</code></span>
<span class="codeline" id="line-1902"><code>	if fr.lastFrame != nil {</code></span>
<span class="codeline" id="line-1903"><code>		fr.lastFrame.invalidate()</code></span>
<span class="codeline" id="line-1904"><code>	}</code></span>
<span class="codeline" id="line-1905"><code>	fh, err := http2readFrameHeader(fr.headerBuf[:], fr.r)</code></span>
<span class="codeline" id="line-1906"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1907"><code>		return nil, err</code></span>
<span class="codeline" id="line-1908"><code>	}</code></span>
<span class="codeline" id="line-1909"><code>	if fh.Length &gt; fr.maxReadSize {</code></span>
<span class="codeline" id="line-1910"><code>		return nil, http2ErrFrameTooLarge</code></span>
<span class="codeline" id="line-1911"><code>	}</code></span>
<span class="codeline" id="line-1912"><code>	payload := fr.getReadBuf(fh.Length)</code></span>
<span class="codeline" id="line-1913"><code>	if _, err := io.ReadFull(fr.r, payload); err != nil {</code></span>
<span class="codeline" id="line-1914"><code>		return nil, err</code></span>
<span class="codeline" id="line-1915"><code>	}</code></span>
<span class="codeline" id="line-1916"><code>	f, err := http2typeFrameParser(fh.Type)(fr.frameCache, fh, fr.countError, payload)</code></span>
<span class="codeline" id="line-1917"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1918"><code>		if ce, ok := err.(http2connError); ok {</code></span>
<span class="codeline" id="line-1919"><code>			return nil, fr.connError(ce.Code, ce.Reason)</code></span>
<span class="codeline" id="line-1920"><code>		}</code></span>
<span class="codeline" id="line-1921"><code>		return nil, err</code></span>
<span class="codeline" id="line-1922"><code>	}</code></span>
<span class="codeline" id="line-1923"><code>	if err := fr.checkFrameOrder(f); err != nil {</code></span>
<span class="codeline" id="line-1924"><code>		return nil, err</code></span>
<span class="codeline" id="line-1925"><code>	}</code></span>
<span class="codeline" id="line-1926"><code>	if fr.logReads {</code></span>
<span class="codeline" id="line-1927"><code>		fr.debugReadLoggerf("http2: Framer %p: read %v", fr, http2summarizeFrame(f))</code></span>
<span class="codeline" id="line-1928"><code>	}</code></span>
<span class="codeline" id="line-1929"><code>	if fh.Type == http2FrameHeaders &amp;&amp; fr.ReadMetaHeaders != nil {</code></span>
<span class="codeline" id="line-1930"><code>		return fr.readMetaFrame(f.(*http2HeadersFrame))</code></span>
<span class="codeline" id="line-1931"><code>	}</code></span>
<span class="codeline" id="line-1932"><code>	return f, nil</code></span>
<span class="codeline" id="line-1933"><code>}</code></span>
<span class="codeline" id="line-1934"><code></code></span>
<span class="codeline" id="line-1935"><code>// connError returns ConnectionError(code) but first</code></span>
<span class="codeline" id="line-1936"><code>// stashes away a public reason to the caller can optionally relay it</code></span>
<span class="codeline" id="line-1937"><code>// to the peer before hanging up on them. This might help others debug</code></span>
<span class="codeline" id="line-1938"><code>// their implementations.</code></span>
<span class="codeline" id="line-1939"><code>func (fr *http2Framer) connError(code http2ErrCode, reason string) error {</code></span>
<span class="codeline" id="line-1940"><code>	fr.errDetail = errors.New(reason)</code></span>
<span class="codeline" id="line-1941"><code>	return http2ConnectionError(code)</code></span>
<span class="codeline" id="line-1942"><code>}</code></span>
<span class="codeline" id="line-1943"><code></code></span>
<span class="codeline" id="line-1944"><code>// checkFrameOrder reports an error if f is an invalid frame to return</code></span>
<span class="codeline" id="line-1945"><code>// next from ReadFrame. Mostly it checks whether HEADERS and</code></span>
<span class="codeline" id="line-1946"><code>// CONTINUATION frames are contiguous.</code></span>
<span class="codeline" id="line-1947"><code>func (fr *http2Framer) checkFrameOrder(f http2Frame) error {</code></span>
<span class="codeline" id="line-1948"><code>	last := fr.lastFrame</code></span>
<span class="codeline" id="line-1949"><code>	fr.lastFrame = f</code></span>
<span class="codeline" id="line-1950"><code>	if fr.AllowIllegalReads {</code></span>
<span class="codeline" id="line-1951"><code>		return nil</code></span>
<span class="codeline" id="line-1952"><code>	}</code></span>
<span class="codeline" id="line-1953"><code></code></span>
<span class="codeline" id="line-1954"><code>	fh := f.Header()</code></span>
<span class="codeline" id="line-1955"><code>	if fr.lastHeaderStream != 0 {</code></span>
<span class="codeline" id="line-1956"><code>		if fh.Type != http2FrameContinuation {</code></span>
<span class="codeline" id="line-1957"><code>			return fr.connError(http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-1958"><code>				fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d",</code></span>
<span class="codeline" id="line-1959"><code>					fh.Type, fh.StreamID,</code></span>
<span class="codeline" id="line-1960"><code>					last.Header().Type, fr.lastHeaderStream))</code></span>
<span class="codeline" id="line-1961"><code>		}</code></span>
<span class="codeline" id="line-1962"><code>		if fh.StreamID != fr.lastHeaderStream {</code></span>
<span class="codeline" id="line-1963"><code>			return fr.connError(http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-1964"><code>				fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d",</code></span>
<span class="codeline" id="line-1965"><code>					fh.StreamID, fr.lastHeaderStream))</code></span>
<span class="codeline" id="line-1966"><code>		}</code></span>
<span class="codeline" id="line-1967"><code>	} else if fh.Type == http2FrameContinuation {</code></span>
<span class="codeline" id="line-1968"><code>		return fr.connError(http2ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID))</code></span>
<span class="codeline" id="line-1969"><code>	}</code></span>
<span class="codeline" id="line-1970"><code></code></span>
<span class="codeline" id="line-1971"><code>	switch fh.Type {</code></span>
<span class="codeline" id="line-1972"><code>	case http2FrameHeaders, http2FrameContinuation:</code></span>
<span class="codeline" id="line-1973"><code>		if fh.Flags.Has(http2FlagHeadersEndHeaders) {</code></span>
<span class="codeline" id="line-1974"><code>			fr.lastHeaderStream = 0</code></span>
<span class="codeline" id="line-1975"><code>		} else {</code></span>
<span class="codeline" id="line-1976"><code>			fr.lastHeaderStream = fh.StreamID</code></span>
<span class="codeline" id="line-1977"><code>		}</code></span>
<span class="codeline" id="line-1978"><code>	}</code></span>
<span class="codeline" id="line-1979"><code></code></span>
<span class="codeline" id="line-1980"><code>	return nil</code></span>
<span class="codeline" id="line-1981"><code>}</code></span>
<span class="codeline" id="line-1982"><code></code></span>
<span class="codeline" id="line-1983"><code>// A DataFrame conveys arbitrary, variable-length sequences of octets</code></span>
<span class="codeline" id="line-1984"><code>// associated with a stream.</code></span>
<span class="codeline" id="line-1985"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.1</code></span>
<span class="codeline" id="line-1986"><code>type http2DataFrame struct {</code></span>
<span class="codeline" id="line-1987"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-1988"><code>	data []byte</code></span>
<span class="codeline" id="line-1989"><code>}</code></span>
<span class="codeline" id="line-1990"><code></code></span>
<span class="codeline" id="line-1991"><code>func (f *http2DataFrame) StreamEnded() bool {</code></span>
<span class="codeline" id="line-1992"><code>	return f.http2FrameHeader.Flags.Has(http2FlagDataEndStream)</code></span>
<span class="codeline" id="line-1993"><code>}</code></span>
<span class="codeline" id="line-1994"><code></code></span>
<span class="codeline" id="line-1995"><code>// Data returns the frame's data octets, not including any padding</code></span>
<span class="codeline" id="line-1996"><code>// size byte or padding suffix bytes.</code></span>
<span class="codeline" id="line-1997"><code>// The caller must not retain the returned memory past the next</code></span>
<span class="codeline" id="line-1998"><code>// call to ReadFrame.</code></span>
<span class="codeline" id="line-1999"><code>func (f *http2DataFrame) Data() []byte {</code></span>
<span class="codeline" id="line-2000"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2001"><code>	return f.data</code></span>
<span class="codeline" id="line-2002"><code>}</code></span>
<span class="codeline" id="line-2003"><code></code></span>
<span class="codeline" id="line-2004"><code>func http2parseDataFrame(fc *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2005"><code>	if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2006"><code>		// DATA frames MUST be associated with a stream. If a</code></span>
<span class="codeline" id="line-2007"><code>		// DATA frame is received whose stream identifier</code></span>
<span class="codeline" id="line-2008"><code>		// field is 0x0, the recipient MUST respond with a</code></span>
<span class="codeline" id="line-2009"><code>		// connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-2010"><code>		// PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-2011"><code>		countError("frame_data_stream_0")</code></span>
<span class="codeline" id="line-2012"><code>		return nil, http2connError{http2ErrCodeProtocol, "DATA frame with stream ID 0"}</code></span>
<span class="codeline" id="line-2013"><code>	}</code></span>
<span class="codeline" id="line-2014"><code>	f := fc.getDataFrame()</code></span>
<span class="codeline" id="line-2015"><code>	f.http2FrameHeader = fh</code></span>
<span class="codeline" id="line-2016"><code></code></span>
<span class="codeline" id="line-2017"><code>	var padSize byte</code></span>
<span class="codeline" id="line-2018"><code>	if fh.Flags.Has(http2FlagDataPadded) {</code></span>
<span class="codeline" id="line-2019"><code>		var err error</code></span>
<span class="codeline" id="line-2020"><code>		payload, padSize, err = http2readByte(payload)</code></span>
<span class="codeline" id="line-2021"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2022"><code>			countError("frame_data_pad_byte_short")</code></span>
<span class="codeline" id="line-2023"><code>			return nil, err</code></span>
<span class="codeline" id="line-2024"><code>		}</code></span>
<span class="codeline" id="line-2025"><code>	}</code></span>
<span class="codeline" id="line-2026"><code>	if int(padSize) &gt; len(payload) {</code></span>
<span class="codeline" id="line-2027"><code>		// If the length of the padding is greater than the</code></span>
<span class="codeline" id="line-2028"><code>		// length of the frame payload, the recipient MUST</code></span>
<span class="codeline" id="line-2029"><code>		// treat this as a connection error.</code></span>
<span class="codeline" id="line-2030"><code>		// Filed: https://github.com/http2/http2-spec/issues/610</code></span>
<span class="codeline" id="line-2031"><code>		countError("frame_data_pad_too_big")</code></span>
<span class="codeline" id="line-2032"><code>		return nil, http2connError{http2ErrCodeProtocol, "pad size larger than data payload"}</code></span>
<span class="codeline" id="line-2033"><code>	}</code></span>
<span class="codeline" id="line-2034"><code>	f.data = payload[:len(payload)-int(padSize)]</code></span>
<span class="codeline" id="line-2035"><code>	return f, nil</code></span>
<span class="codeline" id="line-2036"><code>}</code></span>
<span class="codeline" id="line-2037"><code></code></span>
<span class="codeline" id="line-2038"><code>var (</code></span>
<span class="codeline" id="line-2039"><code>	http2errStreamID    = errors.New("invalid stream ID")</code></span>
<span class="codeline" id="line-2040"><code>	http2errDepStreamID = errors.New("invalid dependent stream ID")</code></span>
<span class="codeline" id="line-2041"><code>	http2errPadLength   = errors.New("pad length too large")</code></span>
<span class="codeline" id="line-2042"><code>	http2errPadBytes    = errors.New("padding bytes must all be zeros unless AllowIllegalWrites is enabled")</code></span>
<span class="codeline" id="line-2043"><code>)</code></span>
<span class="codeline" id="line-2044"><code></code></span>
<span class="codeline" id="line-2045"><code>func http2validStreamIDOrZero(streamID uint32) bool {</code></span>
<span class="codeline" id="line-2046"><code>	return streamID&amp;(1&lt;&lt;31) == 0</code></span>
<span class="codeline" id="line-2047"><code>}</code></span>
<span class="codeline" id="line-2048"><code></code></span>
<span class="codeline" id="line-2049"><code>func http2validStreamID(streamID uint32) bool {</code></span>
<span class="codeline" id="line-2050"><code>	return streamID != 0 &amp;&amp; streamID&amp;(1&lt;&lt;31) == 0</code></span>
<span class="codeline" id="line-2051"><code>}</code></span>
<span class="codeline" id="line-2052"><code></code></span>
<span class="codeline" id="line-2053"><code>// WriteData writes a DATA frame.</code></span>
<span class="codeline" id="line-2054"><code>//</code></span>
<span class="codeline" id="line-2055"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2056"><code>// It is the caller's responsibility not to violate the maximum frame size</code></span>
<span class="codeline" id="line-2057"><code>// and to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2058"><code>func (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error {</code></span>
<span class="codeline" id="line-2059"><code>	return f.WriteDataPadded(streamID, endStream, data, nil)</code></span>
<span class="codeline" id="line-2060"><code>}</code></span>
<span class="codeline" id="line-2061"><code></code></span>
<span class="codeline" id="line-2062"><code>// WriteDataPadded writes a DATA frame with optional padding.</code></span>
<span class="codeline" id="line-2063"><code>//</code></span>
<span class="codeline" id="line-2064"><code>// If pad is nil, the padding bit is not sent.</code></span>
<span class="codeline" id="line-2065"><code>// The length of pad must not exceed 255 bytes.</code></span>
<span class="codeline" id="line-2066"><code>// The bytes of pad must all be zero, unless f.AllowIllegalWrites is set.</code></span>
<span class="codeline" id="line-2067"><code>//</code></span>
<span class="codeline" id="line-2068"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2069"><code>// It is the caller's responsibility not to violate the maximum frame size</code></span>
<span class="codeline" id="line-2070"><code>// and to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2071"><code>func (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {</code></span>
<span class="codeline" id="line-2072"><code>	if err := f.startWriteDataPadded(streamID, endStream, data, pad); err != nil {</code></span>
<span class="codeline" id="line-2073"><code>		return err</code></span>
<span class="codeline" id="line-2074"><code>	}</code></span>
<span class="codeline" id="line-2075"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2076"><code>}</code></span>
<span class="codeline" id="line-2077"><code></code></span>
<span class="codeline" id="line-2078"><code>// startWriteDataPadded is WriteDataPadded, but only writes the frame to the Framer's internal buffer.</code></span>
<span class="codeline" id="line-2079"><code>// The caller should call endWrite to flush the frame to the underlying writer.</code></span>
<span class="codeline" id="line-2080"><code>func (f *http2Framer) startWriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {</code></span>
<span class="codeline" id="line-2081"><code>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2082"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2083"><code>	}</code></span>
<span class="codeline" id="line-2084"><code>	if len(pad) &gt; 0 {</code></span>
<span class="codeline" id="line-2085"><code>		if len(pad) &gt; 255 {</code></span>
<span class="codeline" id="line-2086"><code>			return http2errPadLength</code></span>
<span class="codeline" id="line-2087"><code>		}</code></span>
<span class="codeline" id="line-2088"><code>		if !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2089"><code>			for _, b := range pad {</code></span>
<span class="codeline" id="line-2090"><code>				if b != 0 {</code></span>
<span class="codeline" id="line-2091"><code>					// "Padding octets MUST be set to zero when sending."</code></span>
<span class="codeline" id="line-2092"><code>					return http2errPadBytes</code></span>
<span class="codeline" id="line-2093"><code>				}</code></span>
<span class="codeline" id="line-2094"><code>			}</code></span>
<span class="codeline" id="line-2095"><code>		}</code></span>
<span class="codeline" id="line-2096"><code>	}</code></span>
<span class="codeline" id="line-2097"><code>	var flags http2Flags</code></span>
<span class="codeline" id="line-2098"><code>	if endStream {</code></span>
<span class="codeline" id="line-2099"><code>		flags |= http2FlagDataEndStream</code></span>
<span class="codeline" id="line-2100"><code>	}</code></span>
<span class="codeline" id="line-2101"><code>	if pad != nil {</code></span>
<span class="codeline" id="line-2102"><code>		flags |= http2FlagDataPadded</code></span>
<span class="codeline" id="line-2103"><code>	}</code></span>
<span class="codeline" id="line-2104"><code>	f.startWrite(http2FrameData, flags, streamID)</code></span>
<span class="codeline" id="line-2105"><code>	if pad != nil {</code></span>
<span class="codeline" id="line-2106"><code>		f.wbuf = append(f.wbuf, byte(len(pad)))</code></span>
<span class="codeline" id="line-2107"><code>	}</code></span>
<span class="codeline" id="line-2108"><code>	f.wbuf = append(f.wbuf, data...)</code></span>
<span class="codeline" id="line-2109"><code>	f.wbuf = append(f.wbuf, pad...)</code></span>
<span class="codeline" id="line-2110"><code>	return nil</code></span>
<span class="codeline" id="line-2111"><code>}</code></span>
<span class="codeline" id="line-2112"><code></code></span>
<span class="codeline" id="line-2113"><code>// A SettingsFrame conveys configuration parameters that affect how</code></span>
<span class="codeline" id="line-2114"><code>// endpoints communicate, such as preferences and constraints on peer</code></span>
<span class="codeline" id="line-2115"><code>// behavior.</code></span>
<span class="codeline" id="line-2116"><code>//</code></span>
<span class="codeline" id="line-2117"><code>// See https://httpwg.org/specs/rfc7540.html#SETTINGS</code></span>
<span class="codeline" id="line-2118"><code>type http2SettingsFrame struct {</code></span>
<span class="codeline" id="line-2119"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2120"><code>	p []byte</code></span>
<span class="codeline" id="line-2121"><code>}</code></span>
<span class="codeline" id="line-2122"><code></code></span>
<span class="codeline" id="line-2123"><code>func http2parseSettingsFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2124"><code>	if fh.Flags.Has(http2FlagSettingsAck) &amp;&amp; fh.Length &gt; 0 {</code></span>
<span class="codeline" id="line-2125"><code>		// When this (ACK 0x1) bit is set, the payload of the</code></span>
<span class="codeline" id="line-2126"><code>		// SETTINGS frame MUST be empty. Receipt of a</code></span>
<span class="codeline" id="line-2127"><code>		// SETTINGS frame with the ACK flag set and a length</code></span>
<span class="codeline" id="line-2128"><code>		// field value other than 0 MUST be treated as a</code></span>
<span class="codeline" id="line-2129"><code>		// connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-2130"><code>		// FRAME_SIZE_ERROR.</code></span>
<span class="codeline" id="line-2131"><code>		countError("frame_settings_ack_with_length")</code></span>
<span class="codeline" id="line-2132"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2133"><code>	}</code></span>
<span class="codeline" id="line-2134"><code>	if fh.StreamID != 0 {</code></span>
<span class="codeline" id="line-2135"><code>		// SETTINGS frames always apply to a connection,</code></span>
<span class="codeline" id="line-2136"><code>		// never a single stream. The stream identifier for a</code></span>
<span class="codeline" id="line-2137"><code>		// SETTINGS frame MUST be zero (0x0).  If an endpoint</code></span>
<span class="codeline" id="line-2138"><code>		// receives a SETTINGS frame whose stream identifier</code></span>
<span class="codeline" id="line-2139"><code>		// field is anything other than 0x0, the endpoint MUST</code></span>
<span class="codeline" id="line-2140"><code>		// respond with a connection error (Section 5.4.1) of</code></span>
<span class="codeline" id="line-2141"><code>		// type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-2142"><code>		countError("frame_settings_has_stream")</code></span>
<span class="codeline" id="line-2143"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2144"><code>	}</code></span>
<span class="codeline" id="line-2145"><code>	if len(p)%6 != 0 {</code></span>
<span class="codeline" id="line-2146"><code>		countError("frame_settings_mod_6")</code></span>
<span class="codeline" id="line-2147"><code>		// Expecting even number of 6 byte settings.</code></span>
<span class="codeline" id="line-2148"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2149"><code>	}</code></span>
<span class="codeline" id="line-2150"><code>	f := &amp;http2SettingsFrame{http2FrameHeader: fh, p: p}</code></span>
<span class="codeline" id="line-2151"><code>	if v, ok := f.Value(http2SettingInitialWindowSize); ok &amp;&amp; v &gt; (1&lt;&lt;31)-1 {</code></span>
<span class="codeline" id="line-2152"><code>		countError("frame_settings_window_size_too_big")</code></span>
<span class="codeline" id="line-2153"><code>		// Values above the maximum flow control window size of 2^31 - 1 MUST</code></span>
<span class="codeline" id="line-2154"><code>		// be treated as a connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-2155"><code>		// FLOW_CONTROL_ERROR.</code></span>
<span class="codeline" id="line-2156"><code>		return nil, http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-2157"><code>	}</code></span>
<span class="codeline" id="line-2158"><code>	return f, nil</code></span>
<span class="codeline" id="line-2159"><code>}</code></span>
<span class="codeline" id="line-2160"><code></code></span>
<span class="codeline" id="line-2161"><code>func (f *http2SettingsFrame) IsAck() bool {</code></span>
<span class="codeline" id="line-2162"><code>	return f.http2FrameHeader.Flags.Has(http2FlagSettingsAck)</code></span>
<span class="codeline" id="line-2163"><code>}</code></span>
<span class="codeline" id="line-2164"><code></code></span>
<span class="codeline" id="line-2165"><code>func (f *http2SettingsFrame) Value(id http2SettingID) (v uint32, ok bool) {</code></span>
<span class="codeline" id="line-2166"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2167"><code>	for i := 0; i &lt; f.NumSettings(); i++ {</code></span>
<span class="codeline" id="line-2168"><code>		if s := f.Setting(i); s.ID == id {</code></span>
<span class="codeline" id="line-2169"><code>			return s.Val, true</code></span>
<span class="codeline" id="line-2170"><code>		}</code></span>
<span class="codeline" id="line-2171"><code>	}</code></span>
<span class="codeline" id="line-2172"><code>	return 0, false</code></span>
<span class="codeline" id="line-2173"><code>}</code></span>
<span class="codeline" id="line-2174"><code></code></span>
<span class="codeline" id="line-2175"><code>// Setting returns the setting from the frame at the given 0-based index.</code></span>
<span class="codeline" id="line-2176"><code>// The index must be &gt;= 0 and less than f.NumSettings().</code></span>
<span class="codeline" id="line-2177"><code>func (f *http2SettingsFrame) Setting(i int) http2Setting {</code></span>
<span class="codeline" id="line-2178"><code>	buf := f.p</code></span>
<span class="codeline" id="line-2179"><code>	return http2Setting{</code></span>
<span class="codeline" id="line-2180"><code>		ID:  http2SettingID(binary.BigEndian.Uint16(buf[i*6 : i*6+2])),</code></span>
<span class="codeline" id="line-2181"><code>		Val: binary.BigEndian.Uint32(buf[i*6+2 : i*6+6]),</code></span>
<span class="codeline" id="line-2182"><code>	}</code></span>
<span class="codeline" id="line-2183"><code>}</code></span>
<span class="codeline" id="line-2184"><code></code></span>
<span class="codeline" id="line-2185"><code>func (f *http2SettingsFrame) NumSettings() int { return len(f.p) / 6 }</code></span>
<span class="codeline" id="line-2186"><code></code></span>
<span class="codeline" id="line-2187"><code>// HasDuplicates reports whether f contains any duplicate setting IDs.</code></span>
<span class="codeline" id="line-2188"><code>func (f *http2SettingsFrame) HasDuplicates() bool {</code></span>
<span class="codeline" id="line-2189"><code>	num := f.NumSettings()</code></span>
<span class="codeline" id="line-2190"><code>	if num == 0 {</code></span>
<span class="codeline" id="line-2191"><code>		return false</code></span>
<span class="codeline" id="line-2192"><code>	}</code></span>
<span class="codeline" id="line-2193"><code>	// If it's small enough (the common case), just do the n^2</code></span>
<span class="codeline" id="line-2194"><code>	// thing and avoid a map allocation.</code></span>
<span class="codeline" id="line-2195"><code>	if num &lt; 10 {</code></span>
<span class="codeline" id="line-2196"><code>		for i := 0; i &lt; num; i++ {</code></span>
<span class="codeline" id="line-2197"><code>			idi := f.Setting(i).ID</code></span>
<span class="codeline" id="line-2198"><code>			for j := i + 1; j &lt; num; j++ {</code></span>
<span class="codeline" id="line-2199"><code>				idj := f.Setting(j).ID</code></span>
<span class="codeline" id="line-2200"><code>				if idi == idj {</code></span>
<span class="codeline" id="line-2201"><code>					return true</code></span>
<span class="codeline" id="line-2202"><code>				}</code></span>
<span class="codeline" id="line-2203"><code>			}</code></span>
<span class="codeline" id="line-2204"><code>		}</code></span>
<span class="codeline" id="line-2205"><code>		return false</code></span>
<span class="codeline" id="line-2206"><code>	}</code></span>
<span class="codeline" id="line-2207"><code>	seen := map[http2SettingID]bool{}</code></span>
<span class="codeline" id="line-2208"><code>	for i := 0; i &lt; num; i++ {</code></span>
<span class="codeline" id="line-2209"><code>		id := f.Setting(i).ID</code></span>
<span class="codeline" id="line-2210"><code>		if seen[id] {</code></span>
<span class="codeline" id="line-2211"><code>			return true</code></span>
<span class="codeline" id="line-2212"><code>		}</code></span>
<span class="codeline" id="line-2213"><code>		seen[id] = true</code></span>
<span class="codeline" id="line-2214"><code>	}</code></span>
<span class="codeline" id="line-2215"><code>	return false</code></span>
<span class="codeline" id="line-2216"><code>}</code></span>
<span class="codeline" id="line-2217"><code></code></span>
<span class="codeline" id="line-2218"><code>// ForeachSetting runs fn for each setting.</code></span>
<span class="codeline" id="line-2219"><code>// It stops and returns the first error.</code></span>
<span class="codeline" id="line-2220"><code>func (f *http2SettingsFrame) ForeachSetting(fn func(http2Setting) error) error {</code></span>
<span class="codeline" id="line-2221"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2222"><code>	for i := 0; i &lt; f.NumSettings(); i++ {</code></span>
<span class="codeline" id="line-2223"><code>		if err := fn(f.Setting(i)); err != nil {</code></span>
<span class="codeline" id="line-2224"><code>			return err</code></span>
<span class="codeline" id="line-2225"><code>		}</code></span>
<span class="codeline" id="line-2226"><code>	}</code></span>
<span class="codeline" id="line-2227"><code>	return nil</code></span>
<span class="codeline" id="line-2228"><code>}</code></span>
<span class="codeline" id="line-2229"><code></code></span>
<span class="codeline" id="line-2230"><code>// WriteSettings writes a SETTINGS frame with zero or more settings</code></span>
<span class="codeline" id="line-2231"><code>// specified and the ACK bit not set.</code></span>
<span class="codeline" id="line-2232"><code>//</code></span>
<span class="codeline" id="line-2233"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2234"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2235"><code>func (f *http2Framer) WriteSettings(settings ...http2Setting) error {</code></span>
<span class="codeline" id="line-2236"><code>	f.startWrite(http2FrameSettings, 0, 0)</code></span>
<span class="codeline" id="line-2237"><code>	for _, s := range settings {</code></span>
<span class="codeline" id="line-2238"><code>		f.writeUint16(uint16(s.ID))</code></span>
<span class="codeline" id="line-2239"><code>		f.writeUint32(s.Val)</code></span>
<span class="codeline" id="line-2240"><code>	}</code></span>
<span class="codeline" id="line-2241"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2242"><code>}</code></span>
<span class="codeline" id="line-2243"><code></code></span>
<span class="codeline" id="line-2244"><code>// WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.</code></span>
<span class="codeline" id="line-2245"><code>//</code></span>
<span class="codeline" id="line-2246"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2247"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2248"><code>func (f *http2Framer) WriteSettingsAck() error {</code></span>
<span class="codeline" id="line-2249"><code>	f.startWrite(http2FrameSettings, http2FlagSettingsAck, 0)</code></span>
<span class="codeline" id="line-2250"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2251"><code>}</code></span>
<span class="codeline" id="line-2252"><code></code></span>
<span class="codeline" id="line-2253"><code>// A PingFrame is a mechanism for measuring a minimal round trip time</code></span>
<span class="codeline" id="line-2254"><code>// from the sender, as well as determining whether an idle connection</code></span>
<span class="codeline" id="line-2255"><code>// is still functional.</code></span>
<span class="codeline" id="line-2256"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.7</code></span>
<span class="codeline" id="line-2257"><code>type http2PingFrame struct {</code></span>
<span class="codeline" id="line-2258"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2259"><code>	Data [8]byte</code></span>
<span class="codeline" id="line-2260"><code>}</code></span>
<span class="codeline" id="line-2261"><code></code></span>
<span class="codeline" id="line-2262"><code>func (f *http2PingFrame) IsAck() bool { return f.Flags.Has(http2FlagPingAck) }</code></span>
<span class="codeline" id="line-2263"><code></code></span>
<span class="codeline" id="line-2264"><code>func http2parsePingFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2265"><code>	if len(payload) != 8 {</code></span>
<span class="codeline" id="line-2266"><code>		countError("frame_ping_length")</code></span>
<span class="codeline" id="line-2267"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2268"><code>	}</code></span>
<span class="codeline" id="line-2269"><code>	if fh.StreamID != 0 {</code></span>
<span class="codeline" id="line-2270"><code>		countError("frame_ping_has_stream")</code></span>
<span class="codeline" id="line-2271"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2272"><code>	}</code></span>
<span class="codeline" id="line-2273"><code>	f := &amp;http2PingFrame{http2FrameHeader: fh}</code></span>
<span class="codeline" id="line-2274"><code>	copy(f.Data[:], payload)</code></span>
<span class="codeline" id="line-2275"><code>	return f, nil</code></span>
<span class="codeline" id="line-2276"><code>}</code></span>
<span class="codeline" id="line-2277"><code></code></span>
<span class="codeline" id="line-2278"><code>func (f *http2Framer) WritePing(ack bool, data [8]byte) error {</code></span>
<span class="codeline" id="line-2279"><code>	var flags http2Flags</code></span>
<span class="codeline" id="line-2280"><code>	if ack {</code></span>
<span class="codeline" id="line-2281"><code>		flags = http2FlagPingAck</code></span>
<span class="codeline" id="line-2282"><code>	}</code></span>
<span class="codeline" id="line-2283"><code>	f.startWrite(http2FramePing, flags, 0)</code></span>
<span class="codeline" id="line-2284"><code>	f.writeBytes(data[:])</code></span>
<span class="codeline" id="line-2285"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2286"><code>}</code></span>
<span class="codeline" id="line-2287"><code></code></span>
<span class="codeline" id="line-2288"><code>// A GoAwayFrame informs the remote peer to stop creating streams on this connection.</code></span>
<span class="codeline" id="line-2289"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.8</code></span>
<span class="codeline" id="line-2290"><code>type http2GoAwayFrame struct {</code></span>
<span class="codeline" id="line-2291"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2292"><code>	LastStreamID uint32</code></span>
<span class="codeline" id="line-2293"><code>	ErrCode      http2ErrCode</code></span>
<span class="codeline" id="line-2294"><code>	debugData    []byte</code></span>
<span class="codeline" id="line-2295"><code>}</code></span>
<span class="codeline" id="line-2296"><code></code></span>
<span class="codeline" id="line-2297"><code>// DebugData returns any debug data in the GOAWAY frame. Its contents</code></span>
<span class="codeline" id="line-2298"><code>// are not defined.</code></span>
<span class="codeline" id="line-2299"><code>// The caller must not retain the returned memory past the next</code></span>
<span class="codeline" id="line-2300"><code>// call to ReadFrame.</code></span>
<span class="codeline" id="line-2301"><code>func (f *http2GoAwayFrame) DebugData() []byte {</code></span>
<span class="codeline" id="line-2302"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2303"><code>	return f.debugData</code></span>
<span class="codeline" id="line-2304"><code>}</code></span>
<span class="codeline" id="line-2305"><code></code></span>
<span class="codeline" id="line-2306"><code>func http2parseGoAwayFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2307"><code>	if fh.StreamID != 0 {</code></span>
<span class="codeline" id="line-2308"><code>		countError("frame_goaway_has_stream")</code></span>
<span class="codeline" id="line-2309"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2310"><code>	}</code></span>
<span class="codeline" id="line-2311"><code>	if len(p) &lt; 8 {</code></span>
<span class="codeline" id="line-2312"><code>		countError("frame_goaway_short")</code></span>
<span class="codeline" id="line-2313"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2314"><code>	}</code></span>
<span class="codeline" id="line-2315"><code>	return &amp;http2GoAwayFrame{</code></span>
<span class="codeline" id="line-2316"><code>		http2FrameHeader: fh,</code></span>
<span class="codeline" id="line-2317"><code>		LastStreamID:     binary.BigEndian.Uint32(p[:4]) &amp; (1&lt;&lt;31 - 1),</code></span>
<span class="codeline" id="line-2318"><code>		ErrCode:          http2ErrCode(binary.BigEndian.Uint32(p[4:8])),</code></span>
<span class="codeline" id="line-2319"><code>		debugData:        p[8:],</code></span>
<span class="codeline" id="line-2320"><code>	}, nil</code></span>
<span class="codeline" id="line-2321"><code>}</code></span>
<span class="codeline" id="line-2322"><code></code></span>
<span class="codeline" id="line-2323"><code>func (f *http2Framer) WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error {</code></span>
<span class="codeline" id="line-2324"><code>	f.startWrite(http2FrameGoAway, 0, 0)</code></span>
<span class="codeline" id="line-2325"><code>	f.writeUint32(maxStreamID &amp; (1&lt;&lt;31 - 1))</code></span>
<span class="codeline" id="line-2326"><code>	f.writeUint32(uint32(code))</code></span>
<span class="codeline" id="line-2327"><code>	f.writeBytes(debugData)</code></span>
<span class="codeline" id="line-2328"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2329"><code>}</code></span>
<span class="codeline" id="line-2330"><code></code></span>
<span class="codeline" id="line-2331"><code>// An UnknownFrame is the frame type returned when the frame type is unknown</code></span>
<span class="codeline" id="line-2332"><code>// or no specific frame type parser exists.</code></span>
<span class="codeline" id="line-2333"><code>type http2UnknownFrame struct {</code></span>
<span class="codeline" id="line-2334"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2335"><code>	p []byte</code></span>
<span class="codeline" id="line-2336"><code>}</code></span>
<span class="codeline" id="line-2337"><code></code></span>
<span class="codeline" id="line-2338"><code>// Payload returns the frame's payload (after the header).  It is not</code></span>
<span class="codeline" id="line-2339"><code>// valid to call this method after a subsequent call to</code></span>
<span class="codeline" id="line-2340"><code>// Framer.ReadFrame, nor is it valid to retain the returned slice.</code></span>
<span class="codeline" id="line-2341"><code>// The memory is owned by the Framer and is invalidated when the next</code></span>
<span class="codeline" id="line-2342"><code>// frame is read.</code></span>
<span class="codeline" id="line-2343"><code>func (f *http2UnknownFrame) Payload() []byte {</code></span>
<span class="codeline" id="line-2344"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2345"><code>	return f.p</code></span>
<span class="codeline" id="line-2346"><code>}</code></span>
<span class="codeline" id="line-2347"><code></code></span>
<span class="codeline" id="line-2348"><code>func http2parseUnknownFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2349"><code>	return &amp;http2UnknownFrame{fh, p}, nil</code></span>
<span class="codeline" id="line-2350"><code>}</code></span>
<span class="codeline" id="line-2351"><code></code></span>
<span class="codeline" id="line-2352"><code>// A WindowUpdateFrame is used to implement flow control.</code></span>
<span class="codeline" id="line-2353"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.9</code></span>
<span class="codeline" id="line-2354"><code>type http2WindowUpdateFrame struct {</code></span>
<span class="codeline" id="line-2355"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2356"><code>	Increment uint32 // never read with high bit set</code></span>
<span class="codeline" id="line-2357"><code>}</code></span>
<span class="codeline" id="line-2358"><code></code></span>
<span class="codeline" id="line-2359"><code>func http2parseWindowUpdateFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2360"><code>	if len(p) != 4 {</code></span>
<span class="codeline" id="line-2361"><code>		countError("frame_windowupdate_bad_len")</code></span>
<span class="codeline" id="line-2362"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2363"><code>	}</code></span>
<span class="codeline" id="line-2364"><code>	inc := binary.BigEndian.Uint32(p[:4]) &amp; 0x7fffffff // mask off high reserved bit</code></span>
<span class="codeline" id="line-2365"><code>	if inc == 0 {</code></span>
<span class="codeline" id="line-2366"><code>		// A receiver MUST treat the receipt of a</code></span>
<span class="codeline" id="line-2367"><code>		// WINDOW_UPDATE frame with an flow control window</code></span>
<span class="codeline" id="line-2368"><code>		// increment of 0 as a stream error (Section 5.4.2) of</code></span>
<span class="codeline" id="line-2369"><code>		// type PROTOCOL_ERROR; errors on the connection flow</code></span>
<span class="codeline" id="line-2370"><code>		// control window MUST be treated as a connection</code></span>
<span class="codeline" id="line-2371"><code>		// error (Section 5.4.1).</code></span>
<span class="codeline" id="line-2372"><code>		if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2373"><code>			countError("frame_windowupdate_zero_inc_conn")</code></span>
<span class="codeline" id="line-2374"><code>			return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2375"><code>		}</code></span>
<span class="codeline" id="line-2376"><code>		countError("frame_windowupdate_zero_inc_stream")</code></span>
<span class="codeline" id="line-2377"><code>		return nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2378"><code>	}</code></span>
<span class="codeline" id="line-2379"><code>	return &amp;http2WindowUpdateFrame{</code></span>
<span class="codeline" id="line-2380"><code>		http2FrameHeader: fh,</code></span>
<span class="codeline" id="line-2381"><code>		Increment:        inc,</code></span>
<span class="codeline" id="line-2382"><code>	}, nil</code></span>
<span class="codeline" id="line-2383"><code>}</code></span>
<span class="codeline" id="line-2384"><code></code></span>
<span class="codeline" id="line-2385"><code>// WriteWindowUpdate writes a WINDOW_UPDATE frame.</code></span>
<span class="codeline" id="line-2386"><code>// The increment value must be between 1 and 2,147,483,647, inclusive.</code></span>
<span class="codeline" id="line-2387"><code>// If the Stream ID is zero, the window update applies to the</code></span>
<span class="codeline" id="line-2388"><code>// connection as a whole.</code></span>
<span class="codeline" id="line-2389"><code>func (f *http2Framer) WriteWindowUpdate(streamID, incr uint32) error {</code></span>
<span class="codeline" id="line-2390"><code>	// "The legal range for the increment to the flow control window is 1 to 2^31-1 (2,147,483,647) octets."</code></span>
<span class="codeline" id="line-2391"><code>	if (incr &lt; 1 || incr &gt; 2147483647) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2392"><code>		return errors.New("illegal window increment value")</code></span>
<span class="codeline" id="line-2393"><code>	}</code></span>
<span class="codeline" id="line-2394"><code>	f.startWrite(http2FrameWindowUpdate, 0, streamID)</code></span>
<span class="codeline" id="line-2395"><code>	f.writeUint32(incr)</code></span>
<span class="codeline" id="line-2396"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2397"><code>}</code></span>
<span class="codeline" id="line-2398"><code></code></span>
<span class="codeline" id="line-2399"><code>// A HeadersFrame is used to open a stream and additionally carries a</code></span>
<span class="codeline" id="line-2400"><code>// header block fragment.</code></span>
<span class="codeline" id="line-2401"><code>type http2HeadersFrame struct {</code></span>
<span class="codeline" id="line-2402"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2403"><code></code></span>
<span class="codeline" id="line-2404"><code>	// Priority is set if FlagHeadersPriority is set in the FrameHeader.</code></span>
<span class="codeline" id="line-2405"><code>	Priority http2PriorityParam</code></span>
<span class="codeline" id="line-2406"><code></code></span>
<span class="codeline" id="line-2407"><code>	headerFragBuf []byte // not owned</code></span>
<span class="codeline" id="line-2408"><code>}</code></span>
<span class="codeline" id="line-2409"><code></code></span>
<span class="codeline" id="line-2410"><code>func (f *http2HeadersFrame) HeaderBlockFragment() []byte {</code></span>
<span class="codeline" id="line-2411"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2412"><code>	return f.headerFragBuf</code></span>
<span class="codeline" id="line-2413"><code>}</code></span>
<span class="codeline" id="line-2414"><code></code></span>
<span class="codeline" id="line-2415"><code>func (f *http2HeadersFrame) HeadersEnded() bool {</code></span>
<span class="codeline" id="line-2416"><code>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndHeaders)</code></span>
<span class="codeline" id="line-2417"><code>}</code></span>
<span class="codeline" id="line-2418"><code></code></span>
<span class="codeline" id="line-2419"><code>func (f *http2HeadersFrame) StreamEnded() bool {</code></span>
<span class="codeline" id="line-2420"><code>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersEndStream)</code></span>
<span class="codeline" id="line-2421"><code>}</code></span>
<span class="codeline" id="line-2422"><code></code></span>
<span class="codeline" id="line-2423"><code>func (f *http2HeadersFrame) HasPriority() bool {</code></span>
<span class="codeline" id="line-2424"><code>	return f.http2FrameHeader.Flags.Has(http2FlagHeadersPriority)</code></span>
<span class="codeline" id="line-2425"><code>}</code></span>
<span class="codeline" id="line-2426"><code></code></span>
<span class="codeline" id="line-2427"><code>func http2parseHeadersFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (_ http2Frame, err error) {</code></span>
<span class="codeline" id="line-2428"><code>	hf := &amp;http2HeadersFrame{</code></span>
<span class="codeline" id="line-2429"><code>		http2FrameHeader: fh,</code></span>
<span class="codeline" id="line-2430"><code>	}</code></span>
<span class="codeline" id="line-2431"><code>	if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2432"><code>		// HEADERS frames MUST be associated with a stream. If a HEADERS frame</code></span>
<span class="codeline" id="line-2433"><code>		// is received whose stream identifier field is 0x0, the recipient MUST</code></span>
<span class="codeline" id="line-2434"><code>		// respond with a connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-2435"><code>		// PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-2436"><code>		countError("frame_headers_zero_stream")</code></span>
<span class="codeline" id="line-2437"><code>		return nil, http2connError{http2ErrCodeProtocol, "HEADERS frame with stream ID 0"}</code></span>
<span class="codeline" id="line-2438"><code>	}</code></span>
<span class="codeline" id="line-2439"><code>	var padLength uint8</code></span>
<span class="codeline" id="line-2440"><code>	if fh.Flags.Has(http2FlagHeadersPadded) {</code></span>
<span class="codeline" id="line-2441"><code>		if p, padLength, err = http2readByte(p); err != nil {</code></span>
<span class="codeline" id="line-2442"><code>			countError("frame_headers_pad_short")</code></span>
<span class="codeline" id="line-2443"><code>			return</code></span>
<span class="codeline" id="line-2444"><code>		}</code></span>
<span class="codeline" id="line-2445"><code>	}</code></span>
<span class="codeline" id="line-2446"><code>	if fh.Flags.Has(http2FlagHeadersPriority) {</code></span>
<span class="codeline" id="line-2447"><code>		var v uint32</code></span>
<span class="codeline" id="line-2448"><code>		p, v, err = http2readUint32(p)</code></span>
<span class="codeline" id="line-2449"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2450"><code>			countError("frame_headers_prio_short")</code></span>
<span class="codeline" id="line-2451"><code>			return nil, err</code></span>
<span class="codeline" id="line-2452"><code>		}</code></span>
<span class="codeline" id="line-2453"><code>		hf.Priority.StreamDep = v &amp; 0x7fffffff</code></span>
<span class="codeline" id="line-2454"><code>		hf.Priority.Exclusive = (v != hf.Priority.StreamDep) // high bit was set</code></span>
<span class="codeline" id="line-2455"><code>		p, hf.Priority.Weight, err = http2readByte(p)</code></span>
<span class="codeline" id="line-2456"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2457"><code>			countError("frame_headers_prio_weight_short")</code></span>
<span class="codeline" id="line-2458"><code>			return nil, err</code></span>
<span class="codeline" id="line-2459"><code>		}</code></span>
<span class="codeline" id="line-2460"><code>	}</code></span>
<span class="codeline" id="line-2461"><code>	if len(p)-int(padLength) &lt; 0 {</code></span>
<span class="codeline" id="line-2462"><code>		countError("frame_headers_pad_too_big")</code></span>
<span class="codeline" id="line-2463"><code>		return nil, http2streamError(fh.StreamID, http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2464"><code>	}</code></span>
<span class="codeline" id="line-2465"><code>	hf.headerFragBuf = p[:len(p)-int(padLength)]</code></span>
<span class="codeline" id="line-2466"><code>	return hf, nil</code></span>
<span class="codeline" id="line-2467"><code>}</code></span>
<span class="codeline" id="line-2468"><code></code></span>
<span class="codeline" id="line-2469"><code>// HeadersFrameParam are the parameters for writing a HEADERS frame.</code></span>
<span class="codeline" id="line-2470"><code>type http2HeadersFrameParam struct {</code></span>
<span class="codeline" id="line-2471"><code>	// StreamID is the required Stream ID to initiate.</code></span>
<span class="codeline" id="line-2472"><code>	StreamID uint32</code></span>
<span class="codeline" id="line-2473"><code>	// BlockFragment is part (or all) of a Header Block.</code></span>
<span class="codeline" id="line-2474"><code>	BlockFragment []byte</code></span>
<span class="codeline" id="line-2475"><code></code></span>
<span class="codeline" id="line-2476"><code>	// EndStream indicates that the header block is the last that</code></span>
<span class="codeline" id="line-2477"><code>	// the endpoint will send for the identified stream. Setting</code></span>
<span class="codeline" id="line-2478"><code>	// this flag causes the stream to enter one of "half closed"</code></span>
<span class="codeline" id="line-2479"><code>	// states.</code></span>
<span class="codeline" id="line-2480"><code>	EndStream bool</code></span>
<span class="codeline" id="line-2481"><code></code></span>
<span class="codeline" id="line-2482"><code>	// EndHeaders indicates that this frame contains an entire</code></span>
<span class="codeline" id="line-2483"><code>	// header block and is not followed by any</code></span>
<span class="codeline" id="line-2484"><code>	// CONTINUATION frames.</code></span>
<span class="codeline" id="line-2485"><code>	EndHeaders bool</code></span>
<span class="codeline" id="line-2486"><code></code></span>
<span class="codeline" id="line-2487"><code>	// PadLength is the optional number of bytes of zeros to add</code></span>
<span class="codeline" id="line-2488"><code>	// to this frame.</code></span>
<span class="codeline" id="line-2489"><code>	PadLength uint8</code></span>
<span class="codeline" id="line-2490"><code></code></span>
<span class="codeline" id="line-2491"><code>	// Priority, if non-zero, includes stream priority information</code></span>
<span class="codeline" id="line-2492"><code>	// in the HEADER frame.</code></span>
<span class="codeline" id="line-2493"><code>	Priority http2PriorityParam</code></span>
<span class="codeline" id="line-2494"><code>}</code></span>
<span class="codeline" id="line-2495"><code></code></span>
<span class="codeline" id="line-2496"><code>// WriteHeaders writes a single HEADERS frame.</code></span>
<span class="codeline" id="line-2497"><code>//</code></span>
<span class="codeline" id="line-2498"><code>// This is a low-level header writing method. Encoding headers and</code></span>
<span class="codeline" id="line-2499"><code>// splitting them into any necessary CONTINUATION frames is handled</code></span>
<span class="codeline" id="line-2500"><code>// elsewhere.</code></span>
<span class="codeline" id="line-2501"><code>//</code></span>
<span class="codeline" id="line-2502"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2503"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2504"><code>func (f *http2Framer) WriteHeaders(p http2HeadersFrameParam) error {</code></span>
<span class="codeline" id="line-2505"><code>	if !http2validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2506"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2507"><code>	}</code></span>
<span class="codeline" id="line-2508"><code>	var flags http2Flags</code></span>
<span class="codeline" id="line-2509"><code>	if p.PadLength != 0 {</code></span>
<span class="codeline" id="line-2510"><code>		flags |= http2FlagHeadersPadded</code></span>
<span class="codeline" id="line-2511"><code>	}</code></span>
<span class="codeline" id="line-2512"><code>	if p.EndStream {</code></span>
<span class="codeline" id="line-2513"><code>		flags |= http2FlagHeadersEndStream</code></span>
<span class="codeline" id="line-2514"><code>	}</code></span>
<span class="codeline" id="line-2515"><code>	if p.EndHeaders {</code></span>
<span class="codeline" id="line-2516"><code>		flags |= http2FlagHeadersEndHeaders</code></span>
<span class="codeline" id="line-2517"><code>	}</code></span>
<span class="codeline" id="line-2518"><code>	if !p.Priority.IsZero() {</code></span>
<span class="codeline" id="line-2519"><code>		flags |= http2FlagHeadersPriority</code></span>
<span class="codeline" id="line-2520"><code>	}</code></span>
<span class="codeline" id="line-2521"><code>	f.startWrite(http2FrameHeaders, flags, p.StreamID)</code></span>
<span class="codeline" id="line-2522"><code>	if p.PadLength != 0 {</code></span>
<span class="codeline" id="line-2523"><code>		f.writeByte(p.PadLength)</code></span>
<span class="codeline" id="line-2524"><code>	}</code></span>
<span class="codeline" id="line-2525"><code>	if !p.Priority.IsZero() {</code></span>
<span class="codeline" id="line-2526"><code>		v := p.Priority.StreamDep</code></span>
<span class="codeline" id="line-2527"><code>		if !http2validStreamIDOrZero(v) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2528"><code>			return http2errDepStreamID</code></span>
<span class="codeline" id="line-2529"><code>		}</code></span>
<span class="codeline" id="line-2530"><code>		if p.Priority.Exclusive {</code></span>
<span class="codeline" id="line-2531"><code>			v |= 1 &lt;&lt; 31</code></span>
<span class="codeline" id="line-2532"><code>		}</code></span>
<span class="codeline" id="line-2533"><code>		f.writeUint32(v)</code></span>
<span class="codeline" id="line-2534"><code>		f.writeByte(p.Priority.Weight)</code></span>
<span class="codeline" id="line-2535"><code>	}</code></span>
<span class="codeline" id="line-2536"><code>	f.wbuf = append(f.wbuf, p.BlockFragment...)</code></span>
<span class="codeline" id="line-2537"><code>	f.wbuf = append(f.wbuf, http2padZeros[:p.PadLength]...)</code></span>
<span class="codeline" id="line-2538"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2539"><code>}</code></span>
<span class="codeline" id="line-2540"><code></code></span>
<span class="codeline" id="line-2541"><code>// A PriorityFrame specifies the sender-advised priority of a stream.</code></span>
<span class="codeline" id="line-2542"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.3</code></span>
<span class="codeline" id="line-2543"><code>type http2PriorityFrame struct {</code></span>
<span class="codeline" id="line-2544"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2545"><code>	http2PriorityParam</code></span>
<span class="codeline" id="line-2546"><code>}</code></span>
<span class="codeline" id="line-2547"><code></code></span>
<span class="codeline" id="line-2548"><code>// PriorityParam are the stream prioritzation parameters.</code></span>
<span class="codeline" id="line-2549"><code>type http2PriorityParam struct {</code></span>
<span class="codeline" id="line-2550"><code>	// StreamDep is a 31-bit stream identifier for the</code></span>
<span class="codeline" id="line-2551"><code>	// stream that this stream depends on. Zero means no</code></span>
<span class="codeline" id="line-2552"><code>	// dependency.</code></span>
<span class="codeline" id="line-2553"><code>	StreamDep uint32</code></span>
<span class="codeline" id="line-2554"><code></code></span>
<span class="codeline" id="line-2555"><code>	// Exclusive is whether the dependency is exclusive.</code></span>
<span class="codeline" id="line-2556"><code>	Exclusive bool</code></span>
<span class="codeline" id="line-2557"><code></code></span>
<span class="codeline" id="line-2558"><code>	// Weight is the stream's zero-indexed weight. It should be</code></span>
<span class="codeline" id="line-2559"><code>	// set together with StreamDep, or neither should be set. Per</code></span>
<span class="codeline" id="line-2560"><code>	// the spec, "Add one to the value to obtain a weight between</code></span>
<span class="codeline" id="line-2561"><code>	// 1 and 256."</code></span>
<span class="codeline" id="line-2562"><code>	Weight uint8</code></span>
<span class="codeline" id="line-2563"><code>}</code></span>
<span class="codeline" id="line-2564"><code></code></span>
<span class="codeline" id="line-2565"><code>func (p http2PriorityParam) IsZero() bool {</code></span>
<span class="codeline" id="line-2566"><code>	return p == http2PriorityParam{}</code></span>
<span class="codeline" id="line-2567"><code>}</code></span>
<span class="codeline" id="line-2568"><code></code></span>
<span class="codeline" id="line-2569"><code>func http2parsePriorityFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), payload []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2570"><code>	if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2571"><code>		countError("frame_priority_zero_stream")</code></span>
<span class="codeline" id="line-2572"><code>		return nil, http2connError{http2ErrCodeProtocol, "PRIORITY frame with stream ID 0"}</code></span>
<span class="codeline" id="line-2573"><code>	}</code></span>
<span class="codeline" id="line-2574"><code>	if len(payload) != 5 {</code></span>
<span class="codeline" id="line-2575"><code>		countError("frame_priority_bad_length")</code></span>
<span class="codeline" id="line-2576"><code>		return nil, http2connError{http2ErrCodeFrameSize, fmt.Sprintf("PRIORITY frame payload size was %d; want 5", len(payload))}</code></span>
<span class="codeline" id="line-2577"><code>	}</code></span>
<span class="codeline" id="line-2578"><code>	v := binary.BigEndian.Uint32(payload[:4])</code></span>
<span class="codeline" id="line-2579"><code>	streamID := v &amp; 0x7fffffff // mask off high bit</code></span>
<span class="codeline" id="line-2580"><code>	return &amp;http2PriorityFrame{</code></span>
<span class="codeline" id="line-2581"><code>		http2FrameHeader: fh,</code></span>
<span class="codeline" id="line-2582"><code>		http2PriorityParam: http2PriorityParam{</code></span>
<span class="codeline" id="line-2583"><code>			Weight:    payload[4],</code></span>
<span class="codeline" id="line-2584"><code>			StreamDep: streamID,</code></span>
<span class="codeline" id="line-2585"><code>			Exclusive: streamID != v, // was high bit set?</code></span>
<span class="codeline" id="line-2586"><code>		},</code></span>
<span class="codeline" id="line-2587"><code>	}, nil</code></span>
<span class="codeline" id="line-2588"><code>}</code></span>
<span class="codeline" id="line-2589"><code></code></span>
<span class="codeline" id="line-2590"><code>// WritePriority writes a PRIORITY frame.</code></span>
<span class="codeline" id="line-2591"><code>//</code></span>
<span class="codeline" id="line-2592"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2593"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2594"><code>func (f *http2Framer) WritePriority(streamID uint32, p http2PriorityParam) error {</code></span>
<span class="codeline" id="line-2595"><code>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2596"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2597"><code>	}</code></span>
<span class="codeline" id="line-2598"><code>	if !http2validStreamIDOrZero(p.StreamDep) {</code></span>
<span class="codeline" id="line-2599"><code>		return http2errDepStreamID</code></span>
<span class="codeline" id="line-2600"><code>	}</code></span>
<span class="codeline" id="line-2601"><code>	f.startWrite(http2FramePriority, 0, streamID)</code></span>
<span class="codeline" id="line-2602"><code>	v := p.StreamDep</code></span>
<span class="codeline" id="line-2603"><code>	if p.Exclusive {</code></span>
<span class="codeline" id="line-2604"><code>		v |= 1 &lt;&lt; 31</code></span>
<span class="codeline" id="line-2605"><code>	}</code></span>
<span class="codeline" id="line-2606"><code>	f.writeUint32(v)</code></span>
<span class="codeline" id="line-2607"><code>	f.writeByte(p.Weight)</code></span>
<span class="codeline" id="line-2608"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2609"><code>}</code></span>
<span class="codeline" id="line-2610"><code></code></span>
<span class="codeline" id="line-2611"><code>// A RSTStreamFrame allows for abnormal termination of a stream.</code></span>
<span class="codeline" id="line-2612"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.4</code></span>
<span class="codeline" id="line-2613"><code>type http2RSTStreamFrame struct {</code></span>
<span class="codeline" id="line-2614"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2615"><code>	ErrCode http2ErrCode</code></span>
<span class="codeline" id="line-2616"><code>}</code></span>
<span class="codeline" id="line-2617"><code></code></span>
<span class="codeline" id="line-2618"><code>func http2parseRSTStreamFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2619"><code>	if len(p) != 4 {</code></span>
<span class="codeline" id="line-2620"><code>		countError("frame_rststream_bad_len")</code></span>
<span class="codeline" id="line-2621"><code>		return nil, http2ConnectionError(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-2622"><code>	}</code></span>
<span class="codeline" id="line-2623"><code>	if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2624"><code>		countError("frame_rststream_zero_stream")</code></span>
<span class="codeline" id="line-2625"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2626"><code>	}</code></span>
<span class="codeline" id="line-2627"><code>	return &amp;http2RSTStreamFrame{fh, http2ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil</code></span>
<span class="codeline" id="line-2628"><code>}</code></span>
<span class="codeline" id="line-2629"><code></code></span>
<span class="codeline" id="line-2630"><code>// WriteRSTStream writes a RST_STREAM frame.</code></span>
<span class="codeline" id="line-2631"><code>//</code></span>
<span class="codeline" id="line-2632"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2633"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2634"><code>func (f *http2Framer) WriteRSTStream(streamID uint32, code http2ErrCode) error {</code></span>
<span class="codeline" id="line-2635"><code>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2636"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2637"><code>	}</code></span>
<span class="codeline" id="line-2638"><code>	f.startWrite(http2FrameRSTStream, 0, streamID)</code></span>
<span class="codeline" id="line-2639"><code>	f.writeUint32(uint32(code))</code></span>
<span class="codeline" id="line-2640"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2641"><code>}</code></span>
<span class="codeline" id="line-2642"><code></code></span>
<span class="codeline" id="line-2643"><code>// A ContinuationFrame is used to continue a sequence of header block fragments.</code></span>
<span class="codeline" id="line-2644"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.10</code></span>
<span class="codeline" id="line-2645"><code>type http2ContinuationFrame struct {</code></span>
<span class="codeline" id="line-2646"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2647"><code>	headerFragBuf []byte</code></span>
<span class="codeline" id="line-2648"><code>}</code></span>
<span class="codeline" id="line-2649"><code></code></span>
<span class="codeline" id="line-2650"><code>func http2parseContinuationFrame(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2651"><code>	if fh.StreamID == 0 {</code></span>
<span class="codeline" id="line-2652"><code>		countError("frame_continuation_zero_stream")</code></span>
<span class="codeline" id="line-2653"><code>		return nil, http2connError{http2ErrCodeProtocol, "CONTINUATION frame with stream ID 0"}</code></span>
<span class="codeline" id="line-2654"><code>	}</code></span>
<span class="codeline" id="line-2655"><code>	return &amp;http2ContinuationFrame{fh, p}, nil</code></span>
<span class="codeline" id="line-2656"><code>}</code></span>
<span class="codeline" id="line-2657"><code></code></span>
<span class="codeline" id="line-2658"><code>func (f *http2ContinuationFrame) HeaderBlockFragment() []byte {</code></span>
<span class="codeline" id="line-2659"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2660"><code>	return f.headerFragBuf</code></span>
<span class="codeline" id="line-2661"><code>}</code></span>
<span class="codeline" id="line-2662"><code></code></span>
<span class="codeline" id="line-2663"><code>func (f *http2ContinuationFrame) HeadersEnded() bool {</code></span>
<span class="codeline" id="line-2664"><code>	return f.http2FrameHeader.Flags.Has(http2FlagContinuationEndHeaders)</code></span>
<span class="codeline" id="line-2665"><code>}</code></span>
<span class="codeline" id="line-2666"><code></code></span>
<span class="codeline" id="line-2667"><code>// WriteContinuation writes a CONTINUATION frame.</code></span>
<span class="codeline" id="line-2668"><code>//</code></span>
<span class="codeline" id="line-2669"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2670"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2671"><code>func (f *http2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error {</code></span>
<span class="codeline" id="line-2672"><code>	if !http2validStreamID(streamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2673"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2674"><code>	}</code></span>
<span class="codeline" id="line-2675"><code>	var flags http2Flags</code></span>
<span class="codeline" id="line-2676"><code>	if endHeaders {</code></span>
<span class="codeline" id="line-2677"><code>		flags |= http2FlagContinuationEndHeaders</code></span>
<span class="codeline" id="line-2678"><code>	}</code></span>
<span class="codeline" id="line-2679"><code>	f.startWrite(http2FrameContinuation, flags, streamID)</code></span>
<span class="codeline" id="line-2680"><code>	f.wbuf = append(f.wbuf, headerBlockFragment...)</code></span>
<span class="codeline" id="line-2681"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2682"><code>}</code></span>
<span class="codeline" id="line-2683"><code></code></span>
<span class="codeline" id="line-2684"><code>// A PushPromiseFrame is used to initiate a server stream.</code></span>
<span class="codeline" id="line-2685"><code>// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.6</code></span>
<span class="codeline" id="line-2686"><code>type http2PushPromiseFrame struct {</code></span>
<span class="codeline" id="line-2687"><code>	http2FrameHeader</code></span>
<span class="codeline" id="line-2688"><code>	PromiseID     uint32</code></span>
<span class="codeline" id="line-2689"><code>	headerFragBuf []byte // not owned</code></span>
<span class="codeline" id="line-2690"><code>}</code></span>
<span class="codeline" id="line-2691"><code></code></span>
<span class="codeline" id="line-2692"><code>func (f *http2PushPromiseFrame) HeaderBlockFragment() []byte {</code></span>
<span class="codeline" id="line-2693"><code>	f.checkValid()</code></span>
<span class="codeline" id="line-2694"><code>	return f.headerFragBuf</code></span>
<span class="codeline" id="line-2695"><code>}</code></span>
<span class="codeline" id="line-2696"><code></code></span>
<span class="codeline" id="line-2697"><code>func (f *http2PushPromiseFrame) HeadersEnded() bool {</code></span>
<span class="codeline" id="line-2698"><code>	return f.http2FrameHeader.Flags.Has(http2FlagPushPromiseEndHeaders)</code></span>
<span class="codeline" id="line-2699"><code>}</code></span>
<span class="codeline" id="line-2700"><code></code></span>
<span class="codeline" id="line-2701"><code>func http2parsePushPromise(_ *http2frameCache, fh http2FrameHeader, countError func(string), p []byte) (_ http2Frame, err error) {</code></span>
<span class="codeline" id="line-2702"><code>	pp := &amp;http2PushPromiseFrame{</code></span>
<span class="codeline" id="line-2703"><code>		http2FrameHeader: fh,</code></span>
<span class="codeline" id="line-2704"><code>	}</code></span>
<span class="codeline" id="line-2705"><code>	if pp.StreamID == 0 {</code></span>
<span class="codeline" id="line-2706"><code>		// PUSH_PROMISE frames MUST be associated with an existing,</code></span>
<span class="codeline" id="line-2707"><code>		// peer-initiated stream. The stream identifier of a</code></span>
<span class="codeline" id="line-2708"><code>		// PUSH_PROMISE frame indicates the stream it is associated</code></span>
<span class="codeline" id="line-2709"><code>		// with. If the stream identifier field specifies the value</code></span>
<span class="codeline" id="line-2710"><code>		// 0x0, a recipient MUST respond with a connection error</code></span>
<span class="codeline" id="line-2711"><code>		// (Section 5.4.1) of type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-2712"><code>		countError("frame_pushpromise_zero_stream")</code></span>
<span class="codeline" id="line-2713"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2714"><code>	}</code></span>
<span class="codeline" id="line-2715"><code>	// The PUSH_PROMISE frame includes optional padding.</code></span>
<span class="codeline" id="line-2716"><code>	// Padding fields and flags are identical to those defined for DATA frames</code></span>
<span class="codeline" id="line-2717"><code>	var padLength uint8</code></span>
<span class="codeline" id="line-2718"><code>	if fh.Flags.Has(http2FlagPushPromisePadded) {</code></span>
<span class="codeline" id="line-2719"><code>		if p, padLength, err = http2readByte(p); err != nil {</code></span>
<span class="codeline" id="line-2720"><code>			countError("frame_pushpromise_pad_short")</code></span>
<span class="codeline" id="line-2721"><code>			return</code></span>
<span class="codeline" id="line-2722"><code>		}</code></span>
<span class="codeline" id="line-2723"><code>	}</code></span>
<span class="codeline" id="line-2724"><code></code></span>
<span class="codeline" id="line-2725"><code>	p, pp.PromiseID, err = http2readUint32(p)</code></span>
<span class="codeline" id="line-2726"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2727"><code>		countError("frame_pushpromise_promiseid_short")</code></span>
<span class="codeline" id="line-2728"><code>		return</code></span>
<span class="codeline" id="line-2729"><code>	}</code></span>
<span class="codeline" id="line-2730"><code>	pp.PromiseID = pp.PromiseID &amp; (1&lt;&lt;31 - 1)</code></span>
<span class="codeline" id="line-2731"><code></code></span>
<span class="codeline" id="line-2732"><code>	if int(padLength) &gt; len(p) {</code></span>
<span class="codeline" id="line-2733"><code>		// like the DATA frame, error out if padding is longer than the body.</code></span>
<span class="codeline" id="line-2734"><code>		countError("frame_pushpromise_pad_too_big")</code></span>
<span class="codeline" id="line-2735"><code>		return nil, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-2736"><code>	}</code></span>
<span class="codeline" id="line-2737"><code>	pp.headerFragBuf = p[:len(p)-int(padLength)]</code></span>
<span class="codeline" id="line-2738"><code>	return pp, nil</code></span>
<span class="codeline" id="line-2739"><code>}</code></span>
<span class="codeline" id="line-2740"><code></code></span>
<span class="codeline" id="line-2741"><code>// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.</code></span>
<span class="codeline" id="line-2742"><code>type http2PushPromiseParam struct {</code></span>
<span class="codeline" id="line-2743"><code>	// StreamID is the required Stream ID to initiate.</code></span>
<span class="codeline" id="line-2744"><code>	StreamID uint32</code></span>
<span class="codeline" id="line-2745"><code></code></span>
<span class="codeline" id="line-2746"><code>	// PromiseID is the required Stream ID which this</code></span>
<span class="codeline" id="line-2747"><code>	// Push Promises</code></span>
<span class="codeline" id="line-2748"><code>	PromiseID uint32</code></span>
<span class="codeline" id="line-2749"><code></code></span>
<span class="codeline" id="line-2750"><code>	// BlockFragment is part (or all) of a Header Block.</code></span>
<span class="codeline" id="line-2751"><code>	BlockFragment []byte</code></span>
<span class="codeline" id="line-2752"><code></code></span>
<span class="codeline" id="line-2753"><code>	// EndHeaders indicates that this frame contains an entire</code></span>
<span class="codeline" id="line-2754"><code>	// header block and is not followed by any</code></span>
<span class="codeline" id="line-2755"><code>	// CONTINUATION frames.</code></span>
<span class="codeline" id="line-2756"><code>	EndHeaders bool</code></span>
<span class="codeline" id="line-2757"><code></code></span>
<span class="codeline" id="line-2758"><code>	// PadLength is the optional number of bytes of zeros to add</code></span>
<span class="codeline" id="line-2759"><code>	// to this frame.</code></span>
<span class="codeline" id="line-2760"><code>	PadLength uint8</code></span>
<span class="codeline" id="line-2761"><code>}</code></span>
<span class="codeline" id="line-2762"><code></code></span>
<span class="codeline" id="line-2763"><code>// WritePushPromise writes a single PushPromise Frame.</code></span>
<span class="codeline" id="line-2764"><code>//</code></span>
<span class="codeline" id="line-2765"><code>// As with Header Frames, This is the low level call for writing</code></span>
<span class="codeline" id="line-2766"><code>// individual frames. Continuation frames are handled elsewhere.</code></span>
<span class="codeline" id="line-2767"><code>//</code></span>
<span class="codeline" id="line-2768"><code>// It will perform exactly one Write to the underlying Writer.</code></span>
<span class="codeline" id="line-2769"><code>// It is the caller's responsibility to not call other Write methods concurrently.</code></span>
<span class="codeline" id="line-2770"><code>func (f *http2Framer) WritePushPromise(p http2PushPromiseParam) error {</code></span>
<span class="codeline" id="line-2771"><code>	if !http2validStreamID(p.StreamID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2772"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2773"><code>	}</code></span>
<span class="codeline" id="line-2774"><code>	var flags http2Flags</code></span>
<span class="codeline" id="line-2775"><code>	if p.PadLength != 0 {</code></span>
<span class="codeline" id="line-2776"><code>		flags |= http2FlagPushPromisePadded</code></span>
<span class="codeline" id="line-2777"><code>	}</code></span>
<span class="codeline" id="line-2778"><code>	if p.EndHeaders {</code></span>
<span class="codeline" id="line-2779"><code>		flags |= http2FlagPushPromiseEndHeaders</code></span>
<span class="codeline" id="line-2780"><code>	}</code></span>
<span class="codeline" id="line-2781"><code>	f.startWrite(http2FramePushPromise, flags, p.StreamID)</code></span>
<span class="codeline" id="line-2782"><code>	if p.PadLength != 0 {</code></span>
<span class="codeline" id="line-2783"><code>		f.writeByte(p.PadLength)</code></span>
<span class="codeline" id="line-2784"><code>	}</code></span>
<span class="codeline" id="line-2785"><code>	if !http2validStreamID(p.PromiseID) &amp;&amp; !f.AllowIllegalWrites {</code></span>
<span class="codeline" id="line-2786"><code>		return http2errStreamID</code></span>
<span class="codeline" id="line-2787"><code>	}</code></span>
<span class="codeline" id="line-2788"><code>	f.writeUint32(p.PromiseID)</code></span>
<span class="codeline" id="line-2789"><code>	f.wbuf = append(f.wbuf, p.BlockFragment...)</code></span>
<span class="codeline" id="line-2790"><code>	f.wbuf = append(f.wbuf, http2padZeros[:p.PadLength]...)</code></span>
<span class="codeline" id="line-2791"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2792"><code>}</code></span>
<span class="codeline" id="line-2793"><code></code></span>
<span class="codeline" id="line-2794"><code>// WriteRawFrame writes a raw frame. This can be used to write</code></span>
<span class="codeline" id="line-2795"><code>// extension frames unknown to this package.</code></span>
<span class="codeline" id="line-2796"><code>func (f *http2Framer) WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error {</code></span>
<span class="codeline" id="line-2797"><code>	f.startWrite(t, flags, streamID)</code></span>
<span class="codeline" id="line-2798"><code>	f.writeBytes(payload)</code></span>
<span class="codeline" id="line-2799"><code>	return f.endWrite()</code></span>
<span class="codeline" id="line-2800"><code>}</code></span>
<span class="codeline" id="line-2801"><code></code></span>
<span class="codeline" id="line-2802"><code>func http2readByte(p []byte) (remain []byte, b byte, err error) {</code></span>
<span class="codeline" id="line-2803"><code>	if len(p) == 0 {</code></span>
<span class="codeline" id="line-2804"><code>		return nil, 0, io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-2805"><code>	}</code></span>
<span class="codeline" id="line-2806"><code>	return p[1:], p[0], nil</code></span>
<span class="codeline" id="line-2807"><code>}</code></span>
<span class="codeline" id="line-2808"><code></code></span>
<span class="codeline" id="line-2809"><code>func http2readUint32(p []byte) (remain []byte, v uint32, err error) {</code></span>
<span class="codeline" id="line-2810"><code>	if len(p) &lt; 4 {</code></span>
<span class="codeline" id="line-2811"><code>		return nil, 0, io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-2812"><code>	}</code></span>
<span class="codeline" id="line-2813"><code>	return p[4:], binary.BigEndian.Uint32(p[:4]), nil</code></span>
<span class="codeline" id="line-2814"><code>}</code></span>
<span class="codeline" id="line-2815"><code></code></span>
<span class="codeline" id="line-2816"><code>type http2streamEnder interface {</code></span>
<span class="codeline" id="line-2817"><code>	StreamEnded() bool</code></span>
<span class="codeline" id="line-2818"><code>}</code></span>
<span class="codeline" id="line-2819"><code></code></span>
<span class="codeline" id="line-2820"><code>type http2headersEnder interface {</code></span>
<span class="codeline" id="line-2821"><code>	HeadersEnded() bool</code></span>
<span class="codeline" id="line-2822"><code>}</code></span>
<span class="codeline" id="line-2823"><code></code></span>
<span class="codeline" id="line-2824"><code>type http2headersOrContinuation interface {</code></span>
<span class="codeline" id="line-2825"><code>	http2headersEnder</code></span>
<span class="codeline" id="line-2826"><code>	HeaderBlockFragment() []byte</code></span>
<span class="codeline" id="line-2827"><code>}</code></span>
<span class="codeline" id="line-2828"><code></code></span>
<span class="codeline" id="line-2829"><code>// A MetaHeadersFrame is the representation of one HEADERS frame and</code></span>
<span class="codeline" id="line-2830"><code>// zero or more contiguous CONTINUATION frames and the decoding of</code></span>
<span class="codeline" id="line-2831"><code>// their HPACK-encoded contents.</code></span>
<span class="codeline" id="line-2832"><code>//</code></span>
<span class="codeline" id="line-2833"><code>// This type of frame does not appear on the wire and is only returned</code></span>
<span class="codeline" id="line-2834"><code>// by the Framer when Framer.ReadMetaHeaders is set.</code></span>
<span class="codeline" id="line-2835"><code>type http2MetaHeadersFrame struct {</code></span>
<span class="codeline" id="line-2836"><code>	*http2HeadersFrame</code></span>
<span class="codeline" id="line-2837"><code></code></span>
<span class="codeline" id="line-2838"><code>	// Fields are the fields contained in the HEADERS and</code></span>
<span class="codeline" id="line-2839"><code>	// CONTINUATION frames. The underlying slice is owned by the</code></span>
<span class="codeline" id="line-2840"><code>	// Framer and must not be retained after the next call to</code></span>
<span class="codeline" id="line-2841"><code>	// ReadFrame.</code></span>
<span class="codeline" id="line-2842"><code>	//</code></span>
<span class="codeline" id="line-2843"><code>	// Fields are guaranteed to be in the correct http2 order and</code></span>
<span class="codeline" id="line-2844"><code>	// not have unknown pseudo header fields or invalid header</code></span>
<span class="codeline" id="line-2845"><code>	// field names or values. Required pseudo header fields may be</code></span>
<span class="codeline" id="line-2846"><code>	// missing, however. Use the MetaHeadersFrame.Pseudo accessor</code></span>
<span class="codeline" id="line-2847"><code>	// method access pseudo headers.</code></span>
<span class="codeline" id="line-2848"><code>	Fields []hpack.HeaderField</code></span>
<span class="codeline" id="line-2849"><code></code></span>
<span class="codeline" id="line-2850"><code>	// Truncated is whether the max header list size limit was hit</code></span>
<span class="codeline" id="line-2851"><code>	// and Fields is incomplete. The hpack decoder state is still</code></span>
<span class="codeline" id="line-2852"><code>	// valid, however.</code></span>
<span class="codeline" id="line-2853"><code>	Truncated bool</code></span>
<span class="codeline" id="line-2854"><code>}</code></span>
<span class="codeline" id="line-2855"><code></code></span>
<span class="codeline" id="line-2856"><code>// PseudoValue returns the given pseudo header field's value.</code></span>
<span class="codeline" id="line-2857"><code>// The provided pseudo field should not contain the leading colon.</code></span>
<span class="codeline" id="line-2858"><code>func (mh *http2MetaHeadersFrame) PseudoValue(pseudo string) string {</code></span>
<span class="codeline" id="line-2859"><code>	for _, hf := range mh.Fields {</code></span>
<span class="codeline" id="line-2860"><code>		if !hf.IsPseudo() {</code></span>
<span class="codeline" id="line-2861"><code>			return ""</code></span>
<span class="codeline" id="line-2862"><code>		}</code></span>
<span class="codeline" id="line-2863"><code>		if hf.Name[1:] == pseudo {</code></span>
<span class="codeline" id="line-2864"><code>			return hf.Value</code></span>
<span class="codeline" id="line-2865"><code>		}</code></span>
<span class="codeline" id="line-2866"><code>	}</code></span>
<span class="codeline" id="line-2867"><code>	return ""</code></span>
<span class="codeline" id="line-2868"><code>}</code></span>
<span class="codeline" id="line-2869"><code></code></span>
<span class="codeline" id="line-2870"><code>// RegularFields returns the regular (non-pseudo) header fields of mh.</code></span>
<span class="codeline" id="line-2871"><code>// The caller does not own the returned slice.</code></span>
<span class="codeline" id="line-2872"><code>func (mh *http2MetaHeadersFrame) RegularFields() []hpack.HeaderField {</code></span>
<span class="codeline" id="line-2873"><code>	for i, hf := range mh.Fields {</code></span>
<span class="codeline" id="line-2874"><code>		if !hf.IsPseudo() {</code></span>
<span class="codeline" id="line-2875"><code>			return mh.Fields[i:]</code></span>
<span class="codeline" id="line-2876"><code>		}</code></span>
<span class="codeline" id="line-2877"><code>	}</code></span>
<span class="codeline" id="line-2878"><code>	return nil</code></span>
<span class="codeline" id="line-2879"><code>}</code></span>
<span class="codeline" id="line-2880"><code></code></span>
<span class="codeline" id="line-2881"><code>// PseudoFields returns the pseudo header fields of mh.</code></span>
<span class="codeline" id="line-2882"><code>// The caller does not own the returned slice.</code></span>
<span class="codeline" id="line-2883"><code>func (mh *http2MetaHeadersFrame) PseudoFields() []hpack.HeaderField {</code></span>
<span class="codeline" id="line-2884"><code>	for i, hf := range mh.Fields {</code></span>
<span class="codeline" id="line-2885"><code>		if !hf.IsPseudo() {</code></span>
<span class="codeline" id="line-2886"><code>			return mh.Fields[:i]</code></span>
<span class="codeline" id="line-2887"><code>		}</code></span>
<span class="codeline" id="line-2888"><code>	}</code></span>
<span class="codeline" id="line-2889"><code>	return mh.Fields</code></span>
<span class="codeline" id="line-2890"><code>}</code></span>
<span class="codeline" id="line-2891"><code></code></span>
<span class="codeline" id="line-2892"><code>func (mh *http2MetaHeadersFrame) checkPseudos() error {</code></span>
<span class="codeline" id="line-2893"><code>	var isRequest, isResponse bool</code></span>
<span class="codeline" id="line-2894"><code>	pf := mh.PseudoFields()</code></span>
<span class="codeline" id="line-2895"><code>	for i, hf := range pf {</code></span>
<span class="codeline" id="line-2896"><code>		switch hf.Name {</code></span>
<span class="codeline" id="line-2897"><code>		case ":method", ":path", ":scheme", ":authority":</code></span>
<span class="codeline" id="line-2898"><code>			isRequest = true</code></span>
<span class="codeline" id="line-2899"><code>		case ":status":</code></span>
<span class="codeline" id="line-2900"><code>			isResponse = true</code></span>
<span class="codeline" id="line-2901"><code>		default:</code></span>
<span class="codeline" id="line-2902"><code>			return http2pseudoHeaderError(hf.Name)</code></span>
<span class="codeline" id="line-2903"><code>		}</code></span>
<span class="codeline" id="line-2904"><code>		// Check for duplicates.</code></span>
<span class="codeline" id="line-2905"><code>		// This would be a bad algorithm, but N is 4.</code></span>
<span class="codeline" id="line-2906"><code>		// And this doesn't allocate.</code></span>
<span class="codeline" id="line-2907"><code>		for _, hf2 := range pf[:i] {</code></span>
<span class="codeline" id="line-2908"><code>			if hf.Name == hf2.Name {</code></span>
<span class="codeline" id="line-2909"><code>				return http2duplicatePseudoHeaderError(hf.Name)</code></span>
<span class="codeline" id="line-2910"><code>			}</code></span>
<span class="codeline" id="line-2911"><code>		}</code></span>
<span class="codeline" id="line-2912"><code>	}</code></span>
<span class="codeline" id="line-2913"><code>	if isRequest &amp;&amp; isResponse {</code></span>
<span class="codeline" id="line-2914"><code>		return http2errMixPseudoHeaderTypes</code></span>
<span class="codeline" id="line-2915"><code>	}</code></span>
<span class="codeline" id="line-2916"><code>	return nil</code></span>
<span class="codeline" id="line-2917"><code>}</code></span>
<span class="codeline" id="line-2918"><code></code></span>
<span class="codeline" id="line-2919"><code>func (fr *http2Framer) maxHeaderStringLen() int {</code></span>
<span class="codeline" id="line-2920"><code>	v := fr.maxHeaderListSize()</code></span>
<span class="codeline" id="line-2921"><code>	if uint32(int(v)) == v {</code></span>
<span class="codeline" id="line-2922"><code>		return int(v)</code></span>
<span class="codeline" id="line-2923"><code>	}</code></span>
<span class="codeline" id="line-2924"><code>	// They had a crazy big number for MaxHeaderBytes anyway,</code></span>
<span class="codeline" id="line-2925"><code>	// so give them unlimited header lengths:</code></span>
<span class="codeline" id="line-2926"><code>	return 0</code></span>
<span class="codeline" id="line-2927"><code>}</code></span>
<span class="codeline" id="line-2928"><code></code></span>
<span class="codeline" id="line-2929"><code>// readMetaFrame returns 0 or more CONTINUATION frames from fr and</code></span>
<span class="codeline" id="line-2930"><code>// merge them into the provided hf and returns a MetaHeadersFrame</code></span>
<span class="codeline" id="line-2931"><code>// with the decoded hpack values.</code></span>
<span class="codeline" id="line-2932"><code>func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (http2Frame, error) {</code></span>
<span class="codeline" id="line-2933"><code>	if fr.AllowIllegalReads {</code></span>
<span class="codeline" id="line-2934"><code>		return nil, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders")</code></span>
<span class="codeline" id="line-2935"><code>	}</code></span>
<span class="codeline" id="line-2936"><code>	mh := &amp;http2MetaHeadersFrame{</code></span>
<span class="codeline" id="line-2937"><code>		http2HeadersFrame: hf,</code></span>
<span class="codeline" id="line-2938"><code>	}</code></span>
<span class="codeline" id="line-2939"><code>	var remainSize = fr.maxHeaderListSize()</code></span>
<span class="codeline" id="line-2940"><code>	var sawRegular bool</code></span>
<span class="codeline" id="line-2941"><code></code></span>
<span class="codeline" id="line-2942"><code>	var invalid error // pseudo header field errors</code></span>
<span class="codeline" id="line-2943"><code>	hdec := fr.ReadMetaHeaders</code></span>
<span class="codeline" id="line-2944"><code>	hdec.SetEmitEnabled(true)</code></span>
<span class="codeline" id="line-2945"><code>	hdec.SetMaxStringLength(fr.maxHeaderStringLen())</code></span>
<span class="codeline" id="line-2946"><code>	hdec.SetEmitFunc(func(hf hpack.HeaderField) {</code></span>
<span class="codeline" id="line-2947"><code>		if http2VerboseLogs &amp;&amp; fr.logReads {</code></span>
<span class="codeline" id="line-2948"><code>			fr.debugReadLoggerf("http2: decoded hpack field %+v", hf)</code></span>
<span class="codeline" id="line-2949"><code>		}</code></span>
<span class="codeline" id="line-2950"><code>		if !httpguts.ValidHeaderFieldValue(hf.Value) {</code></span>
<span class="codeline" id="line-2951"><code>			// Don't include the value in the error, because it may be sensitive.</code></span>
<span class="codeline" id="line-2952"><code>			invalid = http2headerFieldValueError(hf.Name)</code></span>
<span class="codeline" id="line-2953"><code>		}</code></span>
<span class="codeline" id="line-2954"><code>		isPseudo := strings.HasPrefix(hf.Name, ":")</code></span>
<span class="codeline" id="line-2955"><code>		if isPseudo {</code></span>
<span class="codeline" id="line-2956"><code>			if sawRegular {</code></span>
<span class="codeline" id="line-2957"><code>				invalid = http2errPseudoAfterRegular</code></span>
<span class="codeline" id="line-2958"><code>			}</code></span>
<span class="codeline" id="line-2959"><code>		} else {</code></span>
<span class="codeline" id="line-2960"><code>			sawRegular = true</code></span>
<span class="codeline" id="line-2961"><code>			if !http2validWireHeaderFieldName(hf.Name) {</code></span>
<span class="codeline" id="line-2962"><code>				invalid = http2headerFieldNameError(hf.Name)</code></span>
<span class="codeline" id="line-2963"><code>			}</code></span>
<span class="codeline" id="line-2964"><code>		}</code></span>
<span class="codeline" id="line-2965"><code></code></span>
<span class="codeline" id="line-2966"><code>		if invalid != nil {</code></span>
<span class="codeline" id="line-2967"><code>			hdec.SetEmitEnabled(false)</code></span>
<span class="codeline" id="line-2968"><code>			return</code></span>
<span class="codeline" id="line-2969"><code>		}</code></span>
<span class="codeline" id="line-2970"><code></code></span>
<span class="codeline" id="line-2971"><code>		size := hf.Size()</code></span>
<span class="codeline" id="line-2972"><code>		if size &gt; remainSize {</code></span>
<span class="codeline" id="line-2973"><code>			hdec.SetEmitEnabled(false)</code></span>
<span class="codeline" id="line-2974"><code>			mh.Truncated = true</code></span>
<span class="codeline" id="line-2975"><code>			remainSize = 0</code></span>
<span class="codeline" id="line-2976"><code>			return</code></span>
<span class="codeline" id="line-2977"><code>		}</code></span>
<span class="codeline" id="line-2978"><code>		remainSize -= size</code></span>
<span class="codeline" id="line-2979"><code></code></span>
<span class="codeline" id="line-2980"><code>		mh.Fields = append(mh.Fields, hf)</code></span>
<span class="codeline" id="line-2981"><code>	})</code></span>
<span class="codeline" id="line-2982"><code>	// Lose reference to MetaHeadersFrame:</code></span>
<span class="codeline" id="line-2983"><code>	defer hdec.SetEmitFunc(func(hf hpack.HeaderField) {})</code></span>
<span class="codeline" id="line-2984"><code></code></span>
<span class="codeline" id="line-2985"><code>	var hc http2headersOrContinuation = hf</code></span>
<span class="codeline" id="line-2986"><code>	for {</code></span>
<span class="codeline" id="line-2987"><code>		frag := hc.HeaderBlockFragment()</code></span>
<span class="codeline" id="line-2988"><code></code></span>
<span class="codeline" id="line-2989"><code>		// Avoid parsing large amounts of headers that we will then discard.</code></span>
<span class="codeline" id="line-2990"><code>		// If the sender exceeds the max header list size by too much,</code></span>
<span class="codeline" id="line-2991"><code>		// skip parsing the fragment and close the connection.</code></span>
<span class="codeline" id="line-2992"><code>		//</code></span>
<span class="codeline" id="line-2993"><code>		// "Too much" is either any CONTINUATION frame after we've already</code></span>
<span class="codeline" id="line-2994"><code>		// exceeded the max header list size (in which case remainSize is 0),</code></span>
<span class="codeline" id="line-2995"><code>		// or a frame whose encoded size is more than twice the remaining</code></span>
<span class="codeline" id="line-2996"><code>		// header list bytes we're willing to accept.</code></span>
<span class="codeline" id="line-2997"><code>		if int64(len(frag)) &gt; int64(2*remainSize) {</code></span>
<span class="codeline" id="line-2998"><code>			if http2VerboseLogs {</code></span>
<span class="codeline" id="line-2999"><code>				log.Printf("http2: header list too large")</code></span>
<span class="codeline" id="line-3000"><code>			}</code></span>
<span class="codeline" id="line-3001"><code>			// It would be nice to send a RST_STREAM before sending the GOAWAY,</code></span>
<span class="codeline" id="line-3002"><code>			// but the structure of the server's frame writer makes this difficult.</code></span>
<span class="codeline" id="line-3003"><code>			return mh, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-3004"><code>		}</code></span>
<span class="codeline" id="line-3005"><code></code></span>
<span class="codeline" id="line-3006"><code>		// Also close the connection after any CONTINUATION frame following an</code></span>
<span class="codeline" id="line-3007"><code>		// invalid header, since we stop tracking the size of the headers after</code></span>
<span class="codeline" id="line-3008"><code>		// an invalid one.</code></span>
<span class="codeline" id="line-3009"><code>		if invalid != nil {</code></span>
<span class="codeline" id="line-3010"><code>			if http2VerboseLogs {</code></span>
<span class="codeline" id="line-3011"><code>				log.Printf("http2: invalid header: %v", invalid)</code></span>
<span class="codeline" id="line-3012"><code>			}</code></span>
<span class="codeline" id="line-3013"><code>			// It would be nice to send a RST_STREAM before sending the GOAWAY,</code></span>
<span class="codeline" id="line-3014"><code>			// but the structure of the server's frame writer makes this difficult.</code></span>
<span class="codeline" id="line-3015"><code>			return mh, http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-3016"><code>		}</code></span>
<span class="codeline" id="line-3017"><code></code></span>
<span class="codeline" id="line-3018"><code>		if _, err := hdec.Write(frag); err != nil {</code></span>
<span class="codeline" id="line-3019"><code>			return mh, http2ConnectionError(http2ErrCodeCompression)</code></span>
<span class="codeline" id="line-3020"><code>		}</code></span>
<span class="codeline" id="line-3021"><code></code></span>
<span class="codeline" id="line-3022"><code>		if hc.HeadersEnded() {</code></span>
<span class="codeline" id="line-3023"><code>			break</code></span>
<span class="codeline" id="line-3024"><code>		}</code></span>
<span class="codeline" id="line-3025"><code>		if f, err := fr.ReadFrame(); err != nil {</code></span>
<span class="codeline" id="line-3026"><code>			return nil, err</code></span>
<span class="codeline" id="line-3027"><code>		} else {</code></span>
<span class="codeline" id="line-3028"><code>			hc = f.(*http2ContinuationFrame) // guaranteed by checkFrameOrder</code></span>
<span class="codeline" id="line-3029"><code>		}</code></span>
<span class="codeline" id="line-3030"><code>	}</code></span>
<span class="codeline" id="line-3031"><code></code></span>
<span class="codeline" id="line-3032"><code>	mh.http2HeadersFrame.headerFragBuf = nil</code></span>
<span class="codeline" id="line-3033"><code>	mh.http2HeadersFrame.invalidate()</code></span>
<span class="codeline" id="line-3034"><code></code></span>
<span class="codeline" id="line-3035"><code>	if err := hdec.Close(); err != nil {</code></span>
<span class="codeline" id="line-3036"><code>		return mh, http2ConnectionError(http2ErrCodeCompression)</code></span>
<span class="codeline" id="line-3037"><code>	}</code></span>
<span class="codeline" id="line-3038"><code>	if invalid != nil {</code></span>
<span class="codeline" id="line-3039"><code>		fr.errDetail = invalid</code></span>
<span class="codeline" id="line-3040"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-3041"><code>			log.Printf("http2: invalid header: %v", invalid)</code></span>
<span class="codeline" id="line-3042"><code>		}</code></span>
<span class="codeline" id="line-3043"><code>		return nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, invalid}</code></span>
<span class="codeline" id="line-3044"><code>	}</code></span>
<span class="codeline" id="line-3045"><code>	if err := mh.checkPseudos(); err != nil {</code></span>
<span class="codeline" id="line-3046"><code>		fr.errDetail = err</code></span>
<span class="codeline" id="line-3047"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-3048"><code>			log.Printf("http2: invalid pseudo headers: %v", err)</code></span>
<span class="codeline" id="line-3049"><code>		}</code></span>
<span class="codeline" id="line-3050"><code>		return nil, http2StreamError{mh.StreamID, http2ErrCodeProtocol, err}</code></span>
<span class="codeline" id="line-3051"><code>	}</code></span>
<span class="codeline" id="line-3052"><code>	return mh, nil</code></span>
<span class="codeline" id="line-3053"><code>}</code></span>
<span class="codeline" id="line-3054"><code></code></span>
<span class="codeline" id="line-3055"><code>func http2summarizeFrame(f http2Frame) string {</code></span>
<span class="codeline" id="line-3056"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-3057"><code>	f.Header().writeDebug(&amp;buf)</code></span>
<span class="codeline" id="line-3058"><code>	switch f := f.(type) {</code></span>
<span class="codeline" id="line-3059"><code>	case *http2SettingsFrame:</code></span>
<span class="codeline" id="line-3060"><code>		n := 0</code></span>
<span class="codeline" id="line-3061"><code>		f.ForeachSetting(func(s http2Setting) error {</code></span>
<span class="codeline" id="line-3062"><code>			n++</code></span>
<span class="codeline" id="line-3063"><code>			if n == 1 {</code></span>
<span class="codeline" id="line-3064"><code>				buf.WriteString(", settings:")</code></span>
<span class="codeline" id="line-3065"><code>			}</code></span>
<span class="codeline" id="line-3066"><code>			fmt.Fprintf(&amp;buf, " %v=%v,", s.ID, s.Val)</code></span>
<span class="codeline" id="line-3067"><code>			return nil</code></span>
<span class="codeline" id="line-3068"><code>		})</code></span>
<span class="codeline" id="line-3069"><code>		if n &gt; 0 {</code></span>
<span class="codeline" id="line-3070"><code>			buf.Truncate(buf.Len() - 1) // remove trailing comma</code></span>
<span class="codeline" id="line-3071"><code>		}</code></span>
<span class="codeline" id="line-3072"><code>	case *http2DataFrame:</code></span>
<span class="codeline" id="line-3073"><code>		data := f.Data()</code></span>
<span class="codeline" id="line-3074"><code>		const max = 256</code></span>
<span class="codeline" id="line-3075"><code>		if len(data) &gt; max {</code></span>
<span class="codeline" id="line-3076"><code>			data = data[:max]</code></span>
<span class="codeline" id="line-3077"><code>		}</code></span>
<span class="codeline" id="line-3078"><code>		fmt.Fprintf(&amp;buf, " data=%q", data)</code></span>
<span class="codeline" id="line-3079"><code>		if len(f.Data()) &gt; max {</code></span>
<span class="codeline" id="line-3080"><code>			fmt.Fprintf(&amp;buf, " (%d bytes omitted)", len(f.Data())-max)</code></span>
<span class="codeline" id="line-3081"><code>		}</code></span>
<span class="codeline" id="line-3082"><code>	case *http2WindowUpdateFrame:</code></span>
<span class="codeline" id="line-3083"><code>		if f.StreamID == 0 {</code></span>
<span class="codeline" id="line-3084"><code>			buf.WriteString(" (conn)")</code></span>
<span class="codeline" id="line-3085"><code>		}</code></span>
<span class="codeline" id="line-3086"><code>		fmt.Fprintf(&amp;buf, " incr=%v", f.Increment)</code></span>
<span class="codeline" id="line-3087"><code>	case *http2PingFrame:</code></span>
<span class="codeline" id="line-3088"><code>		fmt.Fprintf(&amp;buf, " ping=%q", f.Data[:])</code></span>
<span class="codeline" id="line-3089"><code>	case *http2GoAwayFrame:</code></span>
<span class="codeline" id="line-3090"><code>		fmt.Fprintf(&amp;buf, " LastStreamID=%v ErrCode=%v Debug=%q",</code></span>
<span class="codeline" id="line-3091"><code>			f.LastStreamID, f.ErrCode, f.debugData)</code></span>
<span class="codeline" id="line-3092"><code>	case *http2RSTStreamFrame:</code></span>
<span class="codeline" id="line-3093"><code>		fmt.Fprintf(&amp;buf, " ErrCode=%v", f.ErrCode)</code></span>
<span class="codeline" id="line-3094"><code>	}</code></span>
<span class="codeline" id="line-3095"><code>	return buf.String()</code></span>
<span class="codeline" id="line-3096"><code>}</code></span>
<span class="codeline" id="line-3097"><code></code></span>
<span class="codeline" id="line-3098"><code>var http2DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1"</code></span>
<span class="codeline" id="line-3099"><code></code></span>
<span class="codeline" id="line-3100"><code>type http2goroutineLock uint64</code></span>
<span class="codeline" id="line-3101"><code></code></span>
<span class="codeline" id="line-3102"><code>func http2newGoroutineLock() http2goroutineLock {</code></span>
<span class="codeline" id="line-3103"><code>	if !http2DebugGoroutines {</code></span>
<span class="codeline" id="line-3104"><code>		return 0</code></span>
<span class="codeline" id="line-3105"><code>	}</code></span>
<span class="codeline" id="line-3106"><code>	return http2goroutineLock(http2curGoroutineID())</code></span>
<span class="codeline" id="line-3107"><code>}</code></span>
<span class="codeline" id="line-3108"><code></code></span>
<span class="codeline" id="line-3109"><code>func (g http2goroutineLock) check() {</code></span>
<span class="codeline" id="line-3110"><code>	if !http2DebugGoroutines {</code></span>
<span class="codeline" id="line-3111"><code>		return</code></span>
<span class="codeline" id="line-3112"><code>	}</code></span>
<span class="codeline" id="line-3113"><code>	if http2curGoroutineID() != uint64(g) {</code></span>
<span class="codeline" id="line-3114"><code>		panic("running on the wrong goroutine")</code></span>
<span class="codeline" id="line-3115"><code>	}</code></span>
<span class="codeline" id="line-3116"><code>}</code></span>
<span class="codeline" id="line-3117"><code></code></span>
<span class="codeline" id="line-3118"><code>func (g http2goroutineLock) checkNotOn() {</code></span>
<span class="codeline" id="line-3119"><code>	if !http2DebugGoroutines {</code></span>
<span class="codeline" id="line-3120"><code>		return</code></span>
<span class="codeline" id="line-3121"><code>	}</code></span>
<span class="codeline" id="line-3122"><code>	if http2curGoroutineID() == uint64(g) {</code></span>
<span class="codeline" id="line-3123"><code>		panic("running on the wrong goroutine")</code></span>
<span class="codeline" id="line-3124"><code>	}</code></span>
<span class="codeline" id="line-3125"><code>}</code></span>
<span class="codeline" id="line-3126"><code></code></span>
<span class="codeline" id="line-3127"><code>var http2goroutineSpace = []byte("goroutine ")</code></span>
<span class="codeline" id="line-3128"><code></code></span>
<span class="codeline" id="line-3129"><code>func http2curGoroutineID() uint64 {</code></span>
<span class="codeline" id="line-3130"><code>	bp := http2littleBuf.Get().(*[]byte)</code></span>
<span class="codeline" id="line-3131"><code>	defer http2littleBuf.Put(bp)</code></span>
<span class="codeline" id="line-3132"><code>	b := *bp</code></span>
<span class="codeline" id="line-3133"><code>	b = b[:runtime.Stack(b, false)]</code></span>
<span class="codeline" id="line-3134"><code>	// Parse the 4707 out of "goroutine 4707 ["</code></span>
<span class="codeline" id="line-3135"><code>	b = bytes.TrimPrefix(b, http2goroutineSpace)</code></span>
<span class="codeline" id="line-3136"><code>	i := bytes.IndexByte(b, ' ')</code></span>
<span class="codeline" id="line-3137"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-3138"><code>		panic(fmt.Sprintf("No space found in %q", b))</code></span>
<span class="codeline" id="line-3139"><code>	}</code></span>
<span class="codeline" id="line-3140"><code>	b = b[:i]</code></span>
<span class="codeline" id="line-3141"><code>	n, err := http2parseUintBytes(b, 10, 64)</code></span>
<span class="codeline" id="line-3142"><code>	if err != nil {</code></span>
<span class="codeline" id="line-3143"><code>		panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err))</code></span>
<span class="codeline" id="line-3144"><code>	}</code></span>
<span class="codeline" id="line-3145"><code>	return n</code></span>
<span class="codeline" id="line-3146"><code>}</code></span>
<span class="codeline" id="line-3147"><code></code></span>
<span class="codeline" id="line-3148"><code>var http2littleBuf = sync.Pool{</code></span>
<span class="codeline" id="line-3149"><code>	New: func() interface{} {</code></span>
<span class="codeline" id="line-3150"><code>		buf := make([]byte, 64)</code></span>
<span class="codeline" id="line-3151"><code>		return &amp;buf</code></span>
<span class="codeline" id="line-3152"><code>	},</code></span>
<span class="codeline" id="line-3153"><code>}</code></span>
<span class="codeline" id="line-3154"><code></code></span>
<span class="codeline" id="line-3155"><code>// parseUintBytes is like strconv.ParseUint, but using a []byte.</code></span>
<span class="codeline" id="line-3156"><code>func http2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error) {</code></span>
<span class="codeline" id="line-3157"><code>	var cutoff, maxVal uint64</code></span>
<span class="codeline" id="line-3158"><code></code></span>
<span class="codeline" id="line-3159"><code>	if bitSize == 0 {</code></span>
<span class="codeline" id="line-3160"><code>		bitSize = int(strconv.IntSize)</code></span>
<span class="codeline" id="line-3161"><code>	}</code></span>
<span class="codeline" id="line-3162"><code></code></span>
<span class="codeline" id="line-3163"><code>	s0 := s</code></span>
<span class="codeline" id="line-3164"><code>	switch {</code></span>
<span class="codeline" id="line-3165"><code>	case len(s) &lt; 1:</code></span>
<span class="codeline" id="line-3166"><code>		err = strconv.ErrSyntax</code></span>
<span class="codeline" id="line-3167"><code>		goto Error</code></span>
<span class="codeline" id="line-3168"><code></code></span>
<span class="codeline" id="line-3169"><code>	case 2 &lt;= base &amp;&amp; base &lt;= 36:</code></span>
<span class="codeline" id="line-3170"><code>		// valid base; nothing to do</code></span>
<span class="codeline" id="line-3171"><code></code></span>
<span class="codeline" id="line-3172"><code>	case base == 0:</code></span>
<span class="codeline" id="line-3173"><code>		// Look for octal, hex prefix.</code></span>
<span class="codeline" id="line-3174"><code>		switch {</code></span>
<span class="codeline" id="line-3175"><code>		case s[0] == '0' &amp;&amp; len(s) &gt; 1 &amp;&amp; (s[1] == 'x' || s[1] == 'X'):</code></span>
<span class="codeline" id="line-3176"><code>			base = 16</code></span>
<span class="codeline" id="line-3177"><code>			s = s[2:]</code></span>
<span class="codeline" id="line-3178"><code>			if len(s) &lt; 1 {</code></span>
<span class="codeline" id="line-3179"><code>				err = strconv.ErrSyntax</code></span>
<span class="codeline" id="line-3180"><code>				goto Error</code></span>
<span class="codeline" id="line-3181"><code>			}</code></span>
<span class="codeline" id="line-3182"><code>		case s[0] == '0':</code></span>
<span class="codeline" id="line-3183"><code>			base = 8</code></span>
<span class="codeline" id="line-3184"><code>		default:</code></span>
<span class="codeline" id="line-3185"><code>			base = 10</code></span>
<span class="codeline" id="line-3186"><code>		}</code></span>
<span class="codeline" id="line-3187"><code></code></span>
<span class="codeline" id="line-3188"><code>	default:</code></span>
<span class="codeline" id="line-3189"><code>		err = errors.New("invalid base " + strconv.Itoa(base))</code></span>
<span class="codeline" id="line-3190"><code>		goto Error</code></span>
<span class="codeline" id="line-3191"><code>	}</code></span>
<span class="codeline" id="line-3192"><code></code></span>
<span class="codeline" id="line-3193"><code>	n = 0</code></span>
<span class="codeline" id="line-3194"><code>	cutoff = http2cutoff64(base)</code></span>
<span class="codeline" id="line-3195"><code>	maxVal = 1&lt;&lt;uint(bitSize) - 1</code></span>
<span class="codeline" id="line-3196"><code></code></span>
<span class="codeline" id="line-3197"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-3198"><code>		var v byte</code></span>
<span class="codeline" id="line-3199"><code>		d := s[i]</code></span>
<span class="codeline" id="line-3200"><code>		switch {</code></span>
<span class="codeline" id="line-3201"><code>		case '0' &lt;= d &amp;&amp; d &lt;= '9':</code></span>
<span class="codeline" id="line-3202"><code>			v = d - '0'</code></span>
<span class="codeline" id="line-3203"><code>		case 'a' &lt;= d &amp;&amp; d &lt;= 'z':</code></span>
<span class="codeline" id="line-3204"><code>			v = d - 'a' + 10</code></span>
<span class="codeline" id="line-3205"><code>		case 'A' &lt;= d &amp;&amp; d &lt;= 'Z':</code></span>
<span class="codeline" id="line-3206"><code>			v = d - 'A' + 10</code></span>
<span class="codeline" id="line-3207"><code>		default:</code></span>
<span class="codeline" id="line-3208"><code>			n = 0</code></span>
<span class="codeline" id="line-3209"><code>			err = strconv.ErrSyntax</code></span>
<span class="codeline" id="line-3210"><code>			goto Error</code></span>
<span class="codeline" id="line-3211"><code>		}</code></span>
<span class="codeline" id="line-3212"><code>		if int(v) &gt;= base {</code></span>
<span class="codeline" id="line-3213"><code>			n = 0</code></span>
<span class="codeline" id="line-3214"><code>			err = strconv.ErrSyntax</code></span>
<span class="codeline" id="line-3215"><code>			goto Error</code></span>
<span class="codeline" id="line-3216"><code>		}</code></span>
<span class="codeline" id="line-3217"><code></code></span>
<span class="codeline" id="line-3218"><code>		if n &gt;= cutoff {</code></span>
<span class="codeline" id="line-3219"><code>			// n*base overflows</code></span>
<span class="codeline" id="line-3220"><code>			n = 1&lt;&lt;64 - 1</code></span>
<span class="codeline" id="line-3221"><code>			err = strconv.ErrRange</code></span>
<span class="codeline" id="line-3222"><code>			goto Error</code></span>
<span class="codeline" id="line-3223"><code>		}</code></span>
<span class="codeline" id="line-3224"><code>		n *= uint64(base)</code></span>
<span class="codeline" id="line-3225"><code></code></span>
<span class="codeline" id="line-3226"><code>		n1 := n + uint64(v)</code></span>
<span class="codeline" id="line-3227"><code>		if n1 &lt; n || n1 &gt; maxVal {</code></span>
<span class="codeline" id="line-3228"><code>			// n+v overflows</code></span>
<span class="codeline" id="line-3229"><code>			n = 1&lt;&lt;64 - 1</code></span>
<span class="codeline" id="line-3230"><code>			err = strconv.ErrRange</code></span>
<span class="codeline" id="line-3231"><code>			goto Error</code></span>
<span class="codeline" id="line-3232"><code>		}</code></span>
<span class="codeline" id="line-3233"><code>		n = n1</code></span>
<span class="codeline" id="line-3234"><code>	}</code></span>
<span class="codeline" id="line-3235"><code></code></span>
<span class="codeline" id="line-3236"><code>	return n, nil</code></span>
<span class="codeline" id="line-3237"><code></code></span>
<span class="codeline" id="line-3238"><code>Error:</code></span>
<span class="codeline" id="line-3239"><code>	return n, &amp;strconv.NumError{Func: "ParseUint", Num: string(s0), Err: err}</code></span>
<span class="codeline" id="line-3240"><code>}</code></span>
<span class="codeline" id="line-3241"><code></code></span>
<span class="codeline" id="line-3242"><code>// Return the first number n such that n*base &gt;= 1&lt;&lt;64.</code></span>
<span class="codeline" id="line-3243"><code>func http2cutoff64(base int) uint64 {</code></span>
<span class="codeline" id="line-3244"><code>	if base &lt; 2 {</code></span>
<span class="codeline" id="line-3245"><code>		return 0</code></span>
<span class="codeline" id="line-3246"><code>	}</code></span>
<span class="codeline" id="line-3247"><code>	return (1&lt;&lt;64-1)/uint64(base) + 1</code></span>
<span class="codeline" id="line-3248"><code>}</code></span>
<span class="codeline" id="line-3249"><code></code></span>
<span class="codeline" id="line-3250"><code>var (</code></span>
<span class="codeline" id="line-3251"><code>	http2commonBuildOnce   sync.Once</code></span>
<span class="codeline" id="line-3252"><code>	http2commonLowerHeader map[string]string // Go-Canonical-Case -&gt; lower-case</code></span>
<span class="codeline" id="line-3253"><code>	http2commonCanonHeader map[string]string // lower-case -&gt; Go-Canonical-Case</code></span>
<span class="codeline" id="line-3254"><code>)</code></span>
<span class="codeline" id="line-3255"><code></code></span>
<span class="codeline" id="line-3256"><code>func http2buildCommonHeaderMapsOnce() {</code></span>
<span class="codeline" id="line-3257"><code>	http2commonBuildOnce.Do(http2buildCommonHeaderMaps)</code></span>
<span class="codeline" id="line-3258"><code>}</code></span>
<span class="codeline" id="line-3259"><code></code></span>
<span class="codeline" id="line-3260"><code>func http2buildCommonHeaderMaps() {</code></span>
<span class="codeline" id="line-3261"><code>	common := []string{</code></span>
<span class="codeline" id="line-3262"><code>		"accept",</code></span>
<span class="codeline" id="line-3263"><code>		"accept-charset",</code></span>
<span class="codeline" id="line-3264"><code>		"accept-encoding",</code></span>
<span class="codeline" id="line-3265"><code>		"accept-language",</code></span>
<span class="codeline" id="line-3266"><code>		"accept-ranges",</code></span>
<span class="codeline" id="line-3267"><code>		"age",</code></span>
<span class="codeline" id="line-3268"><code>		"access-control-allow-credentials",</code></span>
<span class="codeline" id="line-3269"><code>		"access-control-allow-headers",</code></span>
<span class="codeline" id="line-3270"><code>		"access-control-allow-methods",</code></span>
<span class="codeline" id="line-3271"><code>		"access-control-allow-origin",</code></span>
<span class="codeline" id="line-3272"><code>		"access-control-expose-headers",</code></span>
<span class="codeline" id="line-3273"><code>		"access-control-max-age",</code></span>
<span class="codeline" id="line-3274"><code>		"access-control-request-headers",</code></span>
<span class="codeline" id="line-3275"><code>		"access-control-request-method",</code></span>
<span class="codeline" id="line-3276"><code>		"allow",</code></span>
<span class="codeline" id="line-3277"><code>		"authorization",</code></span>
<span class="codeline" id="line-3278"><code>		"cache-control",</code></span>
<span class="codeline" id="line-3279"><code>		"content-disposition",</code></span>
<span class="codeline" id="line-3280"><code>		"content-encoding",</code></span>
<span class="codeline" id="line-3281"><code>		"content-language",</code></span>
<span class="codeline" id="line-3282"><code>		"content-length",</code></span>
<span class="codeline" id="line-3283"><code>		"content-location",</code></span>
<span class="codeline" id="line-3284"><code>		"content-range",</code></span>
<span class="codeline" id="line-3285"><code>		"content-type",</code></span>
<span class="codeline" id="line-3286"><code>		"cookie",</code></span>
<span class="codeline" id="line-3287"><code>		"date",</code></span>
<span class="codeline" id="line-3288"><code>		"etag",</code></span>
<span class="codeline" id="line-3289"><code>		"expect",</code></span>
<span class="codeline" id="line-3290"><code>		"expires",</code></span>
<span class="codeline" id="line-3291"><code>		"from",</code></span>
<span class="codeline" id="line-3292"><code>		"host",</code></span>
<span class="codeline" id="line-3293"><code>		"if-match",</code></span>
<span class="codeline" id="line-3294"><code>		"if-modified-since",</code></span>
<span class="codeline" id="line-3295"><code>		"if-none-match",</code></span>
<span class="codeline" id="line-3296"><code>		"if-unmodified-since",</code></span>
<span class="codeline" id="line-3297"><code>		"last-modified",</code></span>
<span class="codeline" id="line-3298"><code>		"link",</code></span>
<span class="codeline" id="line-3299"><code>		"location",</code></span>
<span class="codeline" id="line-3300"><code>		"max-forwards",</code></span>
<span class="codeline" id="line-3301"><code>		"origin",</code></span>
<span class="codeline" id="line-3302"><code>		"proxy-authenticate",</code></span>
<span class="codeline" id="line-3303"><code>		"proxy-authorization",</code></span>
<span class="codeline" id="line-3304"><code>		"range",</code></span>
<span class="codeline" id="line-3305"><code>		"referer",</code></span>
<span class="codeline" id="line-3306"><code>		"refresh",</code></span>
<span class="codeline" id="line-3307"><code>		"retry-after",</code></span>
<span class="codeline" id="line-3308"><code>		"server",</code></span>
<span class="codeline" id="line-3309"><code>		"set-cookie",</code></span>
<span class="codeline" id="line-3310"><code>		"strict-transport-security",</code></span>
<span class="codeline" id="line-3311"><code>		"trailer",</code></span>
<span class="codeline" id="line-3312"><code>		"transfer-encoding",</code></span>
<span class="codeline" id="line-3313"><code>		"user-agent",</code></span>
<span class="codeline" id="line-3314"><code>		"vary",</code></span>
<span class="codeline" id="line-3315"><code>		"via",</code></span>
<span class="codeline" id="line-3316"><code>		"www-authenticate",</code></span>
<span class="codeline" id="line-3317"><code>		"x-forwarded-for",</code></span>
<span class="codeline" id="line-3318"><code>		"x-forwarded-proto",</code></span>
<span class="codeline" id="line-3319"><code>	}</code></span>
<span class="codeline" id="line-3320"><code>	http2commonLowerHeader = make(map[string]string, len(common))</code></span>
<span class="codeline" id="line-3321"><code>	http2commonCanonHeader = make(map[string]string, len(common))</code></span>
<span class="codeline" id="line-3322"><code>	for _, v := range common {</code></span>
<span class="codeline" id="line-3323"><code>		chk := CanonicalHeaderKey(v)</code></span>
<span class="codeline" id="line-3324"><code>		http2commonLowerHeader[chk] = v</code></span>
<span class="codeline" id="line-3325"><code>		http2commonCanonHeader[v] = chk</code></span>
<span class="codeline" id="line-3326"><code>	}</code></span>
<span class="codeline" id="line-3327"><code>}</code></span>
<span class="codeline" id="line-3328"><code></code></span>
<span class="codeline" id="line-3329"><code>func http2lowerHeader(v string) (lower string, ascii bool) {</code></span>
<span class="codeline" id="line-3330"><code>	http2buildCommonHeaderMapsOnce()</code></span>
<span class="codeline" id="line-3331"><code>	if s, ok := http2commonLowerHeader[v]; ok {</code></span>
<span class="codeline" id="line-3332"><code>		return s, true</code></span>
<span class="codeline" id="line-3333"><code>	}</code></span>
<span class="codeline" id="line-3334"><code>	return http2asciiToLower(v)</code></span>
<span class="codeline" id="line-3335"><code>}</code></span>
<span class="codeline" id="line-3336"><code></code></span>
<span class="codeline" id="line-3337"><code>func http2canonicalHeader(v string) string {</code></span>
<span class="codeline" id="line-3338"><code>	http2buildCommonHeaderMapsOnce()</code></span>
<span class="codeline" id="line-3339"><code>	if s, ok := http2commonCanonHeader[v]; ok {</code></span>
<span class="codeline" id="line-3340"><code>		return s</code></span>
<span class="codeline" id="line-3341"><code>	}</code></span>
<span class="codeline" id="line-3342"><code>	return CanonicalHeaderKey(v)</code></span>
<span class="codeline" id="line-3343"><code>}</code></span>
<span class="codeline" id="line-3344"><code></code></span>
<span class="codeline" id="line-3345"><code>var (</code></span>
<span class="codeline" id="line-3346"><code>	http2VerboseLogs    bool</code></span>
<span class="codeline" id="line-3347"><code>	http2logFrameWrites bool</code></span>
<span class="codeline" id="line-3348"><code>	http2logFrameReads  bool</code></span>
<span class="codeline" id="line-3349"><code>	http2inTests        bool</code></span>
<span class="codeline" id="line-3350"><code>)</code></span>
<span class="codeline" id="line-3351"><code></code></span>
<span class="codeline" id="line-3352"><code>func init() {</code></span>
<span class="codeline" id="line-3353"><code>	e := os.Getenv("GODEBUG")</code></span>
<span class="codeline" id="line-3354"><code>	if strings.Contains(e, "http2debug=1") {</code></span>
<span class="codeline" id="line-3355"><code>		http2VerboseLogs = true</code></span>
<span class="codeline" id="line-3356"><code>	}</code></span>
<span class="codeline" id="line-3357"><code>	if strings.Contains(e, "http2debug=2") {</code></span>
<span class="codeline" id="line-3358"><code>		http2VerboseLogs = true</code></span>
<span class="codeline" id="line-3359"><code>		http2logFrameWrites = true</code></span>
<span class="codeline" id="line-3360"><code>		http2logFrameReads = true</code></span>
<span class="codeline" id="line-3361"><code>	}</code></span>
<span class="codeline" id="line-3362"><code>}</code></span>
<span class="codeline" id="line-3363"><code></code></span>
<span class="codeline" id="line-3364"><code>const (</code></span>
<span class="codeline" id="line-3365"><code>	// ClientPreface is the string that must be sent by new</code></span>
<span class="codeline" id="line-3366"><code>	// connections from clients.</code></span>
<span class="codeline" id="line-3367"><code>	http2ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"</code></span>
<span class="codeline" id="line-3368"><code></code></span>
<span class="codeline" id="line-3369"><code>	// SETTINGS_MAX_FRAME_SIZE default</code></span>
<span class="codeline" id="line-3370"><code>	// https://httpwg.org/specs/rfc7540.html#rfc.section.6.5.2</code></span>
<span class="codeline" id="line-3371"><code>	http2initialMaxFrameSize = 16384</code></span>
<span class="codeline" id="line-3372"><code></code></span>
<span class="codeline" id="line-3373"><code>	// NextProtoTLS is the NPN/ALPN protocol negotiated during</code></span>
<span class="codeline" id="line-3374"><code>	// HTTP/2's TLS setup.</code></span>
<span class="codeline" id="line-3375"><code>	http2NextProtoTLS = "h2"</code></span>
<span class="codeline" id="line-3376"><code></code></span>
<span class="codeline" id="line-3377"><code>	// https://httpwg.org/specs/rfc7540.html#SettingValues</code></span>
<span class="codeline" id="line-3378"><code>	http2initialHeaderTableSize = 4096</code></span>
<span class="codeline" id="line-3379"><code></code></span>
<span class="codeline" id="line-3380"><code>	http2initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size</code></span>
<span class="codeline" id="line-3381"><code></code></span>
<span class="codeline" id="line-3382"><code>	http2defaultMaxReadFrameSize = 1 &lt;&lt; 20</code></span>
<span class="codeline" id="line-3383"><code>)</code></span>
<span class="codeline" id="line-3384"><code></code></span>
<span class="codeline" id="line-3385"><code>var (</code></span>
<span class="codeline" id="line-3386"><code>	http2clientPreface = []byte(http2ClientPreface)</code></span>
<span class="codeline" id="line-3387"><code>)</code></span>
<span class="codeline" id="line-3388"><code></code></span>
<span class="codeline" id="line-3389"><code>type http2streamState int</code></span>
<span class="codeline" id="line-3390"><code></code></span>
<span class="codeline" id="line-3391"><code>// HTTP/2 stream states.</code></span>
<span class="codeline" id="line-3392"><code>//</code></span>
<span class="codeline" id="line-3393"><code>// See http://tools.ietf.org/html/rfc7540#section-5.1.</code></span>
<span class="codeline" id="line-3394"><code>//</code></span>
<span class="codeline" id="line-3395"><code>// For simplicity, the server code merges "reserved (local)" into</code></span>
<span class="codeline" id="line-3396"><code>// "half-closed (remote)". This is one less state transition to track.</code></span>
<span class="codeline" id="line-3397"><code>// The only downside is that we send PUSH_PROMISEs slightly less</code></span>
<span class="codeline" id="line-3398"><code>// liberally than allowable. More discussion here:</code></span>
<span class="codeline" id="line-3399"><code>// https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html</code></span>
<span class="codeline" id="line-3400"><code>//</code></span>
<span class="codeline" id="line-3401"><code>// "reserved (remote)" is omitted since the client code does not</code></span>
<span class="codeline" id="line-3402"><code>// support server push.</code></span>
<span class="codeline" id="line-3403"><code>const (</code></span>
<span class="codeline" id="line-3404"><code>	http2stateIdle http2streamState = iota</code></span>
<span class="codeline" id="line-3405"><code>	http2stateOpen</code></span>
<span class="codeline" id="line-3406"><code>	http2stateHalfClosedLocal</code></span>
<span class="codeline" id="line-3407"><code>	http2stateHalfClosedRemote</code></span>
<span class="codeline" id="line-3408"><code>	http2stateClosed</code></span>
<span class="codeline" id="line-3409"><code>)</code></span>
<span class="codeline" id="line-3410"><code></code></span>
<span class="codeline" id="line-3411"><code>var http2stateName = [...]string{</code></span>
<span class="codeline" id="line-3412"><code>	http2stateIdle:             "Idle",</code></span>
<span class="codeline" id="line-3413"><code>	http2stateOpen:             "Open",</code></span>
<span class="codeline" id="line-3414"><code>	http2stateHalfClosedLocal:  "HalfClosedLocal",</code></span>
<span class="codeline" id="line-3415"><code>	http2stateHalfClosedRemote: "HalfClosedRemote",</code></span>
<span class="codeline" id="line-3416"><code>	http2stateClosed:           "Closed",</code></span>
<span class="codeline" id="line-3417"><code>}</code></span>
<span class="codeline" id="line-3418"><code></code></span>
<span class="codeline" id="line-3419"><code>func (st http2streamState) String() string {</code></span>
<span class="codeline" id="line-3420"><code>	return http2stateName[st]</code></span>
<span class="codeline" id="line-3421"><code>}</code></span>
<span class="codeline" id="line-3422"><code></code></span>
<span class="codeline" id="line-3423"><code>// Setting is a setting parameter: which setting it is, and its value.</code></span>
<span class="codeline" id="line-3424"><code>type http2Setting struct {</code></span>
<span class="codeline" id="line-3425"><code>	// ID is which setting is being set.</code></span>
<span class="codeline" id="line-3426"><code>	// See https://httpwg.org/specs/rfc7540.html#SettingFormat</code></span>
<span class="codeline" id="line-3427"><code>	ID http2SettingID</code></span>
<span class="codeline" id="line-3428"><code></code></span>
<span class="codeline" id="line-3429"><code>	// Val is the value.</code></span>
<span class="codeline" id="line-3430"><code>	Val uint32</code></span>
<span class="codeline" id="line-3431"><code>}</code></span>
<span class="codeline" id="line-3432"><code></code></span>
<span class="codeline" id="line-3433"><code>func (s http2Setting) String() string {</code></span>
<span class="codeline" id="line-3434"><code>	return fmt.Sprintf("[%v = %d]", s.ID, s.Val)</code></span>
<span class="codeline" id="line-3435"><code>}</code></span>
<span class="codeline" id="line-3436"><code></code></span>
<span class="codeline" id="line-3437"><code>// Valid reports whether the setting is valid.</code></span>
<span class="codeline" id="line-3438"><code>func (s http2Setting) Valid() error {</code></span>
<span class="codeline" id="line-3439"><code>	// Limits and error codes from 6.5.2 Defined SETTINGS Parameters</code></span>
<span class="codeline" id="line-3440"><code>	switch s.ID {</code></span>
<span class="codeline" id="line-3441"><code>	case http2SettingEnablePush:</code></span>
<span class="codeline" id="line-3442"><code>		if s.Val != 1 &amp;&amp; s.Val != 0 {</code></span>
<span class="codeline" id="line-3443"><code>			return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-3444"><code>		}</code></span>
<span class="codeline" id="line-3445"><code>	case http2SettingInitialWindowSize:</code></span>
<span class="codeline" id="line-3446"><code>		if s.Val &gt; 1&lt;&lt;31-1 {</code></span>
<span class="codeline" id="line-3447"><code>			return http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-3448"><code>		}</code></span>
<span class="codeline" id="line-3449"><code>	case http2SettingMaxFrameSize:</code></span>
<span class="codeline" id="line-3450"><code>		if s.Val &lt; 16384 || s.Val &gt; 1&lt;&lt;24-1 {</code></span>
<span class="codeline" id="line-3451"><code>			return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-3452"><code>		}</code></span>
<span class="codeline" id="line-3453"><code>	}</code></span>
<span class="codeline" id="line-3454"><code>	return nil</code></span>
<span class="codeline" id="line-3455"><code>}</code></span>
<span class="codeline" id="line-3456"><code></code></span>
<span class="codeline" id="line-3457"><code>// A SettingID is an HTTP/2 setting as defined in</code></span>
<span class="codeline" id="line-3458"><code>// https://httpwg.org/specs/rfc7540.html#iana-settings</code></span>
<span class="codeline" id="line-3459"><code>type http2SettingID uint16</code></span>
<span class="codeline" id="line-3460"><code></code></span>
<span class="codeline" id="line-3461"><code>const (</code></span>
<span class="codeline" id="line-3462"><code>	http2SettingHeaderTableSize      http2SettingID = 0x1</code></span>
<span class="codeline" id="line-3463"><code>	http2SettingEnablePush           http2SettingID = 0x2</code></span>
<span class="codeline" id="line-3464"><code>	http2SettingMaxConcurrentStreams http2SettingID = 0x3</code></span>
<span class="codeline" id="line-3465"><code>	http2SettingInitialWindowSize    http2SettingID = 0x4</code></span>
<span class="codeline" id="line-3466"><code>	http2SettingMaxFrameSize         http2SettingID = 0x5</code></span>
<span class="codeline" id="line-3467"><code>	http2SettingMaxHeaderListSize    http2SettingID = 0x6</code></span>
<span class="codeline" id="line-3468"><code>)</code></span>
<span class="codeline" id="line-3469"><code></code></span>
<span class="codeline" id="line-3470"><code>var http2settingName = map[http2SettingID]string{</code></span>
<span class="codeline" id="line-3471"><code>	http2SettingHeaderTableSize:      "HEADER_TABLE_SIZE",</code></span>
<span class="codeline" id="line-3472"><code>	http2SettingEnablePush:           "ENABLE_PUSH",</code></span>
<span class="codeline" id="line-3473"><code>	http2SettingMaxConcurrentStreams: "MAX_CONCURRENT_STREAMS",</code></span>
<span class="codeline" id="line-3474"><code>	http2SettingInitialWindowSize:    "INITIAL_WINDOW_SIZE",</code></span>
<span class="codeline" id="line-3475"><code>	http2SettingMaxFrameSize:         "MAX_FRAME_SIZE",</code></span>
<span class="codeline" id="line-3476"><code>	http2SettingMaxHeaderListSize:    "MAX_HEADER_LIST_SIZE",</code></span>
<span class="codeline" id="line-3477"><code>}</code></span>
<span class="codeline" id="line-3478"><code></code></span>
<span class="codeline" id="line-3479"><code>func (s http2SettingID) String() string {</code></span>
<span class="codeline" id="line-3480"><code>	if v, ok := http2settingName[s]; ok {</code></span>
<span class="codeline" id="line-3481"><code>		return v</code></span>
<span class="codeline" id="line-3482"><code>	}</code></span>
<span class="codeline" id="line-3483"><code>	return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s))</code></span>
<span class="codeline" id="line-3484"><code>}</code></span>
<span class="codeline" id="line-3485"><code></code></span>
<span class="codeline" id="line-3486"><code>// validWireHeaderFieldName reports whether v is a valid header field</code></span>
<span class="codeline" id="line-3487"><code>// name (key). See httpguts.ValidHeaderName for the base rules.</code></span>
<span class="codeline" id="line-3488"><code>//</code></span>
<span class="codeline" id="line-3489"><code>// Further, http2 says:</code></span>
<span class="codeline" id="line-3490"><code>//</code></span>
<span class="codeline" id="line-3491"><code>//	"Just as in HTTP/1.x, header field names are strings of ASCII</code></span>
<span class="codeline" id="line-3492"><code>//	characters that are compared in a case-insensitive</code></span>
<span class="codeline" id="line-3493"><code>//	fashion. However, header field names MUST be converted to</code></span>
<span class="codeline" id="line-3494"><code>//	lowercase prior to their encoding in HTTP/2. "</code></span>
<span class="codeline" id="line-3495"><code>func http2validWireHeaderFieldName(v string) bool {</code></span>
<span class="codeline" id="line-3496"><code>	if len(v) == 0 {</code></span>
<span class="codeline" id="line-3497"><code>		return false</code></span>
<span class="codeline" id="line-3498"><code>	}</code></span>
<span class="codeline" id="line-3499"><code>	for _, r := range v {</code></span>
<span class="codeline" id="line-3500"><code>		if !httpguts.IsTokenRune(r) {</code></span>
<span class="codeline" id="line-3501"><code>			return false</code></span>
<span class="codeline" id="line-3502"><code>		}</code></span>
<span class="codeline" id="line-3503"><code>		if 'A' &lt;= r &amp;&amp; r &lt;= 'Z' {</code></span>
<span class="codeline" id="line-3504"><code>			return false</code></span>
<span class="codeline" id="line-3505"><code>		}</code></span>
<span class="codeline" id="line-3506"><code>	}</code></span>
<span class="codeline" id="line-3507"><code>	return true</code></span>
<span class="codeline" id="line-3508"><code>}</code></span>
<span class="codeline" id="line-3509"><code></code></span>
<span class="codeline" id="line-3510"><code>func http2httpCodeString(code int) string {</code></span>
<span class="codeline" id="line-3511"><code>	switch code {</code></span>
<span class="codeline" id="line-3512"><code>	case 200:</code></span>
<span class="codeline" id="line-3513"><code>		return "200"</code></span>
<span class="codeline" id="line-3514"><code>	case 404:</code></span>
<span class="codeline" id="line-3515"><code>		return "404"</code></span>
<span class="codeline" id="line-3516"><code>	}</code></span>
<span class="codeline" id="line-3517"><code>	return strconv.Itoa(code)</code></span>
<span class="codeline" id="line-3518"><code>}</code></span>
<span class="codeline" id="line-3519"><code></code></span>
<span class="codeline" id="line-3520"><code>// from pkg io</code></span>
<span class="codeline" id="line-3521"><code>type http2stringWriter interface {</code></span>
<span class="codeline" id="line-3522"><code>	WriteString(s string) (n int, err error)</code></span>
<span class="codeline" id="line-3523"><code>}</code></span>
<span class="codeline" id="line-3524"><code></code></span>
<span class="codeline" id="line-3525"><code>// A gate lets two goroutines coordinate their activities.</code></span>
<span class="codeline" id="line-3526"><code>type http2gate chan struct{}</code></span>
<span class="codeline" id="line-3527"><code></code></span>
<span class="codeline" id="line-3528"><code>func (g http2gate) Done() { g &lt;- struct{}{} }</code></span>
<span class="codeline" id="line-3529"><code></code></span>
<span class="codeline" id="line-3530"><code>func (g http2gate) Wait() { &lt;-g }</code></span>
<span class="codeline" id="line-3531"><code></code></span>
<span class="codeline" id="line-3532"><code>// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).</code></span>
<span class="codeline" id="line-3533"><code>type http2closeWaiter chan struct{}</code></span>
<span class="codeline" id="line-3534"><code></code></span>
<span class="codeline" id="line-3535"><code>// Init makes a closeWaiter usable.</code></span>
<span class="codeline" id="line-3536"><code>// It exists because so a closeWaiter value can be placed inside a</code></span>
<span class="codeline" id="line-3537"><code>// larger struct and have the Mutex and Cond's memory in the same</code></span>
<span class="codeline" id="line-3538"><code>// allocation.</code></span>
<span class="codeline" id="line-3539"><code>func (cw *http2closeWaiter) Init() {</code></span>
<span class="codeline" id="line-3540"><code>	*cw = make(chan struct{})</code></span>
<span class="codeline" id="line-3541"><code>}</code></span>
<span class="codeline" id="line-3542"><code></code></span>
<span class="codeline" id="line-3543"><code>// Close marks the closeWaiter as closed and unblocks any waiters.</code></span>
<span class="codeline" id="line-3544"><code>func (cw http2closeWaiter) Close() {</code></span>
<span class="codeline" id="line-3545"><code>	close(cw)</code></span>
<span class="codeline" id="line-3546"><code>}</code></span>
<span class="codeline" id="line-3547"><code></code></span>
<span class="codeline" id="line-3548"><code>// Wait waits for the closeWaiter to become closed.</code></span>
<span class="codeline" id="line-3549"><code>func (cw http2closeWaiter) Wait() {</code></span>
<span class="codeline" id="line-3550"><code>	&lt;-cw</code></span>
<span class="codeline" id="line-3551"><code>}</code></span>
<span class="codeline" id="line-3552"><code></code></span>
<span class="codeline" id="line-3553"><code>// bufferedWriter is a buffered writer that writes to w.</code></span>
<span class="codeline" id="line-3554"><code>// Its buffered writer is lazily allocated as needed, to minimize</code></span>
<span class="codeline" id="line-3555"><code>// idle memory usage with many connections.</code></span>
<span class="codeline" id="line-3556"><code>type http2bufferedWriter struct {</code></span>
<span class="codeline" id="line-3557"><code>	_  http2incomparable</code></span>
<span class="codeline" id="line-3558"><code>	w  io.Writer     // immutable</code></span>
<span class="codeline" id="line-3559"><code>	bw *bufio.Writer // non-nil when data is buffered</code></span>
<span class="codeline" id="line-3560"><code>}</code></span>
<span class="codeline" id="line-3561"><code></code></span>
<span class="codeline" id="line-3562"><code>func http2newBufferedWriter(w io.Writer) *http2bufferedWriter {</code></span>
<span class="codeline" id="line-3563"><code>	return &amp;http2bufferedWriter{w: w}</code></span>
<span class="codeline" id="line-3564"><code>}</code></span>
<span class="codeline" id="line-3565"><code></code></span>
<span class="codeline" id="line-3566"><code>// bufWriterPoolBufferSize is the size of bufio.Writer's</code></span>
<span class="codeline" id="line-3567"><code>// buffers created using bufWriterPool.</code></span>
<span class="codeline" id="line-3568"><code>//</code></span>
<span class="codeline" id="line-3569"><code>// TODO: pick a less arbitrary value? this is a bit under</code></span>
<span class="codeline" id="line-3570"><code>// (3 x typical 1500 byte MTU) at least. Other than that,</code></span>
<span class="codeline" id="line-3571"><code>// not much thought went into it.</code></span>
<span class="codeline" id="line-3572"><code>const http2bufWriterPoolBufferSize = 4 &lt;&lt; 10</code></span>
<span class="codeline" id="line-3573"><code></code></span>
<span class="codeline" id="line-3574"><code>var http2bufWriterPool = sync.Pool{</code></span>
<span class="codeline" id="line-3575"><code>	New: func() interface{} {</code></span>
<span class="codeline" id="line-3576"><code>		return bufio.NewWriterSize(nil, http2bufWriterPoolBufferSize)</code></span>
<span class="codeline" id="line-3577"><code>	},</code></span>
<span class="codeline" id="line-3578"><code>}</code></span>
<span class="codeline" id="line-3579"><code></code></span>
<span class="codeline" id="line-3580"><code>func (w *http2bufferedWriter) Available() int {</code></span>
<span class="codeline" id="line-3581"><code>	if w.bw == nil {</code></span>
<span class="codeline" id="line-3582"><code>		return http2bufWriterPoolBufferSize</code></span>
<span class="codeline" id="line-3583"><code>	}</code></span>
<span class="codeline" id="line-3584"><code>	return w.bw.Available()</code></span>
<span class="codeline" id="line-3585"><code>}</code></span>
<span class="codeline" id="line-3586"><code></code></span>
<span class="codeline" id="line-3587"><code>func (w *http2bufferedWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3588"><code>	if w.bw == nil {</code></span>
<span class="codeline" id="line-3589"><code>		bw := http2bufWriterPool.Get().(*bufio.Writer)</code></span>
<span class="codeline" id="line-3590"><code>		bw.Reset(w.w)</code></span>
<span class="codeline" id="line-3591"><code>		w.bw = bw</code></span>
<span class="codeline" id="line-3592"><code>	}</code></span>
<span class="codeline" id="line-3593"><code>	return w.bw.Write(p)</code></span>
<span class="codeline" id="line-3594"><code>}</code></span>
<span class="codeline" id="line-3595"><code></code></span>
<span class="codeline" id="line-3596"><code>func (w *http2bufferedWriter) Flush() error {</code></span>
<span class="codeline" id="line-3597"><code>	bw := w.bw</code></span>
<span class="codeline" id="line-3598"><code>	if bw == nil {</code></span>
<span class="codeline" id="line-3599"><code>		return nil</code></span>
<span class="codeline" id="line-3600"><code>	}</code></span>
<span class="codeline" id="line-3601"><code>	err := bw.Flush()</code></span>
<span class="codeline" id="line-3602"><code>	bw.Reset(nil)</code></span>
<span class="codeline" id="line-3603"><code>	http2bufWriterPool.Put(bw)</code></span>
<span class="codeline" id="line-3604"><code>	w.bw = nil</code></span>
<span class="codeline" id="line-3605"><code>	return err</code></span>
<span class="codeline" id="line-3606"><code>}</code></span>
<span class="codeline" id="line-3607"><code></code></span>
<span class="codeline" id="line-3608"><code>func http2mustUint31(v int32) uint32 {</code></span>
<span class="codeline" id="line-3609"><code>	if v &lt; 0 || v &gt; 2147483647 {</code></span>
<span class="codeline" id="line-3610"><code>		panic("out of range")</code></span>
<span class="codeline" id="line-3611"><code>	}</code></span>
<span class="codeline" id="line-3612"><code>	return uint32(v)</code></span>
<span class="codeline" id="line-3613"><code>}</code></span>
<span class="codeline" id="line-3614"><code></code></span>
<span class="codeline" id="line-3615"><code>// bodyAllowedForStatus reports whether a given response status code</code></span>
<span class="codeline" id="line-3616"><code>// permits a body. See RFC 7230, section 3.3.</code></span>
<span class="codeline" id="line-3617"><code>func http2bodyAllowedForStatus(status int) bool {</code></span>
<span class="codeline" id="line-3618"><code>	switch {</code></span>
<span class="codeline" id="line-3619"><code>	case status &gt;= 100 &amp;&amp; status &lt;= 199:</code></span>
<span class="codeline" id="line-3620"><code>		return false</code></span>
<span class="codeline" id="line-3621"><code>	case status == 204:</code></span>
<span class="codeline" id="line-3622"><code>		return false</code></span>
<span class="codeline" id="line-3623"><code>	case status == 304:</code></span>
<span class="codeline" id="line-3624"><code>		return false</code></span>
<span class="codeline" id="line-3625"><code>	}</code></span>
<span class="codeline" id="line-3626"><code>	return true</code></span>
<span class="codeline" id="line-3627"><code>}</code></span>
<span class="codeline" id="line-3628"><code></code></span>
<span class="codeline" id="line-3629"><code>type http2httpError struct {</code></span>
<span class="codeline" id="line-3630"><code>	_       http2incomparable</code></span>
<span class="codeline" id="line-3631"><code>	msg     string</code></span>
<span class="codeline" id="line-3632"><code>	timeout bool</code></span>
<span class="codeline" id="line-3633"><code>}</code></span>
<span class="codeline" id="line-3634"><code></code></span>
<span class="codeline" id="line-3635"><code>func (e *http2httpError) Error() string { return e.msg }</code></span>
<span class="codeline" id="line-3636"><code></code></span>
<span class="codeline" id="line-3637"><code>func (e *http2httpError) Timeout() bool { return e.timeout }</code></span>
<span class="codeline" id="line-3638"><code></code></span>
<span class="codeline" id="line-3639"><code>func (e *http2httpError) Temporary() bool { return true }</code></span>
<span class="codeline" id="line-3640"><code></code></span>
<span class="codeline" id="line-3641"><code>var http2errTimeout error = &amp;http2httpError{msg: "http2: timeout awaiting response headers", timeout: true}</code></span>
<span class="codeline" id="line-3642"><code></code></span>
<span class="codeline" id="line-3643"><code>type http2connectionStater interface {</code></span>
<span class="codeline" id="line-3644"><code>	ConnectionState() tls.ConnectionState</code></span>
<span class="codeline" id="line-3645"><code>}</code></span>
<span class="codeline" id="line-3646"><code></code></span>
<span class="codeline" id="line-3647"><code>var http2sorterPool = sync.Pool{New: func() interface{} { return new(http2sorter) }}</code></span>
<span class="codeline" id="line-3648"><code></code></span>
<span class="codeline" id="line-3649"><code>type http2sorter struct {</code></span>
<span class="codeline" id="line-3650"><code>	v []string // owned by sorter</code></span>
<span class="codeline" id="line-3651"><code>}</code></span>
<span class="codeline" id="line-3652"><code></code></span>
<span class="codeline" id="line-3653"><code>func (s *http2sorter) Len() int { return len(s.v) }</code></span>
<span class="codeline" id="line-3654"><code></code></span>
<span class="codeline" id="line-3655"><code>func (s *http2sorter) Swap(i, j int) { s.v[i], s.v[j] = s.v[j], s.v[i] }</code></span>
<span class="codeline" id="line-3656"><code></code></span>
<span class="codeline" id="line-3657"><code>func (s *http2sorter) Less(i, j int) bool { return s.v[i] &lt; s.v[j] }</code></span>
<span class="codeline" id="line-3658"><code></code></span>
<span class="codeline" id="line-3659"><code>// Keys returns the sorted keys of h.</code></span>
<span class="codeline" id="line-3660"><code>//</code></span>
<span class="codeline" id="line-3661"><code>// The returned slice is only valid until s used again or returned to</code></span>
<span class="codeline" id="line-3662"><code>// its pool.</code></span>
<span class="codeline" id="line-3663"><code>func (s *http2sorter) Keys(h Header) []string {</code></span>
<span class="codeline" id="line-3664"><code>	keys := s.v[:0]</code></span>
<span class="codeline" id="line-3665"><code>	for k := range h {</code></span>
<span class="codeline" id="line-3666"><code>		keys = append(keys, k)</code></span>
<span class="codeline" id="line-3667"><code>	}</code></span>
<span class="codeline" id="line-3668"><code>	s.v = keys</code></span>
<span class="codeline" id="line-3669"><code>	sort.Sort(s)</code></span>
<span class="codeline" id="line-3670"><code>	return keys</code></span>
<span class="codeline" id="line-3671"><code>}</code></span>
<span class="codeline" id="line-3672"><code></code></span>
<span class="codeline" id="line-3673"><code>func (s *http2sorter) SortStrings(ss []string) {</code></span>
<span class="codeline" id="line-3674"><code>	// Our sorter works on s.v, which sorter owns, so</code></span>
<span class="codeline" id="line-3675"><code>	// stash it away while we sort the user's buffer.</code></span>
<span class="codeline" id="line-3676"><code>	save := s.v</code></span>
<span class="codeline" id="line-3677"><code>	s.v = ss</code></span>
<span class="codeline" id="line-3678"><code>	sort.Sort(s)</code></span>
<span class="codeline" id="line-3679"><code>	s.v = save</code></span>
<span class="codeline" id="line-3680"><code>}</code></span>
<span class="codeline" id="line-3681"><code></code></span>
<span class="codeline" id="line-3682"><code>// validPseudoPath reports whether v is a valid :path pseudo-header</code></span>
<span class="codeline" id="line-3683"><code>// value. It must be either:</code></span>
<span class="codeline" id="line-3684"><code>//</code></span>
<span class="codeline" id="line-3685"><code>//   - a non-empty string starting with '/'</code></span>
<span class="codeline" id="line-3686"><code>//   - the string '*', for OPTIONS requests.</code></span>
<span class="codeline" id="line-3687"><code>//</code></span>
<span class="codeline" id="line-3688"><code>// For now this is only used a quick check for deciding when to clean</code></span>
<span class="codeline" id="line-3689"><code>// up Opaque URLs before sending requests from the Transport.</code></span>
<span class="codeline" id="line-3690"><code>// See golang.org/issue/16847</code></span>
<span class="codeline" id="line-3691"><code>//</code></span>
<span class="codeline" id="line-3692"><code>// We used to enforce that the path also didn't start with "//", but</code></span>
<span class="codeline" id="line-3693"><code>// Google's GFE accepts such paths and Chrome sends them, so ignore</code></span>
<span class="codeline" id="line-3694"><code>// that part of the spec. See golang.org/issue/19103.</code></span>
<span class="codeline" id="line-3695"><code>func http2validPseudoPath(v string) bool {</code></span>
<span class="codeline" id="line-3696"><code>	return (len(v) &gt; 0 &amp;&amp; v[0] == '/') || v == "*"</code></span>
<span class="codeline" id="line-3697"><code>}</code></span>
<span class="codeline" id="line-3698"><code></code></span>
<span class="codeline" id="line-3699"><code>// incomparable is a zero-width, non-comparable type. Adding it to a struct</code></span>
<span class="codeline" id="line-3700"><code>// makes that struct also non-comparable, and generally doesn't add</code></span>
<span class="codeline" id="line-3701"><code>// any size (as long as it's first).</code></span>
<span class="codeline" id="line-3702"><code>type http2incomparable [0]func()</code></span>
<span class="codeline" id="line-3703"><code></code></span>
<span class="codeline" id="line-3704"><code>// pipe is a goroutine-safe io.Reader/io.Writer pair. It's like</code></span>
<span class="codeline" id="line-3705"><code>// io.Pipe except there are no PipeReader/PipeWriter halves, and the</code></span>
<span class="codeline" id="line-3706"><code>// underlying buffer is an interface. (io.Pipe is always unbuffered)</code></span>
<span class="codeline" id="line-3707"><code>type http2pipe struct {</code></span>
<span class="codeline" id="line-3708"><code>	mu       sync.Mutex</code></span>
<span class="codeline" id="line-3709"><code>	c        sync.Cond       // c.L lazily initialized to &amp;p.mu</code></span>
<span class="codeline" id="line-3710"><code>	b        http2pipeBuffer // nil when done reading</code></span>
<span class="codeline" id="line-3711"><code>	unread   int             // bytes unread when done</code></span>
<span class="codeline" id="line-3712"><code>	err      error           // read error once empty. non-nil means closed.</code></span>
<span class="codeline" id="line-3713"><code>	breakErr error           // immediate read error (caller doesn't see rest of b)</code></span>
<span class="codeline" id="line-3714"><code>	donec    chan struct{}   // closed on error</code></span>
<span class="codeline" id="line-3715"><code>	readFn   func()          // optional code to run in Read before error</code></span>
<span class="codeline" id="line-3716"><code>}</code></span>
<span class="codeline" id="line-3717"><code></code></span>
<span class="codeline" id="line-3718"><code>type http2pipeBuffer interface {</code></span>
<span class="codeline" id="line-3719"><code>	Len() int</code></span>
<span class="codeline" id="line-3720"><code>	io.Writer</code></span>
<span class="codeline" id="line-3721"><code>	io.Reader</code></span>
<span class="codeline" id="line-3722"><code>}</code></span>
<span class="codeline" id="line-3723"><code></code></span>
<span class="codeline" id="line-3724"><code>// setBuffer initializes the pipe buffer.</code></span>
<span class="codeline" id="line-3725"><code>// It has no effect if the pipe is already closed.</code></span>
<span class="codeline" id="line-3726"><code>func (p *http2pipe) setBuffer(b http2pipeBuffer) {</code></span>
<span class="codeline" id="line-3727"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3728"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3729"><code>	if p.err != nil || p.breakErr != nil {</code></span>
<span class="codeline" id="line-3730"><code>		return</code></span>
<span class="codeline" id="line-3731"><code>	}</code></span>
<span class="codeline" id="line-3732"><code>	p.b = b</code></span>
<span class="codeline" id="line-3733"><code>}</code></span>
<span class="codeline" id="line-3734"><code></code></span>
<span class="codeline" id="line-3735"><code>func (p *http2pipe) Len() int {</code></span>
<span class="codeline" id="line-3736"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3737"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3738"><code>	if p.b == nil {</code></span>
<span class="codeline" id="line-3739"><code>		return p.unread</code></span>
<span class="codeline" id="line-3740"><code>	}</code></span>
<span class="codeline" id="line-3741"><code>	return p.b.Len()</code></span>
<span class="codeline" id="line-3742"><code>}</code></span>
<span class="codeline" id="line-3743"><code></code></span>
<span class="codeline" id="line-3744"><code>// Read waits until data is available and copies bytes</code></span>
<span class="codeline" id="line-3745"><code>// from the buffer into p.</code></span>
<span class="codeline" id="line-3746"><code>func (p *http2pipe) Read(d []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3747"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3748"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3749"><code>	if p.c.L == nil {</code></span>
<span class="codeline" id="line-3750"><code>		p.c.L = &amp;p.mu</code></span>
<span class="codeline" id="line-3751"><code>	}</code></span>
<span class="codeline" id="line-3752"><code>	for {</code></span>
<span class="codeline" id="line-3753"><code>		if p.breakErr != nil {</code></span>
<span class="codeline" id="line-3754"><code>			return 0, p.breakErr</code></span>
<span class="codeline" id="line-3755"><code>		}</code></span>
<span class="codeline" id="line-3756"><code>		if p.b != nil &amp;&amp; p.b.Len() &gt; 0 {</code></span>
<span class="codeline" id="line-3757"><code>			return p.b.Read(d)</code></span>
<span class="codeline" id="line-3758"><code>		}</code></span>
<span class="codeline" id="line-3759"><code>		if p.err != nil {</code></span>
<span class="codeline" id="line-3760"><code>			if p.readFn != nil {</code></span>
<span class="codeline" id="line-3761"><code>				p.readFn()     // e.g. copy trailers</code></span>
<span class="codeline" id="line-3762"><code>				p.readFn = nil // not sticky like p.err</code></span>
<span class="codeline" id="line-3763"><code>			}</code></span>
<span class="codeline" id="line-3764"><code>			p.b = nil</code></span>
<span class="codeline" id="line-3765"><code>			return 0, p.err</code></span>
<span class="codeline" id="line-3766"><code>		}</code></span>
<span class="codeline" id="line-3767"><code>		p.c.Wait()</code></span>
<span class="codeline" id="line-3768"><code>	}</code></span>
<span class="codeline" id="line-3769"><code>}</code></span>
<span class="codeline" id="line-3770"><code></code></span>
<span class="codeline" id="line-3771"><code>var http2errClosedPipeWrite = errors.New("write on closed buffer")</code></span>
<span class="codeline" id="line-3772"><code></code></span>
<span class="codeline" id="line-3773"><code>// Write copies bytes from p into the buffer and wakes a reader.</code></span>
<span class="codeline" id="line-3774"><code>// It is an error to write more data than the buffer can hold.</code></span>
<span class="codeline" id="line-3775"><code>func (p *http2pipe) Write(d []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3776"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3777"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3778"><code>	if p.c.L == nil {</code></span>
<span class="codeline" id="line-3779"><code>		p.c.L = &amp;p.mu</code></span>
<span class="codeline" id="line-3780"><code>	}</code></span>
<span class="codeline" id="line-3781"><code>	defer p.c.Signal()</code></span>
<span class="codeline" id="line-3782"><code>	if p.err != nil || p.breakErr != nil {</code></span>
<span class="codeline" id="line-3783"><code>		return 0, http2errClosedPipeWrite</code></span>
<span class="codeline" id="line-3784"><code>	}</code></span>
<span class="codeline" id="line-3785"><code>	return p.b.Write(d)</code></span>
<span class="codeline" id="line-3786"><code>}</code></span>
<span class="codeline" id="line-3787"><code></code></span>
<span class="codeline" id="line-3788"><code>// CloseWithError causes the next Read (waking up a current blocked</code></span>
<span class="codeline" id="line-3789"><code>// Read if needed) to return the provided err after all data has been</code></span>
<span class="codeline" id="line-3790"><code>// read.</code></span>
<span class="codeline" id="line-3791"><code>//</code></span>
<span class="codeline" id="line-3792"><code>// The error must be non-nil.</code></span>
<span class="codeline" id="line-3793"><code>func (p *http2pipe) CloseWithError(err error) { p.closeWithError(&amp;p.err, err, nil) }</code></span>
<span class="codeline" id="line-3794"><code></code></span>
<span class="codeline" id="line-3795"><code>// BreakWithError causes the next Read (waking up a current blocked</code></span>
<span class="codeline" id="line-3796"><code>// Read if needed) to return the provided err immediately, without</code></span>
<span class="codeline" id="line-3797"><code>// waiting for unread data.</code></span>
<span class="codeline" id="line-3798"><code>func (p *http2pipe) BreakWithError(err error) { p.closeWithError(&amp;p.breakErr, err, nil) }</code></span>
<span class="codeline" id="line-3799"><code></code></span>
<span class="codeline" id="line-3800"><code>// closeWithErrorAndCode is like CloseWithError but also sets some code to run</code></span>
<span class="codeline" id="line-3801"><code>// in the caller's goroutine before returning the error.</code></span>
<span class="codeline" id="line-3802"><code>func (p *http2pipe) closeWithErrorAndCode(err error, fn func()) { p.closeWithError(&amp;p.err, err, fn) }</code></span>
<span class="codeline" id="line-3803"><code></code></span>
<span class="codeline" id="line-3804"><code>func (p *http2pipe) closeWithError(dst *error, err error, fn func()) {</code></span>
<span class="codeline" id="line-3805"><code>	if err == nil {</code></span>
<span class="codeline" id="line-3806"><code>		panic("err must be non-nil")</code></span>
<span class="codeline" id="line-3807"><code>	}</code></span>
<span class="codeline" id="line-3808"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3809"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3810"><code>	if p.c.L == nil {</code></span>
<span class="codeline" id="line-3811"><code>		p.c.L = &amp;p.mu</code></span>
<span class="codeline" id="line-3812"><code>	}</code></span>
<span class="codeline" id="line-3813"><code>	defer p.c.Signal()</code></span>
<span class="codeline" id="line-3814"><code>	if *dst != nil {</code></span>
<span class="codeline" id="line-3815"><code>		// Already been done.</code></span>
<span class="codeline" id="line-3816"><code>		return</code></span>
<span class="codeline" id="line-3817"><code>	}</code></span>
<span class="codeline" id="line-3818"><code>	p.readFn = fn</code></span>
<span class="codeline" id="line-3819"><code>	if dst == &amp;p.breakErr {</code></span>
<span class="codeline" id="line-3820"><code>		if p.b != nil {</code></span>
<span class="codeline" id="line-3821"><code>			p.unread += p.b.Len()</code></span>
<span class="codeline" id="line-3822"><code>		}</code></span>
<span class="codeline" id="line-3823"><code>		p.b = nil</code></span>
<span class="codeline" id="line-3824"><code>	}</code></span>
<span class="codeline" id="line-3825"><code>	*dst = err</code></span>
<span class="codeline" id="line-3826"><code>	p.closeDoneLocked()</code></span>
<span class="codeline" id="line-3827"><code>}</code></span>
<span class="codeline" id="line-3828"><code></code></span>
<span class="codeline" id="line-3829"><code>// requires p.mu be held.</code></span>
<span class="codeline" id="line-3830"><code>func (p *http2pipe) closeDoneLocked() {</code></span>
<span class="codeline" id="line-3831"><code>	if p.donec == nil {</code></span>
<span class="codeline" id="line-3832"><code>		return</code></span>
<span class="codeline" id="line-3833"><code>	}</code></span>
<span class="codeline" id="line-3834"><code>	// Close if unclosed. This isn't racy since we always</code></span>
<span class="codeline" id="line-3835"><code>	// hold p.mu while closing.</code></span>
<span class="codeline" id="line-3836"><code>	select {</code></span>
<span class="codeline" id="line-3837"><code>	case &lt;-p.donec:</code></span>
<span class="codeline" id="line-3838"><code>	default:</code></span>
<span class="codeline" id="line-3839"><code>		close(p.donec)</code></span>
<span class="codeline" id="line-3840"><code>	}</code></span>
<span class="codeline" id="line-3841"><code>}</code></span>
<span class="codeline" id="line-3842"><code></code></span>
<span class="codeline" id="line-3843"><code>// Err returns the error (if any) first set by BreakWithError or CloseWithError.</code></span>
<span class="codeline" id="line-3844"><code>func (p *http2pipe) Err() error {</code></span>
<span class="codeline" id="line-3845"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3846"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3847"><code>	if p.breakErr != nil {</code></span>
<span class="codeline" id="line-3848"><code>		return p.breakErr</code></span>
<span class="codeline" id="line-3849"><code>	}</code></span>
<span class="codeline" id="line-3850"><code>	return p.err</code></span>
<span class="codeline" id="line-3851"><code>}</code></span>
<span class="codeline" id="line-3852"><code></code></span>
<span class="codeline" id="line-3853"><code>// Done returns a channel which is closed if and when this pipe is closed</code></span>
<span class="codeline" id="line-3854"><code>// with CloseWithError.</code></span>
<span class="codeline" id="line-3855"><code>func (p *http2pipe) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-3856"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-3857"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-3858"><code>	if p.donec == nil {</code></span>
<span class="codeline" id="line-3859"><code>		p.donec = make(chan struct{})</code></span>
<span class="codeline" id="line-3860"><code>		if p.err != nil || p.breakErr != nil {</code></span>
<span class="codeline" id="line-3861"><code>			// Already hit an error.</code></span>
<span class="codeline" id="line-3862"><code>			p.closeDoneLocked()</code></span>
<span class="codeline" id="line-3863"><code>		}</code></span>
<span class="codeline" id="line-3864"><code>	}</code></span>
<span class="codeline" id="line-3865"><code>	return p.donec</code></span>
<span class="codeline" id="line-3866"><code>}</code></span>
<span class="codeline" id="line-3867"><code></code></span>
<span class="codeline" id="line-3868"><code>const (</code></span>
<span class="codeline" id="line-3869"><code>	http2prefaceTimeout         = 10 * time.Second</code></span>
<span class="codeline" id="line-3870"><code>	http2firstSettingsTimeout   = 2 * time.Second // should be in-flight with preface anyway</code></span>
<span class="codeline" id="line-3871"><code>	http2handlerChunkWriteSize  = 4 &lt;&lt; 10</code></span>
<span class="codeline" id="line-3872"><code>	http2defaultMaxStreams      = 250 // TODO: make this 100 as the GFE seems to?</code></span>
<span class="codeline" id="line-3873"><code>	http2maxQueuedControlFrames = 10000</code></span>
<span class="codeline" id="line-3874"><code>)</code></span>
<span class="codeline" id="line-3875"><code></code></span>
<span class="codeline" id="line-3876"><code>var (</code></span>
<span class="codeline" id="line-3877"><code>	http2errClientDisconnected = errors.New("client disconnected")</code></span>
<span class="codeline" id="line-3878"><code>	http2errClosedBody         = errors.New("body closed by handler")</code></span>
<span class="codeline" id="line-3879"><code>	http2errHandlerComplete    = errors.New("http2: request body closed due to handler exiting")</code></span>
<span class="codeline" id="line-3880"><code>	http2errStreamClosed       = errors.New("http2: stream closed")</code></span>
<span class="codeline" id="line-3881"><code>)</code></span>
<span class="codeline" id="line-3882"><code></code></span>
<span class="codeline" id="line-3883"><code>var http2responseWriterStatePool = sync.Pool{</code></span>
<span class="codeline" id="line-3884"><code>	New: func() interface{} {</code></span>
<span class="codeline" id="line-3885"><code>		rws := &amp;http2responseWriterState{}</code></span>
<span class="codeline" id="line-3886"><code>		rws.bw = bufio.NewWriterSize(http2chunkWriter{rws}, http2handlerChunkWriteSize)</code></span>
<span class="codeline" id="line-3887"><code>		return rws</code></span>
<span class="codeline" id="line-3888"><code>	},</code></span>
<span class="codeline" id="line-3889"><code>}</code></span>
<span class="codeline" id="line-3890"><code></code></span>
<span class="codeline" id="line-3891"><code>// Test hooks.</code></span>
<span class="codeline" id="line-3892"><code>var (</code></span>
<span class="codeline" id="line-3893"><code>	http2testHookOnConn        func()</code></span>
<span class="codeline" id="line-3894"><code>	http2testHookGetServerConn func(*http2serverConn)</code></span>
<span class="codeline" id="line-3895"><code>	http2testHookOnPanicMu     *sync.Mutex // nil except in tests</code></span>
<span class="codeline" id="line-3896"><code>	http2testHookOnPanic       func(sc *http2serverConn, panicVal interface{}) (rePanic bool)</code></span>
<span class="codeline" id="line-3897"><code>)</code></span>
<span class="codeline" id="line-3898"><code></code></span>
<span class="codeline" id="line-3899"><code>// Server is an HTTP/2 server.</code></span>
<span class="codeline" id="line-3900"><code>type http2Server struct {</code></span>
<span class="codeline" id="line-3901"><code>	// MaxHandlers limits the number of http.Handler ServeHTTP goroutines</code></span>
<span class="codeline" id="line-3902"><code>	// which may run at a time over all connections.</code></span>
<span class="codeline" id="line-3903"><code>	// Negative or zero no limit.</code></span>
<span class="codeline" id="line-3904"><code>	// TODO: implement</code></span>
<span class="codeline" id="line-3905"><code>	MaxHandlers int</code></span>
<span class="codeline" id="line-3906"><code></code></span>
<span class="codeline" id="line-3907"><code>	// MaxConcurrentStreams optionally specifies the number of</code></span>
<span class="codeline" id="line-3908"><code>	// concurrent streams that each client may have open at a</code></span>
<span class="codeline" id="line-3909"><code>	// time. This is unrelated to the number of http.Handler goroutines</code></span>
<span class="codeline" id="line-3910"><code>	// which may be active globally, which is MaxHandlers.</code></span>
<span class="codeline" id="line-3911"><code>	// If zero, MaxConcurrentStreams defaults to at least 100, per</code></span>
<span class="codeline" id="line-3912"><code>	// the HTTP/2 spec's recommendations.</code></span>
<span class="codeline" id="line-3913"><code>	MaxConcurrentStreams uint32</code></span>
<span class="codeline" id="line-3914"><code></code></span>
<span class="codeline" id="line-3915"><code>	// MaxDecoderHeaderTableSize optionally specifies the http2</code></span>
<span class="codeline" id="line-3916"><code>	// SETTINGS_HEADER_TABLE_SIZE to send in the initial settings frame. It</code></span>
<span class="codeline" id="line-3917"><code>	// informs the remote endpoint of the maximum size of the header compression</code></span>
<span class="codeline" id="line-3918"><code>	// table used to decode header blocks, in octets. If zero, the default value</code></span>
<span class="codeline" id="line-3919"><code>	// of 4096 is used.</code></span>
<span class="codeline" id="line-3920"><code>	MaxDecoderHeaderTableSize uint32</code></span>
<span class="codeline" id="line-3921"><code></code></span>
<span class="codeline" id="line-3922"><code>	// MaxEncoderHeaderTableSize optionally specifies an upper limit for the</code></span>
<span class="codeline" id="line-3923"><code>	// header compression table used for encoding request headers. Received</code></span>
<span class="codeline" id="line-3924"><code>	// SETTINGS_HEADER_TABLE_SIZE settings are capped at this limit. If zero,</code></span>
<span class="codeline" id="line-3925"><code>	// the default value of 4096 is used.</code></span>
<span class="codeline" id="line-3926"><code>	MaxEncoderHeaderTableSize uint32</code></span>
<span class="codeline" id="line-3927"><code></code></span>
<span class="codeline" id="line-3928"><code>	// MaxReadFrameSize optionally specifies the largest frame</code></span>
<span class="codeline" id="line-3929"><code>	// this server is willing to read. A valid value is between</code></span>
<span class="codeline" id="line-3930"><code>	// 16k and 16M, inclusive. If zero or otherwise invalid, a</code></span>
<span class="codeline" id="line-3931"><code>	// default value is used.</code></span>
<span class="codeline" id="line-3932"><code>	MaxReadFrameSize uint32</code></span>
<span class="codeline" id="line-3933"><code></code></span>
<span class="codeline" id="line-3934"><code>	// PermitProhibitedCipherSuites, if true, permits the use of</code></span>
<span class="codeline" id="line-3935"><code>	// cipher suites prohibited by the HTTP/2 spec.</code></span>
<span class="codeline" id="line-3936"><code>	PermitProhibitedCipherSuites bool</code></span>
<span class="codeline" id="line-3937"><code></code></span>
<span class="codeline" id="line-3938"><code>	// IdleTimeout specifies how long until idle clients should be</code></span>
<span class="codeline" id="line-3939"><code>	// closed with a GOAWAY frame. PING frames are not considered</code></span>
<span class="codeline" id="line-3940"><code>	// activity for the purposes of IdleTimeout.</code></span>
<span class="codeline" id="line-3941"><code>	IdleTimeout time.Duration</code></span>
<span class="codeline" id="line-3942"><code></code></span>
<span class="codeline" id="line-3943"><code>	// MaxUploadBufferPerConnection is the size of the initial flow</code></span>
<span class="codeline" id="line-3944"><code>	// control window for each connections. The HTTP/2 spec does not</code></span>
<span class="codeline" id="line-3945"><code>	// allow this to be smaller than 65535 or larger than 2^32-1.</code></span>
<span class="codeline" id="line-3946"><code>	// If the value is outside this range, a default value will be</code></span>
<span class="codeline" id="line-3947"><code>	// used instead.</code></span>
<span class="codeline" id="line-3948"><code>	MaxUploadBufferPerConnection int32</code></span>
<span class="codeline" id="line-3949"><code></code></span>
<span class="codeline" id="line-3950"><code>	// MaxUploadBufferPerStream is the size of the initial flow control</code></span>
<span class="codeline" id="line-3951"><code>	// window for each stream. The HTTP/2 spec does not allow this to</code></span>
<span class="codeline" id="line-3952"><code>	// be larger than 2^32-1. If the value is zero or larger than the</code></span>
<span class="codeline" id="line-3953"><code>	// maximum, a default value will be used instead.</code></span>
<span class="codeline" id="line-3954"><code>	MaxUploadBufferPerStream int32</code></span>
<span class="codeline" id="line-3955"><code></code></span>
<span class="codeline" id="line-3956"><code>	// NewWriteScheduler constructs a write scheduler for a connection.</code></span>
<span class="codeline" id="line-3957"><code>	// If nil, a default scheduler is chosen.</code></span>
<span class="codeline" id="line-3958"><code>	NewWriteScheduler func() http2WriteScheduler</code></span>
<span class="codeline" id="line-3959"><code></code></span>
<span class="codeline" id="line-3960"><code>	// CountError, if non-nil, is called on HTTP/2 server errors.</code></span>
<span class="codeline" id="line-3961"><code>	// It's intended to increment a metric for monitoring, such</code></span>
<span class="codeline" id="line-3962"><code>	// as an expvar or Prometheus metric.</code></span>
<span class="codeline" id="line-3963"><code>	// The errType consists of only ASCII word characters.</code></span>
<span class="codeline" id="line-3964"><code>	CountError func(errType string)</code></span>
<span class="codeline" id="line-3965"><code></code></span>
<span class="codeline" id="line-3966"><code>	// Internal state. This is a pointer (rather than embedded directly)</code></span>
<span class="codeline" id="line-3967"><code>	// so that we don't embed a Mutex in this struct, which will make the</code></span>
<span class="codeline" id="line-3968"><code>	// struct non-copyable, which might break some callers.</code></span>
<span class="codeline" id="line-3969"><code>	state *http2serverInternalState</code></span>
<span class="codeline" id="line-3970"><code>}</code></span>
<span class="codeline" id="line-3971"><code></code></span>
<span class="codeline" id="line-3972"><code>func (s *http2Server) initialConnRecvWindowSize() int32 {</code></span>
<span class="codeline" id="line-3973"><code>	if s.MaxUploadBufferPerConnection &gt;= http2initialWindowSize {</code></span>
<span class="codeline" id="line-3974"><code>		return s.MaxUploadBufferPerConnection</code></span>
<span class="codeline" id="line-3975"><code>	}</code></span>
<span class="codeline" id="line-3976"><code>	return 1 &lt;&lt; 20</code></span>
<span class="codeline" id="line-3977"><code>}</code></span>
<span class="codeline" id="line-3978"><code></code></span>
<span class="codeline" id="line-3979"><code>func (s *http2Server) initialStreamRecvWindowSize() int32 {</code></span>
<span class="codeline" id="line-3980"><code>	if s.MaxUploadBufferPerStream &gt; 0 {</code></span>
<span class="codeline" id="line-3981"><code>		return s.MaxUploadBufferPerStream</code></span>
<span class="codeline" id="line-3982"><code>	}</code></span>
<span class="codeline" id="line-3983"><code>	return 1 &lt;&lt; 20</code></span>
<span class="codeline" id="line-3984"><code>}</code></span>
<span class="codeline" id="line-3985"><code></code></span>
<span class="codeline" id="line-3986"><code>func (s *http2Server) maxReadFrameSize() uint32 {</code></span>
<span class="codeline" id="line-3987"><code>	if v := s.MaxReadFrameSize; v &gt;= http2minMaxFrameSize &amp;&amp; v &lt;= http2maxFrameSize {</code></span>
<span class="codeline" id="line-3988"><code>		return v</code></span>
<span class="codeline" id="line-3989"><code>	}</code></span>
<span class="codeline" id="line-3990"><code>	return http2defaultMaxReadFrameSize</code></span>
<span class="codeline" id="line-3991"><code>}</code></span>
<span class="codeline" id="line-3992"><code></code></span>
<span class="codeline" id="line-3993"><code>func (s *http2Server) maxConcurrentStreams() uint32 {</code></span>
<span class="codeline" id="line-3994"><code>	if v := s.MaxConcurrentStreams; v &gt; 0 {</code></span>
<span class="codeline" id="line-3995"><code>		return v</code></span>
<span class="codeline" id="line-3996"><code>	}</code></span>
<span class="codeline" id="line-3997"><code>	return http2defaultMaxStreams</code></span>
<span class="codeline" id="line-3998"><code>}</code></span>
<span class="codeline" id="line-3999"><code></code></span>
<span class="codeline" id="line-4000"><code>func (s *http2Server) maxDecoderHeaderTableSize() uint32 {</code></span>
<span class="codeline" id="line-4001"><code>	if v := s.MaxDecoderHeaderTableSize; v &gt; 0 {</code></span>
<span class="codeline" id="line-4002"><code>		return v</code></span>
<span class="codeline" id="line-4003"><code>	}</code></span>
<span class="codeline" id="line-4004"><code>	return http2initialHeaderTableSize</code></span>
<span class="codeline" id="line-4005"><code>}</code></span>
<span class="codeline" id="line-4006"><code></code></span>
<span class="codeline" id="line-4007"><code>func (s *http2Server) maxEncoderHeaderTableSize() uint32 {</code></span>
<span class="codeline" id="line-4008"><code>	if v := s.MaxEncoderHeaderTableSize; v &gt; 0 {</code></span>
<span class="codeline" id="line-4009"><code>		return v</code></span>
<span class="codeline" id="line-4010"><code>	}</code></span>
<span class="codeline" id="line-4011"><code>	return http2initialHeaderTableSize</code></span>
<span class="codeline" id="line-4012"><code>}</code></span>
<span class="codeline" id="line-4013"><code></code></span>
<span class="codeline" id="line-4014"><code>// maxQueuedControlFrames is the maximum number of control frames like</code></span>
<span class="codeline" id="line-4015"><code>// SETTINGS, PING and RST_STREAM that will be queued for writing before</code></span>
<span class="codeline" id="line-4016"><code>// the connection is closed to prevent memory exhaustion attacks.</code></span>
<span class="codeline" id="line-4017"><code>func (s *http2Server) maxQueuedControlFrames() int {</code></span>
<span class="codeline" id="line-4018"><code>	// TODO: if anybody asks, add a Server field, and remember to define the</code></span>
<span class="codeline" id="line-4019"><code>	// behavior of negative values.</code></span>
<span class="codeline" id="line-4020"><code>	return http2maxQueuedControlFrames</code></span>
<span class="codeline" id="line-4021"><code>}</code></span>
<span class="codeline" id="line-4022"><code></code></span>
<span class="codeline" id="line-4023"><code>type http2serverInternalState struct {</code></span>
<span class="codeline" id="line-4024"><code>	mu          sync.Mutex</code></span>
<span class="codeline" id="line-4025"><code>	activeConns map[*http2serverConn]struct{}</code></span>
<span class="codeline" id="line-4026"><code>}</code></span>
<span class="codeline" id="line-4027"><code></code></span>
<span class="codeline" id="line-4028"><code>func (s *http2serverInternalState) registerConn(sc *http2serverConn) {</code></span>
<span class="codeline" id="line-4029"><code>	if s == nil {</code></span>
<span class="codeline" id="line-4030"><code>		return // if the Server was used without calling ConfigureServer</code></span>
<span class="codeline" id="line-4031"><code>	}</code></span>
<span class="codeline" id="line-4032"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-4033"><code>	s.activeConns[sc] = struct{}{}</code></span>
<span class="codeline" id="line-4034"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-4035"><code>}</code></span>
<span class="codeline" id="line-4036"><code></code></span>
<span class="codeline" id="line-4037"><code>func (s *http2serverInternalState) unregisterConn(sc *http2serverConn) {</code></span>
<span class="codeline" id="line-4038"><code>	if s == nil {</code></span>
<span class="codeline" id="line-4039"><code>		return // if the Server was used without calling ConfigureServer</code></span>
<span class="codeline" id="line-4040"><code>	}</code></span>
<span class="codeline" id="line-4041"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-4042"><code>	delete(s.activeConns, sc)</code></span>
<span class="codeline" id="line-4043"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-4044"><code>}</code></span>
<span class="codeline" id="line-4045"><code></code></span>
<span class="codeline" id="line-4046"><code>func (s *http2serverInternalState) startGracefulShutdown() {</code></span>
<span class="codeline" id="line-4047"><code>	if s == nil {</code></span>
<span class="codeline" id="line-4048"><code>		return // if the Server was used without calling ConfigureServer</code></span>
<span class="codeline" id="line-4049"><code>	}</code></span>
<span class="codeline" id="line-4050"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-4051"><code>	for sc := range s.activeConns {</code></span>
<span class="codeline" id="line-4052"><code>		sc.startGracefulShutdown()</code></span>
<span class="codeline" id="line-4053"><code>	}</code></span>
<span class="codeline" id="line-4054"><code>	s.mu.Unlock()</code></span>
<span class="codeline" id="line-4055"><code>}</code></span>
<span class="codeline" id="line-4056"><code></code></span>
<span class="codeline" id="line-4057"><code>// ConfigureServer adds HTTP/2 support to a net/http Server.</code></span>
<span class="codeline" id="line-4058"><code>//</code></span>
<span class="codeline" id="line-4059"><code>// The configuration conf may be nil.</code></span>
<span class="codeline" id="line-4060"><code>//</code></span>
<span class="codeline" id="line-4061"><code>// ConfigureServer must be called before s begins serving.</code></span>
<span class="codeline" id="line-4062"><code>func http2ConfigureServer(s *Server, conf *http2Server) error {</code></span>
<span class="codeline" id="line-4063"><code>	if s == nil {</code></span>
<span class="codeline" id="line-4064"><code>		panic("nil *http.Server")</code></span>
<span class="codeline" id="line-4065"><code>	}</code></span>
<span class="codeline" id="line-4066"><code>	if conf == nil {</code></span>
<span class="codeline" id="line-4067"><code>		conf = new(http2Server)</code></span>
<span class="codeline" id="line-4068"><code>	}</code></span>
<span class="codeline" id="line-4069"><code>	conf.state = &amp;http2serverInternalState{activeConns: make(map[*http2serverConn]struct{})}</code></span>
<span class="codeline" id="line-4070"><code>	if h1, h2 := s, conf; h2.IdleTimeout == 0 {</code></span>
<span class="codeline" id="line-4071"><code>		if h1.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-4072"><code>			h2.IdleTimeout = h1.IdleTimeout</code></span>
<span class="codeline" id="line-4073"><code>		} else {</code></span>
<span class="codeline" id="line-4074"><code>			h2.IdleTimeout = h1.ReadTimeout</code></span>
<span class="codeline" id="line-4075"><code>		}</code></span>
<span class="codeline" id="line-4076"><code>	}</code></span>
<span class="codeline" id="line-4077"><code>	s.RegisterOnShutdown(conf.state.startGracefulShutdown)</code></span>
<span class="codeline" id="line-4078"><code></code></span>
<span class="codeline" id="line-4079"><code>	if s.TLSConfig == nil {</code></span>
<span class="codeline" id="line-4080"><code>		s.TLSConfig = new(tls.Config)</code></span>
<span class="codeline" id="line-4081"><code>	} else if s.TLSConfig.CipherSuites != nil &amp;&amp; s.TLSConfig.MinVersion &lt; tls.VersionTLS13 {</code></span>
<span class="codeline" id="line-4082"><code>		// If they already provided a TLS 1.0–1.2 CipherSuite list, return an</code></span>
<span class="codeline" id="line-4083"><code>		// error if it is missing ECDHE_RSA_WITH_AES_128_GCM_SHA256 or</code></span>
<span class="codeline" id="line-4084"><code>		// ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.</code></span>
<span class="codeline" id="line-4085"><code>		haveRequired := false</code></span>
<span class="codeline" id="line-4086"><code>		for _, cs := range s.TLSConfig.CipherSuites {</code></span>
<span class="codeline" id="line-4087"><code>			switch cs {</code></span>
<span class="codeline" id="line-4088"><code>			case tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</code></span>
<span class="codeline" id="line-4089"><code>				// Alternative MTI cipher to not discourage ECDSA-only servers.</code></span>
<span class="codeline" id="line-4090"><code>				// See http://golang.org/cl/30721 for further information.</code></span>
<span class="codeline" id="line-4091"><code>				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:</code></span>
<span class="codeline" id="line-4092"><code>				haveRequired = true</code></span>
<span class="codeline" id="line-4093"><code>			}</code></span>
<span class="codeline" id="line-4094"><code>		}</code></span>
<span class="codeline" id="line-4095"><code>		if !haveRequired {</code></span>
<span class="codeline" id="line-4096"><code>			return fmt.Errorf("http2: TLSConfig.CipherSuites is missing an HTTP/2-required AES_128_GCM_SHA256 cipher (need at least one of TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 or TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)")</code></span>
<span class="codeline" id="line-4097"><code>		}</code></span>
<span class="codeline" id="line-4098"><code>	}</code></span>
<span class="codeline" id="line-4099"><code></code></span>
<span class="codeline" id="line-4100"><code>	// Note: not setting MinVersion to tls.VersionTLS12,</code></span>
<span class="codeline" id="line-4101"><code>	// as we don't want to interfere with HTTP/1.1 traffic</code></span>
<span class="codeline" id="line-4102"><code>	// on the user's server. We enforce TLS 1.2 later once</code></span>
<span class="codeline" id="line-4103"><code>	// we accept a connection. Ideally this should be done</code></span>
<span class="codeline" id="line-4104"><code>	// during next-proto selection, but using TLS &lt;1.2 with</code></span>
<span class="codeline" id="line-4105"><code>	// HTTP/2 is still the client's bug.</code></span>
<span class="codeline" id="line-4106"><code></code></span>
<span class="codeline" id="line-4107"><code>	s.TLSConfig.PreferServerCipherSuites = true</code></span>
<span class="codeline" id="line-4108"><code></code></span>
<span class="codeline" id="line-4109"><code>	if !http2strSliceContains(s.TLSConfig.NextProtos, http2NextProtoTLS) {</code></span>
<span class="codeline" id="line-4110"><code>		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, http2NextProtoTLS)</code></span>
<span class="codeline" id="line-4111"><code>	}</code></span>
<span class="codeline" id="line-4112"><code>	if !http2strSliceContains(s.TLSConfig.NextProtos, "http/1.1") {</code></span>
<span class="codeline" id="line-4113"><code>		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "http/1.1")</code></span>
<span class="codeline" id="line-4114"><code>	}</code></span>
<span class="codeline" id="line-4115"><code></code></span>
<span class="codeline" id="line-4116"><code>	if s.TLSNextProto == nil {</code></span>
<span class="codeline" id="line-4117"><code>		s.TLSNextProto = map[string]func(*Server, *tls.Conn, Handler){}</code></span>
<span class="codeline" id="line-4118"><code>	}</code></span>
<span class="codeline" id="line-4119"><code>	protoHandler := func(hs *Server, c *tls.Conn, h Handler) {</code></span>
<span class="codeline" id="line-4120"><code>		if http2testHookOnConn != nil {</code></span>
<span class="codeline" id="line-4121"><code>			http2testHookOnConn()</code></span>
<span class="codeline" id="line-4122"><code>		}</code></span>
<span class="codeline" id="line-4123"><code>		// The TLSNextProto interface predates contexts, so</code></span>
<span class="codeline" id="line-4124"><code>		// the net/http package passes down its per-connection</code></span>
<span class="codeline" id="line-4125"><code>		// base context via an exported but unadvertised</code></span>
<span class="codeline" id="line-4126"><code>		// method on the Handler. This is for internal</code></span>
<span class="codeline" id="line-4127"><code>		// net/http&lt;=&gt;http2 use only.</code></span>
<span class="codeline" id="line-4128"><code>		var ctx context.Context</code></span>
<span class="codeline" id="line-4129"><code>		type baseContexter interface {</code></span>
<span class="codeline" id="line-4130"><code>			BaseContext() context.Context</code></span>
<span class="codeline" id="line-4131"><code>		}</code></span>
<span class="codeline" id="line-4132"><code>		if bc, ok := h.(baseContexter); ok {</code></span>
<span class="codeline" id="line-4133"><code>			ctx = bc.BaseContext()</code></span>
<span class="codeline" id="line-4134"><code>		}</code></span>
<span class="codeline" id="line-4135"><code>		conf.ServeConn(c, &amp;http2ServeConnOpts{</code></span>
<span class="codeline" id="line-4136"><code>			Context:    ctx,</code></span>
<span class="codeline" id="line-4137"><code>			Handler:    h,</code></span>
<span class="codeline" id="line-4138"><code>			BaseConfig: hs,</code></span>
<span class="codeline" id="line-4139"><code>		})</code></span>
<span class="codeline" id="line-4140"><code>	}</code></span>
<span class="codeline" id="line-4141"><code>	s.TLSNextProto[http2NextProtoTLS] = protoHandler</code></span>
<span class="codeline" id="line-4142"><code>	return nil</code></span>
<span class="codeline" id="line-4143"><code>}</code></span>
<span class="codeline" id="line-4144"><code></code></span>
<span class="codeline" id="line-4145"><code>// ServeConnOpts are options for the Server.ServeConn method.</code></span>
<span class="codeline" id="line-4146"><code>type http2ServeConnOpts struct {</code></span>
<span class="codeline" id="line-4147"><code>	// Context is the base context to use.</code></span>
<span class="codeline" id="line-4148"><code>	// If nil, context.Background is used.</code></span>
<span class="codeline" id="line-4149"><code>	Context context.Context</code></span>
<span class="codeline" id="line-4150"><code></code></span>
<span class="codeline" id="line-4151"><code>	// BaseConfig optionally sets the base configuration</code></span>
<span class="codeline" id="line-4152"><code>	// for values. If nil, defaults are used.</code></span>
<span class="codeline" id="line-4153"><code>	BaseConfig *Server</code></span>
<span class="codeline" id="line-4154"><code></code></span>
<span class="codeline" id="line-4155"><code>	// Handler specifies which handler to use for processing</code></span>
<span class="codeline" id="line-4156"><code>	// requests. If nil, BaseConfig.Handler is used. If BaseConfig</code></span>
<span class="codeline" id="line-4157"><code>	// or BaseConfig.Handler is nil, http.DefaultServeMux is used.</code></span>
<span class="codeline" id="line-4158"><code>	Handler Handler</code></span>
<span class="codeline" id="line-4159"><code></code></span>
<span class="codeline" id="line-4160"><code>	// UpgradeRequest is an initial request received on a connection</code></span>
<span class="codeline" id="line-4161"><code>	// undergoing an h2c upgrade. The request body must have been</code></span>
<span class="codeline" id="line-4162"><code>	// completely read from the connection before calling ServeConn,</code></span>
<span class="codeline" id="line-4163"><code>	// and the 101 Switching Protocols response written.</code></span>
<span class="codeline" id="line-4164"><code>	UpgradeRequest *Request</code></span>
<span class="codeline" id="line-4165"><code></code></span>
<span class="codeline" id="line-4166"><code>	// Settings is the decoded contents of the HTTP2-Settings header</code></span>
<span class="codeline" id="line-4167"><code>	// in an h2c upgrade request.</code></span>
<span class="codeline" id="line-4168"><code>	Settings []byte</code></span>
<span class="codeline" id="line-4169"><code></code></span>
<span class="codeline" id="line-4170"><code>	// SawClientPreface is set if the HTTP/2 connection preface</code></span>
<span class="codeline" id="line-4171"><code>	// has already been read from the connection.</code></span>
<span class="codeline" id="line-4172"><code>	SawClientPreface bool</code></span>
<span class="codeline" id="line-4173"><code>}</code></span>
<span class="codeline" id="line-4174"><code></code></span>
<span class="codeline" id="line-4175"><code>func (o *http2ServeConnOpts) context() context.Context {</code></span>
<span class="codeline" id="line-4176"><code>	if o != nil &amp;&amp; o.Context != nil {</code></span>
<span class="codeline" id="line-4177"><code>		return o.Context</code></span>
<span class="codeline" id="line-4178"><code>	}</code></span>
<span class="codeline" id="line-4179"><code>	return context.Background()</code></span>
<span class="codeline" id="line-4180"><code>}</code></span>
<span class="codeline" id="line-4181"><code></code></span>
<span class="codeline" id="line-4182"><code>func (o *http2ServeConnOpts) baseConfig() *Server {</code></span>
<span class="codeline" id="line-4183"><code>	if o != nil &amp;&amp; o.BaseConfig != nil {</code></span>
<span class="codeline" id="line-4184"><code>		return o.BaseConfig</code></span>
<span class="codeline" id="line-4185"><code>	}</code></span>
<span class="codeline" id="line-4186"><code>	return new(Server)</code></span>
<span class="codeline" id="line-4187"><code>}</code></span>
<span class="codeline" id="line-4188"><code></code></span>
<span class="codeline" id="line-4189"><code>func (o *http2ServeConnOpts) handler() Handler {</code></span>
<span class="codeline" id="line-4190"><code>	if o != nil {</code></span>
<span class="codeline" id="line-4191"><code>		if o.Handler != nil {</code></span>
<span class="codeline" id="line-4192"><code>			return o.Handler</code></span>
<span class="codeline" id="line-4193"><code>		}</code></span>
<span class="codeline" id="line-4194"><code>		if o.BaseConfig != nil &amp;&amp; o.BaseConfig.Handler != nil {</code></span>
<span class="codeline" id="line-4195"><code>			return o.BaseConfig.Handler</code></span>
<span class="codeline" id="line-4196"><code>		}</code></span>
<span class="codeline" id="line-4197"><code>	}</code></span>
<span class="codeline" id="line-4198"><code>	return DefaultServeMux</code></span>
<span class="codeline" id="line-4199"><code>}</code></span>
<span class="codeline" id="line-4200"><code></code></span>
<span class="codeline" id="line-4201"><code>// ServeConn serves HTTP/2 requests on the provided connection and</code></span>
<span class="codeline" id="line-4202"><code>// blocks until the connection is no longer readable.</code></span>
<span class="codeline" id="line-4203"><code>//</code></span>
<span class="codeline" id="line-4204"><code>// ServeConn starts speaking HTTP/2 assuming that c has not had any</code></span>
<span class="codeline" id="line-4205"><code>// reads or writes. It writes its initial settings frame and expects</code></span>
<span class="codeline" id="line-4206"><code>// to be able to read the preface and settings frame from the</code></span>
<span class="codeline" id="line-4207"><code>// client. If c has a ConnectionState method like a *tls.Conn, the</code></span>
<span class="codeline" id="line-4208"><code>// ConnectionState is used to verify the TLS ciphersuite and to set</code></span>
<span class="codeline" id="line-4209"><code>// the Request.TLS field in Handlers.</code></span>
<span class="codeline" id="line-4210"><code>//</code></span>
<span class="codeline" id="line-4211"><code>// ServeConn does not support h2c by itself. Any h2c support must be</code></span>
<span class="codeline" id="line-4212"><code>// implemented in terms of providing a suitably-behaving net.Conn.</code></span>
<span class="codeline" id="line-4213"><code>//</code></span>
<span class="codeline" id="line-4214"><code>// The opts parameter is optional. If nil, default values are used.</code></span>
<span class="codeline" id="line-4215"><code>func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {</code></span>
<span class="codeline" id="line-4216"><code>	baseCtx, cancel := http2serverConnBaseContext(c, opts)</code></span>
<span class="codeline" id="line-4217"><code>	defer cancel()</code></span>
<span class="codeline" id="line-4218"><code></code></span>
<span class="codeline" id="line-4219"><code>	sc := &amp;http2serverConn{</code></span>
<span class="codeline" id="line-4220"><code>		srv:                         s,</code></span>
<span class="codeline" id="line-4221"><code>		hs:                          opts.baseConfig(),</code></span>
<span class="codeline" id="line-4222"><code>		conn:                        c,</code></span>
<span class="codeline" id="line-4223"><code>		baseCtx:                     baseCtx,</code></span>
<span class="codeline" id="line-4224"><code>		remoteAddrStr:               c.RemoteAddr().String(),</code></span>
<span class="codeline" id="line-4225"><code>		bw:                          http2newBufferedWriter(c),</code></span>
<span class="codeline" id="line-4226"><code>		handler:                     opts.handler(),</code></span>
<span class="codeline" id="line-4227"><code>		streams:                     make(map[uint32]*http2stream),</code></span>
<span class="codeline" id="line-4228"><code>		readFrameCh:                 make(chan http2readFrameResult),</code></span>
<span class="codeline" id="line-4229"><code>		wantWriteFrameCh:            make(chan http2FrameWriteRequest, 8),</code></span>
<span class="codeline" id="line-4230"><code>		serveMsgCh:                  make(chan interface{}, 8),</code></span>
<span class="codeline" id="line-4231"><code>		wroteFrameCh:                make(chan http2frameWriteResult, 1), // buffered; one send in writeFrameAsync</code></span>
<span class="codeline" id="line-4232"><code>		bodyReadCh:                  make(chan http2bodyReadMsg),         // buffering doesn't matter either way</code></span>
<span class="codeline" id="line-4233"><code>		doneServing:                 make(chan struct{}),</code></span>
<span class="codeline" id="line-4234"><code>		clientMaxStreams:            math.MaxUint32, // Section 6.5.2: "Initially, there is no limit to this value"</code></span>
<span class="codeline" id="line-4235"><code>		advMaxStreams:               s.maxConcurrentStreams(),</code></span>
<span class="codeline" id="line-4236"><code>		initialStreamSendWindowSize: http2initialWindowSize,</code></span>
<span class="codeline" id="line-4237"><code>		maxFrameSize:                http2initialMaxFrameSize,</code></span>
<span class="codeline" id="line-4238"><code>		serveG:                      http2newGoroutineLock(),</code></span>
<span class="codeline" id="line-4239"><code>		pushEnabled:                 true,</code></span>
<span class="codeline" id="line-4240"><code>		sawClientPreface:            opts.SawClientPreface,</code></span>
<span class="codeline" id="line-4241"><code>	}</code></span>
<span class="codeline" id="line-4242"><code></code></span>
<span class="codeline" id="line-4243"><code>	s.state.registerConn(sc)</code></span>
<span class="codeline" id="line-4244"><code>	defer s.state.unregisterConn(sc)</code></span>
<span class="codeline" id="line-4245"><code></code></span>
<span class="codeline" id="line-4246"><code>	// The net/http package sets the write deadline from the</code></span>
<span class="codeline" id="line-4247"><code>	// http.Server.WriteTimeout during the TLS handshake, but then</code></span>
<span class="codeline" id="line-4248"><code>	// passes the connection off to us with the deadline already set.</code></span>
<span class="codeline" id="line-4249"><code>	// Write deadlines are set per stream in serverConn.newStream.</code></span>
<span class="codeline" id="line-4250"><code>	// Disarm the net.Conn write deadline here.</code></span>
<span class="codeline" id="line-4251"><code>	if sc.hs.WriteTimeout != 0 {</code></span>
<span class="codeline" id="line-4252"><code>		sc.conn.SetWriteDeadline(time.Time{})</code></span>
<span class="codeline" id="line-4253"><code>	}</code></span>
<span class="codeline" id="line-4254"><code></code></span>
<span class="codeline" id="line-4255"><code>	if s.NewWriteScheduler != nil {</code></span>
<span class="codeline" id="line-4256"><code>		sc.writeSched = s.NewWriteScheduler()</code></span>
<span class="codeline" id="line-4257"><code>	} else {</code></span>
<span class="codeline" id="line-4258"><code>		sc.writeSched = http2newRoundRobinWriteScheduler()</code></span>
<span class="codeline" id="line-4259"><code>	}</code></span>
<span class="codeline" id="line-4260"><code></code></span>
<span class="codeline" id="line-4261"><code>	// These start at the RFC-specified defaults. If there is a higher</code></span>
<span class="codeline" id="line-4262"><code>	// configured value for inflow, that will be updated when we send a</code></span>
<span class="codeline" id="line-4263"><code>	// WINDOW_UPDATE shortly after sending SETTINGS.</code></span>
<span class="codeline" id="line-4264"><code>	sc.flow.add(http2initialWindowSize)</code></span>
<span class="codeline" id="line-4265"><code>	sc.inflow.init(http2initialWindowSize)</code></span>
<span class="codeline" id="line-4266"><code>	sc.hpackEncoder = hpack.NewEncoder(&amp;sc.headerWriteBuf)</code></span>
<span class="codeline" id="line-4267"><code>	sc.hpackEncoder.SetMaxDynamicTableSizeLimit(s.maxEncoderHeaderTableSize())</code></span>
<span class="codeline" id="line-4268"><code></code></span>
<span class="codeline" id="line-4269"><code>	fr := http2NewFramer(sc.bw, c)</code></span>
<span class="codeline" id="line-4270"><code>	if s.CountError != nil {</code></span>
<span class="codeline" id="line-4271"><code>		fr.countError = s.CountError</code></span>
<span class="codeline" id="line-4272"><code>	}</code></span>
<span class="codeline" id="line-4273"><code>	fr.ReadMetaHeaders = hpack.NewDecoder(s.maxDecoderHeaderTableSize(), nil)</code></span>
<span class="codeline" id="line-4274"><code>	fr.MaxHeaderListSize = sc.maxHeaderListSize()</code></span>
<span class="codeline" id="line-4275"><code>	fr.SetMaxReadFrameSize(s.maxReadFrameSize())</code></span>
<span class="codeline" id="line-4276"><code>	sc.framer = fr</code></span>
<span class="codeline" id="line-4277"><code></code></span>
<span class="codeline" id="line-4278"><code>	if tc, ok := c.(http2connectionStater); ok {</code></span>
<span class="codeline" id="line-4279"><code>		sc.tlsState = new(tls.ConnectionState)</code></span>
<span class="codeline" id="line-4280"><code>		*sc.tlsState = tc.ConnectionState()</code></span>
<span class="codeline" id="line-4281"><code>		// 9.2 Use of TLS Features</code></span>
<span class="codeline" id="line-4282"><code>		// An implementation of HTTP/2 over TLS MUST use TLS</code></span>
<span class="codeline" id="line-4283"><code>		// 1.2 or higher with the restrictions on feature set</code></span>
<span class="codeline" id="line-4284"><code>		// and cipher suite described in this section. Due to</code></span>
<span class="codeline" id="line-4285"><code>		// implementation limitations, it might not be</code></span>
<span class="codeline" id="line-4286"><code>		// possible to fail TLS negotiation. An endpoint MUST</code></span>
<span class="codeline" id="line-4287"><code>		// immediately terminate an HTTP/2 connection that</code></span>
<span class="codeline" id="line-4288"><code>		// does not meet the TLS requirements described in</code></span>
<span class="codeline" id="line-4289"><code>		// this section with a connection error (Section</code></span>
<span class="codeline" id="line-4290"><code>		// 5.4.1) of type INADEQUATE_SECURITY.</code></span>
<span class="codeline" id="line-4291"><code>		if sc.tlsState.Version &lt; tls.VersionTLS12 {</code></span>
<span class="codeline" id="line-4292"><code>			sc.rejectConn(http2ErrCodeInadequateSecurity, "TLS version too low")</code></span>
<span class="codeline" id="line-4293"><code>			return</code></span>
<span class="codeline" id="line-4294"><code>		}</code></span>
<span class="codeline" id="line-4295"><code></code></span>
<span class="codeline" id="line-4296"><code>		if sc.tlsState.ServerName == "" {</code></span>
<span class="codeline" id="line-4297"><code>			// Client must use SNI, but we don't enforce that anymore,</code></span>
<span class="codeline" id="line-4298"><code>			// since it was causing problems when connecting to bare IP</code></span>
<span class="codeline" id="line-4299"><code>			// addresses during development.</code></span>
<span class="codeline" id="line-4300"><code>			//</code></span>
<span class="codeline" id="line-4301"><code>			// TODO: optionally enforce? Or enforce at the time we receive</code></span>
<span class="codeline" id="line-4302"><code>			// a new request, and verify the ServerName matches the :authority?</code></span>
<span class="codeline" id="line-4303"><code>			// But that precludes proxy situations, perhaps.</code></span>
<span class="codeline" id="line-4304"><code>			//</code></span>
<span class="codeline" id="line-4305"><code>			// So for now, do nothing here again.</code></span>
<span class="codeline" id="line-4306"><code>		}</code></span>
<span class="codeline" id="line-4307"><code></code></span>
<span class="codeline" id="line-4308"><code>		if !s.PermitProhibitedCipherSuites &amp;&amp; http2isBadCipher(sc.tlsState.CipherSuite) {</code></span>
<span class="codeline" id="line-4309"><code>			// "Endpoints MAY choose to generate a connection error</code></span>
<span class="codeline" id="line-4310"><code>			// (Section 5.4.1) of type INADEQUATE_SECURITY if one of</code></span>
<span class="codeline" id="line-4311"><code>			// the prohibited cipher suites are negotiated."</code></span>
<span class="codeline" id="line-4312"><code>			//</code></span>
<span class="codeline" id="line-4313"><code>			// We choose that. In my opinion, the spec is weak</code></span>
<span class="codeline" id="line-4314"><code>			// here. It also says both parties must support at least</code></span>
<span class="codeline" id="line-4315"><code>			// TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 so there's no</code></span>
<span class="codeline" id="line-4316"><code>			// excuses here. If we really must, we could allow an</code></span>
<span class="codeline" id="line-4317"><code>			// "AllowInsecureWeakCiphers" option on the server later.</code></span>
<span class="codeline" id="line-4318"><code>			// Let's see how it plays out first.</code></span>
<span class="codeline" id="line-4319"><code>			sc.rejectConn(http2ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite))</code></span>
<span class="codeline" id="line-4320"><code>			return</code></span>
<span class="codeline" id="line-4321"><code>		}</code></span>
<span class="codeline" id="line-4322"><code>	}</code></span>
<span class="codeline" id="line-4323"><code></code></span>
<span class="codeline" id="line-4324"><code>	if opts.Settings != nil {</code></span>
<span class="codeline" id="line-4325"><code>		fr := &amp;http2SettingsFrame{</code></span>
<span class="codeline" id="line-4326"><code>			http2FrameHeader: http2FrameHeader{valid: true},</code></span>
<span class="codeline" id="line-4327"><code>			p:                opts.Settings,</code></span>
<span class="codeline" id="line-4328"><code>		}</code></span>
<span class="codeline" id="line-4329"><code>		if err := fr.ForeachSetting(sc.processSetting); err != nil {</code></span>
<span class="codeline" id="line-4330"><code>			sc.rejectConn(http2ErrCodeProtocol, "invalid settings")</code></span>
<span class="codeline" id="line-4331"><code>			return</code></span>
<span class="codeline" id="line-4332"><code>		}</code></span>
<span class="codeline" id="line-4333"><code>		opts.Settings = nil</code></span>
<span class="codeline" id="line-4334"><code>	}</code></span>
<span class="codeline" id="line-4335"><code></code></span>
<span class="codeline" id="line-4336"><code>	if hook := http2testHookGetServerConn; hook != nil {</code></span>
<span class="codeline" id="line-4337"><code>		hook(sc)</code></span>
<span class="codeline" id="line-4338"><code>	}</code></span>
<span class="codeline" id="line-4339"><code></code></span>
<span class="codeline" id="line-4340"><code>	if opts.UpgradeRequest != nil {</code></span>
<span class="codeline" id="line-4341"><code>		sc.upgradeRequest(opts.UpgradeRequest)</code></span>
<span class="codeline" id="line-4342"><code>		opts.UpgradeRequest = nil</code></span>
<span class="codeline" id="line-4343"><code>	}</code></span>
<span class="codeline" id="line-4344"><code></code></span>
<span class="codeline" id="line-4345"><code>	sc.serve()</code></span>
<span class="codeline" id="line-4346"><code>}</code></span>
<span class="codeline" id="line-4347"><code></code></span>
<span class="codeline" id="line-4348"><code>func http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx context.Context, cancel func()) {</code></span>
<span class="codeline" id="line-4349"><code>	ctx, cancel = context.WithCancel(opts.context())</code></span>
<span class="codeline" id="line-4350"><code>	ctx = context.WithValue(ctx, LocalAddrContextKey, c.LocalAddr())</code></span>
<span class="codeline" id="line-4351"><code>	if hs := opts.baseConfig(); hs != nil {</code></span>
<span class="codeline" id="line-4352"><code>		ctx = context.WithValue(ctx, ServerContextKey, hs)</code></span>
<span class="codeline" id="line-4353"><code>	}</code></span>
<span class="codeline" id="line-4354"><code>	return</code></span>
<span class="codeline" id="line-4355"><code>}</code></span>
<span class="codeline" id="line-4356"><code></code></span>
<span class="codeline" id="line-4357"><code>func (sc *http2serverConn) rejectConn(err http2ErrCode, debug string) {</code></span>
<span class="codeline" id="line-4358"><code>	sc.vlogf("http2: server rejecting conn: %v, %s", err, debug)</code></span>
<span class="codeline" id="line-4359"><code>	// ignoring errors. hanging up anyway.</code></span>
<span class="codeline" id="line-4360"><code>	sc.framer.WriteGoAway(0, err, []byte(debug))</code></span>
<span class="codeline" id="line-4361"><code>	sc.bw.Flush()</code></span>
<span class="codeline" id="line-4362"><code>	sc.conn.Close()</code></span>
<span class="codeline" id="line-4363"><code>}</code></span>
<span class="codeline" id="line-4364"><code></code></span>
<span class="codeline" id="line-4365"><code>type http2serverConn struct {</code></span>
<span class="codeline" id="line-4366"><code>	// Immutable:</code></span>
<span class="codeline" id="line-4367"><code>	srv              *http2Server</code></span>
<span class="codeline" id="line-4368"><code>	hs               *Server</code></span>
<span class="codeline" id="line-4369"><code>	conn             net.Conn</code></span>
<span class="codeline" id="line-4370"><code>	bw               *http2bufferedWriter // writing to conn</code></span>
<span class="codeline" id="line-4371"><code>	handler          Handler</code></span>
<span class="codeline" id="line-4372"><code>	baseCtx          context.Context</code></span>
<span class="codeline" id="line-4373"><code>	framer           *http2Framer</code></span>
<span class="codeline" id="line-4374"><code>	doneServing      chan struct{}               // closed when serverConn.serve ends</code></span>
<span class="codeline" id="line-4375"><code>	readFrameCh      chan http2readFrameResult   // written by serverConn.readFrames</code></span>
<span class="codeline" id="line-4376"><code>	wantWriteFrameCh chan http2FrameWriteRequest // from handlers -&gt; serve</code></span>
<span class="codeline" id="line-4377"><code>	wroteFrameCh     chan http2frameWriteResult  // from writeFrameAsync -&gt; serve, tickles more frame writes</code></span>
<span class="codeline" id="line-4378"><code>	bodyReadCh       chan http2bodyReadMsg       // from handlers -&gt; serve</code></span>
<span class="codeline" id="line-4379"><code>	serveMsgCh       chan interface{}            // misc messages &amp; code to send to / run on the serve loop</code></span>
<span class="codeline" id="line-4380"><code>	flow             http2outflow                // conn-wide (not stream-specific) outbound flow control</code></span>
<span class="codeline" id="line-4381"><code>	inflow           http2inflow                 // conn-wide inbound flow control</code></span>
<span class="codeline" id="line-4382"><code>	tlsState         *tls.ConnectionState        // shared by all handlers, like net/http</code></span>
<span class="codeline" id="line-4383"><code>	remoteAddrStr    string</code></span>
<span class="codeline" id="line-4384"><code>	writeSched       http2WriteScheduler</code></span>
<span class="codeline" id="line-4385"><code></code></span>
<span class="codeline" id="line-4386"><code>	// Everything following is owned by the serve loop; use serveG.check():</code></span>
<span class="codeline" id="line-4387"><code>	serveG                      http2goroutineLock // used to verify funcs are on serve()</code></span>
<span class="codeline" id="line-4388"><code>	pushEnabled                 bool</code></span>
<span class="codeline" id="line-4389"><code>	sawClientPreface            bool // preface has already been read, used in h2c upgrade</code></span>
<span class="codeline" id="line-4390"><code>	sawFirstSettings            bool // got the initial SETTINGS frame after the preface</code></span>
<span class="codeline" id="line-4391"><code>	needToSendSettingsAck       bool</code></span>
<span class="codeline" id="line-4392"><code>	unackedSettings             int    // how many SETTINGS have we sent without ACKs?</code></span>
<span class="codeline" id="line-4393"><code>	queuedControlFrames         int    // control frames in the writeSched queue</code></span>
<span class="codeline" id="line-4394"><code>	clientMaxStreams            uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)</code></span>
<span class="codeline" id="line-4395"><code>	advMaxStreams               uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client</code></span>
<span class="codeline" id="line-4396"><code>	curClientStreams            uint32 // number of open streams initiated by the client</code></span>
<span class="codeline" id="line-4397"><code>	curPushedStreams            uint32 // number of open streams initiated by server push</code></span>
<span class="codeline" id="line-4398"><code>	curHandlers                 uint32 // number of running handler goroutines</code></span>
<span class="codeline" id="line-4399"><code>	maxClientStreamID           uint32 // max ever seen from client (odd), or 0 if there have been no client requests</code></span>
<span class="codeline" id="line-4400"><code>	maxPushPromiseID            uint32 // ID of the last push promise (even), or 0 if there have been no pushes</code></span>
<span class="codeline" id="line-4401"><code>	streams                     map[uint32]*http2stream</code></span>
<span class="codeline" id="line-4402"><code>	unstartedHandlers           []http2unstartedHandler</code></span>
<span class="codeline" id="line-4403"><code>	initialStreamSendWindowSize int32</code></span>
<span class="codeline" id="line-4404"><code>	maxFrameSize                int32</code></span>
<span class="codeline" id="line-4405"><code>	peerMaxHeaderListSize       uint32            // zero means unknown (default)</code></span>
<span class="codeline" id="line-4406"><code>	canonHeader                 map[string]string // http2-lower-case -&gt; Go-Canonical-Case</code></span>
<span class="codeline" id="line-4407"><code>	canonHeaderKeysSize         int               // canonHeader keys size in bytes</code></span>
<span class="codeline" id="line-4408"><code>	writingFrame                bool              // started writing a frame (on serve goroutine or separate)</code></span>
<span class="codeline" id="line-4409"><code>	writingFrameAsync           bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh</code></span>
<span class="codeline" id="line-4410"><code>	needsFrameFlush             bool              // last frame write wasn't a flush</code></span>
<span class="codeline" id="line-4411"><code>	inGoAway                    bool              // we've started to or sent GOAWAY</code></span>
<span class="codeline" id="line-4412"><code>	inFrameScheduleLoop         bool              // whether we're in the scheduleFrameWrite loop</code></span>
<span class="codeline" id="line-4413"><code>	needToSendGoAway            bool              // we need to schedule a GOAWAY frame write</code></span>
<span class="codeline" id="line-4414"><code>	goAwayCode                  http2ErrCode</code></span>
<span class="codeline" id="line-4415"><code>	shutdownTimer               *time.Timer // nil until used</code></span>
<span class="codeline" id="line-4416"><code>	idleTimer                   *time.Timer // nil if unused</code></span>
<span class="codeline" id="line-4417"><code></code></span>
<span class="codeline" id="line-4418"><code>	// Owned by the writeFrameAsync goroutine:</code></span>
<span class="codeline" id="line-4419"><code>	headerWriteBuf bytes.Buffer</code></span>
<span class="codeline" id="line-4420"><code>	hpackEncoder   *hpack.Encoder</code></span>
<span class="codeline" id="line-4421"><code></code></span>
<span class="codeline" id="line-4422"><code>	// Used by startGracefulShutdown.</code></span>
<span class="codeline" id="line-4423"><code>	shutdownOnce sync.Once</code></span>
<span class="codeline" id="line-4424"><code>}</code></span>
<span class="codeline" id="line-4425"><code></code></span>
<span class="codeline" id="line-4426"><code>func (sc *http2serverConn) maxHeaderListSize() uint32 {</code></span>
<span class="codeline" id="line-4427"><code>	n := sc.hs.MaxHeaderBytes</code></span>
<span class="codeline" id="line-4428"><code>	if n &lt;= 0 {</code></span>
<span class="codeline" id="line-4429"><code>		n = DefaultMaxHeaderBytes</code></span>
<span class="codeline" id="line-4430"><code>	}</code></span>
<span class="codeline" id="line-4431"><code>	// http2's count is in a slightly different unit and includes 32 bytes per pair.</code></span>
<span class="codeline" id="line-4432"><code>	// So, take the net/http.Server value and pad it up a bit, assuming 10 headers.</code></span>
<span class="codeline" id="line-4433"><code>	const perFieldOverhead = 32 // per http2 spec</code></span>
<span class="codeline" id="line-4434"><code>	const typicalHeaders = 10   // conservative</code></span>
<span class="codeline" id="line-4435"><code>	return uint32(n + typicalHeaders*perFieldOverhead)</code></span>
<span class="codeline" id="line-4436"><code>}</code></span>
<span class="codeline" id="line-4437"><code></code></span>
<span class="codeline" id="line-4438"><code>func (sc *http2serverConn) curOpenStreams() uint32 {</code></span>
<span class="codeline" id="line-4439"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4440"><code>	return sc.curClientStreams + sc.curPushedStreams</code></span>
<span class="codeline" id="line-4441"><code>}</code></span>
<span class="codeline" id="line-4442"><code></code></span>
<span class="codeline" id="line-4443"><code>// stream represents a stream. This is the minimal metadata needed by</code></span>
<span class="codeline" id="line-4444"><code>// the serve goroutine. Most of the actual stream state is owned by</code></span>
<span class="codeline" id="line-4445"><code>// the http.Handler's goroutine in the responseWriter. Because the</code></span>
<span class="codeline" id="line-4446"><code>// responseWriter's responseWriterState is recycled at the end of a</code></span>
<span class="codeline" id="line-4447"><code>// handler, this struct intentionally has no pointer to the</code></span>
<span class="codeline" id="line-4448"><code>// *responseWriter{,State} itself, as the Handler ending nils out the</code></span>
<span class="codeline" id="line-4449"><code>// responseWriter's state field.</code></span>
<span class="codeline" id="line-4450"><code>type http2stream struct {</code></span>
<span class="codeline" id="line-4451"><code>	// immutable:</code></span>
<span class="codeline" id="line-4452"><code>	sc        *http2serverConn</code></span>
<span class="codeline" id="line-4453"><code>	id        uint32</code></span>
<span class="codeline" id="line-4454"><code>	body      *http2pipe       // non-nil if expecting DATA frames</code></span>
<span class="codeline" id="line-4455"><code>	cw        http2closeWaiter // closed wait stream transitions to closed state</code></span>
<span class="codeline" id="line-4456"><code>	ctx       context.Context</code></span>
<span class="codeline" id="line-4457"><code>	cancelCtx func()</code></span>
<span class="codeline" id="line-4458"><code></code></span>
<span class="codeline" id="line-4459"><code>	// owned by serverConn's serve loop:</code></span>
<span class="codeline" id="line-4460"><code>	bodyBytes        int64        // body bytes seen so far</code></span>
<span class="codeline" id="line-4461"><code>	declBodyBytes    int64        // or -1 if undeclared</code></span>
<span class="codeline" id="line-4462"><code>	flow             http2outflow // limits writing from Handler to client</code></span>
<span class="codeline" id="line-4463"><code>	inflow           http2inflow  // what the client is allowed to POST/etc to us</code></span>
<span class="codeline" id="line-4464"><code>	state            http2streamState</code></span>
<span class="codeline" id="line-4465"><code>	resetQueued      bool        // RST_STREAM queued for write; set by sc.resetStream</code></span>
<span class="codeline" id="line-4466"><code>	gotTrailerHeader bool        // HEADER frame for trailers was seen</code></span>
<span class="codeline" id="line-4467"><code>	wroteHeaders     bool        // whether we wrote headers (not status 100)</code></span>
<span class="codeline" id="line-4468"><code>	readDeadline     *time.Timer // nil if unused</code></span>
<span class="codeline" id="line-4469"><code>	writeDeadline    *time.Timer // nil if unused</code></span>
<span class="codeline" id="line-4470"><code>	closeErr         error       // set before cw is closed</code></span>
<span class="codeline" id="line-4471"><code></code></span>
<span class="codeline" id="line-4472"><code>	trailer    Header // accumulated trailers</code></span>
<span class="codeline" id="line-4473"><code>	reqTrailer Header // handler's Request.Trailer</code></span>
<span class="codeline" id="line-4474"><code>}</code></span>
<span class="codeline" id="line-4475"><code></code></span>
<span class="codeline" id="line-4476"><code>func (sc *http2serverConn) Framer() *http2Framer { return sc.framer }</code></span>
<span class="codeline" id="line-4477"><code></code></span>
<span class="codeline" id="line-4478"><code>func (sc *http2serverConn) CloseConn() error { return sc.conn.Close() }</code></span>
<span class="codeline" id="line-4479"><code></code></span>
<span class="codeline" id="line-4480"><code>func (sc *http2serverConn) Flush() error { return sc.bw.Flush() }</code></span>
<span class="codeline" id="line-4481"><code></code></span>
<span class="codeline" id="line-4482"><code>func (sc *http2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) {</code></span>
<span class="codeline" id="line-4483"><code>	return sc.hpackEncoder, &amp;sc.headerWriteBuf</code></span>
<span class="codeline" id="line-4484"><code>}</code></span>
<span class="codeline" id="line-4485"><code></code></span>
<span class="codeline" id="line-4486"><code>func (sc *http2serverConn) state(streamID uint32) (http2streamState, *http2stream) {</code></span>
<span class="codeline" id="line-4487"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4488"><code>	// http://tools.ietf.org/html/rfc7540#section-5.1</code></span>
<span class="codeline" id="line-4489"><code>	if st, ok := sc.streams[streamID]; ok {</code></span>
<span class="codeline" id="line-4490"><code>		return st.state, st</code></span>
<span class="codeline" id="line-4491"><code>	}</code></span>
<span class="codeline" id="line-4492"><code>	// "The first use of a new stream identifier implicitly closes all</code></span>
<span class="codeline" id="line-4493"><code>	// streams in the "idle" state that might have been initiated by</code></span>
<span class="codeline" id="line-4494"><code>	// that peer with a lower-valued stream identifier. For example, if</code></span>
<span class="codeline" id="line-4495"><code>	// a client sends a HEADERS frame on stream 7 without ever sending a</code></span>
<span class="codeline" id="line-4496"><code>	// frame on stream 5, then stream 5 transitions to the "closed"</code></span>
<span class="codeline" id="line-4497"><code>	// state when the first frame for stream 7 is sent or received."</code></span>
<span class="codeline" id="line-4498"><code>	if streamID%2 == 1 {</code></span>
<span class="codeline" id="line-4499"><code>		if streamID &lt;= sc.maxClientStreamID {</code></span>
<span class="codeline" id="line-4500"><code>			return http2stateClosed, nil</code></span>
<span class="codeline" id="line-4501"><code>		}</code></span>
<span class="codeline" id="line-4502"><code>	} else {</code></span>
<span class="codeline" id="line-4503"><code>		if streamID &lt;= sc.maxPushPromiseID {</code></span>
<span class="codeline" id="line-4504"><code>			return http2stateClosed, nil</code></span>
<span class="codeline" id="line-4505"><code>		}</code></span>
<span class="codeline" id="line-4506"><code>	}</code></span>
<span class="codeline" id="line-4507"><code>	return http2stateIdle, nil</code></span>
<span class="codeline" id="line-4508"><code>}</code></span>
<span class="codeline" id="line-4509"><code></code></span>
<span class="codeline" id="line-4510"><code>// setConnState calls the net/http ConnState hook for this connection, if configured.</code></span>
<span class="codeline" id="line-4511"><code>// Note that the net/http package does StateNew and StateClosed for us.</code></span>
<span class="codeline" id="line-4512"><code>// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.</code></span>
<span class="codeline" id="line-4513"><code>func (sc *http2serverConn) setConnState(state ConnState) {</code></span>
<span class="codeline" id="line-4514"><code>	if sc.hs.ConnState != nil {</code></span>
<span class="codeline" id="line-4515"><code>		sc.hs.ConnState(sc.conn, state)</code></span>
<span class="codeline" id="line-4516"><code>	}</code></span>
<span class="codeline" id="line-4517"><code>}</code></span>
<span class="codeline" id="line-4518"><code></code></span>
<span class="codeline" id="line-4519"><code>func (sc *http2serverConn) vlogf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-4520"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-4521"><code>		sc.logf(format, args...)</code></span>
<span class="codeline" id="line-4522"><code>	}</code></span>
<span class="codeline" id="line-4523"><code>}</code></span>
<span class="codeline" id="line-4524"><code></code></span>
<span class="codeline" id="line-4525"><code>func (sc *http2serverConn) logf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-4526"><code>	if lg := sc.hs.ErrorLog; lg != nil {</code></span>
<span class="codeline" id="line-4527"><code>		lg.Printf(format, args...)</code></span>
<span class="codeline" id="line-4528"><code>	} else {</code></span>
<span class="codeline" id="line-4529"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-4530"><code>	}</code></span>
<span class="codeline" id="line-4531"><code>}</code></span>
<span class="codeline" id="line-4532"><code></code></span>
<span class="codeline" id="line-4533"><code>// errno returns v's underlying uintptr, else 0.</code></span>
<span class="codeline" id="line-4534"><code>//</code></span>
<span class="codeline" id="line-4535"><code>// TODO: remove this helper function once http2 can use build</code></span>
<span class="codeline" id="line-4536"><code>// tags. See comment in isClosedConnError.</code></span>
<span class="codeline" id="line-4537"><code>func http2errno(v error) uintptr {</code></span>
<span class="codeline" id="line-4538"><code>	if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr {</code></span>
<span class="codeline" id="line-4539"><code>		return uintptr(rv.Uint())</code></span>
<span class="codeline" id="line-4540"><code>	}</code></span>
<span class="codeline" id="line-4541"><code>	return 0</code></span>
<span class="codeline" id="line-4542"><code>}</code></span>
<span class="codeline" id="line-4543"><code></code></span>
<span class="codeline" id="line-4544"><code>// isClosedConnError reports whether err is an error from use of a closed</code></span>
<span class="codeline" id="line-4545"><code>// network connection.</code></span>
<span class="codeline" id="line-4546"><code>func http2isClosedConnError(err error) bool {</code></span>
<span class="codeline" id="line-4547"><code>	if err == nil {</code></span>
<span class="codeline" id="line-4548"><code>		return false</code></span>
<span class="codeline" id="line-4549"><code>	}</code></span>
<span class="codeline" id="line-4550"><code></code></span>
<span class="codeline" id="line-4551"><code>	// TODO: remove this string search and be more like the Windows</code></span>
<span class="codeline" id="line-4552"><code>	// case below. That might involve modifying the standard library</code></span>
<span class="codeline" id="line-4553"><code>	// to return better error types.</code></span>
<span class="codeline" id="line-4554"><code>	str := err.Error()</code></span>
<span class="codeline" id="line-4555"><code>	if strings.Contains(str, "use of closed network connection") {</code></span>
<span class="codeline" id="line-4556"><code>		return true</code></span>
<span class="codeline" id="line-4557"><code>	}</code></span>
<span class="codeline" id="line-4558"><code></code></span>
<span class="codeline" id="line-4559"><code>	// TODO(bradfitz): x/tools/cmd/bundle doesn't really support</code></span>
<span class="codeline" id="line-4560"><code>	// build tags, so I can't make an http2_windows.go file with</code></span>
<span class="codeline" id="line-4561"><code>	// Windows-specific stuff. Fix that and move this, once we</code></span>
<span class="codeline" id="line-4562"><code>	// have a way to bundle this into std's net/http somehow.</code></span>
<span class="codeline" id="line-4563"><code>	if runtime.GOOS == "windows" {</code></span>
<span class="codeline" id="line-4564"><code>		if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == "read" {</code></span>
<span class="codeline" id="line-4565"><code>			if se, ok := oe.Err.(*os.SyscallError); ok &amp;&amp; se.Syscall == "wsarecv" {</code></span>
<span class="codeline" id="line-4566"><code>				const WSAECONNABORTED = 10053</code></span>
<span class="codeline" id="line-4567"><code>				const WSAECONNRESET = 10054</code></span>
<span class="codeline" id="line-4568"><code>				if n := http2errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED {</code></span>
<span class="codeline" id="line-4569"><code>					return true</code></span>
<span class="codeline" id="line-4570"><code>				}</code></span>
<span class="codeline" id="line-4571"><code>			}</code></span>
<span class="codeline" id="line-4572"><code>		}</code></span>
<span class="codeline" id="line-4573"><code>	}</code></span>
<span class="codeline" id="line-4574"><code>	return false</code></span>
<span class="codeline" id="line-4575"><code>}</code></span>
<span class="codeline" id="line-4576"><code></code></span>
<span class="codeline" id="line-4577"><code>func (sc *http2serverConn) condlogf(err error, format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-4578"><code>	if err == nil {</code></span>
<span class="codeline" id="line-4579"><code>		return</code></span>
<span class="codeline" id="line-4580"><code>	}</code></span>
<span class="codeline" id="line-4581"><code>	if err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err) || err == http2errPrefaceTimeout {</code></span>
<span class="codeline" id="line-4582"><code>		// Boring, expected errors.</code></span>
<span class="codeline" id="line-4583"><code>		sc.vlogf(format, args...)</code></span>
<span class="codeline" id="line-4584"><code>	} else {</code></span>
<span class="codeline" id="line-4585"><code>		sc.logf(format, args...)</code></span>
<span class="codeline" id="line-4586"><code>	}</code></span>
<span class="codeline" id="line-4587"><code>}</code></span>
<span class="codeline" id="line-4588"><code></code></span>
<span class="codeline" id="line-4589"><code>// maxCachedCanonicalHeadersKeysSize is an arbitrarily-chosen limit on the size</code></span>
<span class="codeline" id="line-4590"><code>// of the entries in the canonHeader cache.</code></span>
<span class="codeline" id="line-4591"><code>// This should be larger than the size of unique, uncommon header keys likely to</code></span>
<span class="codeline" id="line-4592"><code>// be sent by the peer, while not so high as to permit unreasonable memory usage</code></span>
<span class="codeline" id="line-4593"><code>// if the peer sends an unbounded number of unique header keys.</code></span>
<span class="codeline" id="line-4594"><code>const http2maxCachedCanonicalHeadersKeysSize = 2048</code></span>
<span class="codeline" id="line-4595"><code></code></span>
<span class="codeline" id="line-4596"><code>func (sc *http2serverConn) canonicalHeader(v string) string {</code></span>
<span class="codeline" id="line-4597"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4598"><code>	http2buildCommonHeaderMapsOnce()</code></span>
<span class="codeline" id="line-4599"><code>	cv, ok := http2commonCanonHeader[v]</code></span>
<span class="codeline" id="line-4600"><code>	if ok {</code></span>
<span class="codeline" id="line-4601"><code>		return cv</code></span>
<span class="codeline" id="line-4602"><code>	}</code></span>
<span class="codeline" id="line-4603"><code>	cv, ok = sc.canonHeader[v]</code></span>
<span class="codeline" id="line-4604"><code>	if ok {</code></span>
<span class="codeline" id="line-4605"><code>		return cv</code></span>
<span class="codeline" id="line-4606"><code>	}</code></span>
<span class="codeline" id="line-4607"><code>	if sc.canonHeader == nil {</code></span>
<span class="codeline" id="line-4608"><code>		sc.canonHeader = make(map[string]string)</code></span>
<span class="codeline" id="line-4609"><code>	}</code></span>
<span class="codeline" id="line-4610"><code>	cv = CanonicalHeaderKey(v)</code></span>
<span class="codeline" id="line-4611"><code>	size := 100 + len(v)*2 // 100 bytes of map overhead + key + value</code></span>
<span class="codeline" id="line-4612"><code>	if sc.canonHeaderKeysSize+size &lt;= http2maxCachedCanonicalHeadersKeysSize {</code></span>
<span class="codeline" id="line-4613"><code>		sc.canonHeader[v] = cv</code></span>
<span class="codeline" id="line-4614"><code>		sc.canonHeaderKeysSize += size</code></span>
<span class="codeline" id="line-4615"><code>	}</code></span>
<span class="codeline" id="line-4616"><code>	return cv</code></span>
<span class="codeline" id="line-4617"><code>}</code></span>
<span class="codeline" id="line-4618"><code></code></span>
<span class="codeline" id="line-4619"><code>type http2readFrameResult struct {</code></span>
<span class="codeline" id="line-4620"><code>	f   http2Frame // valid until readMore is called</code></span>
<span class="codeline" id="line-4621"><code>	err error</code></span>
<span class="codeline" id="line-4622"><code></code></span>
<span class="codeline" id="line-4623"><code>	// readMore should be called once the consumer no longer needs or</code></span>
<span class="codeline" id="line-4624"><code>	// retains f. After readMore, f is invalid and more frames can be</code></span>
<span class="codeline" id="line-4625"><code>	// read.</code></span>
<span class="codeline" id="line-4626"><code>	readMore func()</code></span>
<span class="codeline" id="line-4627"><code>}</code></span>
<span class="codeline" id="line-4628"><code></code></span>
<span class="codeline" id="line-4629"><code>// readFrames is the loop that reads incoming frames.</code></span>
<span class="codeline" id="line-4630"><code>// It takes care to only read one frame at a time, blocking until the</code></span>
<span class="codeline" id="line-4631"><code>// consumer is done with the frame.</code></span>
<span class="codeline" id="line-4632"><code>// It's run on its own goroutine.</code></span>
<span class="codeline" id="line-4633"><code>func (sc *http2serverConn) readFrames() {</code></span>
<span class="codeline" id="line-4634"><code>	gate := make(http2gate)</code></span>
<span class="codeline" id="line-4635"><code>	gateDone := gate.Done</code></span>
<span class="codeline" id="line-4636"><code>	for {</code></span>
<span class="codeline" id="line-4637"><code>		f, err := sc.framer.ReadFrame()</code></span>
<span class="codeline" id="line-4638"><code>		select {</code></span>
<span class="codeline" id="line-4639"><code>		case sc.readFrameCh &lt;- http2readFrameResult{f, err, gateDone}:</code></span>
<span class="codeline" id="line-4640"><code>		case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-4641"><code>			return</code></span>
<span class="codeline" id="line-4642"><code>		}</code></span>
<span class="codeline" id="line-4643"><code>		select {</code></span>
<span class="codeline" id="line-4644"><code>		case &lt;-gate:</code></span>
<span class="codeline" id="line-4645"><code>		case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-4646"><code>			return</code></span>
<span class="codeline" id="line-4647"><code>		}</code></span>
<span class="codeline" id="line-4648"><code>		if http2terminalReadFrameError(err) {</code></span>
<span class="codeline" id="line-4649"><code>			return</code></span>
<span class="codeline" id="line-4650"><code>		}</code></span>
<span class="codeline" id="line-4651"><code>	}</code></span>
<span class="codeline" id="line-4652"><code>}</code></span>
<span class="codeline" id="line-4653"><code></code></span>
<span class="codeline" id="line-4654"><code>// frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.</code></span>
<span class="codeline" id="line-4655"><code>type http2frameWriteResult struct {</code></span>
<span class="codeline" id="line-4656"><code>	_   http2incomparable</code></span>
<span class="codeline" id="line-4657"><code>	wr  http2FrameWriteRequest // what was written (or attempted)</code></span>
<span class="codeline" id="line-4658"><code>	err error                  // result of the writeFrame call</code></span>
<span class="codeline" id="line-4659"><code>}</code></span>
<span class="codeline" id="line-4660"><code></code></span>
<span class="codeline" id="line-4661"><code>// writeFrameAsync runs in its own goroutine and writes a single frame</code></span>
<span class="codeline" id="line-4662"><code>// and then reports when it's done.</code></span>
<span class="codeline" id="line-4663"><code>// At most one goroutine can be running writeFrameAsync at a time per</code></span>
<span class="codeline" id="line-4664"><code>// serverConn.</code></span>
<span class="codeline" id="line-4665"><code>func (sc *http2serverConn) writeFrameAsync(wr http2FrameWriteRequest, wd *http2writeData) {</code></span>
<span class="codeline" id="line-4666"><code>	var err error</code></span>
<span class="codeline" id="line-4667"><code>	if wd == nil {</code></span>
<span class="codeline" id="line-4668"><code>		err = wr.write.writeFrame(sc)</code></span>
<span class="codeline" id="line-4669"><code>	} else {</code></span>
<span class="codeline" id="line-4670"><code>		err = sc.framer.endWrite()</code></span>
<span class="codeline" id="line-4671"><code>	}</code></span>
<span class="codeline" id="line-4672"><code>	sc.wroteFrameCh &lt;- http2frameWriteResult{wr: wr, err: err}</code></span>
<span class="codeline" id="line-4673"><code>}</code></span>
<span class="codeline" id="line-4674"><code></code></span>
<span class="codeline" id="line-4675"><code>func (sc *http2serverConn) closeAllStreamsOnConnClose() {</code></span>
<span class="codeline" id="line-4676"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4677"><code>	for _, st := range sc.streams {</code></span>
<span class="codeline" id="line-4678"><code>		sc.closeStream(st, http2errClientDisconnected)</code></span>
<span class="codeline" id="line-4679"><code>	}</code></span>
<span class="codeline" id="line-4680"><code>}</code></span>
<span class="codeline" id="line-4681"><code></code></span>
<span class="codeline" id="line-4682"><code>func (sc *http2serverConn) stopShutdownTimer() {</code></span>
<span class="codeline" id="line-4683"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4684"><code>	if t := sc.shutdownTimer; t != nil {</code></span>
<span class="codeline" id="line-4685"><code>		t.Stop()</code></span>
<span class="codeline" id="line-4686"><code>	}</code></span>
<span class="codeline" id="line-4687"><code>}</code></span>
<span class="codeline" id="line-4688"><code></code></span>
<span class="codeline" id="line-4689"><code>func (sc *http2serverConn) notePanic() {</code></span>
<span class="codeline" id="line-4690"><code>	// Note: this is for serverConn.serve panicking, not http.Handler code.</code></span>
<span class="codeline" id="line-4691"><code>	if http2testHookOnPanicMu != nil {</code></span>
<span class="codeline" id="line-4692"><code>		http2testHookOnPanicMu.Lock()</code></span>
<span class="codeline" id="line-4693"><code>		defer http2testHookOnPanicMu.Unlock()</code></span>
<span class="codeline" id="line-4694"><code>	}</code></span>
<span class="codeline" id="line-4695"><code>	if http2testHookOnPanic != nil {</code></span>
<span class="codeline" id="line-4696"><code>		if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-4697"><code>			if http2testHookOnPanic(sc, e) {</code></span>
<span class="codeline" id="line-4698"><code>				panic(e)</code></span>
<span class="codeline" id="line-4699"><code>			}</code></span>
<span class="codeline" id="line-4700"><code>		}</code></span>
<span class="codeline" id="line-4701"><code>	}</code></span>
<span class="codeline" id="line-4702"><code>}</code></span>
<span class="codeline" id="line-4703"><code></code></span>
<span class="codeline" id="line-4704"><code>func (sc *http2serverConn) serve() {</code></span>
<span class="codeline" id="line-4705"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4706"><code>	defer sc.notePanic()</code></span>
<span class="codeline" id="line-4707"><code>	defer sc.conn.Close()</code></span>
<span class="codeline" id="line-4708"><code>	defer sc.closeAllStreamsOnConnClose()</code></span>
<span class="codeline" id="line-4709"><code>	defer sc.stopShutdownTimer()</code></span>
<span class="codeline" id="line-4710"><code>	defer close(sc.doneServing) // unblocks handlers trying to send</code></span>
<span class="codeline" id="line-4711"><code></code></span>
<span class="codeline" id="line-4712"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-4713"><code>		sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)</code></span>
<span class="codeline" id="line-4714"><code>	}</code></span>
<span class="codeline" id="line-4715"><code></code></span>
<span class="codeline" id="line-4716"><code>	sc.writeFrame(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-4717"><code>		write: http2writeSettings{</code></span>
<span class="codeline" id="line-4718"><code>			{http2SettingMaxFrameSize, sc.srv.maxReadFrameSize()},</code></span>
<span class="codeline" id="line-4719"><code>			{http2SettingMaxConcurrentStreams, sc.advMaxStreams},</code></span>
<span class="codeline" id="line-4720"><code>			{http2SettingMaxHeaderListSize, sc.maxHeaderListSize()},</code></span>
<span class="codeline" id="line-4721"><code>			{http2SettingHeaderTableSize, sc.srv.maxDecoderHeaderTableSize()},</code></span>
<span class="codeline" id="line-4722"><code>			{http2SettingInitialWindowSize, uint32(sc.srv.initialStreamRecvWindowSize())},</code></span>
<span class="codeline" id="line-4723"><code>		},</code></span>
<span class="codeline" id="line-4724"><code>	})</code></span>
<span class="codeline" id="line-4725"><code>	sc.unackedSettings++</code></span>
<span class="codeline" id="line-4726"><code></code></span>
<span class="codeline" id="line-4727"><code>	// Each connection starts with initialWindowSize inflow tokens.</code></span>
<span class="codeline" id="line-4728"><code>	// If a higher value is configured, we add more tokens.</code></span>
<span class="codeline" id="line-4729"><code>	if diff := sc.srv.initialConnRecvWindowSize() - http2initialWindowSize; diff &gt; 0 {</code></span>
<span class="codeline" id="line-4730"><code>		sc.sendWindowUpdate(nil, int(diff))</code></span>
<span class="codeline" id="line-4731"><code>	}</code></span>
<span class="codeline" id="line-4732"><code></code></span>
<span class="codeline" id="line-4733"><code>	if err := sc.readPreface(); err != nil {</code></span>
<span class="codeline" id="line-4734"><code>		sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err)</code></span>
<span class="codeline" id="line-4735"><code>		return</code></span>
<span class="codeline" id="line-4736"><code>	}</code></span>
<span class="codeline" id="line-4737"><code>	// Now that we've got the preface, get us out of the</code></span>
<span class="codeline" id="line-4738"><code>	// "StateNew" state. We can't go directly to idle, though.</code></span>
<span class="codeline" id="line-4739"><code>	// Active means we read some data and anticipate a request. We'll</code></span>
<span class="codeline" id="line-4740"><code>	// do another Active when we get a HEADERS frame.</code></span>
<span class="codeline" id="line-4741"><code>	sc.setConnState(StateActive)</code></span>
<span class="codeline" id="line-4742"><code>	sc.setConnState(StateIdle)</code></span>
<span class="codeline" id="line-4743"><code></code></span>
<span class="codeline" id="line-4744"><code>	if sc.srv.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-4745"><code>		sc.idleTimer = time.AfterFunc(sc.srv.IdleTimeout, sc.onIdleTimer)</code></span>
<span class="codeline" id="line-4746"><code>		defer sc.idleTimer.Stop()</code></span>
<span class="codeline" id="line-4747"><code>	}</code></span>
<span class="codeline" id="line-4748"><code></code></span>
<span class="codeline" id="line-4749"><code>	go sc.readFrames() // closed by defer sc.conn.Close above</code></span>
<span class="codeline" id="line-4750"><code></code></span>
<span class="codeline" id="line-4751"><code>	settingsTimer := time.AfterFunc(http2firstSettingsTimeout, sc.onSettingsTimer)</code></span>
<span class="codeline" id="line-4752"><code>	defer settingsTimer.Stop()</code></span>
<span class="codeline" id="line-4753"><code></code></span>
<span class="codeline" id="line-4754"><code>	loopNum := 0</code></span>
<span class="codeline" id="line-4755"><code>	for {</code></span>
<span class="codeline" id="line-4756"><code>		loopNum++</code></span>
<span class="codeline" id="line-4757"><code>		select {</code></span>
<span class="codeline" id="line-4758"><code>		case wr := &lt;-sc.wantWriteFrameCh:</code></span>
<span class="codeline" id="line-4759"><code>			if se, ok := wr.write.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-4760"><code>				sc.resetStream(se)</code></span>
<span class="codeline" id="line-4761"><code>				break</code></span>
<span class="codeline" id="line-4762"><code>			}</code></span>
<span class="codeline" id="line-4763"><code>			sc.writeFrame(wr)</code></span>
<span class="codeline" id="line-4764"><code>		case res := &lt;-sc.wroteFrameCh:</code></span>
<span class="codeline" id="line-4765"><code>			sc.wroteFrame(res)</code></span>
<span class="codeline" id="line-4766"><code>		case res := &lt;-sc.readFrameCh:</code></span>
<span class="codeline" id="line-4767"><code>			// Process any written frames before reading new frames from the client since a</code></span>
<span class="codeline" id="line-4768"><code>			// written frame could have triggered a new stream to be started.</code></span>
<span class="codeline" id="line-4769"><code>			if sc.writingFrameAsync {</code></span>
<span class="codeline" id="line-4770"><code>				select {</code></span>
<span class="codeline" id="line-4771"><code>				case wroteRes := &lt;-sc.wroteFrameCh:</code></span>
<span class="codeline" id="line-4772"><code>					sc.wroteFrame(wroteRes)</code></span>
<span class="codeline" id="line-4773"><code>				default:</code></span>
<span class="codeline" id="line-4774"><code>				}</code></span>
<span class="codeline" id="line-4775"><code>			}</code></span>
<span class="codeline" id="line-4776"><code>			if !sc.processFrameFromReader(res) {</code></span>
<span class="codeline" id="line-4777"><code>				return</code></span>
<span class="codeline" id="line-4778"><code>			}</code></span>
<span class="codeline" id="line-4779"><code>			res.readMore()</code></span>
<span class="codeline" id="line-4780"><code>			if settingsTimer != nil {</code></span>
<span class="codeline" id="line-4781"><code>				settingsTimer.Stop()</code></span>
<span class="codeline" id="line-4782"><code>				settingsTimer = nil</code></span>
<span class="codeline" id="line-4783"><code>			}</code></span>
<span class="codeline" id="line-4784"><code>		case m := &lt;-sc.bodyReadCh:</code></span>
<span class="codeline" id="line-4785"><code>			sc.noteBodyRead(m.st, m.n)</code></span>
<span class="codeline" id="line-4786"><code>		case msg := &lt;-sc.serveMsgCh:</code></span>
<span class="codeline" id="line-4787"><code>			switch v := msg.(type) {</code></span>
<span class="codeline" id="line-4788"><code>			case func(int):</code></span>
<span class="codeline" id="line-4789"><code>				v(loopNum) // for testing</code></span>
<span class="codeline" id="line-4790"><code>			case *http2serverMessage:</code></span>
<span class="codeline" id="line-4791"><code>				switch v {</code></span>
<span class="codeline" id="line-4792"><code>				case http2settingsTimerMsg:</code></span>
<span class="codeline" id="line-4793"><code>					sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr())</code></span>
<span class="codeline" id="line-4794"><code>					return</code></span>
<span class="codeline" id="line-4795"><code>				case http2idleTimerMsg:</code></span>
<span class="codeline" id="line-4796"><code>					sc.vlogf("connection is idle")</code></span>
<span class="codeline" id="line-4797"><code>					sc.goAway(http2ErrCodeNo)</code></span>
<span class="codeline" id="line-4798"><code>				case http2shutdownTimerMsg:</code></span>
<span class="codeline" id="line-4799"><code>					sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr())</code></span>
<span class="codeline" id="line-4800"><code>					return</code></span>
<span class="codeline" id="line-4801"><code>				case http2gracefulShutdownMsg:</code></span>
<span class="codeline" id="line-4802"><code>					sc.startGracefulShutdownInternal()</code></span>
<span class="codeline" id="line-4803"><code>				case http2handlerDoneMsg:</code></span>
<span class="codeline" id="line-4804"><code>					sc.handlerDone()</code></span>
<span class="codeline" id="line-4805"><code>				default:</code></span>
<span class="codeline" id="line-4806"><code>					panic("unknown timer")</code></span>
<span class="codeline" id="line-4807"><code>				}</code></span>
<span class="codeline" id="line-4808"><code>			case *http2startPushRequest:</code></span>
<span class="codeline" id="line-4809"><code>				sc.startPush(v)</code></span>
<span class="codeline" id="line-4810"><code>			case func(*http2serverConn):</code></span>
<span class="codeline" id="line-4811"><code>				v(sc)</code></span>
<span class="codeline" id="line-4812"><code>			default:</code></span>
<span class="codeline" id="line-4813"><code>				panic(fmt.Sprintf("unexpected type %T", v))</code></span>
<span class="codeline" id="line-4814"><code>			}</code></span>
<span class="codeline" id="line-4815"><code>		}</code></span>
<span class="codeline" id="line-4816"><code></code></span>
<span class="codeline" id="line-4817"><code>		// If the peer is causing us to generate a lot of control frames,</code></span>
<span class="codeline" id="line-4818"><code>		// but not reading them from us, assume they are trying to make us</code></span>
<span class="codeline" id="line-4819"><code>		// run out of memory.</code></span>
<span class="codeline" id="line-4820"><code>		if sc.queuedControlFrames &gt; sc.srv.maxQueuedControlFrames() {</code></span>
<span class="codeline" id="line-4821"><code>			sc.vlogf("http2: too many control frames in send queue, closing connection")</code></span>
<span class="codeline" id="line-4822"><code>			return</code></span>
<span class="codeline" id="line-4823"><code>		}</code></span>
<span class="codeline" id="line-4824"><code></code></span>
<span class="codeline" id="line-4825"><code>		// Start the shutdown timer after sending a GOAWAY. When sending GOAWAY</code></span>
<span class="codeline" id="line-4826"><code>		// with no error code (graceful shutdown), don't start the timer until</code></span>
<span class="codeline" id="line-4827"><code>		// all open streams have been completed.</code></span>
<span class="codeline" id="line-4828"><code>		sentGoAway := sc.inGoAway &amp;&amp; !sc.needToSendGoAway &amp;&amp; !sc.writingFrame</code></span>
<span class="codeline" id="line-4829"><code>		gracefulShutdownComplete := sc.goAwayCode == http2ErrCodeNo &amp;&amp; sc.curOpenStreams() == 0</code></span>
<span class="codeline" id="line-4830"><code>		if sentGoAway &amp;&amp; sc.shutdownTimer == nil &amp;&amp; (sc.goAwayCode != http2ErrCodeNo || gracefulShutdownComplete) {</code></span>
<span class="codeline" id="line-4831"><code>			sc.shutDownIn(http2goAwayTimeout)</code></span>
<span class="codeline" id="line-4832"><code>		}</code></span>
<span class="codeline" id="line-4833"><code>	}</code></span>
<span class="codeline" id="line-4834"><code>}</code></span>
<span class="codeline" id="line-4835"><code></code></span>
<span class="codeline" id="line-4836"><code>type http2serverMessage int</code></span>
<span class="codeline" id="line-4837"><code></code></span>
<span class="codeline" id="line-4838"><code>// Message values sent to serveMsgCh.</code></span>
<span class="codeline" id="line-4839"><code>var (</code></span>
<span class="codeline" id="line-4840"><code>	http2settingsTimerMsg    = new(http2serverMessage)</code></span>
<span class="codeline" id="line-4841"><code>	http2idleTimerMsg        = new(http2serverMessage)</code></span>
<span class="codeline" id="line-4842"><code>	http2shutdownTimerMsg    = new(http2serverMessage)</code></span>
<span class="codeline" id="line-4843"><code>	http2gracefulShutdownMsg = new(http2serverMessage)</code></span>
<span class="codeline" id="line-4844"><code>	http2handlerDoneMsg      = new(http2serverMessage)</code></span>
<span class="codeline" id="line-4845"><code>)</code></span>
<span class="codeline" id="line-4846"><code></code></span>
<span class="codeline" id="line-4847"><code>func (sc *http2serverConn) onSettingsTimer() { sc.sendServeMsg(http2settingsTimerMsg) }</code></span>
<span class="codeline" id="line-4848"><code></code></span>
<span class="codeline" id="line-4849"><code>func (sc *http2serverConn) onIdleTimer() { sc.sendServeMsg(http2idleTimerMsg) }</code></span>
<span class="codeline" id="line-4850"><code></code></span>
<span class="codeline" id="line-4851"><code>func (sc *http2serverConn) onShutdownTimer() { sc.sendServeMsg(http2shutdownTimerMsg) }</code></span>
<span class="codeline" id="line-4852"><code></code></span>
<span class="codeline" id="line-4853"><code>func (sc *http2serverConn) sendServeMsg(msg interface{}) {</code></span>
<span class="codeline" id="line-4854"><code>	sc.serveG.checkNotOn() // NOT</code></span>
<span class="codeline" id="line-4855"><code>	select {</code></span>
<span class="codeline" id="line-4856"><code>	case sc.serveMsgCh &lt;- msg:</code></span>
<span class="codeline" id="line-4857"><code>	case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-4858"><code>	}</code></span>
<span class="codeline" id="line-4859"><code>}</code></span>
<span class="codeline" id="line-4860"><code></code></span>
<span class="codeline" id="line-4861"><code>var http2errPrefaceTimeout = errors.New("timeout waiting for client preface")</code></span>
<span class="codeline" id="line-4862"><code></code></span>
<span class="codeline" id="line-4863"><code>// readPreface reads the ClientPreface greeting from the peer or</code></span>
<span class="codeline" id="line-4864"><code>// returns errPrefaceTimeout on timeout, or an error if the greeting</code></span>
<span class="codeline" id="line-4865"><code>// is invalid.</code></span>
<span class="codeline" id="line-4866"><code>func (sc *http2serverConn) readPreface() error {</code></span>
<span class="codeline" id="line-4867"><code>	if sc.sawClientPreface {</code></span>
<span class="codeline" id="line-4868"><code>		return nil</code></span>
<span class="codeline" id="line-4869"><code>	}</code></span>
<span class="codeline" id="line-4870"><code>	errc := make(chan error, 1)</code></span>
<span class="codeline" id="line-4871"><code>	go func() {</code></span>
<span class="codeline" id="line-4872"><code>		// Read the client preface</code></span>
<span class="codeline" id="line-4873"><code>		buf := make([]byte, len(http2ClientPreface))</code></span>
<span class="codeline" id="line-4874"><code>		if _, err := io.ReadFull(sc.conn, buf); err != nil {</code></span>
<span class="codeline" id="line-4875"><code>			errc &lt;- err</code></span>
<span class="codeline" id="line-4876"><code>		} else if !bytes.Equal(buf, http2clientPreface) {</code></span>
<span class="codeline" id="line-4877"><code>			errc &lt;- fmt.Errorf("bogus greeting %q", buf)</code></span>
<span class="codeline" id="line-4878"><code>		} else {</code></span>
<span class="codeline" id="line-4879"><code>			errc &lt;- nil</code></span>
<span class="codeline" id="line-4880"><code>		}</code></span>
<span class="codeline" id="line-4881"><code>	}()</code></span>
<span class="codeline" id="line-4882"><code>	timer := time.NewTimer(http2prefaceTimeout) // TODO: configurable on *Server?</code></span>
<span class="codeline" id="line-4883"><code>	defer timer.Stop()</code></span>
<span class="codeline" id="line-4884"><code>	select {</code></span>
<span class="codeline" id="line-4885"><code>	case &lt;-timer.C:</code></span>
<span class="codeline" id="line-4886"><code>		return http2errPrefaceTimeout</code></span>
<span class="codeline" id="line-4887"><code>	case err := &lt;-errc:</code></span>
<span class="codeline" id="line-4888"><code>		if err == nil {</code></span>
<span class="codeline" id="line-4889"><code>			if http2VerboseLogs {</code></span>
<span class="codeline" id="line-4890"><code>				sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr())</code></span>
<span class="codeline" id="line-4891"><code>			}</code></span>
<span class="codeline" id="line-4892"><code>		}</code></span>
<span class="codeline" id="line-4893"><code>		return err</code></span>
<span class="codeline" id="line-4894"><code>	}</code></span>
<span class="codeline" id="line-4895"><code>}</code></span>
<span class="codeline" id="line-4896"><code></code></span>
<span class="codeline" id="line-4897"><code>var http2errChanPool = sync.Pool{</code></span>
<span class="codeline" id="line-4898"><code>	New: func() interface{} { return make(chan error, 1) },</code></span>
<span class="codeline" id="line-4899"><code>}</code></span>
<span class="codeline" id="line-4900"><code></code></span>
<span class="codeline" id="line-4901"><code>var http2writeDataPool = sync.Pool{</code></span>
<span class="codeline" id="line-4902"><code>	New: func() interface{} { return new(http2writeData) },</code></span>
<span class="codeline" id="line-4903"><code>}</code></span>
<span class="codeline" id="line-4904"><code></code></span>
<span class="codeline" id="line-4905"><code>// writeDataFromHandler writes DATA response frames from a handler on</code></span>
<span class="codeline" id="line-4906"><code>// the given stream.</code></span>
<span class="codeline" id="line-4907"><code>func (sc *http2serverConn) writeDataFromHandler(stream *http2stream, data []byte, endStream bool) error {</code></span>
<span class="codeline" id="line-4908"><code>	ch := http2errChanPool.Get().(chan error)</code></span>
<span class="codeline" id="line-4909"><code>	writeArg := http2writeDataPool.Get().(*http2writeData)</code></span>
<span class="codeline" id="line-4910"><code>	*writeArg = http2writeData{stream.id, data, endStream}</code></span>
<span class="codeline" id="line-4911"><code>	err := sc.writeFrameFromHandler(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-4912"><code>		write:  writeArg,</code></span>
<span class="codeline" id="line-4913"><code>		stream: stream,</code></span>
<span class="codeline" id="line-4914"><code>		done:   ch,</code></span>
<span class="codeline" id="line-4915"><code>	})</code></span>
<span class="codeline" id="line-4916"><code>	if err != nil {</code></span>
<span class="codeline" id="line-4917"><code>		return err</code></span>
<span class="codeline" id="line-4918"><code>	}</code></span>
<span class="codeline" id="line-4919"><code>	var frameWriteDone bool // the frame write is done (successfully or not)</code></span>
<span class="codeline" id="line-4920"><code>	select {</code></span>
<span class="codeline" id="line-4921"><code>	case err = &lt;-ch:</code></span>
<span class="codeline" id="line-4922"><code>		frameWriteDone = true</code></span>
<span class="codeline" id="line-4923"><code>	case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-4924"><code>		return http2errClientDisconnected</code></span>
<span class="codeline" id="line-4925"><code>	case &lt;-stream.cw:</code></span>
<span class="codeline" id="line-4926"><code>		// If both ch and stream.cw were ready (as might</code></span>
<span class="codeline" id="line-4927"><code>		// happen on the final Write after an http.Handler</code></span>
<span class="codeline" id="line-4928"><code>		// ends), prefer the write result. Otherwise this</code></span>
<span class="codeline" id="line-4929"><code>		// might just be us successfully closing the stream.</code></span>
<span class="codeline" id="line-4930"><code>		// The writeFrameAsync and serve goroutines guarantee</code></span>
<span class="codeline" id="line-4931"><code>		// that the ch send will happen before the stream.cw</code></span>
<span class="codeline" id="line-4932"><code>		// close.</code></span>
<span class="codeline" id="line-4933"><code>		select {</code></span>
<span class="codeline" id="line-4934"><code>		case err = &lt;-ch:</code></span>
<span class="codeline" id="line-4935"><code>			frameWriteDone = true</code></span>
<span class="codeline" id="line-4936"><code>		default:</code></span>
<span class="codeline" id="line-4937"><code>			return http2errStreamClosed</code></span>
<span class="codeline" id="line-4938"><code>		}</code></span>
<span class="codeline" id="line-4939"><code>	}</code></span>
<span class="codeline" id="line-4940"><code>	http2errChanPool.Put(ch)</code></span>
<span class="codeline" id="line-4941"><code>	if frameWriteDone {</code></span>
<span class="codeline" id="line-4942"><code>		http2writeDataPool.Put(writeArg)</code></span>
<span class="codeline" id="line-4943"><code>	}</code></span>
<span class="codeline" id="line-4944"><code>	return err</code></span>
<span class="codeline" id="line-4945"><code>}</code></span>
<span class="codeline" id="line-4946"><code></code></span>
<span class="codeline" id="line-4947"><code>// writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts</code></span>
<span class="codeline" id="line-4948"><code>// if the connection has gone away.</code></span>
<span class="codeline" id="line-4949"><code>//</code></span>
<span class="codeline" id="line-4950"><code>// This must not be run from the serve goroutine itself, else it might</code></span>
<span class="codeline" id="line-4951"><code>// deadlock writing to sc.wantWriteFrameCh (which is only mildly</code></span>
<span class="codeline" id="line-4952"><code>// buffered and is read by serve itself). If you're on the serve</code></span>
<span class="codeline" id="line-4953"><code>// goroutine, call writeFrame instead.</code></span>
<span class="codeline" id="line-4954"><code>func (sc *http2serverConn) writeFrameFromHandler(wr http2FrameWriteRequest) error {</code></span>
<span class="codeline" id="line-4955"><code>	sc.serveG.checkNotOn() // NOT</code></span>
<span class="codeline" id="line-4956"><code>	select {</code></span>
<span class="codeline" id="line-4957"><code>	case sc.wantWriteFrameCh &lt;- wr:</code></span>
<span class="codeline" id="line-4958"><code>		return nil</code></span>
<span class="codeline" id="line-4959"><code>	case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-4960"><code>		// Serve loop is gone.</code></span>
<span class="codeline" id="line-4961"><code>		// Client has closed their connection to the server.</code></span>
<span class="codeline" id="line-4962"><code>		return http2errClientDisconnected</code></span>
<span class="codeline" id="line-4963"><code>	}</code></span>
<span class="codeline" id="line-4964"><code>}</code></span>
<span class="codeline" id="line-4965"><code></code></span>
<span class="codeline" id="line-4966"><code>// writeFrame schedules a frame to write and sends it if there's nothing</code></span>
<span class="codeline" id="line-4967"><code>// already being written.</code></span>
<span class="codeline" id="line-4968"><code>//</code></span>
<span class="codeline" id="line-4969"><code>// There is no pushback here (the serve goroutine never blocks). It's</code></span>
<span class="codeline" id="line-4970"><code>// the http.Handlers that block, waiting for their previous frames to</code></span>
<span class="codeline" id="line-4971"><code>// make it onto the wire</code></span>
<span class="codeline" id="line-4972"><code>//</code></span>
<span class="codeline" id="line-4973"><code>// If you're not on the serve goroutine, use writeFrameFromHandler instead.</code></span>
<span class="codeline" id="line-4974"><code>func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-4975"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-4976"><code></code></span>
<span class="codeline" id="line-4977"><code>	// If true, wr will not be written and wr.done will not be signaled.</code></span>
<span class="codeline" id="line-4978"><code>	var ignoreWrite bool</code></span>
<span class="codeline" id="line-4979"><code></code></span>
<span class="codeline" id="line-4980"><code>	// We are not allowed to write frames on closed streams. RFC 7540 Section</code></span>
<span class="codeline" id="line-4981"><code>	// 5.1.1 says: "An endpoint MUST NOT send frames other than PRIORITY on</code></span>
<span class="codeline" id="line-4982"><code>	// a closed stream." Our server never sends PRIORITY, so that exception</code></span>
<span class="codeline" id="line-4983"><code>	// does not apply.</code></span>
<span class="codeline" id="line-4984"><code>	//</code></span>
<span class="codeline" id="line-4985"><code>	// The serverConn might close an open stream while the stream's handler</code></span>
<span class="codeline" id="line-4986"><code>	// is still running. For example, the server might close a stream when it</code></span>
<span class="codeline" id="line-4987"><code>	// receives bad data from the client. If this happens, the handler might</code></span>
<span class="codeline" id="line-4988"><code>	// attempt to write a frame after the stream has been closed (since the</code></span>
<span class="codeline" id="line-4989"><code>	// handler hasn't yet been notified of the close). In this case, we simply</code></span>
<span class="codeline" id="line-4990"><code>	// ignore the frame. The handler will notice that the stream is closed when</code></span>
<span class="codeline" id="line-4991"><code>	// it waits for the frame to be written.</code></span>
<span class="codeline" id="line-4992"><code>	//</code></span>
<span class="codeline" id="line-4993"><code>	// As an exception to this rule, we allow sending RST_STREAM after close.</code></span>
<span class="codeline" id="line-4994"><code>	// This allows us to immediately reject new streams without tracking any</code></span>
<span class="codeline" id="line-4995"><code>	// state for those streams (except for the queued RST_STREAM frame). This</code></span>
<span class="codeline" id="line-4996"><code>	// may result in duplicate RST_STREAMs in some cases, but the client should</code></span>
<span class="codeline" id="line-4997"><code>	// ignore those.</code></span>
<span class="codeline" id="line-4998"><code>	if wr.StreamID() != 0 {</code></span>
<span class="codeline" id="line-4999"><code>		_, isReset := wr.write.(http2StreamError)</code></span>
<span class="codeline" id="line-5000"><code>		if state, _ := sc.state(wr.StreamID()); state == http2stateClosed &amp;&amp; !isReset {</code></span>
<span class="codeline" id="line-5001"><code>			ignoreWrite = true</code></span>
<span class="codeline" id="line-5002"><code>		}</code></span>
<span class="codeline" id="line-5003"><code>	}</code></span>
<span class="codeline" id="line-5004"><code></code></span>
<span class="codeline" id="line-5005"><code>	// Don't send a 100-continue response if we've already sent headers.</code></span>
<span class="codeline" id="line-5006"><code>	// See golang.org/issue/14030.</code></span>
<span class="codeline" id="line-5007"><code>	switch wr.write.(type) {</code></span>
<span class="codeline" id="line-5008"><code>	case *http2writeResHeaders:</code></span>
<span class="codeline" id="line-5009"><code>		wr.stream.wroteHeaders = true</code></span>
<span class="codeline" id="line-5010"><code>	case http2write100ContinueHeadersFrame:</code></span>
<span class="codeline" id="line-5011"><code>		if wr.stream.wroteHeaders {</code></span>
<span class="codeline" id="line-5012"><code>			// We do not need to notify wr.done because this frame is</code></span>
<span class="codeline" id="line-5013"><code>			// never written with wr.done != nil.</code></span>
<span class="codeline" id="line-5014"><code>			if wr.done != nil {</code></span>
<span class="codeline" id="line-5015"><code>				panic("wr.done != nil for write100ContinueHeadersFrame")</code></span>
<span class="codeline" id="line-5016"><code>			}</code></span>
<span class="codeline" id="line-5017"><code>			ignoreWrite = true</code></span>
<span class="codeline" id="line-5018"><code>		}</code></span>
<span class="codeline" id="line-5019"><code>	}</code></span>
<span class="codeline" id="line-5020"><code></code></span>
<span class="codeline" id="line-5021"><code>	if !ignoreWrite {</code></span>
<span class="codeline" id="line-5022"><code>		if wr.isControl() {</code></span>
<span class="codeline" id="line-5023"><code>			sc.queuedControlFrames++</code></span>
<span class="codeline" id="line-5024"><code>			// For extra safety, detect wraparounds, which should not happen,</code></span>
<span class="codeline" id="line-5025"><code>			// and pull the plug.</code></span>
<span class="codeline" id="line-5026"><code>			if sc.queuedControlFrames &lt; 0 {</code></span>
<span class="codeline" id="line-5027"><code>				sc.conn.Close()</code></span>
<span class="codeline" id="line-5028"><code>			}</code></span>
<span class="codeline" id="line-5029"><code>		}</code></span>
<span class="codeline" id="line-5030"><code>		sc.writeSched.Push(wr)</code></span>
<span class="codeline" id="line-5031"><code>	}</code></span>
<span class="codeline" id="line-5032"><code>	sc.scheduleFrameWrite()</code></span>
<span class="codeline" id="line-5033"><code>}</code></span>
<span class="codeline" id="line-5034"><code></code></span>
<span class="codeline" id="line-5035"><code>// startFrameWrite starts a goroutine to write wr (in a separate</code></span>
<span class="codeline" id="line-5036"><code>// goroutine since that might block on the network), and updates the</code></span>
<span class="codeline" id="line-5037"><code>// serve goroutine's state about the world, updated from info in wr.</code></span>
<span class="codeline" id="line-5038"><code>func (sc *http2serverConn) startFrameWrite(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-5039"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5040"><code>	if sc.writingFrame {</code></span>
<span class="codeline" id="line-5041"><code>		panic("internal error: can only be writing one frame at a time")</code></span>
<span class="codeline" id="line-5042"><code>	}</code></span>
<span class="codeline" id="line-5043"><code></code></span>
<span class="codeline" id="line-5044"><code>	st := wr.stream</code></span>
<span class="codeline" id="line-5045"><code>	if st != nil {</code></span>
<span class="codeline" id="line-5046"><code>		switch st.state {</code></span>
<span class="codeline" id="line-5047"><code>		case http2stateHalfClosedLocal:</code></span>
<span class="codeline" id="line-5048"><code>			switch wr.write.(type) {</code></span>
<span class="codeline" id="line-5049"><code>			case http2StreamError, http2handlerPanicRST, http2writeWindowUpdate:</code></span>
<span class="codeline" id="line-5050"><code>				// RFC 7540 Section 5.1 allows sending RST_STREAM, PRIORITY, and WINDOW_UPDATE</code></span>
<span class="codeline" id="line-5051"><code>				// in this state. (We never send PRIORITY from the server, so that is not checked.)</code></span>
<span class="codeline" id="line-5052"><code>			default:</code></span>
<span class="codeline" id="line-5053"><code>				panic(fmt.Sprintf("internal error: attempt to send frame on a half-closed-local stream: %v", wr))</code></span>
<span class="codeline" id="line-5054"><code>			}</code></span>
<span class="codeline" id="line-5055"><code>		case http2stateClosed:</code></span>
<span class="codeline" id="line-5056"><code>			panic(fmt.Sprintf("internal error: attempt to send frame on a closed stream: %v", wr))</code></span>
<span class="codeline" id="line-5057"><code>		}</code></span>
<span class="codeline" id="line-5058"><code>	}</code></span>
<span class="codeline" id="line-5059"><code>	if wpp, ok := wr.write.(*http2writePushPromise); ok {</code></span>
<span class="codeline" id="line-5060"><code>		var err error</code></span>
<span class="codeline" id="line-5061"><code>		wpp.promisedID, err = wpp.allocatePromisedID()</code></span>
<span class="codeline" id="line-5062"><code>		if err != nil {</code></span>
<span class="codeline" id="line-5063"><code>			sc.writingFrameAsync = false</code></span>
<span class="codeline" id="line-5064"><code>			wr.replyToWriter(err)</code></span>
<span class="codeline" id="line-5065"><code>			return</code></span>
<span class="codeline" id="line-5066"><code>		}</code></span>
<span class="codeline" id="line-5067"><code>	}</code></span>
<span class="codeline" id="line-5068"><code></code></span>
<span class="codeline" id="line-5069"><code>	sc.writingFrame = true</code></span>
<span class="codeline" id="line-5070"><code>	sc.needsFrameFlush = true</code></span>
<span class="codeline" id="line-5071"><code>	if wr.write.staysWithinBuffer(sc.bw.Available()) {</code></span>
<span class="codeline" id="line-5072"><code>		sc.writingFrameAsync = false</code></span>
<span class="codeline" id="line-5073"><code>		err := wr.write.writeFrame(sc)</code></span>
<span class="codeline" id="line-5074"><code>		sc.wroteFrame(http2frameWriteResult{wr: wr, err: err})</code></span>
<span class="codeline" id="line-5075"><code>	} else if wd, ok := wr.write.(*http2writeData); ok {</code></span>
<span class="codeline" id="line-5076"><code>		// Encode the frame in the serve goroutine, to ensure we don't have</code></span>
<span class="codeline" id="line-5077"><code>		// any lingering asynchronous references to data passed to Write.</code></span>
<span class="codeline" id="line-5078"><code>		// See https://go.dev/issue/58446.</code></span>
<span class="codeline" id="line-5079"><code>		sc.framer.startWriteDataPadded(wd.streamID, wd.endStream, wd.p, nil)</code></span>
<span class="codeline" id="line-5080"><code>		sc.writingFrameAsync = true</code></span>
<span class="codeline" id="line-5081"><code>		go sc.writeFrameAsync(wr, wd)</code></span>
<span class="codeline" id="line-5082"><code>	} else {</code></span>
<span class="codeline" id="line-5083"><code>		sc.writingFrameAsync = true</code></span>
<span class="codeline" id="line-5084"><code>		go sc.writeFrameAsync(wr, nil)</code></span>
<span class="codeline" id="line-5085"><code>	}</code></span>
<span class="codeline" id="line-5086"><code>}</code></span>
<span class="codeline" id="line-5087"><code></code></span>
<span class="codeline" id="line-5088"><code>// errHandlerPanicked is the error given to any callers blocked in a read from</code></span>
<span class="codeline" id="line-5089"><code>// Request.Body when the main goroutine panics. Since most handlers read in the</code></span>
<span class="codeline" id="line-5090"><code>// main ServeHTTP goroutine, this will show up rarely.</code></span>
<span class="codeline" id="line-5091"><code>var http2errHandlerPanicked = errors.New("http2: handler panicked")</code></span>
<span class="codeline" id="line-5092"><code></code></span>
<span class="codeline" id="line-5093"><code>// wroteFrame is called on the serve goroutine with the result of</code></span>
<span class="codeline" id="line-5094"><code>// whatever happened on writeFrameAsync.</code></span>
<span class="codeline" id="line-5095"><code>func (sc *http2serverConn) wroteFrame(res http2frameWriteResult) {</code></span>
<span class="codeline" id="line-5096"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5097"><code>	if !sc.writingFrame {</code></span>
<span class="codeline" id="line-5098"><code>		panic("internal error: expected to be already writing a frame")</code></span>
<span class="codeline" id="line-5099"><code>	}</code></span>
<span class="codeline" id="line-5100"><code>	sc.writingFrame = false</code></span>
<span class="codeline" id="line-5101"><code>	sc.writingFrameAsync = false</code></span>
<span class="codeline" id="line-5102"><code></code></span>
<span class="codeline" id="line-5103"><code>	wr := res.wr</code></span>
<span class="codeline" id="line-5104"><code></code></span>
<span class="codeline" id="line-5105"><code>	if http2writeEndsStream(wr.write) {</code></span>
<span class="codeline" id="line-5106"><code>		st := wr.stream</code></span>
<span class="codeline" id="line-5107"><code>		if st == nil {</code></span>
<span class="codeline" id="line-5108"><code>			panic("internal error: expecting non-nil stream")</code></span>
<span class="codeline" id="line-5109"><code>		}</code></span>
<span class="codeline" id="line-5110"><code>		switch st.state {</code></span>
<span class="codeline" id="line-5111"><code>		case http2stateOpen:</code></span>
<span class="codeline" id="line-5112"><code>			// Here we would go to stateHalfClosedLocal in</code></span>
<span class="codeline" id="line-5113"><code>			// theory, but since our handler is done and</code></span>
<span class="codeline" id="line-5114"><code>			// the net/http package provides no mechanism</code></span>
<span class="codeline" id="line-5115"><code>			// for closing a ResponseWriter while still</code></span>
<span class="codeline" id="line-5116"><code>			// reading data (see possible TODO at top of</code></span>
<span class="codeline" id="line-5117"><code>			// this file), we go into closed state here</code></span>
<span class="codeline" id="line-5118"><code>			// anyway, after telling the peer we're</code></span>
<span class="codeline" id="line-5119"><code>			// hanging up on them. We'll transition to</code></span>
<span class="codeline" id="line-5120"><code>			// stateClosed after the RST_STREAM frame is</code></span>
<span class="codeline" id="line-5121"><code>			// written.</code></span>
<span class="codeline" id="line-5122"><code>			st.state = http2stateHalfClosedLocal</code></span>
<span class="codeline" id="line-5123"><code>			// Section 8.1: a server MAY request that the client abort</code></span>
<span class="codeline" id="line-5124"><code>			// transmission of a request without error by sending a</code></span>
<span class="codeline" id="line-5125"><code>			// RST_STREAM with an error code of NO_ERROR after sending</code></span>
<span class="codeline" id="line-5126"><code>			// a complete response.</code></span>
<span class="codeline" id="line-5127"><code>			sc.resetStream(http2streamError(st.id, http2ErrCodeNo))</code></span>
<span class="codeline" id="line-5128"><code>		case http2stateHalfClosedRemote:</code></span>
<span class="codeline" id="line-5129"><code>			sc.closeStream(st, http2errHandlerComplete)</code></span>
<span class="codeline" id="line-5130"><code>		}</code></span>
<span class="codeline" id="line-5131"><code>	} else {</code></span>
<span class="codeline" id="line-5132"><code>		switch v := wr.write.(type) {</code></span>
<span class="codeline" id="line-5133"><code>		case http2StreamError:</code></span>
<span class="codeline" id="line-5134"><code>			// st may be unknown if the RST_STREAM was generated to reject bad input.</code></span>
<span class="codeline" id="line-5135"><code>			if st, ok := sc.streams[v.StreamID]; ok {</code></span>
<span class="codeline" id="line-5136"><code>				sc.closeStream(st, v)</code></span>
<span class="codeline" id="line-5137"><code>			}</code></span>
<span class="codeline" id="line-5138"><code>		case http2handlerPanicRST:</code></span>
<span class="codeline" id="line-5139"><code>			sc.closeStream(wr.stream, http2errHandlerPanicked)</code></span>
<span class="codeline" id="line-5140"><code>		}</code></span>
<span class="codeline" id="line-5141"><code>	}</code></span>
<span class="codeline" id="line-5142"><code></code></span>
<span class="codeline" id="line-5143"><code>	// Reply (if requested) to unblock the ServeHTTP goroutine.</code></span>
<span class="codeline" id="line-5144"><code>	wr.replyToWriter(res.err)</code></span>
<span class="codeline" id="line-5145"><code></code></span>
<span class="codeline" id="line-5146"><code>	sc.scheduleFrameWrite()</code></span>
<span class="codeline" id="line-5147"><code>}</code></span>
<span class="codeline" id="line-5148"><code></code></span>
<span class="codeline" id="line-5149"><code>// scheduleFrameWrite tickles the frame writing scheduler.</code></span>
<span class="codeline" id="line-5150"><code>//</code></span>
<span class="codeline" id="line-5151"><code>// If a frame is already being written, nothing happens. This will be called again</code></span>
<span class="codeline" id="line-5152"><code>// when the frame is done being written.</code></span>
<span class="codeline" id="line-5153"><code>//</code></span>
<span class="codeline" id="line-5154"><code>// If a frame isn't being written and we need to send one, the best frame</code></span>
<span class="codeline" id="line-5155"><code>// to send is selected by writeSched.</code></span>
<span class="codeline" id="line-5156"><code>//</code></span>
<span class="codeline" id="line-5157"><code>// If a frame isn't being written and there's nothing else to send, we</code></span>
<span class="codeline" id="line-5158"><code>// flush the write buffer.</code></span>
<span class="codeline" id="line-5159"><code>func (sc *http2serverConn) scheduleFrameWrite() {</code></span>
<span class="codeline" id="line-5160"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5161"><code>	if sc.writingFrame || sc.inFrameScheduleLoop {</code></span>
<span class="codeline" id="line-5162"><code>		return</code></span>
<span class="codeline" id="line-5163"><code>	}</code></span>
<span class="codeline" id="line-5164"><code>	sc.inFrameScheduleLoop = true</code></span>
<span class="codeline" id="line-5165"><code>	for !sc.writingFrameAsync {</code></span>
<span class="codeline" id="line-5166"><code>		if sc.needToSendGoAway {</code></span>
<span class="codeline" id="line-5167"><code>			sc.needToSendGoAway = false</code></span>
<span class="codeline" id="line-5168"><code>			sc.startFrameWrite(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-5169"><code>				write: &amp;http2writeGoAway{</code></span>
<span class="codeline" id="line-5170"><code>					maxStreamID: sc.maxClientStreamID,</code></span>
<span class="codeline" id="line-5171"><code>					code:        sc.goAwayCode,</code></span>
<span class="codeline" id="line-5172"><code>				},</code></span>
<span class="codeline" id="line-5173"><code>			})</code></span>
<span class="codeline" id="line-5174"><code>			continue</code></span>
<span class="codeline" id="line-5175"><code>		}</code></span>
<span class="codeline" id="line-5176"><code>		if sc.needToSendSettingsAck {</code></span>
<span class="codeline" id="line-5177"><code>			sc.needToSendSettingsAck = false</code></span>
<span class="codeline" id="line-5178"><code>			sc.startFrameWrite(http2FrameWriteRequest{write: http2writeSettingsAck{}})</code></span>
<span class="codeline" id="line-5179"><code>			continue</code></span>
<span class="codeline" id="line-5180"><code>		}</code></span>
<span class="codeline" id="line-5181"><code>		if !sc.inGoAway || sc.goAwayCode == http2ErrCodeNo {</code></span>
<span class="codeline" id="line-5182"><code>			if wr, ok := sc.writeSched.Pop(); ok {</code></span>
<span class="codeline" id="line-5183"><code>				if wr.isControl() {</code></span>
<span class="codeline" id="line-5184"><code>					sc.queuedControlFrames--</code></span>
<span class="codeline" id="line-5185"><code>				}</code></span>
<span class="codeline" id="line-5186"><code>				sc.startFrameWrite(wr)</code></span>
<span class="codeline" id="line-5187"><code>				continue</code></span>
<span class="codeline" id="line-5188"><code>			}</code></span>
<span class="codeline" id="line-5189"><code>		}</code></span>
<span class="codeline" id="line-5190"><code>		if sc.needsFrameFlush {</code></span>
<span class="codeline" id="line-5191"><code>			sc.startFrameWrite(http2FrameWriteRequest{write: http2flushFrameWriter{}})</code></span>
<span class="codeline" id="line-5192"><code>			sc.needsFrameFlush = false // after startFrameWrite, since it sets this true</code></span>
<span class="codeline" id="line-5193"><code>			continue</code></span>
<span class="codeline" id="line-5194"><code>		}</code></span>
<span class="codeline" id="line-5195"><code>		break</code></span>
<span class="codeline" id="line-5196"><code>	}</code></span>
<span class="codeline" id="line-5197"><code>	sc.inFrameScheduleLoop = false</code></span>
<span class="codeline" id="line-5198"><code>}</code></span>
<span class="codeline" id="line-5199"><code></code></span>
<span class="codeline" id="line-5200"><code>// startGracefulShutdown gracefully shuts down a connection. This</code></span>
<span class="codeline" id="line-5201"><code>// sends GOAWAY with ErrCodeNo to tell the client we're gracefully</code></span>
<span class="codeline" id="line-5202"><code>// shutting down. The connection isn't closed until all current</code></span>
<span class="codeline" id="line-5203"><code>// streams are done.</code></span>
<span class="codeline" id="line-5204"><code>//</code></span>
<span class="codeline" id="line-5205"><code>// startGracefulShutdown returns immediately; it does not wait until</code></span>
<span class="codeline" id="line-5206"><code>// the connection has shut down.</code></span>
<span class="codeline" id="line-5207"><code>func (sc *http2serverConn) startGracefulShutdown() {</code></span>
<span class="codeline" id="line-5208"><code>	sc.serveG.checkNotOn() // NOT</code></span>
<span class="codeline" id="line-5209"><code>	sc.shutdownOnce.Do(func() { sc.sendServeMsg(http2gracefulShutdownMsg) })</code></span>
<span class="codeline" id="line-5210"><code>}</code></span>
<span class="codeline" id="line-5211"><code></code></span>
<span class="codeline" id="line-5212"><code>// After sending GOAWAY with an error code (non-graceful shutdown), the</code></span>
<span class="codeline" id="line-5213"><code>// connection will close after goAwayTimeout.</code></span>
<span class="codeline" id="line-5214"><code>//</code></span>
<span class="codeline" id="line-5215"><code>// If we close the connection immediately after sending GOAWAY, there may</code></span>
<span class="codeline" id="line-5216"><code>// be unsent data in our kernel receive buffer, which will cause the kernel</code></span>
<span class="codeline" id="line-5217"><code>// to send a TCP RST on close() instead of a FIN. This RST will abort the</code></span>
<span class="codeline" id="line-5218"><code>// connection immediately, whether or not the client had received the GOAWAY.</code></span>
<span class="codeline" id="line-5219"><code>//</code></span>
<span class="codeline" id="line-5220"><code>// Ideally we should delay for at least 1 RTT + epsilon so the client has</code></span>
<span class="codeline" id="line-5221"><code>// a chance to read the GOAWAY and stop sending messages. Measuring RTT</code></span>
<span class="codeline" id="line-5222"><code>// is hard, so we approximate with 1 second. See golang.org/issue/18701.</code></span>
<span class="codeline" id="line-5223"><code>//</code></span>
<span class="codeline" id="line-5224"><code>// This is a var so it can be shorter in tests, where all requests uses the</code></span>
<span class="codeline" id="line-5225"><code>// loopback interface making the expected RTT very small.</code></span>
<span class="codeline" id="line-5226"><code>//</code></span>
<span class="codeline" id="line-5227"><code>// TODO: configurable?</code></span>
<span class="codeline" id="line-5228"><code>var http2goAwayTimeout = 1 * time.Second</code></span>
<span class="codeline" id="line-5229"><code></code></span>
<span class="codeline" id="line-5230"><code>func (sc *http2serverConn) startGracefulShutdownInternal() {</code></span>
<span class="codeline" id="line-5231"><code>	sc.goAway(http2ErrCodeNo)</code></span>
<span class="codeline" id="line-5232"><code>}</code></span>
<span class="codeline" id="line-5233"><code></code></span>
<span class="codeline" id="line-5234"><code>func (sc *http2serverConn) goAway(code http2ErrCode) {</code></span>
<span class="codeline" id="line-5235"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5236"><code>	if sc.inGoAway {</code></span>
<span class="codeline" id="line-5237"><code>		if sc.goAwayCode == http2ErrCodeNo {</code></span>
<span class="codeline" id="line-5238"><code>			sc.goAwayCode = code</code></span>
<span class="codeline" id="line-5239"><code>		}</code></span>
<span class="codeline" id="line-5240"><code>		return</code></span>
<span class="codeline" id="line-5241"><code>	}</code></span>
<span class="codeline" id="line-5242"><code>	sc.inGoAway = true</code></span>
<span class="codeline" id="line-5243"><code>	sc.needToSendGoAway = true</code></span>
<span class="codeline" id="line-5244"><code>	sc.goAwayCode = code</code></span>
<span class="codeline" id="line-5245"><code>	sc.scheduleFrameWrite()</code></span>
<span class="codeline" id="line-5246"><code>}</code></span>
<span class="codeline" id="line-5247"><code></code></span>
<span class="codeline" id="line-5248"><code>func (sc *http2serverConn) shutDownIn(d time.Duration) {</code></span>
<span class="codeline" id="line-5249"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5250"><code>	sc.shutdownTimer = time.AfterFunc(d, sc.onShutdownTimer)</code></span>
<span class="codeline" id="line-5251"><code>}</code></span>
<span class="codeline" id="line-5252"><code></code></span>
<span class="codeline" id="line-5253"><code>func (sc *http2serverConn) resetStream(se http2StreamError) {</code></span>
<span class="codeline" id="line-5254"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5255"><code>	sc.writeFrame(http2FrameWriteRequest{write: se})</code></span>
<span class="codeline" id="line-5256"><code>	if st, ok := sc.streams[se.StreamID]; ok {</code></span>
<span class="codeline" id="line-5257"><code>		st.resetQueued = true</code></span>
<span class="codeline" id="line-5258"><code>	}</code></span>
<span class="codeline" id="line-5259"><code>}</code></span>
<span class="codeline" id="line-5260"><code></code></span>
<span class="codeline" id="line-5261"><code>// processFrameFromReader processes the serve loop's read from readFrameCh from the</code></span>
<span class="codeline" id="line-5262"><code>// frame-reading goroutine.</code></span>
<span class="codeline" id="line-5263"><code>// processFrameFromReader returns whether the connection should be kept open.</code></span>
<span class="codeline" id="line-5264"><code>func (sc *http2serverConn) processFrameFromReader(res http2readFrameResult) bool {</code></span>
<span class="codeline" id="line-5265"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5266"><code>	err := res.err</code></span>
<span class="codeline" id="line-5267"><code>	if err != nil {</code></span>
<span class="codeline" id="line-5268"><code>		if err == http2ErrFrameTooLarge {</code></span>
<span class="codeline" id="line-5269"><code>			sc.goAway(http2ErrCodeFrameSize)</code></span>
<span class="codeline" id="line-5270"><code>			return true // goAway will close the loop</code></span>
<span class="codeline" id="line-5271"><code>		}</code></span>
<span class="codeline" id="line-5272"><code>		clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || http2isClosedConnError(err)</code></span>
<span class="codeline" id="line-5273"><code>		if clientGone {</code></span>
<span class="codeline" id="line-5274"><code>			// TODO: could we also get into this state if</code></span>
<span class="codeline" id="line-5275"><code>			// the peer does a half close</code></span>
<span class="codeline" id="line-5276"><code>			// (e.g. CloseWrite) because they're done</code></span>
<span class="codeline" id="line-5277"><code>			// sending frames but they're still wanting</code></span>
<span class="codeline" id="line-5278"><code>			// our open replies?  Investigate.</code></span>
<span class="codeline" id="line-5279"><code>			// TODO: add CloseWrite to crypto/tls.Conn first</code></span>
<span class="codeline" id="line-5280"><code>			// so we have a way to test this? I suppose</code></span>
<span class="codeline" id="line-5281"><code>			// just for testing we could have a non-TLS mode.</code></span>
<span class="codeline" id="line-5282"><code>			return false</code></span>
<span class="codeline" id="line-5283"><code>		}</code></span>
<span class="codeline" id="line-5284"><code>	} else {</code></span>
<span class="codeline" id="line-5285"><code>		f := res.f</code></span>
<span class="codeline" id="line-5286"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-5287"><code>			sc.vlogf("http2: server read frame %v", http2summarizeFrame(f))</code></span>
<span class="codeline" id="line-5288"><code>		}</code></span>
<span class="codeline" id="line-5289"><code>		err = sc.processFrame(f)</code></span>
<span class="codeline" id="line-5290"><code>		if err == nil {</code></span>
<span class="codeline" id="line-5291"><code>			return true</code></span>
<span class="codeline" id="line-5292"><code>		}</code></span>
<span class="codeline" id="line-5293"><code>	}</code></span>
<span class="codeline" id="line-5294"><code></code></span>
<span class="codeline" id="line-5295"><code>	switch ev := err.(type) {</code></span>
<span class="codeline" id="line-5296"><code>	case http2StreamError:</code></span>
<span class="codeline" id="line-5297"><code>		sc.resetStream(ev)</code></span>
<span class="codeline" id="line-5298"><code>		return true</code></span>
<span class="codeline" id="line-5299"><code>	case http2goAwayFlowError:</code></span>
<span class="codeline" id="line-5300"><code>		sc.goAway(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-5301"><code>		return true</code></span>
<span class="codeline" id="line-5302"><code>	case http2ConnectionError:</code></span>
<span class="codeline" id="line-5303"><code>		if res.f != nil {</code></span>
<span class="codeline" id="line-5304"><code>			if id := res.f.Header().StreamID; id &gt; sc.maxClientStreamID {</code></span>
<span class="codeline" id="line-5305"><code>				sc.maxClientStreamID = id</code></span>
<span class="codeline" id="line-5306"><code>			}</code></span>
<span class="codeline" id="line-5307"><code>		}</code></span>
<span class="codeline" id="line-5308"><code>		sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev)</code></span>
<span class="codeline" id="line-5309"><code>		sc.goAway(http2ErrCode(ev))</code></span>
<span class="codeline" id="line-5310"><code>		return true // goAway will handle shutdown</code></span>
<span class="codeline" id="line-5311"><code>	default:</code></span>
<span class="codeline" id="line-5312"><code>		if res.err != nil {</code></span>
<span class="codeline" id="line-5313"><code>			sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err)</code></span>
<span class="codeline" id="line-5314"><code>		} else {</code></span>
<span class="codeline" id="line-5315"><code>			sc.logf("http2: server closing client connection: %v", err)</code></span>
<span class="codeline" id="line-5316"><code>		}</code></span>
<span class="codeline" id="line-5317"><code>		return false</code></span>
<span class="codeline" id="line-5318"><code>	}</code></span>
<span class="codeline" id="line-5319"><code>}</code></span>
<span class="codeline" id="line-5320"><code></code></span>
<span class="codeline" id="line-5321"><code>func (sc *http2serverConn) processFrame(f http2Frame) error {</code></span>
<span class="codeline" id="line-5322"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5323"><code></code></span>
<span class="codeline" id="line-5324"><code>	// First frame received must be SETTINGS.</code></span>
<span class="codeline" id="line-5325"><code>	if !sc.sawFirstSettings {</code></span>
<span class="codeline" id="line-5326"><code>		if _, ok := f.(*http2SettingsFrame); !ok {</code></span>
<span class="codeline" id="line-5327"><code>			return sc.countError("first_settings", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5328"><code>		}</code></span>
<span class="codeline" id="line-5329"><code>		sc.sawFirstSettings = true</code></span>
<span class="codeline" id="line-5330"><code>	}</code></span>
<span class="codeline" id="line-5331"><code></code></span>
<span class="codeline" id="line-5332"><code>	// Discard frames for streams initiated after the identified last</code></span>
<span class="codeline" id="line-5333"><code>	// stream sent in a GOAWAY, or all frames after sending an error.</code></span>
<span class="codeline" id="line-5334"><code>	// We still need to return connection-level flow control for DATA frames.</code></span>
<span class="codeline" id="line-5335"><code>	// RFC 9113 Section 6.8.</code></span>
<span class="codeline" id="line-5336"><code>	if sc.inGoAway &amp;&amp; (sc.goAwayCode != http2ErrCodeNo || f.Header().StreamID &gt; sc.maxClientStreamID) {</code></span>
<span class="codeline" id="line-5337"><code></code></span>
<span class="codeline" id="line-5338"><code>		if f, ok := f.(*http2DataFrame); ok {</code></span>
<span class="codeline" id="line-5339"><code>			if !sc.inflow.take(f.Length) {</code></span>
<span class="codeline" id="line-5340"><code>				return sc.countError("data_flow", http2streamError(f.Header().StreamID, http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5341"><code>			}</code></span>
<span class="codeline" id="line-5342"><code>			sc.sendWindowUpdate(nil, int(f.Length)) // conn-level</code></span>
<span class="codeline" id="line-5343"><code>		}</code></span>
<span class="codeline" id="line-5344"><code>		return nil</code></span>
<span class="codeline" id="line-5345"><code>	}</code></span>
<span class="codeline" id="line-5346"><code></code></span>
<span class="codeline" id="line-5347"><code>	switch f := f.(type) {</code></span>
<span class="codeline" id="line-5348"><code>	case *http2SettingsFrame:</code></span>
<span class="codeline" id="line-5349"><code>		return sc.processSettings(f)</code></span>
<span class="codeline" id="line-5350"><code>	case *http2MetaHeadersFrame:</code></span>
<span class="codeline" id="line-5351"><code>		return sc.processHeaders(f)</code></span>
<span class="codeline" id="line-5352"><code>	case *http2WindowUpdateFrame:</code></span>
<span class="codeline" id="line-5353"><code>		return sc.processWindowUpdate(f)</code></span>
<span class="codeline" id="line-5354"><code>	case *http2PingFrame:</code></span>
<span class="codeline" id="line-5355"><code>		return sc.processPing(f)</code></span>
<span class="codeline" id="line-5356"><code>	case *http2DataFrame:</code></span>
<span class="codeline" id="line-5357"><code>		return sc.processData(f)</code></span>
<span class="codeline" id="line-5358"><code>	case *http2RSTStreamFrame:</code></span>
<span class="codeline" id="line-5359"><code>		return sc.processResetStream(f)</code></span>
<span class="codeline" id="line-5360"><code>	case *http2PriorityFrame:</code></span>
<span class="codeline" id="line-5361"><code>		return sc.processPriority(f)</code></span>
<span class="codeline" id="line-5362"><code>	case *http2GoAwayFrame:</code></span>
<span class="codeline" id="line-5363"><code>		return sc.processGoAway(f)</code></span>
<span class="codeline" id="line-5364"><code>	case *http2PushPromiseFrame:</code></span>
<span class="codeline" id="line-5365"><code>		// A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE</code></span>
<span class="codeline" id="line-5366"><code>		// frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-5367"><code>		return sc.countError("push_promise", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5368"><code>	default:</code></span>
<span class="codeline" id="line-5369"><code>		sc.vlogf("http2: server ignoring frame: %v", f.Header())</code></span>
<span class="codeline" id="line-5370"><code>		return nil</code></span>
<span class="codeline" id="line-5371"><code>	}</code></span>
<span class="codeline" id="line-5372"><code>}</code></span>
<span class="codeline" id="line-5373"><code></code></span>
<span class="codeline" id="line-5374"><code>func (sc *http2serverConn) processPing(f *http2PingFrame) error {</code></span>
<span class="codeline" id="line-5375"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5376"><code>	if f.IsAck() {</code></span>
<span class="codeline" id="line-5377"><code>		// 6.7 PING: " An endpoint MUST NOT respond to PING frames</code></span>
<span class="codeline" id="line-5378"><code>		// containing this flag."</code></span>
<span class="codeline" id="line-5379"><code>		return nil</code></span>
<span class="codeline" id="line-5380"><code>	}</code></span>
<span class="codeline" id="line-5381"><code>	if f.StreamID != 0 {</code></span>
<span class="codeline" id="line-5382"><code>		// "PING frames are not associated with any individual</code></span>
<span class="codeline" id="line-5383"><code>		// stream. If a PING frame is received with a stream</code></span>
<span class="codeline" id="line-5384"><code>		// identifier field value other than 0x0, the recipient MUST</code></span>
<span class="codeline" id="line-5385"><code>		// respond with a connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-5386"><code>		// PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5387"><code>		return sc.countError("ping_on_stream", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5388"><code>	}</code></span>
<span class="codeline" id="line-5389"><code>	sc.writeFrame(http2FrameWriteRequest{write: http2writePingAck{f}})</code></span>
<span class="codeline" id="line-5390"><code>	return nil</code></span>
<span class="codeline" id="line-5391"><code>}</code></span>
<span class="codeline" id="line-5392"><code></code></span>
<span class="codeline" id="line-5393"><code>func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error {</code></span>
<span class="codeline" id="line-5394"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5395"><code>	switch {</code></span>
<span class="codeline" id="line-5396"><code>	case f.StreamID != 0: // stream-level flow control</code></span>
<span class="codeline" id="line-5397"><code>		state, st := sc.state(f.StreamID)</code></span>
<span class="codeline" id="line-5398"><code>		if state == http2stateIdle {</code></span>
<span class="codeline" id="line-5399"><code>			// Section 5.1: "Receiving any frame other than HEADERS</code></span>
<span class="codeline" id="line-5400"><code>			// or PRIORITY on a stream in this state MUST be</code></span>
<span class="codeline" id="line-5401"><code>			// treated as a connection error (Section 5.4.1) of</code></span>
<span class="codeline" id="line-5402"><code>			// type PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5403"><code>			return sc.countError("stream_idle", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5404"><code>		}</code></span>
<span class="codeline" id="line-5405"><code>		if st == nil {</code></span>
<span class="codeline" id="line-5406"><code>			// "WINDOW_UPDATE can be sent by a peer that has sent a</code></span>
<span class="codeline" id="line-5407"><code>			// frame bearing the END_STREAM flag. This means that a</code></span>
<span class="codeline" id="line-5408"><code>			// receiver could receive a WINDOW_UPDATE frame on a "half</code></span>
<span class="codeline" id="line-5409"><code>			// closed (remote)" or "closed" stream. A receiver MUST</code></span>
<span class="codeline" id="line-5410"><code>			// NOT treat this as an error, see Section 5.1."</code></span>
<span class="codeline" id="line-5411"><code>			return nil</code></span>
<span class="codeline" id="line-5412"><code>		}</code></span>
<span class="codeline" id="line-5413"><code>		if !st.flow.add(int32(f.Increment)) {</code></span>
<span class="codeline" id="line-5414"><code>			return sc.countError("bad_flow", http2streamError(f.StreamID, http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5415"><code>		}</code></span>
<span class="codeline" id="line-5416"><code>	default: // connection-level flow control</code></span>
<span class="codeline" id="line-5417"><code>		if !sc.flow.add(int32(f.Increment)) {</code></span>
<span class="codeline" id="line-5418"><code>			return http2goAwayFlowError{}</code></span>
<span class="codeline" id="line-5419"><code>		}</code></span>
<span class="codeline" id="line-5420"><code>	}</code></span>
<span class="codeline" id="line-5421"><code>	sc.scheduleFrameWrite()</code></span>
<span class="codeline" id="line-5422"><code>	return nil</code></span>
<span class="codeline" id="line-5423"><code>}</code></span>
<span class="codeline" id="line-5424"><code></code></span>
<span class="codeline" id="line-5425"><code>func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error {</code></span>
<span class="codeline" id="line-5426"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5427"><code></code></span>
<span class="codeline" id="line-5428"><code>	state, st := sc.state(f.StreamID)</code></span>
<span class="codeline" id="line-5429"><code>	if state == http2stateIdle {</code></span>
<span class="codeline" id="line-5430"><code>		// 6.4 "RST_STREAM frames MUST NOT be sent for a</code></span>
<span class="codeline" id="line-5431"><code>		// stream in the "idle" state. If a RST_STREAM frame</code></span>
<span class="codeline" id="line-5432"><code>		// identifying an idle stream is received, the</code></span>
<span class="codeline" id="line-5433"><code>		// recipient MUST treat this as a connection error</code></span>
<span class="codeline" id="line-5434"><code>		// (Section 5.4.1) of type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-5435"><code>		return sc.countError("reset_idle_stream", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5436"><code>	}</code></span>
<span class="codeline" id="line-5437"><code>	if st != nil {</code></span>
<span class="codeline" id="line-5438"><code>		st.cancelCtx()</code></span>
<span class="codeline" id="line-5439"><code>		sc.closeStream(st, http2streamError(f.StreamID, f.ErrCode))</code></span>
<span class="codeline" id="line-5440"><code>	}</code></span>
<span class="codeline" id="line-5441"><code>	return nil</code></span>
<span class="codeline" id="line-5442"><code>}</code></span>
<span class="codeline" id="line-5443"><code></code></span>
<span class="codeline" id="line-5444"><code>func (sc *http2serverConn) closeStream(st *http2stream, err error) {</code></span>
<span class="codeline" id="line-5445"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5446"><code>	if st.state == http2stateIdle || st.state == http2stateClosed {</code></span>
<span class="codeline" id="line-5447"><code>		panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))</code></span>
<span class="codeline" id="line-5448"><code>	}</code></span>
<span class="codeline" id="line-5449"><code>	st.state = http2stateClosed</code></span>
<span class="codeline" id="line-5450"><code>	if st.readDeadline != nil {</code></span>
<span class="codeline" id="line-5451"><code>		st.readDeadline.Stop()</code></span>
<span class="codeline" id="line-5452"><code>	}</code></span>
<span class="codeline" id="line-5453"><code>	if st.writeDeadline != nil {</code></span>
<span class="codeline" id="line-5454"><code>		st.writeDeadline.Stop()</code></span>
<span class="codeline" id="line-5455"><code>	}</code></span>
<span class="codeline" id="line-5456"><code>	if st.isPushed() {</code></span>
<span class="codeline" id="line-5457"><code>		sc.curPushedStreams--</code></span>
<span class="codeline" id="line-5458"><code>	} else {</code></span>
<span class="codeline" id="line-5459"><code>		sc.curClientStreams--</code></span>
<span class="codeline" id="line-5460"><code>	}</code></span>
<span class="codeline" id="line-5461"><code>	delete(sc.streams, st.id)</code></span>
<span class="codeline" id="line-5462"><code>	if len(sc.streams) == 0 {</code></span>
<span class="codeline" id="line-5463"><code>		sc.setConnState(StateIdle)</code></span>
<span class="codeline" id="line-5464"><code>		if sc.srv.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-5465"><code>			sc.idleTimer.Reset(sc.srv.IdleTimeout)</code></span>
<span class="codeline" id="line-5466"><code>		}</code></span>
<span class="codeline" id="line-5467"><code>		if http2h1ServerKeepAlivesDisabled(sc.hs) {</code></span>
<span class="codeline" id="line-5468"><code>			sc.startGracefulShutdownInternal()</code></span>
<span class="codeline" id="line-5469"><code>		}</code></span>
<span class="codeline" id="line-5470"><code>	}</code></span>
<span class="codeline" id="line-5471"><code>	if p := st.body; p != nil {</code></span>
<span class="codeline" id="line-5472"><code>		// Return any buffered unread bytes worth of conn-level flow control.</code></span>
<span class="codeline" id="line-5473"><code>		// See golang.org/issue/16481</code></span>
<span class="codeline" id="line-5474"><code>		sc.sendWindowUpdate(nil, p.Len())</code></span>
<span class="codeline" id="line-5475"><code></code></span>
<span class="codeline" id="line-5476"><code>		p.CloseWithError(err)</code></span>
<span class="codeline" id="line-5477"><code>	}</code></span>
<span class="codeline" id="line-5478"><code>	if e, ok := err.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-5479"><code>		if e.Cause != nil {</code></span>
<span class="codeline" id="line-5480"><code>			err = e.Cause</code></span>
<span class="codeline" id="line-5481"><code>		} else {</code></span>
<span class="codeline" id="line-5482"><code>			err = http2errStreamClosed</code></span>
<span class="codeline" id="line-5483"><code>		}</code></span>
<span class="codeline" id="line-5484"><code>	}</code></span>
<span class="codeline" id="line-5485"><code>	st.closeErr = err</code></span>
<span class="codeline" id="line-5486"><code>	st.cw.Close() // signals Handler's CloseNotifier, unblocks writes, etc</code></span>
<span class="codeline" id="line-5487"><code>	sc.writeSched.CloseStream(st.id)</code></span>
<span class="codeline" id="line-5488"><code>}</code></span>
<span class="codeline" id="line-5489"><code></code></span>
<span class="codeline" id="line-5490"><code>func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error {</code></span>
<span class="codeline" id="line-5491"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5492"><code>	if f.IsAck() {</code></span>
<span class="codeline" id="line-5493"><code>		sc.unackedSettings--</code></span>
<span class="codeline" id="line-5494"><code>		if sc.unackedSettings &lt; 0 {</code></span>
<span class="codeline" id="line-5495"><code>			// Why is the peer ACKing settings we never sent?</code></span>
<span class="codeline" id="line-5496"><code>			// The spec doesn't mention this case, but</code></span>
<span class="codeline" id="line-5497"><code>			// hang up on them anyway.</code></span>
<span class="codeline" id="line-5498"><code>			return sc.countError("ack_mystery", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5499"><code>		}</code></span>
<span class="codeline" id="line-5500"><code>		return nil</code></span>
<span class="codeline" id="line-5501"><code>	}</code></span>
<span class="codeline" id="line-5502"><code>	if f.NumSettings() &gt; 100 || f.HasDuplicates() {</code></span>
<span class="codeline" id="line-5503"><code>		// This isn't actually in the spec, but hang up on</code></span>
<span class="codeline" id="line-5504"><code>		// suspiciously large settings frames or those with</code></span>
<span class="codeline" id="line-5505"><code>		// duplicate entries.</code></span>
<span class="codeline" id="line-5506"><code>		return sc.countError("settings_big_or_dups", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5507"><code>	}</code></span>
<span class="codeline" id="line-5508"><code>	if err := f.ForeachSetting(sc.processSetting); err != nil {</code></span>
<span class="codeline" id="line-5509"><code>		return err</code></span>
<span class="codeline" id="line-5510"><code>	}</code></span>
<span class="codeline" id="line-5511"><code>	// TODO: judging by RFC 7540, Section 6.5.3 each SETTINGS frame should be</code></span>
<span class="codeline" id="line-5512"><code>	// acknowledged individually, even if multiple are received before the ACK.</code></span>
<span class="codeline" id="line-5513"><code>	sc.needToSendSettingsAck = true</code></span>
<span class="codeline" id="line-5514"><code>	sc.scheduleFrameWrite()</code></span>
<span class="codeline" id="line-5515"><code>	return nil</code></span>
<span class="codeline" id="line-5516"><code>}</code></span>
<span class="codeline" id="line-5517"><code></code></span>
<span class="codeline" id="line-5518"><code>func (sc *http2serverConn) processSetting(s http2Setting) error {</code></span>
<span class="codeline" id="line-5519"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5520"><code>	if err := s.Valid(); err != nil {</code></span>
<span class="codeline" id="line-5521"><code>		return err</code></span>
<span class="codeline" id="line-5522"><code>	}</code></span>
<span class="codeline" id="line-5523"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-5524"><code>		sc.vlogf("http2: server processing setting %v", s)</code></span>
<span class="codeline" id="line-5525"><code>	}</code></span>
<span class="codeline" id="line-5526"><code>	switch s.ID {</code></span>
<span class="codeline" id="line-5527"><code>	case http2SettingHeaderTableSize:</code></span>
<span class="codeline" id="line-5528"><code>		sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)</code></span>
<span class="codeline" id="line-5529"><code>	case http2SettingEnablePush:</code></span>
<span class="codeline" id="line-5530"><code>		sc.pushEnabled = s.Val != 0</code></span>
<span class="codeline" id="line-5531"><code>	case http2SettingMaxConcurrentStreams:</code></span>
<span class="codeline" id="line-5532"><code>		sc.clientMaxStreams = s.Val</code></span>
<span class="codeline" id="line-5533"><code>	case http2SettingInitialWindowSize:</code></span>
<span class="codeline" id="line-5534"><code>		return sc.processSettingInitialWindowSize(s.Val)</code></span>
<span class="codeline" id="line-5535"><code>	case http2SettingMaxFrameSize:</code></span>
<span class="codeline" id="line-5536"><code>		sc.maxFrameSize = int32(s.Val) // the maximum valid s.Val is &lt; 2^31</code></span>
<span class="codeline" id="line-5537"><code>	case http2SettingMaxHeaderListSize:</code></span>
<span class="codeline" id="line-5538"><code>		sc.peerMaxHeaderListSize = s.Val</code></span>
<span class="codeline" id="line-5539"><code>	default:</code></span>
<span class="codeline" id="line-5540"><code>		// Unknown setting: "An endpoint that receives a SETTINGS</code></span>
<span class="codeline" id="line-5541"><code>		// frame with any unknown or unsupported identifier MUST</code></span>
<span class="codeline" id="line-5542"><code>		// ignore that setting."</code></span>
<span class="codeline" id="line-5543"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-5544"><code>			sc.vlogf("http2: server ignoring unknown setting %v", s)</code></span>
<span class="codeline" id="line-5545"><code>		}</code></span>
<span class="codeline" id="line-5546"><code>	}</code></span>
<span class="codeline" id="line-5547"><code>	return nil</code></span>
<span class="codeline" id="line-5548"><code>}</code></span>
<span class="codeline" id="line-5549"><code></code></span>
<span class="codeline" id="line-5550"><code>func (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error {</code></span>
<span class="codeline" id="line-5551"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5552"><code>	// Note: val already validated to be within range by</code></span>
<span class="codeline" id="line-5553"><code>	// processSetting's Valid call.</code></span>
<span class="codeline" id="line-5554"><code></code></span>
<span class="codeline" id="line-5555"><code>	// "A SETTINGS frame can alter the initial flow control window</code></span>
<span class="codeline" id="line-5556"><code>	// size for all current streams. When the value of</code></span>
<span class="codeline" id="line-5557"><code>	// SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST</code></span>
<span class="codeline" id="line-5558"><code>	// adjust the size of all stream flow control windows that it</code></span>
<span class="codeline" id="line-5559"><code>	// maintains by the difference between the new value and the</code></span>
<span class="codeline" id="line-5560"><code>	// old value."</code></span>
<span class="codeline" id="line-5561"><code>	old := sc.initialStreamSendWindowSize</code></span>
<span class="codeline" id="line-5562"><code>	sc.initialStreamSendWindowSize = int32(val)</code></span>
<span class="codeline" id="line-5563"><code>	growth := int32(val) - old // may be negative</code></span>
<span class="codeline" id="line-5564"><code>	for _, st := range sc.streams {</code></span>
<span class="codeline" id="line-5565"><code>		if !st.flow.add(growth) {</code></span>
<span class="codeline" id="line-5566"><code>			// 6.9.2 Initial Flow Control Window Size</code></span>
<span class="codeline" id="line-5567"><code>			// "An endpoint MUST treat a change to</code></span>
<span class="codeline" id="line-5568"><code>			// SETTINGS_INITIAL_WINDOW_SIZE that causes any flow</code></span>
<span class="codeline" id="line-5569"><code>			// control window to exceed the maximum size as a</code></span>
<span class="codeline" id="line-5570"><code>			// connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-5571"><code>			// FLOW_CONTROL_ERROR."</code></span>
<span class="codeline" id="line-5572"><code>			return sc.countError("setting_win_size", http2ConnectionError(http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5573"><code>		}</code></span>
<span class="codeline" id="line-5574"><code>	}</code></span>
<span class="codeline" id="line-5575"><code>	return nil</code></span>
<span class="codeline" id="line-5576"><code>}</code></span>
<span class="codeline" id="line-5577"><code></code></span>
<span class="codeline" id="line-5578"><code>func (sc *http2serverConn) processData(f *http2DataFrame) error {</code></span>
<span class="codeline" id="line-5579"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5580"><code>	id := f.Header().StreamID</code></span>
<span class="codeline" id="line-5581"><code></code></span>
<span class="codeline" id="line-5582"><code>	data := f.Data()</code></span>
<span class="codeline" id="line-5583"><code>	state, st := sc.state(id)</code></span>
<span class="codeline" id="line-5584"><code>	if id == 0 || state == http2stateIdle {</code></span>
<span class="codeline" id="line-5585"><code>		// Section 6.1: "DATA frames MUST be associated with a</code></span>
<span class="codeline" id="line-5586"><code>		// stream. If a DATA frame is received whose stream</code></span>
<span class="codeline" id="line-5587"><code>		// identifier field is 0x0, the recipient MUST respond</code></span>
<span class="codeline" id="line-5588"><code>		// with a connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-5589"><code>		// PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5590"><code>		//</code></span>
<span class="codeline" id="line-5591"><code>		// Section 5.1: "Receiving any frame other than HEADERS</code></span>
<span class="codeline" id="line-5592"><code>		// or PRIORITY on a stream in this state MUST be</code></span>
<span class="codeline" id="line-5593"><code>		// treated as a connection error (Section 5.4.1) of</code></span>
<span class="codeline" id="line-5594"><code>		// type PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5595"><code>		return sc.countError("data_on_idle", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5596"><code>	}</code></span>
<span class="codeline" id="line-5597"><code></code></span>
<span class="codeline" id="line-5598"><code>	// "If a DATA frame is received whose stream is not in "open"</code></span>
<span class="codeline" id="line-5599"><code>	// or "half closed (local)" state, the recipient MUST respond</code></span>
<span class="codeline" id="line-5600"><code>	// with a stream error (Section 5.4.2) of type STREAM_CLOSED."</code></span>
<span class="codeline" id="line-5601"><code>	if st == nil || state != http2stateOpen || st.gotTrailerHeader || st.resetQueued {</code></span>
<span class="codeline" id="line-5602"><code>		// This includes sending a RST_STREAM if the stream is</code></span>
<span class="codeline" id="line-5603"><code>		// in stateHalfClosedLocal (which currently means that</code></span>
<span class="codeline" id="line-5604"><code>		// the http.Handler returned, so it's done reading &amp;</code></span>
<span class="codeline" id="line-5605"><code>		// done writing). Try to stop the client from sending</code></span>
<span class="codeline" id="line-5606"><code>		// more DATA.</code></span>
<span class="codeline" id="line-5607"><code></code></span>
<span class="codeline" id="line-5608"><code>		// But still enforce their connection-level flow control,</code></span>
<span class="codeline" id="line-5609"><code>		// and return any flow control bytes since we're not going</code></span>
<span class="codeline" id="line-5610"><code>		// to consume them.</code></span>
<span class="codeline" id="line-5611"><code>		if !sc.inflow.take(f.Length) {</code></span>
<span class="codeline" id="line-5612"><code>			return sc.countError("data_flow", http2streamError(id, http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5613"><code>		}</code></span>
<span class="codeline" id="line-5614"><code>		sc.sendWindowUpdate(nil, int(f.Length)) // conn-level</code></span>
<span class="codeline" id="line-5615"><code></code></span>
<span class="codeline" id="line-5616"><code>		if st != nil &amp;&amp; st.resetQueued {</code></span>
<span class="codeline" id="line-5617"><code>			// Already have a stream error in flight. Don't send another.</code></span>
<span class="codeline" id="line-5618"><code>			return nil</code></span>
<span class="codeline" id="line-5619"><code>		}</code></span>
<span class="codeline" id="line-5620"><code>		return sc.countError("closed", http2streamError(id, http2ErrCodeStreamClosed))</code></span>
<span class="codeline" id="line-5621"><code>	}</code></span>
<span class="codeline" id="line-5622"><code>	if st.body == nil {</code></span>
<span class="codeline" id="line-5623"><code>		panic("internal error: should have a body in this state")</code></span>
<span class="codeline" id="line-5624"><code>	}</code></span>
<span class="codeline" id="line-5625"><code></code></span>
<span class="codeline" id="line-5626"><code>	// Sender sending more than they'd declared?</code></span>
<span class="codeline" id="line-5627"><code>	if st.declBodyBytes != -1 &amp;&amp; st.bodyBytes+int64(len(data)) &gt; st.declBodyBytes {</code></span>
<span class="codeline" id="line-5628"><code>		if !sc.inflow.take(f.Length) {</code></span>
<span class="codeline" id="line-5629"><code>			return sc.countError("data_flow", http2streamError(id, http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5630"><code>		}</code></span>
<span class="codeline" id="line-5631"><code>		sc.sendWindowUpdate(nil, int(f.Length)) // conn-level</code></span>
<span class="codeline" id="line-5632"><code></code></span>
<span class="codeline" id="line-5633"><code>		st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes))</code></span>
<span class="codeline" id="line-5634"><code>		// RFC 7540, sec 8.1.2.6: A request or response is also malformed if the</code></span>
<span class="codeline" id="line-5635"><code>		// value of a content-length header field does not equal the sum of the</code></span>
<span class="codeline" id="line-5636"><code>		// DATA frame payload lengths that form the body.</code></span>
<span class="codeline" id="line-5637"><code>		return sc.countError("send_too_much", http2streamError(id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5638"><code>	}</code></span>
<span class="codeline" id="line-5639"><code>	if f.Length &gt; 0 {</code></span>
<span class="codeline" id="line-5640"><code>		// Check whether the client has flow control quota.</code></span>
<span class="codeline" id="line-5641"><code>		if !http2takeInflows(&amp;sc.inflow, &amp;st.inflow, f.Length) {</code></span>
<span class="codeline" id="line-5642"><code>			return sc.countError("flow_on_data_length", http2streamError(id, http2ErrCodeFlowControl))</code></span>
<span class="codeline" id="line-5643"><code>		}</code></span>
<span class="codeline" id="line-5644"><code></code></span>
<span class="codeline" id="line-5645"><code>		if len(data) &gt; 0 {</code></span>
<span class="codeline" id="line-5646"><code>			st.bodyBytes += int64(len(data))</code></span>
<span class="codeline" id="line-5647"><code>			wrote, err := st.body.Write(data)</code></span>
<span class="codeline" id="line-5648"><code>			if err != nil {</code></span>
<span class="codeline" id="line-5649"><code>				// The handler has closed the request body.</code></span>
<span class="codeline" id="line-5650"><code>				// Return the connection-level flow control for the discarded data,</code></span>
<span class="codeline" id="line-5651"><code>				// but not the stream-level flow control.</code></span>
<span class="codeline" id="line-5652"><code>				sc.sendWindowUpdate(nil, int(f.Length)-wrote)</code></span>
<span class="codeline" id="line-5653"><code>				return nil</code></span>
<span class="codeline" id="line-5654"><code>			}</code></span>
<span class="codeline" id="line-5655"><code>			if wrote != len(data) {</code></span>
<span class="codeline" id="line-5656"><code>				panic("internal error: bad Writer")</code></span>
<span class="codeline" id="line-5657"><code>			}</code></span>
<span class="codeline" id="line-5658"><code>		}</code></span>
<span class="codeline" id="line-5659"><code></code></span>
<span class="codeline" id="line-5660"><code>		// Return any padded flow control now, since we won't</code></span>
<span class="codeline" id="line-5661"><code>		// refund it later on body reads.</code></span>
<span class="codeline" id="line-5662"><code>		// Call sendWindowUpdate even if there is no padding,</code></span>
<span class="codeline" id="line-5663"><code>		// to return buffered flow control credit if the sent</code></span>
<span class="codeline" id="line-5664"><code>		// window has shrunk.</code></span>
<span class="codeline" id="line-5665"><code>		pad := int32(f.Length) - int32(len(data))</code></span>
<span class="codeline" id="line-5666"><code>		sc.sendWindowUpdate32(nil, pad)</code></span>
<span class="codeline" id="line-5667"><code>		sc.sendWindowUpdate32(st, pad)</code></span>
<span class="codeline" id="line-5668"><code>	}</code></span>
<span class="codeline" id="line-5669"><code>	if f.StreamEnded() {</code></span>
<span class="codeline" id="line-5670"><code>		st.endStream()</code></span>
<span class="codeline" id="line-5671"><code>	}</code></span>
<span class="codeline" id="line-5672"><code>	return nil</code></span>
<span class="codeline" id="line-5673"><code>}</code></span>
<span class="codeline" id="line-5674"><code></code></span>
<span class="codeline" id="line-5675"><code>func (sc *http2serverConn) processGoAway(f *http2GoAwayFrame) error {</code></span>
<span class="codeline" id="line-5676"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5677"><code>	if f.ErrCode != http2ErrCodeNo {</code></span>
<span class="codeline" id="line-5678"><code>		sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f)</code></span>
<span class="codeline" id="line-5679"><code>	} else {</code></span>
<span class="codeline" id="line-5680"><code>		sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f)</code></span>
<span class="codeline" id="line-5681"><code>	}</code></span>
<span class="codeline" id="line-5682"><code>	sc.startGracefulShutdownInternal()</code></span>
<span class="codeline" id="line-5683"><code>	// http://tools.ietf.org/html/rfc7540#section-6.8</code></span>
<span class="codeline" id="line-5684"><code>	// We should not create any new streams, which means we should disable push.</code></span>
<span class="codeline" id="line-5685"><code>	sc.pushEnabled = false</code></span>
<span class="codeline" id="line-5686"><code>	return nil</code></span>
<span class="codeline" id="line-5687"><code>}</code></span>
<span class="codeline" id="line-5688"><code></code></span>
<span class="codeline" id="line-5689"><code>// isPushed reports whether the stream is server-initiated.</code></span>
<span class="codeline" id="line-5690"><code>func (st *http2stream) isPushed() bool {</code></span>
<span class="codeline" id="line-5691"><code>	return st.id%2 == 0</code></span>
<span class="codeline" id="line-5692"><code>}</code></span>
<span class="codeline" id="line-5693"><code></code></span>
<span class="codeline" id="line-5694"><code>// endStream closes a Request.Body's pipe. It is called when a DATA</code></span>
<span class="codeline" id="line-5695"><code>// frame says a request body is over (or after trailers).</code></span>
<span class="codeline" id="line-5696"><code>func (st *http2stream) endStream() {</code></span>
<span class="codeline" id="line-5697"><code>	sc := st.sc</code></span>
<span class="codeline" id="line-5698"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5699"><code></code></span>
<span class="codeline" id="line-5700"><code>	if st.declBodyBytes != -1 &amp;&amp; st.declBodyBytes != st.bodyBytes {</code></span>
<span class="codeline" id="line-5701"><code>		st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",</code></span>
<span class="codeline" id="line-5702"><code>			st.declBodyBytes, st.bodyBytes))</code></span>
<span class="codeline" id="line-5703"><code>	} else {</code></span>
<span class="codeline" id="line-5704"><code>		st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)</code></span>
<span class="codeline" id="line-5705"><code>		st.body.CloseWithError(io.EOF)</code></span>
<span class="codeline" id="line-5706"><code>	}</code></span>
<span class="codeline" id="line-5707"><code>	st.state = http2stateHalfClosedRemote</code></span>
<span class="codeline" id="line-5708"><code>}</code></span>
<span class="codeline" id="line-5709"><code></code></span>
<span class="codeline" id="line-5710"><code>// copyTrailersToHandlerRequest is run in the Handler's goroutine in</code></span>
<span class="codeline" id="line-5711"><code>// its Request.Body.Read just before it gets io.EOF.</code></span>
<span class="codeline" id="line-5712"><code>func (st *http2stream) copyTrailersToHandlerRequest() {</code></span>
<span class="codeline" id="line-5713"><code>	for k, vv := range st.trailer {</code></span>
<span class="codeline" id="line-5714"><code>		if _, ok := st.reqTrailer[k]; ok {</code></span>
<span class="codeline" id="line-5715"><code>			// Only copy it over it was pre-declared.</code></span>
<span class="codeline" id="line-5716"><code>			st.reqTrailer[k] = vv</code></span>
<span class="codeline" id="line-5717"><code>		}</code></span>
<span class="codeline" id="line-5718"><code>	}</code></span>
<span class="codeline" id="line-5719"><code>}</code></span>
<span class="codeline" id="line-5720"><code></code></span>
<span class="codeline" id="line-5721"><code>// onReadTimeout is run on its own goroutine (from time.AfterFunc)</code></span>
<span class="codeline" id="line-5722"><code>// when the stream's ReadTimeout has fired.</code></span>
<span class="codeline" id="line-5723"><code>func (st *http2stream) onReadTimeout() {</code></span>
<span class="codeline" id="line-5724"><code>	if st.body != nil {</code></span>
<span class="codeline" id="line-5725"><code>		// Wrap the ErrDeadlineExceeded to avoid callers depending on us</code></span>
<span class="codeline" id="line-5726"><code>		// returning the bare error.</code></span>
<span class="codeline" id="line-5727"><code>		st.body.CloseWithError(fmt.Errorf("%w", os.ErrDeadlineExceeded))</code></span>
<span class="codeline" id="line-5728"><code>	}</code></span>
<span class="codeline" id="line-5729"><code>}</code></span>
<span class="codeline" id="line-5730"><code></code></span>
<span class="codeline" id="line-5731"><code>// onWriteTimeout is run on its own goroutine (from time.AfterFunc)</code></span>
<span class="codeline" id="line-5732"><code>// when the stream's WriteTimeout has fired.</code></span>
<span class="codeline" id="line-5733"><code>func (st *http2stream) onWriteTimeout() {</code></span>
<span class="codeline" id="line-5734"><code>	st.sc.writeFrameFromHandler(http2FrameWriteRequest{write: http2StreamError{</code></span>
<span class="codeline" id="line-5735"><code>		StreamID: st.id,</code></span>
<span class="codeline" id="line-5736"><code>		Code:     http2ErrCodeInternal,</code></span>
<span class="codeline" id="line-5737"><code>		Cause:    os.ErrDeadlineExceeded,</code></span>
<span class="codeline" id="line-5738"><code>	}})</code></span>
<span class="codeline" id="line-5739"><code>}</code></span>
<span class="codeline" id="line-5740"><code></code></span>
<span class="codeline" id="line-5741"><code>func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error {</code></span>
<span class="codeline" id="line-5742"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5743"><code>	id := f.StreamID</code></span>
<span class="codeline" id="line-5744"><code>	// http://tools.ietf.org/html/rfc7540#section-5.1.1</code></span>
<span class="codeline" id="line-5745"><code>	// Streams initiated by a client MUST use odd-numbered stream</code></span>
<span class="codeline" id="line-5746"><code>	// identifiers. [...] An endpoint that receives an unexpected</code></span>
<span class="codeline" id="line-5747"><code>	// stream identifier MUST respond with a connection error</code></span>
<span class="codeline" id="line-5748"><code>	// (Section 5.4.1) of type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-5749"><code>	if id%2 != 1 {</code></span>
<span class="codeline" id="line-5750"><code>		return sc.countError("headers_even", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5751"><code>	}</code></span>
<span class="codeline" id="line-5752"><code>	// A HEADERS frame can be used to create a new stream or</code></span>
<span class="codeline" id="line-5753"><code>	// send a trailer for an open one. If we already have a stream</code></span>
<span class="codeline" id="line-5754"><code>	// open, let it process its own HEADERS frame (trailers at this</code></span>
<span class="codeline" id="line-5755"><code>	// point, if it's valid).</code></span>
<span class="codeline" id="line-5756"><code>	if st := sc.streams[f.StreamID]; st != nil {</code></span>
<span class="codeline" id="line-5757"><code>		if st.resetQueued {</code></span>
<span class="codeline" id="line-5758"><code>			// We're sending RST_STREAM to close the stream, so don't bother</code></span>
<span class="codeline" id="line-5759"><code>			// processing this frame.</code></span>
<span class="codeline" id="line-5760"><code>			return nil</code></span>
<span class="codeline" id="line-5761"><code>		}</code></span>
<span class="codeline" id="line-5762"><code>		// RFC 7540, sec 5.1: If an endpoint receives additional frames, other than</code></span>
<span class="codeline" id="line-5763"><code>		// WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in</code></span>
<span class="codeline" id="line-5764"><code>		// this state, it MUST respond with a stream error (Section 5.4.2) of</code></span>
<span class="codeline" id="line-5765"><code>		// type STREAM_CLOSED.</code></span>
<span class="codeline" id="line-5766"><code>		if st.state == http2stateHalfClosedRemote {</code></span>
<span class="codeline" id="line-5767"><code>			return sc.countError("headers_half_closed", http2streamError(id, http2ErrCodeStreamClosed))</code></span>
<span class="codeline" id="line-5768"><code>		}</code></span>
<span class="codeline" id="line-5769"><code>		return st.processTrailerHeaders(f)</code></span>
<span class="codeline" id="line-5770"><code>	}</code></span>
<span class="codeline" id="line-5771"><code></code></span>
<span class="codeline" id="line-5772"><code>	// [...] The identifier of a newly established stream MUST be</code></span>
<span class="codeline" id="line-5773"><code>	// numerically greater than all streams that the initiating</code></span>
<span class="codeline" id="line-5774"><code>	// endpoint has opened or reserved. [...]  An endpoint that</code></span>
<span class="codeline" id="line-5775"><code>	// receives an unexpected stream identifier MUST respond with</code></span>
<span class="codeline" id="line-5776"><code>	// a connection error (Section 5.4.1) of type PROTOCOL_ERROR.</code></span>
<span class="codeline" id="line-5777"><code>	if id &lt;= sc.maxClientStreamID {</code></span>
<span class="codeline" id="line-5778"><code>		return sc.countError("stream_went_down", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5779"><code>	}</code></span>
<span class="codeline" id="line-5780"><code>	sc.maxClientStreamID = id</code></span>
<span class="codeline" id="line-5781"><code></code></span>
<span class="codeline" id="line-5782"><code>	if sc.idleTimer != nil {</code></span>
<span class="codeline" id="line-5783"><code>		sc.idleTimer.Stop()</code></span>
<span class="codeline" id="line-5784"><code>	}</code></span>
<span class="codeline" id="line-5785"><code></code></span>
<span class="codeline" id="line-5786"><code>	// http://tools.ietf.org/html/rfc7540#section-5.1.2</code></span>
<span class="codeline" id="line-5787"><code>	// [...] Endpoints MUST NOT exceed the limit set by their peer. An</code></span>
<span class="codeline" id="line-5788"><code>	// endpoint that receives a HEADERS frame that causes their</code></span>
<span class="codeline" id="line-5789"><code>	// advertised concurrent stream limit to be exceeded MUST treat</code></span>
<span class="codeline" id="line-5790"><code>	// this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR</code></span>
<span class="codeline" id="line-5791"><code>	// or REFUSED_STREAM.</code></span>
<span class="codeline" id="line-5792"><code>	if sc.curClientStreams+1 &gt; sc.advMaxStreams {</code></span>
<span class="codeline" id="line-5793"><code>		if sc.unackedSettings == 0 {</code></span>
<span class="codeline" id="line-5794"><code>			// They should know better.</code></span>
<span class="codeline" id="line-5795"><code>			return sc.countError("over_max_streams", http2streamError(id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5796"><code>		}</code></span>
<span class="codeline" id="line-5797"><code>		// Assume it's a network race, where they just haven't</code></span>
<span class="codeline" id="line-5798"><code>		// received our last SETTINGS update. But actually</code></span>
<span class="codeline" id="line-5799"><code>		// this can't happen yet, because we don't yet provide</code></span>
<span class="codeline" id="line-5800"><code>		// a way for users to adjust server parameters at</code></span>
<span class="codeline" id="line-5801"><code>		// runtime.</code></span>
<span class="codeline" id="line-5802"><code>		return sc.countError("over_max_streams_race", http2streamError(id, http2ErrCodeRefusedStream))</code></span>
<span class="codeline" id="line-5803"><code>	}</code></span>
<span class="codeline" id="line-5804"><code></code></span>
<span class="codeline" id="line-5805"><code>	initialState := http2stateOpen</code></span>
<span class="codeline" id="line-5806"><code>	if f.StreamEnded() {</code></span>
<span class="codeline" id="line-5807"><code>		initialState = http2stateHalfClosedRemote</code></span>
<span class="codeline" id="line-5808"><code>	}</code></span>
<span class="codeline" id="line-5809"><code>	st := sc.newStream(id, 0, initialState)</code></span>
<span class="codeline" id="line-5810"><code></code></span>
<span class="codeline" id="line-5811"><code>	if f.HasPriority() {</code></span>
<span class="codeline" id="line-5812"><code>		if err := sc.checkPriority(f.StreamID, f.Priority); err != nil {</code></span>
<span class="codeline" id="line-5813"><code>			return err</code></span>
<span class="codeline" id="line-5814"><code>		}</code></span>
<span class="codeline" id="line-5815"><code>		sc.writeSched.AdjustStream(st.id, f.Priority)</code></span>
<span class="codeline" id="line-5816"><code>	}</code></span>
<span class="codeline" id="line-5817"><code></code></span>
<span class="codeline" id="line-5818"><code>	rw, req, err := sc.newWriterAndRequest(st, f)</code></span>
<span class="codeline" id="line-5819"><code>	if err != nil {</code></span>
<span class="codeline" id="line-5820"><code>		return err</code></span>
<span class="codeline" id="line-5821"><code>	}</code></span>
<span class="codeline" id="line-5822"><code>	st.reqTrailer = req.Trailer</code></span>
<span class="codeline" id="line-5823"><code>	if st.reqTrailer != nil {</code></span>
<span class="codeline" id="line-5824"><code>		st.trailer = make(Header)</code></span>
<span class="codeline" id="line-5825"><code>	}</code></span>
<span class="codeline" id="line-5826"><code>	st.body = req.Body.(*http2requestBody).pipe // may be nil</code></span>
<span class="codeline" id="line-5827"><code>	st.declBodyBytes = req.ContentLength</code></span>
<span class="codeline" id="line-5828"><code></code></span>
<span class="codeline" id="line-5829"><code>	handler := sc.handler.ServeHTTP</code></span>
<span class="codeline" id="line-5830"><code>	if f.Truncated {</code></span>
<span class="codeline" id="line-5831"><code>		// Their header list was too long. Send a 431 error.</code></span>
<span class="codeline" id="line-5832"><code>		handler = http2handleHeaderListTooLong</code></span>
<span class="codeline" id="line-5833"><code>	} else if err := http2checkValidHTTP2RequestHeaders(req.Header); err != nil {</code></span>
<span class="codeline" id="line-5834"><code>		handler = http2new400Handler(err)</code></span>
<span class="codeline" id="line-5835"><code>	}</code></span>
<span class="codeline" id="line-5836"><code></code></span>
<span class="codeline" id="line-5837"><code>	// The net/http package sets the read deadline from the</code></span>
<span class="codeline" id="line-5838"><code>	// http.Server.ReadTimeout during the TLS handshake, but then</code></span>
<span class="codeline" id="line-5839"><code>	// passes the connection off to us with the deadline already</code></span>
<span class="codeline" id="line-5840"><code>	// set. Disarm it here after the request headers are read,</code></span>
<span class="codeline" id="line-5841"><code>	// similar to how the http1 server works. Here it's</code></span>
<span class="codeline" id="line-5842"><code>	// technically more like the http1 Server's ReadHeaderTimeout</code></span>
<span class="codeline" id="line-5843"><code>	// (in Go 1.8), though. That's a more sane option anyway.</code></span>
<span class="codeline" id="line-5844"><code>	if sc.hs.ReadTimeout != 0 {</code></span>
<span class="codeline" id="line-5845"><code>		sc.conn.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-5846"><code>		st.readDeadline = time.AfterFunc(sc.hs.ReadTimeout, st.onReadTimeout)</code></span>
<span class="codeline" id="line-5847"><code>	}</code></span>
<span class="codeline" id="line-5848"><code></code></span>
<span class="codeline" id="line-5849"><code>	return sc.scheduleHandler(id, rw, req, handler)</code></span>
<span class="codeline" id="line-5850"><code>}</code></span>
<span class="codeline" id="line-5851"><code></code></span>
<span class="codeline" id="line-5852"><code>func (sc *http2serverConn) upgradeRequest(req *Request) {</code></span>
<span class="codeline" id="line-5853"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5854"><code>	id := uint32(1)</code></span>
<span class="codeline" id="line-5855"><code>	sc.maxClientStreamID = id</code></span>
<span class="codeline" id="line-5856"><code>	st := sc.newStream(id, 0, http2stateHalfClosedRemote)</code></span>
<span class="codeline" id="line-5857"><code>	st.reqTrailer = req.Trailer</code></span>
<span class="codeline" id="line-5858"><code>	if st.reqTrailer != nil {</code></span>
<span class="codeline" id="line-5859"><code>		st.trailer = make(Header)</code></span>
<span class="codeline" id="line-5860"><code>	}</code></span>
<span class="codeline" id="line-5861"><code>	rw := sc.newResponseWriter(st, req)</code></span>
<span class="codeline" id="line-5862"><code></code></span>
<span class="codeline" id="line-5863"><code>	// Disable any read deadline set by the net/http package</code></span>
<span class="codeline" id="line-5864"><code>	// prior to the upgrade.</code></span>
<span class="codeline" id="line-5865"><code>	if sc.hs.ReadTimeout != 0 {</code></span>
<span class="codeline" id="line-5866"><code>		sc.conn.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-5867"><code>	}</code></span>
<span class="codeline" id="line-5868"><code></code></span>
<span class="codeline" id="line-5869"><code>	// This is the first request on the connection,</code></span>
<span class="codeline" id="line-5870"><code>	// so start the handler directly rather than going</code></span>
<span class="codeline" id="line-5871"><code>	// through scheduleHandler.</code></span>
<span class="codeline" id="line-5872"><code>	sc.curHandlers++</code></span>
<span class="codeline" id="line-5873"><code>	go sc.runHandler(rw, req, sc.handler.ServeHTTP)</code></span>
<span class="codeline" id="line-5874"><code>}</code></span>
<span class="codeline" id="line-5875"><code></code></span>
<span class="codeline" id="line-5876"><code>func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error {</code></span>
<span class="codeline" id="line-5877"><code>	sc := st.sc</code></span>
<span class="codeline" id="line-5878"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5879"><code>	if st.gotTrailerHeader {</code></span>
<span class="codeline" id="line-5880"><code>		return sc.countError("dup_trailers", http2ConnectionError(http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5881"><code>	}</code></span>
<span class="codeline" id="line-5882"><code>	st.gotTrailerHeader = true</code></span>
<span class="codeline" id="line-5883"><code>	if !f.StreamEnded() {</code></span>
<span class="codeline" id="line-5884"><code>		return sc.countError("trailers_not_ended", http2streamError(st.id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5885"><code>	}</code></span>
<span class="codeline" id="line-5886"><code></code></span>
<span class="codeline" id="line-5887"><code>	if len(f.PseudoFields()) &gt; 0 {</code></span>
<span class="codeline" id="line-5888"><code>		return sc.countError("trailers_pseudo", http2streamError(st.id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5889"><code>	}</code></span>
<span class="codeline" id="line-5890"><code>	if st.trailer != nil {</code></span>
<span class="codeline" id="line-5891"><code>		for _, hf := range f.RegularFields() {</code></span>
<span class="codeline" id="line-5892"><code>			key := sc.canonicalHeader(hf.Name)</code></span>
<span class="codeline" id="line-5893"><code>			if !httpguts.ValidTrailerHeader(key) {</code></span>
<span class="codeline" id="line-5894"><code>				// TODO: send more details to the peer somehow. But http2 has</code></span>
<span class="codeline" id="line-5895"><code>				// no way to send debug data at a stream level. Discuss with</code></span>
<span class="codeline" id="line-5896"><code>				// HTTP folk.</code></span>
<span class="codeline" id="line-5897"><code>				return sc.countError("trailers_bogus", http2streamError(st.id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5898"><code>			}</code></span>
<span class="codeline" id="line-5899"><code>			st.trailer[key] = append(st.trailer[key], hf.Value)</code></span>
<span class="codeline" id="line-5900"><code>		}</code></span>
<span class="codeline" id="line-5901"><code>	}</code></span>
<span class="codeline" id="line-5902"><code>	st.endStream()</code></span>
<span class="codeline" id="line-5903"><code>	return nil</code></span>
<span class="codeline" id="line-5904"><code>}</code></span>
<span class="codeline" id="line-5905"><code></code></span>
<span class="codeline" id="line-5906"><code>func (sc *http2serverConn) checkPriority(streamID uint32, p http2PriorityParam) error {</code></span>
<span class="codeline" id="line-5907"><code>	if streamID == p.StreamDep {</code></span>
<span class="codeline" id="line-5908"><code>		// Section 5.3.1: "A stream cannot depend on itself. An endpoint MUST treat</code></span>
<span class="codeline" id="line-5909"><code>		// this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5910"><code>		// Section 5.3.3 says that a stream can depend on one of its dependencies,</code></span>
<span class="codeline" id="line-5911"><code>		// so it's only self-dependencies that are forbidden.</code></span>
<span class="codeline" id="line-5912"><code>		return sc.countError("priority", http2streamError(streamID, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5913"><code>	}</code></span>
<span class="codeline" id="line-5914"><code>	return nil</code></span>
<span class="codeline" id="line-5915"><code>}</code></span>
<span class="codeline" id="line-5916"><code></code></span>
<span class="codeline" id="line-5917"><code>func (sc *http2serverConn) processPriority(f *http2PriorityFrame) error {</code></span>
<span class="codeline" id="line-5918"><code>	if err := sc.checkPriority(f.StreamID, f.http2PriorityParam); err != nil {</code></span>
<span class="codeline" id="line-5919"><code>		return err</code></span>
<span class="codeline" id="line-5920"><code>	}</code></span>
<span class="codeline" id="line-5921"><code>	sc.writeSched.AdjustStream(f.StreamID, f.http2PriorityParam)</code></span>
<span class="codeline" id="line-5922"><code>	return nil</code></span>
<span class="codeline" id="line-5923"><code>}</code></span>
<span class="codeline" id="line-5924"><code></code></span>
<span class="codeline" id="line-5925"><code>func (sc *http2serverConn) newStream(id, pusherID uint32, state http2streamState) *http2stream {</code></span>
<span class="codeline" id="line-5926"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5927"><code>	if id == 0 {</code></span>
<span class="codeline" id="line-5928"><code>		panic("internal error: cannot create stream with id 0")</code></span>
<span class="codeline" id="line-5929"><code>	}</code></span>
<span class="codeline" id="line-5930"><code></code></span>
<span class="codeline" id="line-5931"><code>	ctx, cancelCtx := context.WithCancel(sc.baseCtx)</code></span>
<span class="codeline" id="line-5932"><code>	st := &amp;http2stream{</code></span>
<span class="codeline" id="line-5933"><code>		sc:        sc,</code></span>
<span class="codeline" id="line-5934"><code>		id:        id,</code></span>
<span class="codeline" id="line-5935"><code>		state:     state,</code></span>
<span class="codeline" id="line-5936"><code>		ctx:       ctx,</code></span>
<span class="codeline" id="line-5937"><code>		cancelCtx: cancelCtx,</code></span>
<span class="codeline" id="line-5938"><code>	}</code></span>
<span class="codeline" id="line-5939"><code>	st.cw.Init()</code></span>
<span class="codeline" id="line-5940"><code>	st.flow.conn = &amp;sc.flow // link to conn-level counter</code></span>
<span class="codeline" id="line-5941"><code>	st.flow.add(sc.initialStreamSendWindowSize)</code></span>
<span class="codeline" id="line-5942"><code>	st.inflow.init(sc.srv.initialStreamRecvWindowSize())</code></span>
<span class="codeline" id="line-5943"><code>	if sc.hs.WriteTimeout != 0 {</code></span>
<span class="codeline" id="line-5944"><code>		st.writeDeadline = time.AfterFunc(sc.hs.WriteTimeout, st.onWriteTimeout)</code></span>
<span class="codeline" id="line-5945"><code>	}</code></span>
<span class="codeline" id="line-5946"><code></code></span>
<span class="codeline" id="line-5947"><code>	sc.streams[id] = st</code></span>
<span class="codeline" id="line-5948"><code>	sc.writeSched.OpenStream(st.id, http2OpenStreamOptions{PusherID: pusherID})</code></span>
<span class="codeline" id="line-5949"><code>	if st.isPushed() {</code></span>
<span class="codeline" id="line-5950"><code>		sc.curPushedStreams++</code></span>
<span class="codeline" id="line-5951"><code>	} else {</code></span>
<span class="codeline" id="line-5952"><code>		sc.curClientStreams++</code></span>
<span class="codeline" id="line-5953"><code>	}</code></span>
<span class="codeline" id="line-5954"><code>	if sc.curOpenStreams() == 1 {</code></span>
<span class="codeline" id="line-5955"><code>		sc.setConnState(StateActive)</code></span>
<span class="codeline" id="line-5956"><code>	}</code></span>
<span class="codeline" id="line-5957"><code></code></span>
<span class="codeline" id="line-5958"><code>	return st</code></span>
<span class="codeline" id="line-5959"><code>}</code></span>
<span class="codeline" id="line-5960"><code></code></span>
<span class="codeline" id="line-5961"><code>func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHeadersFrame) (*http2responseWriter, *Request, error) {</code></span>
<span class="codeline" id="line-5962"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-5963"><code></code></span>
<span class="codeline" id="line-5964"><code>	rp := http2requestParam{</code></span>
<span class="codeline" id="line-5965"><code>		method:    f.PseudoValue("method"),</code></span>
<span class="codeline" id="line-5966"><code>		scheme:    f.PseudoValue("scheme"),</code></span>
<span class="codeline" id="line-5967"><code>		authority: f.PseudoValue("authority"),</code></span>
<span class="codeline" id="line-5968"><code>		path:      f.PseudoValue("path"),</code></span>
<span class="codeline" id="line-5969"><code>	}</code></span>
<span class="codeline" id="line-5970"><code></code></span>
<span class="codeline" id="line-5971"><code>	isConnect := rp.method == "CONNECT"</code></span>
<span class="codeline" id="line-5972"><code>	if isConnect {</code></span>
<span class="codeline" id="line-5973"><code>		if rp.path != "" || rp.scheme != "" || rp.authority == "" {</code></span>
<span class="codeline" id="line-5974"><code>			return nil, nil, sc.countError("bad_connect", http2streamError(f.StreamID, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5975"><code>		}</code></span>
<span class="codeline" id="line-5976"><code>	} else if rp.method == "" || rp.path == "" || (rp.scheme != "https" &amp;&amp; rp.scheme != "http") {</code></span>
<span class="codeline" id="line-5977"><code>		// See 8.1.2.6 Malformed Requests and Responses:</code></span>
<span class="codeline" id="line-5978"><code>		//</code></span>
<span class="codeline" id="line-5979"><code>		// Malformed requests or responses that are detected</code></span>
<span class="codeline" id="line-5980"><code>		// MUST be treated as a stream error (Section 5.4.2)</code></span>
<span class="codeline" id="line-5981"><code>		// of type PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-5982"><code>		//</code></span>
<span class="codeline" id="line-5983"><code>		// 8.1.2.3 Request Pseudo-Header Fields</code></span>
<span class="codeline" id="line-5984"><code>		// "All HTTP/2 requests MUST include exactly one valid</code></span>
<span class="codeline" id="line-5985"><code>		// value for the :method, :scheme, and :path</code></span>
<span class="codeline" id="line-5986"><code>		// pseudo-header fields"</code></span>
<span class="codeline" id="line-5987"><code>		return nil, nil, sc.countError("bad_path_method", http2streamError(f.StreamID, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-5988"><code>	}</code></span>
<span class="codeline" id="line-5989"><code></code></span>
<span class="codeline" id="line-5990"><code>	rp.header = make(Header)</code></span>
<span class="codeline" id="line-5991"><code>	for _, hf := range f.RegularFields() {</code></span>
<span class="codeline" id="line-5992"><code>		rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value)</code></span>
<span class="codeline" id="line-5993"><code>	}</code></span>
<span class="codeline" id="line-5994"><code>	if rp.authority == "" {</code></span>
<span class="codeline" id="line-5995"><code>		rp.authority = rp.header.Get("Host")</code></span>
<span class="codeline" id="line-5996"><code>	}</code></span>
<span class="codeline" id="line-5997"><code></code></span>
<span class="codeline" id="line-5998"><code>	rw, req, err := sc.newWriterAndRequestNoBody(st, rp)</code></span>
<span class="codeline" id="line-5999"><code>	if err != nil {</code></span>
<span class="codeline" id="line-6000"><code>		return nil, nil, err</code></span>
<span class="codeline" id="line-6001"><code>	}</code></span>
<span class="codeline" id="line-6002"><code>	bodyOpen := !f.StreamEnded()</code></span>
<span class="codeline" id="line-6003"><code>	if bodyOpen {</code></span>
<span class="codeline" id="line-6004"><code>		if vv, ok := rp.header["Content-Length"]; ok {</code></span>
<span class="codeline" id="line-6005"><code>			if cl, err := strconv.ParseUint(vv[0], 10, 63); err == nil {</code></span>
<span class="codeline" id="line-6006"><code>				req.ContentLength = int64(cl)</code></span>
<span class="codeline" id="line-6007"><code>			} else {</code></span>
<span class="codeline" id="line-6008"><code>				req.ContentLength = 0</code></span>
<span class="codeline" id="line-6009"><code>			}</code></span>
<span class="codeline" id="line-6010"><code>		} else {</code></span>
<span class="codeline" id="line-6011"><code>			req.ContentLength = -1</code></span>
<span class="codeline" id="line-6012"><code>		}</code></span>
<span class="codeline" id="line-6013"><code>		req.Body.(*http2requestBody).pipe = &amp;http2pipe{</code></span>
<span class="codeline" id="line-6014"><code>			b: &amp;http2dataBuffer{expected: req.ContentLength},</code></span>
<span class="codeline" id="line-6015"><code>		}</code></span>
<span class="codeline" id="line-6016"><code>	}</code></span>
<span class="codeline" id="line-6017"><code>	return rw, req, nil</code></span>
<span class="codeline" id="line-6018"><code>}</code></span>
<span class="codeline" id="line-6019"><code></code></span>
<span class="codeline" id="line-6020"><code>type http2requestParam struct {</code></span>
<span class="codeline" id="line-6021"><code>	method                  string</code></span>
<span class="codeline" id="line-6022"><code>	scheme, authority, path string</code></span>
<span class="codeline" id="line-6023"><code>	header                  Header</code></span>
<span class="codeline" id="line-6024"><code>}</code></span>
<span class="codeline" id="line-6025"><code></code></span>
<span class="codeline" id="line-6026"><code>func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2requestParam) (*http2responseWriter, *Request, error) {</code></span>
<span class="codeline" id="line-6027"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6028"><code></code></span>
<span class="codeline" id="line-6029"><code>	var tlsState *tls.ConnectionState // nil if not scheme https</code></span>
<span class="codeline" id="line-6030"><code>	if rp.scheme == "https" {</code></span>
<span class="codeline" id="line-6031"><code>		tlsState = sc.tlsState</code></span>
<span class="codeline" id="line-6032"><code>	}</code></span>
<span class="codeline" id="line-6033"><code></code></span>
<span class="codeline" id="line-6034"><code>	needsContinue := httpguts.HeaderValuesContainsToken(rp.header["Expect"], "100-continue")</code></span>
<span class="codeline" id="line-6035"><code>	if needsContinue {</code></span>
<span class="codeline" id="line-6036"><code>		rp.header.Del("Expect")</code></span>
<span class="codeline" id="line-6037"><code>	}</code></span>
<span class="codeline" id="line-6038"><code>	// Merge Cookie headers into one "; "-delimited value.</code></span>
<span class="codeline" id="line-6039"><code>	if cookies := rp.header["Cookie"]; len(cookies) &gt; 1 {</code></span>
<span class="codeline" id="line-6040"><code>		rp.header.Set("Cookie", strings.Join(cookies, "; "))</code></span>
<span class="codeline" id="line-6041"><code>	}</code></span>
<span class="codeline" id="line-6042"><code></code></span>
<span class="codeline" id="line-6043"><code>	// Setup Trailers</code></span>
<span class="codeline" id="line-6044"><code>	var trailer Header</code></span>
<span class="codeline" id="line-6045"><code>	for _, v := range rp.header["Trailer"] {</code></span>
<span class="codeline" id="line-6046"><code>		for _, key := range strings.Split(v, ",") {</code></span>
<span class="codeline" id="line-6047"><code>			key = CanonicalHeaderKey(textproto.TrimString(key))</code></span>
<span class="codeline" id="line-6048"><code>			switch key {</code></span>
<span class="codeline" id="line-6049"><code>			case "Transfer-Encoding", "Trailer", "Content-Length":</code></span>
<span class="codeline" id="line-6050"><code>				// Bogus. (copy of http1 rules)</code></span>
<span class="codeline" id="line-6051"><code>				// Ignore.</code></span>
<span class="codeline" id="line-6052"><code>			default:</code></span>
<span class="codeline" id="line-6053"><code>				if trailer == nil {</code></span>
<span class="codeline" id="line-6054"><code>					trailer = make(Header)</code></span>
<span class="codeline" id="line-6055"><code>				}</code></span>
<span class="codeline" id="line-6056"><code>				trailer[key] = nil</code></span>
<span class="codeline" id="line-6057"><code>			}</code></span>
<span class="codeline" id="line-6058"><code>		}</code></span>
<span class="codeline" id="line-6059"><code>	}</code></span>
<span class="codeline" id="line-6060"><code>	delete(rp.header, "Trailer")</code></span>
<span class="codeline" id="line-6061"><code></code></span>
<span class="codeline" id="line-6062"><code>	var url_ *url.URL</code></span>
<span class="codeline" id="line-6063"><code>	var requestURI string</code></span>
<span class="codeline" id="line-6064"><code>	if rp.method == "CONNECT" {</code></span>
<span class="codeline" id="line-6065"><code>		url_ = &amp;url.URL{Host: rp.authority}</code></span>
<span class="codeline" id="line-6066"><code>		requestURI = rp.authority // mimic HTTP/1 server behavior</code></span>
<span class="codeline" id="line-6067"><code>	} else {</code></span>
<span class="codeline" id="line-6068"><code>		var err error</code></span>
<span class="codeline" id="line-6069"><code>		url_, err = url.ParseRequestURI(rp.path)</code></span>
<span class="codeline" id="line-6070"><code>		if err != nil {</code></span>
<span class="codeline" id="line-6071"><code>			return nil, nil, sc.countError("bad_path", http2streamError(st.id, http2ErrCodeProtocol))</code></span>
<span class="codeline" id="line-6072"><code>		}</code></span>
<span class="codeline" id="line-6073"><code>		requestURI = rp.path</code></span>
<span class="codeline" id="line-6074"><code>	}</code></span>
<span class="codeline" id="line-6075"><code></code></span>
<span class="codeline" id="line-6076"><code>	body := &amp;http2requestBody{</code></span>
<span class="codeline" id="line-6077"><code>		conn:          sc,</code></span>
<span class="codeline" id="line-6078"><code>		stream:        st,</code></span>
<span class="codeline" id="line-6079"><code>		needsContinue: needsContinue,</code></span>
<span class="codeline" id="line-6080"><code>	}</code></span>
<span class="codeline" id="line-6081"><code>	req := &amp;Request{</code></span>
<span class="codeline" id="line-6082"><code>		Method:     rp.method,</code></span>
<span class="codeline" id="line-6083"><code>		URL:        url_,</code></span>
<span class="codeline" id="line-6084"><code>		RemoteAddr: sc.remoteAddrStr,</code></span>
<span class="codeline" id="line-6085"><code>		Header:     rp.header,</code></span>
<span class="codeline" id="line-6086"><code>		RequestURI: requestURI,</code></span>
<span class="codeline" id="line-6087"><code>		Proto:      "HTTP/2.0",</code></span>
<span class="codeline" id="line-6088"><code>		ProtoMajor: 2,</code></span>
<span class="codeline" id="line-6089"><code>		ProtoMinor: 0,</code></span>
<span class="codeline" id="line-6090"><code>		TLS:        tlsState,</code></span>
<span class="codeline" id="line-6091"><code>		Host:       rp.authority,</code></span>
<span class="codeline" id="line-6092"><code>		Body:       body,</code></span>
<span class="codeline" id="line-6093"><code>		Trailer:    trailer,</code></span>
<span class="codeline" id="line-6094"><code>	}</code></span>
<span class="codeline" id="line-6095"><code>	req = req.WithContext(st.ctx)</code></span>
<span class="codeline" id="line-6096"><code></code></span>
<span class="codeline" id="line-6097"><code>	rw := sc.newResponseWriter(st, req)</code></span>
<span class="codeline" id="line-6098"><code>	return rw, req, nil</code></span>
<span class="codeline" id="line-6099"><code>}</code></span>
<span class="codeline" id="line-6100"><code></code></span>
<span class="codeline" id="line-6101"><code>func (sc *http2serverConn) newResponseWriter(st *http2stream, req *Request) *http2responseWriter {</code></span>
<span class="codeline" id="line-6102"><code>	rws := http2responseWriterStatePool.Get().(*http2responseWriterState)</code></span>
<span class="codeline" id="line-6103"><code>	bwSave := rws.bw</code></span>
<span class="codeline" id="line-6104"><code>	*rws = http2responseWriterState{} // zero all the fields</code></span>
<span class="codeline" id="line-6105"><code>	rws.conn = sc</code></span>
<span class="codeline" id="line-6106"><code>	rws.bw = bwSave</code></span>
<span class="codeline" id="line-6107"><code>	rws.bw.Reset(http2chunkWriter{rws})</code></span>
<span class="codeline" id="line-6108"><code>	rws.stream = st</code></span>
<span class="codeline" id="line-6109"><code>	rws.req = req</code></span>
<span class="codeline" id="line-6110"><code>	return &amp;http2responseWriter{rws: rws}</code></span>
<span class="codeline" id="line-6111"><code>}</code></span>
<span class="codeline" id="line-6112"><code></code></span>
<span class="codeline" id="line-6113"><code>type http2unstartedHandler struct {</code></span>
<span class="codeline" id="line-6114"><code>	streamID uint32</code></span>
<span class="codeline" id="line-6115"><code>	rw       *http2responseWriter</code></span>
<span class="codeline" id="line-6116"><code>	req      *Request</code></span>
<span class="codeline" id="line-6117"><code>	handler  func(ResponseWriter, *Request)</code></span>
<span class="codeline" id="line-6118"><code>}</code></span>
<span class="codeline" id="line-6119"><code></code></span>
<span class="codeline" id="line-6120"><code>// scheduleHandler starts a handler goroutine,</code></span>
<span class="codeline" id="line-6121"><code>// or schedules one to start as soon as an existing handler finishes.</code></span>
<span class="codeline" id="line-6122"><code>func (sc *http2serverConn) scheduleHandler(streamID uint32, rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request)) error {</code></span>
<span class="codeline" id="line-6123"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6124"><code>	maxHandlers := sc.advMaxStreams</code></span>
<span class="codeline" id="line-6125"><code>	if sc.curHandlers &lt; maxHandlers {</code></span>
<span class="codeline" id="line-6126"><code>		sc.curHandlers++</code></span>
<span class="codeline" id="line-6127"><code>		go sc.runHandler(rw, req, handler)</code></span>
<span class="codeline" id="line-6128"><code>		return nil</code></span>
<span class="codeline" id="line-6129"><code>	}</code></span>
<span class="codeline" id="line-6130"><code>	if len(sc.unstartedHandlers) &gt; int(4*sc.advMaxStreams) {</code></span>
<span class="codeline" id="line-6131"><code>		return sc.countError("too_many_early_resets", http2ConnectionError(http2ErrCodeEnhanceYourCalm))</code></span>
<span class="codeline" id="line-6132"><code>	}</code></span>
<span class="codeline" id="line-6133"><code>	sc.unstartedHandlers = append(sc.unstartedHandlers, http2unstartedHandler{</code></span>
<span class="codeline" id="line-6134"><code>		streamID: streamID,</code></span>
<span class="codeline" id="line-6135"><code>		rw:       rw,</code></span>
<span class="codeline" id="line-6136"><code>		req:      req,</code></span>
<span class="codeline" id="line-6137"><code>		handler:  handler,</code></span>
<span class="codeline" id="line-6138"><code>	})</code></span>
<span class="codeline" id="line-6139"><code>	return nil</code></span>
<span class="codeline" id="line-6140"><code>}</code></span>
<span class="codeline" id="line-6141"><code></code></span>
<span class="codeline" id="line-6142"><code>func (sc *http2serverConn) handlerDone() {</code></span>
<span class="codeline" id="line-6143"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6144"><code>	sc.curHandlers--</code></span>
<span class="codeline" id="line-6145"><code>	i := 0</code></span>
<span class="codeline" id="line-6146"><code>	maxHandlers := sc.advMaxStreams</code></span>
<span class="codeline" id="line-6147"><code>	for ; i &lt; len(sc.unstartedHandlers); i++ {</code></span>
<span class="codeline" id="line-6148"><code>		u := sc.unstartedHandlers[i]</code></span>
<span class="codeline" id="line-6149"><code>		if sc.streams[u.streamID] == nil {</code></span>
<span class="codeline" id="line-6150"><code>			// This stream was reset before its goroutine had a chance to start.</code></span>
<span class="codeline" id="line-6151"><code>			continue</code></span>
<span class="codeline" id="line-6152"><code>		}</code></span>
<span class="codeline" id="line-6153"><code>		if sc.curHandlers &gt;= maxHandlers {</code></span>
<span class="codeline" id="line-6154"><code>			break</code></span>
<span class="codeline" id="line-6155"><code>		}</code></span>
<span class="codeline" id="line-6156"><code>		sc.curHandlers++</code></span>
<span class="codeline" id="line-6157"><code>		go sc.runHandler(u.rw, u.req, u.handler)</code></span>
<span class="codeline" id="line-6158"><code>		sc.unstartedHandlers[i] = http2unstartedHandler{} // don't retain references</code></span>
<span class="codeline" id="line-6159"><code>	}</code></span>
<span class="codeline" id="line-6160"><code>	sc.unstartedHandlers = sc.unstartedHandlers[i:]</code></span>
<span class="codeline" id="line-6161"><code>	if len(sc.unstartedHandlers) == 0 {</code></span>
<span class="codeline" id="line-6162"><code>		sc.unstartedHandlers = nil</code></span>
<span class="codeline" id="line-6163"><code>	}</code></span>
<span class="codeline" id="line-6164"><code>}</code></span>
<span class="codeline" id="line-6165"><code></code></span>
<span class="codeline" id="line-6166"><code>// Run on its own goroutine.</code></span>
<span class="codeline" id="line-6167"><code>func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request)) {</code></span>
<span class="codeline" id="line-6168"><code>	defer sc.sendServeMsg(http2handlerDoneMsg)</code></span>
<span class="codeline" id="line-6169"><code>	didPanic := true</code></span>
<span class="codeline" id="line-6170"><code>	defer func() {</code></span>
<span class="codeline" id="line-6171"><code>		rw.rws.stream.cancelCtx()</code></span>
<span class="codeline" id="line-6172"><code>		if req.MultipartForm != nil {</code></span>
<span class="codeline" id="line-6173"><code>			req.MultipartForm.RemoveAll()</code></span>
<span class="codeline" id="line-6174"><code>		}</code></span>
<span class="codeline" id="line-6175"><code>		if didPanic {</code></span>
<span class="codeline" id="line-6176"><code>			e := recover()</code></span>
<span class="codeline" id="line-6177"><code>			sc.writeFrameFromHandler(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-6178"><code>				write:  http2handlerPanicRST{rw.rws.stream.id},</code></span>
<span class="codeline" id="line-6179"><code>				stream: rw.rws.stream,</code></span>
<span class="codeline" id="line-6180"><code>			})</code></span>
<span class="codeline" id="line-6181"><code>			// Same as net/http:</code></span>
<span class="codeline" id="line-6182"><code>			if e != nil &amp;&amp; e != ErrAbortHandler {</code></span>
<span class="codeline" id="line-6183"><code>				const size = 64 &lt;&lt; 10</code></span>
<span class="codeline" id="line-6184"><code>				buf := make([]byte, size)</code></span>
<span class="codeline" id="line-6185"><code>				buf = buf[:runtime.Stack(buf, false)]</code></span>
<span class="codeline" id="line-6186"><code>				sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf)</code></span>
<span class="codeline" id="line-6187"><code>			}</code></span>
<span class="codeline" id="line-6188"><code>			return</code></span>
<span class="codeline" id="line-6189"><code>		}</code></span>
<span class="codeline" id="line-6190"><code>		rw.handlerDone()</code></span>
<span class="codeline" id="line-6191"><code>	}()</code></span>
<span class="codeline" id="line-6192"><code>	handler(rw, req)</code></span>
<span class="codeline" id="line-6193"><code>	didPanic = false</code></span>
<span class="codeline" id="line-6194"><code>}</code></span>
<span class="codeline" id="line-6195"><code></code></span>
<span class="codeline" id="line-6196"><code>func http2handleHeaderListTooLong(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-6197"><code>	// 10.5.1 Limits on Header Block Size:</code></span>
<span class="codeline" id="line-6198"><code>	// .. "A server that receives a larger header block than it is</code></span>
<span class="codeline" id="line-6199"><code>	// willing to handle can send an HTTP 431 (Request Header Fields Too</code></span>
<span class="codeline" id="line-6200"><code>	// Large) status code"</code></span>
<span class="codeline" id="line-6201"><code>	const statusRequestHeaderFieldsTooLarge = 431 // only in Go 1.6+</code></span>
<span class="codeline" id="line-6202"><code>	w.WriteHeader(statusRequestHeaderFieldsTooLarge)</code></span>
<span class="codeline" id="line-6203"><code>	io.WriteString(w, "&lt;h1&gt;HTTP Error 431&lt;/h1&gt;&lt;p&gt;Request Header Field(s) Too Large&lt;/p&gt;")</code></span>
<span class="codeline" id="line-6204"><code>}</code></span>
<span class="codeline" id="line-6205"><code></code></span>
<span class="codeline" id="line-6206"><code>// called from handler goroutines.</code></span>
<span class="codeline" id="line-6207"><code>// h may be nil.</code></span>
<span class="codeline" id="line-6208"><code>func (sc *http2serverConn) writeHeaders(st *http2stream, headerData *http2writeResHeaders) error {</code></span>
<span class="codeline" id="line-6209"><code>	sc.serveG.checkNotOn() // NOT on</code></span>
<span class="codeline" id="line-6210"><code>	var errc chan error</code></span>
<span class="codeline" id="line-6211"><code>	if headerData.h != nil {</code></span>
<span class="codeline" id="line-6212"><code>		// If there's a header map (which we don't own), so we have to block on</code></span>
<span class="codeline" id="line-6213"><code>		// waiting for this frame to be written, so an http.Flush mid-handler</code></span>
<span class="codeline" id="line-6214"><code>		// writes out the correct value of keys, before a handler later potentially</code></span>
<span class="codeline" id="line-6215"><code>		// mutates it.</code></span>
<span class="codeline" id="line-6216"><code>		errc = http2errChanPool.Get().(chan error)</code></span>
<span class="codeline" id="line-6217"><code>	}</code></span>
<span class="codeline" id="line-6218"><code>	if err := sc.writeFrameFromHandler(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-6219"><code>		write:  headerData,</code></span>
<span class="codeline" id="line-6220"><code>		stream: st,</code></span>
<span class="codeline" id="line-6221"><code>		done:   errc,</code></span>
<span class="codeline" id="line-6222"><code>	}); err != nil {</code></span>
<span class="codeline" id="line-6223"><code>		return err</code></span>
<span class="codeline" id="line-6224"><code>	}</code></span>
<span class="codeline" id="line-6225"><code>	if errc != nil {</code></span>
<span class="codeline" id="line-6226"><code>		select {</code></span>
<span class="codeline" id="line-6227"><code>		case err := &lt;-errc:</code></span>
<span class="codeline" id="line-6228"><code>			http2errChanPool.Put(errc)</code></span>
<span class="codeline" id="line-6229"><code>			return err</code></span>
<span class="codeline" id="line-6230"><code>		case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-6231"><code>			return http2errClientDisconnected</code></span>
<span class="codeline" id="line-6232"><code>		case &lt;-st.cw:</code></span>
<span class="codeline" id="line-6233"><code>			return http2errStreamClosed</code></span>
<span class="codeline" id="line-6234"><code>		}</code></span>
<span class="codeline" id="line-6235"><code>	}</code></span>
<span class="codeline" id="line-6236"><code>	return nil</code></span>
<span class="codeline" id="line-6237"><code>}</code></span>
<span class="codeline" id="line-6238"><code></code></span>
<span class="codeline" id="line-6239"><code>// called from handler goroutines.</code></span>
<span class="codeline" id="line-6240"><code>func (sc *http2serverConn) write100ContinueHeaders(st *http2stream) {</code></span>
<span class="codeline" id="line-6241"><code>	sc.writeFrameFromHandler(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-6242"><code>		write:  http2write100ContinueHeadersFrame{st.id},</code></span>
<span class="codeline" id="line-6243"><code>		stream: st,</code></span>
<span class="codeline" id="line-6244"><code>	})</code></span>
<span class="codeline" id="line-6245"><code>}</code></span>
<span class="codeline" id="line-6246"><code></code></span>
<span class="codeline" id="line-6247"><code>// A bodyReadMsg tells the server loop that the http.Handler read n</code></span>
<span class="codeline" id="line-6248"><code>// bytes of the DATA from the client on the given stream.</code></span>
<span class="codeline" id="line-6249"><code>type http2bodyReadMsg struct {</code></span>
<span class="codeline" id="line-6250"><code>	st *http2stream</code></span>
<span class="codeline" id="line-6251"><code>	n  int</code></span>
<span class="codeline" id="line-6252"><code>}</code></span>
<span class="codeline" id="line-6253"><code></code></span>
<span class="codeline" id="line-6254"><code>// called from handler goroutines.</code></span>
<span class="codeline" id="line-6255"><code>// Notes that the handler for the given stream ID read n bytes of its body</code></span>
<span class="codeline" id="line-6256"><code>// and schedules flow control tokens to be sent.</code></span>
<span class="codeline" id="line-6257"><code>func (sc *http2serverConn) noteBodyReadFromHandler(st *http2stream, n int, err error) {</code></span>
<span class="codeline" id="line-6258"><code>	sc.serveG.checkNotOn() // NOT on</code></span>
<span class="codeline" id="line-6259"><code>	if n &gt; 0 {</code></span>
<span class="codeline" id="line-6260"><code>		select {</code></span>
<span class="codeline" id="line-6261"><code>		case sc.bodyReadCh &lt;- http2bodyReadMsg{st, n}:</code></span>
<span class="codeline" id="line-6262"><code>		case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-6263"><code>		}</code></span>
<span class="codeline" id="line-6264"><code>	}</code></span>
<span class="codeline" id="line-6265"><code>}</code></span>
<span class="codeline" id="line-6266"><code></code></span>
<span class="codeline" id="line-6267"><code>func (sc *http2serverConn) noteBodyRead(st *http2stream, n int) {</code></span>
<span class="codeline" id="line-6268"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6269"><code>	sc.sendWindowUpdate(nil, n) // conn-level</code></span>
<span class="codeline" id="line-6270"><code>	if st.state != http2stateHalfClosedRemote &amp;&amp; st.state != http2stateClosed {</code></span>
<span class="codeline" id="line-6271"><code>		// Don't send this WINDOW_UPDATE if the stream is closed</code></span>
<span class="codeline" id="line-6272"><code>		// remotely.</code></span>
<span class="codeline" id="line-6273"><code>		sc.sendWindowUpdate(st, n)</code></span>
<span class="codeline" id="line-6274"><code>	}</code></span>
<span class="codeline" id="line-6275"><code>}</code></span>
<span class="codeline" id="line-6276"><code></code></span>
<span class="codeline" id="line-6277"><code>// st may be nil for conn-level</code></span>
<span class="codeline" id="line-6278"><code>func (sc *http2serverConn) sendWindowUpdate32(st *http2stream, n int32) {</code></span>
<span class="codeline" id="line-6279"><code>	sc.sendWindowUpdate(st, int(n))</code></span>
<span class="codeline" id="line-6280"><code>}</code></span>
<span class="codeline" id="line-6281"><code></code></span>
<span class="codeline" id="line-6282"><code>// st may be nil for conn-level</code></span>
<span class="codeline" id="line-6283"><code>func (sc *http2serverConn) sendWindowUpdate(st *http2stream, n int) {</code></span>
<span class="codeline" id="line-6284"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6285"><code>	var streamID uint32</code></span>
<span class="codeline" id="line-6286"><code>	var send int32</code></span>
<span class="codeline" id="line-6287"><code>	if st == nil {</code></span>
<span class="codeline" id="line-6288"><code>		send = sc.inflow.add(n)</code></span>
<span class="codeline" id="line-6289"><code>	} else {</code></span>
<span class="codeline" id="line-6290"><code>		streamID = st.id</code></span>
<span class="codeline" id="line-6291"><code>		send = st.inflow.add(n)</code></span>
<span class="codeline" id="line-6292"><code>	}</code></span>
<span class="codeline" id="line-6293"><code>	if send == 0 {</code></span>
<span class="codeline" id="line-6294"><code>		return</code></span>
<span class="codeline" id="line-6295"><code>	}</code></span>
<span class="codeline" id="line-6296"><code>	sc.writeFrame(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-6297"><code>		write:  http2writeWindowUpdate{streamID: streamID, n: uint32(send)},</code></span>
<span class="codeline" id="line-6298"><code>		stream: st,</code></span>
<span class="codeline" id="line-6299"><code>	})</code></span>
<span class="codeline" id="line-6300"><code>}</code></span>
<span class="codeline" id="line-6301"><code></code></span>
<span class="codeline" id="line-6302"><code>// requestBody is the Handler's Request.Body type.</code></span>
<span class="codeline" id="line-6303"><code>// Read and Close may be called concurrently.</code></span>
<span class="codeline" id="line-6304"><code>type http2requestBody struct {</code></span>
<span class="codeline" id="line-6305"><code>	_             http2incomparable</code></span>
<span class="codeline" id="line-6306"><code>	stream        *http2stream</code></span>
<span class="codeline" id="line-6307"><code>	conn          *http2serverConn</code></span>
<span class="codeline" id="line-6308"><code>	closeOnce     sync.Once  // for use by Close only</code></span>
<span class="codeline" id="line-6309"><code>	sawEOF        bool       // for use by Read only</code></span>
<span class="codeline" id="line-6310"><code>	pipe          *http2pipe // non-nil if we have an HTTP entity message body</code></span>
<span class="codeline" id="line-6311"><code>	needsContinue bool       // need to send a 100-continue</code></span>
<span class="codeline" id="line-6312"><code>}</code></span>
<span class="codeline" id="line-6313"><code></code></span>
<span class="codeline" id="line-6314"><code>func (b *http2requestBody) Close() error {</code></span>
<span class="codeline" id="line-6315"><code>	b.closeOnce.Do(func() {</code></span>
<span class="codeline" id="line-6316"><code>		if b.pipe != nil {</code></span>
<span class="codeline" id="line-6317"><code>			b.pipe.BreakWithError(http2errClosedBody)</code></span>
<span class="codeline" id="line-6318"><code>		}</code></span>
<span class="codeline" id="line-6319"><code>	})</code></span>
<span class="codeline" id="line-6320"><code>	return nil</code></span>
<span class="codeline" id="line-6321"><code>}</code></span>
<span class="codeline" id="line-6322"><code></code></span>
<span class="codeline" id="line-6323"><code>func (b *http2requestBody) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-6324"><code>	if b.needsContinue {</code></span>
<span class="codeline" id="line-6325"><code>		b.needsContinue = false</code></span>
<span class="codeline" id="line-6326"><code>		b.conn.write100ContinueHeaders(b.stream)</code></span>
<span class="codeline" id="line-6327"><code>	}</code></span>
<span class="codeline" id="line-6328"><code>	if b.pipe == nil || b.sawEOF {</code></span>
<span class="codeline" id="line-6329"><code>		return 0, io.EOF</code></span>
<span class="codeline" id="line-6330"><code>	}</code></span>
<span class="codeline" id="line-6331"><code>	n, err = b.pipe.Read(p)</code></span>
<span class="codeline" id="line-6332"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-6333"><code>		b.sawEOF = true</code></span>
<span class="codeline" id="line-6334"><code>	}</code></span>
<span class="codeline" id="line-6335"><code>	if b.conn == nil &amp;&amp; http2inTests {</code></span>
<span class="codeline" id="line-6336"><code>		return</code></span>
<span class="codeline" id="line-6337"><code>	}</code></span>
<span class="codeline" id="line-6338"><code>	b.conn.noteBodyReadFromHandler(b.stream, n, err)</code></span>
<span class="codeline" id="line-6339"><code>	return</code></span>
<span class="codeline" id="line-6340"><code>}</code></span>
<span class="codeline" id="line-6341"><code></code></span>
<span class="codeline" id="line-6342"><code>// responseWriter is the http.ResponseWriter implementation. It's</code></span>
<span class="codeline" id="line-6343"><code>// intentionally small (1 pointer wide) to minimize garbage. The</code></span>
<span class="codeline" id="line-6344"><code>// responseWriterState pointer inside is zeroed at the end of a</code></span>
<span class="codeline" id="line-6345"><code>// request (in handlerDone) and calls on the responseWriter thereafter</code></span>
<span class="codeline" id="line-6346"><code>// simply crash (caller's mistake), but the much larger responseWriterState</code></span>
<span class="codeline" id="line-6347"><code>// and buffers are reused between multiple requests.</code></span>
<span class="codeline" id="line-6348"><code>type http2responseWriter struct {</code></span>
<span class="codeline" id="line-6349"><code>	rws *http2responseWriterState</code></span>
<span class="codeline" id="line-6350"><code>}</code></span>
<span class="codeline" id="line-6351"><code></code></span>
<span class="codeline" id="line-6352"><code>// Optional http.ResponseWriter interfaces implemented.</code></span>
<span class="codeline" id="line-6353"><code>var (</code></span>
<span class="codeline" id="line-6354"><code>	_ CloseNotifier     = (*http2responseWriter)(nil)</code></span>
<span class="codeline" id="line-6355"><code>	_ Flusher           = (*http2responseWriter)(nil)</code></span>
<span class="codeline" id="line-6356"><code>	_ http2stringWriter = (*http2responseWriter)(nil)</code></span>
<span class="codeline" id="line-6357"><code>)</code></span>
<span class="codeline" id="line-6358"><code></code></span>
<span class="codeline" id="line-6359"><code>type http2responseWriterState struct {</code></span>
<span class="codeline" id="line-6360"><code>	// immutable within a request:</code></span>
<span class="codeline" id="line-6361"><code>	stream *http2stream</code></span>
<span class="codeline" id="line-6362"><code>	req    *Request</code></span>
<span class="codeline" id="line-6363"><code>	conn   *http2serverConn</code></span>
<span class="codeline" id="line-6364"><code></code></span>
<span class="codeline" id="line-6365"><code>	// TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc</code></span>
<span class="codeline" id="line-6366"><code>	bw *bufio.Writer // writing to a chunkWriter{this *responseWriterState}</code></span>
<span class="codeline" id="line-6367"><code></code></span>
<span class="codeline" id="line-6368"><code>	// mutated by http.Handler goroutine:</code></span>
<span class="codeline" id="line-6369"><code>	handlerHeader Header   // nil until called</code></span>
<span class="codeline" id="line-6370"><code>	snapHeader    Header   // snapshot of handlerHeader at WriteHeader time</code></span>
<span class="codeline" id="line-6371"><code>	trailers      []string // set in writeChunk</code></span>
<span class="codeline" id="line-6372"><code>	status        int      // status code passed to WriteHeader</code></span>
<span class="codeline" id="line-6373"><code>	wroteHeader   bool     // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.</code></span>
<span class="codeline" id="line-6374"><code>	sentHeader    bool     // have we sent the header frame?</code></span>
<span class="codeline" id="line-6375"><code>	handlerDone   bool     // handler has finished</code></span>
<span class="codeline" id="line-6376"><code></code></span>
<span class="codeline" id="line-6377"><code>	sentContentLen int64 // non-zero if handler set a Content-Length header</code></span>
<span class="codeline" id="line-6378"><code>	wroteBytes     int64</code></span>
<span class="codeline" id="line-6379"><code></code></span>
<span class="codeline" id="line-6380"><code>	closeNotifierMu sync.Mutex // guards closeNotifierCh</code></span>
<span class="codeline" id="line-6381"><code>	closeNotifierCh chan bool  // nil until first used</code></span>
<span class="codeline" id="line-6382"><code>}</code></span>
<span class="codeline" id="line-6383"><code></code></span>
<span class="codeline" id="line-6384"><code>type http2chunkWriter struct{ rws *http2responseWriterState }</code></span>
<span class="codeline" id="line-6385"><code></code></span>
<span class="codeline" id="line-6386"><code>func (cw http2chunkWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-6387"><code>	n, err = cw.rws.writeChunk(p)</code></span>
<span class="codeline" id="line-6388"><code>	if err == http2errStreamClosed {</code></span>
<span class="codeline" id="line-6389"><code>		// If writing failed because the stream has been closed,</code></span>
<span class="codeline" id="line-6390"><code>		// return the reason it was closed.</code></span>
<span class="codeline" id="line-6391"><code>		err = cw.rws.stream.closeErr</code></span>
<span class="codeline" id="line-6392"><code>	}</code></span>
<span class="codeline" id="line-6393"><code>	return n, err</code></span>
<span class="codeline" id="line-6394"><code>}</code></span>
<span class="codeline" id="line-6395"><code></code></span>
<span class="codeline" id="line-6396"><code>func (rws *http2responseWriterState) hasTrailers() bool { return len(rws.trailers) &gt; 0 }</code></span>
<span class="codeline" id="line-6397"><code></code></span>
<span class="codeline" id="line-6398"><code>func (rws *http2responseWriterState) hasNonemptyTrailers() bool {</code></span>
<span class="codeline" id="line-6399"><code>	for _, trailer := range rws.trailers {</code></span>
<span class="codeline" id="line-6400"><code>		if _, ok := rws.handlerHeader[trailer]; ok {</code></span>
<span class="codeline" id="line-6401"><code>			return true</code></span>
<span class="codeline" id="line-6402"><code>		}</code></span>
<span class="codeline" id="line-6403"><code>	}</code></span>
<span class="codeline" id="line-6404"><code>	return false</code></span>
<span class="codeline" id="line-6405"><code>}</code></span>
<span class="codeline" id="line-6406"><code></code></span>
<span class="codeline" id="line-6407"><code>// declareTrailer is called for each Trailer header when the</code></span>
<span class="codeline" id="line-6408"><code>// response header is written. It notes that a header will need to be</code></span>
<span class="codeline" id="line-6409"><code>// written in the trailers at the end of the response.</code></span>
<span class="codeline" id="line-6410"><code>func (rws *http2responseWriterState) declareTrailer(k string) {</code></span>
<span class="codeline" id="line-6411"><code>	k = CanonicalHeaderKey(k)</code></span>
<span class="codeline" id="line-6412"><code>	if !httpguts.ValidTrailerHeader(k) {</code></span>
<span class="codeline" id="line-6413"><code>		// Forbidden by RFC 7230, section 4.1.2.</code></span>
<span class="codeline" id="line-6414"><code>		rws.conn.logf("ignoring invalid trailer %q", k)</code></span>
<span class="codeline" id="line-6415"><code>		return</code></span>
<span class="codeline" id="line-6416"><code>	}</code></span>
<span class="codeline" id="line-6417"><code>	if !http2strSliceContains(rws.trailers, k) {</code></span>
<span class="codeline" id="line-6418"><code>		rws.trailers = append(rws.trailers, k)</code></span>
<span class="codeline" id="line-6419"><code>	}</code></span>
<span class="codeline" id="line-6420"><code>}</code></span>
<span class="codeline" id="line-6421"><code></code></span>
<span class="codeline" id="line-6422"><code>// writeChunk writes chunks from the bufio.Writer. But because</code></span>
<span class="codeline" id="line-6423"><code>// bufio.Writer may bypass its chunking, sometimes p may be</code></span>
<span class="codeline" id="line-6424"><code>// arbitrarily large.</code></span>
<span class="codeline" id="line-6425"><code>//</code></span>
<span class="codeline" id="line-6426"><code>// writeChunk is also responsible (on the first chunk) for sending the</code></span>
<span class="codeline" id="line-6427"><code>// HEADER response.</code></span>
<span class="codeline" id="line-6428"><code>func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-6429"><code>	if !rws.wroteHeader {</code></span>
<span class="codeline" id="line-6430"><code>		rws.writeHeader(200)</code></span>
<span class="codeline" id="line-6431"><code>	}</code></span>
<span class="codeline" id="line-6432"><code></code></span>
<span class="codeline" id="line-6433"><code>	if rws.handlerDone {</code></span>
<span class="codeline" id="line-6434"><code>		rws.promoteUndeclaredTrailers()</code></span>
<span class="codeline" id="line-6435"><code>	}</code></span>
<span class="codeline" id="line-6436"><code></code></span>
<span class="codeline" id="line-6437"><code>	isHeadResp := rws.req.Method == "HEAD"</code></span>
<span class="codeline" id="line-6438"><code>	if !rws.sentHeader {</code></span>
<span class="codeline" id="line-6439"><code>		rws.sentHeader = true</code></span>
<span class="codeline" id="line-6440"><code>		var ctype, clen string</code></span>
<span class="codeline" id="line-6441"><code>		if clen = rws.snapHeader.Get("Content-Length"); clen != "" {</code></span>
<span class="codeline" id="line-6442"><code>			rws.snapHeader.Del("Content-Length")</code></span>
<span class="codeline" id="line-6443"><code>			if cl, err := strconv.ParseUint(clen, 10, 63); err == nil {</code></span>
<span class="codeline" id="line-6444"><code>				rws.sentContentLen = int64(cl)</code></span>
<span class="codeline" id="line-6445"><code>			} else {</code></span>
<span class="codeline" id="line-6446"><code>				clen = ""</code></span>
<span class="codeline" id="line-6447"><code>			}</code></span>
<span class="codeline" id="line-6448"><code>		}</code></span>
<span class="codeline" id="line-6449"><code>		_, hasContentLength := rws.snapHeader["Content-Length"]</code></span>
<span class="codeline" id="line-6450"><code>		if !hasContentLength &amp;&amp; clen == "" &amp;&amp; rws.handlerDone &amp;&amp; http2bodyAllowedForStatus(rws.status) &amp;&amp; (len(p) &gt; 0 || !isHeadResp) {</code></span>
<span class="codeline" id="line-6451"><code>			clen = strconv.Itoa(len(p))</code></span>
<span class="codeline" id="line-6452"><code>		}</code></span>
<span class="codeline" id="line-6453"><code>		_, hasContentType := rws.snapHeader["Content-Type"]</code></span>
<span class="codeline" id="line-6454"><code>		// If the Content-Encoding is non-blank, we shouldn't</code></span>
<span class="codeline" id="line-6455"><code>		// sniff the body. See Issue golang.org/issue/31753.</code></span>
<span class="codeline" id="line-6456"><code>		ce := rws.snapHeader.Get("Content-Encoding")</code></span>
<span class="codeline" id="line-6457"><code>		hasCE := len(ce) &gt; 0</code></span>
<span class="codeline" id="line-6458"><code>		if !hasCE &amp;&amp; !hasContentType &amp;&amp; http2bodyAllowedForStatus(rws.status) &amp;&amp; len(p) &gt; 0 {</code></span>
<span class="codeline" id="line-6459"><code>			ctype = DetectContentType(p)</code></span>
<span class="codeline" id="line-6460"><code>		}</code></span>
<span class="codeline" id="line-6461"><code>		var date string</code></span>
<span class="codeline" id="line-6462"><code>		if _, ok := rws.snapHeader["Date"]; !ok {</code></span>
<span class="codeline" id="line-6463"><code>			// TODO(bradfitz): be faster here, like net/http? measure.</code></span>
<span class="codeline" id="line-6464"><code>			date = time.Now().UTC().Format(TimeFormat)</code></span>
<span class="codeline" id="line-6465"><code>		}</code></span>
<span class="codeline" id="line-6466"><code></code></span>
<span class="codeline" id="line-6467"><code>		for _, v := range rws.snapHeader["Trailer"] {</code></span>
<span class="codeline" id="line-6468"><code>			http2foreachHeaderElement(v, rws.declareTrailer)</code></span>
<span class="codeline" id="line-6469"><code>		}</code></span>
<span class="codeline" id="line-6470"><code></code></span>
<span class="codeline" id="line-6471"><code>		// "Connection" headers aren't allowed in HTTP/2 (RFC 7540, 8.1.2.2),</code></span>
<span class="codeline" id="line-6472"><code>		// but respect "Connection" == "close" to mean sending a GOAWAY and tearing</code></span>
<span class="codeline" id="line-6473"><code>		// down the TCP connection when idle, like we do for HTTP/1.</code></span>
<span class="codeline" id="line-6474"><code>		// TODO: remove more Connection-specific header fields here, in addition</code></span>
<span class="codeline" id="line-6475"><code>		// to "Connection".</code></span>
<span class="codeline" id="line-6476"><code>		if _, ok := rws.snapHeader["Connection"]; ok {</code></span>
<span class="codeline" id="line-6477"><code>			v := rws.snapHeader.Get("Connection")</code></span>
<span class="codeline" id="line-6478"><code>			delete(rws.snapHeader, "Connection")</code></span>
<span class="codeline" id="line-6479"><code>			if v == "close" {</code></span>
<span class="codeline" id="line-6480"><code>				rws.conn.startGracefulShutdown()</code></span>
<span class="codeline" id="line-6481"><code>			}</code></span>
<span class="codeline" id="line-6482"><code>		}</code></span>
<span class="codeline" id="line-6483"><code></code></span>
<span class="codeline" id="line-6484"><code>		endStream := (rws.handlerDone &amp;&amp; !rws.hasTrailers() &amp;&amp; len(p) == 0) || isHeadResp</code></span>
<span class="codeline" id="line-6485"><code>		err = rws.conn.writeHeaders(rws.stream, &amp;http2writeResHeaders{</code></span>
<span class="codeline" id="line-6486"><code>			streamID:      rws.stream.id,</code></span>
<span class="codeline" id="line-6487"><code>			httpResCode:   rws.status,</code></span>
<span class="codeline" id="line-6488"><code>			h:             rws.snapHeader,</code></span>
<span class="codeline" id="line-6489"><code>			endStream:     endStream,</code></span>
<span class="codeline" id="line-6490"><code>			contentType:   ctype,</code></span>
<span class="codeline" id="line-6491"><code>			contentLength: clen,</code></span>
<span class="codeline" id="line-6492"><code>			date:          date,</code></span>
<span class="codeline" id="line-6493"><code>		})</code></span>
<span class="codeline" id="line-6494"><code>		if err != nil {</code></span>
<span class="codeline" id="line-6495"><code>			return 0, err</code></span>
<span class="codeline" id="line-6496"><code>		}</code></span>
<span class="codeline" id="line-6497"><code>		if endStream {</code></span>
<span class="codeline" id="line-6498"><code>			return 0, nil</code></span>
<span class="codeline" id="line-6499"><code>		}</code></span>
<span class="codeline" id="line-6500"><code>	}</code></span>
<span class="codeline" id="line-6501"><code>	if isHeadResp {</code></span>
<span class="codeline" id="line-6502"><code>		return len(p), nil</code></span>
<span class="codeline" id="line-6503"><code>	}</code></span>
<span class="codeline" id="line-6504"><code>	if len(p) == 0 &amp;&amp; !rws.handlerDone {</code></span>
<span class="codeline" id="line-6505"><code>		return 0, nil</code></span>
<span class="codeline" id="line-6506"><code>	}</code></span>
<span class="codeline" id="line-6507"><code></code></span>
<span class="codeline" id="line-6508"><code>	// only send trailers if they have actually been defined by the</code></span>
<span class="codeline" id="line-6509"><code>	// server handler.</code></span>
<span class="codeline" id="line-6510"><code>	hasNonemptyTrailers := rws.hasNonemptyTrailers()</code></span>
<span class="codeline" id="line-6511"><code>	endStream := rws.handlerDone &amp;&amp; !hasNonemptyTrailers</code></span>
<span class="codeline" id="line-6512"><code>	if len(p) &gt; 0 || endStream {</code></span>
<span class="codeline" id="line-6513"><code>		// only send a 0 byte DATA frame if we're ending the stream.</code></span>
<span class="codeline" id="line-6514"><code>		if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil {</code></span>
<span class="codeline" id="line-6515"><code>			return 0, err</code></span>
<span class="codeline" id="line-6516"><code>		}</code></span>
<span class="codeline" id="line-6517"><code>	}</code></span>
<span class="codeline" id="line-6518"><code></code></span>
<span class="codeline" id="line-6519"><code>	if rws.handlerDone &amp;&amp; hasNonemptyTrailers {</code></span>
<span class="codeline" id="line-6520"><code>		err = rws.conn.writeHeaders(rws.stream, &amp;http2writeResHeaders{</code></span>
<span class="codeline" id="line-6521"><code>			streamID:  rws.stream.id,</code></span>
<span class="codeline" id="line-6522"><code>			h:         rws.handlerHeader,</code></span>
<span class="codeline" id="line-6523"><code>			trailers:  rws.trailers,</code></span>
<span class="codeline" id="line-6524"><code>			endStream: true,</code></span>
<span class="codeline" id="line-6525"><code>		})</code></span>
<span class="codeline" id="line-6526"><code>		return len(p), err</code></span>
<span class="codeline" id="line-6527"><code>	}</code></span>
<span class="codeline" id="line-6528"><code>	return len(p), nil</code></span>
<span class="codeline" id="line-6529"><code>}</code></span>
<span class="codeline" id="line-6530"><code></code></span>
<span class="codeline" id="line-6531"><code>// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys</code></span>
<span class="codeline" id="line-6532"><code>// that, if present, signals that the map entry is actually for</code></span>
<span class="codeline" id="line-6533"><code>// the response trailers, and not the response headers. The prefix</code></span>
<span class="codeline" id="line-6534"><code>// is stripped after the ServeHTTP call finishes and the values are</code></span>
<span class="codeline" id="line-6535"><code>// sent in the trailers.</code></span>
<span class="codeline" id="line-6536"><code>//</code></span>
<span class="codeline" id="line-6537"><code>// This mechanism is intended only for trailers that are not known</code></span>
<span class="codeline" id="line-6538"><code>// prior to the headers being written. If the set of trailers is fixed</code></span>
<span class="codeline" id="line-6539"><code>// or known before the header is written, the normal Go trailers mechanism</code></span>
<span class="codeline" id="line-6540"><code>// is preferred:</code></span>
<span class="codeline" id="line-6541"><code>//</code></span>
<span class="codeline" id="line-6542"><code>//	https://golang.org/pkg/net/http/#ResponseWriter</code></span>
<span class="codeline" id="line-6543"><code>//	https://golang.org/pkg/net/http/#example_ResponseWriter_trailers</code></span>
<span class="codeline" id="line-6544"><code>const http2TrailerPrefix = "Trailer:"</code></span>
<span class="codeline" id="line-6545"><code></code></span>
<span class="codeline" id="line-6546"><code>// promoteUndeclaredTrailers permits http.Handlers to set trailers</code></span>
<span class="codeline" id="line-6547"><code>// after the header has already been flushed. Because the Go</code></span>
<span class="codeline" id="line-6548"><code>// ResponseWriter interface has no way to set Trailers (only the</code></span>
<span class="codeline" id="line-6549"><code>// Header), and because we didn't want to expand the ResponseWriter</code></span>
<span class="codeline" id="line-6550"><code>// interface, and because nobody used trailers, and because RFC 7230</code></span>
<span class="codeline" id="line-6551"><code>// says you SHOULD (but not must) predeclare any trailers in the</code></span>
<span class="codeline" id="line-6552"><code>// header, the official ResponseWriter rules said trailers in Go must</code></span>
<span class="codeline" id="line-6553"><code>// be predeclared, and then we reuse the same ResponseWriter.Header()</code></span>
<span class="codeline" id="line-6554"><code>// map to mean both Headers and Trailers. When it's time to write the</code></span>
<span class="codeline" id="line-6555"><code>// Trailers, we pick out the fields of Headers that were declared as</code></span>
<span class="codeline" id="line-6556"><code>// trailers. That worked for a while, until we found the first major</code></span>
<span class="codeline" id="line-6557"><code>// user of Trailers in the wild: gRPC (using them only over http2),</code></span>
<span class="codeline" id="line-6558"><code>// and gRPC libraries permit setting trailers mid-stream without</code></span>
<span class="codeline" id="line-6559"><code>// predeclaring them. So: change of plans. We still permit the old</code></span>
<span class="codeline" id="line-6560"><code>// way, but we also permit this hack: if a Header() key begins with</code></span>
<span class="codeline" id="line-6561"><code>// "Trailer:", the suffix of that key is a Trailer. Because ':' is an</code></span>
<span class="codeline" id="line-6562"><code>// invalid token byte anyway, there is no ambiguity. (And it's already</code></span>
<span class="codeline" id="line-6563"><code>// filtered out) It's mildly hacky, but not terrible.</code></span>
<span class="codeline" id="line-6564"><code>//</code></span>
<span class="codeline" id="line-6565"><code>// This method runs after the Handler is done and promotes any Header</code></span>
<span class="codeline" id="line-6566"><code>// fields to be trailers.</code></span>
<span class="codeline" id="line-6567"><code>func (rws *http2responseWriterState) promoteUndeclaredTrailers() {</code></span>
<span class="codeline" id="line-6568"><code>	for k, vv := range rws.handlerHeader {</code></span>
<span class="codeline" id="line-6569"><code>		if !strings.HasPrefix(k, http2TrailerPrefix) {</code></span>
<span class="codeline" id="line-6570"><code>			continue</code></span>
<span class="codeline" id="line-6571"><code>		}</code></span>
<span class="codeline" id="line-6572"><code>		trailerKey := strings.TrimPrefix(k, http2TrailerPrefix)</code></span>
<span class="codeline" id="line-6573"><code>		rws.declareTrailer(trailerKey)</code></span>
<span class="codeline" id="line-6574"><code>		rws.handlerHeader[CanonicalHeaderKey(trailerKey)] = vv</code></span>
<span class="codeline" id="line-6575"><code>	}</code></span>
<span class="codeline" id="line-6576"><code></code></span>
<span class="codeline" id="line-6577"><code>	if len(rws.trailers) &gt; 1 {</code></span>
<span class="codeline" id="line-6578"><code>		sorter := http2sorterPool.Get().(*http2sorter)</code></span>
<span class="codeline" id="line-6579"><code>		sorter.SortStrings(rws.trailers)</code></span>
<span class="codeline" id="line-6580"><code>		http2sorterPool.Put(sorter)</code></span>
<span class="codeline" id="line-6581"><code>	}</code></span>
<span class="codeline" id="line-6582"><code>}</code></span>
<span class="codeline" id="line-6583"><code></code></span>
<span class="codeline" id="line-6584"><code>func (w *http2responseWriter) SetReadDeadline(deadline time.Time) error {</code></span>
<span class="codeline" id="line-6585"><code>	st := w.rws.stream</code></span>
<span class="codeline" id="line-6586"><code>	if !deadline.IsZero() &amp;&amp; deadline.Before(time.Now()) {</code></span>
<span class="codeline" id="line-6587"><code>		// If we're setting a deadline in the past, reset the stream immediately</code></span>
<span class="codeline" id="line-6588"><code>		// so writes after SetWriteDeadline returns will fail.</code></span>
<span class="codeline" id="line-6589"><code>		st.onReadTimeout()</code></span>
<span class="codeline" id="line-6590"><code>		return nil</code></span>
<span class="codeline" id="line-6591"><code>	}</code></span>
<span class="codeline" id="line-6592"><code>	w.rws.conn.sendServeMsg(func(sc *http2serverConn) {</code></span>
<span class="codeline" id="line-6593"><code>		if st.readDeadline != nil {</code></span>
<span class="codeline" id="line-6594"><code>			if !st.readDeadline.Stop() {</code></span>
<span class="codeline" id="line-6595"><code>				// Deadline already exceeded, or stream has been closed.</code></span>
<span class="codeline" id="line-6596"><code>				return</code></span>
<span class="codeline" id="line-6597"><code>			}</code></span>
<span class="codeline" id="line-6598"><code>		}</code></span>
<span class="codeline" id="line-6599"><code>		if deadline.IsZero() {</code></span>
<span class="codeline" id="line-6600"><code>			st.readDeadline = nil</code></span>
<span class="codeline" id="line-6601"><code>		} else if st.readDeadline == nil {</code></span>
<span class="codeline" id="line-6602"><code>			st.readDeadline = time.AfterFunc(deadline.Sub(time.Now()), st.onReadTimeout)</code></span>
<span class="codeline" id="line-6603"><code>		} else {</code></span>
<span class="codeline" id="line-6604"><code>			st.readDeadline.Reset(deadline.Sub(time.Now()))</code></span>
<span class="codeline" id="line-6605"><code>		}</code></span>
<span class="codeline" id="line-6606"><code>	})</code></span>
<span class="codeline" id="line-6607"><code>	return nil</code></span>
<span class="codeline" id="line-6608"><code>}</code></span>
<span class="codeline" id="line-6609"><code></code></span>
<span class="codeline" id="line-6610"><code>func (w *http2responseWriter) SetWriteDeadline(deadline time.Time) error {</code></span>
<span class="codeline" id="line-6611"><code>	st := w.rws.stream</code></span>
<span class="codeline" id="line-6612"><code>	if !deadline.IsZero() &amp;&amp; deadline.Before(time.Now()) {</code></span>
<span class="codeline" id="line-6613"><code>		// If we're setting a deadline in the past, reset the stream immediately</code></span>
<span class="codeline" id="line-6614"><code>		// so writes after SetWriteDeadline returns will fail.</code></span>
<span class="codeline" id="line-6615"><code>		st.onWriteTimeout()</code></span>
<span class="codeline" id="line-6616"><code>		return nil</code></span>
<span class="codeline" id="line-6617"><code>	}</code></span>
<span class="codeline" id="line-6618"><code>	w.rws.conn.sendServeMsg(func(sc *http2serverConn) {</code></span>
<span class="codeline" id="line-6619"><code>		if st.writeDeadline != nil {</code></span>
<span class="codeline" id="line-6620"><code>			if !st.writeDeadline.Stop() {</code></span>
<span class="codeline" id="line-6621"><code>				// Deadline already exceeded, or stream has been closed.</code></span>
<span class="codeline" id="line-6622"><code>				return</code></span>
<span class="codeline" id="line-6623"><code>			}</code></span>
<span class="codeline" id="line-6624"><code>		}</code></span>
<span class="codeline" id="line-6625"><code>		if deadline.IsZero() {</code></span>
<span class="codeline" id="line-6626"><code>			st.writeDeadline = nil</code></span>
<span class="codeline" id="line-6627"><code>		} else if st.writeDeadline == nil {</code></span>
<span class="codeline" id="line-6628"><code>			st.writeDeadline = time.AfterFunc(deadline.Sub(time.Now()), st.onWriteTimeout)</code></span>
<span class="codeline" id="line-6629"><code>		} else {</code></span>
<span class="codeline" id="line-6630"><code>			st.writeDeadline.Reset(deadline.Sub(time.Now()))</code></span>
<span class="codeline" id="line-6631"><code>		}</code></span>
<span class="codeline" id="line-6632"><code>	})</code></span>
<span class="codeline" id="line-6633"><code>	return nil</code></span>
<span class="codeline" id="line-6634"><code>}</code></span>
<span class="codeline" id="line-6635"><code></code></span>
<span class="codeline" id="line-6636"><code>func (w *http2responseWriter) Flush() {</code></span>
<span class="codeline" id="line-6637"><code>	w.FlushError()</code></span>
<span class="codeline" id="line-6638"><code>}</code></span>
<span class="codeline" id="line-6639"><code></code></span>
<span class="codeline" id="line-6640"><code>func (w *http2responseWriter) FlushError() error {</code></span>
<span class="codeline" id="line-6641"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6642"><code>	if rws == nil {</code></span>
<span class="codeline" id="line-6643"><code>		panic("Header called after Handler finished")</code></span>
<span class="codeline" id="line-6644"><code>	}</code></span>
<span class="codeline" id="line-6645"><code>	var err error</code></span>
<span class="codeline" id="line-6646"><code>	if rws.bw.Buffered() &gt; 0 {</code></span>
<span class="codeline" id="line-6647"><code>		err = rws.bw.Flush()</code></span>
<span class="codeline" id="line-6648"><code>	} else {</code></span>
<span class="codeline" id="line-6649"><code>		// The bufio.Writer won't call chunkWriter.Write</code></span>
<span class="codeline" id="line-6650"><code>		// (writeChunk with zero bytes), so we have to do it</code></span>
<span class="codeline" id="line-6651"><code>		// ourselves to force the HTTP response header and/or</code></span>
<span class="codeline" id="line-6652"><code>		// final DATA frame (with END_STREAM) to be sent.</code></span>
<span class="codeline" id="line-6653"><code>		_, err = http2chunkWriter{rws}.Write(nil)</code></span>
<span class="codeline" id="line-6654"><code>		if err == nil {</code></span>
<span class="codeline" id="line-6655"><code>			select {</code></span>
<span class="codeline" id="line-6656"><code>			case &lt;-rws.stream.cw:</code></span>
<span class="codeline" id="line-6657"><code>				err = rws.stream.closeErr</code></span>
<span class="codeline" id="line-6658"><code>			default:</code></span>
<span class="codeline" id="line-6659"><code>			}</code></span>
<span class="codeline" id="line-6660"><code>		}</code></span>
<span class="codeline" id="line-6661"><code>	}</code></span>
<span class="codeline" id="line-6662"><code>	return err</code></span>
<span class="codeline" id="line-6663"><code>}</code></span>
<span class="codeline" id="line-6664"><code></code></span>
<span class="codeline" id="line-6665"><code>func (w *http2responseWriter) CloseNotify() &lt;-chan bool {</code></span>
<span class="codeline" id="line-6666"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6667"><code>	if rws == nil {</code></span>
<span class="codeline" id="line-6668"><code>		panic("CloseNotify called after Handler finished")</code></span>
<span class="codeline" id="line-6669"><code>	}</code></span>
<span class="codeline" id="line-6670"><code>	rws.closeNotifierMu.Lock()</code></span>
<span class="codeline" id="line-6671"><code>	ch := rws.closeNotifierCh</code></span>
<span class="codeline" id="line-6672"><code>	if ch == nil {</code></span>
<span class="codeline" id="line-6673"><code>		ch = make(chan bool, 1)</code></span>
<span class="codeline" id="line-6674"><code>		rws.closeNotifierCh = ch</code></span>
<span class="codeline" id="line-6675"><code>		cw := rws.stream.cw</code></span>
<span class="codeline" id="line-6676"><code>		go func() {</code></span>
<span class="codeline" id="line-6677"><code>			cw.Wait() // wait for close</code></span>
<span class="codeline" id="line-6678"><code>			ch &lt;- true</code></span>
<span class="codeline" id="line-6679"><code>		}()</code></span>
<span class="codeline" id="line-6680"><code>	}</code></span>
<span class="codeline" id="line-6681"><code>	rws.closeNotifierMu.Unlock()</code></span>
<span class="codeline" id="line-6682"><code>	return ch</code></span>
<span class="codeline" id="line-6683"><code>}</code></span>
<span class="codeline" id="line-6684"><code></code></span>
<span class="codeline" id="line-6685"><code>func (w *http2responseWriter) Header() Header {</code></span>
<span class="codeline" id="line-6686"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6687"><code>	if rws == nil {</code></span>
<span class="codeline" id="line-6688"><code>		panic("Header called after Handler finished")</code></span>
<span class="codeline" id="line-6689"><code>	}</code></span>
<span class="codeline" id="line-6690"><code>	if rws.handlerHeader == nil {</code></span>
<span class="codeline" id="line-6691"><code>		rws.handlerHeader = make(Header)</code></span>
<span class="codeline" id="line-6692"><code>	}</code></span>
<span class="codeline" id="line-6693"><code>	return rws.handlerHeader</code></span>
<span class="codeline" id="line-6694"><code>}</code></span>
<span class="codeline" id="line-6695"><code></code></span>
<span class="codeline" id="line-6696"><code>// checkWriteHeaderCode is a copy of net/http's checkWriteHeaderCode.</code></span>
<span class="codeline" id="line-6697"><code>func http2checkWriteHeaderCode(code int) {</code></span>
<span class="codeline" id="line-6698"><code>	// Issue 22880: require valid WriteHeader status codes.</code></span>
<span class="codeline" id="line-6699"><code>	// For now we only enforce that it's three digits.</code></span>
<span class="codeline" id="line-6700"><code>	// In the future we might block things over 599 (600 and above aren't defined</code></span>
<span class="codeline" id="line-6701"><code>	// at http://httpwg.org/specs/rfc7231.html#status.codes).</code></span>
<span class="codeline" id="line-6702"><code>	// But for now any three digits.</code></span>
<span class="codeline" id="line-6703"><code>	//</code></span>
<span class="codeline" id="line-6704"><code>	// We used to send "HTTP/1.1 000 0" on the wire in responses but there's</code></span>
<span class="codeline" id="line-6705"><code>	// no equivalent bogus thing we can realistically send in HTTP/2,</code></span>
<span class="codeline" id="line-6706"><code>	// so we'll consistently panic instead and help people find their bugs</code></span>
<span class="codeline" id="line-6707"><code>	// early. (We can't return an error from WriteHeader even if we wanted to.)</code></span>
<span class="codeline" id="line-6708"><code>	if code &lt; 100 || code &gt; 999 {</code></span>
<span class="codeline" id="line-6709"><code>		panic(fmt.Sprintf("invalid WriteHeader code %v", code))</code></span>
<span class="codeline" id="line-6710"><code>	}</code></span>
<span class="codeline" id="line-6711"><code>}</code></span>
<span class="codeline" id="line-6712"><code></code></span>
<span class="codeline" id="line-6713"><code>func (w *http2responseWriter) WriteHeader(code int) {</code></span>
<span class="codeline" id="line-6714"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6715"><code>	if rws == nil {</code></span>
<span class="codeline" id="line-6716"><code>		panic("WriteHeader called after Handler finished")</code></span>
<span class="codeline" id="line-6717"><code>	}</code></span>
<span class="codeline" id="line-6718"><code>	rws.writeHeader(code)</code></span>
<span class="codeline" id="line-6719"><code>}</code></span>
<span class="codeline" id="line-6720"><code></code></span>
<span class="codeline" id="line-6721"><code>func (rws *http2responseWriterState) writeHeader(code int) {</code></span>
<span class="codeline" id="line-6722"><code>	if rws.wroteHeader {</code></span>
<span class="codeline" id="line-6723"><code>		return</code></span>
<span class="codeline" id="line-6724"><code>	}</code></span>
<span class="codeline" id="line-6725"><code></code></span>
<span class="codeline" id="line-6726"><code>	http2checkWriteHeaderCode(code)</code></span>
<span class="codeline" id="line-6727"><code></code></span>
<span class="codeline" id="line-6728"><code>	// Handle informational headers</code></span>
<span class="codeline" id="line-6729"><code>	if code &gt;= 100 &amp;&amp; code &lt;= 199 {</code></span>
<span class="codeline" id="line-6730"><code>		// Per RFC 8297 we must not clear the current header map</code></span>
<span class="codeline" id="line-6731"><code>		h := rws.handlerHeader</code></span>
<span class="codeline" id="line-6732"><code></code></span>
<span class="codeline" id="line-6733"><code>		_, cl := h["Content-Length"]</code></span>
<span class="codeline" id="line-6734"><code>		_, te := h["Transfer-Encoding"]</code></span>
<span class="codeline" id="line-6735"><code>		if cl || te {</code></span>
<span class="codeline" id="line-6736"><code>			h = h.Clone()</code></span>
<span class="codeline" id="line-6737"><code>			h.Del("Content-Length")</code></span>
<span class="codeline" id="line-6738"><code>			h.Del("Transfer-Encoding")</code></span>
<span class="codeline" id="line-6739"><code>		}</code></span>
<span class="codeline" id="line-6740"><code></code></span>
<span class="codeline" id="line-6741"><code>		rws.conn.writeHeaders(rws.stream, &amp;http2writeResHeaders{</code></span>
<span class="codeline" id="line-6742"><code>			streamID:    rws.stream.id,</code></span>
<span class="codeline" id="line-6743"><code>			httpResCode: code,</code></span>
<span class="codeline" id="line-6744"><code>			h:           h,</code></span>
<span class="codeline" id="line-6745"><code>			endStream:   rws.handlerDone &amp;&amp; !rws.hasTrailers(),</code></span>
<span class="codeline" id="line-6746"><code>		})</code></span>
<span class="codeline" id="line-6747"><code></code></span>
<span class="codeline" id="line-6748"><code>		return</code></span>
<span class="codeline" id="line-6749"><code>	}</code></span>
<span class="codeline" id="line-6750"><code></code></span>
<span class="codeline" id="line-6751"><code>	rws.wroteHeader = true</code></span>
<span class="codeline" id="line-6752"><code>	rws.status = code</code></span>
<span class="codeline" id="line-6753"><code>	if len(rws.handlerHeader) &gt; 0 {</code></span>
<span class="codeline" id="line-6754"><code>		rws.snapHeader = http2cloneHeader(rws.handlerHeader)</code></span>
<span class="codeline" id="line-6755"><code>	}</code></span>
<span class="codeline" id="line-6756"><code>}</code></span>
<span class="codeline" id="line-6757"><code></code></span>
<span class="codeline" id="line-6758"><code>func http2cloneHeader(h Header) Header {</code></span>
<span class="codeline" id="line-6759"><code>	h2 := make(Header, len(h))</code></span>
<span class="codeline" id="line-6760"><code>	for k, vv := range h {</code></span>
<span class="codeline" id="line-6761"><code>		vv2 := make([]string, len(vv))</code></span>
<span class="codeline" id="line-6762"><code>		copy(vv2, vv)</code></span>
<span class="codeline" id="line-6763"><code>		h2[k] = vv2</code></span>
<span class="codeline" id="line-6764"><code>	}</code></span>
<span class="codeline" id="line-6765"><code>	return h2</code></span>
<span class="codeline" id="line-6766"><code>}</code></span>
<span class="codeline" id="line-6767"><code></code></span>
<span class="codeline" id="line-6768"><code>// The Life Of A Write is like this:</code></span>
<span class="codeline" id="line-6769"><code>//</code></span>
<span class="codeline" id="line-6770"><code>// * Handler calls w.Write or w.WriteString -&gt;</code></span>
<span class="codeline" id="line-6771"><code>// * -&gt; rws.bw (*bufio.Writer) -&gt;</code></span>
<span class="codeline" id="line-6772"><code>// * (Handler might call Flush)</code></span>
<span class="codeline" id="line-6773"><code>// * -&gt; chunkWriter{rws}</code></span>
<span class="codeline" id="line-6774"><code>// * -&gt; responseWriterState.writeChunk(p []byte)</code></span>
<span class="codeline" id="line-6775"><code>// * -&gt; responseWriterState.writeChunk (most of the magic; see comment there)</code></span>
<span class="codeline" id="line-6776"><code>func (w *http2responseWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-6777"><code>	return w.write(len(p), p, "")</code></span>
<span class="codeline" id="line-6778"><code>}</code></span>
<span class="codeline" id="line-6779"><code></code></span>
<span class="codeline" id="line-6780"><code>func (w *http2responseWriter) WriteString(s string) (n int, err error) {</code></span>
<span class="codeline" id="line-6781"><code>	return w.write(len(s), nil, s)</code></span>
<span class="codeline" id="line-6782"><code>}</code></span>
<span class="codeline" id="line-6783"><code></code></span>
<span class="codeline" id="line-6784"><code>// either dataB or dataS is non-zero.</code></span>
<span class="codeline" id="line-6785"><code>func (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) {</code></span>
<span class="codeline" id="line-6786"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6787"><code>	if rws == nil {</code></span>
<span class="codeline" id="line-6788"><code>		panic("Write called after Handler finished")</code></span>
<span class="codeline" id="line-6789"><code>	}</code></span>
<span class="codeline" id="line-6790"><code>	if !rws.wroteHeader {</code></span>
<span class="codeline" id="line-6791"><code>		w.WriteHeader(200)</code></span>
<span class="codeline" id="line-6792"><code>	}</code></span>
<span class="codeline" id="line-6793"><code>	if !http2bodyAllowedForStatus(rws.status) {</code></span>
<span class="codeline" id="line-6794"><code>		return 0, ErrBodyNotAllowed</code></span>
<span class="codeline" id="line-6795"><code>	}</code></span>
<span class="codeline" id="line-6796"><code>	rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)) // only one can be set</code></span>
<span class="codeline" id="line-6797"><code>	if rws.sentContentLen != 0 &amp;&amp; rws.wroteBytes &gt; rws.sentContentLen {</code></span>
<span class="codeline" id="line-6798"><code>		// TODO: send a RST_STREAM</code></span>
<span class="codeline" id="line-6799"><code>		return 0, errors.New("http2: handler wrote more than declared Content-Length")</code></span>
<span class="codeline" id="line-6800"><code>	}</code></span>
<span class="codeline" id="line-6801"><code></code></span>
<span class="codeline" id="line-6802"><code>	if dataB != nil {</code></span>
<span class="codeline" id="line-6803"><code>		return rws.bw.Write(dataB)</code></span>
<span class="codeline" id="line-6804"><code>	} else {</code></span>
<span class="codeline" id="line-6805"><code>		return rws.bw.WriteString(dataS)</code></span>
<span class="codeline" id="line-6806"><code>	}</code></span>
<span class="codeline" id="line-6807"><code>}</code></span>
<span class="codeline" id="line-6808"><code></code></span>
<span class="codeline" id="line-6809"><code>func (w *http2responseWriter) handlerDone() {</code></span>
<span class="codeline" id="line-6810"><code>	rws := w.rws</code></span>
<span class="codeline" id="line-6811"><code>	rws.handlerDone = true</code></span>
<span class="codeline" id="line-6812"><code>	w.Flush()</code></span>
<span class="codeline" id="line-6813"><code>	w.rws = nil</code></span>
<span class="codeline" id="line-6814"><code>	http2responseWriterStatePool.Put(rws)</code></span>
<span class="codeline" id="line-6815"><code>}</code></span>
<span class="codeline" id="line-6816"><code></code></span>
<span class="codeline" id="line-6817"><code>// Push errors.</code></span>
<span class="codeline" id="line-6818"><code>var (</code></span>
<span class="codeline" id="line-6819"><code>	http2ErrRecursivePush    = errors.New("http2: recursive push not allowed")</code></span>
<span class="codeline" id="line-6820"><code>	http2ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")</code></span>
<span class="codeline" id="line-6821"><code>)</code></span>
<span class="codeline" id="line-6822"><code></code></span>
<span class="codeline" id="line-6823"><code>var _ Pusher = (*http2responseWriter)(nil)</code></span>
<span class="codeline" id="line-6824"><code></code></span>
<span class="codeline" id="line-6825"><code>func (w *http2responseWriter) Push(target string, opts *PushOptions) error {</code></span>
<span class="codeline" id="line-6826"><code>	st := w.rws.stream</code></span>
<span class="codeline" id="line-6827"><code>	sc := st.sc</code></span>
<span class="codeline" id="line-6828"><code>	sc.serveG.checkNotOn()</code></span>
<span class="codeline" id="line-6829"><code></code></span>
<span class="codeline" id="line-6830"><code>	// No recursive pushes: "PUSH_PROMISE frames MUST only be sent on a peer-initiated stream."</code></span>
<span class="codeline" id="line-6831"><code>	// http://tools.ietf.org/html/rfc7540#section-6.6</code></span>
<span class="codeline" id="line-6832"><code>	if st.isPushed() {</code></span>
<span class="codeline" id="line-6833"><code>		return http2ErrRecursivePush</code></span>
<span class="codeline" id="line-6834"><code>	}</code></span>
<span class="codeline" id="line-6835"><code></code></span>
<span class="codeline" id="line-6836"><code>	if opts == nil {</code></span>
<span class="codeline" id="line-6837"><code>		opts = new(PushOptions)</code></span>
<span class="codeline" id="line-6838"><code>	}</code></span>
<span class="codeline" id="line-6839"><code></code></span>
<span class="codeline" id="line-6840"><code>	// Default options.</code></span>
<span class="codeline" id="line-6841"><code>	if opts.Method == "" {</code></span>
<span class="codeline" id="line-6842"><code>		opts.Method = "GET"</code></span>
<span class="codeline" id="line-6843"><code>	}</code></span>
<span class="codeline" id="line-6844"><code>	if opts.Header == nil {</code></span>
<span class="codeline" id="line-6845"><code>		opts.Header = Header{}</code></span>
<span class="codeline" id="line-6846"><code>	}</code></span>
<span class="codeline" id="line-6847"><code>	wantScheme := "http"</code></span>
<span class="codeline" id="line-6848"><code>	if w.rws.req.TLS != nil {</code></span>
<span class="codeline" id="line-6849"><code>		wantScheme = "https"</code></span>
<span class="codeline" id="line-6850"><code>	}</code></span>
<span class="codeline" id="line-6851"><code></code></span>
<span class="codeline" id="line-6852"><code>	// Validate the request.</code></span>
<span class="codeline" id="line-6853"><code>	u, err := url.Parse(target)</code></span>
<span class="codeline" id="line-6854"><code>	if err != nil {</code></span>
<span class="codeline" id="line-6855"><code>		return err</code></span>
<span class="codeline" id="line-6856"><code>	}</code></span>
<span class="codeline" id="line-6857"><code>	if u.Scheme == "" {</code></span>
<span class="codeline" id="line-6858"><code>		if !strings.HasPrefix(target, "/") {</code></span>
<span class="codeline" id="line-6859"><code>			return fmt.Errorf("target must be an absolute URL or an absolute path: %q", target)</code></span>
<span class="codeline" id="line-6860"><code>		}</code></span>
<span class="codeline" id="line-6861"><code>		u.Scheme = wantScheme</code></span>
<span class="codeline" id="line-6862"><code>		u.Host = w.rws.req.Host</code></span>
<span class="codeline" id="line-6863"><code>	} else {</code></span>
<span class="codeline" id="line-6864"><code>		if u.Scheme != wantScheme {</code></span>
<span class="codeline" id="line-6865"><code>			return fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme)</code></span>
<span class="codeline" id="line-6866"><code>		}</code></span>
<span class="codeline" id="line-6867"><code>		if u.Host == "" {</code></span>
<span class="codeline" id="line-6868"><code>			return errors.New("URL must have a host")</code></span>
<span class="codeline" id="line-6869"><code>		}</code></span>
<span class="codeline" id="line-6870"><code>	}</code></span>
<span class="codeline" id="line-6871"><code>	for k := range opts.Header {</code></span>
<span class="codeline" id="line-6872"><code>		if strings.HasPrefix(k, ":") {</code></span>
<span class="codeline" id="line-6873"><code>			return fmt.Errorf("promised request headers cannot include pseudo header %q", k)</code></span>
<span class="codeline" id="line-6874"><code>		}</code></span>
<span class="codeline" id="line-6875"><code>		// These headers are meaningful only if the request has a body,</code></span>
<span class="codeline" id="line-6876"><code>		// but PUSH_PROMISE requests cannot have a body.</code></span>
<span class="codeline" id="line-6877"><code>		// http://tools.ietf.org/html/rfc7540#section-8.2</code></span>
<span class="codeline" id="line-6878"><code>		// Also disallow Host, since the promised URL must be absolute.</code></span>
<span class="codeline" id="line-6879"><code>		if http2asciiEqualFold(k, "content-length") ||</code></span>
<span class="codeline" id="line-6880"><code>			http2asciiEqualFold(k, "content-encoding") ||</code></span>
<span class="codeline" id="line-6881"><code>			http2asciiEqualFold(k, "trailer") ||</code></span>
<span class="codeline" id="line-6882"><code>			http2asciiEqualFold(k, "te") ||</code></span>
<span class="codeline" id="line-6883"><code>			http2asciiEqualFold(k, "expect") ||</code></span>
<span class="codeline" id="line-6884"><code>			http2asciiEqualFold(k, "host") {</code></span>
<span class="codeline" id="line-6885"><code>			return fmt.Errorf("promised request headers cannot include %q", k)</code></span>
<span class="codeline" id="line-6886"><code>		}</code></span>
<span class="codeline" id="line-6887"><code>	}</code></span>
<span class="codeline" id="line-6888"><code>	if err := http2checkValidHTTP2RequestHeaders(opts.Header); err != nil {</code></span>
<span class="codeline" id="line-6889"><code>		return err</code></span>
<span class="codeline" id="line-6890"><code>	}</code></span>
<span class="codeline" id="line-6891"><code></code></span>
<span class="codeline" id="line-6892"><code>	// The RFC effectively limits promised requests to GET and HEAD:</code></span>
<span class="codeline" id="line-6893"><code>	// "Promised requests MUST be cacheable [GET, HEAD, or POST], and MUST be safe [GET or HEAD]"</code></span>
<span class="codeline" id="line-6894"><code>	// http://tools.ietf.org/html/rfc7540#section-8.2</code></span>
<span class="codeline" id="line-6895"><code>	if opts.Method != "GET" &amp;&amp; opts.Method != "HEAD" {</code></span>
<span class="codeline" id="line-6896"><code>		return fmt.Errorf("method %q must be GET or HEAD", opts.Method)</code></span>
<span class="codeline" id="line-6897"><code>	}</code></span>
<span class="codeline" id="line-6898"><code></code></span>
<span class="codeline" id="line-6899"><code>	msg := &amp;http2startPushRequest{</code></span>
<span class="codeline" id="line-6900"><code>		parent: st,</code></span>
<span class="codeline" id="line-6901"><code>		method: opts.Method,</code></span>
<span class="codeline" id="line-6902"><code>		url:    u,</code></span>
<span class="codeline" id="line-6903"><code>		header: http2cloneHeader(opts.Header),</code></span>
<span class="codeline" id="line-6904"><code>		done:   http2errChanPool.Get().(chan error),</code></span>
<span class="codeline" id="line-6905"><code>	}</code></span>
<span class="codeline" id="line-6906"><code></code></span>
<span class="codeline" id="line-6907"><code>	select {</code></span>
<span class="codeline" id="line-6908"><code>	case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-6909"><code>		return http2errClientDisconnected</code></span>
<span class="codeline" id="line-6910"><code>	case &lt;-st.cw:</code></span>
<span class="codeline" id="line-6911"><code>		return http2errStreamClosed</code></span>
<span class="codeline" id="line-6912"><code>	case sc.serveMsgCh &lt;- msg:</code></span>
<span class="codeline" id="line-6913"><code>	}</code></span>
<span class="codeline" id="line-6914"><code></code></span>
<span class="codeline" id="line-6915"><code>	select {</code></span>
<span class="codeline" id="line-6916"><code>	case &lt;-sc.doneServing:</code></span>
<span class="codeline" id="line-6917"><code>		return http2errClientDisconnected</code></span>
<span class="codeline" id="line-6918"><code>	case &lt;-st.cw:</code></span>
<span class="codeline" id="line-6919"><code>		return http2errStreamClosed</code></span>
<span class="codeline" id="line-6920"><code>	case err := &lt;-msg.done:</code></span>
<span class="codeline" id="line-6921"><code>		http2errChanPool.Put(msg.done)</code></span>
<span class="codeline" id="line-6922"><code>		return err</code></span>
<span class="codeline" id="line-6923"><code>	}</code></span>
<span class="codeline" id="line-6924"><code>}</code></span>
<span class="codeline" id="line-6925"><code></code></span>
<span class="codeline" id="line-6926"><code>type http2startPushRequest struct {</code></span>
<span class="codeline" id="line-6927"><code>	parent *http2stream</code></span>
<span class="codeline" id="line-6928"><code>	method string</code></span>
<span class="codeline" id="line-6929"><code>	url    *url.URL</code></span>
<span class="codeline" id="line-6930"><code>	header Header</code></span>
<span class="codeline" id="line-6931"><code>	done   chan error</code></span>
<span class="codeline" id="line-6932"><code>}</code></span>
<span class="codeline" id="line-6933"><code></code></span>
<span class="codeline" id="line-6934"><code>func (sc *http2serverConn) startPush(msg *http2startPushRequest) {</code></span>
<span class="codeline" id="line-6935"><code>	sc.serveG.check()</code></span>
<span class="codeline" id="line-6936"><code></code></span>
<span class="codeline" id="line-6937"><code>	// http://tools.ietf.org/html/rfc7540#section-6.6.</code></span>
<span class="codeline" id="line-6938"><code>	// PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that</code></span>
<span class="codeline" id="line-6939"><code>	// is in either the "open" or "half-closed (remote)" state.</code></span>
<span class="codeline" id="line-6940"><code>	if msg.parent.state != http2stateOpen &amp;&amp; msg.parent.state != http2stateHalfClosedRemote {</code></span>
<span class="codeline" id="line-6941"><code>		// responseWriter.Push checks that the stream is peer-initiated.</code></span>
<span class="codeline" id="line-6942"><code>		msg.done &lt;- http2errStreamClosed</code></span>
<span class="codeline" id="line-6943"><code>		return</code></span>
<span class="codeline" id="line-6944"><code>	}</code></span>
<span class="codeline" id="line-6945"><code></code></span>
<span class="codeline" id="line-6946"><code>	// http://tools.ietf.org/html/rfc7540#section-6.6.</code></span>
<span class="codeline" id="line-6947"><code>	if !sc.pushEnabled {</code></span>
<span class="codeline" id="line-6948"><code>		msg.done &lt;- ErrNotSupported</code></span>
<span class="codeline" id="line-6949"><code>		return</code></span>
<span class="codeline" id="line-6950"><code>	}</code></span>
<span class="codeline" id="line-6951"><code></code></span>
<span class="codeline" id="line-6952"><code>	// PUSH_PROMISE frames must be sent in increasing order by stream ID, so</code></span>
<span class="codeline" id="line-6953"><code>	// we allocate an ID for the promised stream lazily, when the PUSH_PROMISE</code></span>
<span class="codeline" id="line-6954"><code>	// is written. Once the ID is allocated, we start the request handler.</code></span>
<span class="codeline" id="line-6955"><code>	allocatePromisedID := func() (uint32, error) {</code></span>
<span class="codeline" id="line-6956"><code>		sc.serveG.check()</code></span>
<span class="codeline" id="line-6957"><code></code></span>
<span class="codeline" id="line-6958"><code>		// Check this again, just in case. Technically, we might have received</code></span>
<span class="codeline" id="line-6959"><code>		// an updated SETTINGS by the time we got around to writing this frame.</code></span>
<span class="codeline" id="line-6960"><code>		if !sc.pushEnabled {</code></span>
<span class="codeline" id="line-6961"><code>			return 0, ErrNotSupported</code></span>
<span class="codeline" id="line-6962"><code>		}</code></span>
<span class="codeline" id="line-6963"><code>		// http://tools.ietf.org/html/rfc7540#section-6.5.2.</code></span>
<span class="codeline" id="line-6964"><code>		if sc.curPushedStreams+1 &gt; sc.clientMaxStreams {</code></span>
<span class="codeline" id="line-6965"><code>			return 0, http2ErrPushLimitReached</code></span>
<span class="codeline" id="line-6966"><code>		}</code></span>
<span class="codeline" id="line-6967"><code></code></span>
<span class="codeline" id="line-6968"><code>		// http://tools.ietf.org/html/rfc7540#section-5.1.1.</code></span>
<span class="codeline" id="line-6969"><code>		// Streams initiated by the server MUST use even-numbered identifiers.</code></span>
<span class="codeline" id="line-6970"><code>		// A server that is unable to establish a new stream identifier can send a GOAWAY</code></span>
<span class="codeline" id="line-6971"><code>		// frame so that the client is forced to open a new connection for new streams.</code></span>
<span class="codeline" id="line-6972"><code>		if sc.maxPushPromiseID+2 &gt;= 1&lt;&lt;31 {</code></span>
<span class="codeline" id="line-6973"><code>			sc.startGracefulShutdownInternal()</code></span>
<span class="codeline" id="line-6974"><code>			return 0, http2ErrPushLimitReached</code></span>
<span class="codeline" id="line-6975"><code>		}</code></span>
<span class="codeline" id="line-6976"><code>		sc.maxPushPromiseID += 2</code></span>
<span class="codeline" id="line-6977"><code>		promisedID := sc.maxPushPromiseID</code></span>
<span class="codeline" id="line-6978"><code></code></span>
<span class="codeline" id="line-6979"><code>		// http://tools.ietf.org/html/rfc7540#section-8.2.</code></span>
<span class="codeline" id="line-6980"><code>		// Strictly speaking, the new stream should start in "reserved (local)", then</code></span>
<span class="codeline" id="line-6981"><code>		// transition to "half closed (remote)" after sending the initial HEADERS, but</code></span>
<span class="codeline" id="line-6982"><code>		// we start in "half closed (remote)" for simplicity.</code></span>
<span class="codeline" id="line-6983"><code>		// See further comments at the definition of stateHalfClosedRemote.</code></span>
<span class="codeline" id="line-6984"><code>		promised := sc.newStream(promisedID, msg.parent.id, http2stateHalfClosedRemote)</code></span>
<span class="codeline" id="line-6985"><code>		rw, req, err := sc.newWriterAndRequestNoBody(promised, http2requestParam{</code></span>
<span class="codeline" id="line-6986"><code>			method:    msg.method,</code></span>
<span class="codeline" id="line-6987"><code>			scheme:    msg.url.Scheme,</code></span>
<span class="codeline" id="line-6988"><code>			authority: msg.url.Host,</code></span>
<span class="codeline" id="line-6989"><code>			path:      msg.url.RequestURI(),</code></span>
<span class="codeline" id="line-6990"><code>			header:    http2cloneHeader(msg.header), // clone since handler runs concurrently with writing the PUSH_PROMISE</code></span>
<span class="codeline" id="line-6991"><code>		})</code></span>
<span class="codeline" id="line-6992"><code>		if err != nil {</code></span>
<span class="codeline" id="line-6993"><code>			// Should not happen, since we've already validated msg.url.</code></span>
<span class="codeline" id="line-6994"><code>			panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err))</code></span>
<span class="codeline" id="line-6995"><code>		}</code></span>
<span class="codeline" id="line-6996"><code></code></span>
<span class="codeline" id="line-6997"><code>		sc.curHandlers++</code></span>
<span class="codeline" id="line-6998"><code>		go sc.runHandler(rw, req, sc.handler.ServeHTTP)</code></span>
<span class="codeline" id="line-6999"><code>		return promisedID, nil</code></span>
<span class="codeline" id="line-7000"><code>	}</code></span>
<span class="codeline" id="line-7001"><code></code></span>
<span class="codeline" id="line-7002"><code>	sc.writeFrame(http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-7003"><code>		write: &amp;http2writePushPromise{</code></span>
<span class="codeline" id="line-7004"><code>			streamID:           msg.parent.id,</code></span>
<span class="codeline" id="line-7005"><code>			method:             msg.method,</code></span>
<span class="codeline" id="line-7006"><code>			url:                msg.url,</code></span>
<span class="codeline" id="line-7007"><code>			h:                  msg.header,</code></span>
<span class="codeline" id="line-7008"><code>			allocatePromisedID: allocatePromisedID,</code></span>
<span class="codeline" id="line-7009"><code>		},</code></span>
<span class="codeline" id="line-7010"><code>		stream: msg.parent,</code></span>
<span class="codeline" id="line-7011"><code>		done:   msg.done,</code></span>
<span class="codeline" id="line-7012"><code>	})</code></span>
<span class="codeline" id="line-7013"><code>}</code></span>
<span class="codeline" id="line-7014"><code></code></span>
<span class="codeline" id="line-7015"><code>// foreachHeaderElement splits v according to the "#rule" construction</code></span>
<span class="codeline" id="line-7016"><code>// in RFC 7230 section 7 and calls fn for each non-empty element.</code></span>
<span class="codeline" id="line-7017"><code>func http2foreachHeaderElement(v string, fn func(string)) {</code></span>
<span class="codeline" id="line-7018"><code>	v = textproto.TrimString(v)</code></span>
<span class="codeline" id="line-7019"><code>	if v == "" {</code></span>
<span class="codeline" id="line-7020"><code>		return</code></span>
<span class="codeline" id="line-7021"><code>	}</code></span>
<span class="codeline" id="line-7022"><code>	if !strings.Contains(v, ",") {</code></span>
<span class="codeline" id="line-7023"><code>		fn(v)</code></span>
<span class="codeline" id="line-7024"><code>		return</code></span>
<span class="codeline" id="line-7025"><code>	}</code></span>
<span class="codeline" id="line-7026"><code>	for _, f := range strings.Split(v, ",") {</code></span>
<span class="codeline" id="line-7027"><code>		if f = textproto.TrimString(f); f != "" {</code></span>
<span class="codeline" id="line-7028"><code>			fn(f)</code></span>
<span class="codeline" id="line-7029"><code>		}</code></span>
<span class="codeline" id="line-7030"><code>	}</code></span>
<span class="codeline" id="line-7031"><code>}</code></span>
<span class="codeline" id="line-7032"><code></code></span>
<span class="codeline" id="line-7033"><code>// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2</code></span>
<span class="codeline" id="line-7034"><code>var http2connHeaders = []string{</code></span>
<span class="codeline" id="line-7035"><code>	"Connection",</code></span>
<span class="codeline" id="line-7036"><code>	"Keep-Alive",</code></span>
<span class="codeline" id="line-7037"><code>	"Proxy-Connection",</code></span>
<span class="codeline" id="line-7038"><code>	"Transfer-Encoding",</code></span>
<span class="codeline" id="line-7039"><code>	"Upgrade",</code></span>
<span class="codeline" id="line-7040"><code>}</code></span>
<span class="codeline" id="line-7041"><code></code></span>
<span class="codeline" id="line-7042"><code>// checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,</code></span>
<span class="codeline" id="line-7043"><code>// per RFC 7540 Section 8.1.2.2.</code></span>
<span class="codeline" id="line-7044"><code>// The returned error is reported to users.</code></span>
<span class="codeline" id="line-7045"><code>func http2checkValidHTTP2RequestHeaders(h Header) error {</code></span>
<span class="codeline" id="line-7046"><code>	for _, k := range http2connHeaders {</code></span>
<span class="codeline" id="line-7047"><code>		if _, ok := h[k]; ok {</code></span>
<span class="codeline" id="line-7048"><code>			return fmt.Errorf("request header %q is not valid in HTTP/2", k)</code></span>
<span class="codeline" id="line-7049"><code>		}</code></span>
<span class="codeline" id="line-7050"><code>	}</code></span>
<span class="codeline" id="line-7051"><code>	te := h["Te"]</code></span>
<span class="codeline" id="line-7052"><code>	if len(te) &gt; 0 &amp;&amp; (len(te) &gt; 1 || (te[0] != "trailers" &amp;&amp; te[0] != "")) {</code></span>
<span class="codeline" id="line-7053"><code>		return errors.New(`request header "TE" may only be "trailers" in HTTP/2`)</code></span>
<span class="codeline" id="line-7054"><code>	}</code></span>
<span class="codeline" id="line-7055"><code>	return nil</code></span>
<span class="codeline" id="line-7056"><code>}</code></span>
<span class="codeline" id="line-7057"><code></code></span>
<span class="codeline" id="line-7058"><code>func http2new400Handler(err error) HandlerFunc {</code></span>
<span class="codeline" id="line-7059"><code>	return func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-7060"><code>		Error(w, err.Error(), StatusBadRequest)</code></span>
<span class="codeline" id="line-7061"><code>	}</code></span>
<span class="codeline" id="line-7062"><code>}</code></span>
<span class="codeline" id="line-7063"><code></code></span>
<span class="codeline" id="line-7064"><code>// h1ServerKeepAlivesDisabled reports whether hs has its keep-alives</code></span>
<span class="codeline" id="line-7065"><code>// disabled. See comments on h1ServerShutdownChan above for why</code></span>
<span class="codeline" id="line-7066"><code>// the code is written this way.</code></span>
<span class="codeline" id="line-7067"><code>func http2h1ServerKeepAlivesDisabled(hs *Server) bool {</code></span>
<span class="codeline" id="line-7068"><code>	var x interface{} = hs</code></span>
<span class="codeline" id="line-7069"><code>	type I interface {</code></span>
<span class="codeline" id="line-7070"><code>		doKeepAlives() bool</code></span>
<span class="codeline" id="line-7071"><code>	}</code></span>
<span class="codeline" id="line-7072"><code>	if hs, ok := x.(I); ok {</code></span>
<span class="codeline" id="line-7073"><code>		return !hs.doKeepAlives()</code></span>
<span class="codeline" id="line-7074"><code>	}</code></span>
<span class="codeline" id="line-7075"><code>	return false</code></span>
<span class="codeline" id="line-7076"><code>}</code></span>
<span class="codeline" id="line-7077"><code></code></span>
<span class="codeline" id="line-7078"><code>func (sc *http2serverConn) countError(name string, err error) error {</code></span>
<span class="codeline" id="line-7079"><code>	if sc == nil || sc.srv == nil {</code></span>
<span class="codeline" id="line-7080"><code>		return err</code></span>
<span class="codeline" id="line-7081"><code>	}</code></span>
<span class="codeline" id="line-7082"><code>	f := sc.srv.CountError</code></span>
<span class="codeline" id="line-7083"><code>	if f == nil {</code></span>
<span class="codeline" id="line-7084"><code>		return err</code></span>
<span class="codeline" id="line-7085"><code>	}</code></span>
<span class="codeline" id="line-7086"><code>	var typ string</code></span>
<span class="codeline" id="line-7087"><code>	var code http2ErrCode</code></span>
<span class="codeline" id="line-7088"><code>	switch e := err.(type) {</code></span>
<span class="codeline" id="line-7089"><code>	case http2ConnectionError:</code></span>
<span class="codeline" id="line-7090"><code>		typ = "conn"</code></span>
<span class="codeline" id="line-7091"><code>		code = http2ErrCode(e)</code></span>
<span class="codeline" id="line-7092"><code>	case http2StreamError:</code></span>
<span class="codeline" id="line-7093"><code>		typ = "stream"</code></span>
<span class="codeline" id="line-7094"><code>		code = http2ErrCode(e.Code)</code></span>
<span class="codeline" id="line-7095"><code>	default:</code></span>
<span class="codeline" id="line-7096"><code>		return err</code></span>
<span class="codeline" id="line-7097"><code>	}</code></span>
<span class="codeline" id="line-7098"><code>	codeStr := http2errCodeName[code]</code></span>
<span class="codeline" id="line-7099"><code>	if codeStr == "" {</code></span>
<span class="codeline" id="line-7100"><code>		codeStr = strconv.Itoa(int(code))</code></span>
<span class="codeline" id="line-7101"><code>	}</code></span>
<span class="codeline" id="line-7102"><code>	f(fmt.Sprintf("%s_%s_%s", typ, codeStr, name))</code></span>
<span class="codeline" id="line-7103"><code>	return err</code></span>
<span class="codeline" id="line-7104"><code>}</code></span>
<span class="codeline" id="line-7105"><code></code></span>
<span class="codeline" id="line-7106"><code>const (</code></span>
<span class="codeline" id="line-7107"><code>	// transportDefaultConnFlow is how many connection-level flow control</code></span>
<span class="codeline" id="line-7108"><code>	// tokens we give the server at start-up, past the default 64k.</code></span>
<span class="codeline" id="line-7109"><code>	http2transportDefaultConnFlow = 1 &lt;&lt; 30</code></span>
<span class="codeline" id="line-7110"><code></code></span>
<span class="codeline" id="line-7111"><code>	// transportDefaultStreamFlow is how many stream-level flow</code></span>
<span class="codeline" id="line-7112"><code>	// control tokens we announce to the peer, and how many bytes</code></span>
<span class="codeline" id="line-7113"><code>	// we buffer per stream.</code></span>
<span class="codeline" id="line-7114"><code>	http2transportDefaultStreamFlow = 4 &lt;&lt; 20</code></span>
<span class="codeline" id="line-7115"><code></code></span>
<span class="codeline" id="line-7116"><code>	http2defaultUserAgent = "Go-http-client/2.0"</code></span>
<span class="codeline" id="line-7117"><code></code></span>
<span class="codeline" id="line-7118"><code>	// initialMaxConcurrentStreams is a connections maxConcurrentStreams until</code></span>
<span class="codeline" id="line-7119"><code>	// it's received servers initial SETTINGS frame, which corresponds with the</code></span>
<span class="codeline" id="line-7120"><code>	// spec's minimum recommended value.</code></span>
<span class="codeline" id="line-7121"><code>	http2initialMaxConcurrentStreams = 100</code></span>
<span class="codeline" id="line-7122"><code></code></span>
<span class="codeline" id="line-7123"><code>	// defaultMaxConcurrentStreams is a connections default maxConcurrentStreams</code></span>
<span class="codeline" id="line-7124"><code>	// if the server doesn't include one in its initial SETTINGS frame.</code></span>
<span class="codeline" id="line-7125"><code>	http2defaultMaxConcurrentStreams = 1000</code></span>
<span class="codeline" id="line-7126"><code>)</code></span>
<span class="codeline" id="line-7127"><code></code></span>
<span class="codeline" id="line-7128"><code>// Transport is an HTTP/2 Transport.</code></span>
<span class="codeline" id="line-7129"><code>//</code></span>
<span class="codeline" id="line-7130"><code>// A Transport internally caches connections to servers. It is safe</code></span>
<span class="codeline" id="line-7131"><code>// for concurrent use by multiple goroutines.</code></span>
<span class="codeline" id="line-7132"><code>type http2Transport struct {</code></span>
<span class="codeline" id="line-7133"><code>	// DialTLSContext specifies an optional dial function with context for</code></span>
<span class="codeline" id="line-7134"><code>	// creating TLS connections for requests.</code></span>
<span class="codeline" id="line-7135"><code>	//</code></span>
<span class="codeline" id="line-7136"><code>	// If DialTLSContext and DialTLS is nil, tls.Dial is used.</code></span>
<span class="codeline" id="line-7137"><code>	//</code></span>
<span class="codeline" id="line-7138"><code>	// If the returned net.Conn has a ConnectionState method like tls.Conn,</code></span>
<span class="codeline" id="line-7139"><code>	// it will be used to set http.Response.TLS.</code></span>
<span class="codeline" id="line-7140"><code>	DialTLSContext func(ctx context.Context, network, addr string, cfg *tls.Config) (net.Conn, error)</code></span>
<span class="codeline" id="line-7141"><code></code></span>
<span class="codeline" id="line-7142"><code>	// DialTLS specifies an optional dial function for creating</code></span>
<span class="codeline" id="line-7143"><code>	// TLS connections for requests.</code></span>
<span class="codeline" id="line-7144"><code>	//</code></span>
<span class="codeline" id="line-7145"><code>	// If DialTLSContext and DialTLS is nil, tls.Dial is used.</code></span>
<span class="codeline" id="line-7146"><code>	//</code></span>
<span class="codeline" id="line-7147"><code>	// Deprecated: Use DialTLSContext instead, which allows the transport</code></span>
<span class="codeline" id="line-7148"><code>	// to cancel dials as soon as they are no longer needed.</code></span>
<span class="codeline" id="line-7149"><code>	// If both are set, DialTLSContext takes priority.</code></span>
<span class="codeline" id="line-7150"><code>	DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)</code></span>
<span class="codeline" id="line-7151"><code></code></span>
<span class="codeline" id="line-7152"><code>	// TLSClientConfig specifies the TLS configuration to use with</code></span>
<span class="codeline" id="line-7153"><code>	// tls.Client. If nil, the default configuration is used.</code></span>
<span class="codeline" id="line-7154"><code>	TLSClientConfig *tls.Config</code></span>
<span class="codeline" id="line-7155"><code></code></span>
<span class="codeline" id="line-7156"><code>	// ConnPool optionally specifies an alternate connection pool to use.</code></span>
<span class="codeline" id="line-7157"><code>	// If nil, the default is used.</code></span>
<span class="codeline" id="line-7158"><code>	ConnPool http2ClientConnPool</code></span>
<span class="codeline" id="line-7159"><code></code></span>
<span class="codeline" id="line-7160"><code>	// DisableCompression, if true, prevents the Transport from</code></span>
<span class="codeline" id="line-7161"><code>	// requesting compression with an "Accept-Encoding: gzip"</code></span>
<span class="codeline" id="line-7162"><code>	// request header when the Request contains no existing</code></span>
<span class="codeline" id="line-7163"><code>	// Accept-Encoding value. If the Transport requests gzip on</code></span>
<span class="codeline" id="line-7164"><code>	// its own and gets a gzipped response, it's transparently</code></span>
<span class="codeline" id="line-7165"><code>	// decoded in the Response.Body. However, if the user</code></span>
<span class="codeline" id="line-7166"><code>	// explicitly requested gzip it is not automatically</code></span>
<span class="codeline" id="line-7167"><code>	// uncompressed.</code></span>
<span class="codeline" id="line-7168"><code>	DisableCompression bool</code></span>
<span class="codeline" id="line-7169"><code></code></span>
<span class="codeline" id="line-7170"><code>	// AllowHTTP, if true, permits HTTP/2 requests using the insecure,</code></span>
<span class="codeline" id="line-7171"><code>	// plain-text "http" scheme. Note that this does not enable h2c support.</code></span>
<span class="codeline" id="line-7172"><code>	AllowHTTP bool</code></span>
<span class="codeline" id="line-7173"><code></code></span>
<span class="codeline" id="line-7174"><code>	// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to</code></span>
<span class="codeline" id="line-7175"><code>	// send in the initial settings frame. It is how many bytes</code></span>
<span class="codeline" id="line-7176"><code>	// of response headers are allowed. Unlike the http2 spec, zero here</code></span>
<span class="codeline" id="line-7177"><code>	// means to use a default limit (currently 10MB). If you actually</code></span>
<span class="codeline" id="line-7178"><code>	// want to advertise an unlimited value to the peer, Transport</code></span>
<span class="codeline" id="line-7179"><code>	// interprets the highest possible value here (0xffffffff or 1&lt;&lt;32-1)</code></span>
<span class="codeline" id="line-7180"><code>	// to mean no limit.</code></span>
<span class="codeline" id="line-7181"><code>	MaxHeaderListSize uint32</code></span>
<span class="codeline" id="line-7182"><code></code></span>
<span class="codeline" id="line-7183"><code>	// MaxReadFrameSize is the http2 SETTINGS_MAX_FRAME_SIZE to send in the</code></span>
<span class="codeline" id="line-7184"><code>	// initial settings frame. It is the size in bytes of the largest frame</code></span>
<span class="codeline" id="line-7185"><code>	// payload that the sender is willing to receive. If 0, no setting is</code></span>
<span class="codeline" id="line-7186"><code>	// sent, and the value is provided by the peer, which should be 16384</code></span>
<span class="codeline" id="line-7187"><code>	// according to the spec:</code></span>
<span class="codeline" id="line-7188"><code>	// https://datatracker.ietf.org/doc/html/rfc7540#section-6.5.2.</code></span>
<span class="codeline" id="line-7189"><code>	// Values are bounded in the range 16k to 16M.</code></span>
<span class="codeline" id="line-7190"><code>	MaxReadFrameSize uint32</code></span>
<span class="codeline" id="line-7191"><code></code></span>
<span class="codeline" id="line-7192"><code>	// MaxDecoderHeaderTableSize optionally specifies the http2</code></span>
<span class="codeline" id="line-7193"><code>	// SETTINGS_HEADER_TABLE_SIZE to send in the initial settings frame. It</code></span>
<span class="codeline" id="line-7194"><code>	// informs the remote endpoint of the maximum size of the header compression</code></span>
<span class="codeline" id="line-7195"><code>	// table used to decode header blocks, in octets. If zero, the default value</code></span>
<span class="codeline" id="line-7196"><code>	// of 4096 is used.</code></span>
<span class="codeline" id="line-7197"><code>	MaxDecoderHeaderTableSize uint32</code></span>
<span class="codeline" id="line-7198"><code></code></span>
<span class="codeline" id="line-7199"><code>	// MaxEncoderHeaderTableSize optionally specifies an upper limit for the</code></span>
<span class="codeline" id="line-7200"><code>	// header compression table used for encoding request headers. Received</code></span>
<span class="codeline" id="line-7201"><code>	// SETTINGS_HEADER_TABLE_SIZE settings are capped at this limit. If zero,</code></span>
<span class="codeline" id="line-7202"><code>	// the default value of 4096 is used.</code></span>
<span class="codeline" id="line-7203"><code>	MaxEncoderHeaderTableSize uint32</code></span>
<span class="codeline" id="line-7204"><code></code></span>
<span class="codeline" id="line-7205"><code>	// StrictMaxConcurrentStreams controls whether the server's</code></span>
<span class="codeline" id="line-7206"><code>	// SETTINGS_MAX_CONCURRENT_STREAMS should be respected</code></span>
<span class="codeline" id="line-7207"><code>	// globally. If false, new TCP connections are created to the</code></span>
<span class="codeline" id="line-7208"><code>	// server as needed to keep each under the per-connection</code></span>
<span class="codeline" id="line-7209"><code>	// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the</code></span>
<span class="codeline" id="line-7210"><code>	// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as</code></span>
<span class="codeline" id="line-7211"><code>	// a global limit and callers of RoundTrip block when needed,</code></span>
<span class="codeline" id="line-7212"><code>	// waiting for their turn.</code></span>
<span class="codeline" id="line-7213"><code>	StrictMaxConcurrentStreams bool</code></span>
<span class="codeline" id="line-7214"><code></code></span>
<span class="codeline" id="line-7215"><code>	// ReadIdleTimeout is the timeout after which a health check using ping</code></span>
<span class="codeline" id="line-7216"><code>	// frame will be carried out if no frame is received on the connection.</code></span>
<span class="codeline" id="line-7217"><code>	// Note that a ping response will is considered a received frame, so if</code></span>
<span class="codeline" id="line-7218"><code>	// there is no other traffic on the connection, the health check will</code></span>
<span class="codeline" id="line-7219"><code>	// be performed every ReadIdleTimeout interval.</code></span>
<span class="codeline" id="line-7220"><code>	// If zero, no health check is performed.</code></span>
<span class="codeline" id="line-7221"><code>	ReadIdleTimeout time.Duration</code></span>
<span class="codeline" id="line-7222"><code></code></span>
<span class="codeline" id="line-7223"><code>	// PingTimeout is the timeout after which the connection will be closed</code></span>
<span class="codeline" id="line-7224"><code>	// if a response to Ping is not received.</code></span>
<span class="codeline" id="line-7225"><code>	// Defaults to 15s.</code></span>
<span class="codeline" id="line-7226"><code>	PingTimeout time.Duration</code></span>
<span class="codeline" id="line-7227"><code></code></span>
<span class="codeline" id="line-7228"><code>	// WriteByteTimeout is the timeout after which the connection will be</code></span>
<span class="codeline" id="line-7229"><code>	// closed no data can be written to it. The timeout begins when data is</code></span>
<span class="codeline" id="line-7230"><code>	// available to write, and is extended whenever any bytes are written.</code></span>
<span class="codeline" id="line-7231"><code>	WriteByteTimeout time.Duration</code></span>
<span class="codeline" id="line-7232"><code></code></span>
<span class="codeline" id="line-7233"><code>	// CountError, if non-nil, is called on HTTP/2 transport errors.</code></span>
<span class="codeline" id="line-7234"><code>	// It's intended to increment a metric for monitoring, such</code></span>
<span class="codeline" id="line-7235"><code>	// as an expvar or Prometheus metric.</code></span>
<span class="codeline" id="line-7236"><code>	// The errType consists of only ASCII word characters.</code></span>
<span class="codeline" id="line-7237"><code>	CountError func(errType string)</code></span>
<span class="codeline" id="line-7238"><code></code></span>
<span class="codeline" id="line-7239"><code>	// t1, if non-nil, is the standard library Transport using</code></span>
<span class="codeline" id="line-7240"><code>	// this transport. Its settings are used (but not its</code></span>
<span class="codeline" id="line-7241"><code>	// RoundTrip method, etc).</code></span>
<span class="codeline" id="line-7242"><code>	t1 *Transport</code></span>
<span class="codeline" id="line-7243"><code></code></span>
<span class="codeline" id="line-7244"><code>	connPoolOnce  sync.Once</code></span>
<span class="codeline" id="line-7245"><code>	connPoolOrDef http2ClientConnPool // non-nil version of ConnPool</code></span>
<span class="codeline" id="line-7246"><code>}</code></span>
<span class="codeline" id="line-7247"><code></code></span>
<span class="codeline" id="line-7248"><code>func (t *http2Transport) maxHeaderListSize() uint32 {</code></span>
<span class="codeline" id="line-7249"><code>	if t.MaxHeaderListSize == 0 {</code></span>
<span class="codeline" id="line-7250"><code>		return 10 &lt;&lt; 20</code></span>
<span class="codeline" id="line-7251"><code>	}</code></span>
<span class="codeline" id="line-7252"><code>	if t.MaxHeaderListSize == 0xffffffff {</code></span>
<span class="codeline" id="line-7253"><code>		return 0</code></span>
<span class="codeline" id="line-7254"><code>	}</code></span>
<span class="codeline" id="line-7255"><code>	return t.MaxHeaderListSize</code></span>
<span class="codeline" id="line-7256"><code>}</code></span>
<span class="codeline" id="line-7257"><code></code></span>
<span class="codeline" id="line-7258"><code>func (t *http2Transport) maxFrameReadSize() uint32 {</code></span>
<span class="codeline" id="line-7259"><code>	if t.MaxReadFrameSize == 0 {</code></span>
<span class="codeline" id="line-7260"><code>		return 0 // use the default provided by the peer</code></span>
<span class="codeline" id="line-7261"><code>	}</code></span>
<span class="codeline" id="line-7262"><code>	if t.MaxReadFrameSize &lt; http2minMaxFrameSize {</code></span>
<span class="codeline" id="line-7263"><code>		return http2minMaxFrameSize</code></span>
<span class="codeline" id="line-7264"><code>	}</code></span>
<span class="codeline" id="line-7265"><code>	if t.MaxReadFrameSize &gt; http2maxFrameSize {</code></span>
<span class="codeline" id="line-7266"><code>		return http2maxFrameSize</code></span>
<span class="codeline" id="line-7267"><code>	}</code></span>
<span class="codeline" id="line-7268"><code>	return t.MaxReadFrameSize</code></span>
<span class="codeline" id="line-7269"><code>}</code></span>
<span class="codeline" id="line-7270"><code></code></span>
<span class="codeline" id="line-7271"><code>func (t *http2Transport) disableCompression() bool {</code></span>
<span class="codeline" id="line-7272"><code>	return t.DisableCompression || (t.t1 != nil &amp;&amp; t.t1.DisableCompression)</code></span>
<span class="codeline" id="line-7273"><code>}</code></span>
<span class="codeline" id="line-7274"><code></code></span>
<span class="codeline" id="line-7275"><code>func (t *http2Transport) pingTimeout() time.Duration {</code></span>
<span class="codeline" id="line-7276"><code>	if t.PingTimeout == 0 {</code></span>
<span class="codeline" id="line-7277"><code>		return 15 * time.Second</code></span>
<span class="codeline" id="line-7278"><code>	}</code></span>
<span class="codeline" id="line-7279"><code>	return t.PingTimeout</code></span>
<span class="codeline" id="line-7280"><code></code></span>
<span class="codeline" id="line-7281"><code>}</code></span>
<span class="codeline" id="line-7282"><code></code></span>
<span class="codeline" id="line-7283"><code>// ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.</code></span>
<span class="codeline" id="line-7284"><code>// It returns an error if t1 has already been HTTP/2-enabled.</code></span>
<span class="codeline" id="line-7285"><code>//</code></span>
<span class="codeline" id="line-7286"><code>// Use ConfigureTransports instead to configure the HTTP/2 Transport.</code></span>
<span class="codeline" id="line-7287"><code>func http2ConfigureTransport(t1 *Transport) error {</code></span>
<span class="codeline" id="line-7288"><code>	_, err := http2ConfigureTransports(t1)</code></span>
<span class="codeline" id="line-7289"><code>	return err</code></span>
<span class="codeline" id="line-7290"><code>}</code></span>
<span class="codeline" id="line-7291"><code></code></span>
<span class="codeline" id="line-7292"><code>// ConfigureTransports configures a net/http HTTP/1 Transport to use HTTP/2.</code></span>
<span class="codeline" id="line-7293"><code>// It returns a new HTTP/2 Transport for further configuration.</code></span>
<span class="codeline" id="line-7294"><code>// It returns an error if t1 has already been HTTP/2-enabled.</code></span>
<span class="codeline" id="line-7295"><code>func http2ConfigureTransports(t1 *Transport) (*http2Transport, error) {</code></span>
<span class="codeline" id="line-7296"><code>	return http2configureTransports(t1)</code></span>
<span class="codeline" id="line-7297"><code>}</code></span>
<span class="codeline" id="line-7298"><code></code></span>
<span class="codeline" id="line-7299"><code>func http2configureTransports(t1 *Transport) (*http2Transport, error) {</code></span>
<span class="codeline" id="line-7300"><code>	connPool := new(http2clientConnPool)</code></span>
<span class="codeline" id="line-7301"><code>	t2 := &amp;http2Transport{</code></span>
<span class="codeline" id="line-7302"><code>		ConnPool: http2noDialClientConnPool{connPool},</code></span>
<span class="codeline" id="line-7303"><code>		t1:       t1,</code></span>
<span class="codeline" id="line-7304"><code>	}</code></span>
<span class="codeline" id="line-7305"><code>	connPool.t = t2</code></span>
<span class="codeline" id="line-7306"><code>	if err := http2registerHTTPSProtocol(t1, http2noDialH2RoundTripper{t2}); err != nil {</code></span>
<span class="codeline" id="line-7307"><code>		return nil, err</code></span>
<span class="codeline" id="line-7308"><code>	}</code></span>
<span class="codeline" id="line-7309"><code>	if t1.TLSClientConfig == nil {</code></span>
<span class="codeline" id="line-7310"><code>		t1.TLSClientConfig = new(tls.Config)</code></span>
<span class="codeline" id="line-7311"><code>	}</code></span>
<span class="codeline" id="line-7312"><code>	if !http2strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {</code></span>
<span class="codeline" id="line-7313"><code>		t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)</code></span>
<span class="codeline" id="line-7314"><code>	}</code></span>
<span class="codeline" id="line-7315"><code>	if !http2strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1") {</code></span>
<span class="codeline" id="line-7316"><code>		t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1")</code></span>
<span class="codeline" id="line-7317"><code>	}</code></span>
<span class="codeline" id="line-7318"><code>	upgradeFn := func(authority string, c *tls.Conn) RoundTripper {</code></span>
<span class="codeline" id="line-7319"><code>		addr := http2authorityAddr("https", authority)</code></span>
<span class="codeline" id="line-7320"><code>		if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {</code></span>
<span class="codeline" id="line-7321"><code>			go c.Close()</code></span>
<span class="codeline" id="line-7322"><code>			return http2erringRoundTripper{err}</code></span>
<span class="codeline" id="line-7323"><code>		} else if !used {</code></span>
<span class="codeline" id="line-7324"><code>			// Turns out we don't need this c.</code></span>
<span class="codeline" id="line-7325"><code>			// For example, two goroutines made requests to the same host</code></span>
<span class="codeline" id="line-7326"><code>			// at the same time, both kicking off TCP dials. (since protocol</code></span>
<span class="codeline" id="line-7327"><code>			// was unknown)</code></span>
<span class="codeline" id="line-7328"><code>			go c.Close()</code></span>
<span class="codeline" id="line-7329"><code>		}</code></span>
<span class="codeline" id="line-7330"><code>		return t2</code></span>
<span class="codeline" id="line-7331"><code>	}</code></span>
<span class="codeline" id="line-7332"><code>	if m := t1.TLSNextProto; len(m) == 0 {</code></span>
<span class="codeline" id="line-7333"><code>		t1.TLSNextProto = map[string]func(string, *tls.Conn) RoundTripper{</code></span>
<span class="codeline" id="line-7334"><code>			"h2": upgradeFn,</code></span>
<span class="codeline" id="line-7335"><code>		}</code></span>
<span class="codeline" id="line-7336"><code>	} else {</code></span>
<span class="codeline" id="line-7337"><code>		m["h2"] = upgradeFn</code></span>
<span class="codeline" id="line-7338"><code>	}</code></span>
<span class="codeline" id="line-7339"><code>	return t2, nil</code></span>
<span class="codeline" id="line-7340"><code>}</code></span>
<span class="codeline" id="line-7341"><code></code></span>
<span class="codeline" id="line-7342"><code>func (t *http2Transport) connPool() http2ClientConnPool {</code></span>
<span class="codeline" id="line-7343"><code>	t.connPoolOnce.Do(t.initConnPool)</code></span>
<span class="codeline" id="line-7344"><code>	return t.connPoolOrDef</code></span>
<span class="codeline" id="line-7345"><code>}</code></span>
<span class="codeline" id="line-7346"><code></code></span>
<span class="codeline" id="line-7347"><code>func (t *http2Transport) initConnPool() {</code></span>
<span class="codeline" id="line-7348"><code>	if t.ConnPool != nil {</code></span>
<span class="codeline" id="line-7349"><code>		t.connPoolOrDef = t.ConnPool</code></span>
<span class="codeline" id="line-7350"><code>	} else {</code></span>
<span class="codeline" id="line-7351"><code>		t.connPoolOrDef = &amp;http2clientConnPool{t: t}</code></span>
<span class="codeline" id="line-7352"><code>	}</code></span>
<span class="codeline" id="line-7353"><code>}</code></span>
<span class="codeline" id="line-7354"><code></code></span>
<span class="codeline" id="line-7355"><code>// ClientConn is the state of a single HTTP/2 client connection to an</code></span>
<span class="codeline" id="line-7356"><code>// HTTP/2 server.</code></span>
<span class="codeline" id="line-7357"><code>type http2ClientConn struct {</code></span>
<span class="codeline" id="line-7358"><code>	t             *http2Transport</code></span>
<span class="codeline" id="line-7359"><code>	tconn         net.Conn             // usually *tls.Conn, except specialized impls</code></span>
<span class="codeline" id="line-7360"><code>	tlsState      *tls.ConnectionState // nil only for specialized impls</code></span>
<span class="codeline" id="line-7361"><code>	reused        uint32               // whether conn is being reused; atomic</code></span>
<span class="codeline" id="line-7362"><code>	singleUse     bool                 // whether being used for a single http.Request</code></span>
<span class="codeline" id="line-7363"><code>	getConnCalled bool                 // used by clientConnPool</code></span>
<span class="codeline" id="line-7364"><code></code></span>
<span class="codeline" id="line-7365"><code>	// readLoop goroutine fields:</code></span>
<span class="codeline" id="line-7366"><code>	readerDone chan struct{} // closed on error</code></span>
<span class="codeline" id="line-7367"><code>	readerErr  error         // set before readerDone is closed</code></span>
<span class="codeline" id="line-7368"><code></code></span>
<span class="codeline" id="line-7369"><code>	idleTimeout time.Duration // or 0 for never</code></span>
<span class="codeline" id="line-7370"><code>	idleTimer   *time.Timer</code></span>
<span class="codeline" id="line-7371"><code></code></span>
<span class="codeline" id="line-7372"><code>	mu              sync.Mutex   // guards following</code></span>
<span class="codeline" id="line-7373"><code>	cond            *sync.Cond   // hold mu; broadcast on flow/closed changes</code></span>
<span class="codeline" id="line-7374"><code>	flow            http2outflow // our conn-level flow control quota (cs.outflow is per stream)</code></span>
<span class="codeline" id="line-7375"><code>	inflow          http2inflow  // peer's conn-level flow control</code></span>
<span class="codeline" id="line-7376"><code>	doNotReuse      bool         // whether conn is marked to not be reused for any future requests</code></span>
<span class="codeline" id="line-7377"><code>	closing         bool</code></span>
<span class="codeline" id="line-7378"><code>	closed          bool</code></span>
<span class="codeline" id="line-7379"><code>	seenSettings    bool                          // true if we've seen a settings frame, false otherwise</code></span>
<span class="codeline" id="line-7380"><code>	wantSettingsAck bool                          // we sent a SETTINGS frame and haven't heard back</code></span>
<span class="codeline" id="line-7381"><code>	goAway          *http2GoAwayFrame             // if non-nil, the GoAwayFrame we received</code></span>
<span class="codeline" id="line-7382"><code>	goAwayDebug     string                        // goAway frame's debug data, retained as a string</code></span>
<span class="codeline" id="line-7383"><code>	streams         map[uint32]*http2clientStream // client-initiated</code></span>
<span class="codeline" id="line-7384"><code>	streamsReserved int                           // incr by ReserveNewRequest; decr on RoundTrip</code></span>
<span class="codeline" id="line-7385"><code>	nextStreamID    uint32</code></span>
<span class="codeline" id="line-7386"><code>	pendingRequests int                       // requests blocked and waiting to be sent because len(streams) == maxConcurrentStreams</code></span>
<span class="codeline" id="line-7387"><code>	pings           map[[8]byte]chan struct{} // in flight ping data to notification channel</code></span>
<span class="codeline" id="line-7388"><code>	br              *bufio.Reader</code></span>
<span class="codeline" id="line-7389"><code>	lastActive      time.Time</code></span>
<span class="codeline" id="line-7390"><code>	lastIdle        time.Time // time last idle</code></span>
<span class="codeline" id="line-7391"><code>	// Settings from peer: (also guarded by wmu)</code></span>
<span class="codeline" id="line-7392"><code>	maxFrameSize           uint32</code></span>
<span class="codeline" id="line-7393"><code>	maxConcurrentStreams   uint32</code></span>
<span class="codeline" id="line-7394"><code>	peerMaxHeaderListSize  uint64</code></span>
<span class="codeline" id="line-7395"><code>	peerMaxHeaderTableSize uint32</code></span>
<span class="codeline" id="line-7396"><code>	initialWindowSize      uint32</code></span>
<span class="codeline" id="line-7397"><code></code></span>
<span class="codeline" id="line-7398"><code>	// reqHeaderMu is a 1-element semaphore channel controlling access to sending new requests.</code></span>
<span class="codeline" id="line-7399"><code>	// Write to reqHeaderMu to lock it, read from it to unlock.</code></span>
<span class="codeline" id="line-7400"><code>	// Lock reqmu BEFORE mu or wmu.</code></span>
<span class="codeline" id="line-7401"><code>	reqHeaderMu chan struct{}</code></span>
<span class="codeline" id="line-7402"><code></code></span>
<span class="codeline" id="line-7403"><code>	// wmu is held while writing.</code></span>
<span class="codeline" id="line-7404"><code>	// Acquire BEFORE mu when holding both, to avoid blocking mu on network writes.</code></span>
<span class="codeline" id="line-7405"><code>	// Only acquire both at the same time when changing peer settings.</code></span>
<span class="codeline" id="line-7406"><code>	wmu  sync.Mutex</code></span>
<span class="codeline" id="line-7407"><code>	bw   *bufio.Writer</code></span>
<span class="codeline" id="line-7408"><code>	fr   *http2Framer</code></span>
<span class="codeline" id="line-7409"><code>	werr error        // first write error that has occurred</code></span>
<span class="codeline" id="line-7410"><code>	hbuf bytes.Buffer // HPACK encoder writes into this</code></span>
<span class="codeline" id="line-7411"><code>	henc *hpack.Encoder</code></span>
<span class="codeline" id="line-7412"><code>}</code></span>
<span class="codeline" id="line-7413"><code></code></span>
<span class="codeline" id="line-7414"><code>// clientStream is the state for a single HTTP/2 stream. One of these</code></span>
<span class="codeline" id="line-7415"><code>// is created for each Transport.RoundTrip call.</code></span>
<span class="codeline" id="line-7416"><code>type http2clientStream struct {</code></span>
<span class="codeline" id="line-7417"><code>	cc *http2ClientConn</code></span>
<span class="codeline" id="line-7418"><code></code></span>
<span class="codeline" id="line-7419"><code>	// Fields of Request that we may access even after the response body is closed.</code></span>
<span class="codeline" id="line-7420"><code>	ctx       context.Context</code></span>
<span class="codeline" id="line-7421"><code>	reqCancel &lt;-chan struct{}</code></span>
<span class="codeline" id="line-7422"><code></code></span>
<span class="codeline" id="line-7423"><code>	trace         *httptrace.ClientTrace // or nil</code></span>
<span class="codeline" id="line-7424"><code>	ID            uint32</code></span>
<span class="codeline" id="line-7425"><code>	bufPipe       http2pipe // buffered pipe with the flow-controlled response payload</code></span>
<span class="codeline" id="line-7426"><code>	requestedGzip bool</code></span>
<span class="codeline" id="line-7427"><code>	isHead        bool</code></span>
<span class="codeline" id="line-7428"><code></code></span>
<span class="codeline" id="line-7429"><code>	abortOnce sync.Once</code></span>
<span class="codeline" id="line-7430"><code>	abort     chan struct{} // closed to signal stream should end immediately</code></span>
<span class="codeline" id="line-7431"><code>	abortErr  error         // set if abort is closed</code></span>
<span class="codeline" id="line-7432"><code></code></span>
<span class="codeline" id="line-7433"><code>	peerClosed chan struct{} // closed when the peer sends an END_STREAM flag</code></span>
<span class="codeline" id="line-7434"><code>	donec      chan struct{} // closed after the stream is in the closed state</code></span>
<span class="codeline" id="line-7435"><code>	on100      chan struct{} // buffered; written to if a 100 is received</code></span>
<span class="codeline" id="line-7436"><code></code></span>
<span class="codeline" id="line-7437"><code>	respHeaderRecv chan struct{} // closed when headers are received</code></span>
<span class="codeline" id="line-7438"><code>	res            *Response     // set if respHeaderRecv is closed</code></span>
<span class="codeline" id="line-7439"><code></code></span>
<span class="codeline" id="line-7440"><code>	flow        http2outflow // guarded by cc.mu</code></span>
<span class="codeline" id="line-7441"><code>	inflow      http2inflow  // guarded by cc.mu</code></span>
<span class="codeline" id="line-7442"><code>	bytesRemain int64        // -1 means unknown; owned by transportResponseBody.Read</code></span>
<span class="codeline" id="line-7443"><code>	readErr     error        // sticky read error; owned by transportResponseBody.Read</code></span>
<span class="codeline" id="line-7444"><code></code></span>
<span class="codeline" id="line-7445"><code>	reqBody              io.ReadCloser</code></span>
<span class="codeline" id="line-7446"><code>	reqBodyContentLength int64         // -1 means unknown</code></span>
<span class="codeline" id="line-7447"><code>	reqBodyClosed        chan struct{} // guarded by cc.mu; non-nil on Close, closed when done</code></span>
<span class="codeline" id="line-7448"><code></code></span>
<span class="codeline" id="line-7449"><code>	// owned by writeRequest:</code></span>
<span class="codeline" id="line-7450"><code>	sentEndStream bool // sent an END_STREAM flag to the peer</code></span>
<span class="codeline" id="line-7451"><code>	sentHeaders   bool</code></span>
<span class="codeline" id="line-7452"><code></code></span>
<span class="codeline" id="line-7453"><code>	// owned by clientConnReadLoop:</code></span>
<span class="codeline" id="line-7454"><code>	firstByte    bool  // got the first response byte</code></span>
<span class="codeline" id="line-7455"><code>	pastHeaders  bool  // got first MetaHeadersFrame (actual headers)</code></span>
<span class="codeline" id="line-7456"><code>	pastTrailers bool  // got optional second MetaHeadersFrame (trailers)</code></span>
<span class="codeline" id="line-7457"><code>	num1xx       uint8 // number of 1xx responses seen</code></span>
<span class="codeline" id="line-7458"><code>	readClosed   bool  // peer sent an END_STREAM flag</code></span>
<span class="codeline" id="line-7459"><code>	readAborted  bool  // read loop reset the stream</code></span>
<span class="codeline" id="line-7460"><code></code></span>
<span class="codeline" id="line-7461"><code>	trailer    Header  // accumulated trailers</code></span>
<span class="codeline" id="line-7462"><code>	resTrailer *Header // client's Response.Trailer</code></span>
<span class="codeline" id="line-7463"><code>}</code></span>
<span class="codeline" id="line-7464"><code></code></span>
<span class="codeline" id="line-7465"><code>var http2got1xxFuncForTests func(int, textproto.MIMEHeader) error</code></span>
<span class="codeline" id="line-7466"><code></code></span>
<span class="codeline" id="line-7467"><code>// get1xxTraceFunc returns the value of request's httptrace.ClientTrace.Got1xxResponse func,</code></span>
<span class="codeline" id="line-7468"><code>// if any. It returns nil if not set or if the Go version is too old.</code></span>
<span class="codeline" id="line-7469"><code>func (cs *http2clientStream) get1xxTraceFunc() func(int, textproto.MIMEHeader) error {</code></span>
<span class="codeline" id="line-7470"><code>	if fn := http2got1xxFuncForTests; fn != nil {</code></span>
<span class="codeline" id="line-7471"><code>		return fn</code></span>
<span class="codeline" id="line-7472"><code>	}</code></span>
<span class="codeline" id="line-7473"><code>	return http2traceGot1xxResponseFunc(cs.trace)</code></span>
<span class="codeline" id="line-7474"><code>}</code></span>
<span class="codeline" id="line-7475"><code></code></span>
<span class="codeline" id="line-7476"><code>func (cs *http2clientStream) abortStream(err error) {</code></span>
<span class="codeline" id="line-7477"><code>	cs.cc.mu.Lock()</code></span>
<span class="codeline" id="line-7478"><code>	defer cs.cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7479"><code>	cs.abortStreamLocked(err)</code></span>
<span class="codeline" id="line-7480"><code>}</code></span>
<span class="codeline" id="line-7481"><code></code></span>
<span class="codeline" id="line-7482"><code>func (cs *http2clientStream) abortStreamLocked(err error) {</code></span>
<span class="codeline" id="line-7483"><code>	cs.abortOnce.Do(func() {</code></span>
<span class="codeline" id="line-7484"><code>		cs.abortErr = err</code></span>
<span class="codeline" id="line-7485"><code>		close(cs.abort)</code></span>
<span class="codeline" id="line-7486"><code>	})</code></span>
<span class="codeline" id="line-7487"><code>	if cs.reqBody != nil {</code></span>
<span class="codeline" id="line-7488"><code>		cs.closeReqBodyLocked()</code></span>
<span class="codeline" id="line-7489"><code>	}</code></span>
<span class="codeline" id="line-7490"><code>	// TODO(dneil): Clean up tests where cs.cc.cond is nil.</code></span>
<span class="codeline" id="line-7491"><code>	if cs.cc.cond != nil {</code></span>
<span class="codeline" id="line-7492"><code>		// Wake up writeRequestBody if it is waiting on flow control.</code></span>
<span class="codeline" id="line-7493"><code>		cs.cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-7494"><code>	}</code></span>
<span class="codeline" id="line-7495"><code>}</code></span>
<span class="codeline" id="line-7496"><code></code></span>
<span class="codeline" id="line-7497"><code>func (cs *http2clientStream) abortRequestBodyWrite() {</code></span>
<span class="codeline" id="line-7498"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-7499"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-7500"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7501"><code>	if cs.reqBody != nil &amp;&amp; cs.reqBodyClosed == nil {</code></span>
<span class="codeline" id="line-7502"><code>		cs.closeReqBodyLocked()</code></span>
<span class="codeline" id="line-7503"><code>		cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-7504"><code>	}</code></span>
<span class="codeline" id="line-7505"><code>}</code></span>
<span class="codeline" id="line-7506"><code></code></span>
<span class="codeline" id="line-7507"><code>func (cs *http2clientStream) closeReqBodyLocked() {</code></span>
<span class="codeline" id="line-7508"><code>	if cs.reqBodyClosed != nil {</code></span>
<span class="codeline" id="line-7509"><code>		return</code></span>
<span class="codeline" id="line-7510"><code>	}</code></span>
<span class="codeline" id="line-7511"><code>	cs.reqBodyClosed = make(chan struct{})</code></span>
<span class="codeline" id="line-7512"><code>	reqBodyClosed := cs.reqBodyClosed</code></span>
<span class="codeline" id="line-7513"><code>	go func() {</code></span>
<span class="codeline" id="line-7514"><code>		cs.reqBody.Close()</code></span>
<span class="codeline" id="line-7515"><code>		close(reqBodyClosed)</code></span>
<span class="codeline" id="line-7516"><code>	}()</code></span>
<span class="codeline" id="line-7517"><code>}</code></span>
<span class="codeline" id="line-7518"><code></code></span>
<span class="codeline" id="line-7519"><code>type http2stickyErrWriter struct {</code></span>
<span class="codeline" id="line-7520"><code>	conn    net.Conn</code></span>
<span class="codeline" id="line-7521"><code>	timeout time.Duration</code></span>
<span class="codeline" id="line-7522"><code>	err     *error</code></span>
<span class="codeline" id="line-7523"><code>}</code></span>
<span class="codeline" id="line-7524"><code></code></span>
<span class="codeline" id="line-7525"><code>func (sew http2stickyErrWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-7526"><code>	if *sew.err != nil {</code></span>
<span class="codeline" id="line-7527"><code>		return 0, *sew.err</code></span>
<span class="codeline" id="line-7528"><code>	}</code></span>
<span class="codeline" id="line-7529"><code>	for {</code></span>
<span class="codeline" id="line-7530"><code>		if sew.timeout != 0 {</code></span>
<span class="codeline" id="line-7531"><code>			sew.conn.SetWriteDeadline(time.Now().Add(sew.timeout))</code></span>
<span class="codeline" id="line-7532"><code>		}</code></span>
<span class="codeline" id="line-7533"><code>		nn, err := sew.conn.Write(p[n:])</code></span>
<span class="codeline" id="line-7534"><code>		n += nn</code></span>
<span class="codeline" id="line-7535"><code>		if n &lt; len(p) &amp;&amp; nn &gt; 0 &amp;&amp; errors.Is(err, os.ErrDeadlineExceeded) {</code></span>
<span class="codeline" id="line-7536"><code>			// Keep extending the deadline so long as we're making progress.</code></span>
<span class="codeline" id="line-7537"><code>			continue</code></span>
<span class="codeline" id="line-7538"><code>		}</code></span>
<span class="codeline" id="line-7539"><code>		if sew.timeout != 0 {</code></span>
<span class="codeline" id="line-7540"><code>			sew.conn.SetWriteDeadline(time.Time{})</code></span>
<span class="codeline" id="line-7541"><code>		}</code></span>
<span class="codeline" id="line-7542"><code>		*sew.err = err</code></span>
<span class="codeline" id="line-7543"><code>		return n, err</code></span>
<span class="codeline" id="line-7544"><code>	}</code></span>
<span class="codeline" id="line-7545"><code>}</code></span>
<span class="codeline" id="line-7546"><code></code></span>
<span class="codeline" id="line-7547"><code>// noCachedConnError is the concrete type of ErrNoCachedConn, which</code></span>
<span class="codeline" id="line-7548"><code>// needs to be detected by net/http regardless of whether it's its</code></span>
<span class="codeline" id="line-7549"><code>// bundled version (in h2_bundle.go with a rewritten type name) or</code></span>
<span class="codeline" id="line-7550"><code>// from a user's x/net/http2. As such, as it has a unique method name</code></span>
<span class="codeline" id="line-7551"><code>// (IsHTTP2NoCachedConnError) that net/http sniffs for via func</code></span>
<span class="codeline" id="line-7552"><code>// isNoCachedConnError.</code></span>
<span class="codeline" id="line-7553"><code>type http2noCachedConnError struct{}</code></span>
<span class="codeline" id="line-7554"><code></code></span>
<span class="codeline" id="line-7555"><code>func (http2noCachedConnError) IsHTTP2NoCachedConnError() {}</code></span>
<span class="codeline" id="line-7556"><code></code></span>
<span class="codeline" id="line-7557"><code>func (http2noCachedConnError) Error() string { return "http2: no cached connection was available" }</code></span>
<span class="codeline" id="line-7558"><code></code></span>
<span class="codeline" id="line-7559"><code>// isNoCachedConnError reports whether err is of type noCachedConnError</code></span>
<span class="codeline" id="line-7560"><code>// or its equivalent renamed type in net/http2's h2_bundle.go. Both types</code></span>
<span class="codeline" id="line-7561"><code>// may coexist in the same running program.</code></span>
<span class="codeline" id="line-7562"><code>func http2isNoCachedConnError(err error) bool {</code></span>
<span class="codeline" id="line-7563"><code>	_, ok := err.(interface{ IsHTTP2NoCachedConnError() })</code></span>
<span class="codeline" id="line-7564"><code>	return ok</code></span>
<span class="codeline" id="line-7565"><code>}</code></span>
<span class="codeline" id="line-7566"><code></code></span>
<span class="codeline" id="line-7567"><code>var http2ErrNoCachedConn error = http2noCachedConnError{}</code></span>
<span class="codeline" id="line-7568"><code></code></span>
<span class="codeline" id="line-7569"><code>// RoundTripOpt are options for the Transport.RoundTripOpt method.</code></span>
<span class="codeline" id="line-7570"><code>type http2RoundTripOpt struct {</code></span>
<span class="codeline" id="line-7571"><code>	// OnlyCachedConn controls whether RoundTripOpt may</code></span>
<span class="codeline" id="line-7572"><code>	// create a new TCP connection. If set true and</code></span>
<span class="codeline" id="line-7573"><code>	// no cached connection is available, RoundTripOpt</code></span>
<span class="codeline" id="line-7574"><code>	// will return ErrNoCachedConn.</code></span>
<span class="codeline" id="line-7575"><code>	OnlyCachedConn bool</code></span>
<span class="codeline" id="line-7576"><code>}</code></span>
<span class="codeline" id="line-7577"><code></code></span>
<span class="codeline" id="line-7578"><code>func (t *http2Transport) RoundTrip(req *Request) (*Response, error) {</code></span>
<span class="codeline" id="line-7579"><code>	return t.RoundTripOpt(req, http2RoundTripOpt{})</code></span>
<span class="codeline" id="line-7580"><code>}</code></span>
<span class="codeline" id="line-7581"><code></code></span>
<span class="codeline" id="line-7582"><code>// authorityAddr returns a given authority (a host/IP, or host:port / ip:port)</code></span>
<span class="codeline" id="line-7583"><code>// and returns a host:port. The port 443 is added if needed.</code></span>
<span class="codeline" id="line-7584"><code>func http2authorityAddr(scheme string, authority string) (addr string) {</code></span>
<span class="codeline" id="line-7585"><code>	host, port, err := net.SplitHostPort(authority)</code></span>
<span class="codeline" id="line-7586"><code>	if err != nil { // authority didn't have a port</code></span>
<span class="codeline" id="line-7587"><code>		host = authority</code></span>
<span class="codeline" id="line-7588"><code>		port = ""</code></span>
<span class="codeline" id="line-7589"><code>	}</code></span>
<span class="codeline" id="line-7590"><code>	if port == "" { // authority's port was empty</code></span>
<span class="codeline" id="line-7591"><code>		port = "443"</code></span>
<span class="codeline" id="line-7592"><code>		if scheme == "http" {</code></span>
<span class="codeline" id="line-7593"><code>			port = "80"</code></span>
<span class="codeline" id="line-7594"><code>		}</code></span>
<span class="codeline" id="line-7595"><code>	}</code></span>
<span class="codeline" id="line-7596"><code>	if a, err := idna.ToASCII(host); err == nil {</code></span>
<span class="codeline" id="line-7597"><code>		host = a</code></span>
<span class="codeline" id="line-7598"><code>	}</code></span>
<span class="codeline" id="line-7599"><code>	// IPv6 address literal, without a port:</code></span>
<span class="codeline" id="line-7600"><code>	if strings.HasPrefix(host, "[") &amp;&amp; strings.HasSuffix(host, "]") {</code></span>
<span class="codeline" id="line-7601"><code>		return host + ":" + port</code></span>
<span class="codeline" id="line-7602"><code>	}</code></span>
<span class="codeline" id="line-7603"><code>	return net.JoinHostPort(host, port)</code></span>
<span class="codeline" id="line-7604"><code>}</code></span>
<span class="codeline" id="line-7605"><code></code></span>
<span class="codeline" id="line-7606"><code>var http2retryBackoffHook func(time.Duration) *time.Timer</code></span>
<span class="codeline" id="line-7607"><code></code></span>
<span class="codeline" id="line-7608"><code>func http2backoffNewTimer(d time.Duration) *time.Timer {</code></span>
<span class="codeline" id="line-7609"><code>	if http2retryBackoffHook != nil {</code></span>
<span class="codeline" id="line-7610"><code>		return http2retryBackoffHook(d)</code></span>
<span class="codeline" id="line-7611"><code>	}</code></span>
<span class="codeline" id="line-7612"><code>	return time.NewTimer(d)</code></span>
<span class="codeline" id="line-7613"><code>}</code></span>
<span class="codeline" id="line-7614"><code></code></span>
<span class="codeline" id="line-7615"><code>// RoundTripOpt is like RoundTrip, but takes options.</code></span>
<span class="codeline" id="line-7616"><code>func (t *http2Transport) RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error) {</code></span>
<span class="codeline" id="line-7617"><code>	if !(req.URL.Scheme == "https" || (req.URL.Scheme == "http" &amp;&amp; t.AllowHTTP)) {</code></span>
<span class="codeline" id="line-7618"><code>		return nil, errors.New("http2: unsupported scheme")</code></span>
<span class="codeline" id="line-7619"><code>	}</code></span>
<span class="codeline" id="line-7620"><code></code></span>
<span class="codeline" id="line-7621"><code>	addr := http2authorityAddr(req.URL.Scheme, req.URL.Host)</code></span>
<span class="codeline" id="line-7622"><code>	for retry := 0; ; retry++ {</code></span>
<span class="codeline" id="line-7623"><code>		cc, err := t.connPool().GetClientConn(req, addr)</code></span>
<span class="codeline" id="line-7624"><code>		if err != nil {</code></span>
<span class="codeline" id="line-7625"><code>			t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err)</code></span>
<span class="codeline" id="line-7626"><code>			return nil, err</code></span>
<span class="codeline" id="line-7627"><code>		}</code></span>
<span class="codeline" id="line-7628"><code>		reused := !atomic.CompareAndSwapUint32(&amp;cc.reused, 0, 1)</code></span>
<span class="codeline" id="line-7629"><code>		http2traceGotConn(req, cc, reused)</code></span>
<span class="codeline" id="line-7630"><code>		res, err := cc.RoundTrip(req)</code></span>
<span class="codeline" id="line-7631"><code>		if err != nil &amp;&amp; retry &lt;= 6 {</code></span>
<span class="codeline" id="line-7632"><code>			roundTripErr := err</code></span>
<span class="codeline" id="line-7633"><code>			if req, err = http2shouldRetryRequest(req, err); err == nil {</code></span>
<span class="codeline" id="line-7634"><code>				// After the first retry, do exponential backoff with 10% jitter.</code></span>
<span class="codeline" id="line-7635"><code>				if retry == 0 {</code></span>
<span class="codeline" id="line-7636"><code>					t.vlogf("RoundTrip retrying after failure: %v", roundTripErr)</code></span>
<span class="codeline" id="line-7637"><code>					continue</code></span>
<span class="codeline" id="line-7638"><code>				}</code></span>
<span class="codeline" id="line-7639"><code>				backoff := float64(uint(1) &lt;&lt; (uint(retry) - 1))</code></span>
<span class="codeline" id="line-7640"><code>				backoff += backoff * (0.1 * mathrand.Float64())</code></span>
<span class="codeline" id="line-7641"><code>				d := time.Second * time.Duration(backoff)</code></span>
<span class="codeline" id="line-7642"><code>				timer := http2backoffNewTimer(d)</code></span>
<span class="codeline" id="line-7643"><code>				select {</code></span>
<span class="codeline" id="line-7644"><code>				case &lt;-timer.C:</code></span>
<span class="codeline" id="line-7645"><code>					t.vlogf("RoundTrip retrying after failure: %v", roundTripErr)</code></span>
<span class="codeline" id="line-7646"><code>					continue</code></span>
<span class="codeline" id="line-7647"><code>				case &lt;-req.Context().Done():</code></span>
<span class="codeline" id="line-7648"><code>					timer.Stop()</code></span>
<span class="codeline" id="line-7649"><code>					err = req.Context().Err()</code></span>
<span class="codeline" id="line-7650"><code>				}</code></span>
<span class="codeline" id="line-7651"><code>			}</code></span>
<span class="codeline" id="line-7652"><code>		}</code></span>
<span class="codeline" id="line-7653"><code>		if err != nil {</code></span>
<span class="codeline" id="line-7654"><code>			t.vlogf("RoundTrip failure: %v", err)</code></span>
<span class="codeline" id="line-7655"><code>			return nil, err</code></span>
<span class="codeline" id="line-7656"><code>		}</code></span>
<span class="codeline" id="line-7657"><code>		return res, nil</code></span>
<span class="codeline" id="line-7658"><code>	}</code></span>
<span class="codeline" id="line-7659"><code>}</code></span>
<span class="codeline" id="line-7660"><code></code></span>
<span class="codeline" id="line-7661"><code>// CloseIdleConnections closes any connections which were previously</code></span>
<span class="codeline" id="line-7662"><code>// connected from previous requests but are now sitting idle.</code></span>
<span class="codeline" id="line-7663"><code>// It does not interrupt any connections currently in use.</code></span>
<span class="codeline" id="line-7664"><code>func (t *http2Transport) CloseIdleConnections() {</code></span>
<span class="codeline" id="line-7665"><code>	if cp, ok := t.connPool().(http2clientConnPoolIdleCloser); ok {</code></span>
<span class="codeline" id="line-7666"><code>		cp.closeIdleConnections()</code></span>
<span class="codeline" id="line-7667"><code>	}</code></span>
<span class="codeline" id="line-7668"><code>}</code></span>
<span class="codeline" id="line-7669"><code></code></span>
<span class="codeline" id="line-7670"><code>var (</code></span>
<span class="codeline" id="line-7671"><code>	http2errClientConnClosed    = errors.New("http2: client conn is closed")</code></span>
<span class="codeline" id="line-7672"><code>	http2errClientConnUnusable  = errors.New("http2: client conn not usable")</code></span>
<span class="codeline" id="line-7673"><code>	http2errClientConnGotGoAway = errors.New("http2: Transport received Server's graceful shutdown GOAWAY")</code></span>
<span class="codeline" id="line-7674"><code>)</code></span>
<span class="codeline" id="line-7675"><code></code></span>
<span class="codeline" id="line-7676"><code>// shouldRetryRequest is called by RoundTrip when a request fails to get</code></span>
<span class="codeline" id="line-7677"><code>// response headers. It is always called with a non-nil error.</code></span>
<span class="codeline" id="line-7678"><code>// It returns either a request to retry (either the same request, or a</code></span>
<span class="codeline" id="line-7679"><code>// modified clone), or an error if the request can't be replayed.</code></span>
<span class="codeline" id="line-7680"><code>func http2shouldRetryRequest(req *Request, err error) (*Request, error) {</code></span>
<span class="codeline" id="line-7681"><code>	if !http2canRetryError(err) {</code></span>
<span class="codeline" id="line-7682"><code>		return nil, err</code></span>
<span class="codeline" id="line-7683"><code>	}</code></span>
<span class="codeline" id="line-7684"><code>	// If the Body is nil (or http.NoBody), it's safe to reuse</code></span>
<span class="codeline" id="line-7685"><code>	// this request and its Body.</code></span>
<span class="codeline" id="line-7686"><code>	if req.Body == nil || req.Body == NoBody {</code></span>
<span class="codeline" id="line-7687"><code>		return req, nil</code></span>
<span class="codeline" id="line-7688"><code>	}</code></span>
<span class="codeline" id="line-7689"><code></code></span>
<span class="codeline" id="line-7690"><code>	// If the request body can be reset back to its original</code></span>
<span class="codeline" id="line-7691"><code>	// state via the optional req.GetBody, do that.</code></span>
<span class="codeline" id="line-7692"><code>	if req.GetBody != nil {</code></span>
<span class="codeline" id="line-7693"><code>		body, err := req.GetBody()</code></span>
<span class="codeline" id="line-7694"><code>		if err != nil {</code></span>
<span class="codeline" id="line-7695"><code>			return nil, err</code></span>
<span class="codeline" id="line-7696"><code>		}</code></span>
<span class="codeline" id="line-7697"><code>		newReq := *req</code></span>
<span class="codeline" id="line-7698"><code>		newReq.Body = body</code></span>
<span class="codeline" id="line-7699"><code>		return &amp;newReq, nil</code></span>
<span class="codeline" id="line-7700"><code>	}</code></span>
<span class="codeline" id="line-7701"><code></code></span>
<span class="codeline" id="line-7702"><code>	// The Request.Body can't reset back to the beginning, but we</code></span>
<span class="codeline" id="line-7703"><code>	// don't seem to have started to read from it yet, so reuse</code></span>
<span class="codeline" id="line-7704"><code>	// the request directly.</code></span>
<span class="codeline" id="line-7705"><code>	if err == http2errClientConnUnusable {</code></span>
<span class="codeline" id="line-7706"><code>		return req, nil</code></span>
<span class="codeline" id="line-7707"><code>	}</code></span>
<span class="codeline" id="line-7708"><code></code></span>
<span class="codeline" id="line-7709"><code>	return nil, fmt.Errorf("http2: Transport: cannot retry err [%v] after Request.Body was written; define Request.GetBody to avoid this error", err)</code></span>
<span class="codeline" id="line-7710"><code>}</code></span>
<span class="codeline" id="line-7711"><code></code></span>
<span class="codeline" id="line-7712"><code>func http2canRetryError(err error) bool {</code></span>
<span class="codeline" id="line-7713"><code>	if err == http2errClientConnUnusable || err == http2errClientConnGotGoAway {</code></span>
<span class="codeline" id="line-7714"><code>		return true</code></span>
<span class="codeline" id="line-7715"><code>	}</code></span>
<span class="codeline" id="line-7716"><code>	if se, ok := err.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-7717"><code>		if se.Code == http2ErrCodeProtocol &amp;&amp; se.Cause == http2errFromPeer {</code></span>
<span class="codeline" id="line-7718"><code>			// See golang/go#47635, golang/go#42777</code></span>
<span class="codeline" id="line-7719"><code>			return true</code></span>
<span class="codeline" id="line-7720"><code>		}</code></span>
<span class="codeline" id="line-7721"><code>		return se.Code == http2ErrCodeRefusedStream</code></span>
<span class="codeline" id="line-7722"><code>	}</code></span>
<span class="codeline" id="line-7723"><code>	return false</code></span>
<span class="codeline" id="line-7724"><code>}</code></span>
<span class="codeline" id="line-7725"><code></code></span>
<span class="codeline" id="line-7726"><code>func (t *http2Transport) dialClientConn(ctx context.Context, addr string, singleUse bool) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-7727"><code>	host, _, err := net.SplitHostPort(addr)</code></span>
<span class="codeline" id="line-7728"><code>	if err != nil {</code></span>
<span class="codeline" id="line-7729"><code>		return nil, err</code></span>
<span class="codeline" id="line-7730"><code>	}</code></span>
<span class="codeline" id="line-7731"><code>	tconn, err := t.dialTLS(ctx, "tcp", addr, t.newTLSConfig(host))</code></span>
<span class="codeline" id="line-7732"><code>	if err != nil {</code></span>
<span class="codeline" id="line-7733"><code>		return nil, err</code></span>
<span class="codeline" id="line-7734"><code>	}</code></span>
<span class="codeline" id="line-7735"><code>	return t.newClientConn(tconn, singleUse)</code></span>
<span class="codeline" id="line-7736"><code>}</code></span>
<span class="codeline" id="line-7737"><code></code></span>
<span class="codeline" id="line-7738"><code>func (t *http2Transport) newTLSConfig(host string) *tls.Config {</code></span>
<span class="codeline" id="line-7739"><code>	cfg := new(tls.Config)</code></span>
<span class="codeline" id="line-7740"><code>	if t.TLSClientConfig != nil {</code></span>
<span class="codeline" id="line-7741"><code>		*cfg = *t.TLSClientConfig.Clone()</code></span>
<span class="codeline" id="line-7742"><code>	}</code></span>
<span class="codeline" id="line-7743"><code>	if !http2strSliceContains(cfg.NextProtos, http2NextProtoTLS) {</code></span>
<span class="codeline" id="line-7744"><code>		cfg.NextProtos = append([]string{http2NextProtoTLS}, cfg.NextProtos...)</code></span>
<span class="codeline" id="line-7745"><code>	}</code></span>
<span class="codeline" id="line-7746"><code>	if cfg.ServerName == "" {</code></span>
<span class="codeline" id="line-7747"><code>		cfg.ServerName = host</code></span>
<span class="codeline" id="line-7748"><code>	}</code></span>
<span class="codeline" id="line-7749"><code>	return cfg</code></span>
<span class="codeline" id="line-7750"><code>}</code></span>
<span class="codeline" id="line-7751"><code></code></span>
<span class="codeline" id="line-7752"><code>func (t *http2Transport) dialTLS(ctx context.Context, network, addr string, tlsCfg *tls.Config) (net.Conn, error) {</code></span>
<span class="codeline" id="line-7753"><code>	if t.DialTLSContext != nil {</code></span>
<span class="codeline" id="line-7754"><code>		return t.DialTLSContext(ctx, network, addr, tlsCfg)</code></span>
<span class="codeline" id="line-7755"><code>	} else if t.DialTLS != nil {</code></span>
<span class="codeline" id="line-7756"><code>		return t.DialTLS(network, addr, tlsCfg)</code></span>
<span class="codeline" id="line-7757"><code>	}</code></span>
<span class="codeline" id="line-7758"><code></code></span>
<span class="codeline" id="line-7759"><code>	tlsCn, err := t.dialTLSWithContext(ctx, network, addr, tlsCfg)</code></span>
<span class="codeline" id="line-7760"><code>	if err != nil {</code></span>
<span class="codeline" id="line-7761"><code>		return nil, err</code></span>
<span class="codeline" id="line-7762"><code>	}</code></span>
<span class="codeline" id="line-7763"><code>	state := tlsCn.ConnectionState()</code></span>
<span class="codeline" id="line-7764"><code>	if p := state.NegotiatedProtocol; p != http2NextProtoTLS {</code></span>
<span class="codeline" id="line-7765"><code>		return nil, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, http2NextProtoTLS)</code></span>
<span class="codeline" id="line-7766"><code>	}</code></span>
<span class="codeline" id="line-7767"><code>	if !state.NegotiatedProtocolIsMutual {</code></span>
<span class="codeline" id="line-7768"><code>		return nil, errors.New("http2: could not negotiate protocol mutually")</code></span>
<span class="codeline" id="line-7769"><code>	}</code></span>
<span class="codeline" id="line-7770"><code>	return tlsCn, nil</code></span>
<span class="codeline" id="line-7771"><code>}</code></span>
<span class="codeline" id="line-7772"><code></code></span>
<span class="codeline" id="line-7773"><code>// disableKeepAlives reports whether connections should be closed as</code></span>
<span class="codeline" id="line-7774"><code>// soon as possible after handling the first request.</code></span>
<span class="codeline" id="line-7775"><code>func (t *http2Transport) disableKeepAlives() bool {</code></span>
<span class="codeline" id="line-7776"><code>	return t.t1 != nil &amp;&amp; t.t1.DisableKeepAlives</code></span>
<span class="codeline" id="line-7777"><code>}</code></span>
<span class="codeline" id="line-7778"><code></code></span>
<span class="codeline" id="line-7779"><code>func (t *http2Transport) expectContinueTimeout() time.Duration {</code></span>
<span class="codeline" id="line-7780"><code>	if t.t1 == nil {</code></span>
<span class="codeline" id="line-7781"><code>		return 0</code></span>
<span class="codeline" id="line-7782"><code>	}</code></span>
<span class="codeline" id="line-7783"><code>	return t.t1.ExpectContinueTimeout</code></span>
<span class="codeline" id="line-7784"><code>}</code></span>
<span class="codeline" id="line-7785"><code></code></span>
<span class="codeline" id="line-7786"><code>func (t *http2Transport) maxDecoderHeaderTableSize() uint32 {</code></span>
<span class="codeline" id="line-7787"><code>	if v := t.MaxDecoderHeaderTableSize; v &gt; 0 {</code></span>
<span class="codeline" id="line-7788"><code>		return v</code></span>
<span class="codeline" id="line-7789"><code>	}</code></span>
<span class="codeline" id="line-7790"><code>	return http2initialHeaderTableSize</code></span>
<span class="codeline" id="line-7791"><code>}</code></span>
<span class="codeline" id="line-7792"><code></code></span>
<span class="codeline" id="line-7793"><code>func (t *http2Transport) maxEncoderHeaderTableSize() uint32 {</code></span>
<span class="codeline" id="line-7794"><code>	if v := t.MaxEncoderHeaderTableSize; v &gt; 0 {</code></span>
<span class="codeline" id="line-7795"><code>		return v</code></span>
<span class="codeline" id="line-7796"><code>	}</code></span>
<span class="codeline" id="line-7797"><code>	return http2initialHeaderTableSize</code></span>
<span class="codeline" id="line-7798"><code>}</code></span>
<span class="codeline" id="line-7799"><code></code></span>
<span class="codeline" id="line-7800"><code>func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-7801"><code>	return t.newClientConn(c, t.disableKeepAlives())</code></span>
<span class="codeline" id="line-7802"><code>}</code></span>
<span class="codeline" id="line-7803"><code></code></span>
<span class="codeline" id="line-7804"><code>func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error) {</code></span>
<span class="codeline" id="line-7805"><code>	cc := &amp;http2ClientConn{</code></span>
<span class="codeline" id="line-7806"><code>		t:                     t,</code></span>
<span class="codeline" id="line-7807"><code>		tconn:                 c,</code></span>
<span class="codeline" id="line-7808"><code>		readerDone:            make(chan struct{}),</code></span>
<span class="codeline" id="line-7809"><code>		nextStreamID:          1,</code></span>
<span class="codeline" id="line-7810"><code>		maxFrameSize:          16 &lt;&lt; 10,                         // spec default</code></span>
<span class="codeline" id="line-7811"><code>		initialWindowSize:     65535,                            // spec default</code></span>
<span class="codeline" id="line-7812"><code>		maxConcurrentStreams:  http2initialMaxConcurrentStreams, // "infinite", per spec. Use a smaller value until we have received server settings.</code></span>
<span class="codeline" id="line-7813"><code>		peerMaxHeaderListSize: 0xffffffffffffffff,               // "infinite", per spec. Use 2^64-1 instead.</code></span>
<span class="codeline" id="line-7814"><code>		streams:               make(map[uint32]*http2clientStream),</code></span>
<span class="codeline" id="line-7815"><code>		singleUse:             singleUse,</code></span>
<span class="codeline" id="line-7816"><code>		wantSettingsAck:       true,</code></span>
<span class="codeline" id="line-7817"><code>		pings:                 make(map[[8]byte]chan struct{}),</code></span>
<span class="codeline" id="line-7818"><code>		reqHeaderMu:           make(chan struct{}, 1),</code></span>
<span class="codeline" id="line-7819"><code>	}</code></span>
<span class="codeline" id="line-7820"><code>	if d := t.idleConnTimeout(); d != 0 {</code></span>
<span class="codeline" id="line-7821"><code>		cc.idleTimeout = d</code></span>
<span class="codeline" id="line-7822"><code>		cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)</code></span>
<span class="codeline" id="line-7823"><code>	}</code></span>
<span class="codeline" id="line-7824"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-7825"><code>		t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr())</code></span>
<span class="codeline" id="line-7826"><code>	}</code></span>
<span class="codeline" id="line-7827"><code></code></span>
<span class="codeline" id="line-7828"><code>	cc.cond = sync.NewCond(&amp;cc.mu)</code></span>
<span class="codeline" id="line-7829"><code>	cc.flow.add(int32(http2initialWindowSize))</code></span>
<span class="codeline" id="line-7830"><code></code></span>
<span class="codeline" id="line-7831"><code>	// TODO: adjust this writer size to account for frame size +</code></span>
<span class="codeline" id="line-7832"><code>	// MTU + crypto/tls record padding.</code></span>
<span class="codeline" id="line-7833"><code>	cc.bw = bufio.NewWriter(http2stickyErrWriter{</code></span>
<span class="codeline" id="line-7834"><code>		conn:    c,</code></span>
<span class="codeline" id="line-7835"><code>		timeout: t.WriteByteTimeout,</code></span>
<span class="codeline" id="line-7836"><code>		err:     &amp;cc.werr,</code></span>
<span class="codeline" id="line-7837"><code>	})</code></span>
<span class="codeline" id="line-7838"><code>	cc.br = bufio.NewReader(c)</code></span>
<span class="codeline" id="line-7839"><code>	cc.fr = http2NewFramer(cc.bw, cc.br)</code></span>
<span class="codeline" id="line-7840"><code>	if t.maxFrameReadSize() != 0 {</code></span>
<span class="codeline" id="line-7841"><code>		cc.fr.SetMaxReadFrameSize(t.maxFrameReadSize())</code></span>
<span class="codeline" id="line-7842"><code>	}</code></span>
<span class="codeline" id="line-7843"><code>	if t.CountError != nil {</code></span>
<span class="codeline" id="line-7844"><code>		cc.fr.countError = t.CountError</code></span>
<span class="codeline" id="line-7845"><code>	}</code></span>
<span class="codeline" id="line-7846"><code>	maxHeaderTableSize := t.maxDecoderHeaderTableSize()</code></span>
<span class="codeline" id="line-7847"><code>	cc.fr.ReadMetaHeaders = hpack.NewDecoder(maxHeaderTableSize, nil)</code></span>
<span class="codeline" id="line-7848"><code>	cc.fr.MaxHeaderListSize = t.maxHeaderListSize()</code></span>
<span class="codeline" id="line-7849"><code></code></span>
<span class="codeline" id="line-7850"><code>	cc.henc = hpack.NewEncoder(&amp;cc.hbuf)</code></span>
<span class="codeline" id="line-7851"><code>	cc.henc.SetMaxDynamicTableSizeLimit(t.maxEncoderHeaderTableSize())</code></span>
<span class="codeline" id="line-7852"><code>	cc.peerMaxHeaderTableSize = http2initialHeaderTableSize</code></span>
<span class="codeline" id="line-7853"><code></code></span>
<span class="codeline" id="line-7854"><code>	if t.AllowHTTP {</code></span>
<span class="codeline" id="line-7855"><code>		cc.nextStreamID = 3</code></span>
<span class="codeline" id="line-7856"><code>	}</code></span>
<span class="codeline" id="line-7857"><code></code></span>
<span class="codeline" id="line-7858"><code>	if cs, ok := c.(http2connectionStater); ok {</code></span>
<span class="codeline" id="line-7859"><code>		state := cs.ConnectionState()</code></span>
<span class="codeline" id="line-7860"><code>		cc.tlsState = &amp;state</code></span>
<span class="codeline" id="line-7861"><code>	}</code></span>
<span class="codeline" id="line-7862"><code></code></span>
<span class="codeline" id="line-7863"><code>	initialSettings := []http2Setting{</code></span>
<span class="codeline" id="line-7864"><code>		{ID: http2SettingEnablePush, Val: 0},</code></span>
<span class="codeline" id="line-7865"><code>		{ID: http2SettingInitialWindowSize, Val: http2transportDefaultStreamFlow},</code></span>
<span class="codeline" id="line-7866"><code>	}</code></span>
<span class="codeline" id="line-7867"><code>	if max := t.maxFrameReadSize(); max != 0 {</code></span>
<span class="codeline" id="line-7868"><code>		initialSettings = append(initialSettings, http2Setting{ID: http2SettingMaxFrameSize, Val: max})</code></span>
<span class="codeline" id="line-7869"><code>	}</code></span>
<span class="codeline" id="line-7870"><code>	if max := t.maxHeaderListSize(); max != 0 {</code></span>
<span class="codeline" id="line-7871"><code>		initialSettings = append(initialSettings, http2Setting{ID: http2SettingMaxHeaderListSize, Val: max})</code></span>
<span class="codeline" id="line-7872"><code>	}</code></span>
<span class="codeline" id="line-7873"><code>	if maxHeaderTableSize != http2initialHeaderTableSize {</code></span>
<span class="codeline" id="line-7874"><code>		initialSettings = append(initialSettings, http2Setting{ID: http2SettingHeaderTableSize, Val: maxHeaderTableSize})</code></span>
<span class="codeline" id="line-7875"><code>	}</code></span>
<span class="codeline" id="line-7876"><code></code></span>
<span class="codeline" id="line-7877"><code>	cc.bw.Write(http2clientPreface)</code></span>
<span class="codeline" id="line-7878"><code>	cc.fr.WriteSettings(initialSettings...)</code></span>
<span class="codeline" id="line-7879"><code>	cc.fr.WriteWindowUpdate(0, http2transportDefaultConnFlow)</code></span>
<span class="codeline" id="line-7880"><code>	cc.inflow.init(http2transportDefaultConnFlow + http2initialWindowSize)</code></span>
<span class="codeline" id="line-7881"><code>	cc.bw.Flush()</code></span>
<span class="codeline" id="line-7882"><code>	if cc.werr != nil {</code></span>
<span class="codeline" id="line-7883"><code>		cc.Close()</code></span>
<span class="codeline" id="line-7884"><code>		return nil, cc.werr</code></span>
<span class="codeline" id="line-7885"><code>	}</code></span>
<span class="codeline" id="line-7886"><code></code></span>
<span class="codeline" id="line-7887"><code>	go cc.readLoop()</code></span>
<span class="codeline" id="line-7888"><code>	return cc, nil</code></span>
<span class="codeline" id="line-7889"><code>}</code></span>
<span class="codeline" id="line-7890"><code></code></span>
<span class="codeline" id="line-7891"><code>func (cc *http2ClientConn) healthCheck() {</code></span>
<span class="codeline" id="line-7892"><code>	pingTimeout := cc.t.pingTimeout()</code></span>
<span class="codeline" id="line-7893"><code>	// We don't need to periodically ping in the health check, because the readLoop of ClientConn will</code></span>
<span class="codeline" id="line-7894"><code>	// trigger the healthCheck again if there is no frame received.</code></span>
<span class="codeline" id="line-7895"><code>	ctx, cancel := context.WithTimeout(context.Background(), pingTimeout)</code></span>
<span class="codeline" id="line-7896"><code>	defer cancel()</code></span>
<span class="codeline" id="line-7897"><code>	cc.vlogf("http2: Transport sending health check")</code></span>
<span class="codeline" id="line-7898"><code>	err := cc.Ping(ctx)</code></span>
<span class="codeline" id="line-7899"><code>	if err != nil {</code></span>
<span class="codeline" id="line-7900"><code>		cc.vlogf("http2: Transport health check failure: %v", err)</code></span>
<span class="codeline" id="line-7901"><code>		cc.closeForLostPing()</code></span>
<span class="codeline" id="line-7902"><code>	} else {</code></span>
<span class="codeline" id="line-7903"><code>		cc.vlogf("http2: Transport health check success")</code></span>
<span class="codeline" id="line-7904"><code>	}</code></span>
<span class="codeline" id="line-7905"><code>}</code></span>
<span class="codeline" id="line-7906"><code></code></span>
<span class="codeline" id="line-7907"><code>// SetDoNotReuse marks cc as not reusable for future HTTP requests.</code></span>
<span class="codeline" id="line-7908"><code>func (cc *http2ClientConn) SetDoNotReuse() {</code></span>
<span class="codeline" id="line-7909"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-7910"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7911"><code>	cc.doNotReuse = true</code></span>
<span class="codeline" id="line-7912"><code>}</code></span>
<span class="codeline" id="line-7913"><code></code></span>
<span class="codeline" id="line-7914"><code>func (cc *http2ClientConn) setGoAway(f *http2GoAwayFrame) {</code></span>
<span class="codeline" id="line-7915"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-7916"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7917"><code></code></span>
<span class="codeline" id="line-7918"><code>	old := cc.goAway</code></span>
<span class="codeline" id="line-7919"><code>	cc.goAway = f</code></span>
<span class="codeline" id="line-7920"><code></code></span>
<span class="codeline" id="line-7921"><code>	// Merge the previous and current GoAway error frames.</code></span>
<span class="codeline" id="line-7922"><code>	if cc.goAwayDebug == "" {</code></span>
<span class="codeline" id="line-7923"><code>		cc.goAwayDebug = string(f.DebugData())</code></span>
<span class="codeline" id="line-7924"><code>	}</code></span>
<span class="codeline" id="line-7925"><code>	if old != nil &amp;&amp; old.ErrCode != http2ErrCodeNo {</code></span>
<span class="codeline" id="line-7926"><code>		cc.goAway.ErrCode = old.ErrCode</code></span>
<span class="codeline" id="line-7927"><code>	}</code></span>
<span class="codeline" id="line-7928"><code>	last := f.LastStreamID</code></span>
<span class="codeline" id="line-7929"><code>	for streamID, cs := range cc.streams {</code></span>
<span class="codeline" id="line-7930"><code>		if streamID &gt; last {</code></span>
<span class="codeline" id="line-7931"><code>			cs.abortStreamLocked(http2errClientConnGotGoAway)</code></span>
<span class="codeline" id="line-7932"><code>		}</code></span>
<span class="codeline" id="line-7933"><code>	}</code></span>
<span class="codeline" id="line-7934"><code>}</code></span>
<span class="codeline" id="line-7935"><code></code></span>
<span class="codeline" id="line-7936"><code>// CanTakeNewRequest reports whether the connection can take a new request,</code></span>
<span class="codeline" id="line-7937"><code>// meaning it has not been closed or received or sent a GOAWAY.</code></span>
<span class="codeline" id="line-7938"><code>//</code></span>
<span class="codeline" id="line-7939"><code>// If the caller is going to immediately make a new request on this</code></span>
<span class="codeline" id="line-7940"><code>// connection, use ReserveNewRequest instead.</code></span>
<span class="codeline" id="line-7941"><code>func (cc *http2ClientConn) CanTakeNewRequest() bool {</code></span>
<span class="codeline" id="line-7942"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-7943"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7944"><code>	return cc.canTakeNewRequestLocked()</code></span>
<span class="codeline" id="line-7945"><code>}</code></span>
<span class="codeline" id="line-7946"><code></code></span>
<span class="codeline" id="line-7947"><code>// ReserveNewRequest is like CanTakeNewRequest but also reserves a</code></span>
<span class="codeline" id="line-7948"><code>// concurrent stream in cc. The reservation is decremented on the</code></span>
<span class="codeline" id="line-7949"><code>// next call to RoundTrip.</code></span>
<span class="codeline" id="line-7950"><code>func (cc *http2ClientConn) ReserveNewRequest() bool {</code></span>
<span class="codeline" id="line-7951"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-7952"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-7953"><code>	if st := cc.idleStateLocked(); !st.canTakeNewRequest {</code></span>
<span class="codeline" id="line-7954"><code>		return false</code></span>
<span class="codeline" id="line-7955"><code>	}</code></span>
<span class="codeline" id="line-7956"><code>	cc.streamsReserved++</code></span>
<span class="codeline" id="line-7957"><code>	return true</code></span>
<span class="codeline" id="line-7958"><code>}</code></span>
<span class="codeline" id="line-7959"><code></code></span>
<span class="codeline" id="line-7960"><code>// ClientConnState describes the state of a ClientConn.</code></span>
<span class="codeline" id="line-7961"><code>type http2ClientConnState struct {</code></span>
<span class="codeline" id="line-7962"><code>	// Closed is whether the connection is closed.</code></span>
<span class="codeline" id="line-7963"><code>	Closed bool</code></span>
<span class="codeline" id="line-7964"><code></code></span>
<span class="codeline" id="line-7965"><code>	// Closing is whether the connection is in the process of</code></span>
<span class="codeline" id="line-7966"><code>	// closing. It may be closing due to shutdown, being a</code></span>
<span class="codeline" id="line-7967"><code>	// single-use connection, being marked as DoNotReuse, or</code></span>
<span class="codeline" id="line-7968"><code>	// having received a GOAWAY frame.</code></span>
<span class="codeline" id="line-7969"><code>	Closing bool</code></span>
<span class="codeline" id="line-7970"><code></code></span>
<span class="codeline" id="line-7971"><code>	// StreamsActive is how many streams are active.</code></span>
<span class="codeline" id="line-7972"><code>	StreamsActive int</code></span>
<span class="codeline" id="line-7973"><code></code></span>
<span class="codeline" id="line-7974"><code>	// StreamsReserved is how many streams have been reserved via</code></span>
<span class="codeline" id="line-7975"><code>	// ClientConn.ReserveNewRequest.</code></span>
<span class="codeline" id="line-7976"><code>	StreamsReserved int</code></span>
<span class="codeline" id="line-7977"><code></code></span>
<span class="codeline" id="line-7978"><code>	// StreamsPending is how many requests have been sent in excess</code></span>
<span class="codeline" id="line-7979"><code>	// of the peer's advertised MaxConcurrentStreams setting and</code></span>
<span class="codeline" id="line-7980"><code>	// are waiting for other streams to complete.</code></span>
<span class="codeline" id="line-7981"><code>	StreamsPending int</code></span>
<span class="codeline" id="line-7982"><code></code></span>
<span class="codeline" id="line-7983"><code>	// MaxConcurrentStreams is how many concurrent streams the</code></span>
<span class="codeline" id="line-7984"><code>	// peer advertised as acceptable. Zero means no SETTINGS</code></span>
<span class="codeline" id="line-7985"><code>	// frame has been received yet.</code></span>
<span class="codeline" id="line-7986"><code>	MaxConcurrentStreams uint32</code></span>
<span class="codeline" id="line-7987"><code></code></span>
<span class="codeline" id="line-7988"><code>	// LastIdle, if non-zero, is when the connection last</code></span>
<span class="codeline" id="line-7989"><code>	// transitioned to idle state.</code></span>
<span class="codeline" id="line-7990"><code>	LastIdle time.Time</code></span>
<span class="codeline" id="line-7991"><code>}</code></span>
<span class="codeline" id="line-7992"><code></code></span>
<span class="codeline" id="line-7993"><code>// State returns a snapshot of cc's state.</code></span>
<span class="codeline" id="line-7994"><code>func (cc *http2ClientConn) State() http2ClientConnState {</code></span>
<span class="codeline" id="line-7995"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-7996"><code>	maxConcurrent := cc.maxConcurrentStreams</code></span>
<span class="codeline" id="line-7997"><code>	if !cc.seenSettings {</code></span>
<span class="codeline" id="line-7998"><code>		maxConcurrent = 0</code></span>
<span class="codeline" id="line-7999"><code>	}</code></span>
<span class="codeline" id="line-8000"><code>	cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8001"><code></code></span>
<span class="codeline" id="line-8002"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8003"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8004"><code>	return http2ClientConnState{</code></span>
<span class="codeline" id="line-8005"><code>		Closed:               cc.closed,</code></span>
<span class="codeline" id="line-8006"><code>		Closing:              cc.closing || cc.singleUse || cc.doNotReuse || cc.goAway != nil,</code></span>
<span class="codeline" id="line-8007"><code>		StreamsActive:        len(cc.streams),</code></span>
<span class="codeline" id="line-8008"><code>		StreamsReserved:      cc.streamsReserved,</code></span>
<span class="codeline" id="line-8009"><code>		StreamsPending:       cc.pendingRequests,</code></span>
<span class="codeline" id="line-8010"><code>		LastIdle:             cc.lastIdle,</code></span>
<span class="codeline" id="line-8011"><code>		MaxConcurrentStreams: maxConcurrent,</code></span>
<span class="codeline" id="line-8012"><code>	}</code></span>
<span class="codeline" id="line-8013"><code>}</code></span>
<span class="codeline" id="line-8014"><code></code></span>
<span class="codeline" id="line-8015"><code>// clientConnIdleState describes the suitability of a client</code></span>
<span class="codeline" id="line-8016"><code>// connection to initiate a new RoundTrip request.</code></span>
<span class="codeline" id="line-8017"><code>type http2clientConnIdleState struct {</code></span>
<span class="codeline" id="line-8018"><code>	canTakeNewRequest bool</code></span>
<span class="codeline" id="line-8019"><code>}</code></span>
<span class="codeline" id="line-8020"><code></code></span>
<span class="codeline" id="line-8021"><code>func (cc *http2ClientConn) idleState() http2clientConnIdleState {</code></span>
<span class="codeline" id="line-8022"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8023"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8024"><code>	return cc.idleStateLocked()</code></span>
<span class="codeline" id="line-8025"><code>}</code></span>
<span class="codeline" id="line-8026"><code></code></span>
<span class="codeline" id="line-8027"><code>func (cc *http2ClientConn) idleStateLocked() (st http2clientConnIdleState) {</code></span>
<span class="codeline" id="line-8028"><code>	if cc.singleUse &amp;&amp; cc.nextStreamID &gt; 1 {</code></span>
<span class="codeline" id="line-8029"><code>		return</code></span>
<span class="codeline" id="line-8030"><code>	}</code></span>
<span class="codeline" id="line-8031"><code>	var maxConcurrentOkay bool</code></span>
<span class="codeline" id="line-8032"><code>	if cc.t.StrictMaxConcurrentStreams {</code></span>
<span class="codeline" id="line-8033"><code>		// We'll tell the caller we can take a new request to</code></span>
<span class="codeline" id="line-8034"><code>		// prevent the caller from dialing a new TCP</code></span>
<span class="codeline" id="line-8035"><code>		// connection, but then we'll block later before</code></span>
<span class="codeline" id="line-8036"><code>		// writing it.</code></span>
<span class="codeline" id="line-8037"><code>		maxConcurrentOkay = true</code></span>
<span class="codeline" id="line-8038"><code>	} else {</code></span>
<span class="codeline" id="line-8039"><code>		maxConcurrentOkay = int64(len(cc.streams)+cc.streamsReserved+1) &lt;= int64(cc.maxConcurrentStreams)</code></span>
<span class="codeline" id="line-8040"><code>	}</code></span>
<span class="codeline" id="line-8041"><code></code></span>
<span class="codeline" id="line-8042"><code>	st.canTakeNewRequest = cc.goAway == nil &amp;&amp; !cc.closed &amp;&amp; !cc.closing &amp;&amp; maxConcurrentOkay &amp;&amp;</code></span>
<span class="codeline" id="line-8043"><code>		!cc.doNotReuse &amp;&amp;</code></span>
<span class="codeline" id="line-8044"><code>		int64(cc.nextStreamID)+2*int64(cc.pendingRequests) &lt; math.MaxInt32 &amp;&amp;</code></span>
<span class="codeline" id="line-8045"><code>		!cc.tooIdleLocked()</code></span>
<span class="codeline" id="line-8046"><code>	return</code></span>
<span class="codeline" id="line-8047"><code>}</code></span>
<span class="codeline" id="line-8048"><code></code></span>
<span class="codeline" id="line-8049"><code>func (cc *http2ClientConn) canTakeNewRequestLocked() bool {</code></span>
<span class="codeline" id="line-8050"><code>	st := cc.idleStateLocked()</code></span>
<span class="codeline" id="line-8051"><code>	return st.canTakeNewRequest</code></span>
<span class="codeline" id="line-8052"><code>}</code></span>
<span class="codeline" id="line-8053"><code></code></span>
<span class="codeline" id="line-8054"><code>// tooIdleLocked reports whether this connection has been been sitting idle</code></span>
<span class="codeline" id="line-8055"><code>// for too much wall time.</code></span>
<span class="codeline" id="line-8056"><code>func (cc *http2ClientConn) tooIdleLocked() bool {</code></span>
<span class="codeline" id="line-8057"><code>	// The Round(0) strips the monontonic clock reading so the</code></span>
<span class="codeline" id="line-8058"><code>	// times are compared based on their wall time. We don't want</code></span>
<span class="codeline" id="line-8059"><code>	// to reuse a connection that's been sitting idle during</code></span>
<span class="codeline" id="line-8060"><code>	// VM/laptop suspend if monotonic time was also frozen.</code></span>
<span class="codeline" id="line-8061"><code>	return cc.idleTimeout != 0 &amp;&amp; !cc.lastIdle.IsZero() &amp;&amp; time.Since(cc.lastIdle.Round(0)) &gt; cc.idleTimeout</code></span>
<span class="codeline" id="line-8062"><code>}</code></span>
<span class="codeline" id="line-8063"><code></code></span>
<span class="codeline" id="line-8064"><code>// onIdleTimeout is called from a time.AfterFunc goroutine. It will</code></span>
<span class="codeline" id="line-8065"><code>// only be called when we're idle, but because we're coming from a new</code></span>
<span class="codeline" id="line-8066"><code>// goroutine, there could be a new request coming in at the same time,</code></span>
<span class="codeline" id="line-8067"><code>// so this simply calls the synchronized closeIfIdle to shut down this</code></span>
<span class="codeline" id="line-8068"><code>// connection. The timer could just call closeIfIdle, but this is more</code></span>
<span class="codeline" id="line-8069"><code>// clear.</code></span>
<span class="codeline" id="line-8070"><code>func (cc *http2ClientConn) onIdleTimeout() {</code></span>
<span class="codeline" id="line-8071"><code>	cc.closeIfIdle()</code></span>
<span class="codeline" id="line-8072"><code>}</code></span>
<span class="codeline" id="line-8073"><code></code></span>
<span class="codeline" id="line-8074"><code>func (cc *http2ClientConn) closeConn() {</code></span>
<span class="codeline" id="line-8075"><code>	t := time.AfterFunc(250*time.Millisecond, cc.forceCloseConn)</code></span>
<span class="codeline" id="line-8076"><code>	defer t.Stop()</code></span>
<span class="codeline" id="line-8077"><code>	cc.tconn.Close()</code></span>
<span class="codeline" id="line-8078"><code>}</code></span>
<span class="codeline" id="line-8079"><code></code></span>
<span class="codeline" id="line-8080"><code>// A tls.Conn.Close can hang for a long time if the peer is unresponsive.</code></span>
<span class="codeline" id="line-8081"><code>// Try to shut it down more aggressively.</code></span>
<span class="codeline" id="line-8082"><code>func (cc *http2ClientConn) forceCloseConn() {</code></span>
<span class="codeline" id="line-8083"><code>	tc, ok := cc.tconn.(*tls.Conn)</code></span>
<span class="codeline" id="line-8084"><code>	if !ok {</code></span>
<span class="codeline" id="line-8085"><code>		return</code></span>
<span class="codeline" id="line-8086"><code>	}</code></span>
<span class="codeline" id="line-8087"><code>	if nc := tc.NetConn(); nc != nil {</code></span>
<span class="codeline" id="line-8088"><code>		nc.Close()</code></span>
<span class="codeline" id="line-8089"><code>	}</code></span>
<span class="codeline" id="line-8090"><code>}</code></span>
<span class="codeline" id="line-8091"><code></code></span>
<span class="codeline" id="line-8092"><code>func (cc *http2ClientConn) closeIfIdle() {</code></span>
<span class="codeline" id="line-8093"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8094"><code>	if len(cc.streams) &gt; 0 || cc.streamsReserved &gt; 0 {</code></span>
<span class="codeline" id="line-8095"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8096"><code>		return</code></span>
<span class="codeline" id="line-8097"><code>	}</code></span>
<span class="codeline" id="line-8098"><code>	cc.closed = true</code></span>
<span class="codeline" id="line-8099"><code>	nextID := cc.nextStreamID</code></span>
<span class="codeline" id="line-8100"><code>	// TODO: do clients send GOAWAY too? maybe? Just Close:</code></span>
<span class="codeline" id="line-8101"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8102"><code></code></span>
<span class="codeline" id="line-8103"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-8104"><code>		cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID-2)</code></span>
<span class="codeline" id="line-8105"><code>	}</code></span>
<span class="codeline" id="line-8106"><code>	cc.closeConn()</code></span>
<span class="codeline" id="line-8107"><code>}</code></span>
<span class="codeline" id="line-8108"><code></code></span>
<span class="codeline" id="line-8109"><code>func (cc *http2ClientConn) isDoNotReuseAndIdle() bool {</code></span>
<span class="codeline" id="line-8110"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8111"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8112"><code>	return cc.doNotReuse &amp;&amp; len(cc.streams) == 0</code></span>
<span class="codeline" id="line-8113"><code>}</code></span>
<span class="codeline" id="line-8114"><code></code></span>
<span class="codeline" id="line-8115"><code>var http2shutdownEnterWaitStateHook = func() {}</code></span>
<span class="codeline" id="line-8116"><code></code></span>
<span class="codeline" id="line-8117"><code>// Shutdown gracefully closes the client connection, waiting for running streams to complete.</code></span>
<span class="codeline" id="line-8118"><code>func (cc *http2ClientConn) Shutdown(ctx context.Context) error {</code></span>
<span class="codeline" id="line-8119"><code>	if err := cc.sendGoAway(); err != nil {</code></span>
<span class="codeline" id="line-8120"><code>		return err</code></span>
<span class="codeline" id="line-8121"><code>	}</code></span>
<span class="codeline" id="line-8122"><code>	// Wait for all in-flight streams to complete or connection to close</code></span>
<span class="codeline" id="line-8123"><code>	done := make(chan struct{})</code></span>
<span class="codeline" id="line-8124"><code>	cancelled := false // guarded by cc.mu</code></span>
<span class="codeline" id="line-8125"><code>	go func() {</code></span>
<span class="codeline" id="line-8126"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-8127"><code>		defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8128"><code>		for {</code></span>
<span class="codeline" id="line-8129"><code>			if len(cc.streams) == 0 || cc.closed {</code></span>
<span class="codeline" id="line-8130"><code>				cc.closed = true</code></span>
<span class="codeline" id="line-8131"><code>				close(done)</code></span>
<span class="codeline" id="line-8132"><code>				break</code></span>
<span class="codeline" id="line-8133"><code>			}</code></span>
<span class="codeline" id="line-8134"><code>			if cancelled {</code></span>
<span class="codeline" id="line-8135"><code>				break</code></span>
<span class="codeline" id="line-8136"><code>			}</code></span>
<span class="codeline" id="line-8137"><code>			cc.cond.Wait()</code></span>
<span class="codeline" id="line-8138"><code>		}</code></span>
<span class="codeline" id="line-8139"><code>	}()</code></span>
<span class="codeline" id="line-8140"><code>	http2shutdownEnterWaitStateHook()</code></span>
<span class="codeline" id="line-8141"><code>	select {</code></span>
<span class="codeline" id="line-8142"><code>	case &lt;-done:</code></span>
<span class="codeline" id="line-8143"><code>		cc.closeConn()</code></span>
<span class="codeline" id="line-8144"><code>		return nil</code></span>
<span class="codeline" id="line-8145"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8146"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-8147"><code>		// Free the goroutine above</code></span>
<span class="codeline" id="line-8148"><code>		cancelled = true</code></span>
<span class="codeline" id="line-8149"><code>		cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-8150"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8151"><code>		return ctx.Err()</code></span>
<span class="codeline" id="line-8152"><code>	}</code></span>
<span class="codeline" id="line-8153"><code>}</code></span>
<span class="codeline" id="line-8154"><code></code></span>
<span class="codeline" id="line-8155"><code>func (cc *http2ClientConn) sendGoAway() error {</code></span>
<span class="codeline" id="line-8156"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8157"><code>	closing := cc.closing</code></span>
<span class="codeline" id="line-8158"><code>	cc.closing = true</code></span>
<span class="codeline" id="line-8159"><code>	maxStreamID := cc.nextStreamID</code></span>
<span class="codeline" id="line-8160"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8161"><code>	if closing {</code></span>
<span class="codeline" id="line-8162"><code>		// GOAWAY sent already</code></span>
<span class="codeline" id="line-8163"><code>		return nil</code></span>
<span class="codeline" id="line-8164"><code>	}</code></span>
<span class="codeline" id="line-8165"><code></code></span>
<span class="codeline" id="line-8166"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-8167"><code>	defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8168"><code>	// Send a graceful shutdown frame to server</code></span>
<span class="codeline" id="line-8169"><code>	if err := cc.fr.WriteGoAway(maxStreamID, http2ErrCodeNo, nil); err != nil {</code></span>
<span class="codeline" id="line-8170"><code>		return err</code></span>
<span class="codeline" id="line-8171"><code>	}</code></span>
<span class="codeline" id="line-8172"><code>	if err := cc.bw.Flush(); err != nil {</code></span>
<span class="codeline" id="line-8173"><code>		return err</code></span>
<span class="codeline" id="line-8174"><code>	}</code></span>
<span class="codeline" id="line-8175"><code>	// Prevent new requests</code></span>
<span class="codeline" id="line-8176"><code>	return nil</code></span>
<span class="codeline" id="line-8177"><code>}</code></span>
<span class="codeline" id="line-8178"><code></code></span>
<span class="codeline" id="line-8179"><code>// closes the client connection immediately. In-flight requests are interrupted.</code></span>
<span class="codeline" id="line-8180"><code>// err is sent to streams.</code></span>
<span class="codeline" id="line-8181"><code>func (cc *http2ClientConn) closeForError(err error) {</code></span>
<span class="codeline" id="line-8182"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8183"><code>	cc.closed = true</code></span>
<span class="codeline" id="line-8184"><code>	for _, cs := range cc.streams {</code></span>
<span class="codeline" id="line-8185"><code>		cs.abortStreamLocked(err)</code></span>
<span class="codeline" id="line-8186"><code>	}</code></span>
<span class="codeline" id="line-8187"><code>	cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-8188"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8189"><code>	cc.closeConn()</code></span>
<span class="codeline" id="line-8190"><code>}</code></span>
<span class="codeline" id="line-8191"><code></code></span>
<span class="codeline" id="line-8192"><code>// Close closes the client connection immediately.</code></span>
<span class="codeline" id="line-8193"><code>//</code></span>
<span class="codeline" id="line-8194"><code>// In-flight requests are interrupted. For a graceful shutdown, use Shutdown instead.</code></span>
<span class="codeline" id="line-8195"><code>func (cc *http2ClientConn) Close() error {</code></span>
<span class="codeline" id="line-8196"><code>	err := errors.New("http2: client connection force closed via ClientConn.Close")</code></span>
<span class="codeline" id="line-8197"><code>	cc.closeForError(err)</code></span>
<span class="codeline" id="line-8198"><code>	return nil</code></span>
<span class="codeline" id="line-8199"><code>}</code></span>
<span class="codeline" id="line-8200"><code></code></span>
<span class="codeline" id="line-8201"><code>// closes the client connection immediately. In-flight requests are interrupted.</code></span>
<span class="codeline" id="line-8202"><code>func (cc *http2ClientConn) closeForLostPing() {</code></span>
<span class="codeline" id="line-8203"><code>	err := errors.New("http2: client connection lost")</code></span>
<span class="codeline" id="line-8204"><code>	if f := cc.t.CountError; f != nil {</code></span>
<span class="codeline" id="line-8205"><code>		f("conn_close_lost_ping")</code></span>
<span class="codeline" id="line-8206"><code>	}</code></span>
<span class="codeline" id="line-8207"><code>	cc.closeForError(err)</code></span>
<span class="codeline" id="line-8208"><code>}</code></span>
<span class="codeline" id="line-8209"><code></code></span>
<span class="codeline" id="line-8210"><code>// errRequestCanceled is a copy of net/http's errRequestCanceled because it's not</code></span>
<span class="codeline" id="line-8211"><code>// exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.</code></span>
<span class="codeline" id="line-8212"><code>var http2errRequestCanceled = errors.New("net/http: request canceled")</code></span>
<span class="codeline" id="line-8213"><code></code></span>
<span class="codeline" id="line-8214"><code>func http2commaSeparatedTrailers(req *Request) (string, error) {</code></span>
<span class="codeline" id="line-8215"><code>	keys := make([]string, 0, len(req.Trailer))</code></span>
<span class="codeline" id="line-8216"><code>	for k := range req.Trailer {</code></span>
<span class="codeline" id="line-8217"><code>		k = http2canonicalHeader(k)</code></span>
<span class="codeline" id="line-8218"><code>		switch k {</code></span>
<span class="codeline" id="line-8219"><code>		case "Transfer-Encoding", "Trailer", "Content-Length":</code></span>
<span class="codeline" id="line-8220"><code>			return "", fmt.Errorf("invalid Trailer key %q", k)</code></span>
<span class="codeline" id="line-8221"><code>		}</code></span>
<span class="codeline" id="line-8222"><code>		keys = append(keys, k)</code></span>
<span class="codeline" id="line-8223"><code>	}</code></span>
<span class="codeline" id="line-8224"><code>	if len(keys) &gt; 0 {</code></span>
<span class="codeline" id="line-8225"><code>		sort.Strings(keys)</code></span>
<span class="codeline" id="line-8226"><code>		return strings.Join(keys, ","), nil</code></span>
<span class="codeline" id="line-8227"><code>	}</code></span>
<span class="codeline" id="line-8228"><code>	return "", nil</code></span>
<span class="codeline" id="line-8229"><code>}</code></span>
<span class="codeline" id="line-8230"><code></code></span>
<span class="codeline" id="line-8231"><code>func (cc *http2ClientConn) responseHeaderTimeout() time.Duration {</code></span>
<span class="codeline" id="line-8232"><code>	if cc.t.t1 != nil {</code></span>
<span class="codeline" id="line-8233"><code>		return cc.t.t1.ResponseHeaderTimeout</code></span>
<span class="codeline" id="line-8234"><code>	}</code></span>
<span class="codeline" id="line-8235"><code>	// No way to do this (yet?) with just an http2.Transport. Probably</code></span>
<span class="codeline" id="line-8236"><code>	// no need. Request.Cancel this is the new way. We only need to support</code></span>
<span class="codeline" id="line-8237"><code>	// this for compatibility with the old http.Transport fields when</code></span>
<span class="codeline" id="line-8238"><code>	// we're doing transparent http2.</code></span>
<span class="codeline" id="line-8239"><code>	return 0</code></span>
<span class="codeline" id="line-8240"><code>}</code></span>
<span class="codeline" id="line-8241"><code></code></span>
<span class="codeline" id="line-8242"><code>// checkConnHeaders checks whether req has any invalid connection-level headers.</code></span>
<span class="codeline" id="line-8243"><code>// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.</code></span>
<span class="codeline" id="line-8244"><code>// Certain headers are special-cased as okay but not transmitted later.</code></span>
<span class="codeline" id="line-8245"><code>func http2checkConnHeaders(req *Request) error {</code></span>
<span class="codeline" id="line-8246"><code>	if v := req.Header.Get("Upgrade"); v != "" {</code></span>
<span class="codeline" id="line-8247"><code>		return fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"])</code></span>
<span class="codeline" id="line-8248"><code>	}</code></span>
<span class="codeline" id="line-8249"><code>	if vv := req.Header["Transfer-Encoding"]; len(vv) &gt; 0 &amp;&amp; (len(vv) &gt; 1 || vv[0] != "" &amp;&amp; vv[0] != "chunked") {</code></span>
<span class="codeline" id="line-8250"><code>		return fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv)</code></span>
<span class="codeline" id="line-8251"><code>	}</code></span>
<span class="codeline" id="line-8252"><code>	if vv := req.Header["Connection"]; len(vv) &gt; 0 &amp;&amp; (len(vv) &gt; 1 || vv[0] != "" &amp;&amp; !http2asciiEqualFold(vv[0], "close") &amp;&amp; !http2asciiEqualFold(vv[0], "keep-alive")) {</code></span>
<span class="codeline" id="line-8253"><code>		return fmt.Errorf("http2: invalid Connection request header: %q", vv)</code></span>
<span class="codeline" id="line-8254"><code>	}</code></span>
<span class="codeline" id="line-8255"><code>	return nil</code></span>
<span class="codeline" id="line-8256"><code>}</code></span>
<span class="codeline" id="line-8257"><code></code></span>
<span class="codeline" id="line-8258"><code>// actualContentLength returns a sanitized version of</code></span>
<span class="codeline" id="line-8259"><code>// req.ContentLength, where 0 actually means zero (not unknown) and -1</code></span>
<span class="codeline" id="line-8260"><code>// means unknown.</code></span>
<span class="codeline" id="line-8261"><code>func http2actualContentLength(req *Request) int64 {</code></span>
<span class="codeline" id="line-8262"><code>	if req.Body == nil || req.Body == NoBody {</code></span>
<span class="codeline" id="line-8263"><code>		return 0</code></span>
<span class="codeline" id="line-8264"><code>	}</code></span>
<span class="codeline" id="line-8265"><code>	if req.ContentLength != 0 {</code></span>
<span class="codeline" id="line-8266"><code>		return req.ContentLength</code></span>
<span class="codeline" id="line-8267"><code>	}</code></span>
<span class="codeline" id="line-8268"><code>	return -1</code></span>
<span class="codeline" id="line-8269"><code>}</code></span>
<span class="codeline" id="line-8270"><code></code></span>
<span class="codeline" id="line-8271"><code>func (cc *http2ClientConn) decrStreamReservations() {</code></span>
<span class="codeline" id="line-8272"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8273"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8274"><code>	cc.decrStreamReservationsLocked()</code></span>
<span class="codeline" id="line-8275"><code>}</code></span>
<span class="codeline" id="line-8276"><code></code></span>
<span class="codeline" id="line-8277"><code>func (cc *http2ClientConn) decrStreamReservationsLocked() {</code></span>
<span class="codeline" id="line-8278"><code>	if cc.streamsReserved &gt; 0 {</code></span>
<span class="codeline" id="line-8279"><code>		cc.streamsReserved--</code></span>
<span class="codeline" id="line-8280"><code>	}</code></span>
<span class="codeline" id="line-8281"><code>}</code></span>
<span class="codeline" id="line-8282"><code></code></span>
<span class="codeline" id="line-8283"><code>func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {</code></span>
<span class="codeline" id="line-8284"><code>	ctx := req.Context()</code></span>
<span class="codeline" id="line-8285"><code>	cs := &amp;http2clientStream{</code></span>
<span class="codeline" id="line-8286"><code>		cc:                   cc,</code></span>
<span class="codeline" id="line-8287"><code>		ctx:                  ctx,</code></span>
<span class="codeline" id="line-8288"><code>		reqCancel:            req.Cancel,</code></span>
<span class="codeline" id="line-8289"><code>		isHead:               req.Method == "HEAD",</code></span>
<span class="codeline" id="line-8290"><code>		reqBody:              req.Body,</code></span>
<span class="codeline" id="line-8291"><code>		reqBodyContentLength: http2actualContentLength(req),</code></span>
<span class="codeline" id="line-8292"><code>		trace:                httptrace.ContextClientTrace(ctx),</code></span>
<span class="codeline" id="line-8293"><code>		peerClosed:           make(chan struct{}),</code></span>
<span class="codeline" id="line-8294"><code>		abort:                make(chan struct{}),</code></span>
<span class="codeline" id="line-8295"><code>		respHeaderRecv:       make(chan struct{}),</code></span>
<span class="codeline" id="line-8296"><code>		donec:                make(chan struct{}),</code></span>
<span class="codeline" id="line-8297"><code>	}</code></span>
<span class="codeline" id="line-8298"><code>	go cs.doRequest(req)</code></span>
<span class="codeline" id="line-8299"><code></code></span>
<span class="codeline" id="line-8300"><code>	waitDone := func() error {</code></span>
<span class="codeline" id="line-8301"><code>		select {</code></span>
<span class="codeline" id="line-8302"><code>		case &lt;-cs.donec:</code></span>
<span class="codeline" id="line-8303"><code>			return nil</code></span>
<span class="codeline" id="line-8304"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8305"><code>			return ctx.Err()</code></span>
<span class="codeline" id="line-8306"><code>		case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8307"><code>			return http2errRequestCanceled</code></span>
<span class="codeline" id="line-8308"><code>		}</code></span>
<span class="codeline" id="line-8309"><code>	}</code></span>
<span class="codeline" id="line-8310"><code></code></span>
<span class="codeline" id="line-8311"><code>	handleResponseHeaders := func() (*Response, error) {</code></span>
<span class="codeline" id="line-8312"><code>		res := cs.res</code></span>
<span class="codeline" id="line-8313"><code>		if res.StatusCode &gt; 299 {</code></span>
<span class="codeline" id="line-8314"><code>			// On error or status code 3xx, 4xx, 5xx, etc abort any</code></span>
<span class="codeline" id="line-8315"><code>			// ongoing write, assuming that the server doesn't care</code></span>
<span class="codeline" id="line-8316"><code>			// about our request body. If the server replied with 1xx or</code></span>
<span class="codeline" id="line-8317"><code>			// 2xx, however, then assume the server DOES potentially</code></span>
<span class="codeline" id="line-8318"><code>			// want our body (e.g. full-duplex streaming:</code></span>
<span class="codeline" id="line-8319"><code>			// golang.org/issue/13444). If it turns out the server</code></span>
<span class="codeline" id="line-8320"><code>			// doesn't, they'll RST_STREAM us soon enough. This is a</code></span>
<span class="codeline" id="line-8321"><code>			// heuristic to avoid adding knobs to Transport. Hopefully</code></span>
<span class="codeline" id="line-8322"><code>			// we can keep it.</code></span>
<span class="codeline" id="line-8323"><code>			cs.abortRequestBodyWrite()</code></span>
<span class="codeline" id="line-8324"><code>		}</code></span>
<span class="codeline" id="line-8325"><code>		res.Request = req</code></span>
<span class="codeline" id="line-8326"><code>		res.TLS = cc.tlsState</code></span>
<span class="codeline" id="line-8327"><code>		if res.Body == http2noBody &amp;&amp; http2actualContentLength(req) == 0 {</code></span>
<span class="codeline" id="line-8328"><code>			// If there isn't a request or response body still being</code></span>
<span class="codeline" id="line-8329"><code>			// written, then wait for the stream to be closed before</code></span>
<span class="codeline" id="line-8330"><code>			// RoundTrip returns.</code></span>
<span class="codeline" id="line-8331"><code>			if err := waitDone(); err != nil {</code></span>
<span class="codeline" id="line-8332"><code>				return nil, err</code></span>
<span class="codeline" id="line-8333"><code>			}</code></span>
<span class="codeline" id="line-8334"><code>		}</code></span>
<span class="codeline" id="line-8335"><code>		return res, nil</code></span>
<span class="codeline" id="line-8336"><code>	}</code></span>
<span class="codeline" id="line-8337"><code></code></span>
<span class="codeline" id="line-8338"><code>	cancelRequest := func(cs *http2clientStream, err error) error {</code></span>
<span class="codeline" id="line-8339"><code>		cs.cc.mu.Lock()</code></span>
<span class="codeline" id="line-8340"><code>		bodyClosed := cs.reqBodyClosed</code></span>
<span class="codeline" id="line-8341"><code>		cs.cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8342"><code>		// Wait for the request body to be closed.</code></span>
<span class="codeline" id="line-8343"><code>		//</code></span>
<span class="codeline" id="line-8344"><code>		// If nothing closed the body before now, abortStreamLocked</code></span>
<span class="codeline" id="line-8345"><code>		// will have started a goroutine to close it.</code></span>
<span class="codeline" id="line-8346"><code>		//</code></span>
<span class="codeline" id="line-8347"><code>		// Closing the body before returning avoids a race condition</code></span>
<span class="codeline" id="line-8348"><code>		// with net/http checking its readTrackingBody to see if the</code></span>
<span class="codeline" id="line-8349"><code>		// body was read from or closed. See golang/go#60041.</code></span>
<span class="codeline" id="line-8350"><code>		//</code></span>
<span class="codeline" id="line-8351"><code>		// The body is closed in a separate goroutine without the</code></span>
<span class="codeline" id="line-8352"><code>		// connection mutex held, but dropping the mutex before waiting</code></span>
<span class="codeline" id="line-8353"><code>		// will keep us from holding it indefinitely if the body</code></span>
<span class="codeline" id="line-8354"><code>		// close is slow for some reason.</code></span>
<span class="codeline" id="line-8355"><code>		if bodyClosed != nil {</code></span>
<span class="codeline" id="line-8356"><code>			&lt;-bodyClosed</code></span>
<span class="codeline" id="line-8357"><code>		}</code></span>
<span class="codeline" id="line-8358"><code>		return err</code></span>
<span class="codeline" id="line-8359"><code>	}</code></span>
<span class="codeline" id="line-8360"><code></code></span>
<span class="codeline" id="line-8361"><code>	for {</code></span>
<span class="codeline" id="line-8362"><code>		select {</code></span>
<span class="codeline" id="line-8363"><code>		case &lt;-cs.respHeaderRecv:</code></span>
<span class="codeline" id="line-8364"><code>			return handleResponseHeaders()</code></span>
<span class="codeline" id="line-8365"><code>		case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8366"><code>			select {</code></span>
<span class="codeline" id="line-8367"><code>			case &lt;-cs.respHeaderRecv:</code></span>
<span class="codeline" id="line-8368"><code>				// If both cs.respHeaderRecv and cs.abort are signaling,</code></span>
<span class="codeline" id="line-8369"><code>				// pick respHeaderRecv. The server probably wrote the</code></span>
<span class="codeline" id="line-8370"><code>				// response and immediately reset the stream.</code></span>
<span class="codeline" id="line-8371"><code>				// golang.org/issue/49645</code></span>
<span class="codeline" id="line-8372"><code>				return handleResponseHeaders()</code></span>
<span class="codeline" id="line-8373"><code>			default:</code></span>
<span class="codeline" id="line-8374"><code>				waitDone()</code></span>
<span class="codeline" id="line-8375"><code>				return nil, cs.abortErr</code></span>
<span class="codeline" id="line-8376"><code>			}</code></span>
<span class="codeline" id="line-8377"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8378"><code>			err := ctx.Err()</code></span>
<span class="codeline" id="line-8379"><code>			cs.abortStream(err)</code></span>
<span class="codeline" id="line-8380"><code>			return nil, cancelRequest(cs, err)</code></span>
<span class="codeline" id="line-8381"><code>		case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8382"><code>			cs.abortStream(http2errRequestCanceled)</code></span>
<span class="codeline" id="line-8383"><code>			return nil, cancelRequest(cs, http2errRequestCanceled)</code></span>
<span class="codeline" id="line-8384"><code>		}</code></span>
<span class="codeline" id="line-8385"><code>	}</code></span>
<span class="codeline" id="line-8386"><code>}</code></span>
<span class="codeline" id="line-8387"><code></code></span>
<span class="codeline" id="line-8388"><code>// doRequest runs for the duration of the request lifetime.</code></span>
<span class="codeline" id="line-8389"><code>//</code></span>
<span class="codeline" id="line-8390"><code>// It sends the request and performs post-request cleanup (closing Request.Body, etc.).</code></span>
<span class="codeline" id="line-8391"><code>func (cs *http2clientStream) doRequest(req *Request) {</code></span>
<span class="codeline" id="line-8392"><code>	err := cs.writeRequest(req)</code></span>
<span class="codeline" id="line-8393"><code>	cs.cleanupWriteRequest(err)</code></span>
<span class="codeline" id="line-8394"><code>}</code></span>
<span class="codeline" id="line-8395"><code></code></span>
<span class="codeline" id="line-8396"><code>// writeRequest sends a request.</code></span>
<span class="codeline" id="line-8397"><code>//</code></span>
<span class="codeline" id="line-8398"><code>// It returns nil after the request is written, the response read,</code></span>
<span class="codeline" id="line-8399"><code>// and the request stream is half-closed by the peer.</code></span>
<span class="codeline" id="line-8400"><code>//</code></span>
<span class="codeline" id="line-8401"><code>// It returns non-nil if the request ends otherwise.</code></span>
<span class="codeline" id="line-8402"><code>// If the returned error is StreamError, the error Code may be used in resetting the stream.</code></span>
<span class="codeline" id="line-8403"><code>func (cs *http2clientStream) writeRequest(req *Request) (err error) {</code></span>
<span class="codeline" id="line-8404"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-8405"><code>	ctx := cs.ctx</code></span>
<span class="codeline" id="line-8406"><code></code></span>
<span class="codeline" id="line-8407"><code>	if err := http2checkConnHeaders(req); err != nil {</code></span>
<span class="codeline" id="line-8408"><code>		return err</code></span>
<span class="codeline" id="line-8409"><code>	}</code></span>
<span class="codeline" id="line-8410"><code></code></span>
<span class="codeline" id="line-8411"><code>	// Acquire the new-request lock by writing to reqHeaderMu.</code></span>
<span class="codeline" id="line-8412"><code>	// This lock guards the critical section covering allocating a new stream ID</code></span>
<span class="codeline" id="line-8413"><code>	// (requires mu) and creating the stream (requires wmu).</code></span>
<span class="codeline" id="line-8414"><code>	if cc.reqHeaderMu == nil {</code></span>
<span class="codeline" id="line-8415"><code>		panic("RoundTrip on uninitialized ClientConn") // for tests</code></span>
<span class="codeline" id="line-8416"><code>	}</code></span>
<span class="codeline" id="line-8417"><code>	select {</code></span>
<span class="codeline" id="line-8418"><code>	case cc.reqHeaderMu &lt;- struct{}{}:</code></span>
<span class="codeline" id="line-8419"><code>	case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8420"><code>		return http2errRequestCanceled</code></span>
<span class="codeline" id="line-8421"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8422"><code>		return ctx.Err()</code></span>
<span class="codeline" id="line-8423"><code>	}</code></span>
<span class="codeline" id="line-8424"><code></code></span>
<span class="codeline" id="line-8425"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8426"><code>	if cc.idleTimer != nil {</code></span>
<span class="codeline" id="line-8427"><code>		cc.idleTimer.Stop()</code></span>
<span class="codeline" id="line-8428"><code>	}</code></span>
<span class="codeline" id="line-8429"><code>	cc.decrStreamReservationsLocked()</code></span>
<span class="codeline" id="line-8430"><code>	if err := cc.awaitOpenSlotForStreamLocked(cs); err != nil {</code></span>
<span class="codeline" id="line-8431"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8432"><code>		&lt;-cc.reqHeaderMu</code></span>
<span class="codeline" id="line-8433"><code>		return err</code></span>
<span class="codeline" id="line-8434"><code>	}</code></span>
<span class="codeline" id="line-8435"><code>	cc.addStreamLocked(cs) // assigns stream ID</code></span>
<span class="codeline" id="line-8436"><code>	if http2isConnectionCloseRequest(req) {</code></span>
<span class="codeline" id="line-8437"><code>		cc.doNotReuse = true</code></span>
<span class="codeline" id="line-8438"><code>	}</code></span>
<span class="codeline" id="line-8439"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8440"><code></code></span>
<span class="codeline" id="line-8441"><code>	// TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?</code></span>
<span class="codeline" id="line-8442"><code>	if !cc.t.disableCompression() &amp;&amp;</code></span>
<span class="codeline" id="line-8443"><code>		req.Header.Get("Accept-Encoding") == "" &amp;&amp;</code></span>
<span class="codeline" id="line-8444"><code>		req.Header.Get("Range") == "" &amp;&amp;</code></span>
<span class="codeline" id="line-8445"><code>		!cs.isHead {</code></span>
<span class="codeline" id="line-8446"><code>		// Request gzip only, not deflate. Deflate is ambiguous and</code></span>
<span class="codeline" id="line-8447"><code>		// not as universally supported anyway.</code></span>
<span class="codeline" id="line-8448"><code>		// See: https://zlib.net/zlib_faq.html#faq39</code></span>
<span class="codeline" id="line-8449"><code>		//</code></span>
<span class="codeline" id="line-8450"><code>		// Note that we don't request this for HEAD requests,</code></span>
<span class="codeline" id="line-8451"><code>		// due to a bug in nginx:</code></span>
<span class="codeline" id="line-8452"><code>		//   http://trac.nginx.org/nginx/ticket/358</code></span>
<span class="codeline" id="line-8453"><code>		//   https://golang.org/issue/5522</code></span>
<span class="codeline" id="line-8454"><code>		//</code></span>
<span class="codeline" id="line-8455"><code>		// We don't request gzip if the request is for a range, since</code></span>
<span class="codeline" id="line-8456"><code>		// auto-decoding a portion of a gzipped document will just fail</code></span>
<span class="codeline" id="line-8457"><code>		// anyway. See https://golang.org/issue/8923</code></span>
<span class="codeline" id="line-8458"><code>		cs.requestedGzip = true</code></span>
<span class="codeline" id="line-8459"><code>	}</code></span>
<span class="codeline" id="line-8460"><code></code></span>
<span class="codeline" id="line-8461"><code>	continueTimeout := cc.t.expectContinueTimeout()</code></span>
<span class="codeline" id="line-8462"><code>	if continueTimeout != 0 {</code></span>
<span class="codeline" id="line-8463"><code>		if !httpguts.HeaderValuesContainsToken(req.Header["Expect"], "100-continue") {</code></span>
<span class="codeline" id="line-8464"><code>			continueTimeout = 0</code></span>
<span class="codeline" id="line-8465"><code>		} else {</code></span>
<span class="codeline" id="line-8466"><code>			cs.on100 = make(chan struct{}, 1)</code></span>
<span class="codeline" id="line-8467"><code>		}</code></span>
<span class="codeline" id="line-8468"><code>	}</code></span>
<span class="codeline" id="line-8469"><code></code></span>
<span class="codeline" id="line-8470"><code>	// Past this point (where we send request headers), it is possible for</code></span>
<span class="codeline" id="line-8471"><code>	// RoundTrip to return successfully. Since the RoundTrip contract permits</code></span>
<span class="codeline" id="line-8472"><code>	// the caller to "mutate or reuse" the Request after closing the Response's Body,</code></span>
<span class="codeline" id="line-8473"><code>	// we must take care when referencing the Request from here on.</code></span>
<span class="codeline" id="line-8474"><code>	err = cs.encodeAndWriteHeaders(req)</code></span>
<span class="codeline" id="line-8475"><code>	&lt;-cc.reqHeaderMu</code></span>
<span class="codeline" id="line-8476"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8477"><code>		return err</code></span>
<span class="codeline" id="line-8478"><code>	}</code></span>
<span class="codeline" id="line-8479"><code></code></span>
<span class="codeline" id="line-8480"><code>	hasBody := cs.reqBodyContentLength != 0</code></span>
<span class="codeline" id="line-8481"><code>	if !hasBody {</code></span>
<span class="codeline" id="line-8482"><code>		cs.sentEndStream = true</code></span>
<span class="codeline" id="line-8483"><code>	} else {</code></span>
<span class="codeline" id="line-8484"><code>		if continueTimeout != 0 {</code></span>
<span class="codeline" id="line-8485"><code>			http2traceWait100Continue(cs.trace)</code></span>
<span class="codeline" id="line-8486"><code>			timer := time.NewTimer(continueTimeout)</code></span>
<span class="codeline" id="line-8487"><code>			select {</code></span>
<span class="codeline" id="line-8488"><code>			case &lt;-timer.C:</code></span>
<span class="codeline" id="line-8489"><code>				err = nil</code></span>
<span class="codeline" id="line-8490"><code>			case &lt;-cs.on100:</code></span>
<span class="codeline" id="line-8491"><code>				err = nil</code></span>
<span class="codeline" id="line-8492"><code>			case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8493"><code>				err = cs.abortErr</code></span>
<span class="codeline" id="line-8494"><code>			case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8495"><code>				err = ctx.Err()</code></span>
<span class="codeline" id="line-8496"><code>			case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8497"><code>				err = http2errRequestCanceled</code></span>
<span class="codeline" id="line-8498"><code>			}</code></span>
<span class="codeline" id="line-8499"><code>			timer.Stop()</code></span>
<span class="codeline" id="line-8500"><code>			if err != nil {</code></span>
<span class="codeline" id="line-8501"><code>				http2traceWroteRequest(cs.trace, err)</code></span>
<span class="codeline" id="line-8502"><code>				return err</code></span>
<span class="codeline" id="line-8503"><code>			}</code></span>
<span class="codeline" id="line-8504"><code>		}</code></span>
<span class="codeline" id="line-8505"><code></code></span>
<span class="codeline" id="line-8506"><code>		if err = cs.writeRequestBody(req); err != nil {</code></span>
<span class="codeline" id="line-8507"><code>			if err != http2errStopReqBodyWrite {</code></span>
<span class="codeline" id="line-8508"><code>				http2traceWroteRequest(cs.trace, err)</code></span>
<span class="codeline" id="line-8509"><code>				return err</code></span>
<span class="codeline" id="line-8510"><code>			}</code></span>
<span class="codeline" id="line-8511"><code>		} else {</code></span>
<span class="codeline" id="line-8512"><code>			cs.sentEndStream = true</code></span>
<span class="codeline" id="line-8513"><code>		}</code></span>
<span class="codeline" id="line-8514"><code>	}</code></span>
<span class="codeline" id="line-8515"><code></code></span>
<span class="codeline" id="line-8516"><code>	http2traceWroteRequest(cs.trace, err)</code></span>
<span class="codeline" id="line-8517"><code></code></span>
<span class="codeline" id="line-8518"><code>	var respHeaderTimer &lt;-chan time.Time</code></span>
<span class="codeline" id="line-8519"><code>	var respHeaderRecv chan struct{}</code></span>
<span class="codeline" id="line-8520"><code>	if d := cc.responseHeaderTimeout(); d != 0 {</code></span>
<span class="codeline" id="line-8521"><code>		timer := time.NewTimer(d)</code></span>
<span class="codeline" id="line-8522"><code>		defer timer.Stop()</code></span>
<span class="codeline" id="line-8523"><code>		respHeaderTimer = timer.C</code></span>
<span class="codeline" id="line-8524"><code>		respHeaderRecv = cs.respHeaderRecv</code></span>
<span class="codeline" id="line-8525"><code>	}</code></span>
<span class="codeline" id="line-8526"><code>	// Wait until the peer half-closes its end of the stream,</code></span>
<span class="codeline" id="line-8527"><code>	// or until the request is aborted (via context, error, or otherwise),</code></span>
<span class="codeline" id="line-8528"><code>	// whichever comes first.</code></span>
<span class="codeline" id="line-8529"><code>	for {</code></span>
<span class="codeline" id="line-8530"><code>		select {</code></span>
<span class="codeline" id="line-8531"><code>		case &lt;-cs.peerClosed:</code></span>
<span class="codeline" id="line-8532"><code>			return nil</code></span>
<span class="codeline" id="line-8533"><code>		case &lt;-respHeaderTimer:</code></span>
<span class="codeline" id="line-8534"><code>			return http2errTimeout</code></span>
<span class="codeline" id="line-8535"><code>		case &lt;-respHeaderRecv:</code></span>
<span class="codeline" id="line-8536"><code>			respHeaderRecv = nil</code></span>
<span class="codeline" id="line-8537"><code>			respHeaderTimer = nil // keep waiting for END_STREAM</code></span>
<span class="codeline" id="line-8538"><code>		case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8539"><code>			return cs.abortErr</code></span>
<span class="codeline" id="line-8540"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8541"><code>			return ctx.Err()</code></span>
<span class="codeline" id="line-8542"><code>		case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8543"><code>			return http2errRequestCanceled</code></span>
<span class="codeline" id="line-8544"><code>		}</code></span>
<span class="codeline" id="line-8545"><code>	}</code></span>
<span class="codeline" id="line-8546"><code>}</code></span>
<span class="codeline" id="line-8547"><code></code></span>
<span class="codeline" id="line-8548"><code>func (cs *http2clientStream) encodeAndWriteHeaders(req *Request) error {</code></span>
<span class="codeline" id="line-8549"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-8550"><code>	ctx := cs.ctx</code></span>
<span class="codeline" id="line-8551"><code></code></span>
<span class="codeline" id="line-8552"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-8553"><code>	defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8554"><code></code></span>
<span class="codeline" id="line-8555"><code>	// If the request was canceled while waiting for cc.mu, just quit.</code></span>
<span class="codeline" id="line-8556"><code>	select {</code></span>
<span class="codeline" id="line-8557"><code>	case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8558"><code>		return cs.abortErr</code></span>
<span class="codeline" id="line-8559"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8560"><code>		return ctx.Err()</code></span>
<span class="codeline" id="line-8561"><code>	case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8562"><code>		return http2errRequestCanceled</code></span>
<span class="codeline" id="line-8563"><code>	default:</code></span>
<span class="codeline" id="line-8564"><code>	}</code></span>
<span class="codeline" id="line-8565"><code></code></span>
<span class="codeline" id="line-8566"><code>	// Encode headers.</code></span>
<span class="codeline" id="line-8567"><code>	//</code></span>
<span class="codeline" id="line-8568"><code>	// we send: HEADERS{1}, CONTINUATION{0,} + DATA{0,} (DATA is</code></span>
<span class="codeline" id="line-8569"><code>	// sent by writeRequestBody below, along with any Trailers,</code></span>
<span class="codeline" id="line-8570"><code>	// again in form HEADERS{1}, CONTINUATION{0,})</code></span>
<span class="codeline" id="line-8571"><code>	trailers, err := http2commaSeparatedTrailers(req)</code></span>
<span class="codeline" id="line-8572"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8573"><code>		return err</code></span>
<span class="codeline" id="line-8574"><code>	}</code></span>
<span class="codeline" id="line-8575"><code>	hasTrailers := trailers != ""</code></span>
<span class="codeline" id="line-8576"><code>	contentLen := http2actualContentLength(req)</code></span>
<span class="codeline" id="line-8577"><code>	hasBody := contentLen != 0</code></span>
<span class="codeline" id="line-8578"><code>	hdrs, err := cc.encodeHeaders(req, cs.requestedGzip, trailers, contentLen)</code></span>
<span class="codeline" id="line-8579"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8580"><code>		return err</code></span>
<span class="codeline" id="line-8581"><code>	}</code></span>
<span class="codeline" id="line-8582"><code></code></span>
<span class="codeline" id="line-8583"><code>	// Write the request.</code></span>
<span class="codeline" id="line-8584"><code>	endStream := !hasBody &amp;&amp; !hasTrailers</code></span>
<span class="codeline" id="line-8585"><code>	cs.sentHeaders = true</code></span>
<span class="codeline" id="line-8586"><code>	err = cc.writeHeaders(cs.ID, endStream, int(cc.maxFrameSize), hdrs)</code></span>
<span class="codeline" id="line-8587"><code>	http2traceWroteHeaders(cs.trace)</code></span>
<span class="codeline" id="line-8588"><code>	return err</code></span>
<span class="codeline" id="line-8589"><code>}</code></span>
<span class="codeline" id="line-8590"><code></code></span>
<span class="codeline" id="line-8591"><code>// cleanupWriteRequest performs post-request tasks.</code></span>
<span class="codeline" id="line-8592"><code>//</code></span>
<span class="codeline" id="line-8593"><code>// If err (the result of writeRequest) is non-nil and the stream is not closed,</code></span>
<span class="codeline" id="line-8594"><code>// cleanupWriteRequest will send a reset to the peer.</code></span>
<span class="codeline" id="line-8595"><code>func (cs *http2clientStream) cleanupWriteRequest(err error) {</code></span>
<span class="codeline" id="line-8596"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-8597"><code></code></span>
<span class="codeline" id="line-8598"><code>	if cs.ID == 0 {</code></span>
<span class="codeline" id="line-8599"><code>		// We were canceled before creating the stream, so return our reservation.</code></span>
<span class="codeline" id="line-8600"><code>		cc.decrStreamReservations()</code></span>
<span class="codeline" id="line-8601"><code>	}</code></span>
<span class="codeline" id="line-8602"><code></code></span>
<span class="codeline" id="line-8603"><code>	// TODO: write h12Compare test showing whether</code></span>
<span class="codeline" id="line-8604"><code>	// Request.Body is closed by the Transport,</code></span>
<span class="codeline" id="line-8605"><code>	// and in multiple cases: server replies &lt;=299 and &gt;299</code></span>
<span class="codeline" id="line-8606"><code>	// while still writing request body</code></span>
<span class="codeline" id="line-8607"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8608"><code>	mustCloseBody := false</code></span>
<span class="codeline" id="line-8609"><code>	if cs.reqBody != nil &amp;&amp; cs.reqBodyClosed == nil {</code></span>
<span class="codeline" id="line-8610"><code>		mustCloseBody = true</code></span>
<span class="codeline" id="line-8611"><code>		cs.reqBodyClosed = make(chan struct{})</code></span>
<span class="codeline" id="line-8612"><code>	}</code></span>
<span class="codeline" id="line-8613"><code>	bodyClosed := cs.reqBodyClosed</code></span>
<span class="codeline" id="line-8614"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8615"><code>	if mustCloseBody {</code></span>
<span class="codeline" id="line-8616"><code>		cs.reqBody.Close()</code></span>
<span class="codeline" id="line-8617"><code>		close(bodyClosed)</code></span>
<span class="codeline" id="line-8618"><code>	}</code></span>
<span class="codeline" id="line-8619"><code>	if bodyClosed != nil {</code></span>
<span class="codeline" id="line-8620"><code>		&lt;-bodyClosed</code></span>
<span class="codeline" id="line-8621"><code>	}</code></span>
<span class="codeline" id="line-8622"><code></code></span>
<span class="codeline" id="line-8623"><code>	if err != nil &amp;&amp; cs.sentEndStream {</code></span>
<span class="codeline" id="line-8624"><code>		// If the connection is closed immediately after the response is read,</code></span>
<span class="codeline" id="line-8625"><code>		// we may be aborted before finishing up here. If the stream was closed</code></span>
<span class="codeline" id="line-8626"><code>		// cleanly on both sides, there is no error.</code></span>
<span class="codeline" id="line-8627"><code>		select {</code></span>
<span class="codeline" id="line-8628"><code>		case &lt;-cs.peerClosed:</code></span>
<span class="codeline" id="line-8629"><code>			err = nil</code></span>
<span class="codeline" id="line-8630"><code>		default:</code></span>
<span class="codeline" id="line-8631"><code>		}</code></span>
<span class="codeline" id="line-8632"><code>	}</code></span>
<span class="codeline" id="line-8633"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8634"><code>		cs.abortStream(err) // possibly redundant, but harmless</code></span>
<span class="codeline" id="line-8635"><code>		if cs.sentHeaders {</code></span>
<span class="codeline" id="line-8636"><code>			if se, ok := err.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-8637"><code>				if se.Cause != http2errFromPeer {</code></span>
<span class="codeline" id="line-8638"><code>					cc.writeStreamReset(cs.ID, se.Code, err)</code></span>
<span class="codeline" id="line-8639"><code>				}</code></span>
<span class="codeline" id="line-8640"><code>			} else {</code></span>
<span class="codeline" id="line-8641"><code>				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, err)</code></span>
<span class="codeline" id="line-8642"><code>			}</code></span>
<span class="codeline" id="line-8643"><code>		}</code></span>
<span class="codeline" id="line-8644"><code>		cs.bufPipe.CloseWithError(err) // no-op if already closed</code></span>
<span class="codeline" id="line-8645"><code>	} else {</code></span>
<span class="codeline" id="line-8646"><code>		if cs.sentHeaders &amp;&amp; !cs.sentEndStream {</code></span>
<span class="codeline" id="line-8647"><code>			cc.writeStreamReset(cs.ID, http2ErrCodeNo, nil)</code></span>
<span class="codeline" id="line-8648"><code>		}</code></span>
<span class="codeline" id="line-8649"><code>		cs.bufPipe.CloseWithError(http2errRequestCanceled)</code></span>
<span class="codeline" id="line-8650"><code>	}</code></span>
<span class="codeline" id="line-8651"><code>	if cs.ID != 0 {</code></span>
<span class="codeline" id="line-8652"><code>		cc.forgetStreamID(cs.ID)</code></span>
<span class="codeline" id="line-8653"><code>	}</code></span>
<span class="codeline" id="line-8654"><code></code></span>
<span class="codeline" id="line-8655"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-8656"><code>	werr := cc.werr</code></span>
<span class="codeline" id="line-8657"><code>	cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8658"><code>	if werr != nil {</code></span>
<span class="codeline" id="line-8659"><code>		cc.Close()</code></span>
<span class="codeline" id="line-8660"><code>	}</code></span>
<span class="codeline" id="line-8661"><code></code></span>
<span class="codeline" id="line-8662"><code>	close(cs.donec)</code></span>
<span class="codeline" id="line-8663"><code>}</code></span>
<span class="codeline" id="line-8664"><code></code></span>
<span class="codeline" id="line-8665"><code>// awaitOpenSlotForStreamLocked waits until len(streams) &lt; maxConcurrentStreams.</code></span>
<span class="codeline" id="line-8666"><code>// Must hold cc.mu.</code></span>
<span class="codeline" id="line-8667"><code>func (cc *http2ClientConn) awaitOpenSlotForStreamLocked(cs *http2clientStream) error {</code></span>
<span class="codeline" id="line-8668"><code>	for {</code></span>
<span class="codeline" id="line-8669"><code>		cc.lastActive = time.Now()</code></span>
<span class="codeline" id="line-8670"><code>		if cc.closed || !cc.canTakeNewRequestLocked() {</code></span>
<span class="codeline" id="line-8671"><code>			return http2errClientConnUnusable</code></span>
<span class="codeline" id="line-8672"><code>		}</code></span>
<span class="codeline" id="line-8673"><code>		cc.lastIdle = time.Time{}</code></span>
<span class="codeline" id="line-8674"><code>		if int64(len(cc.streams)) &lt; int64(cc.maxConcurrentStreams) {</code></span>
<span class="codeline" id="line-8675"><code>			return nil</code></span>
<span class="codeline" id="line-8676"><code>		}</code></span>
<span class="codeline" id="line-8677"><code>		cc.pendingRequests++</code></span>
<span class="codeline" id="line-8678"><code>		cc.cond.Wait()</code></span>
<span class="codeline" id="line-8679"><code>		cc.pendingRequests--</code></span>
<span class="codeline" id="line-8680"><code>		select {</code></span>
<span class="codeline" id="line-8681"><code>		case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8682"><code>			return cs.abortErr</code></span>
<span class="codeline" id="line-8683"><code>		default:</code></span>
<span class="codeline" id="line-8684"><code>		}</code></span>
<span class="codeline" id="line-8685"><code>	}</code></span>
<span class="codeline" id="line-8686"><code>}</code></span>
<span class="codeline" id="line-8687"><code></code></span>
<span class="codeline" id="line-8688"><code>// requires cc.wmu be held</code></span>
<span class="codeline" id="line-8689"><code>func (cc *http2ClientConn) writeHeaders(streamID uint32, endStream bool, maxFrameSize int, hdrs []byte) error {</code></span>
<span class="codeline" id="line-8690"><code>	first := true // first frame written (HEADERS is first, then CONTINUATION)</code></span>
<span class="codeline" id="line-8691"><code>	for len(hdrs) &gt; 0 &amp;&amp; cc.werr == nil {</code></span>
<span class="codeline" id="line-8692"><code>		chunk := hdrs</code></span>
<span class="codeline" id="line-8693"><code>		if len(chunk) &gt; maxFrameSize {</code></span>
<span class="codeline" id="line-8694"><code>			chunk = chunk[:maxFrameSize]</code></span>
<span class="codeline" id="line-8695"><code>		}</code></span>
<span class="codeline" id="line-8696"><code>		hdrs = hdrs[len(chunk):]</code></span>
<span class="codeline" id="line-8697"><code>		endHeaders := len(hdrs) == 0</code></span>
<span class="codeline" id="line-8698"><code>		if first {</code></span>
<span class="codeline" id="line-8699"><code>			cc.fr.WriteHeaders(http2HeadersFrameParam{</code></span>
<span class="codeline" id="line-8700"><code>				StreamID:      streamID,</code></span>
<span class="codeline" id="line-8701"><code>				BlockFragment: chunk,</code></span>
<span class="codeline" id="line-8702"><code>				EndStream:     endStream,</code></span>
<span class="codeline" id="line-8703"><code>				EndHeaders:    endHeaders,</code></span>
<span class="codeline" id="line-8704"><code>			})</code></span>
<span class="codeline" id="line-8705"><code>			first = false</code></span>
<span class="codeline" id="line-8706"><code>		} else {</code></span>
<span class="codeline" id="line-8707"><code>			cc.fr.WriteContinuation(streamID, endHeaders, chunk)</code></span>
<span class="codeline" id="line-8708"><code>		}</code></span>
<span class="codeline" id="line-8709"><code>	}</code></span>
<span class="codeline" id="line-8710"><code>	cc.bw.Flush()</code></span>
<span class="codeline" id="line-8711"><code>	return cc.werr</code></span>
<span class="codeline" id="line-8712"><code>}</code></span>
<span class="codeline" id="line-8713"><code></code></span>
<span class="codeline" id="line-8714"><code>// internal error values; they don't escape to callers</code></span>
<span class="codeline" id="line-8715"><code>var (</code></span>
<span class="codeline" id="line-8716"><code>	// abort request body write; don't send cancel</code></span>
<span class="codeline" id="line-8717"><code>	http2errStopReqBodyWrite = errors.New("http2: aborting request body write")</code></span>
<span class="codeline" id="line-8718"><code></code></span>
<span class="codeline" id="line-8719"><code>	// abort request body write, but send stream reset of cancel.</code></span>
<span class="codeline" id="line-8720"><code>	http2errStopReqBodyWriteAndCancel = errors.New("http2: canceling request")</code></span>
<span class="codeline" id="line-8721"><code></code></span>
<span class="codeline" id="line-8722"><code>	http2errReqBodyTooLong = errors.New("http2: request body larger than specified content length")</code></span>
<span class="codeline" id="line-8723"><code>)</code></span>
<span class="codeline" id="line-8724"><code></code></span>
<span class="codeline" id="line-8725"><code>// frameScratchBufferLen returns the length of a buffer to use for</code></span>
<span class="codeline" id="line-8726"><code>// outgoing request bodies to read/write to/from.</code></span>
<span class="codeline" id="line-8727"><code>//</code></span>
<span class="codeline" id="line-8728"><code>// It returns max(1, min(peer's advertised max frame size,</code></span>
<span class="codeline" id="line-8729"><code>// Request.ContentLength+1, 512KB)).</code></span>
<span class="codeline" id="line-8730"><code>func (cs *http2clientStream) frameScratchBufferLen(maxFrameSize int) int {</code></span>
<span class="codeline" id="line-8731"><code>	const max = 512 &lt;&lt; 10</code></span>
<span class="codeline" id="line-8732"><code>	n := int64(maxFrameSize)</code></span>
<span class="codeline" id="line-8733"><code>	if n &gt; max {</code></span>
<span class="codeline" id="line-8734"><code>		n = max</code></span>
<span class="codeline" id="line-8735"><code>	}</code></span>
<span class="codeline" id="line-8736"><code>	if cl := cs.reqBodyContentLength; cl != -1 &amp;&amp; cl+1 &lt; n {</code></span>
<span class="codeline" id="line-8737"><code>		// Add an extra byte past the declared content-length to</code></span>
<span class="codeline" id="line-8738"><code>		// give the caller's Request.Body io.Reader a chance to</code></span>
<span class="codeline" id="line-8739"><code>		// give us more bytes than they declared, so we can catch it</code></span>
<span class="codeline" id="line-8740"><code>		// early.</code></span>
<span class="codeline" id="line-8741"><code>		n = cl + 1</code></span>
<span class="codeline" id="line-8742"><code>	}</code></span>
<span class="codeline" id="line-8743"><code>	if n &lt; 1 {</code></span>
<span class="codeline" id="line-8744"><code>		return 1</code></span>
<span class="codeline" id="line-8745"><code>	}</code></span>
<span class="codeline" id="line-8746"><code>	return int(n) // doesn't truncate; max is 512K</code></span>
<span class="codeline" id="line-8747"><code>}</code></span>
<span class="codeline" id="line-8748"><code></code></span>
<span class="codeline" id="line-8749"><code>// Seven bufPools manage different frame sizes. This helps to avoid scenarios where long-running</code></span>
<span class="codeline" id="line-8750"><code>// streaming requests using small frame sizes occupy large buffers initially allocated for prior</code></span>
<span class="codeline" id="line-8751"><code>// requests needing big buffers. The size ranges are as follows:</code></span>
<span class="codeline" id="line-8752"><code>// {0 KB, 16 KB], {16 KB, 32 KB], {32 KB, 64 KB], {64 KB, 128 KB], {128 KB, 256 KB],</code></span>
<span class="codeline" id="line-8753"><code>// {256 KB, 512 KB], {512 KB, infinity}</code></span>
<span class="codeline" id="line-8754"><code>// In practice, the maximum scratch buffer size should not exceed 512 KB due to</code></span>
<span class="codeline" id="line-8755"><code>// frameScratchBufferLen(maxFrameSize), thus the "infinity pool" should never be used.</code></span>
<span class="codeline" id="line-8756"><code>// It exists mainly as a safety measure, for potential future increases in max buffer size.</code></span>
<span class="codeline" id="line-8757"><code>var http2bufPools [7]sync.Pool // of *[]byte</code></span>
<span class="codeline" id="line-8758"><code></code></span>
<span class="codeline" id="line-8759"><code>func http2bufPoolIndex(size int) int {</code></span>
<span class="codeline" id="line-8760"><code>	if size &lt;= 16384 {</code></span>
<span class="codeline" id="line-8761"><code>		return 0</code></span>
<span class="codeline" id="line-8762"><code>	}</code></span>
<span class="codeline" id="line-8763"><code>	size -= 1</code></span>
<span class="codeline" id="line-8764"><code>	bits := bits.Len(uint(size))</code></span>
<span class="codeline" id="line-8765"><code>	index := bits - 14</code></span>
<span class="codeline" id="line-8766"><code>	if index &gt;= len(http2bufPools) {</code></span>
<span class="codeline" id="line-8767"><code>		return len(http2bufPools) - 1</code></span>
<span class="codeline" id="line-8768"><code>	}</code></span>
<span class="codeline" id="line-8769"><code>	return index</code></span>
<span class="codeline" id="line-8770"><code>}</code></span>
<span class="codeline" id="line-8771"><code></code></span>
<span class="codeline" id="line-8772"><code>func (cs *http2clientStream) writeRequestBody(req *Request) (err error) {</code></span>
<span class="codeline" id="line-8773"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-8774"><code>	body := cs.reqBody</code></span>
<span class="codeline" id="line-8775"><code>	sentEnd := false // whether we sent the final DATA frame w/ END_STREAM</code></span>
<span class="codeline" id="line-8776"><code></code></span>
<span class="codeline" id="line-8777"><code>	hasTrailers := req.Trailer != nil</code></span>
<span class="codeline" id="line-8778"><code>	remainLen := cs.reqBodyContentLength</code></span>
<span class="codeline" id="line-8779"><code>	hasContentLen := remainLen != -1</code></span>
<span class="codeline" id="line-8780"><code></code></span>
<span class="codeline" id="line-8781"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8782"><code>	maxFrameSize := int(cc.maxFrameSize)</code></span>
<span class="codeline" id="line-8783"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8784"><code></code></span>
<span class="codeline" id="line-8785"><code>	// Scratch buffer for reading into &amp; writing from.</code></span>
<span class="codeline" id="line-8786"><code>	scratchLen := cs.frameScratchBufferLen(maxFrameSize)</code></span>
<span class="codeline" id="line-8787"><code>	var buf []byte</code></span>
<span class="codeline" id="line-8788"><code>	index := http2bufPoolIndex(scratchLen)</code></span>
<span class="codeline" id="line-8789"><code>	if bp, ok := http2bufPools[index].Get().(*[]byte); ok &amp;&amp; len(*bp) &gt;= scratchLen {</code></span>
<span class="codeline" id="line-8790"><code>		defer http2bufPools[index].Put(bp)</code></span>
<span class="codeline" id="line-8791"><code>		buf = *bp</code></span>
<span class="codeline" id="line-8792"><code>	} else {</code></span>
<span class="codeline" id="line-8793"><code>		buf = make([]byte, scratchLen)</code></span>
<span class="codeline" id="line-8794"><code>		defer http2bufPools[index].Put(&amp;buf)</code></span>
<span class="codeline" id="line-8795"><code>	}</code></span>
<span class="codeline" id="line-8796"><code></code></span>
<span class="codeline" id="line-8797"><code>	var sawEOF bool</code></span>
<span class="codeline" id="line-8798"><code>	for !sawEOF {</code></span>
<span class="codeline" id="line-8799"><code>		n, err := body.Read(buf)</code></span>
<span class="codeline" id="line-8800"><code>		if hasContentLen {</code></span>
<span class="codeline" id="line-8801"><code>			remainLen -= int64(n)</code></span>
<span class="codeline" id="line-8802"><code>			if remainLen == 0 &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-8803"><code>				// The request body's Content-Length was predeclared and</code></span>
<span class="codeline" id="line-8804"><code>				// we just finished reading it all, but the underlying io.Reader</code></span>
<span class="codeline" id="line-8805"><code>				// returned the final chunk with a nil error (which is one of</code></span>
<span class="codeline" id="line-8806"><code>				// the two valid things a Reader can do at EOF). Because we'd prefer</code></span>
<span class="codeline" id="line-8807"><code>				// to send the END_STREAM bit early, double-check that we're actually</code></span>
<span class="codeline" id="line-8808"><code>				// at EOF. Subsequent reads should return (0, EOF) at this point.</code></span>
<span class="codeline" id="line-8809"><code>				// If either value is different, we return an error in one of two ways below.</code></span>
<span class="codeline" id="line-8810"><code>				var scratch [1]byte</code></span>
<span class="codeline" id="line-8811"><code>				var n1 int</code></span>
<span class="codeline" id="line-8812"><code>				n1, err = body.Read(scratch[:])</code></span>
<span class="codeline" id="line-8813"><code>				remainLen -= int64(n1)</code></span>
<span class="codeline" id="line-8814"><code>			}</code></span>
<span class="codeline" id="line-8815"><code>			if remainLen &lt; 0 {</code></span>
<span class="codeline" id="line-8816"><code>				err = http2errReqBodyTooLong</code></span>
<span class="codeline" id="line-8817"><code>				return err</code></span>
<span class="codeline" id="line-8818"><code>			}</code></span>
<span class="codeline" id="line-8819"><code>		}</code></span>
<span class="codeline" id="line-8820"><code>		if err != nil {</code></span>
<span class="codeline" id="line-8821"><code>			cc.mu.Lock()</code></span>
<span class="codeline" id="line-8822"><code>			bodyClosed := cs.reqBodyClosed != nil</code></span>
<span class="codeline" id="line-8823"><code>			cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8824"><code>			switch {</code></span>
<span class="codeline" id="line-8825"><code>			case bodyClosed:</code></span>
<span class="codeline" id="line-8826"><code>				return http2errStopReqBodyWrite</code></span>
<span class="codeline" id="line-8827"><code>			case err == io.EOF:</code></span>
<span class="codeline" id="line-8828"><code>				sawEOF = true</code></span>
<span class="codeline" id="line-8829"><code>				err = nil</code></span>
<span class="codeline" id="line-8830"><code>			default:</code></span>
<span class="codeline" id="line-8831"><code>				return err</code></span>
<span class="codeline" id="line-8832"><code>			}</code></span>
<span class="codeline" id="line-8833"><code>		}</code></span>
<span class="codeline" id="line-8834"><code></code></span>
<span class="codeline" id="line-8835"><code>		remain := buf[:n]</code></span>
<span class="codeline" id="line-8836"><code>		for len(remain) &gt; 0 &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-8837"><code>			var allowed int32</code></span>
<span class="codeline" id="line-8838"><code>			allowed, err = cs.awaitFlowControl(len(remain))</code></span>
<span class="codeline" id="line-8839"><code>			if err != nil {</code></span>
<span class="codeline" id="line-8840"><code>				return err</code></span>
<span class="codeline" id="line-8841"><code>			}</code></span>
<span class="codeline" id="line-8842"><code>			cc.wmu.Lock()</code></span>
<span class="codeline" id="line-8843"><code>			data := remain[:allowed]</code></span>
<span class="codeline" id="line-8844"><code>			remain = remain[allowed:]</code></span>
<span class="codeline" id="line-8845"><code>			sentEnd = sawEOF &amp;&amp; len(remain) == 0 &amp;&amp; !hasTrailers</code></span>
<span class="codeline" id="line-8846"><code>			err = cc.fr.WriteData(cs.ID, sentEnd, data)</code></span>
<span class="codeline" id="line-8847"><code>			if err == nil {</code></span>
<span class="codeline" id="line-8848"><code>				// TODO(bradfitz): this flush is for latency, not bandwidth.</code></span>
<span class="codeline" id="line-8849"><code>				// Most requests won't need this. Make this opt-in or</code></span>
<span class="codeline" id="line-8850"><code>				// opt-out?  Use some heuristic on the body type? Nagel-like</code></span>
<span class="codeline" id="line-8851"><code>				// timers?  Based on 'n'? Only last chunk of this for loop,</code></span>
<span class="codeline" id="line-8852"><code>				// unless flow control tokens are low? For now, always.</code></span>
<span class="codeline" id="line-8853"><code>				// If we change this, see comment below.</code></span>
<span class="codeline" id="line-8854"><code>				err = cc.bw.Flush()</code></span>
<span class="codeline" id="line-8855"><code>			}</code></span>
<span class="codeline" id="line-8856"><code>			cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8857"><code>		}</code></span>
<span class="codeline" id="line-8858"><code>		if err != nil {</code></span>
<span class="codeline" id="line-8859"><code>			return err</code></span>
<span class="codeline" id="line-8860"><code>		}</code></span>
<span class="codeline" id="line-8861"><code>	}</code></span>
<span class="codeline" id="line-8862"><code></code></span>
<span class="codeline" id="line-8863"><code>	if sentEnd {</code></span>
<span class="codeline" id="line-8864"><code>		// Already sent END_STREAM (which implies we have no</code></span>
<span class="codeline" id="line-8865"><code>		// trailers) and flushed, because currently all</code></span>
<span class="codeline" id="line-8866"><code>		// WriteData frames above get a flush. So we're done.</code></span>
<span class="codeline" id="line-8867"><code>		return nil</code></span>
<span class="codeline" id="line-8868"><code>	}</code></span>
<span class="codeline" id="line-8869"><code></code></span>
<span class="codeline" id="line-8870"><code>	// Since the RoundTrip contract permits the caller to "mutate or reuse"</code></span>
<span class="codeline" id="line-8871"><code>	// a request after the Response's Body is closed, verify that this hasn't</code></span>
<span class="codeline" id="line-8872"><code>	// happened before accessing the trailers.</code></span>
<span class="codeline" id="line-8873"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8874"><code>	trailer := req.Trailer</code></span>
<span class="codeline" id="line-8875"><code>	err = cs.abortErr</code></span>
<span class="codeline" id="line-8876"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8877"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8878"><code>		return err</code></span>
<span class="codeline" id="line-8879"><code>	}</code></span>
<span class="codeline" id="line-8880"><code></code></span>
<span class="codeline" id="line-8881"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-8882"><code>	defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-8883"><code>	var trls []byte</code></span>
<span class="codeline" id="line-8884"><code>	if len(trailer) &gt; 0 {</code></span>
<span class="codeline" id="line-8885"><code>		trls, err = cc.encodeTrailers(trailer)</code></span>
<span class="codeline" id="line-8886"><code>		if err != nil {</code></span>
<span class="codeline" id="line-8887"><code>			return err</code></span>
<span class="codeline" id="line-8888"><code>		}</code></span>
<span class="codeline" id="line-8889"><code>	}</code></span>
<span class="codeline" id="line-8890"><code></code></span>
<span class="codeline" id="line-8891"><code>	// Two ways to send END_STREAM: either with trailers, or</code></span>
<span class="codeline" id="line-8892"><code>	// with an empty DATA frame.</code></span>
<span class="codeline" id="line-8893"><code>	if len(trls) &gt; 0 {</code></span>
<span class="codeline" id="line-8894"><code>		err = cc.writeHeaders(cs.ID, true, maxFrameSize, trls)</code></span>
<span class="codeline" id="line-8895"><code>	} else {</code></span>
<span class="codeline" id="line-8896"><code>		err = cc.fr.WriteData(cs.ID, true, nil)</code></span>
<span class="codeline" id="line-8897"><code>	}</code></span>
<span class="codeline" id="line-8898"><code>	if ferr := cc.bw.Flush(); ferr != nil &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-8899"><code>		err = ferr</code></span>
<span class="codeline" id="line-8900"><code>	}</code></span>
<span class="codeline" id="line-8901"><code>	return err</code></span>
<span class="codeline" id="line-8902"><code>}</code></span>
<span class="codeline" id="line-8903"><code></code></span>
<span class="codeline" id="line-8904"><code>// awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow</code></span>
<span class="codeline" id="line-8905"><code>// control tokens from the server.</code></span>
<span class="codeline" id="line-8906"><code>// It returns either the non-zero number of tokens taken or an error</code></span>
<span class="codeline" id="line-8907"><code>// if the stream is dead.</code></span>
<span class="codeline" id="line-8908"><code>func (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {</code></span>
<span class="codeline" id="line-8909"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-8910"><code>	ctx := cs.ctx</code></span>
<span class="codeline" id="line-8911"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-8912"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-8913"><code>	for {</code></span>
<span class="codeline" id="line-8914"><code>		if cc.closed {</code></span>
<span class="codeline" id="line-8915"><code>			return 0, http2errClientConnClosed</code></span>
<span class="codeline" id="line-8916"><code>		}</code></span>
<span class="codeline" id="line-8917"><code>		if cs.reqBodyClosed != nil {</code></span>
<span class="codeline" id="line-8918"><code>			return 0, http2errStopReqBodyWrite</code></span>
<span class="codeline" id="line-8919"><code>		}</code></span>
<span class="codeline" id="line-8920"><code>		select {</code></span>
<span class="codeline" id="line-8921"><code>		case &lt;-cs.abort:</code></span>
<span class="codeline" id="line-8922"><code>			return 0, cs.abortErr</code></span>
<span class="codeline" id="line-8923"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-8924"><code>			return 0, ctx.Err()</code></span>
<span class="codeline" id="line-8925"><code>		case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-8926"><code>			return 0, http2errRequestCanceled</code></span>
<span class="codeline" id="line-8927"><code>		default:</code></span>
<span class="codeline" id="line-8928"><code>		}</code></span>
<span class="codeline" id="line-8929"><code>		if a := cs.flow.available(); a &gt; 0 {</code></span>
<span class="codeline" id="line-8930"><code>			take := a</code></span>
<span class="codeline" id="line-8931"><code>			if int(take) &gt; maxBytes {</code></span>
<span class="codeline" id="line-8932"><code></code></span>
<span class="codeline" id="line-8933"><code>				take = int32(maxBytes) // can't truncate int; take is int32</code></span>
<span class="codeline" id="line-8934"><code>			}</code></span>
<span class="codeline" id="line-8935"><code>			if take &gt; int32(cc.maxFrameSize) {</code></span>
<span class="codeline" id="line-8936"><code>				take = int32(cc.maxFrameSize)</code></span>
<span class="codeline" id="line-8937"><code>			}</code></span>
<span class="codeline" id="line-8938"><code>			cs.flow.take(take)</code></span>
<span class="codeline" id="line-8939"><code>			return take, nil</code></span>
<span class="codeline" id="line-8940"><code>		}</code></span>
<span class="codeline" id="line-8941"><code>		cc.cond.Wait()</code></span>
<span class="codeline" id="line-8942"><code>	}</code></span>
<span class="codeline" id="line-8943"><code>}</code></span>
<span class="codeline" id="line-8944"><code></code></span>
<span class="codeline" id="line-8945"><code>var http2errNilRequestURL = errors.New("http2: Request.URI is nil")</code></span>
<span class="codeline" id="line-8946"><code></code></span>
<span class="codeline" id="line-8947"><code>// requires cc.wmu be held.</code></span>
<span class="codeline" id="line-8948"><code>func (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error) {</code></span>
<span class="codeline" id="line-8949"><code>	cc.hbuf.Reset()</code></span>
<span class="codeline" id="line-8950"><code>	if req.URL == nil {</code></span>
<span class="codeline" id="line-8951"><code>		return nil, http2errNilRequestURL</code></span>
<span class="codeline" id="line-8952"><code>	}</code></span>
<span class="codeline" id="line-8953"><code></code></span>
<span class="codeline" id="line-8954"><code>	host := req.Host</code></span>
<span class="codeline" id="line-8955"><code>	if host == "" {</code></span>
<span class="codeline" id="line-8956"><code>		host = req.URL.Host</code></span>
<span class="codeline" id="line-8957"><code>	}</code></span>
<span class="codeline" id="line-8958"><code>	host, err := httpguts.PunycodeHostPort(host)</code></span>
<span class="codeline" id="line-8959"><code>	if err != nil {</code></span>
<span class="codeline" id="line-8960"><code>		return nil, err</code></span>
<span class="codeline" id="line-8961"><code>	}</code></span>
<span class="codeline" id="line-8962"><code>	if !httpguts.ValidHostHeader(host) {</code></span>
<span class="codeline" id="line-8963"><code>		return nil, errors.New("http2: invalid Host header")</code></span>
<span class="codeline" id="line-8964"><code>	}</code></span>
<span class="codeline" id="line-8965"><code></code></span>
<span class="codeline" id="line-8966"><code>	var path string</code></span>
<span class="codeline" id="line-8967"><code>	if req.Method != "CONNECT" {</code></span>
<span class="codeline" id="line-8968"><code>		path = req.URL.RequestURI()</code></span>
<span class="codeline" id="line-8969"><code>		if !http2validPseudoPath(path) {</code></span>
<span class="codeline" id="line-8970"><code>			orig := path</code></span>
<span class="codeline" id="line-8971"><code>			path = strings.TrimPrefix(path, req.URL.Scheme+"://"+host)</code></span>
<span class="codeline" id="line-8972"><code>			if !http2validPseudoPath(path) {</code></span>
<span class="codeline" id="line-8973"><code>				if req.URL.Opaque != "" {</code></span>
<span class="codeline" id="line-8974"><code>					return nil, fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque)</code></span>
<span class="codeline" id="line-8975"><code>				} else {</code></span>
<span class="codeline" id="line-8976"><code>					return nil, fmt.Errorf("invalid request :path %q", orig)</code></span>
<span class="codeline" id="line-8977"><code>				}</code></span>
<span class="codeline" id="line-8978"><code>			}</code></span>
<span class="codeline" id="line-8979"><code>		}</code></span>
<span class="codeline" id="line-8980"><code>	}</code></span>
<span class="codeline" id="line-8981"><code></code></span>
<span class="codeline" id="line-8982"><code>	// Check for any invalid headers and return an error before we</code></span>
<span class="codeline" id="line-8983"><code>	// potentially pollute our hpack state. (We want to be able to</code></span>
<span class="codeline" id="line-8984"><code>	// continue to reuse the hpack encoder for future requests)</code></span>
<span class="codeline" id="line-8985"><code>	for k, vv := range req.Header {</code></span>
<span class="codeline" id="line-8986"><code>		if !httpguts.ValidHeaderFieldName(k) {</code></span>
<span class="codeline" id="line-8987"><code>			return nil, fmt.Errorf("invalid HTTP header name %q", k)</code></span>
<span class="codeline" id="line-8988"><code>		}</code></span>
<span class="codeline" id="line-8989"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-8990"><code>			if !httpguts.ValidHeaderFieldValue(v) {</code></span>
<span class="codeline" id="line-8991"><code>				// Don't include the value in the error, because it may be sensitive.</code></span>
<span class="codeline" id="line-8992"><code>				return nil, fmt.Errorf("invalid HTTP header value for header %q", k)</code></span>
<span class="codeline" id="line-8993"><code>			}</code></span>
<span class="codeline" id="line-8994"><code>		}</code></span>
<span class="codeline" id="line-8995"><code>	}</code></span>
<span class="codeline" id="line-8996"><code></code></span>
<span class="codeline" id="line-8997"><code>	enumerateHeaders := func(f func(name, value string)) {</code></span>
<span class="codeline" id="line-8998"><code>		// 8.1.2.3 Request Pseudo-Header Fields</code></span>
<span class="codeline" id="line-8999"><code>		// The :path pseudo-header field includes the path and query parts of the</code></span>
<span class="codeline" id="line-9000"><code>		// target URI (the path-absolute production and optionally a '?' character</code></span>
<span class="codeline" id="line-9001"><code>		// followed by the query production, see Sections 3.3 and 3.4 of</code></span>
<span class="codeline" id="line-9002"><code>		// [RFC3986]).</code></span>
<span class="codeline" id="line-9003"><code>		f(":authority", host)</code></span>
<span class="codeline" id="line-9004"><code>		m := req.Method</code></span>
<span class="codeline" id="line-9005"><code>		if m == "" {</code></span>
<span class="codeline" id="line-9006"><code>			m = MethodGet</code></span>
<span class="codeline" id="line-9007"><code>		}</code></span>
<span class="codeline" id="line-9008"><code>		f(":method", m)</code></span>
<span class="codeline" id="line-9009"><code>		if req.Method != "CONNECT" {</code></span>
<span class="codeline" id="line-9010"><code>			f(":path", path)</code></span>
<span class="codeline" id="line-9011"><code>			f(":scheme", req.URL.Scheme)</code></span>
<span class="codeline" id="line-9012"><code>		}</code></span>
<span class="codeline" id="line-9013"><code>		if trailers != "" {</code></span>
<span class="codeline" id="line-9014"><code>			f("trailer", trailers)</code></span>
<span class="codeline" id="line-9015"><code>		}</code></span>
<span class="codeline" id="line-9016"><code></code></span>
<span class="codeline" id="line-9017"><code>		var didUA bool</code></span>
<span class="codeline" id="line-9018"><code>		for k, vv := range req.Header {</code></span>
<span class="codeline" id="line-9019"><code>			if http2asciiEqualFold(k, "host") || http2asciiEqualFold(k, "content-length") {</code></span>
<span class="codeline" id="line-9020"><code>				// Host is :authority, already sent.</code></span>
<span class="codeline" id="line-9021"><code>				// Content-Length is automatic, set below.</code></span>
<span class="codeline" id="line-9022"><code>				continue</code></span>
<span class="codeline" id="line-9023"><code>			} else if http2asciiEqualFold(k, "connection") ||</code></span>
<span class="codeline" id="line-9024"><code>				http2asciiEqualFold(k, "proxy-connection") ||</code></span>
<span class="codeline" id="line-9025"><code>				http2asciiEqualFold(k, "transfer-encoding") ||</code></span>
<span class="codeline" id="line-9026"><code>				http2asciiEqualFold(k, "upgrade") ||</code></span>
<span class="codeline" id="line-9027"><code>				http2asciiEqualFold(k, "keep-alive") {</code></span>
<span class="codeline" id="line-9028"><code>				// Per 8.1.2.2 Connection-Specific Header</code></span>
<span class="codeline" id="line-9029"><code>				// Fields, don't send connection-specific</code></span>
<span class="codeline" id="line-9030"><code>				// fields. We have already checked if any</code></span>
<span class="codeline" id="line-9031"><code>				// are error-worthy so just ignore the rest.</code></span>
<span class="codeline" id="line-9032"><code>				continue</code></span>
<span class="codeline" id="line-9033"><code>			} else if http2asciiEqualFold(k, "user-agent") {</code></span>
<span class="codeline" id="line-9034"><code>				// Match Go's http1 behavior: at most one</code></span>
<span class="codeline" id="line-9035"><code>				// User-Agent. If set to nil or empty string,</code></span>
<span class="codeline" id="line-9036"><code>				// then omit it. Otherwise if not mentioned,</code></span>
<span class="codeline" id="line-9037"><code>				// include the default (below).</code></span>
<span class="codeline" id="line-9038"><code>				didUA = true</code></span>
<span class="codeline" id="line-9039"><code>				if len(vv) &lt; 1 {</code></span>
<span class="codeline" id="line-9040"><code>					continue</code></span>
<span class="codeline" id="line-9041"><code>				}</code></span>
<span class="codeline" id="line-9042"><code>				vv = vv[:1]</code></span>
<span class="codeline" id="line-9043"><code>				if vv[0] == "" {</code></span>
<span class="codeline" id="line-9044"><code>					continue</code></span>
<span class="codeline" id="line-9045"><code>				}</code></span>
<span class="codeline" id="line-9046"><code>			} else if http2asciiEqualFold(k, "cookie") {</code></span>
<span class="codeline" id="line-9047"><code>				// Per 8.1.2.5 To allow for better compression efficiency, the</code></span>
<span class="codeline" id="line-9048"><code>				// Cookie header field MAY be split into separate header fields,</code></span>
<span class="codeline" id="line-9049"><code>				// each with one or more cookie-pairs.</code></span>
<span class="codeline" id="line-9050"><code>				for _, v := range vv {</code></span>
<span class="codeline" id="line-9051"><code>					for {</code></span>
<span class="codeline" id="line-9052"><code>						p := strings.IndexByte(v, ';')</code></span>
<span class="codeline" id="line-9053"><code>						if p &lt; 0 {</code></span>
<span class="codeline" id="line-9054"><code>							break</code></span>
<span class="codeline" id="line-9055"><code>						}</code></span>
<span class="codeline" id="line-9056"><code>						f("cookie", v[:p])</code></span>
<span class="codeline" id="line-9057"><code>						p++</code></span>
<span class="codeline" id="line-9058"><code>						// strip space after semicolon if any.</code></span>
<span class="codeline" id="line-9059"><code>						for p+1 &lt;= len(v) &amp;&amp; v[p] == ' ' {</code></span>
<span class="codeline" id="line-9060"><code>							p++</code></span>
<span class="codeline" id="line-9061"><code>						}</code></span>
<span class="codeline" id="line-9062"><code>						v = v[p:]</code></span>
<span class="codeline" id="line-9063"><code>					}</code></span>
<span class="codeline" id="line-9064"><code>					if len(v) &gt; 0 {</code></span>
<span class="codeline" id="line-9065"><code>						f("cookie", v)</code></span>
<span class="codeline" id="line-9066"><code>					}</code></span>
<span class="codeline" id="line-9067"><code>				}</code></span>
<span class="codeline" id="line-9068"><code>				continue</code></span>
<span class="codeline" id="line-9069"><code>			}</code></span>
<span class="codeline" id="line-9070"><code></code></span>
<span class="codeline" id="line-9071"><code>			for _, v := range vv {</code></span>
<span class="codeline" id="line-9072"><code>				f(k, v)</code></span>
<span class="codeline" id="line-9073"><code>			}</code></span>
<span class="codeline" id="line-9074"><code>		}</code></span>
<span class="codeline" id="line-9075"><code>		if http2shouldSendReqContentLength(req.Method, contentLength) {</code></span>
<span class="codeline" id="line-9076"><code>			f("content-length", strconv.FormatInt(contentLength, 10))</code></span>
<span class="codeline" id="line-9077"><code>		}</code></span>
<span class="codeline" id="line-9078"><code>		if addGzipHeader {</code></span>
<span class="codeline" id="line-9079"><code>			f("accept-encoding", "gzip")</code></span>
<span class="codeline" id="line-9080"><code>		}</code></span>
<span class="codeline" id="line-9081"><code>		if !didUA {</code></span>
<span class="codeline" id="line-9082"><code>			f("user-agent", http2defaultUserAgent)</code></span>
<span class="codeline" id="line-9083"><code>		}</code></span>
<span class="codeline" id="line-9084"><code>	}</code></span>
<span class="codeline" id="line-9085"><code></code></span>
<span class="codeline" id="line-9086"><code>	// Do a first pass over the headers counting bytes to ensure</code></span>
<span class="codeline" id="line-9087"><code>	// we don't exceed cc.peerMaxHeaderListSize. This is done as a</code></span>
<span class="codeline" id="line-9088"><code>	// separate pass before encoding the headers to prevent</code></span>
<span class="codeline" id="line-9089"><code>	// modifying the hpack state.</code></span>
<span class="codeline" id="line-9090"><code>	hlSize := uint64(0)</code></span>
<span class="codeline" id="line-9091"><code>	enumerateHeaders(func(name, value string) {</code></span>
<span class="codeline" id="line-9092"><code>		hf := hpack.HeaderField{Name: name, Value: value}</code></span>
<span class="codeline" id="line-9093"><code>		hlSize += uint64(hf.Size())</code></span>
<span class="codeline" id="line-9094"><code>	})</code></span>
<span class="codeline" id="line-9095"><code></code></span>
<span class="codeline" id="line-9096"><code>	if hlSize &gt; cc.peerMaxHeaderListSize {</code></span>
<span class="codeline" id="line-9097"><code>		return nil, http2errRequestHeaderListSize</code></span>
<span class="codeline" id="line-9098"><code>	}</code></span>
<span class="codeline" id="line-9099"><code></code></span>
<span class="codeline" id="line-9100"><code>	trace := httptrace.ContextClientTrace(req.Context())</code></span>
<span class="codeline" id="line-9101"><code>	traceHeaders := http2traceHasWroteHeaderField(trace)</code></span>
<span class="codeline" id="line-9102"><code></code></span>
<span class="codeline" id="line-9103"><code>	// Header list size is ok. Write the headers.</code></span>
<span class="codeline" id="line-9104"><code>	enumerateHeaders(func(name, value string) {</code></span>
<span class="codeline" id="line-9105"><code>		name, ascii := http2lowerHeader(name)</code></span>
<span class="codeline" id="line-9106"><code>		if !ascii {</code></span>
<span class="codeline" id="line-9107"><code>			// Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header</code></span>
<span class="codeline" id="line-9108"><code>			// field names have to be ASCII characters (just as in HTTP/1.x).</code></span>
<span class="codeline" id="line-9109"><code>			return</code></span>
<span class="codeline" id="line-9110"><code>		}</code></span>
<span class="codeline" id="line-9111"><code>		cc.writeHeader(name, value)</code></span>
<span class="codeline" id="line-9112"><code>		if traceHeaders {</code></span>
<span class="codeline" id="line-9113"><code>			http2traceWroteHeaderField(trace, name, value)</code></span>
<span class="codeline" id="line-9114"><code>		}</code></span>
<span class="codeline" id="line-9115"><code>	})</code></span>
<span class="codeline" id="line-9116"><code></code></span>
<span class="codeline" id="line-9117"><code>	return cc.hbuf.Bytes(), nil</code></span>
<span class="codeline" id="line-9118"><code>}</code></span>
<span class="codeline" id="line-9119"><code></code></span>
<span class="codeline" id="line-9120"><code>// shouldSendReqContentLength reports whether the http2.Transport should send</code></span>
<span class="codeline" id="line-9121"><code>// a "content-length" request header. This logic is basically a copy of the net/http</code></span>
<span class="codeline" id="line-9122"><code>// transferWriter.shouldSendContentLength.</code></span>
<span class="codeline" id="line-9123"><code>// The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).</code></span>
<span class="codeline" id="line-9124"><code>// -1 means unknown.</code></span>
<span class="codeline" id="line-9125"><code>func http2shouldSendReqContentLength(method string, contentLength int64) bool {</code></span>
<span class="codeline" id="line-9126"><code>	if contentLength &gt; 0 {</code></span>
<span class="codeline" id="line-9127"><code>		return true</code></span>
<span class="codeline" id="line-9128"><code>	}</code></span>
<span class="codeline" id="line-9129"><code>	if contentLength &lt; 0 {</code></span>
<span class="codeline" id="line-9130"><code>		return false</code></span>
<span class="codeline" id="line-9131"><code>	}</code></span>
<span class="codeline" id="line-9132"><code>	// For zero bodies, whether we send a content-length depends on the method.</code></span>
<span class="codeline" id="line-9133"><code>	// It also kinda doesn't matter for http2 either way, with END_STREAM.</code></span>
<span class="codeline" id="line-9134"><code>	switch method {</code></span>
<span class="codeline" id="line-9135"><code>	case "POST", "PUT", "PATCH":</code></span>
<span class="codeline" id="line-9136"><code>		return true</code></span>
<span class="codeline" id="line-9137"><code>	default:</code></span>
<span class="codeline" id="line-9138"><code>		return false</code></span>
<span class="codeline" id="line-9139"><code>	}</code></span>
<span class="codeline" id="line-9140"><code>}</code></span>
<span class="codeline" id="line-9141"><code></code></span>
<span class="codeline" id="line-9142"><code>// requires cc.wmu be held.</code></span>
<span class="codeline" id="line-9143"><code>func (cc *http2ClientConn) encodeTrailers(trailer Header) ([]byte, error) {</code></span>
<span class="codeline" id="line-9144"><code>	cc.hbuf.Reset()</code></span>
<span class="codeline" id="line-9145"><code></code></span>
<span class="codeline" id="line-9146"><code>	hlSize := uint64(0)</code></span>
<span class="codeline" id="line-9147"><code>	for k, vv := range trailer {</code></span>
<span class="codeline" id="line-9148"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-9149"><code>			hf := hpack.HeaderField{Name: k, Value: v}</code></span>
<span class="codeline" id="line-9150"><code>			hlSize += uint64(hf.Size())</code></span>
<span class="codeline" id="line-9151"><code>		}</code></span>
<span class="codeline" id="line-9152"><code>	}</code></span>
<span class="codeline" id="line-9153"><code>	if hlSize &gt; cc.peerMaxHeaderListSize {</code></span>
<span class="codeline" id="line-9154"><code>		return nil, http2errRequestHeaderListSize</code></span>
<span class="codeline" id="line-9155"><code>	}</code></span>
<span class="codeline" id="line-9156"><code></code></span>
<span class="codeline" id="line-9157"><code>	for k, vv := range trailer {</code></span>
<span class="codeline" id="line-9158"><code>		lowKey, ascii := http2lowerHeader(k)</code></span>
<span class="codeline" id="line-9159"><code>		if !ascii {</code></span>
<span class="codeline" id="line-9160"><code>			// Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header</code></span>
<span class="codeline" id="line-9161"><code>			// field names have to be ASCII characters (just as in HTTP/1.x).</code></span>
<span class="codeline" id="line-9162"><code>			continue</code></span>
<span class="codeline" id="line-9163"><code>		}</code></span>
<span class="codeline" id="line-9164"><code>		// Transfer-Encoding, etc.. have already been filtered at the</code></span>
<span class="codeline" id="line-9165"><code>		// start of RoundTrip</code></span>
<span class="codeline" id="line-9166"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-9167"><code>			cc.writeHeader(lowKey, v)</code></span>
<span class="codeline" id="line-9168"><code>		}</code></span>
<span class="codeline" id="line-9169"><code>	}</code></span>
<span class="codeline" id="line-9170"><code>	return cc.hbuf.Bytes(), nil</code></span>
<span class="codeline" id="line-9171"><code>}</code></span>
<span class="codeline" id="line-9172"><code></code></span>
<span class="codeline" id="line-9173"><code>func (cc *http2ClientConn) writeHeader(name, value string) {</code></span>
<span class="codeline" id="line-9174"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-9175"><code>		log.Printf("http2: Transport encoding header %q = %q", name, value)</code></span>
<span class="codeline" id="line-9176"><code>	}</code></span>
<span class="codeline" id="line-9177"><code>	cc.henc.WriteField(hpack.HeaderField{Name: name, Value: value})</code></span>
<span class="codeline" id="line-9178"><code>}</code></span>
<span class="codeline" id="line-9179"><code></code></span>
<span class="codeline" id="line-9180"><code>type http2resAndError struct {</code></span>
<span class="codeline" id="line-9181"><code>	_   http2incomparable</code></span>
<span class="codeline" id="line-9182"><code>	res *Response</code></span>
<span class="codeline" id="line-9183"><code>	err error</code></span>
<span class="codeline" id="line-9184"><code>}</code></span>
<span class="codeline" id="line-9185"><code></code></span>
<span class="codeline" id="line-9186"><code>// requires cc.mu be held.</code></span>
<span class="codeline" id="line-9187"><code>func (cc *http2ClientConn) addStreamLocked(cs *http2clientStream) {</code></span>
<span class="codeline" id="line-9188"><code>	cs.flow.add(int32(cc.initialWindowSize))</code></span>
<span class="codeline" id="line-9189"><code>	cs.flow.setConnFlow(&amp;cc.flow)</code></span>
<span class="codeline" id="line-9190"><code>	cs.inflow.init(http2transportDefaultStreamFlow)</code></span>
<span class="codeline" id="line-9191"><code>	cs.ID = cc.nextStreamID</code></span>
<span class="codeline" id="line-9192"><code>	cc.nextStreamID += 2</code></span>
<span class="codeline" id="line-9193"><code>	cc.streams[cs.ID] = cs</code></span>
<span class="codeline" id="line-9194"><code>	if cs.ID == 0 {</code></span>
<span class="codeline" id="line-9195"><code>		panic("assigned stream ID 0")</code></span>
<span class="codeline" id="line-9196"><code>	}</code></span>
<span class="codeline" id="line-9197"><code>}</code></span>
<span class="codeline" id="line-9198"><code></code></span>
<span class="codeline" id="line-9199"><code>func (cc *http2ClientConn) forgetStreamID(id uint32) {</code></span>
<span class="codeline" id="line-9200"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-9201"><code>	slen := len(cc.streams)</code></span>
<span class="codeline" id="line-9202"><code>	delete(cc.streams, id)</code></span>
<span class="codeline" id="line-9203"><code>	if len(cc.streams) != slen-1 {</code></span>
<span class="codeline" id="line-9204"><code>		panic("forgetting unknown stream id")</code></span>
<span class="codeline" id="line-9205"><code>	}</code></span>
<span class="codeline" id="line-9206"><code>	cc.lastActive = time.Now()</code></span>
<span class="codeline" id="line-9207"><code>	if len(cc.streams) == 0 &amp;&amp; cc.idleTimer != nil {</code></span>
<span class="codeline" id="line-9208"><code>		cc.idleTimer.Reset(cc.idleTimeout)</code></span>
<span class="codeline" id="line-9209"><code>		cc.lastIdle = time.Now()</code></span>
<span class="codeline" id="line-9210"><code>	}</code></span>
<span class="codeline" id="line-9211"><code>	// Wake up writeRequestBody via clientStream.awaitFlowControl and</code></span>
<span class="codeline" id="line-9212"><code>	// wake up RoundTrip if there is a pending request.</code></span>
<span class="codeline" id="line-9213"><code>	cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-9214"><code></code></span>
<span class="codeline" id="line-9215"><code>	closeOnIdle := cc.singleUse || cc.doNotReuse || cc.t.disableKeepAlives() || cc.goAway != nil</code></span>
<span class="codeline" id="line-9216"><code>	if closeOnIdle &amp;&amp; cc.streamsReserved == 0 &amp;&amp; len(cc.streams) == 0 {</code></span>
<span class="codeline" id="line-9217"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-9218"><code>			cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, cc.nextStreamID-2)</code></span>
<span class="codeline" id="line-9219"><code>		}</code></span>
<span class="codeline" id="line-9220"><code>		cc.closed = true</code></span>
<span class="codeline" id="line-9221"><code>		defer cc.closeConn()</code></span>
<span class="codeline" id="line-9222"><code>	}</code></span>
<span class="codeline" id="line-9223"><code></code></span>
<span class="codeline" id="line-9224"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9225"><code>}</code></span>
<span class="codeline" id="line-9226"><code></code></span>
<span class="codeline" id="line-9227"><code>// clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.</code></span>
<span class="codeline" id="line-9228"><code>type http2clientConnReadLoop struct {</code></span>
<span class="codeline" id="line-9229"><code>	_  http2incomparable</code></span>
<span class="codeline" id="line-9230"><code>	cc *http2ClientConn</code></span>
<span class="codeline" id="line-9231"><code>}</code></span>
<span class="codeline" id="line-9232"><code></code></span>
<span class="codeline" id="line-9233"><code>// readLoop runs in its own goroutine and reads and dispatches frames.</code></span>
<span class="codeline" id="line-9234"><code>func (cc *http2ClientConn) readLoop() {</code></span>
<span class="codeline" id="line-9235"><code>	rl := &amp;http2clientConnReadLoop{cc: cc}</code></span>
<span class="codeline" id="line-9236"><code>	defer rl.cleanup()</code></span>
<span class="codeline" id="line-9237"><code>	cc.readerErr = rl.run()</code></span>
<span class="codeline" id="line-9238"><code>	if ce, ok := cc.readerErr.(http2ConnectionError); ok {</code></span>
<span class="codeline" id="line-9239"><code>		cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9240"><code>		cc.fr.WriteGoAway(0, http2ErrCode(ce), nil)</code></span>
<span class="codeline" id="line-9241"><code>		cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9242"><code>	}</code></span>
<span class="codeline" id="line-9243"><code>}</code></span>
<span class="codeline" id="line-9244"><code></code></span>
<span class="codeline" id="line-9245"><code>// GoAwayError is returned by the Transport when the server closes the</code></span>
<span class="codeline" id="line-9246"><code>// TCP connection after sending a GOAWAY frame.</code></span>
<span class="codeline" id="line-9247"><code>type http2GoAwayError struct {</code></span>
<span class="codeline" id="line-9248"><code>	LastStreamID uint32</code></span>
<span class="codeline" id="line-9249"><code>	ErrCode      http2ErrCode</code></span>
<span class="codeline" id="line-9250"><code>	DebugData    string</code></span>
<span class="codeline" id="line-9251"><code>}</code></span>
<span class="codeline" id="line-9252"><code></code></span>
<span class="codeline" id="line-9253"><code>func (e http2GoAwayError) Error() string {</code></span>
<span class="codeline" id="line-9254"><code>	return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q",</code></span>
<span class="codeline" id="line-9255"><code>		e.LastStreamID, e.ErrCode, e.DebugData)</code></span>
<span class="codeline" id="line-9256"><code>}</code></span>
<span class="codeline" id="line-9257"><code></code></span>
<span class="codeline" id="line-9258"><code>func http2isEOFOrNetReadError(err error) bool {</code></span>
<span class="codeline" id="line-9259"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-9260"><code>		return true</code></span>
<span class="codeline" id="line-9261"><code>	}</code></span>
<span class="codeline" id="line-9262"><code>	ne, ok := err.(*net.OpError)</code></span>
<span class="codeline" id="line-9263"><code>	return ok &amp;&amp; ne.Op == "read"</code></span>
<span class="codeline" id="line-9264"><code>}</code></span>
<span class="codeline" id="line-9265"><code></code></span>
<span class="codeline" id="line-9266"><code>func (rl *http2clientConnReadLoop) cleanup() {</code></span>
<span class="codeline" id="line-9267"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9268"><code>	cc.t.connPool().MarkDead(cc)</code></span>
<span class="codeline" id="line-9269"><code>	defer cc.closeConn()</code></span>
<span class="codeline" id="line-9270"><code>	defer close(cc.readerDone)</code></span>
<span class="codeline" id="line-9271"><code></code></span>
<span class="codeline" id="line-9272"><code>	if cc.idleTimer != nil {</code></span>
<span class="codeline" id="line-9273"><code>		cc.idleTimer.Stop()</code></span>
<span class="codeline" id="line-9274"><code>	}</code></span>
<span class="codeline" id="line-9275"><code></code></span>
<span class="codeline" id="line-9276"><code>	// Close any response bodies if the server closes prematurely.</code></span>
<span class="codeline" id="line-9277"><code>	// TODO: also do this if we've written the headers but not</code></span>
<span class="codeline" id="line-9278"><code>	// gotten a response yet.</code></span>
<span class="codeline" id="line-9279"><code>	err := cc.readerErr</code></span>
<span class="codeline" id="line-9280"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-9281"><code>	if cc.goAway != nil &amp;&amp; http2isEOFOrNetReadError(err) {</code></span>
<span class="codeline" id="line-9282"><code>		err = http2GoAwayError{</code></span>
<span class="codeline" id="line-9283"><code>			LastStreamID: cc.goAway.LastStreamID,</code></span>
<span class="codeline" id="line-9284"><code>			ErrCode:      cc.goAway.ErrCode,</code></span>
<span class="codeline" id="line-9285"><code>			DebugData:    cc.goAwayDebug,</code></span>
<span class="codeline" id="line-9286"><code>		}</code></span>
<span class="codeline" id="line-9287"><code>	} else if err == io.EOF {</code></span>
<span class="codeline" id="line-9288"><code>		err = io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-9289"><code>	}</code></span>
<span class="codeline" id="line-9290"><code>	cc.closed = true</code></span>
<span class="codeline" id="line-9291"><code></code></span>
<span class="codeline" id="line-9292"><code>	for _, cs := range cc.streams {</code></span>
<span class="codeline" id="line-9293"><code>		select {</code></span>
<span class="codeline" id="line-9294"><code>		case &lt;-cs.peerClosed:</code></span>
<span class="codeline" id="line-9295"><code>			// The server closed the stream before closing the conn,</code></span>
<span class="codeline" id="line-9296"><code>			// so no need to interrupt it.</code></span>
<span class="codeline" id="line-9297"><code>		default:</code></span>
<span class="codeline" id="line-9298"><code>			cs.abortStreamLocked(err)</code></span>
<span class="codeline" id="line-9299"><code>		}</code></span>
<span class="codeline" id="line-9300"><code>	}</code></span>
<span class="codeline" id="line-9301"><code>	cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-9302"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9303"><code>}</code></span>
<span class="codeline" id="line-9304"><code></code></span>
<span class="codeline" id="line-9305"><code>// countReadFrameError calls Transport.CountError with a string</code></span>
<span class="codeline" id="line-9306"><code>// representing err.</code></span>
<span class="codeline" id="line-9307"><code>func (cc *http2ClientConn) countReadFrameError(err error) {</code></span>
<span class="codeline" id="line-9308"><code>	f := cc.t.CountError</code></span>
<span class="codeline" id="line-9309"><code>	if f == nil || err == nil {</code></span>
<span class="codeline" id="line-9310"><code>		return</code></span>
<span class="codeline" id="line-9311"><code>	}</code></span>
<span class="codeline" id="line-9312"><code>	if ce, ok := err.(http2ConnectionError); ok {</code></span>
<span class="codeline" id="line-9313"><code>		errCode := http2ErrCode(ce)</code></span>
<span class="codeline" id="line-9314"><code>		f(fmt.Sprintf("read_frame_conn_error_%s", errCode.stringToken()))</code></span>
<span class="codeline" id="line-9315"><code>		return</code></span>
<span class="codeline" id="line-9316"><code>	}</code></span>
<span class="codeline" id="line-9317"><code>	if errors.Is(err, io.EOF) {</code></span>
<span class="codeline" id="line-9318"><code>		f("read_frame_eof")</code></span>
<span class="codeline" id="line-9319"><code>		return</code></span>
<span class="codeline" id="line-9320"><code>	}</code></span>
<span class="codeline" id="line-9321"><code>	if errors.Is(err, io.ErrUnexpectedEOF) {</code></span>
<span class="codeline" id="line-9322"><code>		f("read_frame_unexpected_eof")</code></span>
<span class="codeline" id="line-9323"><code>		return</code></span>
<span class="codeline" id="line-9324"><code>	}</code></span>
<span class="codeline" id="line-9325"><code>	if errors.Is(err, http2ErrFrameTooLarge) {</code></span>
<span class="codeline" id="line-9326"><code>		f("read_frame_too_large")</code></span>
<span class="codeline" id="line-9327"><code>		return</code></span>
<span class="codeline" id="line-9328"><code>	}</code></span>
<span class="codeline" id="line-9329"><code>	f("read_frame_other")</code></span>
<span class="codeline" id="line-9330"><code>}</code></span>
<span class="codeline" id="line-9331"><code></code></span>
<span class="codeline" id="line-9332"><code>func (rl *http2clientConnReadLoop) run() error {</code></span>
<span class="codeline" id="line-9333"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9334"><code>	gotSettings := false</code></span>
<span class="codeline" id="line-9335"><code>	readIdleTimeout := cc.t.ReadIdleTimeout</code></span>
<span class="codeline" id="line-9336"><code>	var t *time.Timer</code></span>
<span class="codeline" id="line-9337"><code>	if readIdleTimeout != 0 {</code></span>
<span class="codeline" id="line-9338"><code>		t = time.AfterFunc(readIdleTimeout, cc.healthCheck)</code></span>
<span class="codeline" id="line-9339"><code>		defer t.Stop()</code></span>
<span class="codeline" id="line-9340"><code>	}</code></span>
<span class="codeline" id="line-9341"><code>	for {</code></span>
<span class="codeline" id="line-9342"><code>		f, err := cc.fr.ReadFrame()</code></span>
<span class="codeline" id="line-9343"><code>		if t != nil {</code></span>
<span class="codeline" id="line-9344"><code>			t.Reset(readIdleTimeout)</code></span>
<span class="codeline" id="line-9345"><code>		}</code></span>
<span class="codeline" id="line-9346"><code>		if err != nil {</code></span>
<span class="codeline" id="line-9347"><code>			cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err)</code></span>
<span class="codeline" id="line-9348"><code>		}</code></span>
<span class="codeline" id="line-9349"><code>		if se, ok := err.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-9350"><code>			if cs := rl.streamByID(se.StreamID); cs != nil {</code></span>
<span class="codeline" id="line-9351"><code>				if se.Cause == nil {</code></span>
<span class="codeline" id="line-9352"><code>					se.Cause = cc.fr.errDetail</code></span>
<span class="codeline" id="line-9353"><code>				}</code></span>
<span class="codeline" id="line-9354"><code>				rl.endStreamError(cs, se)</code></span>
<span class="codeline" id="line-9355"><code>			}</code></span>
<span class="codeline" id="line-9356"><code>			continue</code></span>
<span class="codeline" id="line-9357"><code>		} else if err != nil {</code></span>
<span class="codeline" id="line-9358"><code>			cc.countReadFrameError(err)</code></span>
<span class="codeline" id="line-9359"><code>			return err</code></span>
<span class="codeline" id="line-9360"><code>		}</code></span>
<span class="codeline" id="line-9361"><code>		if http2VerboseLogs {</code></span>
<span class="codeline" id="line-9362"><code>			cc.vlogf("http2: Transport received %s", http2summarizeFrame(f))</code></span>
<span class="codeline" id="line-9363"><code>		}</code></span>
<span class="codeline" id="line-9364"><code>		if !gotSettings {</code></span>
<span class="codeline" id="line-9365"><code>			if _, ok := f.(*http2SettingsFrame); !ok {</code></span>
<span class="codeline" id="line-9366"><code>				cc.logf("protocol error: received %T before a SETTINGS frame", f)</code></span>
<span class="codeline" id="line-9367"><code>				return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9368"><code>			}</code></span>
<span class="codeline" id="line-9369"><code>			gotSettings = true</code></span>
<span class="codeline" id="line-9370"><code>		}</code></span>
<span class="codeline" id="line-9371"><code></code></span>
<span class="codeline" id="line-9372"><code>		switch f := f.(type) {</code></span>
<span class="codeline" id="line-9373"><code>		case *http2MetaHeadersFrame:</code></span>
<span class="codeline" id="line-9374"><code>			err = rl.processHeaders(f)</code></span>
<span class="codeline" id="line-9375"><code>		case *http2DataFrame:</code></span>
<span class="codeline" id="line-9376"><code>			err = rl.processData(f)</code></span>
<span class="codeline" id="line-9377"><code>		case *http2GoAwayFrame:</code></span>
<span class="codeline" id="line-9378"><code>			err = rl.processGoAway(f)</code></span>
<span class="codeline" id="line-9379"><code>		case *http2RSTStreamFrame:</code></span>
<span class="codeline" id="line-9380"><code>			err = rl.processResetStream(f)</code></span>
<span class="codeline" id="line-9381"><code>		case *http2SettingsFrame:</code></span>
<span class="codeline" id="line-9382"><code>			err = rl.processSettings(f)</code></span>
<span class="codeline" id="line-9383"><code>		case *http2PushPromiseFrame:</code></span>
<span class="codeline" id="line-9384"><code>			err = rl.processPushPromise(f)</code></span>
<span class="codeline" id="line-9385"><code>		case *http2WindowUpdateFrame:</code></span>
<span class="codeline" id="line-9386"><code>			err = rl.processWindowUpdate(f)</code></span>
<span class="codeline" id="line-9387"><code>		case *http2PingFrame:</code></span>
<span class="codeline" id="line-9388"><code>			err = rl.processPing(f)</code></span>
<span class="codeline" id="line-9389"><code>		default:</code></span>
<span class="codeline" id="line-9390"><code>			cc.logf("Transport: unhandled response frame type %T", f)</code></span>
<span class="codeline" id="line-9391"><code>		}</code></span>
<span class="codeline" id="line-9392"><code>		if err != nil {</code></span>
<span class="codeline" id="line-9393"><code>			if http2VerboseLogs {</code></span>
<span class="codeline" id="line-9394"><code>				cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, http2summarizeFrame(f), err)</code></span>
<span class="codeline" id="line-9395"><code>			}</code></span>
<span class="codeline" id="line-9396"><code>			return err</code></span>
<span class="codeline" id="line-9397"><code>		}</code></span>
<span class="codeline" id="line-9398"><code>	}</code></span>
<span class="codeline" id="line-9399"><code>}</code></span>
<span class="codeline" id="line-9400"><code></code></span>
<span class="codeline" id="line-9401"><code>func (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error {</code></span>
<span class="codeline" id="line-9402"><code>	cs := rl.streamByID(f.StreamID)</code></span>
<span class="codeline" id="line-9403"><code>	if cs == nil {</code></span>
<span class="codeline" id="line-9404"><code>		// We'd get here if we canceled a request while the</code></span>
<span class="codeline" id="line-9405"><code>		// server had its response still in flight. So if this</code></span>
<span class="codeline" id="line-9406"><code>		// was just something we canceled, ignore it.</code></span>
<span class="codeline" id="line-9407"><code>		return nil</code></span>
<span class="codeline" id="line-9408"><code>	}</code></span>
<span class="codeline" id="line-9409"><code>	if cs.readClosed {</code></span>
<span class="codeline" id="line-9410"><code>		rl.endStreamError(cs, http2StreamError{</code></span>
<span class="codeline" id="line-9411"><code>			StreamID: f.StreamID,</code></span>
<span class="codeline" id="line-9412"><code>			Code:     http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-9413"><code>			Cause:    errors.New("protocol error: headers after END_STREAM"),</code></span>
<span class="codeline" id="line-9414"><code>		})</code></span>
<span class="codeline" id="line-9415"><code>		return nil</code></span>
<span class="codeline" id="line-9416"><code>	}</code></span>
<span class="codeline" id="line-9417"><code>	if !cs.firstByte {</code></span>
<span class="codeline" id="line-9418"><code>		if cs.trace != nil {</code></span>
<span class="codeline" id="line-9419"><code>			// TODO(bradfitz): move first response byte earlier,</code></span>
<span class="codeline" id="line-9420"><code>			// when we first read the 9 byte header, not waiting</code></span>
<span class="codeline" id="line-9421"><code>			// until all the HEADERS+CONTINUATION frames have been</code></span>
<span class="codeline" id="line-9422"><code>			// merged. This works for now.</code></span>
<span class="codeline" id="line-9423"><code>			http2traceFirstResponseByte(cs.trace)</code></span>
<span class="codeline" id="line-9424"><code>		}</code></span>
<span class="codeline" id="line-9425"><code>		cs.firstByte = true</code></span>
<span class="codeline" id="line-9426"><code>	}</code></span>
<span class="codeline" id="line-9427"><code>	if !cs.pastHeaders {</code></span>
<span class="codeline" id="line-9428"><code>		cs.pastHeaders = true</code></span>
<span class="codeline" id="line-9429"><code>	} else {</code></span>
<span class="codeline" id="line-9430"><code>		return rl.processTrailers(cs, f)</code></span>
<span class="codeline" id="line-9431"><code>	}</code></span>
<span class="codeline" id="line-9432"><code></code></span>
<span class="codeline" id="line-9433"><code>	res, err := rl.handleResponse(cs, f)</code></span>
<span class="codeline" id="line-9434"><code>	if err != nil {</code></span>
<span class="codeline" id="line-9435"><code>		if _, ok := err.(http2ConnectionError); ok {</code></span>
<span class="codeline" id="line-9436"><code>			return err</code></span>
<span class="codeline" id="line-9437"><code>		}</code></span>
<span class="codeline" id="line-9438"><code>		// Any other error type is a stream error.</code></span>
<span class="codeline" id="line-9439"><code>		rl.endStreamError(cs, http2StreamError{</code></span>
<span class="codeline" id="line-9440"><code>			StreamID: f.StreamID,</code></span>
<span class="codeline" id="line-9441"><code>			Code:     http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-9442"><code>			Cause:    err,</code></span>
<span class="codeline" id="line-9443"><code>		})</code></span>
<span class="codeline" id="line-9444"><code>		return nil // return nil from process* funcs to keep conn alive</code></span>
<span class="codeline" id="line-9445"><code>	}</code></span>
<span class="codeline" id="line-9446"><code>	if res == nil {</code></span>
<span class="codeline" id="line-9447"><code>		// (nil, nil) special case. See handleResponse docs.</code></span>
<span class="codeline" id="line-9448"><code>		return nil</code></span>
<span class="codeline" id="line-9449"><code>	}</code></span>
<span class="codeline" id="line-9450"><code>	cs.resTrailer = &amp;res.Trailer</code></span>
<span class="codeline" id="line-9451"><code>	cs.res = res</code></span>
<span class="codeline" id="line-9452"><code>	close(cs.respHeaderRecv)</code></span>
<span class="codeline" id="line-9453"><code>	if f.StreamEnded() {</code></span>
<span class="codeline" id="line-9454"><code>		rl.endStream(cs)</code></span>
<span class="codeline" id="line-9455"><code>	}</code></span>
<span class="codeline" id="line-9456"><code>	return nil</code></span>
<span class="codeline" id="line-9457"><code>}</code></span>
<span class="codeline" id="line-9458"><code></code></span>
<span class="codeline" id="line-9459"><code>// may return error types nil, or ConnectionError. Any other error value</code></span>
<span class="codeline" id="line-9460"><code>// is a StreamError of type ErrCodeProtocol. The returned error in that case</code></span>
<span class="codeline" id="line-9461"><code>// is the detail.</code></span>
<span class="codeline" id="line-9462"><code>//</code></span>
<span class="codeline" id="line-9463"><code>// As a special case, handleResponse may return (nil, nil) to skip the</code></span>
<span class="codeline" id="line-9464"><code>// frame (currently only used for 1xx responses).</code></span>
<span class="codeline" id="line-9465"><code>func (rl *http2clientConnReadLoop) handleResponse(cs *http2clientStream, f *http2MetaHeadersFrame) (*Response, error) {</code></span>
<span class="codeline" id="line-9466"><code>	if f.Truncated {</code></span>
<span class="codeline" id="line-9467"><code>		return nil, http2errResponseHeaderListSize</code></span>
<span class="codeline" id="line-9468"><code>	}</code></span>
<span class="codeline" id="line-9469"><code></code></span>
<span class="codeline" id="line-9470"><code>	status := f.PseudoValue("status")</code></span>
<span class="codeline" id="line-9471"><code>	if status == "" {</code></span>
<span class="codeline" id="line-9472"><code>		return nil, errors.New("malformed response from server: missing status pseudo header")</code></span>
<span class="codeline" id="line-9473"><code>	}</code></span>
<span class="codeline" id="line-9474"><code>	statusCode, err := strconv.Atoi(status)</code></span>
<span class="codeline" id="line-9475"><code>	if err != nil {</code></span>
<span class="codeline" id="line-9476"><code>		return nil, errors.New("malformed response from server: malformed non-numeric status pseudo header")</code></span>
<span class="codeline" id="line-9477"><code>	}</code></span>
<span class="codeline" id="line-9478"><code></code></span>
<span class="codeline" id="line-9479"><code>	regularFields := f.RegularFields()</code></span>
<span class="codeline" id="line-9480"><code>	strs := make([]string, len(regularFields))</code></span>
<span class="codeline" id="line-9481"><code>	header := make(Header, len(regularFields))</code></span>
<span class="codeline" id="line-9482"><code>	res := &amp;Response{</code></span>
<span class="codeline" id="line-9483"><code>		Proto:      "HTTP/2.0",</code></span>
<span class="codeline" id="line-9484"><code>		ProtoMajor: 2,</code></span>
<span class="codeline" id="line-9485"><code>		Header:     header,</code></span>
<span class="codeline" id="line-9486"><code>		StatusCode: statusCode,</code></span>
<span class="codeline" id="line-9487"><code>		Status:     status + " " + StatusText(statusCode),</code></span>
<span class="codeline" id="line-9488"><code>	}</code></span>
<span class="codeline" id="line-9489"><code>	for _, hf := range regularFields {</code></span>
<span class="codeline" id="line-9490"><code>		key := http2canonicalHeader(hf.Name)</code></span>
<span class="codeline" id="line-9491"><code>		if key == "Trailer" {</code></span>
<span class="codeline" id="line-9492"><code>			t := res.Trailer</code></span>
<span class="codeline" id="line-9493"><code>			if t == nil {</code></span>
<span class="codeline" id="line-9494"><code>				t = make(Header)</code></span>
<span class="codeline" id="line-9495"><code>				res.Trailer = t</code></span>
<span class="codeline" id="line-9496"><code>			}</code></span>
<span class="codeline" id="line-9497"><code>			http2foreachHeaderElement(hf.Value, func(v string) {</code></span>
<span class="codeline" id="line-9498"><code>				t[http2canonicalHeader(v)] = nil</code></span>
<span class="codeline" id="line-9499"><code>			})</code></span>
<span class="codeline" id="line-9500"><code>		} else {</code></span>
<span class="codeline" id="line-9501"><code>			vv := header[key]</code></span>
<span class="codeline" id="line-9502"><code>			if vv == nil &amp;&amp; len(strs) &gt; 0 {</code></span>
<span class="codeline" id="line-9503"><code>				// More than likely this will be a single-element key.</code></span>
<span class="codeline" id="line-9504"><code>				// Most headers aren't multi-valued.</code></span>
<span class="codeline" id="line-9505"><code>				// Set the capacity on strs[0] to 1, so any future append</code></span>
<span class="codeline" id="line-9506"><code>				// won't extend the slice into the other strings.</code></span>
<span class="codeline" id="line-9507"><code>				vv, strs = strs[:1:1], strs[1:]</code></span>
<span class="codeline" id="line-9508"><code>				vv[0] = hf.Value</code></span>
<span class="codeline" id="line-9509"><code>				header[key] = vv</code></span>
<span class="codeline" id="line-9510"><code>			} else {</code></span>
<span class="codeline" id="line-9511"><code>				header[key] = append(vv, hf.Value)</code></span>
<span class="codeline" id="line-9512"><code>			}</code></span>
<span class="codeline" id="line-9513"><code>		}</code></span>
<span class="codeline" id="line-9514"><code>	}</code></span>
<span class="codeline" id="line-9515"><code></code></span>
<span class="codeline" id="line-9516"><code>	if statusCode &gt;= 100 &amp;&amp; statusCode &lt;= 199 {</code></span>
<span class="codeline" id="line-9517"><code>		if f.StreamEnded() {</code></span>
<span class="codeline" id="line-9518"><code>			return nil, errors.New("1xx informational response with END_STREAM flag")</code></span>
<span class="codeline" id="line-9519"><code>		}</code></span>
<span class="codeline" id="line-9520"><code>		cs.num1xx++</code></span>
<span class="codeline" id="line-9521"><code>		const max1xxResponses = 5 // arbitrary bound on number of informational responses, same as net/http</code></span>
<span class="codeline" id="line-9522"><code>		if cs.num1xx &gt; max1xxResponses {</code></span>
<span class="codeline" id="line-9523"><code>			return nil, errors.New("http2: too many 1xx informational responses")</code></span>
<span class="codeline" id="line-9524"><code>		}</code></span>
<span class="codeline" id="line-9525"><code>		if fn := cs.get1xxTraceFunc(); fn != nil {</code></span>
<span class="codeline" id="line-9526"><code>			if err := fn(statusCode, textproto.MIMEHeader(header)); err != nil {</code></span>
<span class="codeline" id="line-9527"><code>				return nil, err</code></span>
<span class="codeline" id="line-9528"><code>			}</code></span>
<span class="codeline" id="line-9529"><code>		}</code></span>
<span class="codeline" id="line-9530"><code>		if statusCode == 100 {</code></span>
<span class="codeline" id="line-9531"><code>			http2traceGot100Continue(cs.trace)</code></span>
<span class="codeline" id="line-9532"><code>			select {</code></span>
<span class="codeline" id="line-9533"><code>			case cs.on100 &lt;- struct{}{}:</code></span>
<span class="codeline" id="line-9534"><code>			default:</code></span>
<span class="codeline" id="line-9535"><code>			}</code></span>
<span class="codeline" id="line-9536"><code>		}</code></span>
<span class="codeline" id="line-9537"><code>		cs.pastHeaders = false // do it all again</code></span>
<span class="codeline" id="line-9538"><code>		return nil, nil</code></span>
<span class="codeline" id="line-9539"><code>	}</code></span>
<span class="codeline" id="line-9540"><code></code></span>
<span class="codeline" id="line-9541"><code>	res.ContentLength = -1</code></span>
<span class="codeline" id="line-9542"><code>	if clens := res.Header["Content-Length"]; len(clens) == 1 {</code></span>
<span class="codeline" id="line-9543"><code>		if cl, err := strconv.ParseUint(clens[0], 10, 63); err == nil {</code></span>
<span class="codeline" id="line-9544"><code>			res.ContentLength = int64(cl)</code></span>
<span class="codeline" id="line-9545"><code>		} else {</code></span>
<span class="codeline" id="line-9546"><code>			// TODO: care? unlike http/1, it won't mess up our framing, so it's</code></span>
<span class="codeline" id="line-9547"><code>			// more safe smuggling-wise to ignore.</code></span>
<span class="codeline" id="line-9548"><code>		}</code></span>
<span class="codeline" id="line-9549"><code>	} else if len(clens) &gt; 1 {</code></span>
<span class="codeline" id="line-9550"><code>		// TODO: care? unlike http/1, it won't mess up our framing, so it's</code></span>
<span class="codeline" id="line-9551"><code>		// more safe smuggling-wise to ignore.</code></span>
<span class="codeline" id="line-9552"><code>	} else if f.StreamEnded() &amp;&amp; !cs.isHead {</code></span>
<span class="codeline" id="line-9553"><code>		res.ContentLength = 0</code></span>
<span class="codeline" id="line-9554"><code>	}</code></span>
<span class="codeline" id="line-9555"><code></code></span>
<span class="codeline" id="line-9556"><code>	if cs.isHead {</code></span>
<span class="codeline" id="line-9557"><code>		res.Body = http2noBody</code></span>
<span class="codeline" id="line-9558"><code>		return res, nil</code></span>
<span class="codeline" id="line-9559"><code>	}</code></span>
<span class="codeline" id="line-9560"><code></code></span>
<span class="codeline" id="line-9561"><code>	if f.StreamEnded() {</code></span>
<span class="codeline" id="line-9562"><code>		if res.ContentLength &gt; 0 {</code></span>
<span class="codeline" id="line-9563"><code>			res.Body = http2missingBody{}</code></span>
<span class="codeline" id="line-9564"><code>		} else {</code></span>
<span class="codeline" id="line-9565"><code>			res.Body = http2noBody</code></span>
<span class="codeline" id="line-9566"><code>		}</code></span>
<span class="codeline" id="line-9567"><code>		return res, nil</code></span>
<span class="codeline" id="line-9568"><code>	}</code></span>
<span class="codeline" id="line-9569"><code></code></span>
<span class="codeline" id="line-9570"><code>	cs.bufPipe.setBuffer(&amp;http2dataBuffer{expected: res.ContentLength})</code></span>
<span class="codeline" id="line-9571"><code>	cs.bytesRemain = res.ContentLength</code></span>
<span class="codeline" id="line-9572"><code>	res.Body = http2transportResponseBody{cs}</code></span>
<span class="codeline" id="line-9573"><code></code></span>
<span class="codeline" id="line-9574"><code>	if cs.requestedGzip &amp;&amp; http2asciiEqualFold(res.Header.Get("Content-Encoding"), "gzip") {</code></span>
<span class="codeline" id="line-9575"><code>		res.Header.Del("Content-Encoding")</code></span>
<span class="codeline" id="line-9576"><code>		res.Header.Del("Content-Length")</code></span>
<span class="codeline" id="line-9577"><code>		res.ContentLength = -1</code></span>
<span class="codeline" id="line-9578"><code>		res.Body = &amp;http2gzipReader{body: res.Body}</code></span>
<span class="codeline" id="line-9579"><code>		res.Uncompressed = true</code></span>
<span class="codeline" id="line-9580"><code>	}</code></span>
<span class="codeline" id="line-9581"><code>	return res, nil</code></span>
<span class="codeline" id="line-9582"><code>}</code></span>
<span class="codeline" id="line-9583"><code></code></span>
<span class="codeline" id="line-9584"><code>func (rl *http2clientConnReadLoop) processTrailers(cs *http2clientStream, f *http2MetaHeadersFrame) error {</code></span>
<span class="codeline" id="line-9585"><code>	if cs.pastTrailers {</code></span>
<span class="codeline" id="line-9586"><code>		// Too many HEADERS frames for this stream.</code></span>
<span class="codeline" id="line-9587"><code>		return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9588"><code>	}</code></span>
<span class="codeline" id="line-9589"><code>	cs.pastTrailers = true</code></span>
<span class="codeline" id="line-9590"><code>	if !f.StreamEnded() {</code></span>
<span class="codeline" id="line-9591"><code>		// We expect that any headers for trailers also</code></span>
<span class="codeline" id="line-9592"><code>		// has END_STREAM.</code></span>
<span class="codeline" id="line-9593"><code>		return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9594"><code>	}</code></span>
<span class="codeline" id="line-9595"><code>	if len(f.PseudoFields()) &gt; 0 {</code></span>
<span class="codeline" id="line-9596"><code>		// No pseudo header fields are defined for trailers.</code></span>
<span class="codeline" id="line-9597"><code>		// TODO: ConnectionError might be overly harsh? Check.</code></span>
<span class="codeline" id="line-9598"><code>		return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9599"><code>	}</code></span>
<span class="codeline" id="line-9600"><code></code></span>
<span class="codeline" id="line-9601"><code>	trailer := make(Header)</code></span>
<span class="codeline" id="line-9602"><code>	for _, hf := range f.RegularFields() {</code></span>
<span class="codeline" id="line-9603"><code>		key := http2canonicalHeader(hf.Name)</code></span>
<span class="codeline" id="line-9604"><code>		trailer[key] = append(trailer[key], hf.Value)</code></span>
<span class="codeline" id="line-9605"><code>	}</code></span>
<span class="codeline" id="line-9606"><code>	cs.trailer = trailer</code></span>
<span class="codeline" id="line-9607"><code></code></span>
<span class="codeline" id="line-9608"><code>	rl.endStream(cs)</code></span>
<span class="codeline" id="line-9609"><code>	return nil</code></span>
<span class="codeline" id="line-9610"><code>}</code></span>
<span class="codeline" id="line-9611"><code></code></span>
<span class="codeline" id="line-9612"><code>// transportResponseBody is the concrete type of Transport.RoundTrip's</code></span>
<span class="codeline" id="line-9613"><code>// Response.Body. It is an io.ReadCloser.</code></span>
<span class="codeline" id="line-9614"><code>type http2transportResponseBody struct {</code></span>
<span class="codeline" id="line-9615"><code>	cs *http2clientStream</code></span>
<span class="codeline" id="line-9616"><code>}</code></span>
<span class="codeline" id="line-9617"><code></code></span>
<span class="codeline" id="line-9618"><code>func (b http2transportResponseBody) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-9619"><code>	cs := b.cs</code></span>
<span class="codeline" id="line-9620"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-9621"><code></code></span>
<span class="codeline" id="line-9622"><code>	if cs.readErr != nil {</code></span>
<span class="codeline" id="line-9623"><code>		return 0, cs.readErr</code></span>
<span class="codeline" id="line-9624"><code>	}</code></span>
<span class="codeline" id="line-9625"><code>	n, err = b.cs.bufPipe.Read(p)</code></span>
<span class="codeline" id="line-9626"><code>	if cs.bytesRemain != -1 {</code></span>
<span class="codeline" id="line-9627"><code>		if int64(n) &gt; cs.bytesRemain {</code></span>
<span class="codeline" id="line-9628"><code>			n = int(cs.bytesRemain)</code></span>
<span class="codeline" id="line-9629"><code>			if err == nil {</code></span>
<span class="codeline" id="line-9630"><code>				err = errors.New("net/http: server replied with more than declared Content-Length; truncated")</code></span>
<span class="codeline" id="line-9631"><code>				cs.abortStream(err)</code></span>
<span class="codeline" id="line-9632"><code>			}</code></span>
<span class="codeline" id="line-9633"><code>			cs.readErr = err</code></span>
<span class="codeline" id="line-9634"><code>			return int(cs.bytesRemain), err</code></span>
<span class="codeline" id="line-9635"><code>		}</code></span>
<span class="codeline" id="line-9636"><code>		cs.bytesRemain -= int64(n)</code></span>
<span class="codeline" id="line-9637"><code>		if err == io.EOF &amp;&amp; cs.bytesRemain &gt; 0 {</code></span>
<span class="codeline" id="line-9638"><code>			err = io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-9639"><code>			cs.readErr = err</code></span>
<span class="codeline" id="line-9640"><code>			return n, err</code></span>
<span class="codeline" id="line-9641"><code>		}</code></span>
<span class="codeline" id="line-9642"><code>	}</code></span>
<span class="codeline" id="line-9643"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-9644"><code>		// No flow control tokens to send back.</code></span>
<span class="codeline" id="line-9645"><code>		return</code></span>
<span class="codeline" id="line-9646"><code>	}</code></span>
<span class="codeline" id="line-9647"><code></code></span>
<span class="codeline" id="line-9648"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-9649"><code>	connAdd := cc.inflow.add(n)</code></span>
<span class="codeline" id="line-9650"><code>	var streamAdd int32</code></span>
<span class="codeline" id="line-9651"><code>	if err == nil { // No need to refresh if the stream is over or failed.</code></span>
<span class="codeline" id="line-9652"><code>		streamAdd = cs.inflow.add(n)</code></span>
<span class="codeline" id="line-9653"><code>	}</code></span>
<span class="codeline" id="line-9654"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9655"><code></code></span>
<span class="codeline" id="line-9656"><code>	if connAdd != 0 || streamAdd != 0 {</code></span>
<span class="codeline" id="line-9657"><code>		cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9658"><code>		defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9659"><code>		if connAdd != 0 {</code></span>
<span class="codeline" id="line-9660"><code>			cc.fr.WriteWindowUpdate(0, http2mustUint31(connAdd))</code></span>
<span class="codeline" id="line-9661"><code>		}</code></span>
<span class="codeline" id="line-9662"><code>		if streamAdd != 0 {</code></span>
<span class="codeline" id="line-9663"><code>			cc.fr.WriteWindowUpdate(cs.ID, http2mustUint31(streamAdd))</code></span>
<span class="codeline" id="line-9664"><code>		}</code></span>
<span class="codeline" id="line-9665"><code>		cc.bw.Flush()</code></span>
<span class="codeline" id="line-9666"><code>	}</code></span>
<span class="codeline" id="line-9667"><code>	return</code></span>
<span class="codeline" id="line-9668"><code>}</code></span>
<span class="codeline" id="line-9669"><code></code></span>
<span class="codeline" id="line-9670"><code>var http2errClosedResponseBody = errors.New("http2: response body closed")</code></span>
<span class="codeline" id="line-9671"><code></code></span>
<span class="codeline" id="line-9672"><code>func (b http2transportResponseBody) Close() error {</code></span>
<span class="codeline" id="line-9673"><code>	cs := b.cs</code></span>
<span class="codeline" id="line-9674"><code>	cc := cs.cc</code></span>
<span class="codeline" id="line-9675"><code></code></span>
<span class="codeline" id="line-9676"><code>	cs.bufPipe.BreakWithError(http2errClosedResponseBody)</code></span>
<span class="codeline" id="line-9677"><code>	cs.abortStream(http2errClosedResponseBody)</code></span>
<span class="codeline" id="line-9678"><code></code></span>
<span class="codeline" id="line-9679"><code>	unread := cs.bufPipe.Len()</code></span>
<span class="codeline" id="line-9680"><code>	if unread &gt; 0 {</code></span>
<span class="codeline" id="line-9681"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-9682"><code>		// Return connection-level flow control.</code></span>
<span class="codeline" id="line-9683"><code>		connAdd := cc.inflow.add(unread)</code></span>
<span class="codeline" id="line-9684"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9685"><code></code></span>
<span class="codeline" id="line-9686"><code>		// TODO(dneil): Acquiring this mutex can block indefinitely.</code></span>
<span class="codeline" id="line-9687"><code>		// Move flow control return to a goroutine?</code></span>
<span class="codeline" id="line-9688"><code>		cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9689"><code>		// Return connection-level flow control.</code></span>
<span class="codeline" id="line-9690"><code>		if connAdd &gt; 0 {</code></span>
<span class="codeline" id="line-9691"><code>			cc.fr.WriteWindowUpdate(0, uint32(connAdd))</code></span>
<span class="codeline" id="line-9692"><code>		}</code></span>
<span class="codeline" id="line-9693"><code>		cc.bw.Flush()</code></span>
<span class="codeline" id="line-9694"><code>		cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9695"><code>	}</code></span>
<span class="codeline" id="line-9696"><code></code></span>
<span class="codeline" id="line-9697"><code>	select {</code></span>
<span class="codeline" id="line-9698"><code>	case &lt;-cs.donec:</code></span>
<span class="codeline" id="line-9699"><code>	case &lt;-cs.ctx.Done():</code></span>
<span class="codeline" id="line-9700"><code>		// See golang/go#49366: The net/http package can cancel the</code></span>
<span class="codeline" id="line-9701"><code>		// request context after the response body is fully read.</code></span>
<span class="codeline" id="line-9702"><code>		// Don't treat this as an error.</code></span>
<span class="codeline" id="line-9703"><code>		return nil</code></span>
<span class="codeline" id="line-9704"><code>	case &lt;-cs.reqCancel:</code></span>
<span class="codeline" id="line-9705"><code>		return http2errRequestCanceled</code></span>
<span class="codeline" id="line-9706"><code>	}</code></span>
<span class="codeline" id="line-9707"><code>	return nil</code></span>
<span class="codeline" id="line-9708"><code>}</code></span>
<span class="codeline" id="line-9709"><code></code></span>
<span class="codeline" id="line-9710"><code>func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error {</code></span>
<span class="codeline" id="line-9711"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9712"><code>	cs := rl.streamByID(f.StreamID)</code></span>
<span class="codeline" id="line-9713"><code>	data := f.Data()</code></span>
<span class="codeline" id="line-9714"><code>	if cs == nil {</code></span>
<span class="codeline" id="line-9715"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-9716"><code>		neverSent := cc.nextStreamID</code></span>
<span class="codeline" id="line-9717"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9718"><code>		if f.StreamID &gt;= neverSent {</code></span>
<span class="codeline" id="line-9719"><code>			// We never asked for this.</code></span>
<span class="codeline" id="line-9720"><code>			cc.logf("http2: Transport received unsolicited DATA frame; closing connection")</code></span>
<span class="codeline" id="line-9721"><code>			return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9722"><code>		}</code></span>
<span class="codeline" id="line-9723"><code>		// We probably did ask for this, but canceled. Just ignore it.</code></span>
<span class="codeline" id="line-9724"><code>		// TODO: be stricter here? only silently ignore things which</code></span>
<span class="codeline" id="line-9725"><code>		// we canceled, but not things which were closed normally</code></span>
<span class="codeline" id="line-9726"><code>		// by the peer? Tough without accumulating too much state.</code></span>
<span class="codeline" id="line-9727"><code></code></span>
<span class="codeline" id="line-9728"><code>		// But at least return their flow control:</code></span>
<span class="codeline" id="line-9729"><code>		if f.Length &gt; 0 {</code></span>
<span class="codeline" id="line-9730"><code>			cc.mu.Lock()</code></span>
<span class="codeline" id="line-9731"><code>			ok := cc.inflow.take(f.Length)</code></span>
<span class="codeline" id="line-9732"><code>			connAdd := cc.inflow.add(int(f.Length))</code></span>
<span class="codeline" id="line-9733"><code>			cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9734"><code>			if !ok {</code></span>
<span class="codeline" id="line-9735"><code>				return http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-9736"><code>			}</code></span>
<span class="codeline" id="line-9737"><code>			if connAdd &gt; 0 {</code></span>
<span class="codeline" id="line-9738"><code>				cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9739"><code>				cc.fr.WriteWindowUpdate(0, uint32(connAdd))</code></span>
<span class="codeline" id="line-9740"><code>				cc.bw.Flush()</code></span>
<span class="codeline" id="line-9741"><code>				cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9742"><code>			}</code></span>
<span class="codeline" id="line-9743"><code>		}</code></span>
<span class="codeline" id="line-9744"><code>		return nil</code></span>
<span class="codeline" id="line-9745"><code>	}</code></span>
<span class="codeline" id="line-9746"><code>	if cs.readClosed {</code></span>
<span class="codeline" id="line-9747"><code>		cc.logf("protocol error: received DATA after END_STREAM")</code></span>
<span class="codeline" id="line-9748"><code>		rl.endStreamError(cs, http2StreamError{</code></span>
<span class="codeline" id="line-9749"><code>			StreamID: f.StreamID,</code></span>
<span class="codeline" id="line-9750"><code>			Code:     http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-9751"><code>		})</code></span>
<span class="codeline" id="line-9752"><code>		return nil</code></span>
<span class="codeline" id="line-9753"><code>	}</code></span>
<span class="codeline" id="line-9754"><code>	if !cs.pastHeaders {</code></span>
<span class="codeline" id="line-9755"><code>		cc.logf("protocol error: received DATA before a HEADERS frame")</code></span>
<span class="codeline" id="line-9756"><code>		rl.endStreamError(cs, http2StreamError{</code></span>
<span class="codeline" id="line-9757"><code>			StreamID: f.StreamID,</code></span>
<span class="codeline" id="line-9758"><code>			Code:     http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-9759"><code>		})</code></span>
<span class="codeline" id="line-9760"><code>		return nil</code></span>
<span class="codeline" id="line-9761"><code>	}</code></span>
<span class="codeline" id="line-9762"><code>	if f.Length &gt; 0 {</code></span>
<span class="codeline" id="line-9763"><code>		if cs.isHead &amp;&amp; len(data) &gt; 0 {</code></span>
<span class="codeline" id="line-9764"><code>			cc.logf("protocol error: received DATA on a HEAD request")</code></span>
<span class="codeline" id="line-9765"><code>			rl.endStreamError(cs, http2StreamError{</code></span>
<span class="codeline" id="line-9766"><code>				StreamID: f.StreamID,</code></span>
<span class="codeline" id="line-9767"><code>				Code:     http2ErrCodeProtocol,</code></span>
<span class="codeline" id="line-9768"><code>			})</code></span>
<span class="codeline" id="line-9769"><code>			return nil</code></span>
<span class="codeline" id="line-9770"><code>		}</code></span>
<span class="codeline" id="line-9771"><code>		// Check connection-level flow control.</code></span>
<span class="codeline" id="line-9772"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-9773"><code>		if !http2takeInflows(&amp;cc.inflow, &amp;cs.inflow, f.Length) {</code></span>
<span class="codeline" id="line-9774"><code>			cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9775"><code>			return http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-9776"><code>		}</code></span>
<span class="codeline" id="line-9777"><code>		// Return any padded flow control now, since we won't</code></span>
<span class="codeline" id="line-9778"><code>		// refund it later on body reads.</code></span>
<span class="codeline" id="line-9779"><code>		var refund int</code></span>
<span class="codeline" id="line-9780"><code>		if pad := int(f.Length) - len(data); pad &gt; 0 {</code></span>
<span class="codeline" id="line-9781"><code>			refund += pad</code></span>
<span class="codeline" id="line-9782"><code>		}</code></span>
<span class="codeline" id="line-9783"><code></code></span>
<span class="codeline" id="line-9784"><code>		didReset := false</code></span>
<span class="codeline" id="line-9785"><code>		var err error</code></span>
<span class="codeline" id="line-9786"><code>		if len(data) &gt; 0 {</code></span>
<span class="codeline" id="line-9787"><code>			if _, err = cs.bufPipe.Write(data); err != nil {</code></span>
<span class="codeline" id="line-9788"><code>				// Return len(data) now if the stream is already closed,</code></span>
<span class="codeline" id="line-9789"><code>				// since data will never be read.</code></span>
<span class="codeline" id="line-9790"><code>				didReset = true</code></span>
<span class="codeline" id="line-9791"><code>				refund += len(data)</code></span>
<span class="codeline" id="line-9792"><code>			}</code></span>
<span class="codeline" id="line-9793"><code>		}</code></span>
<span class="codeline" id="line-9794"><code></code></span>
<span class="codeline" id="line-9795"><code>		sendConn := cc.inflow.add(refund)</code></span>
<span class="codeline" id="line-9796"><code>		var sendStream int32</code></span>
<span class="codeline" id="line-9797"><code>		if !didReset {</code></span>
<span class="codeline" id="line-9798"><code>			sendStream = cs.inflow.add(refund)</code></span>
<span class="codeline" id="line-9799"><code>		}</code></span>
<span class="codeline" id="line-9800"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9801"><code></code></span>
<span class="codeline" id="line-9802"><code>		if sendConn &gt; 0 || sendStream &gt; 0 {</code></span>
<span class="codeline" id="line-9803"><code>			cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9804"><code>			if sendConn &gt; 0 {</code></span>
<span class="codeline" id="line-9805"><code>				cc.fr.WriteWindowUpdate(0, uint32(sendConn))</code></span>
<span class="codeline" id="line-9806"><code>			}</code></span>
<span class="codeline" id="line-9807"><code>			if sendStream &gt; 0 {</code></span>
<span class="codeline" id="line-9808"><code>				cc.fr.WriteWindowUpdate(cs.ID, uint32(sendStream))</code></span>
<span class="codeline" id="line-9809"><code>			}</code></span>
<span class="codeline" id="line-9810"><code>			cc.bw.Flush()</code></span>
<span class="codeline" id="line-9811"><code>			cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9812"><code>		}</code></span>
<span class="codeline" id="line-9813"><code></code></span>
<span class="codeline" id="line-9814"><code>		if err != nil {</code></span>
<span class="codeline" id="line-9815"><code>			rl.endStreamError(cs, err)</code></span>
<span class="codeline" id="line-9816"><code>			return nil</code></span>
<span class="codeline" id="line-9817"><code>		}</code></span>
<span class="codeline" id="line-9818"><code>	}</code></span>
<span class="codeline" id="line-9819"><code></code></span>
<span class="codeline" id="line-9820"><code>	if f.StreamEnded() {</code></span>
<span class="codeline" id="line-9821"><code>		rl.endStream(cs)</code></span>
<span class="codeline" id="line-9822"><code>	}</code></span>
<span class="codeline" id="line-9823"><code>	return nil</code></span>
<span class="codeline" id="line-9824"><code>}</code></span>
<span class="codeline" id="line-9825"><code></code></span>
<span class="codeline" id="line-9826"><code>func (rl *http2clientConnReadLoop) endStream(cs *http2clientStream) {</code></span>
<span class="codeline" id="line-9827"><code>	// TODO: check that any declared content-length matches, like</code></span>
<span class="codeline" id="line-9828"><code>	// server.go's (*stream).endStream method.</code></span>
<span class="codeline" id="line-9829"><code>	if !cs.readClosed {</code></span>
<span class="codeline" id="line-9830"><code>		cs.readClosed = true</code></span>
<span class="codeline" id="line-9831"><code>		// Close cs.bufPipe and cs.peerClosed with cc.mu held to avoid a</code></span>
<span class="codeline" id="line-9832"><code>		// race condition: The caller can read io.EOF from Response.Body</code></span>
<span class="codeline" id="line-9833"><code>		// and close the body before we close cs.peerClosed, causing</code></span>
<span class="codeline" id="line-9834"><code>		// cleanupWriteRequest to send a RST_STREAM.</code></span>
<span class="codeline" id="line-9835"><code>		rl.cc.mu.Lock()</code></span>
<span class="codeline" id="line-9836"><code>		defer rl.cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9837"><code>		cs.bufPipe.closeWithErrorAndCode(io.EOF, cs.copyTrailers)</code></span>
<span class="codeline" id="line-9838"><code>		close(cs.peerClosed)</code></span>
<span class="codeline" id="line-9839"><code>	}</code></span>
<span class="codeline" id="line-9840"><code>}</code></span>
<span class="codeline" id="line-9841"><code></code></span>
<span class="codeline" id="line-9842"><code>func (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err error) {</code></span>
<span class="codeline" id="line-9843"><code>	cs.readAborted = true</code></span>
<span class="codeline" id="line-9844"><code>	cs.abortStream(err)</code></span>
<span class="codeline" id="line-9845"><code>}</code></span>
<span class="codeline" id="line-9846"><code></code></span>
<span class="codeline" id="line-9847"><code>func (rl *http2clientConnReadLoop) streamByID(id uint32) *http2clientStream {</code></span>
<span class="codeline" id="line-9848"><code>	rl.cc.mu.Lock()</code></span>
<span class="codeline" id="line-9849"><code>	defer rl.cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9850"><code>	cs := rl.cc.streams[id]</code></span>
<span class="codeline" id="line-9851"><code>	if cs != nil &amp;&amp; !cs.readAborted {</code></span>
<span class="codeline" id="line-9852"><code>		return cs</code></span>
<span class="codeline" id="line-9853"><code>	}</code></span>
<span class="codeline" id="line-9854"><code>	return nil</code></span>
<span class="codeline" id="line-9855"><code>}</code></span>
<span class="codeline" id="line-9856"><code></code></span>
<span class="codeline" id="line-9857"><code>func (cs *http2clientStream) copyTrailers() {</code></span>
<span class="codeline" id="line-9858"><code>	for k, vv := range cs.trailer {</code></span>
<span class="codeline" id="line-9859"><code>		t := cs.resTrailer</code></span>
<span class="codeline" id="line-9860"><code>		if *t == nil {</code></span>
<span class="codeline" id="line-9861"><code>			*t = make(Header)</code></span>
<span class="codeline" id="line-9862"><code>		}</code></span>
<span class="codeline" id="line-9863"><code>		(*t)[k] = vv</code></span>
<span class="codeline" id="line-9864"><code>	}</code></span>
<span class="codeline" id="line-9865"><code>}</code></span>
<span class="codeline" id="line-9866"><code></code></span>
<span class="codeline" id="line-9867"><code>func (rl *http2clientConnReadLoop) processGoAway(f *http2GoAwayFrame) error {</code></span>
<span class="codeline" id="line-9868"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9869"><code>	cc.t.connPool().MarkDead(cc)</code></span>
<span class="codeline" id="line-9870"><code>	if f.ErrCode != 0 {</code></span>
<span class="codeline" id="line-9871"><code>		// TODO: deal with GOAWAY more. particularly the error code</code></span>
<span class="codeline" id="line-9872"><code>		cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode)</code></span>
<span class="codeline" id="line-9873"><code>		if fn := cc.t.CountError; fn != nil {</code></span>
<span class="codeline" id="line-9874"><code>			fn("recv_goaway_" + f.ErrCode.stringToken())</code></span>
<span class="codeline" id="line-9875"><code>		}</code></span>
<span class="codeline" id="line-9876"><code>	}</code></span>
<span class="codeline" id="line-9877"><code>	cc.setGoAway(f)</code></span>
<span class="codeline" id="line-9878"><code>	return nil</code></span>
<span class="codeline" id="line-9879"><code>}</code></span>
<span class="codeline" id="line-9880"><code></code></span>
<span class="codeline" id="line-9881"><code>func (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error {</code></span>
<span class="codeline" id="line-9882"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9883"><code>	// Locking both mu and wmu here allows frame encoding to read settings with only wmu held.</code></span>
<span class="codeline" id="line-9884"><code>	// Acquiring wmu when f.IsAck() is unnecessary, but convenient and mostly harmless.</code></span>
<span class="codeline" id="line-9885"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-9886"><code>	defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-9887"><code></code></span>
<span class="codeline" id="line-9888"><code>	if err := rl.processSettingsNoWrite(f); err != nil {</code></span>
<span class="codeline" id="line-9889"><code>		return err</code></span>
<span class="codeline" id="line-9890"><code>	}</code></span>
<span class="codeline" id="line-9891"><code>	if !f.IsAck() {</code></span>
<span class="codeline" id="line-9892"><code>		cc.fr.WriteSettingsAck()</code></span>
<span class="codeline" id="line-9893"><code>		cc.bw.Flush()</code></span>
<span class="codeline" id="line-9894"><code>	}</code></span>
<span class="codeline" id="line-9895"><code>	return nil</code></span>
<span class="codeline" id="line-9896"><code>}</code></span>
<span class="codeline" id="line-9897"><code></code></span>
<span class="codeline" id="line-9898"><code>func (rl *http2clientConnReadLoop) processSettingsNoWrite(f *http2SettingsFrame) error {</code></span>
<span class="codeline" id="line-9899"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9900"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-9901"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9902"><code></code></span>
<span class="codeline" id="line-9903"><code>	if f.IsAck() {</code></span>
<span class="codeline" id="line-9904"><code>		if cc.wantSettingsAck {</code></span>
<span class="codeline" id="line-9905"><code>			cc.wantSettingsAck = false</code></span>
<span class="codeline" id="line-9906"><code>			return nil</code></span>
<span class="codeline" id="line-9907"><code>		}</code></span>
<span class="codeline" id="line-9908"><code>		return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-9909"><code>	}</code></span>
<span class="codeline" id="line-9910"><code></code></span>
<span class="codeline" id="line-9911"><code>	var seenMaxConcurrentStreams bool</code></span>
<span class="codeline" id="line-9912"><code>	err := f.ForeachSetting(func(s http2Setting) error {</code></span>
<span class="codeline" id="line-9913"><code>		switch s.ID {</code></span>
<span class="codeline" id="line-9914"><code>		case http2SettingMaxFrameSize:</code></span>
<span class="codeline" id="line-9915"><code>			cc.maxFrameSize = s.Val</code></span>
<span class="codeline" id="line-9916"><code>		case http2SettingMaxConcurrentStreams:</code></span>
<span class="codeline" id="line-9917"><code>			cc.maxConcurrentStreams = s.Val</code></span>
<span class="codeline" id="line-9918"><code>			seenMaxConcurrentStreams = true</code></span>
<span class="codeline" id="line-9919"><code>		case http2SettingMaxHeaderListSize:</code></span>
<span class="codeline" id="line-9920"><code>			cc.peerMaxHeaderListSize = uint64(s.Val)</code></span>
<span class="codeline" id="line-9921"><code>		case http2SettingInitialWindowSize:</code></span>
<span class="codeline" id="line-9922"><code>			// Values above the maximum flow-control</code></span>
<span class="codeline" id="line-9923"><code>			// window size of 2^31-1 MUST be treated as a</code></span>
<span class="codeline" id="line-9924"><code>			// connection error (Section 5.4.1) of type</code></span>
<span class="codeline" id="line-9925"><code>			// FLOW_CONTROL_ERROR.</code></span>
<span class="codeline" id="line-9926"><code>			if s.Val &gt; math.MaxInt32 {</code></span>
<span class="codeline" id="line-9927"><code>				return http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-9928"><code>			}</code></span>
<span class="codeline" id="line-9929"><code></code></span>
<span class="codeline" id="line-9930"><code>			// Adjust flow control of currently-open</code></span>
<span class="codeline" id="line-9931"><code>			// frames by the difference of the old initial</code></span>
<span class="codeline" id="line-9932"><code>			// window size and this one.</code></span>
<span class="codeline" id="line-9933"><code>			delta := int32(s.Val) - int32(cc.initialWindowSize)</code></span>
<span class="codeline" id="line-9934"><code>			for _, cs := range cc.streams {</code></span>
<span class="codeline" id="line-9935"><code>				cs.flow.add(delta)</code></span>
<span class="codeline" id="line-9936"><code>			}</code></span>
<span class="codeline" id="line-9937"><code>			cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-9938"><code></code></span>
<span class="codeline" id="line-9939"><code>			cc.initialWindowSize = s.Val</code></span>
<span class="codeline" id="line-9940"><code>		case http2SettingHeaderTableSize:</code></span>
<span class="codeline" id="line-9941"><code>			cc.henc.SetMaxDynamicTableSize(s.Val)</code></span>
<span class="codeline" id="line-9942"><code>			cc.peerMaxHeaderTableSize = s.Val</code></span>
<span class="codeline" id="line-9943"><code>		default:</code></span>
<span class="codeline" id="line-9944"><code>			cc.vlogf("Unhandled Setting: %v", s)</code></span>
<span class="codeline" id="line-9945"><code>		}</code></span>
<span class="codeline" id="line-9946"><code>		return nil</code></span>
<span class="codeline" id="line-9947"><code>	})</code></span>
<span class="codeline" id="line-9948"><code>	if err != nil {</code></span>
<span class="codeline" id="line-9949"><code>		return err</code></span>
<span class="codeline" id="line-9950"><code>	}</code></span>
<span class="codeline" id="line-9951"><code></code></span>
<span class="codeline" id="line-9952"><code>	if !cc.seenSettings {</code></span>
<span class="codeline" id="line-9953"><code>		if !seenMaxConcurrentStreams {</code></span>
<span class="codeline" id="line-9954"><code>			// This was the servers initial SETTINGS frame and it</code></span>
<span class="codeline" id="line-9955"><code>			// didn't contain a MAX_CONCURRENT_STREAMS field so</code></span>
<span class="codeline" id="line-9956"><code>			// increase the number of concurrent streams this</code></span>
<span class="codeline" id="line-9957"><code>			// connection can establish to our default.</code></span>
<span class="codeline" id="line-9958"><code>			cc.maxConcurrentStreams = http2defaultMaxConcurrentStreams</code></span>
<span class="codeline" id="line-9959"><code>		}</code></span>
<span class="codeline" id="line-9960"><code>		cc.seenSettings = true</code></span>
<span class="codeline" id="line-9961"><code>	}</code></span>
<span class="codeline" id="line-9962"><code></code></span>
<span class="codeline" id="line-9963"><code>	return nil</code></span>
<span class="codeline" id="line-9964"><code>}</code></span>
<span class="codeline" id="line-9965"><code></code></span>
<span class="codeline" id="line-9966"><code>func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error {</code></span>
<span class="codeline" id="line-9967"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-9968"><code>	cs := rl.streamByID(f.StreamID)</code></span>
<span class="codeline" id="line-9969"><code>	if f.StreamID != 0 &amp;&amp; cs == nil {</code></span>
<span class="codeline" id="line-9970"><code>		return nil</code></span>
<span class="codeline" id="line-9971"><code>	}</code></span>
<span class="codeline" id="line-9972"><code></code></span>
<span class="codeline" id="line-9973"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-9974"><code>	defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-9975"><code></code></span>
<span class="codeline" id="line-9976"><code>	fl := &amp;cc.flow</code></span>
<span class="codeline" id="line-9977"><code>	if cs != nil {</code></span>
<span class="codeline" id="line-9978"><code>		fl = &amp;cs.flow</code></span>
<span class="codeline" id="line-9979"><code>	}</code></span>
<span class="codeline" id="line-9980"><code>	if !fl.add(int32(f.Increment)) {</code></span>
<span class="codeline" id="line-9981"><code>		return http2ConnectionError(http2ErrCodeFlowControl)</code></span>
<span class="codeline" id="line-9982"><code>	}</code></span>
<span class="codeline" id="line-9983"><code>	cc.cond.Broadcast()</code></span>
<span class="codeline" id="line-9984"><code>	return nil</code></span>
<span class="codeline" id="line-9985"><code>}</code></span>
<span class="codeline" id="line-9986"><code></code></span>
<span class="codeline" id="line-9987"><code>func (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) error {</code></span>
<span class="codeline" id="line-9988"><code>	cs := rl.streamByID(f.StreamID)</code></span>
<span class="codeline" id="line-9989"><code>	if cs == nil {</code></span>
<span class="codeline" id="line-9990"><code>		// TODO: return error if server tries to RST_STREAM an idle stream</code></span>
<span class="codeline" id="line-9991"><code>		return nil</code></span>
<span class="codeline" id="line-9992"><code>	}</code></span>
<span class="codeline" id="line-9993"><code>	serr := http2streamError(cs.ID, f.ErrCode)</code></span>
<span class="codeline" id="line-9994"><code>	serr.Cause = http2errFromPeer</code></span>
<span class="codeline" id="line-9995"><code>	if f.ErrCode == http2ErrCodeProtocol {</code></span>
<span class="codeline" id="line-9996"><code>		rl.cc.SetDoNotReuse()</code></span>
<span class="codeline" id="line-9997"><code>	}</code></span>
<span class="codeline" id="line-9998"><code>	if fn := cs.cc.t.CountError; fn != nil {</code></span>
<span class="codeline" id="line-9999"><code>		fn("recv_rststream_" + f.ErrCode.stringToken())</code></span>
<span class="codeline" id="line-10000"><code>	}</code></span>
<span class="codeline" id="line-10001"><code>	cs.abortStream(serr)</code></span>
<span class="codeline" id="line-10002"><code></code></span>
<span class="codeline" id="line-10003"><code>	cs.bufPipe.CloseWithError(serr)</code></span>
<span class="codeline" id="line-10004"><code>	return nil</code></span>
<span class="codeline" id="line-10005"><code>}</code></span>
<span class="codeline" id="line-10006"><code></code></span>
<span class="codeline" id="line-10007"><code>// Ping sends a PING frame to the server and waits for the ack.</code></span>
<span class="codeline" id="line-10008"><code>func (cc *http2ClientConn) Ping(ctx context.Context) error {</code></span>
<span class="codeline" id="line-10009"><code>	c := make(chan struct{})</code></span>
<span class="codeline" id="line-10010"><code>	// Generate a random payload</code></span>
<span class="codeline" id="line-10011"><code>	var p [8]byte</code></span>
<span class="codeline" id="line-10012"><code>	for {</code></span>
<span class="codeline" id="line-10013"><code>		if _, err := rand.Read(p[:]); err != nil {</code></span>
<span class="codeline" id="line-10014"><code>			return err</code></span>
<span class="codeline" id="line-10015"><code>		}</code></span>
<span class="codeline" id="line-10016"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-10017"><code>		// check for dup before insert</code></span>
<span class="codeline" id="line-10018"><code>		if _, found := cc.pings[p]; !found {</code></span>
<span class="codeline" id="line-10019"><code>			cc.pings[p] = c</code></span>
<span class="codeline" id="line-10020"><code>			cc.mu.Unlock()</code></span>
<span class="codeline" id="line-10021"><code>			break</code></span>
<span class="codeline" id="line-10022"><code>		}</code></span>
<span class="codeline" id="line-10023"><code>		cc.mu.Unlock()</code></span>
<span class="codeline" id="line-10024"><code>	}</code></span>
<span class="codeline" id="line-10025"><code>	errc := make(chan error, 1)</code></span>
<span class="codeline" id="line-10026"><code>	go func() {</code></span>
<span class="codeline" id="line-10027"><code>		cc.wmu.Lock()</code></span>
<span class="codeline" id="line-10028"><code>		defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-10029"><code>		if err := cc.fr.WritePing(false, p); err != nil {</code></span>
<span class="codeline" id="line-10030"><code>			errc &lt;- err</code></span>
<span class="codeline" id="line-10031"><code>			return</code></span>
<span class="codeline" id="line-10032"><code>		}</code></span>
<span class="codeline" id="line-10033"><code>		if err := cc.bw.Flush(); err != nil {</code></span>
<span class="codeline" id="line-10034"><code>			errc &lt;- err</code></span>
<span class="codeline" id="line-10035"><code>			return</code></span>
<span class="codeline" id="line-10036"><code>		}</code></span>
<span class="codeline" id="line-10037"><code>	}()</code></span>
<span class="codeline" id="line-10038"><code>	select {</code></span>
<span class="codeline" id="line-10039"><code>	case &lt;-c:</code></span>
<span class="codeline" id="line-10040"><code>		return nil</code></span>
<span class="codeline" id="line-10041"><code>	case err := &lt;-errc:</code></span>
<span class="codeline" id="line-10042"><code>		return err</code></span>
<span class="codeline" id="line-10043"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-10044"><code>		return ctx.Err()</code></span>
<span class="codeline" id="line-10045"><code>	case &lt;-cc.readerDone:</code></span>
<span class="codeline" id="line-10046"><code>		// connection closed</code></span>
<span class="codeline" id="line-10047"><code>		return cc.readerErr</code></span>
<span class="codeline" id="line-10048"><code>	}</code></span>
<span class="codeline" id="line-10049"><code>}</code></span>
<span class="codeline" id="line-10050"><code></code></span>
<span class="codeline" id="line-10051"><code>func (rl *http2clientConnReadLoop) processPing(f *http2PingFrame) error {</code></span>
<span class="codeline" id="line-10052"><code>	if f.IsAck() {</code></span>
<span class="codeline" id="line-10053"><code>		cc := rl.cc</code></span>
<span class="codeline" id="line-10054"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-10055"><code>		defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-10056"><code>		// If ack, notify listener if any</code></span>
<span class="codeline" id="line-10057"><code>		if c, ok := cc.pings[f.Data]; ok {</code></span>
<span class="codeline" id="line-10058"><code>			close(c)</code></span>
<span class="codeline" id="line-10059"><code>			delete(cc.pings, f.Data)</code></span>
<span class="codeline" id="line-10060"><code>		}</code></span>
<span class="codeline" id="line-10061"><code>		return nil</code></span>
<span class="codeline" id="line-10062"><code>	}</code></span>
<span class="codeline" id="line-10063"><code>	cc := rl.cc</code></span>
<span class="codeline" id="line-10064"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-10065"><code>	defer cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-10066"><code>	if err := cc.fr.WritePing(true, f.Data); err != nil {</code></span>
<span class="codeline" id="line-10067"><code>		return err</code></span>
<span class="codeline" id="line-10068"><code>	}</code></span>
<span class="codeline" id="line-10069"><code>	return cc.bw.Flush()</code></span>
<span class="codeline" id="line-10070"><code>}</code></span>
<span class="codeline" id="line-10071"><code></code></span>
<span class="codeline" id="line-10072"><code>func (rl *http2clientConnReadLoop) processPushPromise(f *http2PushPromiseFrame) error {</code></span>
<span class="codeline" id="line-10073"><code>	// We told the peer we don't want them.</code></span>
<span class="codeline" id="line-10074"><code>	// Spec says:</code></span>
<span class="codeline" id="line-10075"><code>	// "PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH</code></span>
<span class="codeline" id="line-10076"><code>	// setting of the peer endpoint is set to 0. An endpoint that</code></span>
<span class="codeline" id="line-10077"><code>	// has set this setting and has received acknowledgement MUST</code></span>
<span class="codeline" id="line-10078"><code>	// treat the receipt of a PUSH_PROMISE frame as a connection</code></span>
<span class="codeline" id="line-10079"><code>	// error (Section 5.4.1) of type PROTOCOL_ERROR."</code></span>
<span class="codeline" id="line-10080"><code>	return http2ConnectionError(http2ErrCodeProtocol)</code></span>
<span class="codeline" id="line-10081"><code>}</code></span>
<span class="codeline" id="line-10082"><code></code></span>
<span class="codeline" id="line-10083"><code>func (cc *http2ClientConn) writeStreamReset(streamID uint32, code http2ErrCode, err error) {</code></span>
<span class="codeline" id="line-10084"><code>	// TODO: map err to more interesting error codes, once the</code></span>
<span class="codeline" id="line-10085"><code>	// HTTP community comes up with some. But currently for</code></span>
<span class="codeline" id="line-10086"><code>	// RST_STREAM there's no equivalent to GOAWAY frame's debug</code></span>
<span class="codeline" id="line-10087"><code>	// data, and the error codes are all pretty vague ("cancel").</code></span>
<span class="codeline" id="line-10088"><code>	cc.wmu.Lock()</code></span>
<span class="codeline" id="line-10089"><code>	cc.fr.WriteRSTStream(streamID, code)</code></span>
<span class="codeline" id="line-10090"><code>	cc.bw.Flush()</code></span>
<span class="codeline" id="line-10091"><code>	cc.wmu.Unlock()</code></span>
<span class="codeline" id="line-10092"><code>}</code></span>
<span class="codeline" id="line-10093"><code></code></span>
<span class="codeline" id="line-10094"><code>var (</code></span>
<span class="codeline" id="line-10095"><code>	http2errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit")</code></span>
<span class="codeline" id="line-10096"><code>	http2errRequestHeaderListSize  = errors.New("http2: request header list larger than peer's advertised limit")</code></span>
<span class="codeline" id="line-10097"><code>)</code></span>
<span class="codeline" id="line-10098"><code></code></span>
<span class="codeline" id="line-10099"><code>func (cc *http2ClientConn) logf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-10100"><code>	cc.t.logf(format, args...)</code></span>
<span class="codeline" id="line-10101"><code>}</code></span>
<span class="codeline" id="line-10102"><code></code></span>
<span class="codeline" id="line-10103"><code>func (cc *http2ClientConn) vlogf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-10104"><code>	cc.t.vlogf(format, args...)</code></span>
<span class="codeline" id="line-10105"><code>}</code></span>
<span class="codeline" id="line-10106"><code></code></span>
<span class="codeline" id="line-10107"><code>func (t *http2Transport) vlogf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-10108"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-10109"><code>		t.logf(format, args...)</code></span>
<span class="codeline" id="line-10110"><code>	}</code></span>
<span class="codeline" id="line-10111"><code>}</code></span>
<span class="codeline" id="line-10112"><code></code></span>
<span class="codeline" id="line-10113"><code>func (t *http2Transport) logf(format string, args ...interface{}) {</code></span>
<span class="codeline" id="line-10114"><code>	log.Printf(format, args...)</code></span>
<span class="codeline" id="line-10115"><code>}</code></span>
<span class="codeline" id="line-10116"><code></code></span>
<span class="codeline" id="line-10117"><code>var http2noBody io.ReadCloser = http2noBodyReader{}</code></span>
<span class="codeline" id="line-10118"><code></code></span>
<span class="codeline" id="line-10119"><code>type http2noBodyReader struct{}</code></span>
<span class="codeline" id="line-10120"><code></code></span>
<span class="codeline" id="line-10121"><code>func (http2noBodyReader) Close() error { return nil }</code></span>
<span class="codeline" id="line-10122"><code></code></span>
<span class="codeline" id="line-10123"><code>func (http2noBodyReader) Read([]byte) (int, error) { return 0, io.EOF }</code></span>
<span class="codeline" id="line-10124"><code></code></span>
<span class="codeline" id="line-10125"><code>type http2missingBody struct{}</code></span>
<span class="codeline" id="line-10126"><code></code></span>
<span class="codeline" id="line-10127"><code>func (http2missingBody) Close() error { return nil }</code></span>
<span class="codeline" id="line-10128"><code></code></span>
<span class="codeline" id="line-10129"><code>func (http2missingBody) Read([]byte) (int, error) { return 0, io.ErrUnexpectedEOF }</code></span>
<span class="codeline" id="line-10130"><code></code></span>
<span class="codeline" id="line-10131"><code>func http2strSliceContains(ss []string, s string) bool {</code></span>
<span class="codeline" id="line-10132"><code>	for _, v := range ss {</code></span>
<span class="codeline" id="line-10133"><code>		if v == s {</code></span>
<span class="codeline" id="line-10134"><code>			return true</code></span>
<span class="codeline" id="line-10135"><code>		}</code></span>
<span class="codeline" id="line-10136"><code>	}</code></span>
<span class="codeline" id="line-10137"><code>	return false</code></span>
<span class="codeline" id="line-10138"><code>}</code></span>
<span class="codeline" id="line-10139"><code></code></span>
<span class="codeline" id="line-10140"><code>type http2erringRoundTripper struct{ err error }</code></span>
<span class="codeline" id="line-10141"><code></code></span>
<span class="codeline" id="line-10142"><code>func (rt http2erringRoundTripper) RoundTripErr() error { return rt.err }</code></span>
<span class="codeline" id="line-10143"><code></code></span>
<span class="codeline" id="line-10144"><code>func (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error) { return nil, rt.err }</code></span>
<span class="codeline" id="line-10145"><code></code></span>
<span class="codeline" id="line-10146"><code>// gzipReader wraps a response body so it can lazily</code></span>
<span class="codeline" id="line-10147"><code>// call gzip.NewReader on the first call to Read</code></span>
<span class="codeline" id="line-10148"><code>type http2gzipReader struct {</code></span>
<span class="codeline" id="line-10149"><code>	_    http2incomparable</code></span>
<span class="codeline" id="line-10150"><code>	body io.ReadCloser // underlying Response.Body</code></span>
<span class="codeline" id="line-10151"><code>	zr   *gzip.Reader  // lazily-initialized gzip reader</code></span>
<span class="codeline" id="line-10152"><code>	zerr error         // sticky error</code></span>
<span class="codeline" id="line-10153"><code>}</code></span>
<span class="codeline" id="line-10154"><code></code></span>
<span class="codeline" id="line-10155"><code>func (gz *http2gzipReader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-10156"><code>	if gz.zerr != nil {</code></span>
<span class="codeline" id="line-10157"><code>		return 0, gz.zerr</code></span>
<span class="codeline" id="line-10158"><code>	}</code></span>
<span class="codeline" id="line-10159"><code>	if gz.zr == nil {</code></span>
<span class="codeline" id="line-10160"><code>		gz.zr, err = gzip.NewReader(gz.body)</code></span>
<span class="codeline" id="line-10161"><code>		if err != nil {</code></span>
<span class="codeline" id="line-10162"><code>			gz.zerr = err</code></span>
<span class="codeline" id="line-10163"><code>			return 0, err</code></span>
<span class="codeline" id="line-10164"><code>		}</code></span>
<span class="codeline" id="line-10165"><code>	}</code></span>
<span class="codeline" id="line-10166"><code>	return gz.zr.Read(p)</code></span>
<span class="codeline" id="line-10167"><code>}</code></span>
<span class="codeline" id="line-10168"><code></code></span>
<span class="codeline" id="line-10169"><code>func (gz *http2gzipReader) Close() error {</code></span>
<span class="codeline" id="line-10170"><code>	if err := gz.body.Close(); err != nil {</code></span>
<span class="codeline" id="line-10171"><code>		return err</code></span>
<span class="codeline" id="line-10172"><code>	}</code></span>
<span class="codeline" id="line-10173"><code>	gz.zerr = fs.ErrClosed</code></span>
<span class="codeline" id="line-10174"><code>	return nil</code></span>
<span class="codeline" id="line-10175"><code>}</code></span>
<span class="codeline" id="line-10176"><code></code></span>
<span class="codeline" id="line-10177"><code>type http2errorReader struct{ err error }</code></span>
<span class="codeline" id="line-10178"><code></code></span>
<span class="codeline" id="line-10179"><code>func (r http2errorReader) Read(p []byte) (int, error) { return 0, r.err }</code></span>
<span class="codeline" id="line-10180"><code></code></span>
<span class="codeline" id="line-10181"><code>// isConnectionCloseRequest reports whether req should use its own</code></span>
<span class="codeline" id="line-10182"><code>// connection for a single request and then close the connection.</code></span>
<span class="codeline" id="line-10183"><code>func http2isConnectionCloseRequest(req *Request) bool {</code></span>
<span class="codeline" id="line-10184"><code>	return req.Close || httpguts.HeaderValuesContainsToken(req.Header["Connection"], "close")</code></span>
<span class="codeline" id="line-10185"><code>}</code></span>
<span class="codeline" id="line-10186"><code></code></span>
<span class="codeline" id="line-10187"><code>// registerHTTPSProtocol calls Transport.RegisterProtocol but</code></span>
<span class="codeline" id="line-10188"><code>// converting panics into errors.</code></span>
<span class="codeline" id="line-10189"><code>func http2registerHTTPSProtocol(t *Transport, rt http2noDialH2RoundTripper) (err error) {</code></span>
<span class="codeline" id="line-10190"><code>	defer func() {</code></span>
<span class="codeline" id="line-10191"><code>		if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-10192"><code>			err = fmt.Errorf("%v", e)</code></span>
<span class="codeline" id="line-10193"><code>		}</code></span>
<span class="codeline" id="line-10194"><code>	}()</code></span>
<span class="codeline" id="line-10195"><code>	t.RegisterProtocol("https", rt)</code></span>
<span class="codeline" id="line-10196"><code>	return nil</code></span>
<span class="codeline" id="line-10197"><code>}</code></span>
<span class="codeline" id="line-10198"><code></code></span>
<span class="codeline" id="line-10199"><code>// noDialH2RoundTripper is a RoundTripper which only tries to complete the request</code></span>
<span class="codeline" id="line-10200"><code>// if there's already has a cached connection to the host.</code></span>
<span class="codeline" id="line-10201"><code>// (The field is exported so it can be accessed via reflect from net/http; tested</code></span>
<span class="codeline" id="line-10202"><code>// by TestNoDialH2RoundTripperType)</code></span>
<span class="codeline" id="line-10203"><code>type http2noDialH2RoundTripper struct{ *http2Transport }</code></span>
<span class="codeline" id="line-10204"><code></code></span>
<span class="codeline" id="line-10205"><code>func (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error) {</code></span>
<span class="codeline" id="line-10206"><code>	res, err := rt.http2Transport.RoundTrip(req)</code></span>
<span class="codeline" id="line-10207"><code>	if http2isNoCachedConnError(err) {</code></span>
<span class="codeline" id="line-10208"><code>		return nil, ErrSkipAltProtocol</code></span>
<span class="codeline" id="line-10209"><code>	}</code></span>
<span class="codeline" id="line-10210"><code>	return res, err</code></span>
<span class="codeline" id="line-10211"><code>}</code></span>
<span class="codeline" id="line-10212"><code></code></span>
<span class="codeline" id="line-10213"><code>func (t *http2Transport) idleConnTimeout() time.Duration {</code></span>
<span class="codeline" id="line-10214"><code>	if t.t1 != nil {</code></span>
<span class="codeline" id="line-10215"><code>		return t.t1.IdleConnTimeout</code></span>
<span class="codeline" id="line-10216"><code>	}</code></span>
<span class="codeline" id="line-10217"><code>	return 0</code></span>
<span class="codeline" id="line-10218"><code>}</code></span>
<span class="codeline" id="line-10219"><code></code></span>
<span class="codeline" id="line-10220"><code>func http2traceGetConn(req *Request, hostPort string) {</code></span>
<span class="codeline" id="line-10221"><code>	trace := httptrace.ContextClientTrace(req.Context())</code></span>
<span class="codeline" id="line-10222"><code>	if trace == nil || trace.GetConn == nil {</code></span>
<span class="codeline" id="line-10223"><code>		return</code></span>
<span class="codeline" id="line-10224"><code>	}</code></span>
<span class="codeline" id="line-10225"><code>	trace.GetConn(hostPort)</code></span>
<span class="codeline" id="line-10226"><code>}</code></span>
<span class="codeline" id="line-10227"><code></code></span>
<span class="codeline" id="line-10228"><code>func http2traceGotConn(req *Request, cc *http2ClientConn, reused bool) {</code></span>
<span class="codeline" id="line-10229"><code>	trace := httptrace.ContextClientTrace(req.Context())</code></span>
<span class="codeline" id="line-10230"><code>	if trace == nil || trace.GotConn == nil {</code></span>
<span class="codeline" id="line-10231"><code>		return</code></span>
<span class="codeline" id="line-10232"><code>	}</code></span>
<span class="codeline" id="line-10233"><code>	ci := httptrace.GotConnInfo{Conn: cc.tconn}</code></span>
<span class="codeline" id="line-10234"><code>	ci.Reused = reused</code></span>
<span class="codeline" id="line-10235"><code>	cc.mu.Lock()</code></span>
<span class="codeline" id="line-10236"><code>	ci.WasIdle = len(cc.streams) == 0 &amp;&amp; reused</code></span>
<span class="codeline" id="line-10237"><code>	if ci.WasIdle &amp;&amp; !cc.lastActive.IsZero() {</code></span>
<span class="codeline" id="line-10238"><code>		ci.IdleTime = time.Since(cc.lastActive)</code></span>
<span class="codeline" id="line-10239"><code>	}</code></span>
<span class="codeline" id="line-10240"><code>	cc.mu.Unlock()</code></span>
<span class="codeline" id="line-10241"><code></code></span>
<span class="codeline" id="line-10242"><code>	trace.GotConn(ci)</code></span>
<span class="codeline" id="line-10243"><code>}</code></span>
<span class="codeline" id="line-10244"><code></code></span>
<span class="codeline" id="line-10245"><code>func http2traceWroteHeaders(trace *httptrace.ClientTrace) {</code></span>
<span class="codeline" id="line-10246"><code>	if trace != nil &amp;&amp; trace.WroteHeaders != nil {</code></span>
<span class="codeline" id="line-10247"><code>		trace.WroteHeaders()</code></span>
<span class="codeline" id="line-10248"><code>	}</code></span>
<span class="codeline" id="line-10249"><code>}</code></span>
<span class="codeline" id="line-10250"><code></code></span>
<span class="codeline" id="line-10251"><code>func http2traceGot100Continue(trace *httptrace.ClientTrace) {</code></span>
<span class="codeline" id="line-10252"><code>	if trace != nil &amp;&amp; trace.Got100Continue != nil {</code></span>
<span class="codeline" id="line-10253"><code>		trace.Got100Continue()</code></span>
<span class="codeline" id="line-10254"><code>	}</code></span>
<span class="codeline" id="line-10255"><code>}</code></span>
<span class="codeline" id="line-10256"><code></code></span>
<span class="codeline" id="line-10257"><code>func http2traceWait100Continue(trace *httptrace.ClientTrace) {</code></span>
<span class="codeline" id="line-10258"><code>	if trace != nil &amp;&amp; trace.Wait100Continue != nil {</code></span>
<span class="codeline" id="line-10259"><code>		trace.Wait100Continue()</code></span>
<span class="codeline" id="line-10260"><code>	}</code></span>
<span class="codeline" id="line-10261"><code>}</code></span>
<span class="codeline" id="line-10262"><code></code></span>
<span class="codeline" id="line-10263"><code>func http2traceWroteRequest(trace *httptrace.ClientTrace, err error) {</code></span>
<span class="codeline" id="line-10264"><code>	if trace != nil &amp;&amp; trace.WroteRequest != nil {</code></span>
<span class="codeline" id="line-10265"><code>		trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})</code></span>
<span class="codeline" id="line-10266"><code>	}</code></span>
<span class="codeline" id="line-10267"><code>}</code></span>
<span class="codeline" id="line-10268"><code></code></span>
<span class="codeline" id="line-10269"><code>func http2traceFirstResponseByte(trace *httptrace.ClientTrace) {</code></span>
<span class="codeline" id="line-10270"><code>	if trace != nil &amp;&amp; trace.GotFirstResponseByte != nil {</code></span>
<span class="codeline" id="line-10271"><code>		trace.GotFirstResponseByte()</code></span>
<span class="codeline" id="line-10272"><code>	}</code></span>
<span class="codeline" id="line-10273"><code>}</code></span>
<span class="codeline" id="line-10274"><code></code></span>
<span class="codeline" id="line-10275"><code>func http2traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool {</code></span>
<span class="codeline" id="line-10276"><code>	return trace != nil &amp;&amp; trace.WroteHeaderField != nil</code></span>
<span class="codeline" id="line-10277"><code>}</code></span>
<span class="codeline" id="line-10278"><code></code></span>
<span class="codeline" id="line-10279"><code>func http2traceWroteHeaderField(trace *httptrace.ClientTrace, k, v string) {</code></span>
<span class="codeline" id="line-10280"><code>	if trace != nil &amp;&amp; trace.WroteHeaderField != nil {</code></span>
<span class="codeline" id="line-10281"><code>		trace.WroteHeaderField(k, []string{v})</code></span>
<span class="codeline" id="line-10282"><code>	}</code></span>
<span class="codeline" id="line-10283"><code>}</code></span>
<span class="codeline" id="line-10284"><code></code></span>
<span class="codeline" id="line-10285"><code>func http2traceGot1xxResponseFunc(trace *httptrace.ClientTrace) func(int, textproto.MIMEHeader) error {</code></span>
<span class="codeline" id="line-10286"><code>	if trace != nil {</code></span>
<span class="codeline" id="line-10287"><code>		return trace.Got1xxResponse</code></span>
<span class="codeline" id="line-10288"><code>	}</code></span>
<span class="codeline" id="line-10289"><code>	return nil</code></span>
<span class="codeline" id="line-10290"><code>}</code></span>
<span class="codeline" id="line-10291"><code></code></span>
<span class="codeline" id="line-10292"><code>// dialTLSWithContext uses tls.Dialer, added in Go 1.15, to open a TLS</code></span>
<span class="codeline" id="line-10293"><code>// connection.</code></span>
<span class="codeline" id="line-10294"><code>func (t *http2Transport) dialTLSWithContext(ctx context.Context, network, addr string, cfg *tls.Config) (*tls.Conn, error) {</code></span>
<span class="codeline" id="line-10295"><code>	dialer := &amp;tls.Dialer{</code></span>
<span class="codeline" id="line-10296"><code>		Config: cfg,</code></span>
<span class="codeline" id="line-10297"><code>	}</code></span>
<span class="codeline" id="line-10298"><code>	cn, err := dialer.DialContext(ctx, network, addr)</code></span>
<span class="codeline" id="line-10299"><code>	if err != nil {</code></span>
<span class="codeline" id="line-10300"><code>		return nil, err</code></span>
<span class="codeline" id="line-10301"><code>	}</code></span>
<span class="codeline" id="line-10302"><code>	tlsCn := cn.(*tls.Conn) // DialContext comment promises this will always succeed</code></span>
<span class="codeline" id="line-10303"><code>	return tlsCn, nil</code></span>
<span class="codeline" id="line-10304"><code>}</code></span>
<span class="codeline" id="line-10305"><code></code></span>
<span class="codeline" id="line-10306"><code>// writeFramer is implemented by any type that is used to write frames.</code></span>
<span class="codeline" id="line-10307"><code>type http2writeFramer interface {</code></span>
<span class="codeline" id="line-10308"><code>	writeFrame(http2writeContext) error</code></span>
<span class="codeline" id="line-10309"><code></code></span>
<span class="codeline" id="line-10310"><code>	// staysWithinBuffer reports whether this writer promises that</code></span>
<span class="codeline" id="line-10311"><code>	// it will only write less than or equal to size bytes, and it</code></span>
<span class="codeline" id="line-10312"><code>	// won't Flush the write context.</code></span>
<span class="codeline" id="line-10313"><code>	staysWithinBuffer(size int) bool</code></span>
<span class="codeline" id="line-10314"><code>}</code></span>
<span class="codeline" id="line-10315"><code></code></span>
<span class="codeline" id="line-10316"><code>// writeContext is the interface needed by the various frame writer</code></span>
<span class="codeline" id="line-10317"><code>// types below. All the writeFrame methods below are scheduled via the</code></span>
<span class="codeline" id="line-10318"><code>// frame writing scheduler (see writeScheduler in writesched.go).</code></span>
<span class="codeline" id="line-10319"><code>//</code></span>
<span class="codeline" id="line-10320"><code>// This interface is implemented by *serverConn.</code></span>
<span class="codeline" id="line-10321"><code>//</code></span>
<span class="codeline" id="line-10322"><code>// TODO: decide whether to a) use this in the client code (which didn't</code></span>
<span class="codeline" id="line-10323"><code>// end up using this yet, because it has a simpler design, not</code></span>
<span class="codeline" id="line-10324"><code>// currently implementing priorities), or b) delete this and</code></span>
<span class="codeline" id="line-10325"><code>// make the server code a bit more concrete.</code></span>
<span class="codeline" id="line-10326"><code>type http2writeContext interface {</code></span>
<span class="codeline" id="line-10327"><code>	Framer() *http2Framer</code></span>
<span class="codeline" id="line-10328"><code>	Flush() error</code></span>
<span class="codeline" id="line-10329"><code>	CloseConn() error</code></span>
<span class="codeline" id="line-10330"><code>	// HeaderEncoder returns an HPACK encoder that writes to the</code></span>
<span class="codeline" id="line-10331"><code>	// returned buffer.</code></span>
<span class="codeline" id="line-10332"><code>	HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)</code></span>
<span class="codeline" id="line-10333"><code>}</code></span>
<span class="codeline" id="line-10334"><code></code></span>
<span class="codeline" id="line-10335"><code>// writeEndsStream reports whether w writes a frame that will transition</code></span>
<span class="codeline" id="line-10336"><code>// the stream to a half-closed local state. This returns false for RST_STREAM,</code></span>
<span class="codeline" id="line-10337"><code>// which closes the entire stream (not just the local half).</code></span>
<span class="codeline" id="line-10338"><code>func http2writeEndsStream(w http2writeFramer) bool {</code></span>
<span class="codeline" id="line-10339"><code>	switch v := w.(type) {</code></span>
<span class="codeline" id="line-10340"><code>	case *http2writeData:</code></span>
<span class="codeline" id="line-10341"><code>		return v.endStream</code></span>
<span class="codeline" id="line-10342"><code>	case *http2writeResHeaders:</code></span>
<span class="codeline" id="line-10343"><code>		return v.endStream</code></span>
<span class="codeline" id="line-10344"><code>	case nil:</code></span>
<span class="codeline" id="line-10345"><code>		// This can only happen if the caller reuses w after it's</code></span>
<span class="codeline" id="line-10346"><code>		// been intentionally nil'ed out to prevent use. Keep this</code></span>
<span class="codeline" id="line-10347"><code>		// here to catch future refactoring breaking it.</code></span>
<span class="codeline" id="line-10348"><code>		panic("writeEndsStream called on nil writeFramer")</code></span>
<span class="codeline" id="line-10349"><code>	}</code></span>
<span class="codeline" id="line-10350"><code>	return false</code></span>
<span class="codeline" id="line-10351"><code>}</code></span>
<span class="codeline" id="line-10352"><code></code></span>
<span class="codeline" id="line-10353"><code>type http2flushFrameWriter struct{}</code></span>
<span class="codeline" id="line-10354"><code></code></span>
<span class="codeline" id="line-10355"><code>func (http2flushFrameWriter) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10356"><code>	return ctx.Flush()</code></span>
<span class="codeline" id="line-10357"><code>}</code></span>
<span class="codeline" id="line-10358"><code></code></span>
<span class="codeline" id="line-10359"><code>func (http2flushFrameWriter) staysWithinBuffer(max int) bool { return false }</code></span>
<span class="codeline" id="line-10360"><code></code></span>
<span class="codeline" id="line-10361"><code>type http2writeSettings []http2Setting</code></span>
<span class="codeline" id="line-10362"><code></code></span>
<span class="codeline" id="line-10363"><code>func (s http2writeSettings) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10364"><code>	const settingSize = 6 // uint16 + uint32</code></span>
<span class="codeline" id="line-10365"><code>	return http2frameHeaderLen+settingSize*len(s) &lt;= max</code></span>
<span class="codeline" id="line-10366"><code></code></span>
<span class="codeline" id="line-10367"><code>}</code></span>
<span class="codeline" id="line-10368"><code></code></span>
<span class="codeline" id="line-10369"><code>func (s http2writeSettings) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10370"><code>	return ctx.Framer().WriteSettings([]http2Setting(s)...)</code></span>
<span class="codeline" id="line-10371"><code>}</code></span>
<span class="codeline" id="line-10372"><code></code></span>
<span class="codeline" id="line-10373"><code>type http2writeGoAway struct {</code></span>
<span class="codeline" id="line-10374"><code>	maxStreamID uint32</code></span>
<span class="codeline" id="line-10375"><code>	code        http2ErrCode</code></span>
<span class="codeline" id="line-10376"><code>}</code></span>
<span class="codeline" id="line-10377"><code></code></span>
<span class="codeline" id="line-10378"><code>func (p *http2writeGoAway) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10379"><code>	err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)</code></span>
<span class="codeline" id="line-10380"><code>	ctx.Flush() // ignore error: we're hanging up on them anyway</code></span>
<span class="codeline" id="line-10381"><code>	return err</code></span>
<span class="codeline" id="line-10382"><code>}</code></span>
<span class="codeline" id="line-10383"><code></code></span>
<span class="codeline" id="line-10384"><code>func (*http2writeGoAway) staysWithinBuffer(max int) bool { return false } // flushes</code></span>
<span class="codeline" id="line-10385"><code></code></span>
<span class="codeline" id="line-10386"><code>type http2writeData struct {</code></span>
<span class="codeline" id="line-10387"><code>	streamID  uint32</code></span>
<span class="codeline" id="line-10388"><code>	p         []byte</code></span>
<span class="codeline" id="line-10389"><code>	endStream bool</code></span>
<span class="codeline" id="line-10390"><code>}</code></span>
<span class="codeline" id="line-10391"><code></code></span>
<span class="codeline" id="line-10392"><code>func (w *http2writeData) String() string {</code></span>
<span class="codeline" id="line-10393"><code>	return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream)</code></span>
<span class="codeline" id="line-10394"><code>}</code></span>
<span class="codeline" id="line-10395"><code></code></span>
<span class="codeline" id="line-10396"><code>func (w *http2writeData) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10397"><code>	return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)</code></span>
<span class="codeline" id="line-10398"><code>}</code></span>
<span class="codeline" id="line-10399"><code></code></span>
<span class="codeline" id="line-10400"><code>func (w *http2writeData) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10401"><code>	return http2frameHeaderLen+len(w.p) &lt;= max</code></span>
<span class="codeline" id="line-10402"><code>}</code></span>
<span class="codeline" id="line-10403"><code></code></span>
<span class="codeline" id="line-10404"><code>// handlerPanicRST is the message sent from handler goroutines when</code></span>
<span class="codeline" id="line-10405"><code>// the handler panics.</code></span>
<span class="codeline" id="line-10406"><code>type http2handlerPanicRST struct {</code></span>
<span class="codeline" id="line-10407"><code>	StreamID uint32</code></span>
<span class="codeline" id="line-10408"><code>}</code></span>
<span class="codeline" id="line-10409"><code></code></span>
<span class="codeline" id="line-10410"><code>func (hp http2handlerPanicRST) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10411"><code>	return ctx.Framer().WriteRSTStream(hp.StreamID, http2ErrCodeInternal)</code></span>
<span class="codeline" id="line-10412"><code>}</code></span>
<span class="codeline" id="line-10413"><code></code></span>
<span class="codeline" id="line-10414"><code>func (hp http2handlerPanicRST) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }</code></span>
<span class="codeline" id="line-10415"><code></code></span>
<span class="codeline" id="line-10416"><code>func (se http2StreamError) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10417"><code>	return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)</code></span>
<span class="codeline" id="line-10418"><code>}</code></span>
<span class="codeline" id="line-10419"><code></code></span>
<span class="codeline" id="line-10420"><code>func (se http2StreamError) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }</code></span>
<span class="codeline" id="line-10421"><code></code></span>
<span class="codeline" id="line-10422"><code>type http2writePingAck struct{ pf *http2PingFrame }</code></span>
<span class="codeline" id="line-10423"><code></code></span>
<span class="codeline" id="line-10424"><code>func (w http2writePingAck) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10425"><code>	return ctx.Framer().WritePing(true, w.pf.Data)</code></span>
<span class="codeline" id="line-10426"><code>}</code></span>
<span class="codeline" id="line-10427"><code></code></span>
<span class="codeline" id="line-10428"><code>func (w http2writePingAck) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10429"><code>	return http2frameHeaderLen+len(w.pf.Data) &lt;= max</code></span>
<span class="codeline" id="line-10430"><code>}</code></span>
<span class="codeline" id="line-10431"><code></code></span>
<span class="codeline" id="line-10432"><code>type http2writeSettingsAck struct{}</code></span>
<span class="codeline" id="line-10433"><code></code></span>
<span class="codeline" id="line-10434"><code>func (http2writeSettingsAck) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10435"><code>	return ctx.Framer().WriteSettingsAck()</code></span>
<span class="codeline" id="line-10436"><code>}</code></span>
<span class="codeline" id="line-10437"><code></code></span>
<span class="codeline" id="line-10438"><code>func (http2writeSettingsAck) staysWithinBuffer(max int) bool { return http2frameHeaderLen &lt;= max }</code></span>
<span class="codeline" id="line-10439"><code></code></span>
<span class="codeline" id="line-10440"><code>// splitHeaderBlock splits headerBlock into fragments so that each fragment fits</code></span>
<span class="codeline" id="line-10441"><code>// in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true</code></span>
<span class="codeline" id="line-10442"><code>// for the first/last fragment, respectively.</code></span>
<span class="codeline" id="line-10443"><code>func http2splitHeaderBlock(ctx http2writeContext, headerBlock []byte, fn func(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error) error {</code></span>
<span class="codeline" id="line-10444"><code>	// For now we're lazy and just pick the minimum MAX_FRAME_SIZE</code></span>
<span class="codeline" id="line-10445"><code>	// that all peers must support (16KB). Later we could care</code></span>
<span class="codeline" id="line-10446"><code>	// more and send larger frames if the peer advertised it, but</code></span>
<span class="codeline" id="line-10447"><code>	// there's little point. Most headers are small anyway (so we</code></span>
<span class="codeline" id="line-10448"><code>	// generally won't have CONTINUATION frames), and extra frames</code></span>
<span class="codeline" id="line-10449"><code>	// only waste 9 bytes anyway.</code></span>
<span class="codeline" id="line-10450"><code>	const maxFrameSize = 16384</code></span>
<span class="codeline" id="line-10451"><code></code></span>
<span class="codeline" id="line-10452"><code>	first := true</code></span>
<span class="codeline" id="line-10453"><code>	for len(headerBlock) &gt; 0 {</code></span>
<span class="codeline" id="line-10454"><code>		frag := headerBlock</code></span>
<span class="codeline" id="line-10455"><code>		if len(frag) &gt; maxFrameSize {</code></span>
<span class="codeline" id="line-10456"><code>			frag = frag[:maxFrameSize]</code></span>
<span class="codeline" id="line-10457"><code>		}</code></span>
<span class="codeline" id="line-10458"><code>		headerBlock = headerBlock[len(frag):]</code></span>
<span class="codeline" id="line-10459"><code>		if err := fn(ctx, frag, first, len(headerBlock) == 0); err != nil {</code></span>
<span class="codeline" id="line-10460"><code>			return err</code></span>
<span class="codeline" id="line-10461"><code>		}</code></span>
<span class="codeline" id="line-10462"><code>		first = false</code></span>
<span class="codeline" id="line-10463"><code>	}</code></span>
<span class="codeline" id="line-10464"><code>	return nil</code></span>
<span class="codeline" id="line-10465"><code>}</code></span>
<span class="codeline" id="line-10466"><code></code></span>
<span class="codeline" id="line-10467"><code>// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames</code></span>
<span class="codeline" id="line-10468"><code>// for HTTP response headers or trailers from a server handler.</code></span>
<span class="codeline" id="line-10469"><code>type http2writeResHeaders struct {</code></span>
<span class="codeline" id="line-10470"><code>	streamID    uint32</code></span>
<span class="codeline" id="line-10471"><code>	httpResCode int      // 0 means no ":status" line</code></span>
<span class="codeline" id="line-10472"><code>	h           Header   // may be nil</code></span>
<span class="codeline" id="line-10473"><code>	trailers    []string // if non-nil, which keys of h to write. nil means all.</code></span>
<span class="codeline" id="line-10474"><code>	endStream   bool</code></span>
<span class="codeline" id="line-10475"><code></code></span>
<span class="codeline" id="line-10476"><code>	date          string</code></span>
<span class="codeline" id="line-10477"><code>	contentType   string</code></span>
<span class="codeline" id="line-10478"><code>	contentLength string</code></span>
<span class="codeline" id="line-10479"><code>}</code></span>
<span class="codeline" id="line-10480"><code></code></span>
<span class="codeline" id="line-10481"><code>func http2encKV(enc *hpack.Encoder, k, v string) {</code></span>
<span class="codeline" id="line-10482"><code>	if http2VerboseLogs {</code></span>
<span class="codeline" id="line-10483"><code>		log.Printf("http2: server encoding header %q = %q", k, v)</code></span>
<span class="codeline" id="line-10484"><code>	}</code></span>
<span class="codeline" id="line-10485"><code>	enc.WriteField(hpack.HeaderField{Name: k, Value: v})</code></span>
<span class="codeline" id="line-10486"><code>}</code></span>
<span class="codeline" id="line-10487"><code></code></span>
<span class="codeline" id="line-10488"><code>func (w *http2writeResHeaders) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10489"><code>	// TODO: this is a common one. It'd be nice to return true</code></span>
<span class="codeline" id="line-10490"><code>	// here and get into the fast path if we could be clever and</code></span>
<span class="codeline" id="line-10491"><code>	// calculate the size fast enough, or at least a conservative</code></span>
<span class="codeline" id="line-10492"><code>	// upper bound that usually fires. (Maybe if w.h and</code></span>
<span class="codeline" id="line-10493"><code>	// w.trailers are nil, so we don't need to enumerate it.)</code></span>
<span class="codeline" id="line-10494"><code>	// Otherwise I'm afraid that just calculating the length to</code></span>
<span class="codeline" id="line-10495"><code>	// answer this question would be slower than the ~2µs benefit.</code></span>
<span class="codeline" id="line-10496"><code>	return false</code></span>
<span class="codeline" id="line-10497"><code>}</code></span>
<span class="codeline" id="line-10498"><code></code></span>
<span class="codeline" id="line-10499"><code>func (w *http2writeResHeaders) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10500"><code>	enc, buf := ctx.HeaderEncoder()</code></span>
<span class="codeline" id="line-10501"><code>	buf.Reset()</code></span>
<span class="codeline" id="line-10502"><code></code></span>
<span class="codeline" id="line-10503"><code>	if w.httpResCode != 0 {</code></span>
<span class="codeline" id="line-10504"><code>		http2encKV(enc, ":status", http2httpCodeString(w.httpResCode))</code></span>
<span class="codeline" id="line-10505"><code>	}</code></span>
<span class="codeline" id="line-10506"><code></code></span>
<span class="codeline" id="line-10507"><code>	http2encodeHeaders(enc, w.h, w.trailers)</code></span>
<span class="codeline" id="line-10508"><code></code></span>
<span class="codeline" id="line-10509"><code>	if w.contentType != "" {</code></span>
<span class="codeline" id="line-10510"><code>		http2encKV(enc, "content-type", w.contentType)</code></span>
<span class="codeline" id="line-10511"><code>	}</code></span>
<span class="codeline" id="line-10512"><code>	if w.contentLength != "" {</code></span>
<span class="codeline" id="line-10513"><code>		http2encKV(enc, "content-length", w.contentLength)</code></span>
<span class="codeline" id="line-10514"><code>	}</code></span>
<span class="codeline" id="line-10515"><code>	if w.date != "" {</code></span>
<span class="codeline" id="line-10516"><code>		http2encKV(enc, "date", w.date)</code></span>
<span class="codeline" id="line-10517"><code>	}</code></span>
<span class="codeline" id="line-10518"><code></code></span>
<span class="codeline" id="line-10519"><code>	headerBlock := buf.Bytes()</code></span>
<span class="codeline" id="line-10520"><code>	if len(headerBlock) == 0 &amp;&amp; w.trailers == nil {</code></span>
<span class="codeline" id="line-10521"><code>		panic("unexpected empty hpack")</code></span>
<span class="codeline" id="line-10522"><code>	}</code></span>
<span class="codeline" id="line-10523"><code></code></span>
<span class="codeline" id="line-10524"><code>	return http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)</code></span>
<span class="codeline" id="line-10525"><code>}</code></span>
<span class="codeline" id="line-10526"><code></code></span>
<span class="codeline" id="line-10527"><code>func (w *http2writeResHeaders) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error {</code></span>
<span class="codeline" id="line-10528"><code>	if firstFrag {</code></span>
<span class="codeline" id="line-10529"><code>		return ctx.Framer().WriteHeaders(http2HeadersFrameParam{</code></span>
<span class="codeline" id="line-10530"><code>			StreamID:      w.streamID,</code></span>
<span class="codeline" id="line-10531"><code>			BlockFragment: frag,</code></span>
<span class="codeline" id="line-10532"><code>			EndStream:     w.endStream,</code></span>
<span class="codeline" id="line-10533"><code>			EndHeaders:    lastFrag,</code></span>
<span class="codeline" id="line-10534"><code>		})</code></span>
<span class="codeline" id="line-10535"><code>	} else {</code></span>
<span class="codeline" id="line-10536"><code>		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)</code></span>
<span class="codeline" id="line-10537"><code>	}</code></span>
<span class="codeline" id="line-10538"><code>}</code></span>
<span class="codeline" id="line-10539"><code></code></span>
<span class="codeline" id="line-10540"><code>// writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.</code></span>
<span class="codeline" id="line-10541"><code>type http2writePushPromise struct {</code></span>
<span class="codeline" id="line-10542"><code>	streamID uint32   // pusher stream</code></span>
<span class="codeline" id="line-10543"><code>	method   string   // for :method</code></span>
<span class="codeline" id="line-10544"><code>	url      *url.URL // for :scheme, :authority, :path</code></span>
<span class="codeline" id="line-10545"><code>	h        Header</code></span>
<span class="codeline" id="line-10546"><code></code></span>
<span class="codeline" id="line-10547"><code>	// Creates an ID for a pushed stream. This runs on serveG just before</code></span>
<span class="codeline" id="line-10548"><code>	// the frame is written. The returned ID is copied to promisedID.</code></span>
<span class="codeline" id="line-10549"><code>	allocatePromisedID func() (uint32, error)</code></span>
<span class="codeline" id="line-10550"><code>	promisedID         uint32</code></span>
<span class="codeline" id="line-10551"><code>}</code></span>
<span class="codeline" id="line-10552"><code></code></span>
<span class="codeline" id="line-10553"><code>func (w *http2writePushPromise) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10554"><code>	// TODO: see writeResHeaders.staysWithinBuffer</code></span>
<span class="codeline" id="line-10555"><code>	return false</code></span>
<span class="codeline" id="line-10556"><code>}</code></span>
<span class="codeline" id="line-10557"><code></code></span>
<span class="codeline" id="line-10558"><code>func (w *http2writePushPromise) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10559"><code>	enc, buf := ctx.HeaderEncoder()</code></span>
<span class="codeline" id="line-10560"><code>	buf.Reset()</code></span>
<span class="codeline" id="line-10561"><code></code></span>
<span class="codeline" id="line-10562"><code>	http2encKV(enc, ":method", w.method)</code></span>
<span class="codeline" id="line-10563"><code>	http2encKV(enc, ":scheme", w.url.Scheme)</code></span>
<span class="codeline" id="line-10564"><code>	http2encKV(enc, ":authority", w.url.Host)</code></span>
<span class="codeline" id="line-10565"><code>	http2encKV(enc, ":path", w.url.RequestURI())</code></span>
<span class="codeline" id="line-10566"><code>	http2encodeHeaders(enc, w.h, nil)</code></span>
<span class="codeline" id="line-10567"><code></code></span>
<span class="codeline" id="line-10568"><code>	headerBlock := buf.Bytes()</code></span>
<span class="codeline" id="line-10569"><code>	if len(headerBlock) == 0 {</code></span>
<span class="codeline" id="line-10570"><code>		panic("unexpected empty hpack")</code></span>
<span class="codeline" id="line-10571"><code>	}</code></span>
<span class="codeline" id="line-10572"><code></code></span>
<span class="codeline" id="line-10573"><code>	return http2splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)</code></span>
<span class="codeline" id="line-10574"><code>}</code></span>
<span class="codeline" id="line-10575"><code></code></span>
<span class="codeline" id="line-10576"><code>func (w *http2writePushPromise) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error {</code></span>
<span class="codeline" id="line-10577"><code>	if firstFrag {</code></span>
<span class="codeline" id="line-10578"><code>		return ctx.Framer().WritePushPromise(http2PushPromiseParam{</code></span>
<span class="codeline" id="line-10579"><code>			StreamID:      w.streamID,</code></span>
<span class="codeline" id="line-10580"><code>			PromiseID:     w.promisedID,</code></span>
<span class="codeline" id="line-10581"><code>			BlockFragment: frag,</code></span>
<span class="codeline" id="line-10582"><code>			EndHeaders:    lastFrag,</code></span>
<span class="codeline" id="line-10583"><code>		})</code></span>
<span class="codeline" id="line-10584"><code>	} else {</code></span>
<span class="codeline" id="line-10585"><code>		return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)</code></span>
<span class="codeline" id="line-10586"><code>	}</code></span>
<span class="codeline" id="line-10587"><code>}</code></span>
<span class="codeline" id="line-10588"><code></code></span>
<span class="codeline" id="line-10589"><code>type http2write100ContinueHeadersFrame struct {</code></span>
<span class="codeline" id="line-10590"><code>	streamID uint32</code></span>
<span class="codeline" id="line-10591"><code>}</code></span>
<span class="codeline" id="line-10592"><code></code></span>
<span class="codeline" id="line-10593"><code>func (w http2write100ContinueHeadersFrame) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10594"><code>	enc, buf := ctx.HeaderEncoder()</code></span>
<span class="codeline" id="line-10595"><code>	buf.Reset()</code></span>
<span class="codeline" id="line-10596"><code>	http2encKV(enc, ":status", "100")</code></span>
<span class="codeline" id="line-10597"><code>	return ctx.Framer().WriteHeaders(http2HeadersFrameParam{</code></span>
<span class="codeline" id="line-10598"><code>		StreamID:      w.streamID,</code></span>
<span class="codeline" id="line-10599"><code>		BlockFragment: buf.Bytes(),</code></span>
<span class="codeline" id="line-10600"><code>		EndStream:     false,</code></span>
<span class="codeline" id="line-10601"><code>		EndHeaders:    true,</code></span>
<span class="codeline" id="line-10602"><code>	})</code></span>
<span class="codeline" id="line-10603"><code>}</code></span>
<span class="codeline" id="line-10604"><code></code></span>
<span class="codeline" id="line-10605"><code>func (w http2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool {</code></span>
<span class="codeline" id="line-10606"><code>	// Sloppy but conservative:</code></span>
<span class="codeline" id="line-10607"><code>	return 9+2*(len(":status")+len("100")) &lt;= max</code></span>
<span class="codeline" id="line-10608"><code>}</code></span>
<span class="codeline" id="line-10609"><code></code></span>
<span class="codeline" id="line-10610"><code>type http2writeWindowUpdate struct {</code></span>
<span class="codeline" id="line-10611"><code>	streamID uint32 // or 0 for conn-level</code></span>
<span class="codeline" id="line-10612"><code>	n        uint32</code></span>
<span class="codeline" id="line-10613"><code>}</code></span>
<span class="codeline" id="line-10614"><code></code></span>
<span class="codeline" id="line-10615"><code>func (wu http2writeWindowUpdate) staysWithinBuffer(max int) bool { return http2frameHeaderLen+4 &lt;= max }</code></span>
<span class="codeline" id="line-10616"><code></code></span>
<span class="codeline" id="line-10617"><code>func (wu http2writeWindowUpdate) writeFrame(ctx http2writeContext) error {</code></span>
<span class="codeline" id="line-10618"><code>	return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)</code></span>
<span class="codeline" id="line-10619"><code>}</code></span>
<span class="codeline" id="line-10620"><code></code></span>
<span class="codeline" id="line-10621"><code>// encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])</code></span>
<span class="codeline" id="line-10622"><code>// is encoded only if k is in keys.</code></span>
<span class="codeline" id="line-10623"><code>func http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string) {</code></span>
<span class="codeline" id="line-10624"><code>	if keys == nil {</code></span>
<span class="codeline" id="line-10625"><code>		sorter := http2sorterPool.Get().(*http2sorter)</code></span>
<span class="codeline" id="line-10626"><code>		// Using defer here, since the returned keys from the</code></span>
<span class="codeline" id="line-10627"><code>		// sorter.Keys method is only valid until the sorter</code></span>
<span class="codeline" id="line-10628"><code>		// is returned:</code></span>
<span class="codeline" id="line-10629"><code>		defer http2sorterPool.Put(sorter)</code></span>
<span class="codeline" id="line-10630"><code>		keys = sorter.Keys(h)</code></span>
<span class="codeline" id="line-10631"><code>	}</code></span>
<span class="codeline" id="line-10632"><code>	for _, k := range keys {</code></span>
<span class="codeline" id="line-10633"><code>		vv := h[k]</code></span>
<span class="codeline" id="line-10634"><code>		k, ascii := http2lowerHeader(k)</code></span>
<span class="codeline" id="line-10635"><code>		if !ascii {</code></span>
<span class="codeline" id="line-10636"><code>			// Skip writing invalid headers. Per RFC 7540, Section 8.1.2, header</code></span>
<span class="codeline" id="line-10637"><code>			// field names have to be ASCII characters (just as in HTTP/1.x).</code></span>
<span class="codeline" id="line-10638"><code>			continue</code></span>
<span class="codeline" id="line-10639"><code>		}</code></span>
<span class="codeline" id="line-10640"><code>		if !http2validWireHeaderFieldName(k) {</code></span>
<span class="codeline" id="line-10641"><code>			// Skip it as backup paranoia. Per</code></span>
<span class="codeline" id="line-10642"><code>			// golang.org/issue/14048, these should</code></span>
<span class="codeline" id="line-10643"><code>			// already be rejected at a higher level.</code></span>
<span class="codeline" id="line-10644"><code>			continue</code></span>
<span class="codeline" id="line-10645"><code>		}</code></span>
<span class="codeline" id="line-10646"><code>		isTE := k == "transfer-encoding"</code></span>
<span class="codeline" id="line-10647"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-10648"><code>			if !httpguts.ValidHeaderFieldValue(v) {</code></span>
<span class="codeline" id="line-10649"><code>				// TODO: return an error? golang.org/issue/14048</code></span>
<span class="codeline" id="line-10650"><code>				// For now just omit it.</code></span>
<span class="codeline" id="line-10651"><code>				continue</code></span>
<span class="codeline" id="line-10652"><code>			}</code></span>
<span class="codeline" id="line-10653"><code>			// TODO: more of "8.1.2.2 Connection-Specific Header Fields"</code></span>
<span class="codeline" id="line-10654"><code>			if isTE &amp;&amp; v != "trailers" {</code></span>
<span class="codeline" id="line-10655"><code>				continue</code></span>
<span class="codeline" id="line-10656"><code>			}</code></span>
<span class="codeline" id="line-10657"><code>			http2encKV(enc, k, v)</code></span>
<span class="codeline" id="line-10658"><code>		}</code></span>
<span class="codeline" id="line-10659"><code>	}</code></span>
<span class="codeline" id="line-10660"><code>}</code></span>
<span class="codeline" id="line-10661"><code></code></span>
<span class="codeline" id="line-10662"><code>// WriteScheduler is the interface implemented by HTTP/2 write schedulers.</code></span>
<span class="codeline" id="line-10663"><code>// Methods are never called concurrently.</code></span>
<span class="codeline" id="line-10664"><code>type http2WriteScheduler interface {</code></span>
<span class="codeline" id="line-10665"><code>	// OpenStream opens a new stream in the write scheduler.</code></span>
<span class="codeline" id="line-10666"><code>	// It is illegal to call this with streamID=0 or with a streamID that is</code></span>
<span class="codeline" id="line-10667"><code>	// already open -- the call may panic.</code></span>
<span class="codeline" id="line-10668"><code>	OpenStream(streamID uint32, options http2OpenStreamOptions)</code></span>
<span class="codeline" id="line-10669"><code></code></span>
<span class="codeline" id="line-10670"><code>	// CloseStream closes a stream in the write scheduler. Any frames queued on</code></span>
<span class="codeline" id="line-10671"><code>	// this stream should be discarded. It is illegal to call this on a stream</code></span>
<span class="codeline" id="line-10672"><code>	// that is not open -- the call may panic.</code></span>
<span class="codeline" id="line-10673"><code>	CloseStream(streamID uint32)</code></span>
<span class="codeline" id="line-10674"><code></code></span>
<span class="codeline" id="line-10675"><code>	// AdjustStream adjusts the priority of the given stream. This may be called</code></span>
<span class="codeline" id="line-10676"><code>	// on a stream that has not yet been opened or has been closed. Note that</code></span>
<span class="codeline" id="line-10677"><code>	// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:</code></span>
<span class="codeline" id="line-10678"><code>	// https://tools.ietf.org/html/rfc7540#section-5.1</code></span>
<span class="codeline" id="line-10679"><code>	AdjustStream(streamID uint32, priority http2PriorityParam)</code></span>
<span class="codeline" id="line-10680"><code></code></span>
<span class="codeline" id="line-10681"><code>	// Push queues a frame in the scheduler. In most cases, this will not be</code></span>
<span class="codeline" id="line-10682"><code>	// called with wr.StreamID()!=0 unless that stream is currently open. The one</code></span>
<span class="codeline" id="line-10683"><code>	// exception is RST_STREAM frames, which may be sent on idle or closed streams.</code></span>
<span class="codeline" id="line-10684"><code>	Push(wr http2FrameWriteRequest)</code></span>
<span class="codeline" id="line-10685"><code></code></span>
<span class="codeline" id="line-10686"><code>	// Pop dequeues the next frame to write. Returns false if no frames can</code></span>
<span class="codeline" id="line-10687"><code>	// be written. Frames with a given wr.StreamID() are Pop'd in the same</code></span>
<span class="codeline" id="line-10688"><code>	// order they are Push'd, except RST_STREAM frames. No frames should be</code></span>
<span class="codeline" id="line-10689"><code>	// discarded except by CloseStream.</code></span>
<span class="codeline" id="line-10690"><code>	Pop() (wr http2FrameWriteRequest, ok bool)</code></span>
<span class="codeline" id="line-10691"><code>}</code></span>
<span class="codeline" id="line-10692"><code></code></span>
<span class="codeline" id="line-10693"><code>// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.</code></span>
<span class="codeline" id="line-10694"><code>type http2OpenStreamOptions struct {</code></span>
<span class="codeline" id="line-10695"><code>	// PusherID is zero if the stream was initiated by the client. Otherwise,</code></span>
<span class="codeline" id="line-10696"><code>	// PusherID names the stream that pushed the newly opened stream.</code></span>
<span class="codeline" id="line-10697"><code>	PusherID uint32</code></span>
<span class="codeline" id="line-10698"><code>}</code></span>
<span class="codeline" id="line-10699"><code></code></span>
<span class="codeline" id="line-10700"><code>// FrameWriteRequest is a request to write a frame.</code></span>
<span class="codeline" id="line-10701"><code>type http2FrameWriteRequest struct {</code></span>
<span class="codeline" id="line-10702"><code>	// write is the interface value that does the writing, once the</code></span>
<span class="codeline" id="line-10703"><code>	// WriteScheduler has selected this frame to write. The write</code></span>
<span class="codeline" id="line-10704"><code>	// functions are all defined in write.go.</code></span>
<span class="codeline" id="line-10705"><code>	write http2writeFramer</code></span>
<span class="codeline" id="line-10706"><code></code></span>
<span class="codeline" id="line-10707"><code>	// stream is the stream on which this frame will be written.</code></span>
<span class="codeline" id="line-10708"><code>	// nil for non-stream frames like PING and SETTINGS.</code></span>
<span class="codeline" id="line-10709"><code>	// nil for RST_STREAM streams, which use the StreamError.StreamID field instead.</code></span>
<span class="codeline" id="line-10710"><code>	stream *http2stream</code></span>
<span class="codeline" id="line-10711"><code></code></span>
<span class="codeline" id="line-10712"><code>	// done, if non-nil, must be a buffered channel with space for</code></span>
<span class="codeline" id="line-10713"><code>	// 1 message and is sent the return value from write (or an</code></span>
<span class="codeline" id="line-10714"><code>	// earlier error) when the frame has been written.</code></span>
<span class="codeline" id="line-10715"><code>	done chan error</code></span>
<span class="codeline" id="line-10716"><code>}</code></span>
<span class="codeline" id="line-10717"><code></code></span>
<span class="codeline" id="line-10718"><code>// StreamID returns the id of the stream this frame will be written to.</code></span>
<span class="codeline" id="line-10719"><code>// 0 is used for non-stream frames such as PING and SETTINGS.</code></span>
<span class="codeline" id="line-10720"><code>func (wr http2FrameWriteRequest) StreamID() uint32 {</code></span>
<span class="codeline" id="line-10721"><code>	if wr.stream == nil {</code></span>
<span class="codeline" id="line-10722"><code>		if se, ok := wr.write.(http2StreamError); ok {</code></span>
<span class="codeline" id="line-10723"><code>			// (*serverConn).resetStream doesn't set</code></span>
<span class="codeline" id="line-10724"><code>			// stream because it doesn't necessarily have</code></span>
<span class="codeline" id="line-10725"><code>			// one. So special case this type of write</code></span>
<span class="codeline" id="line-10726"><code>			// message.</code></span>
<span class="codeline" id="line-10727"><code>			return se.StreamID</code></span>
<span class="codeline" id="line-10728"><code>		}</code></span>
<span class="codeline" id="line-10729"><code>		return 0</code></span>
<span class="codeline" id="line-10730"><code>	}</code></span>
<span class="codeline" id="line-10731"><code>	return wr.stream.id</code></span>
<span class="codeline" id="line-10732"><code>}</code></span>
<span class="codeline" id="line-10733"><code></code></span>
<span class="codeline" id="line-10734"><code>// isControl reports whether wr is a control frame for MaxQueuedControlFrames</code></span>
<span class="codeline" id="line-10735"><code>// purposes. That includes non-stream frames and RST_STREAM frames.</code></span>
<span class="codeline" id="line-10736"><code>func (wr http2FrameWriteRequest) isControl() bool {</code></span>
<span class="codeline" id="line-10737"><code>	return wr.stream == nil</code></span>
<span class="codeline" id="line-10738"><code>}</code></span>
<span class="codeline" id="line-10739"><code></code></span>
<span class="codeline" id="line-10740"><code>// DataSize returns the number of flow control bytes that must be consumed</code></span>
<span class="codeline" id="line-10741"><code>// to write this entire frame. This is 0 for non-DATA frames.</code></span>
<span class="codeline" id="line-10742"><code>func (wr http2FrameWriteRequest) DataSize() int {</code></span>
<span class="codeline" id="line-10743"><code>	if wd, ok := wr.write.(*http2writeData); ok {</code></span>
<span class="codeline" id="line-10744"><code>		return len(wd.p)</code></span>
<span class="codeline" id="line-10745"><code>	}</code></span>
<span class="codeline" id="line-10746"><code>	return 0</code></span>
<span class="codeline" id="line-10747"><code>}</code></span>
<span class="codeline" id="line-10748"><code></code></span>
<span class="codeline" id="line-10749"><code>// Consume consumes min(n, available) bytes from this frame, where available</code></span>
<span class="codeline" id="line-10750"><code>// is the number of flow control bytes available on the stream. Consume returns</code></span>
<span class="codeline" id="line-10751"><code>// 0, 1, or 2 frames, where the integer return value gives the number of frames</code></span>
<span class="codeline" id="line-10752"><code>// returned.</code></span>
<span class="codeline" id="line-10753"><code>//</code></span>
<span class="codeline" id="line-10754"><code>// If flow control prevents consuming any bytes, this returns (_, _, 0). If</code></span>
<span class="codeline" id="line-10755"><code>// the entire frame was consumed, this returns (wr, _, 1). Otherwise, this</code></span>
<span class="codeline" id="line-10756"><code>// returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and</code></span>
<span class="codeline" id="line-10757"><code>// 'rest' contains the remaining bytes. The consumed bytes are deducted from the</code></span>
<span class="codeline" id="line-10758"><code>// underlying stream's flow control budget.</code></span>
<span class="codeline" id="line-10759"><code>func (wr http2FrameWriteRequest) Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int) {</code></span>
<span class="codeline" id="line-10760"><code>	var empty http2FrameWriteRequest</code></span>
<span class="codeline" id="line-10761"><code></code></span>
<span class="codeline" id="line-10762"><code>	// Non-DATA frames are always consumed whole.</code></span>
<span class="codeline" id="line-10763"><code>	wd, ok := wr.write.(*http2writeData)</code></span>
<span class="codeline" id="line-10764"><code>	if !ok || len(wd.p) == 0 {</code></span>
<span class="codeline" id="line-10765"><code>		return wr, empty, 1</code></span>
<span class="codeline" id="line-10766"><code>	}</code></span>
<span class="codeline" id="line-10767"><code></code></span>
<span class="codeline" id="line-10768"><code>	// Might need to split after applying limits.</code></span>
<span class="codeline" id="line-10769"><code>	allowed := wr.stream.flow.available()</code></span>
<span class="codeline" id="line-10770"><code>	if n &lt; allowed {</code></span>
<span class="codeline" id="line-10771"><code>		allowed = n</code></span>
<span class="codeline" id="line-10772"><code>	}</code></span>
<span class="codeline" id="line-10773"><code>	if wr.stream.sc.maxFrameSize &lt; allowed {</code></span>
<span class="codeline" id="line-10774"><code>		allowed = wr.stream.sc.maxFrameSize</code></span>
<span class="codeline" id="line-10775"><code>	}</code></span>
<span class="codeline" id="line-10776"><code>	if allowed &lt;= 0 {</code></span>
<span class="codeline" id="line-10777"><code>		return empty, empty, 0</code></span>
<span class="codeline" id="line-10778"><code>	}</code></span>
<span class="codeline" id="line-10779"><code>	if len(wd.p) &gt; int(allowed) {</code></span>
<span class="codeline" id="line-10780"><code>		wr.stream.flow.take(allowed)</code></span>
<span class="codeline" id="line-10781"><code>		consumed := http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-10782"><code>			stream: wr.stream,</code></span>
<span class="codeline" id="line-10783"><code>			write: &amp;http2writeData{</code></span>
<span class="codeline" id="line-10784"><code>				streamID: wd.streamID,</code></span>
<span class="codeline" id="line-10785"><code>				p:        wd.p[:allowed],</code></span>
<span class="codeline" id="line-10786"><code>				// Even if the original had endStream set, there</code></span>
<span class="codeline" id="line-10787"><code>				// are bytes remaining because len(wd.p) &gt; allowed,</code></span>
<span class="codeline" id="line-10788"><code>				// so we know endStream is false.</code></span>
<span class="codeline" id="line-10789"><code>				endStream: false,</code></span>
<span class="codeline" id="line-10790"><code>			},</code></span>
<span class="codeline" id="line-10791"><code>			// Our caller is blocking on the final DATA frame, not</code></span>
<span class="codeline" id="line-10792"><code>			// this intermediate frame, so no need to wait.</code></span>
<span class="codeline" id="line-10793"><code>			done: nil,</code></span>
<span class="codeline" id="line-10794"><code>		}</code></span>
<span class="codeline" id="line-10795"><code>		rest := http2FrameWriteRequest{</code></span>
<span class="codeline" id="line-10796"><code>			stream: wr.stream,</code></span>
<span class="codeline" id="line-10797"><code>			write: &amp;http2writeData{</code></span>
<span class="codeline" id="line-10798"><code>				streamID:  wd.streamID,</code></span>
<span class="codeline" id="line-10799"><code>				p:         wd.p[allowed:],</code></span>
<span class="codeline" id="line-10800"><code>				endStream: wd.endStream,</code></span>
<span class="codeline" id="line-10801"><code>			},</code></span>
<span class="codeline" id="line-10802"><code>			done: wr.done,</code></span>
<span class="codeline" id="line-10803"><code>		}</code></span>
<span class="codeline" id="line-10804"><code>		return consumed, rest, 2</code></span>
<span class="codeline" id="line-10805"><code>	}</code></span>
<span class="codeline" id="line-10806"><code></code></span>
<span class="codeline" id="line-10807"><code>	// The frame is consumed whole.</code></span>
<span class="codeline" id="line-10808"><code>	// NB: This cast cannot overflow because allowed is &lt;= math.MaxInt32.</code></span>
<span class="codeline" id="line-10809"><code>	wr.stream.flow.take(int32(len(wd.p)))</code></span>
<span class="codeline" id="line-10810"><code>	return wr, empty, 1</code></span>
<span class="codeline" id="line-10811"><code>}</code></span>
<span class="codeline" id="line-10812"><code></code></span>
<span class="codeline" id="line-10813"><code>// String is for debugging only.</code></span>
<span class="codeline" id="line-10814"><code>func (wr http2FrameWriteRequest) String() string {</code></span>
<span class="codeline" id="line-10815"><code>	var des string</code></span>
<span class="codeline" id="line-10816"><code>	if s, ok := wr.write.(fmt.Stringer); ok {</code></span>
<span class="codeline" id="line-10817"><code>		des = s.String()</code></span>
<span class="codeline" id="line-10818"><code>	} else {</code></span>
<span class="codeline" id="line-10819"><code>		des = fmt.Sprintf("%T", wr.write)</code></span>
<span class="codeline" id="line-10820"><code>	}</code></span>
<span class="codeline" id="line-10821"><code>	return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != nil, des)</code></span>
<span class="codeline" id="line-10822"><code>}</code></span>
<span class="codeline" id="line-10823"><code></code></span>
<span class="codeline" id="line-10824"><code>// replyToWriter sends err to wr.done and panics if the send must block</code></span>
<span class="codeline" id="line-10825"><code>// This does nothing if wr.done is nil.</code></span>
<span class="codeline" id="line-10826"><code>func (wr *http2FrameWriteRequest) replyToWriter(err error) {</code></span>
<span class="codeline" id="line-10827"><code>	if wr.done == nil {</code></span>
<span class="codeline" id="line-10828"><code>		return</code></span>
<span class="codeline" id="line-10829"><code>	}</code></span>
<span class="codeline" id="line-10830"><code>	select {</code></span>
<span class="codeline" id="line-10831"><code>	case wr.done &lt;- err:</code></span>
<span class="codeline" id="line-10832"><code>	default:</code></span>
<span class="codeline" id="line-10833"><code>		panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write))</code></span>
<span class="codeline" id="line-10834"><code>	}</code></span>
<span class="codeline" id="line-10835"><code>	wr.write = nil // prevent use (assume it's tainted after wr.done send)</code></span>
<span class="codeline" id="line-10836"><code>}</code></span>
<span class="codeline" id="line-10837"><code></code></span>
<span class="codeline" id="line-10838"><code>// writeQueue is used by implementations of WriteScheduler.</code></span>
<span class="codeline" id="line-10839"><code>type http2writeQueue struct {</code></span>
<span class="codeline" id="line-10840"><code>	s          []http2FrameWriteRequest</code></span>
<span class="codeline" id="line-10841"><code>	prev, next *http2writeQueue</code></span>
<span class="codeline" id="line-10842"><code>}</code></span>
<span class="codeline" id="line-10843"><code></code></span>
<span class="codeline" id="line-10844"><code>func (q *http2writeQueue) empty() bool { return len(q.s) == 0 }</code></span>
<span class="codeline" id="line-10845"><code></code></span>
<span class="codeline" id="line-10846"><code>func (q *http2writeQueue) push(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-10847"><code>	q.s = append(q.s, wr)</code></span>
<span class="codeline" id="line-10848"><code>}</code></span>
<span class="codeline" id="line-10849"><code></code></span>
<span class="codeline" id="line-10850"><code>func (q *http2writeQueue) shift() http2FrameWriteRequest {</code></span>
<span class="codeline" id="line-10851"><code>	if len(q.s) == 0 {</code></span>
<span class="codeline" id="line-10852"><code>		panic("invalid use of queue")</code></span>
<span class="codeline" id="line-10853"><code>	}</code></span>
<span class="codeline" id="line-10854"><code>	wr := q.s[0]</code></span>
<span class="codeline" id="line-10855"><code>	// TODO: less copy-happy queue.</code></span>
<span class="codeline" id="line-10856"><code>	copy(q.s, q.s[1:])</code></span>
<span class="codeline" id="line-10857"><code>	q.s[len(q.s)-1] = http2FrameWriteRequest{}</code></span>
<span class="codeline" id="line-10858"><code>	q.s = q.s[:len(q.s)-1]</code></span>
<span class="codeline" id="line-10859"><code>	return wr</code></span>
<span class="codeline" id="line-10860"><code>}</code></span>
<span class="codeline" id="line-10861"><code></code></span>
<span class="codeline" id="line-10862"><code>// consume consumes up to n bytes from q.s[0]. If the frame is</code></span>
<span class="codeline" id="line-10863"><code>// entirely consumed, it is removed from the queue. If the frame</code></span>
<span class="codeline" id="line-10864"><code>// is partially consumed, the frame is kept with the consumed</code></span>
<span class="codeline" id="line-10865"><code>// bytes removed. Returns true iff any bytes were consumed.</code></span>
<span class="codeline" id="line-10866"><code>func (q *http2writeQueue) consume(n int32) (http2FrameWriteRequest, bool) {</code></span>
<span class="codeline" id="line-10867"><code>	if len(q.s) == 0 {</code></span>
<span class="codeline" id="line-10868"><code>		return http2FrameWriteRequest{}, false</code></span>
<span class="codeline" id="line-10869"><code>	}</code></span>
<span class="codeline" id="line-10870"><code>	consumed, rest, numresult := q.s[0].Consume(n)</code></span>
<span class="codeline" id="line-10871"><code>	switch numresult {</code></span>
<span class="codeline" id="line-10872"><code>	case 0:</code></span>
<span class="codeline" id="line-10873"><code>		return http2FrameWriteRequest{}, false</code></span>
<span class="codeline" id="line-10874"><code>	case 1:</code></span>
<span class="codeline" id="line-10875"><code>		q.shift()</code></span>
<span class="codeline" id="line-10876"><code>	case 2:</code></span>
<span class="codeline" id="line-10877"><code>		q.s[0] = rest</code></span>
<span class="codeline" id="line-10878"><code>	}</code></span>
<span class="codeline" id="line-10879"><code>	return consumed, true</code></span>
<span class="codeline" id="line-10880"><code>}</code></span>
<span class="codeline" id="line-10881"><code></code></span>
<span class="codeline" id="line-10882"><code>type http2writeQueuePool []*http2writeQueue</code></span>
<span class="codeline" id="line-10883"><code></code></span>
<span class="codeline" id="line-10884"><code>// put inserts an unused writeQueue into the pool.</code></span>
<span class="codeline" id="line-10885"><code></code></span>
<span class="codeline" id="line-10886"><code>// put inserts an unused writeQueue into the pool.</code></span>
<span class="codeline" id="line-10887"><code>func (p *http2writeQueuePool) put(q *http2writeQueue) {</code></span>
<span class="codeline" id="line-10888"><code>	for i := range q.s {</code></span>
<span class="codeline" id="line-10889"><code>		q.s[i] = http2FrameWriteRequest{}</code></span>
<span class="codeline" id="line-10890"><code>	}</code></span>
<span class="codeline" id="line-10891"><code>	q.s = q.s[:0]</code></span>
<span class="codeline" id="line-10892"><code>	*p = append(*p, q)</code></span>
<span class="codeline" id="line-10893"><code>}</code></span>
<span class="codeline" id="line-10894"><code></code></span>
<span class="codeline" id="line-10895"><code>// get returns an empty writeQueue.</code></span>
<span class="codeline" id="line-10896"><code>func (p *http2writeQueuePool) get() *http2writeQueue {</code></span>
<span class="codeline" id="line-10897"><code>	ln := len(*p)</code></span>
<span class="codeline" id="line-10898"><code>	if ln == 0 {</code></span>
<span class="codeline" id="line-10899"><code>		return new(http2writeQueue)</code></span>
<span class="codeline" id="line-10900"><code>	}</code></span>
<span class="codeline" id="line-10901"><code>	x := ln - 1</code></span>
<span class="codeline" id="line-10902"><code>	q := (*p)[x]</code></span>
<span class="codeline" id="line-10903"><code>	(*p)[x] = nil</code></span>
<span class="codeline" id="line-10904"><code>	*p = (*p)[:x]</code></span>
<span class="codeline" id="line-10905"><code>	return q</code></span>
<span class="codeline" id="line-10906"><code>}</code></span>
<span class="codeline" id="line-10907"><code></code></span>
<span class="codeline" id="line-10908"><code>// RFC 7540, Section 5.3.5: the default weight is 16.</code></span>
<span class="codeline" id="line-10909"><code>const http2priorityDefaultWeight = 15 // 16 = 15 + 1</code></span>
<span class="codeline" id="line-10910"><code></code></span>
<span class="codeline" id="line-10911"><code>// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.</code></span>
<span class="codeline" id="line-10912"><code>type http2PriorityWriteSchedulerConfig struct {</code></span>
<span class="codeline" id="line-10913"><code>	// MaxClosedNodesInTree controls the maximum number of closed streams to</code></span>
<span class="codeline" id="line-10914"><code>	// retain in the priority tree. Setting this to zero saves a small amount</code></span>
<span class="codeline" id="line-10915"><code>	// of memory at the cost of performance.</code></span>
<span class="codeline" id="line-10916"><code>	//</code></span>
<span class="codeline" id="line-10917"><code>	// See RFC 7540, Section 5.3.4:</code></span>
<span class="codeline" id="line-10918"><code>	//   "It is possible for a stream to become closed while prioritization</code></span>
<span class="codeline" id="line-10919"><code>	//   information ... is in transit. ... This potentially creates suboptimal</code></span>
<span class="codeline" id="line-10920"><code>	//   prioritization, since the stream could be given a priority that is</code></span>
<span class="codeline" id="line-10921"><code>	//   different from what is intended. To avoid these problems, an endpoint</code></span>
<span class="codeline" id="line-10922"><code>	//   SHOULD retain stream prioritization state for a period after streams</code></span>
<span class="codeline" id="line-10923"><code>	//   become closed. The longer state is retained, the lower the chance that</code></span>
<span class="codeline" id="line-10924"><code>	//   streams are assigned incorrect or default priority values."</code></span>
<span class="codeline" id="line-10925"><code>	MaxClosedNodesInTree int</code></span>
<span class="codeline" id="line-10926"><code></code></span>
<span class="codeline" id="line-10927"><code>	// MaxIdleNodesInTree controls the maximum number of idle streams to</code></span>
<span class="codeline" id="line-10928"><code>	// retain in the priority tree. Setting this to zero saves a small amount</code></span>
<span class="codeline" id="line-10929"><code>	// of memory at the cost of performance.</code></span>
<span class="codeline" id="line-10930"><code>	//</code></span>
<span class="codeline" id="line-10931"><code>	// See RFC 7540, Section 5.3.4:</code></span>
<span class="codeline" id="line-10932"><code>	//   Similarly, streams that are in the "idle" state can be assigned</code></span>
<span class="codeline" id="line-10933"><code>	//   priority or become a parent of other streams. This allows for the</code></span>
<span class="codeline" id="line-10934"><code>	//   creation of a grouping node in the dependency tree, which enables</code></span>
<span class="codeline" id="line-10935"><code>	//   more flexible expressions of priority. Idle streams begin with a</code></span>
<span class="codeline" id="line-10936"><code>	//   default priority (Section 5.3.5).</code></span>
<span class="codeline" id="line-10937"><code>	MaxIdleNodesInTree int</code></span>
<span class="codeline" id="line-10938"><code></code></span>
<span class="codeline" id="line-10939"><code>	// ThrottleOutOfOrderWrites enables write throttling to help ensure that</code></span>
<span class="codeline" id="line-10940"><code>	// data is delivered in priority order. This works around a race where</code></span>
<span class="codeline" id="line-10941"><code>	// stream B depends on stream A and both streams are about to call Write</code></span>
<span class="codeline" id="line-10942"><code>	// to queue DATA frames. If B wins the race, a naive scheduler would eagerly</code></span>
<span class="codeline" id="line-10943"><code>	// write as much data from B as possible, but this is suboptimal because A</code></span>
<span class="codeline" id="line-10944"><code>	// is a higher-priority stream. With throttling enabled, we write a small</code></span>
<span class="codeline" id="line-10945"><code>	// amount of data from B to minimize the amount of bandwidth that B can</code></span>
<span class="codeline" id="line-10946"><code>	// steal from A.</code></span>
<span class="codeline" id="line-10947"><code>	ThrottleOutOfOrderWrites bool</code></span>
<span class="codeline" id="line-10948"><code>}</code></span>
<span class="codeline" id="line-10949"><code></code></span>
<span class="codeline" id="line-10950"><code>// NewPriorityWriteScheduler constructs a WriteScheduler that schedules</code></span>
<span class="codeline" id="line-10951"><code>// frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.</code></span>
<span class="codeline" id="line-10952"><code>// If cfg is nil, default options are used.</code></span>
<span class="codeline" id="line-10953"><code>func http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler {</code></span>
<span class="codeline" id="line-10954"><code>	if cfg == nil {</code></span>
<span class="codeline" id="line-10955"><code>		// For justification of these defaults, see:</code></span>
<span class="codeline" id="line-10956"><code>		// https://docs.google.com/document/d/1oLhNg1skaWD4_DtaoCxdSRN5erEXrH-KnLrMwEpOtFY</code></span>
<span class="codeline" id="line-10957"><code>		cfg = &amp;http2PriorityWriteSchedulerConfig{</code></span>
<span class="codeline" id="line-10958"><code>			MaxClosedNodesInTree:     10,</code></span>
<span class="codeline" id="line-10959"><code>			MaxIdleNodesInTree:       10,</code></span>
<span class="codeline" id="line-10960"><code>			ThrottleOutOfOrderWrites: false,</code></span>
<span class="codeline" id="line-10961"><code>		}</code></span>
<span class="codeline" id="line-10962"><code>	}</code></span>
<span class="codeline" id="line-10963"><code></code></span>
<span class="codeline" id="line-10964"><code>	ws := &amp;http2priorityWriteScheduler{</code></span>
<span class="codeline" id="line-10965"><code>		nodes:                make(map[uint32]*http2priorityNode),</code></span>
<span class="codeline" id="line-10966"><code>		maxClosedNodesInTree: cfg.MaxClosedNodesInTree,</code></span>
<span class="codeline" id="line-10967"><code>		maxIdleNodesInTree:   cfg.MaxIdleNodesInTree,</code></span>
<span class="codeline" id="line-10968"><code>		enableWriteThrottle:  cfg.ThrottleOutOfOrderWrites,</code></span>
<span class="codeline" id="line-10969"><code>	}</code></span>
<span class="codeline" id="line-10970"><code>	ws.nodes[0] = &amp;ws.root</code></span>
<span class="codeline" id="line-10971"><code>	if cfg.ThrottleOutOfOrderWrites {</code></span>
<span class="codeline" id="line-10972"><code>		ws.writeThrottleLimit = 1024</code></span>
<span class="codeline" id="line-10973"><code>	} else {</code></span>
<span class="codeline" id="line-10974"><code>		ws.writeThrottleLimit = math.MaxInt32</code></span>
<span class="codeline" id="line-10975"><code>	}</code></span>
<span class="codeline" id="line-10976"><code>	return ws</code></span>
<span class="codeline" id="line-10977"><code>}</code></span>
<span class="codeline" id="line-10978"><code></code></span>
<span class="codeline" id="line-10979"><code>type http2priorityNodeState int</code></span>
<span class="codeline" id="line-10980"><code></code></span>
<span class="codeline" id="line-10981"><code>const (</code></span>
<span class="codeline" id="line-10982"><code>	http2priorityNodeOpen http2priorityNodeState = iota</code></span>
<span class="codeline" id="line-10983"><code>	http2priorityNodeClosed</code></span>
<span class="codeline" id="line-10984"><code>	http2priorityNodeIdle</code></span>
<span class="codeline" id="line-10985"><code>)</code></span>
<span class="codeline" id="line-10986"><code></code></span>
<span class="codeline" id="line-10987"><code>// priorityNode is a node in an HTTP/2 priority tree.</code></span>
<span class="codeline" id="line-10988"><code>// Each node is associated with a single stream ID.</code></span>
<span class="codeline" id="line-10989"><code>// See RFC 7540, Section 5.3.</code></span>
<span class="codeline" id="line-10990"><code>type http2priorityNode struct {</code></span>
<span class="codeline" id="line-10991"><code>	q            http2writeQueue        // queue of pending frames to write</code></span>
<span class="codeline" id="line-10992"><code>	id           uint32                 // id of the stream, or 0 for the root of the tree</code></span>
<span class="codeline" id="line-10993"><code>	weight       uint8                  // the actual weight is weight+1, so the value is in [1,256]</code></span>
<span class="codeline" id="line-10994"><code>	state        http2priorityNodeState // open | closed | idle</code></span>
<span class="codeline" id="line-10995"><code>	bytes        int64                  // number of bytes written by this node, or 0 if closed</code></span>
<span class="codeline" id="line-10996"><code>	subtreeBytes int64                  // sum(node.bytes) of all nodes in this subtree</code></span>
<span class="codeline" id="line-10997"><code></code></span>
<span class="codeline" id="line-10998"><code>	// These links form the priority tree.</code></span>
<span class="codeline" id="line-10999"><code>	parent     *http2priorityNode</code></span>
<span class="codeline" id="line-11000"><code>	kids       *http2priorityNode // start of the kids list</code></span>
<span class="codeline" id="line-11001"><code>	prev, next *http2priorityNode // doubly-linked list of siblings</code></span>
<span class="codeline" id="line-11002"><code>}</code></span>
<span class="codeline" id="line-11003"><code></code></span>
<span class="codeline" id="line-11004"><code>func (n *http2priorityNode) setParent(parent *http2priorityNode) {</code></span>
<span class="codeline" id="line-11005"><code>	if n == parent {</code></span>
<span class="codeline" id="line-11006"><code>		panic("setParent to self")</code></span>
<span class="codeline" id="line-11007"><code>	}</code></span>
<span class="codeline" id="line-11008"><code>	if n.parent == parent {</code></span>
<span class="codeline" id="line-11009"><code>		return</code></span>
<span class="codeline" id="line-11010"><code>	}</code></span>
<span class="codeline" id="line-11011"><code>	// Unlink from current parent.</code></span>
<span class="codeline" id="line-11012"><code>	if parent := n.parent; parent != nil {</code></span>
<span class="codeline" id="line-11013"><code>		if n.prev == nil {</code></span>
<span class="codeline" id="line-11014"><code>			parent.kids = n.next</code></span>
<span class="codeline" id="line-11015"><code>		} else {</code></span>
<span class="codeline" id="line-11016"><code>			n.prev.next = n.next</code></span>
<span class="codeline" id="line-11017"><code>		}</code></span>
<span class="codeline" id="line-11018"><code>		if n.next != nil {</code></span>
<span class="codeline" id="line-11019"><code>			n.next.prev = n.prev</code></span>
<span class="codeline" id="line-11020"><code>		}</code></span>
<span class="codeline" id="line-11021"><code>	}</code></span>
<span class="codeline" id="line-11022"><code>	// Link to new parent.</code></span>
<span class="codeline" id="line-11023"><code>	// If parent=nil, remove n from the tree.</code></span>
<span class="codeline" id="line-11024"><code>	// Always insert at the head of parent.kids (this is assumed by walkReadyInOrder).</code></span>
<span class="codeline" id="line-11025"><code>	n.parent = parent</code></span>
<span class="codeline" id="line-11026"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-11027"><code>		n.next = nil</code></span>
<span class="codeline" id="line-11028"><code>		n.prev = nil</code></span>
<span class="codeline" id="line-11029"><code>	} else {</code></span>
<span class="codeline" id="line-11030"><code>		n.next = parent.kids</code></span>
<span class="codeline" id="line-11031"><code>		n.prev = nil</code></span>
<span class="codeline" id="line-11032"><code>		if n.next != nil {</code></span>
<span class="codeline" id="line-11033"><code>			n.next.prev = n</code></span>
<span class="codeline" id="line-11034"><code>		}</code></span>
<span class="codeline" id="line-11035"><code>		parent.kids = n</code></span>
<span class="codeline" id="line-11036"><code>	}</code></span>
<span class="codeline" id="line-11037"><code>}</code></span>
<span class="codeline" id="line-11038"><code></code></span>
<span class="codeline" id="line-11039"><code>func (n *http2priorityNode) addBytes(b int64) {</code></span>
<span class="codeline" id="line-11040"><code>	n.bytes += b</code></span>
<span class="codeline" id="line-11041"><code>	for ; n != nil; n = n.parent {</code></span>
<span class="codeline" id="line-11042"><code>		n.subtreeBytes += b</code></span>
<span class="codeline" id="line-11043"><code>	}</code></span>
<span class="codeline" id="line-11044"><code>}</code></span>
<span class="codeline" id="line-11045"><code></code></span>
<span class="codeline" id="line-11046"><code>// walkReadyInOrder iterates over the tree in priority order, calling f for each node</code></span>
<span class="codeline" id="line-11047"><code>// with a non-empty write queue. When f returns true, this function returns true and the</code></span>
<span class="codeline" id="line-11048"><code>// walk halts. tmp is used as scratch space for sorting.</code></span>
<span class="codeline" id="line-11049"><code>//</code></span>
<span class="codeline" id="line-11050"><code>// f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true</code></span>
<span class="codeline" id="line-11051"><code>// if any ancestor p of n is still open (ignoring the root node).</code></span>
<span class="codeline" id="line-11052"><code>func (n *http2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*http2priorityNode, f func(*http2priorityNode, bool) bool) bool {</code></span>
<span class="codeline" id="line-11053"><code>	if !n.q.empty() &amp;&amp; f(n, openParent) {</code></span>
<span class="codeline" id="line-11054"><code>		return true</code></span>
<span class="codeline" id="line-11055"><code>	}</code></span>
<span class="codeline" id="line-11056"><code>	if n.kids == nil {</code></span>
<span class="codeline" id="line-11057"><code>		return false</code></span>
<span class="codeline" id="line-11058"><code>	}</code></span>
<span class="codeline" id="line-11059"><code></code></span>
<span class="codeline" id="line-11060"><code>	// Don't consider the root "open" when updating openParent since</code></span>
<span class="codeline" id="line-11061"><code>	// we can't send data frames on the root stream (only control frames).</code></span>
<span class="codeline" id="line-11062"><code>	if n.id != 0 {</code></span>
<span class="codeline" id="line-11063"><code>		openParent = openParent || (n.state == http2priorityNodeOpen)</code></span>
<span class="codeline" id="line-11064"><code>	}</code></span>
<span class="codeline" id="line-11065"><code></code></span>
<span class="codeline" id="line-11066"><code>	// Common case: only one kid or all kids have the same weight.</code></span>
<span class="codeline" id="line-11067"><code>	// Some clients don't use weights; other clients (like web browsers)</code></span>
<span class="codeline" id="line-11068"><code>	// use mostly-linear priority trees.</code></span>
<span class="codeline" id="line-11069"><code>	w := n.kids.weight</code></span>
<span class="codeline" id="line-11070"><code>	needSort := false</code></span>
<span class="codeline" id="line-11071"><code>	for k := n.kids.next; k != nil; k = k.next {</code></span>
<span class="codeline" id="line-11072"><code>		if k.weight != w {</code></span>
<span class="codeline" id="line-11073"><code>			needSort = true</code></span>
<span class="codeline" id="line-11074"><code>			break</code></span>
<span class="codeline" id="line-11075"><code>		}</code></span>
<span class="codeline" id="line-11076"><code>	}</code></span>
<span class="codeline" id="line-11077"><code>	if !needSort {</code></span>
<span class="codeline" id="line-11078"><code>		for k := n.kids; k != nil; k = k.next {</code></span>
<span class="codeline" id="line-11079"><code>			if k.walkReadyInOrder(openParent, tmp, f) {</code></span>
<span class="codeline" id="line-11080"><code>				return true</code></span>
<span class="codeline" id="line-11081"><code>			}</code></span>
<span class="codeline" id="line-11082"><code>		}</code></span>
<span class="codeline" id="line-11083"><code>		return false</code></span>
<span class="codeline" id="line-11084"><code>	}</code></span>
<span class="codeline" id="line-11085"><code></code></span>
<span class="codeline" id="line-11086"><code>	// Uncommon case: sort the child nodes. We remove the kids from the parent,</code></span>
<span class="codeline" id="line-11087"><code>	// then re-insert after sorting so we can reuse tmp for future sort calls.</code></span>
<span class="codeline" id="line-11088"><code>	*tmp = (*tmp)[:0]</code></span>
<span class="codeline" id="line-11089"><code>	for n.kids != nil {</code></span>
<span class="codeline" id="line-11090"><code>		*tmp = append(*tmp, n.kids)</code></span>
<span class="codeline" id="line-11091"><code>		n.kids.setParent(nil)</code></span>
<span class="codeline" id="line-11092"><code>	}</code></span>
<span class="codeline" id="line-11093"><code>	sort.Sort(http2sortPriorityNodeSiblings(*tmp))</code></span>
<span class="codeline" id="line-11094"><code>	for i := len(*tmp) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-11095"><code>		(*tmp)[i].setParent(n) // setParent inserts at the head of n.kids</code></span>
<span class="codeline" id="line-11096"><code>	}</code></span>
<span class="codeline" id="line-11097"><code>	for k := n.kids; k != nil; k = k.next {</code></span>
<span class="codeline" id="line-11098"><code>		if k.walkReadyInOrder(openParent, tmp, f) {</code></span>
<span class="codeline" id="line-11099"><code>			return true</code></span>
<span class="codeline" id="line-11100"><code>		}</code></span>
<span class="codeline" id="line-11101"><code>	}</code></span>
<span class="codeline" id="line-11102"><code>	return false</code></span>
<span class="codeline" id="line-11103"><code>}</code></span>
<span class="codeline" id="line-11104"><code></code></span>
<span class="codeline" id="line-11105"><code>type http2sortPriorityNodeSiblings []*http2priorityNode</code></span>
<span class="codeline" id="line-11106"><code></code></span>
<span class="codeline" id="line-11107"><code>func (z http2sortPriorityNodeSiblings) Len() int { return len(z) }</code></span>
<span class="codeline" id="line-11108"><code></code></span>
<span class="codeline" id="line-11109"><code>func (z http2sortPriorityNodeSiblings) Swap(i, k int) { z[i], z[k] = z[k], z[i] }</code></span>
<span class="codeline" id="line-11110"><code></code></span>
<span class="codeline" id="line-11111"><code>func (z http2sortPriorityNodeSiblings) Less(i, k int) bool {</code></span>
<span class="codeline" id="line-11112"><code>	// Prefer the subtree that has sent fewer bytes relative to its weight.</code></span>
<span class="codeline" id="line-11113"><code>	// See sections 5.3.2 and 5.3.4.</code></span>
<span class="codeline" id="line-11114"><code>	wi, bi := float64(z[i].weight+1), float64(z[i].subtreeBytes)</code></span>
<span class="codeline" id="line-11115"><code>	wk, bk := float64(z[k].weight+1), float64(z[k].subtreeBytes)</code></span>
<span class="codeline" id="line-11116"><code>	if bi == 0 &amp;&amp; bk == 0 {</code></span>
<span class="codeline" id="line-11117"><code>		return wi &gt;= wk</code></span>
<span class="codeline" id="line-11118"><code>	}</code></span>
<span class="codeline" id="line-11119"><code>	if bk == 0 {</code></span>
<span class="codeline" id="line-11120"><code>		return false</code></span>
<span class="codeline" id="line-11121"><code>	}</code></span>
<span class="codeline" id="line-11122"><code>	return bi/bk &lt;= wi/wk</code></span>
<span class="codeline" id="line-11123"><code>}</code></span>
<span class="codeline" id="line-11124"><code></code></span>
<span class="codeline" id="line-11125"><code>type http2priorityWriteScheduler struct {</code></span>
<span class="codeline" id="line-11126"><code>	// root is the root of the priority tree, where root.id = 0.</code></span>
<span class="codeline" id="line-11127"><code>	// The root queues control frames that are not associated with any stream.</code></span>
<span class="codeline" id="line-11128"><code>	root http2priorityNode</code></span>
<span class="codeline" id="line-11129"><code></code></span>
<span class="codeline" id="line-11130"><code>	// nodes maps stream ids to priority tree nodes.</code></span>
<span class="codeline" id="line-11131"><code>	nodes map[uint32]*http2priorityNode</code></span>
<span class="codeline" id="line-11132"><code></code></span>
<span class="codeline" id="line-11133"><code>	// maxID is the maximum stream id in nodes.</code></span>
<span class="codeline" id="line-11134"><code>	maxID uint32</code></span>
<span class="codeline" id="line-11135"><code></code></span>
<span class="codeline" id="line-11136"><code>	// lists of nodes that have been closed or are idle, but are kept in</code></span>
<span class="codeline" id="line-11137"><code>	// the tree for improved prioritization. When the lengths exceed either</code></span>
<span class="codeline" id="line-11138"><code>	// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.</code></span>
<span class="codeline" id="line-11139"><code>	closedNodes, idleNodes []*http2priorityNode</code></span>
<span class="codeline" id="line-11140"><code></code></span>
<span class="codeline" id="line-11141"><code>	// From the config.</code></span>
<span class="codeline" id="line-11142"><code>	maxClosedNodesInTree int</code></span>
<span class="codeline" id="line-11143"><code>	maxIdleNodesInTree   int</code></span>
<span class="codeline" id="line-11144"><code>	writeThrottleLimit   int32</code></span>
<span class="codeline" id="line-11145"><code>	enableWriteThrottle  bool</code></span>
<span class="codeline" id="line-11146"><code></code></span>
<span class="codeline" id="line-11147"><code>	// tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.</code></span>
<span class="codeline" id="line-11148"><code>	tmp []*http2priorityNode</code></span>
<span class="codeline" id="line-11149"><code></code></span>
<span class="codeline" id="line-11150"><code>	// pool of empty queues for reuse.</code></span>
<span class="codeline" id="line-11151"><code>	queuePool http2writeQueuePool</code></span>
<span class="codeline" id="line-11152"><code>}</code></span>
<span class="codeline" id="line-11153"><code></code></span>
<span class="codeline" id="line-11154"><code>func (ws *http2priorityWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions) {</code></span>
<span class="codeline" id="line-11155"><code>	// The stream may be currently idle but cannot be opened or closed.</code></span>
<span class="codeline" id="line-11156"><code>	if curr := ws.nodes[streamID]; curr != nil {</code></span>
<span class="codeline" id="line-11157"><code>		if curr.state != http2priorityNodeIdle {</code></span>
<span class="codeline" id="line-11158"><code>			panic(fmt.Sprintf("stream %d already opened", streamID))</code></span>
<span class="codeline" id="line-11159"><code>		}</code></span>
<span class="codeline" id="line-11160"><code>		curr.state = http2priorityNodeOpen</code></span>
<span class="codeline" id="line-11161"><code>		return</code></span>
<span class="codeline" id="line-11162"><code>	}</code></span>
<span class="codeline" id="line-11163"><code></code></span>
<span class="codeline" id="line-11164"><code>	// RFC 7540, Section 5.3.5:</code></span>
<span class="codeline" id="line-11165"><code>	//  "All streams are initially assigned a non-exclusive dependency on stream 0x0.</code></span>
<span class="codeline" id="line-11166"><code>	//  Pushed streams initially depend on their associated stream. In both cases,</code></span>
<span class="codeline" id="line-11167"><code>	//  streams are assigned a default weight of 16."</code></span>
<span class="codeline" id="line-11168"><code>	parent := ws.nodes[options.PusherID]</code></span>
<span class="codeline" id="line-11169"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-11170"><code>		parent = &amp;ws.root</code></span>
<span class="codeline" id="line-11171"><code>	}</code></span>
<span class="codeline" id="line-11172"><code>	n := &amp;http2priorityNode{</code></span>
<span class="codeline" id="line-11173"><code>		q:      *ws.queuePool.get(),</code></span>
<span class="codeline" id="line-11174"><code>		id:     streamID,</code></span>
<span class="codeline" id="line-11175"><code>		weight: http2priorityDefaultWeight,</code></span>
<span class="codeline" id="line-11176"><code>		state:  http2priorityNodeOpen,</code></span>
<span class="codeline" id="line-11177"><code>	}</code></span>
<span class="codeline" id="line-11178"><code>	n.setParent(parent)</code></span>
<span class="codeline" id="line-11179"><code>	ws.nodes[streamID] = n</code></span>
<span class="codeline" id="line-11180"><code>	if streamID &gt; ws.maxID {</code></span>
<span class="codeline" id="line-11181"><code>		ws.maxID = streamID</code></span>
<span class="codeline" id="line-11182"><code>	}</code></span>
<span class="codeline" id="line-11183"><code>}</code></span>
<span class="codeline" id="line-11184"><code></code></span>
<span class="codeline" id="line-11185"><code>func (ws *http2priorityWriteScheduler) CloseStream(streamID uint32) {</code></span>
<span class="codeline" id="line-11186"><code>	if streamID == 0 {</code></span>
<span class="codeline" id="line-11187"><code>		panic("violation of WriteScheduler interface: cannot close stream 0")</code></span>
<span class="codeline" id="line-11188"><code>	}</code></span>
<span class="codeline" id="line-11189"><code>	if ws.nodes[streamID] == nil {</code></span>
<span class="codeline" id="line-11190"><code>		panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID))</code></span>
<span class="codeline" id="line-11191"><code>	}</code></span>
<span class="codeline" id="line-11192"><code>	if ws.nodes[streamID].state != http2priorityNodeOpen {</code></span>
<span class="codeline" id="line-11193"><code>		panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID))</code></span>
<span class="codeline" id="line-11194"><code>	}</code></span>
<span class="codeline" id="line-11195"><code></code></span>
<span class="codeline" id="line-11196"><code>	n := ws.nodes[streamID]</code></span>
<span class="codeline" id="line-11197"><code>	n.state = http2priorityNodeClosed</code></span>
<span class="codeline" id="line-11198"><code>	n.addBytes(-n.bytes)</code></span>
<span class="codeline" id="line-11199"><code></code></span>
<span class="codeline" id="line-11200"><code>	q := n.q</code></span>
<span class="codeline" id="line-11201"><code>	ws.queuePool.put(&amp;q)</code></span>
<span class="codeline" id="line-11202"><code>	n.q.s = nil</code></span>
<span class="codeline" id="line-11203"><code>	if ws.maxClosedNodesInTree &gt; 0 {</code></span>
<span class="codeline" id="line-11204"><code>		ws.addClosedOrIdleNode(&amp;ws.closedNodes, ws.maxClosedNodesInTree, n)</code></span>
<span class="codeline" id="line-11205"><code>	} else {</code></span>
<span class="codeline" id="line-11206"><code>		ws.removeNode(n)</code></span>
<span class="codeline" id="line-11207"><code>	}</code></span>
<span class="codeline" id="line-11208"><code>}</code></span>
<span class="codeline" id="line-11209"><code></code></span>
<span class="codeline" id="line-11210"><code>func (ws *http2priorityWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam) {</code></span>
<span class="codeline" id="line-11211"><code>	if streamID == 0 {</code></span>
<span class="codeline" id="line-11212"><code>		panic("adjustPriority on root")</code></span>
<span class="codeline" id="line-11213"><code>	}</code></span>
<span class="codeline" id="line-11214"><code></code></span>
<span class="codeline" id="line-11215"><code>	// If streamID does not exist, there are two cases:</code></span>
<span class="codeline" id="line-11216"><code>	// - A closed stream that has been removed (this will have ID &lt;= maxID)</code></span>
<span class="codeline" id="line-11217"><code>	// - An idle stream that is being used for "grouping" (this will have ID &gt; maxID)</code></span>
<span class="codeline" id="line-11218"><code>	n := ws.nodes[streamID]</code></span>
<span class="codeline" id="line-11219"><code>	if n == nil {</code></span>
<span class="codeline" id="line-11220"><code>		if streamID &lt;= ws.maxID || ws.maxIdleNodesInTree == 0 {</code></span>
<span class="codeline" id="line-11221"><code>			return</code></span>
<span class="codeline" id="line-11222"><code>		}</code></span>
<span class="codeline" id="line-11223"><code>		ws.maxID = streamID</code></span>
<span class="codeline" id="line-11224"><code>		n = &amp;http2priorityNode{</code></span>
<span class="codeline" id="line-11225"><code>			q:      *ws.queuePool.get(),</code></span>
<span class="codeline" id="line-11226"><code>			id:     streamID,</code></span>
<span class="codeline" id="line-11227"><code>			weight: http2priorityDefaultWeight,</code></span>
<span class="codeline" id="line-11228"><code>			state:  http2priorityNodeIdle,</code></span>
<span class="codeline" id="line-11229"><code>		}</code></span>
<span class="codeline" id="line-11230"><code>		n.setParent(&amp;ws.root)</code></span>
<span class="codeline" id="line-11231"><code>		ws.nodes[streamID] = n</code></span>
<span class="codeline" id="line-11232"><code>		ws.addClosedOrIdleNode(&amp;ws.idleNodes, ws.maxIdleNodesInTree, n)</code></span>
<span class="codeline" id="line-11233"><code>	}</code></span>
<span class="codeline" id="line-11234"><code></code></span>
<span class="codeline" id="line-11235"><code>	// Section 5.3.1: A dependency on a stream that is not currently in the tree</code></span>
<span class="codeline" id="line-11236"><code>	// results in that stream being given a default priority (Section 5.3.5).</code></span>
<span class="codeline" id="line-11237"><code>	parent := ws.nodes[priority.StreamDep]</code></span>
<span class="codeline" id="line-11238"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-11239"><code>		n.setParent(&amp;ws.root)</code></span>
<span class="codeline" id="line-11240"><code>		n.weight = http2priorityDefaultWeight</code></span>
<span class="codeline" id="line-11241"><code>		return</code></span>
<span class="codeline" id="line-11242"><code>	}</code></span>
<span class="codeline" id="line-11243"><code></code></span>
<span class="codeline" id="line-11244"><code>	// Ignore if the client tries to make a node its own parent.</code></span>
<span class="codeline" id="line-11245"><code>	if n == parent {</code></span>
<span class="codeline" id="line-11246"><code>		return</code></span>
<span class="codeline" id="line-11247"><code>	}</code></span>
<span class="codeline" id="line-11248"><code></code></span>
<span class="codeline" id="line-11249"><code>	// Section 5.3.3:</code></span>
<span class="codeline" id="line-11250"><code>	//   "If a stream is made dependent on one of its own dependencies, the</code></span>
<span class="codeline" id="line-11251"><code>	//   formerly dependent stream is first moved to be dependent on the</code></span>
<span class="codeline" id="line-11252"><code>	//   reprioritized stream's previous parent. The moved dependency retains</code></span>
<span class="codeline" id="line-11253"><code>	//   its weight."</code></span>
<span class="codeline" id="line-11254"><code>	//</code></span>
<span class="codeline" id="line-11255"><code>	// That is: if parent depends on n, move parent to depend on n.parent.</code></span>
<span class="codeline" id="line-11256"><code>	for x := parent.parent; x != nil; x = x.parent {</code></span>
<span class="codeline" id="line-11257"><code>		if x == n {</code></span>
<span class="codeline" id="line-11258"><code>			parent.setParent(n.parent)</code></span>
<span class="codeline" id="line-11259"><code>			break</code></span>
<span class="codeline" id="line-11260"><code>		}</code></span>
<span class="codeline" id="line-11261"><code>	}</code></span>
<span class="codeline" id="line-11262"><code></code></span>
<span class="codeline" id="line-11263"><code>	// Section 5.3.3: The exclusive flag causes the stream to become the sole</code></span>
<span class="codeline" id="line-11264"><code>	// dependency of its parent stream, causing other dependencies to become</code></span>
<span class="codeline" id="line-11265"><code>	// dependent on the exclusive stream.</code></span>
<span class="codeline" id="line-11266"><code>	if priority.Exclusive {</code></span>
<span class="codeline" id="line-11267"><code>		k := parent.kids</code></span>
<span class="codeline" id="line-11268"><code>		for k != nil {</code></span>
<span class="codeline" id="line-11269"><code>			next := k.next</code></span>
<span class="codeline" id="line-11270"><code>			if k != n {</code></span>
<span class="codeline" id="line-11271"><code>				k.setParent(n)</code></span>
<span class="codeline" id="line-11272"><code>			}</code></span>
<span class="codeline" id="line-11273"><code>			k = next</code></span>
<span class="codeline" id="line-11274"><code>		}</code></span>
<span class="codeline" id="line-11275"><code>	}</code></span>
<span class="codeline" id="line-11276"><code></code></span>
<span class="codeline" id="line-11277"><code>	n.setParent(parent)</code></span>
<span class="codeline" id="line-11278"><code>	n.weight = priority.Weight</code></span>
<span class="codeline" id="line-11279"><code>}</code></span>
<span class="codeline" id="line-11280"><code></code></span>
<span class="codeline" id="line-11281"><code>func (ws *http2priorityWriteScheduler) Push(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-11282"><code>	var n *http2priorityNode</code></span>
<span class="codeline" id="line-11283"><code>	if wr.isControl() {</code></span>
<span class="codeline" id="line-11284"><code>		n = &amp;ws.root</code></span>
<span class="codeline" id="line-11285"><code>	} else {</code></span>
<span class="codeline" id="line-11286"><code>		id := wr.StreamID()</code></span>
<span class="codeline" id="line-11287"><code>		n = ws.nodes[id]</code></span>
<span class="codeline" id="line-11288"><code>		if n == nil {</code></span>
<span class="codeline" id="line-11289"><code>			// id is an idle or closed stream. wr should not be a HEADERS or</code></span>
<span class="codeline" id="line-11290"><code>			// DATA frame. In other case, we push wr onto the root, rather</code></span>
<span class="codeline" id="line-11291"><code>			// than creating a new priorityNode.</code></span>
<span class="codeline" id="line-11292"><code>			if wr.DataSize() &gt; 0 {</code></span>
<span class="codeline" id="line-11293"><code>				panic("add DATA on non-open stream")</code></span>
<span class="codeline" id="line-11294"><code>			}</code></span>
<span class="codeline" id="line-11295"><code>			n = &amp;ws.root</code></span>
<span class="codeline" id="line-11296"><code>		}</code></span>
<span class="codeline" id="line-11297"><code>	}</code></span>
<span class="codeline" id="line-11298"><code>	n.q.push(wr)</code></span>
<span class="codeline" id="line-11299"><code>}</code></span>
<span class="codeline" id="line-11300"><code></code></span>
<span class="codeline" id="line-11301"><code>func (ws *http2priorityWriteScheduler) Pop() (wr http2FrameWriteRequest, ok bool) {</code></span>
<span class="codeline" id="line-11302"><code>	ws.root.walkReadyInOrder(false, &amp;ws.tmp, func(n *http2priorityNode, openParent bool) bool {</code></span>
<span class="codeline" id="line-11303"><code>		limit := int32(math.MaxInt32)</code></span>
<span class="codeline" id="line-11304"><code>		if openParent {</code></span>
<span class="codeline" id="line-11305"><code>			limit = ws.writeThrottleLimit</code></span>
<span class="codeline" id="line-11306"><code>		}</code></span>
<span class="codeline" id="line-11307"><code>		wr, ok = n.q.consume(limit)</code></span>
<span class="codeline" id="line-11308"><code>		if !ok {</code></span>
<span class="codeline" id="line-11309"><code>			return false</code></span>
<span class="codeline" id="line-11310"><code>		}</code></span>
<span class="codeline" id="line-11311"><code>		n.addBytes(int64(wr.DataSize()))</code></span>
<span class="codeline" id="line-11312"><code>		// If B depends on A and B continuously has data available but A</code></span>
<span class="codeline" id="line-11313"><code>		// does not, gradually increase the throttling limit to allow B to</code></span>
<span class="codeline" id="line-11314"><code>		// steal more and more bandwidth from A.</code></span>
<span class="codeline" id="line-11315"><code>		if openParent {</code></span>
<span class="codeline" id="line-11316"><code>			ws.writeThrottleLimit += 1024</code></span>
<span class="codeline" id="line-11317"><code>			if ws.writeThrottleLimit &lt; 0 {</code></span>
<span class="codeline" id="line-11318"><code>				ws.writeThrottleLimit = math.MaxInt32</code></span>
<span class="codeline" id="line-11319"><code>			}</code></span>
<span class="codeline" id="line-11320"><code>		} else if ws.enableWriteThrottle {</code></span>
<span class="codeline" id="line-11321"><code>			ws.writeThrottleLimit = 1024</code></span>
<span class="codeline" id="line-11322"><code>		}</code></span>
<span class="codeline" id="line-11323"><code>		return true</code></span>
<span class="codeline" id="line-11324"><code>	})</code></span>
<span class="codeline" id="line-11325"><code>	return wr, ok</code></span>
<span class="codeline" id="line-11326"><code>}</code></span>
<span class="codeline" id="line-11327"><code></code></span>
<span class="codeline" id="line-11328"><code>func (ws *http2priorityWriteScheduler) addClosedOrIdleNode(list *[]*http2priorityNode, maxSize int, n *http2priorityNode) {</code></span>
<span class="codeline" id="line-11329"><code>	if maxSize == 0 {</code></span>
<span class="codeline" id="line-11330"><code>		return</code></span>
<span class="codeline" id="line-11331"><code>	}</code></span>
<span class="codeline" id="line-11332"><code>	if len(*list) == maxSize {</code></span>
<span class="codeline" id="line-11333"><code>		// Remove the oldest node, then shift left.</code></span>
<span class="codeline" id="line-11334"><code>		ws.removeNode((*list)[0])</code></span>
<span class="codeline" id="line-11335"><code>		x := (*list)[1:]</code></span>
<span class="codeline" id="line-11336"><code>		copy(*list, x)</code></span>
<span class="codeline" id="line-11337"><code>		*list = (*list)[:len(x)]</code></span>
<span class="codeline" id="line-11338"><code>	}</code></span>
<span class="codeline" id="line-11339"><code>	*list = append(*list, n)</code></span>
<span class="codeline" id="line-11340"><code>}</code></span>
<span class="codeline" id="line-11341"><code></code></span>
<span class="codeline" id="line-11342"><code>func (ws *http2priorityWriteScheduler) removeNode(n *http2priorityNode) {</code></span>
<span class="codeline" id="line-11343"><code>	for k := n.kids; k != nil; k = k.next {</code></span>
<span class="codeline" id="line-11344"><code>		k.setParent(n.parent)</code></span>
<span class="codeline" id="line-11345"><code>	}</code></span>
<span class="codeline" id="line-11346"><code>	n.setParent(nil)</code></span>
<span class="codeline" id="line-11347"><code>	delete(ws.nodes, n.id)</code></span>
<span class="codeline" id="line-11348"><code>}</code></span>
<span class="codeline" id="line-11349"><code></code></span>
<span class="codeline" id="line-11350"><code>// NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2</code></span>
<span class="codeline" id="line-11351"><code>// priorities. Control frames like SETTINGS and PING are written before DATA</code></span>
<span class="codeline" id="line-11352"><code>// frames, but if no control frames are queued and multiple streams have queued</code></span>
<span class="codeline" id="line-11353"><code>// HEADERS or DATA frames, Pop selects a ready stream arbitrarily.</code></span>
<span class="codeline" id="line-11354"><code>func http2NewRandomWriteScheduler() http2WriteScheduler {</code></span>
<span class="codeline" id="line-11355"><code>	return &amp;http2randomWriteScheduler{sq: make(map[uint32]*http2writeQueue)}</code></span>
<span class="codeline" id="line-11356"><code>}</code></span>
<span class="codeline" id="line-11357"><code></code></span>
<span class="codeline" id="line-11358"><code>type http2randomWriteScheduler struct {</code></span>
<span class="codeline" id="line-11359"><code>	// zero are frames not associated with a specific stream.</code></span>
<span class="codeline" id="line-11360"><code>	zero http2writeQueue</code></span>
<span class="codeline" id="line-11361"><code></code></span>
<span class="codeline" id="line-11362"><code>	// sq contains the stream-specific queues, keyed by stream ID.</code></span>
<span class="codeline" id="line-11363"><code>	// When a stream is idle, closed, or emptied, it's deleted</code></span>
<span class="codeline" id="line-11364"><code>	// from the map.</code></span>
<span class="codeline" id="line-11365"><code>	sq map[uint32]*http2writeQueue</code></span>
<span class="codeline" id="line-11366"><code></code></span>
<span class="codeline" id="line-11367"><code>	// pool of empty queues for reuse.</code></span>
<span class="codeline" id="line-11368"><code>	queuePool http2writeQueuePool</code></span>
<span class="codeline" id="line-11369"><code>}</code></span>
<span class="codeline" id="line-11370"><code></code></span>
<span class="codeline" id="line-11371"><code>func (ws *http2randomWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions) {</code></span>
<span class="codeline" id="line-11372"><code>	// no-op: idle streams are not tracked</code></span>
<span class="codeline" id="line-11373"><code>}</code></span>
<span class="codeline" id="line-11374"><code></code></span>
<span class="codeline" id="line-11375"><code>func (ws *http2randomWriteScheduler) CloseStream(streamID uint32) {</code></span>
<span class="codeline" id="line-11376"><code>	q, ok := ws.sq[streamID]</code></span>
<span class="codeline" id="line-11377"><code>	if !ok {</code></span>
<span class="codeline" id="line-11378"><code>		return</code></span>
<span class="codeline" id="line-11379"><code>	}</code></span>
<span class="codeline" id="line-11380"><code>	delete(ws.sq, streamID)</code></span>
<span class="codeline" id="line-11381"><code>	ws.queuePool.put(q)</code></span>
<span class="codeline" id="line-11382"><code>}</code></span>
<span class="codeline" id="line-11383"><code></code></span>
<span class="codeline" id="line-11384"><code>func (ws *http2randomWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam) {</code></span>
<span class="codeline" id="line-11385"><code>	// no-op: priorities are ignored</code></span>
<span class="codeline" id="line-11386"><code>}</code></span>
<span class="codeline" id="line-11387"><code></code></span>
<span class="codeline" id="line-11388"><code>func (ws *http2randomWriteScheduler) Push(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-11389"><code>	if wr.isControl() {</code></span>
<span class="codeline" id="line-11390"><code>		ws.zero.push(wr)</code></span>
<span class="codeline" id="line-11391"><code>		return</code></span>
<span class="codeline" id="line-11392"><code>	}</code></span>
<span class="codeline" id="line-11393"><code>	id := wr.StreamID()</code></span>
<span class="codeline" id="line-11394"><code>	q, ok := ws.sq[id]</code></span>
<span class="codeline" id="line-11395"><code>	if !ok {</code></span>
<span class="codeline" id="line-11396"><code>		q = ws.queuePool.get()</code></span>
<span class="codeline" id="line-11397"><code>		ws.sq[id] = q</code></span>
<span class="codeline" id="line-11398"><code>	}</code></span>
<span class="codeline" id="line-11399"><code>	q.push(wr)</code></span>
<span class="codeline" id="line-11400"><code>}</code></span>
<span class="codeline" id="line-11401"><code></code></span>
<span class="codeline" id="line-11402"><code>func (ws *http2randomWriteScheduler) Pop() (http2FrameWriteRequest, bool) {</code></span>
<span class="codeline" id="line-11403"><code>	// Control and RST_STREAM frames first.</code></span>
<span class="codeline" id="line-11404"><code>	if !ws.zero.empty() {</code></span>
<span class="codeline" id="line-11405"><code>		return ws.zero.shift(), true</code></span>
<span class="codeline" id="line-11406"><code>	}</code></span>
<span class="codeline" id="line-11407"><code>	// Iterate over all non-idle streams until finding one that can be consumed.</code></span>
<span class="codeline" id="line-11408"><code>	for streamID, q := range ws.sq {</code></span>
<span class="codeline" id="line-11409"><code>		if wr, ok := q.consume(math.MaxInt32); ok {</code></span>
<span class="codeline" id="line-11410"><code>			if q.empty() {</code></span>
<span class="codeline" id="line-11411"><code>				delete(ws.sq, streamID)</code></span>
<span class="codeline" id="line-11412"><code>				ws.queuePool.put(q)</code></span>
<span class="codeline" id="line-11413"><code>			}</code></span>
<span class="codeline" id="line-11414"><code>			return wr, true</code></span>
<span class="codeline" id="line-11415"><code>		}</code></span>
<span class="codeline" id="line-11416"><code>	}</code></span>
<span class="codeline" id="line-11417"><code>	return http2FrameWriteRequest{}, false</code></span>
<span class="codeline" id="line-11418"><code>}</code></span>
<span class="codeline" id="line-11419"><code></code></span>
<span class="codeline" id="line-11420"><code>type http2roundRobinWriteScheduler struct {</code></span>
<span class="codeline" id="line-11421"><code>	// control contains control frames (SETTINGS, PING, etc.).</code></span>
<span class="codeline" id="line-11422"><code>	control http2writeQueue</code></span>
<span class="codeline" id="line-11423"><code></code></span>
<span class="codeline" id="line-11424"><code>	// streams maps stream ID to a queue.</code></span>
<span class="codeline" id="line-11425"><code>	streams map[uint32]*http2writeQueue</code></span>
<span class="codeline" id="line-11426"><code></code></span>
<span class="codeline" id="line-11427"><code>	// stream queues are stored in a circular linked list.</code></span>
<span class="codeline" id="line-11428"><code>	// head is the next stream to write, or nil if there are no streams open.</code></span>
<span class="codeline" id="line-11429"><code>	head *http2writeQueue</code></span>
<span class="codeline" id="line-11430"><code></code></span>
<span class="codeline" id="line-11431"><code>	// pool of empty queues for reuse.</code></span>
<span class="codeline" id="line-11432"><code>	queuePool http2writeQueuePool</code></span>
<span class="codeline" id="line-11433"><code>}</code></span>
<span class="codeline" id="line-11434"><code></code></span>
<span class="codeline" id="line-11435"><code>// newRoundRobinWriteScheduler constructs a new write scheduler.</code></span>
<span class="codeline" id="line-11436"><code>// The round robin scheduler priorizes control frames</code></span>
<span class="codeline" id="line-11437"><code>// like SETTINGS and PING over DATA frames.</code></span>
<span class="codeline" id="line-11438"><code>// When there are no control frames to send, it performs a round-robin</code></span>
<span class="codeline" id="line-11439"><code>// selection from the ready streams.</code></span>
<span class="codeline" id="line-11440"><code>func http2newRoundRobinWriteScheduler() http2WriteScheduler {</code></span>
<span class="codeline" id="line-11441"><code>	ws := &amp;http2roundRobinWriteScheduler{</code></span>
<span class="codeline" id="line-11442"><code>		streams: make(map[uint32]*http2writeQueue),</code></span>
<span class="codeline" id="line-11443"><code>	}</code></span>
<span class="codeline" id="line-11444"><code>	return ws</code></span>
<span class="codeline" id="line-11445"><code>}</code></span>
<span class="codeline" id="line-11446"><code></code></span>
<span class="codeline" id="line-11447"><code>func (ws *http2roundRobinWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions) {</code></span>
<span class="codeline" id="line-11448"><code>	if ws.streams[streamID] != nil {</code></span>
<span class="codeline" id="line-11449"><code>		panic(fmt.Errorf("stream %d already opened", streamID))</code></span>
<span class="codeline" id="line-11450"><code>	}</code></span>
<span class="codeline" id="line-11451"><code>	q := ws.queuePool.get()</code></span>
<span class="codeline" id="line-11452"><code>	ws.streams[streamID] = q</code></span>
<span class="codeline" id="line-11453"><code>	if ws.head == nil {</code></span>
<span class="codeline" id="line-11454"><code>		ws.head = q</code></span>
<span class="codeline" id="line-11455"><code>		q.next = q</code></span>
<span class="codeline" id="line-11456"><code>		q.prev = q</code></span>
<span class="codeline" id="line-11457"><code>	} else {</code></span>
<span class="codeline" id="line-11458"><code>		// Queues are stored in a ring.</code></span>
<span class="codeline" id="line-11459"><code>		// Insert the new stream before ws.head, putting it at the end of the list.</code></span>
<span class="codeline" id="line-11460"><code>		q.prev = ws.head.prev</code></span>
<span class="codeline" id="line-11461"><code>		q.next = ws.head</code></span>
<span class="codeline" id="line-11462"><code>		q.prev.next = q</code></span>
<span class="codeline" id="line-11463"><code>		q.next.prev = q</code></span>
<span class="codeline" id="line-11464"><code>	}</code></span>
<span class="codeline" id="line-11465"><code>}</code></span>
<span class="codeline" id="line-11466"><code></code></span>
<span class="codeline" id="line-11467"><code>func (ws *http2roundRobinWriteScheduler) CloseStream(streamID uint32) {</code></span>
<span class="codeline" id="line-11468"><code>	q := ws.streams[streamID]</code></span>
<span class="codeline" id="line-11469"><code>	if q == nil {</code></span>
<span class="codeline" id="line-11470"><code>		return</code></span>
<span class="codeline" id="line-11471"><code>	}</code></span>
<span class="codeline" id="line-11472"><code>	if q.next == q {</code></span>
<span class="codeline" id="line-11473"><code>		// This was the only open stream.</code></span>
<span class="codeline" id="line-11474"><code>		ws.head = nil</code></span>
<span class="codeline" id="line-11475"><code>	} else {</code></span>
<span class="codeline" id="line-11476"><code>		q.prev.next = q.next</code></span>
<span class="codeline" id="line-11477"><code>		q.next.prev = q.prev</code></span>
<span class="codeline" id="line-11478"><code>		if ws.head == q {</code></span>
<span class="codeline" id="line-11479"><code>			ws.head = q.next</code></span>
<span class="codeline" id="line-11480"><code>		}</code></span>
<span class="codeline" id="line-11481"><code>	}</code></span>
<span class="codeline" id="line-11482"><code>	delete(ws.streams, streamID)</code></span>
<span class="codeline" id="line-11483"><code>	ws.queuePool.put(q)</code></span>
<span class="codeline" id="line-11484"><code>}</code></span>
<span class="codeline" id="line-11485"><code></code></span>
<span class="codeline" id="line-11486"><code>func (ws *http2roundRobinWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam) {}</code></span>
<span class="codeline" id="line-11487"><code></code></span>
<span class="codeline" id="line-11488"><code>func (ws *http2roundRobinWriteScheduler) Push(wr http2FrameWriteRequest) {</code></span>
<span class="codeline" id="line-11489"><code>	if wr.isControl() {</code></span>
<span class="codeline" id="line-11490"><code>		ws.control.push(wr)</code></span>
<span class="codeline" id="line-11491"><code>		return</code></span>
<span class="codeline" id="line-11492"><code>	}</code></span>
<span class="codeline" id="line-11493"><code>	q := ws.streams[wr.StreamID()]</code></span>
<span class="codeline" id="line-11494"><code>	if q == nil {</code></span>
<span class="codeline" id="line-11495"><code>		// This is a closed stream.</code></span>
<span class="codeline" id="line-11496"><code>		// wr should not be a HEADERS or DATA frame.</code></span>
<span class="codeline" id="line-11497"><code>		// We push the request onto the control queue.</code></span>
<span class="codeline" id="line-11498"><code>		if wr.DataSize() &gt; 0 {</code></span>
<span class="codeline" id="line-11499"><code>			panic("add DATA on non-open stream")</code></span>
<span class="codeline" id="line-11500"><code>		}</code></span>
<span class="codeline" id="line-11501"><code>		ws.control.push(wr)</code></span>
<span class="codeline" id="line-11502"><code>		return</code></span>
<span class="codeline" id="line-11503"><code>	}</code></span>
<span class="codeline" id="line-11504"><code>	q.push(wr)</code></span>
<span class="codeline" id="line-11505"><code>}</code></span>
<span class="codeline" id="line-11506"><code></code></span>
<span class="codeline" id="line-11507"><code>func (ws *http2roundRobinWriteScheduler) Pop() (http2FrameWriteRequest, bool) {</code></span>
<span class="codeline" id="line-11508"><code>	// Control and RST_STREAM frames first.</code></span>
<span class="codeline" id="line-11509"><code>	if !ws.control.empty() {</code></span>
<span class="codeline" id="line-11510"><code>		return ws.control.shift(), true</code></span>
<span class="codeline" id="line-11511"><code>	}</code></span>
<span class="codeline" id="line-11512"><code>	if ws.head == nil {</code></span>
<span class="codeline" id="line-11513"><code>		return http2FrameWriteRequest{}, false</code></span>
<span class="codeline" id="line-11514"><code>	}</code></span>
<span class="codeline" id="line-11515"><code>	q := ws.head</code></span>
<span class="codeline" id="line-11516"><code>	for {</code></span>
<span class="codeline" id="line-11517"><code>		if wr, ok := q.consume(math.MaxInt32); ok {</code></span>
<span class="codeline" id="line-11518"><code>			ws.head = q.next</code></span>
<span class="codeline" id="line-11519"><code>			return wr, true</code></span>
<span class="codeline" id="line-11520"><code>		}</code></span>
<span class="codeline" id="line-11521"><code>		q = q.next</code></span>
<span class="codeline" id="line-11522"><code>		if q == ws.head {</code></span>
<span class="codeline" id="line-11523"><code>			break</code></span>
<span class="codeline" id="line-11524"><code>		}</code></span>
<span class="codeline" id="line-11525"><code>	}</code></span>
<span class="codeline" id="line-11526"><code>	return http2FrameWriteRequest{}, false</code></span>
<span class="codeline" id="line-11527"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>