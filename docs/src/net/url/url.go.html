<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: url.go in package net/url</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	url.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/url.html">net/url</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package url parses URLs and implements query escaping.</code></span></div><span class="codeline" id="line-6"><code>package url</code></span>
<span class="codeline" id="line-7"><code></code></span>
<span class="codeline" id="line-8"><code>// See RFC 3986. This package generally follows RFC 3986, except where</code></span>
<span class="codeline" id="line-9"><code>// it deviates for compatibility reasons. When sending changes, first</code></span>
<span class="codeline" id="line-10"><code>// search old issues for history on decisions. Unit tests should also</code></span>
<span class="codeline" id="line-11"><code>// contain references to issue numbers with details.</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>import (</code></span>
<span class="codeline" id="line-14"><code>	"errors"</code></span>
<span class="codeline" id="line-15"><code>	"fmt"</code></span>
<span class="codeline" id="line-16"><code>	"path"</code></span>
<span class="codeline" id="line-17"><code>	"sort"</code></span>
<span class="codeline" id="line-18"><code>	"strconv"</code></span>
<span class="codeline" id="line-19"><code>	"strings"</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// Error reports an error and the operation and URL that caused it.</code></span>
<span class="codeline" id="line-23"><code>type Error struct {</code></span>
<span class="codeline" id="line-24"><code>	Op  string</code></span>
<span class="codeline" id="line-25"><code>	URL string</code></span>
<span class="codeline" id="line-26"><code>	Err error</code></span>
<span class="codeline" id="line-27"><code>}</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>func (e *Error) Unwrap() error { return e.Err }</code></span>
<span class="codeline" id="line-30"><code>func (e *Error) Error() string { return fmt.Sprintf("%s %q: %s", e.Op, e.URL, e.Err) }</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>func (e *Error) Timeout() bool {</code></span>
<span class="codeline" id="line-33"><code>	t, ok := e.Err.(interface {</code></span>
<span class="codeline" id="line-34"><code>		Timeout() bool</code></span>
<span class="codeline" id="line-35"><code>	})</code></span>
<span class="codeline" id="line-36"><code>	return ok &amp;&amp; t.Timeout()</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>func (e *Error) Temporary() bool {</code></span>
<span class="codeline" id="line-40"><code>	t, ok := e.Err.(interface {</code></span>
<span class="codeline" id="line-41"><code>		Temporary() bool</code></span>
<span class="codeline" id="line-42"><code>	})</code></span>
<span class="codeline" id="line-43"><code>	return ok &amp;&amp; t.Temporary()</code></span>
<span class="codeline" id="line-44"><code>}</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>const upperhex = "0123456789ABCDEF"</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>func ishex(c byte) bool {</code></span>
<span class="codeline" id="line-49"><code>	switch {</code></span>
<span class="codeline" id="line-50"><code>	case '0' &lt;= c &amp;&amp; c &lt;= '9':</code></span>
<span class="codeline" id="line-51"><code>		return true</code></span>
<span class="codeline" id="line-52"><code>	case 'a' &lt;= c &amp;&amp; c &lt;= 'f':</code></span>
<span class="codeline" id="line-53"><code>		return true</code></span>
<span class="codeline" id="line-54"><code>	case 'A' &lt;= c &amp;&amp; c &lt;= 'F':</code></span>
<span class="codeline" id="line-55"><code>		return true</code></span>
<span class="codeline" id="line-56"><code>	}</code></span>
<span class="codeline" id="line-57"><code>	return false</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>func unhex(c byte) byte {</code></span>
<span class="codeline" id="line-61"><code>	switch {</code></span>
<span class="codeline" id="line-62"><code>	case '0' &lt;= c &amp;&amp; c &lt;= '9':</code></span>
<span class="codeline" id="line-63"><code>		return c - '0'</code></span>
<span class="codeline" id="line-64"><code>	case 'a' &lt;= c &amp;&amp; c &lt;= 'f':</code></span>
<span class="codeline" id="line-65"><code>		return c - 'a' + 10</code></span>
<span class="codeline" id="line-66"><code>	case 'A' &lt;= c &amp;&amp; c &lt;= 'F':</code></span>
<span class="codeline" id="line-67"><code>		return c - 'A' + 10</code></span>
<span class="codeline" id="line-68"><code>	}</code></span>
<span class="codeline" id="line-69"><code>	return 0</code></span>
<span class="codeline" id="line-70"><code>}</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>type encoding int</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>const (</code></span>
<span class="codeline" id="line-75"><code>	encodePath encoding = 1 + iota</code></span>
<span class="codeline" id="line-76"><code>	encodePathSegment</code></span>
<span class="codeline" id="line-77"><code>	encodeHost</code></span>
<span class="codeline" id="line-78"><code>	encodeZone</code></span>
<span class="codeline" id="line-79"><code>	encodeUserPassword</code></span>
<span class="codeline" id="line-80"><code>	encodeQueryComponent</code></span>
<span class="codeline" id="line-81"><code>	encodeFragment</code></span>
<span class="codeline" id="line-82"><code>)</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>type EscapeError string</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>func (e EscapeError) Error() string {</code></span>
<span class="codeline" id="line-87"><code>	return "invalid URL escape " + strconv.Quote(string(e))</code></span>
<span class="codeline" id="line-88"><code>}</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>type InvalidHostError string</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>func (e InvalidHostError) Error() string {</code></span>
<span class="codeline" id="line-93"><code>	return "invalid character " + strconv.Quote(string(e)) + " in host name"</code></span>
<span class="codeline" id="line-94"><code>}</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>// Return true if the specified character should be escaped when</code></span>
<span class="codeline" id="line-97"><code>// appearing in a URL string, according to RFC 3986.</code></span>
<span class="codeline" id="line-98"><code>//</code></span>
<span class="codeline" id="line-99"><code>// Please be informed that for now shouldEscape does not check all</code></span>
<span class="codeline" id="line-100"><code>// reserved characters correctly. See golang.org/issue/5684.</code></span>
<span class="codeline" id="line-101"><code>func shouldEscape(c byte, mode encoding) bool {</code></span>
<span class="codeline" id="line-102"><code>	// §2.3 Unreserved characters (alphanum)</code></span>
<span class="codeline" id="line-103"><code>	if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z' || '0' &lt;= c &amp;&amp; c &lt;= '9' {</code></span>
<span class="codeline" id="line-104"><code>		return false</code></span>
<span class="codeline" id="line-105"><code>	}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	if mode == encodeHost || mode == encodeZone {</code></span>
<span class="codeline" id="line-108"><code>		// §3.2.2 Host allows</code></span>
<span class="codeline" id="line-109"><code>		//	sub-delims = "!" / "$" / "&amp;" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="</code></span>
<span class="codeline" id="line-110"><code>		// as part of reg-name.</code></span>
<span class="codeline" id="line-111"><code>		// We add : because we include :port as part of host.</code></span>
<span class="codeline" id="line-112"><code>		// We add [ ] because we include [ipv6]:port as part of host.</code></span>
<span class="codeline" id="line-113"><code>		// We add &lt; &gt; because they're the only characters left that</code></span>
<span class="codeline" id="line-114"><code>		// we could possibly allow, and Parse will reject them if we</code></span>
<span class="codeline" id="line-115"><code>		// escape them (because hosts can't use %-encoding for</code></span>
<span class="codeline" id="line-116"><code>		// ASCII bytes).</code></span>
<span class="codeline" id="line-117"><code>		switch c {</code></span>
<span class="codeline" id="line-118"><code>		case '!', '$', '&amp;', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']', '&lt;', '&gt;', '"':</code></span>
<span class="codeline" id="line-119"><code>			return false</code></span>
<span class="codeline" id="line-120"><code>		}</code></span>
<span class="codeline" id="line-121"><code>	}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>	switch c {</code></span>
<span class="codeline" id="line-124"><code>	case '-', '_', '.', '~': // §2.3 Unreserved characters (mark)</code></span>
<span class="codeline" id="line-125"><code>		return false</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>	case '$', '&amp;', '+', ',', '/', ':', ';', '=', '?', '@': // §2.2 Reserved characters (reserved)</code></span>
<span class="codeline" id="line-128"><code>		// Different sections of the URL allow a few of</code></span>
<span class="codeline" id="line-129"><code>		// the reserved characters to appear unescaped.</code></span>
<span class="codeline" id="line-130"><code>		switch mode {</code></span>
<span class="codeline" id="line-131"><code>		case encodePath: // §3.3</code></span>
<span class="codeline" id="line-132"><code>			// The RFC allows : @ &amp; = + $ but saves / ; , for assigning</code></span>
<span class="codeline" id="line-133"><code>			// meaning to individual path segments. This package</code></span>
<span class="codeline" id="line-134"><code>			// only manipulates the path as a whole, so we allow those</code></span>
<span class="codeline" id="line-135"><code>			// last three as well. That leaves only ? to escape.</code></span>
<span class="codeline" id="line-136"><code>			return c == '?'</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>		case encodePathSegment: // §3.3</code></span>
<span class="codeline" id="line-139"><code>			// The RFC allows : @ &amp; = + $ but saves / ; , for assigning</code></span>
<span class="codeline" id="line-140"><code>			// meaning to individual path segments.</code></span>
<span class="codeline" id="line-141"><code>			return c == '/' || c == ';' || c == ',' || c == '?'</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>		case encodeUserPassword: // §3.2.1</code></span>
<span class="codeline" id="line-144"><code>			// The RFC allows ';', ':', '&amp;', '=', '+', '$', and ',' in</code></span>
<span class="codeline" id="line-145"><code>			// userinfo, so we must escape only '@', '/', and '?'.</code></span>
<span class="codeline" id="line-146"><code>			// The parsing of userinfo treats ':' as special so we must escape</code></span>
<span class="codeline" id="line-147"><code>			// that too.</code></span>
<span class="codeline" id="line-148"><code>			return c == '@' || c == '/' || c == '?' || c == ':'</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>		case encodeQueryComponent: // §3.4</code></span>
<span class="codeline" id="line-151"><code>			// The RFC reserves (so we must escape) everything.</code></span>
<span class="codeline" id="line-152"><code>			return true</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>		case encodeFragment: // §4.1</code></span>
<span class="codeline" id="line-155"><code>			// The RFC text is silent but the grammar allows</code></span>
<span class="codeline" id="line-156"><code>			// everything, so escape nothing.</code></span>
<span class="codeline" id="line-157"><code>			return false</code></span>
<span class="codeline" id="line-158"><code>		}</code></span>
<span class="codeline" id="line-159"><code>	}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	if mode == encodeFragment {</code></span>
<span class="codeline" id="line-162"><code>		// RFC 3986 §2.2 allows not escaping sub-delims. A subset of sub-delims are</code></span>
<span class="codeline" id="line-163"><code>		// included in reserved from RFC 2396 §2.2. The remaining sub-delims do not</code></span>
<span class="codeline" id="line-164"><code>		// need to be escaped. To minimize potential breakage, we apply two restrictions:</code></span>
<span class="codeline" id="line-165"><code>		// (1) we always escape sub-delims outside of the fragment, and (2) we always</code></span>
<span class="codeline" id="line-166"><code>		// escape single quote to avoid breaking callers that had previously assumed that</code></span>
<span class="codeline" id="line-167"><code>		// single quotes would be escaped. See issue #19917.</code></span>
<span class="codeline" id="line-168"><code>		switch c {</code></span>
<span class="codeline" id="line-169"><code>		case '!', '(', ')', '*':</code></span>
<span class="codeline" id="line-170"><code>			return false</code></span>
<span class="codeline" id="line-171"><code>		}</code></span>
<span class="codeline" id="line-172"><code>	}</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	// Everything else must be escaped.</code></span>
<span class="codeline" id="line-175"><code>	return true</code></span>
<span class="codeline" id="line-176"><code>}</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// QueryUnescape does the inverse transformation of [QueryEscape],</code></span>
<span class="codeline" id="line-179"><code>// converting each 3-byte encoded substring of the form "%AB" into the</code></span>
<span class="codeline" id="line-180"><code>// hex-decoded byte 0xAB.</code></span>
<span class="codeline" id="line-181"><code>// It returns an error if any % is not followed by two hexadecimal</code></span>
<span class="codeline" id="line-182"><code>// digits.</code></span>
<span class="codeline" id="line-183"><code>func QueryUnescape(s string) (string, error) {</code></span>
<span class="codeline" id="line-184"><code>	return unescape(s, encodeQueryComponent)</code></span>
<span class="codeline" id="line-185"><code>}</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>// PathUnescape does the inverse transformation of [PathEscape],</code></span>
<span class="codeline" id="line-188"><code>// converting each 3-byte encoded substring of the form "%AB" into the</code></span>
<span class="codeline" id="line-189"><code>// hex-decoded byte 0xAB. It returns an error if any % is not followed</code></span>
<span class="codeline" id="line-190"><code>// by two hexadecimal digits.</code></span>
<span class="codeline" id="line-191"><code>//</code></span>
<span class="codeline" id="line-192"><code>// PathUnescape is identical to [QueryUnescape] except that it does not</code></span>
<span class="codeline" id="line-193"><code>// unescape '+' to ' ' (space).</code></span>
<span class="codeline" id="line-194"><code>func PathUnescape(s string) (string, error) {</code></span>
<span class="codeline" id="line-195"><code>	return unescape(s, encodePathSegment)</code></span>
<span class="codeline" id="line-196"><code>}</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>// unescape unescapes a string; the mode specifies</code></span>
<span class="codeline" id="line-199"><code>// which section of the URL string is being unescaped.</code></span>
<span class="codeline" id="line-200"><code>func unescape(s string, mode encoding) (string, error) {</code></span>
<span class="codeline" id="line-201"><code>	// Count %, check that they're well-formed.</code></span>
<span class="codeline" id="line-202"><code>	n := 0</code></span>
<span class="codeline" id="line-203"><code>	hasPlus := false</code></span>
<span class="codeline" id="line-204"><code>	for i := 0; i &lt; len(s); {</code></span>
<span class="codeline" id="line-205"><code>		switch s[i] {</code></span>
<span class="codeline" id="line-206"><code>		case '%':</code></span>
<span class="codeline" id="line-207"><code>			n++</code></span>
<span class="codeline" id="line-208"><code>			if i+2 &gt;= len(s) || !ishex(s[i+1]) || !ishex(s[i+2]) {</code></span>
<span class="codeline" id="line-209"><code>				s = s[i:]</code></span>
<span class="codeline" id="line-210"><code>				if len(s) &gt; 3 {</code></span>
<span class="codeline" id="line-211"><code>					s = s[:3]</code></span>
<span class="codeline" id="line-212"><code>				}</code></span>
<span class="codeline" id="line-213"><code>				return "", EscapeError(s)</code></span>
<span class="codeline" id="line-214"><code>			}</code></span>
<span class="codeline" id="line-215"><code>			// Per https://tools.ietf.org/html/rfc3986#page-21</code></span>
<span class="codeline" id="line-216"><code>			// in the host component %-encoding can only be used</code></span>
<span class="codeline" id="line-217"><code>			// for non-ASCII bytes.</code></span>
<span class="codeline" id="line-218"><code>			// But https://tools.ietf.org/html/rfc6874#section-2</code></span>
<span class="codeline" id="line-219"><code>			// introduces %25 being allowed to escape a percent sign</code></span>
<span class="codeline" id="line-220"><code>			// in IPv6 scoped-address literals. Yay.</code></span>
<span class="codeline" id="line-221"><code>			if mode == encodeHost &amp;&amp; unhex(s[i+1]) &lt; 8 &amp;&amp; s[i:i+3] != "%25" {</code></span>
<span class="codeline" id="line-222"><code>				return "", EscapeError(s[i : i+3])</code></span>
<span class="codeline" id="line-223"><code>			}</code></span>
<span class="codeline" id="line-224"><code>			if mode == encodeZone {</code></span>
<span class="codeline" id="line-225"><code>				// RFC 6874 says basically "anything goes" for zone identifiers</code></span>
<span class="codeline" id="line-226"><code>				// and that even non-ASCII can be redundantly escaped,</code></span>
<span class="codeline" id="line-227"><code>				// but it seems prudent to restrict %-escaped bytes here to those</code></span>
<span class="codeline" id="line-228"><code>				// that are valid host name bytes in their unescaped form.</code></span>
<span class="codeline" id="line-229"><code>				// That is, you can use escaping in the zone identifier but not</code></span>
<span class="codeline" id="line-230"><code>				// to introduce bytes you couldn't just write directly.</code></span>
<span class="codeline" id="line-231"><code>				// But Windows puts spaces here! Yay.</code></span>
<span class="codeline" id="line-232"><code>				v := unhex(s[i+1])&lt;&lt;4 | unhex(s[i+2])</code></span>
<span class="codeline" id="line-233"><code>				if s[i:i+3] != "%25" &amp;&amp; v != ' ' &amp;&amp; shouldEscape(v, encodeHost) {</code></span>
<span class="codeline" id="line-234"><code>					return "", EscapeError(s[i : i+3])</code></span>
<span class="codeline" id="line-235"><code>				}</code></span>
<span class="codeline" id="line-236"><code>			}</code></span>
<span class="codeline" id="line-237"><code>			i += 3</code></span>
<span class="codeline" id="line-238"><code>		case '+':</code></span>
<span class="codeline" id="line-239"><code>			hasPlus = mode == encodeQueryComponent</code></span>
<span class="codeline" id="line-240"><code>			i++</code></span>
<span class="codeline" id="line-241"><code>		default:</code></span>
<span class="codeline" id="line-242"><code>			if (mode == encodeHost || mode == encodeZone) &amp;&amp; s[i] &lt; 0x80 &amp;&amp; shouldEscape(s[i], mode) {</code></span>
<span class="codeline" id="line-243"><code>				return "", InvalidHostError(s[i : i+1])</code></span>
<span class="codeline" id="line-244"><code>			}</code></span>
<span class="codeline" id="line-245"><code>			i++</code></span>
<span class="codeline" id="line-246"><code>		}</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>	if n == 0 &amp;&amp; !hasPlus {</code></span>
<span class="codeline" id="line-250"><code>		return s, nil</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>	var t strings.Builder</code></span>
<span class="codeline" id="line-254"><code>	t.Grow(len(s) - 2*n)</code></span>
<span class="codeline" id="line-255"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-256"><code>		switch s[i] {</code></span>
<span class="codeline" id="line-257"><code>		case '%':</code></span>
<span class="codeline" id="line-258"><code>			t.WriteByte(unhex(s[i+1])&lt;&lt;4 | unhex(s[i+2]))</code></span>
<span class="codeline" id="line-259"><code>			i += 2</code></span>
<span class="codeline" id="line-260"><code>		case '+':</code></span>
<span class="codeline" id="line-261"><code>			if mode == encodeQueryComponent {</code></span>
<span class="codeline" id="line-262"><code>				t.WriteByte(' ')</code></span>
<span class="codeline" id="line-263"><code>			} else {</code></span>
<span class="codeline" id="line-264"><code>				t.WriteByte('+')</code></span>
<span class="codeline" id="line-265"><code>			}</code></span>
<span class="codeline" id="line-266"><code>		default:</code></span>
<span class="codeline" id="line-267"><code>			t.WriteByte(s[i])</code></span>
<span class="codeline" id="line-268"><code>		}</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	return t.String(), nil</code></span>
<span class="codeline" id="line-271"><code>}</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>// QueryEscape escapes the string so it can be safely placed</code></span>
<span class="codeline" id="line-274"><code>// inside a [URL] query.</code></span>
<span class="codeline" id="line-275"><code>func QueryEscape(s string) string {</code></span>
<span class="codeline" id="line-276"><code>	return escape(s, encodeQueryComponent)</code></span>
<span class="codeline" id="line-277"><code>}</code></span>
<span class="codeline" id="line-278"><code></code></span>
<span class="codeline" id="line-279"><code>// PathEscape escapes the string so it can be safely placed inside a [URL] path segment,</code></span>
<span class="codeline" id="line-280"><code>// replacing special characters (including /) with %XX sequences as needed.</code></span>
<span class="codeline" id="line-281"><code>func PathEscape(s string) string {</code></span>
<span class="codeline" id="line-282"><code>	return escape(s, encodePathSegment)</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>func escape(s string, mode encoding) string {</code></span>
<span class="codeline" id="line-286"><code>	spaceCount, hexCount := 0, 0</code></span>
<span class="codeline" id="line-287"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-288"><code>		c := s[i]</code></span>
<span class="codeline" id="line-289"><code>		if shouldEscape(c, mode) {</code></span>
<span class="codeline" id="line-290"><code>			if c == ' ' &amp;&amp; mode == encodeQueryComponent {</code></span>
<span class="codeline" id="line-291"><code>				spaceCount++</code></span>
<span class="codeline" id="line-292"><code>			} else {</code></span>
<span class="codeline" id="line-293"><code>				hexCount++</code></span>
<span class="codeline" id="line-294"><code>			}</code></span>
<span class="codeline" id="line-295"><code>		}</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	if spaceCount == 0 &amp;&amp; hexCount == 0 {</code></span>
<span class="codeline" id="line-299"><code>		return s</code></span>
<span class="codeline" id="line-300"><code>	}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>	var buf [64]byte</code></span>
<span class="codeline" id="line-303"><code>	var t []byte</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>	required := len(s) + 2*hexCount</code></span>
<span class="codeline" id="line-306"><code>	if required &lt;= len(buf) {</code></span>
<span class="codeline" id="line-307"><code>		t = buf[:required]</code></span>
<span class="codeline" id="line-308"><code>	} else {</code></span>
<span class="codeline" id="line-309"><code>		t = make([]byte, required)</code></span>
<span class="codeline" id="line-310"><code>	}</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>	if hexCount == 0 {</code></span>
<span class="codeline" id="line-313"><code>		copy(t, s)</code></span>
<span class="codeline" id="line-314"><code>		for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-315"><code>			if s[i] == ' ' {</code></span>
<span class="codeline" id="line-316"><code>				t[i] = '+'</code></span>
<span class="codeline" id="line-317"><code>			}</code></span>
<span class="codeline" id="line-318"><code>		}</code></span>
<span class="codeline" id="line-319"><code>		return string(t)</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>	j := 0</code></span>
<span class="codeline" id="line-323"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-324"><code>		switch c := s[i]; {</code></span>
<span class="codeline" id="line-325"><code>		case c == ' ' &amp;&amp; mode == encodeQueryComponent:</code></span>
<span class="codeline" id="line-326"><code>			t[j] = '+'</code></span>
<span class="codeline" id="line-327"><code>			j++</code></span>
<span class="codeline" id="line-328"><code>		case shouldEscape(c, mode):</code></span>
<span class="codeline" id="line-329"><code>			t[j] = '%'</code></span>
<span class="codeline" id="line-330"><code>			t[j+1] = upperhex[c&gt;&gt;4]</code></span>
<span class="codeline" id="line-331"><code>			t[j+2] = upperhex[c&amp;15]</code></span>
<span class="codeline" id="line-332"><code>			j += 3</code></span>
<span class="codeline" id="line-333"><code>		default:</code></span>
<span class="codeline" id="line-334"><code>			t[j] = s[i]</code></span>
<span class="codeline" id="line-335"><code>			j++</code></span>
<span class="codeline" id="line-336"><code>		}</code></span>
<span class="codeline" id="line-337"><code>	}</code></span>
<span class="codeline" id="line-338"><code>	return string(t)</code></span>
<span class="codeline" id="line-339"><code>}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>// A URL represents a parsed URL (technically, a URI reference).</code></span>
<span class="codeline" id="line-342"><code>//</code></span>
<span class="codeline" id="line-343"><code>// The general form represented is:</code></span>
<span class="codeline" id="line-344"><code>//</code></span>
<span class="codeline" id="line-345"><code>//	[scheme:][//[userinfo@]host][/]path[?query][#fragment]</code></span>
<span class="codeline" id="line-346"><code>//</code></span>
<span class="codeline" id="line-347"><code>// URLs that do not start with a slash after the scheme are interpreted as:</code></span>
<span class="codeline" id="line-348"><code>//</code></span>
<span class="codeline" id="line-349"><code>//	scheme:opaque[?query][#fragment]</code></span>
<span class="codeline" id="line-350"><code>//</code></span>
<span class="codeline" id="line-351"><code>// The Host field contains the host and port subcomponents of the URL.</code></span>
<span class="codeline" id="line-352"><code>// When the port is present, it is separated from the host with a colon.</code></span>
<span class="codeline" id="line-353"><code>// When the host is an IPv6 address, it must be enclosed in square brackets:</code></span>
<span class="codeline" id="line-354"><code>// "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port</code></span>
<span class="codeline" id="line-355"><code>// into a string suitable for the Host field, adding square brackets to</code></span>
<span class="codeline" id="line-356"><code>// the host when necessary.</code></span>
<span class="codeline" id="line-357"><code>//</code></span>
<span class="codeline" id="line-358"><code>// Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.</code></span>
<span class="codeline" id="line-359"><code>// A consequence is that it is impossible to tell which slashes in the Path were</code></span>
<span class="codeline" id="line-360"><code>// slashes in the raw URL and which were %2f. This distinction is rarely important,</code></span>
<span class="codeline" id="line-361"><code>// but when it is, the code should use the [URL.EscapedPath] method, which preserves</code></span>
<span class="codeline" id="line-362"><code>// the original encoding of Path.</code></span>
<span class="codeline" id="line-363"><code>//</code></span>
<span class="codeline" id="line-364"><code>// The RawPath field is an optional field which is only set when the default</code></span>
<span class="codeline" id="line-365"><code>// encoding of Path is different from the escaped path. See the EscapedPath method</code></span>
<span class="codeline" id="line-366"><code>// for more details.</code></span>
<span class="codeline" id="line-367"><code>//</code></span>
<span class="codeline" id="line-368"><code>// URL's String method uses the EscapedPath method to obtain the path.</code></span>
<span class="codeline" id="line-369"><code>type URL struct {</code></span>
<span class="codeline" id="line-370"><code>	Scheme      string</code></span>
<span class="codeline" id="line-371"><code>	Opaque      string    // encoded opaque data</code></span>
<span class="codeline" id="line-372"><code>	User        *Userinfo // username and password information</code></span>
<span class="codeline" id="line-373"><code>	Host        string    // host or host:port (see Hostname and Port methods)</code></span>
<span class="codeline" id="line-374"><code>	Path        string    // path (relative paths may omit leading slash)</code></span>
<span class="codeline" id="line-375"><code>	RawPath     string    // encoded path hint (see EscapedPath method)</code></span>
<span class="codeline" id="line-376"><code>	OmitHost    bool      // do not emit empty host (authority)</code></span>
<span class="codeline" id="line-377"><code>	ForceQuery  bool      // append a query ('?') even if RawQuery is empty</code></span>
<span class="codeline" id="line-378"><code>	RawQuery    string    // encoded query values, without '?'</code></span>
<span class="codeline" id="line-379"><code>	Fragment    string    // fragment for references, without '#'</code></span>
<span class="codeline" id="line-380"><code>	RawFragment string    // encoded fragment hint (see EscapedFragment method)</code></span>
<span class="codeline" id="line-381"><code>}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>// User returns a [Userinfo] containing the provided username</code></span>
<span class="codeline" id="line-384"><code>// and no password set.</code></span>
<span class="codeline" id="line-385"><code>func User(username string) *Userinfo {</code></span>
<span class="codeline" id="line-386"><code>	return &amp;Userinfo{username, "", false}</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>// UserPassword returns a [Userinfo] containing the provided username</code></span>
<span class="codeline" id="line-390"><code>// and password.</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>// This functionality should only be used with legacy web sites.</code></span>
<span class="codeline" id="line-393"><code>// RFC 2396 warns that interpreting Userinfo this way</code></span>
<span class="codeline" id="line-394"><code>// “is NOT RECOMMENDED, because the passing of authentication</code></span>
<span class="codeline" id="line-395"><code>// information in clear text (such as URI) has proven to be a</code></span>
<span class="codeline" id="line-396"><code>// security risk in almost every case where it has been used.”</code></span>
<span class="codeline" id="line-397"><code>func UserPassword(username, password string) *Userinfo {</code></span>
<span class="codeline" id="line-398"><code>	return &amp;Userinfo{username, password, true}</code></span>
<span class="codeline" id="line-399"><code>}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>// The Userinfo type is an immutable encapsulation of username and</code></span>
<span class="codeline" id="line-402"><code>// password details for a [URL]. An existing Userinfo value is guaranteed</code></span>
<span class="codeline" id="line-403"><code>// to have a username set (potentially empty, as allowed by RFC 2396),</code></span>
<span class="codeline" id="line-404"><code>// and optionally a password.</code></span>
<span class="codeline" id="line-405"><code>type Userinfo struct {</code></span>
<span class="codeline" id="line-406"><code>	username    string</code></span>
<span class="codeline" id="line-407"><code>	password    string</code></span>
<span class="codeline" id="line-408"><code>	passwordSet bool</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>// Username returns the username.</code></span>
<span class="codeline" id="line-412"><code>func (u *Userinfo) Username() string {</code></span>
<span class="codeline" id="line-413"><code>	if u == nil {</code></span>
<span class="codeline" id="line-414"><code>		return ""</code></span>
<span class="codeline" id="line-415"><code>	}</code></span>
<span class="codeline" id="line-416"><code>	return u.username</code></span>
<span class="codeline" id="line-417"><code>}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>// Password returns the password in case it is set, and whether it is set.</code></span>
<span class="codeline" id="line-420"><code>func (u *Userinfo) Password() (string, bool) {</code></span>
<span class="codeline" id="line-421"><code>	if u == nil {</code></span>
<span class="codeline" id="line-422"><code>		return "", false</code></span>
<span class="codeline" id="line-423"><code>	}</code></span>
<span class="codeline" id="line-424"><code>	return u.password, u.passwordSet</code></span>
<span class="codeline" id="line-425"><code>}</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>// String returns the encoded userinfo information in the standard form</code></span>
<span class="codeline" id="line-428"><code>// of "username[:password]".</code></span>
<span class="codeline" id="line-429"><code>func (u *Userinfo) String() string {</code></span>
<span class="codeline" id="line-430"><code>	if u == nil {</code></span>
<span class="codeline" id="line-431"><code>		return ""</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code>	s := escape(u.username, encodeUserPassword)</code></span>
<span class="codeline" id="line-434"><code>	if u.passwordSet {</code></span>
<span class="codeline" id="line-435"><code>		s += ":" + escape(u.password, encodeUserPassword)</code></span>
<span class="codeline" id="line-436"><code>	}</code></span>
<span class="codeline" id="line-437"><code>	return s</code></span>
<span class="codeline" id="line-438"><code>}</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>// Maybe rawURL is of the form scheme:path.</code></span>
<span class="codeline" id="line-441"><code>// (Scheme must be [a-zA-Z][a-zA-Z0-9+.-]*)</code></span>
<span class="codeline" id="line-442"><code>// If so, return scheme, path; else return "", rawURL.</code></span>
<span class="codeline" id="line-443"><code>func getScheme(rawURL string) (scheme, path string, err error) {</code></span>
<span class="codeline" id="line-444"><code>	for i := 0; i &lt; len(rawURL); i++ {</code></span>
<span class="codeline" id="line-445"><code>		c := rawURL[i]</code></span>
<span class="codeline" id="line-446"><code>		switch {</code></span>
<span class="codeline" id="line-447"><code>		case 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z':</code></span>
<span class="codeline" id="line-448"><code>		// do nothing</code></span>
<span class="codeline" id="line-449"><code>		case '0' &lt;= c &amp;&amp; c &lt;= '9' || c == '+' || c == '-' || c == '.':</code></span>
<span class="codeline" id="line-450"><code>			if i == 0 {</code></span>
<span class="codeline" id="line-451"><code>				return "", rawURL, nil</code></span>
<span class="codeline" id="line-452"><code>			}</code></span>
<span class="codeline" id="line-453"><code>		case c == ':':</code></span>
<span class="codeline" id="line-454"><code>			if i == 0 {</code></span>
<span class="codeline" id="line-455"><code>				return "", "", errors.New("missing protocol scheme")</code></span>
<span class="codeline" id="line-456"><code>			}</code></span>
<span class="codeline" id="line-457"><code>			return rawURL[:i], rawURL[i+1:], nil</code></span>
<span class="codeline" id="line-458"><code>		default:</code></span>
<span class="codeline" id="line-459"><code>			// we have encountered an invalid character,</code></span>
<span class="codeline" id="line-460"><code>			// so there is no valid scheme</code></span>
<span class="codeline" id="line-461"><code>			return "", rawURL, nil</code></span>
<span class="codeline" id="line-462"><code>		}</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code>	return "", rawURL, nil</code></span>
<span class="codeline" id="line-465"><code>}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>// Parse parses a raw url into a [URL] structure.</code></span>
<span class="codeline" id="line-468"><code>//</code></span>
<span class="codeline" id="line-469"><code>// The url may be relative (a path, without a host) or absolute</code></span>
<span class="codeline" id="line-470"><code>// (starting with a scheme). Trying to parse a hostname and path</code></span>
<span class="codeline" id="line-471"><code>// without a scheme is invalid but may not necessarily return an</code></span>
<span class="codeline" id="line-472"><code>// error, due to parsing ambiguities.</code></span>
<span class="codeline" id="line-473"><code>func Parse(rawURL string) (*URL, error) {</code></span>
<span class="codeline" id="line-474"><code>	// Cut off #frag</code></span>
<span class="codeline" id="line-475"><code>	u, frag, _ := strings.Cut(rawURL, "#")</code></span>
<span class="codeline" id="line-476"><code>	url, err := parse(u, false)</code></span>
<span class="codeline" id="line-477"><code>	if err != nil {</code></span>
<span class="codeline" id="line-478"><code>		return nil, &amp;Error{"parse", u, err}</code></span>
<span class="codeline" id="line-479"><code>	}</code></span>
<span class="codeline" id="line-480"><code>	if frag == "" {</code></span>
<span class="codeline" id="line-481"><code>		return url, nil</code></span>
<span class="codeline" id="line-482"><code>	}</code></span>
<span class="codeline" id="line-483"><code>	if err = url.setFragment(frag); err != nil {</code></span>
<span class="codeline" id="line-484"><code>		return nil, &amp;Error{"parse", rawURL, err}</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code>	return url, nil</code></span>
<span class="codeline" id="line-487"><code>}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>// ParseRequestURI parses a raw url into a [URL] structure. It assumes that</code></span>
<span class="codeline" id="line-490"><code>// url was received in an HTTP request, so the url is interpreted</code></span>
<span class="codeline" id="line-491"><code>// only as an absolute URI or an absolute path.</code></span>
<span class="codeline" id="line-492"><code>// The string url is assumed not to have a #fragment suffix.</code></span>
<span class="codeline" id="line-493"><code>// (Web browsers strip #fragment before sending the URL to a web server.)</code></span>
<span class="codeline" id="line-494"><code>func ParseRequestURI(rawURL string) (*URL, error) {</code></span>
<span class="codeline" id="line-495"><code>	url, err := parse(rawURL, true)</code></span>
<span class="codeline" id="line-496"><code>	if err != nil {</code></span>
<span class="codeline" id="line-497"><code>		return nil, &amp;Error{"parse", rawURL, err}</code></span>
<span class="codeline" id="line-498"><code>	}</code></span>
<span class="codeline" id="line-499"><code>	return url, nil</code></span>
<span class="codeline" id="line-500"><code>}</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>// parse parses a URL from a string in one of two contexts. If</code></span>
<span class="codeline" id="line-503"><code>// viaRequest is true, the URL is assumed to have arrived via an HTTP request,</code></span>
<span class="codeline" id="line-504"><code>// in which case only absolute URLs or path-absolute relative URLs are allowed.</code></span>
<span class="codeline" id="line-505"><code>// If viaRequest is false, all forms of relative URLs are allowed.</code></span>
<span class="codeline" id="line-506"><code>func parse(rawURL string, viaRequest bool) (*URL, error) {</code></span>
<span class="codeline" id="line-507"><code>	var rest string</code></span>
<span class="codeline" id="line-508"><code>	var err error</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>	if stringContainsCTLByte(rawURL) {</code></span>
<span class="codeline" id="line-511"><code>		return nil, errors.New("net/url: invalid control character in URL")</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>	if rawURL == "" &amp;&amp; viaRequest {</code></span>
<span class="codeline" id="line-515"><code>		return nil, errors.New("empty url")</code></span>
<span class="codeline" id="line-516"><code>	}</code></span>
<span class="codeline" id="line-517"><code>	url := new(URL)</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>	if rawURL == "*" {</code></span>
<span class="codeline" id="line-520"><code>		url.Path = "*"</code></span>
<span class="codeline" id="line-521"><code>		return url, nil</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	// Split off possible leading "http:", "mailto:", etc.</code></span>
<span class="codeline" id="line-525"><code>	// Cannot contain escaped characters.</code></span>
<span class="codeline" id="line-526"><code>	if url.Scheme, rest, err = getScheme(rawURL); err != nil {</code></span>
<span class="codeline" id="line-527"><code>		return nil, err</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code>	url.Scheme = strings.ToLower(url.Scheme)</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>	if strings.HasSuffix(rest, "?") &amp;&amp; strings.Count(rest, "?") == 1 {</code></span>
<span class="codeline" id="line-532"><code>		url.ForceQuery = true</code></span>
<span class="codeline" id="line-533"><code>		rest = rest[:len(rest)-1]</code></span>
<span class="codeline" id="line-534"><code>	} else {</code></span>
<span class="codeline" id="line-535"><code>		rest, url.RawQuery, _ = strings.Cut(rest, "?")</code></span>
<span class="codeline" id="line-536"><code>	}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>	if !strings.HasPrefix(rest, "/") {</code></span>
<span class="codeline" id="line-539"><code>		if url.Scheme != "" {</code></span>
<span class="codeline" id="line-540"><code>			// We consider rootless paths per RFC 3986 as opaque.</code></span>
<span class="codeline" id="line-541"><code>			url.Opaque = rest</code></span>
<span class="codeline" id="line-542"><code>			return url, nil</code></span>
<span class="codeline" id="line-543"><code>		}</code></span>
<span class="codeline" id="line-544"><code>		if viaRequest {</code></span>
<span class="codeline" id="line-545"><code>			return nil, errors.New("invalid URI for request")</code></span>
<span class="codeline" id="line-546"><code>		}</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>		// Avoid confusion with malformed schemes, like cache_object:foo/bar.</code></span>
<span class="codeline" id="line-549"><code>		// See golang.org/issue/16822.</code></span>
<span class="codeline" id="line-550"><code>		//</code></span>
<span class="codeline" id="line-551"><code>		// RFC 3986, §3.3:</code></span>
<span class="codeline" id="line-552"><code>		// In addition, a URI reference (Section 4.1) may be a relative-path reference,</code></span>
<span class="codeline" id="line-553"><code>		// in which case the first path segment cannot contain a colon (":") character.</code></span>
<span class="codeline" id="line-554"><code>		if segment, _, _ := strings.Cut(rest, "/"); strings.Contains(segment, ":") {</code></span>
<span class="codeline" id="line-555"><code>			// First path segment has colon. Not allowed in relative URL.</code></span>
<span class="codeline" id="line-556"><code>			return nil, errors.New("first path segment in URL cannot contain colon")</code></span>
<span class="codeline" id="line-557"><code>		}</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>	if (url.Scheme != "" || !viaRequest &amp;&amp; !strings.HasPrefix(rest, "///")) &amp;&amp; strings.HasPrefix(rest, "//") {</code></span>
<span class="codeline" id="line-561"><code>		var authority string</code></span>
<span class="codeline" id="line-562"><code>		authority, rest = rest[2:], ""</code></span>
<span class="codeline" id="line-563"><code>		if i := strings.Index(authority, "/"); i &gt;= 0 {</code></span>
<span class="codeline" id="line-564"><code>			authority, rest = authority[:i], authority[i:]</code></span>
<span class="codeline" id="line-565"><code>		}</code></span>
<span class="codeline" id="line-566"><code>		url.User, url.Host, err = parseAuthority(authority)</code></span>
<span class="codeline" id="line-567"><code>		if err != nil {</code></span>
<span class="codeline" id="line-568"><code>			return nil, err</code></span>
<span class="codeline" id="line-569"><code>		}</code></span>
<span class="codeline" id="line-570"><code>	} else if url.Scheme != "" &amp;&amp; strings.HasPrefix(rest, "/") {</code></span>
<span class="codeline" id="line-571"><code>		// OmitHost is set to true when rawURL has an empty host (authority).</code></span>
<span class="codeline" id="line-572"><code>		// See golang.org/issue/46059.</code></span>
<span class="codeline" id="line-573"><code>		url.OmitHost = true</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code></code></span>
<span class="codeline" id="line-576"><code>	// Set Path and, optionally, RawPath.</code></span>
<span class="codeline" id="line-577"><code>	// RawPath is a hint of the encoding of Path. We don't want to set it if</code></span>
<span class="codeline" id="line-578"><code>	// the default escaping of Path is equivalent, to help make sure that people</code></span>
<span class="codeline" id="line-579"><code>	// don't rely on it in general.</code></span>
<span class="codeline" id="line-580"><code>	if err := url.setPath(rest); err != nil {</code></span>
<span class="codeline" id="line-581"><code>		return nil, err</code></span>
<span class="codeline" id="line-582"><code>	}</code></span>
<span class="codeline" id="line-583"><code>	return url, nil</code></span>
<span class="codeline" id="line-584"><code>}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>func parseAuthority(authority string) (user *Userinfo, host string, err error) {</code></span>
<span class="codeline" id="line-587"><code>	i := strings.LastIndex(authority, "@")</code></span>
<span class="codeline" id="line-588"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-589"><code>		host, err = parseHost(authority)</code></span>
<span class="codeline" id="line-590"><code>	} else {</code></span>
<span class="codeline" id="line-591"><code>		host, err = parseHost(authority[i+1:])</code></span>
<span class="codeline" id="line-592"><code>	}</code></span>
<span class="codeline" id="line-593"><code>	if err != nil {</code></span>
<span class="codeline" id="line-594"><code>		return nil, "", err</code></span>
<span class="codeline" id="line-595"><code>	}</code></span>
<span class="codeline" id="line-596"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-597"><code>		return nil, host, nil</code></span>
<span class="codeline" id="line-598"><code>	}</code></span>
<span class="codeline" id="line-599"><code>	userinfo := authority[:i]</code></span>
<span class="codeline" id="line-600"><code>	if !validUserinfo(userinfo) {</code></span>
<span class="codeline" id="line-601"><code>		return nil, "", errors.New("net/url: invalid userinfo")</code></span>
<span class="codeline" id="line-602"><code>	}</code></span>
<span class="codeline" id="line-603"><code>	if !strings.Contains(userinfo, ":") {</code></span>
<span class="codeline" id="line-604"><code>		if userinfo, err = unescape(userinfo, encodeUserPassword); err != nil {</code></span>
<span class="codeline" id="line-605"><code>			return nil, "", err</code></span>
<span class="codeline" id="line-606"><code>		}</code></span>
<span class="codeline" id="line-607"><code>		user = User(userinfo)</code></span>
<span class="codeline" id="line-608"><code>	} else {</code></span>
<span class="codeline" id="line-609"><code>		username, password, _ := strings.Cut(userinfo, ":")</code></span>
<span class="codeline" id="line-610"><code>		if username, err = unescape(username, encodeUserPassword); err != nil {</code></span>
<span class="codeline" id="line-611"><code>			return nil, "", err</code></span>
<span class="codeline" id="line-612"><code>		}</code></span>
<span class="codeline" id="line-613"><code>		if password, err = unescape(password, encodeUserPassword); err != nil {</code></span>
<span class="codeline" id="line-614"><code>			return nil, "", err</code></span>
<span class="codeline" id="line-615"><code>		}</code></span>
<span class="codeline" id="line-616"><code>		user = UserPassword(username, password)</code></span>
<span class="codeline" id="line-617"><code>	}</code></span>
<span class="codeline" id="line-618"><code>	return user, host, nil</code></span>
<span class="codeline" id="line-619"><code>}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>// parseHost parses host as an authority without user</code></span>
<span class="codeline" id="line-622"><code>// information. That is, as host[:port].</code></span>
<span class="codeline" id="line-623"><code>func parseHost(host string) (string, error) {</code></span>
<span class="codeline" id="line-624"><code>	if strings.HasPrefix(host, "[") {</code></span>
<span class="codeline" id="line-625"><code>		// Parse an IP-Literal in RFC 3986 and RFC 6874.</code></span>
<span class="codeline" id="line-626"><code>		// E.g., "[fe80::1]", "[fe80::1%25en0]", "[fe80::1]:80".</code></span>
<span class="codeline" id="line-627"><code>		i := strings.LastIndex(host, "]")</code></span>
<span class="codeline" id="line-628"><code>		if i &lt; 0 {</code></span>
<span class="codeline" id="line-629"><code>			return "", errors.New("missing ']' in host")</code></span>
<span class="codeline" id="line-630"><code>		}</code></span>
<span class="codeline" id="line-631"><code>		colonPort := host[i+1:]</code></span>
<span class="codeline" id="line-632"><code>		if !validOptionalPort(colonPort) {</code></span>
<span class="codeline" id="line-633"><code>			return "", fmt.Errorf("invalid port %q after host", colonPort)</code></span>
<span class="codeline" id="line-634"><code>		}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>		// RFC 6874 defines that %25 (%-encoded percent) introduces</code></span>
<span class="codeline" id="line-637"><code>		// the zone identifier, and the zone identifier can use basically</code></span>
<span class="codeline" id="line-638"><code>		// any %-encoding it likes. That's different from the host, which</code></span>
<span class="codeline" id="line-639"><code>		// can only %-encode non-ASCII bytes.</code></span>
<span class="codeline" id="line-640"><code>		// We do impose some restrictions on the zone, to avoid stupidity</code></span>
<span class="codeline" id="line-641"><code>		// like newlines.</code></span>
<span class="codeline" id="line-642"><code>		zone := strings.Index(host[:i], "%25")</code></span>
<span class="codeline" id="line-643"><code>		if zone &gt;= 0 {</code></span>
<span class="codeline" id="line-644"><code>			host1, err := unescape(host[:zone], encodeHost)</code></span>
<span class="codeline" id="line-645"><code>			if err != nil {</code></span>
<span class="codeline" id="line-646"><code>				return "", err</code></span>
<span class="codeline" id="line-647"><code>			}</code></span>
<span class="codeline" id="line-648"><code>			host2, err := unescape(host[zone:i], encodeZone)</code></span>
<span class="codeline" id="line-649"><code>			if err != nil {</code></span>
<span class="codeline" id="line-650"><code>				return "", err</code></span>
<span class="codeline" id="line-651"><code>			}</code></span>
<span class="codeline" id="line-652"><code>			host3, err := unescape(host[i:], encodeHost)</code></span>
<span class="codeline" id="line-653"><code>			if err != nil {</code></span>
<span class="codeline" id="line-654"><code>				return "", err</code></span>
<span class="codeline" id="line-655"><code>			}</code></span>
<span class="codeline" id="line-656"><code>			return host1 + host2 + host3, nil</code></span>
<span class="codeline" id="line-657"><code>		}</code></span>
<span class="codeline" id="line-658"><code>	} else if i := strings.LastIndex(host, ":"); i != -1 {</code></span>
<span class="codeline" id="line-659"><code>		colonPort := host[i:]</code></span>
<span class="codeline" id="line-660"><code>		if !validOptionalPort(colonPort) {</code></span>
<span class="codeline" id="line-661"><code>			return "", fmt.Errorf("invalid port %q after host", colonPort)</code></span>
<span class="codeline" id="line-662"><code>		}</code></span>
<span class="codeline" id="line-663"><code>	}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>	var err error</code></span>
<span class="codeline" id="line-666"><code>	if host, err = unescape(host, encodeHost); err != nil {</code></span>
<span class="codeline" id="line-667"><code>		return "", err</code></span>
<span class="codeline" id="line-668"><code>	}</code></span>
<span class="codeline" id="line-669"><code>	return host, nil</code></span>
<span class="codeline" id="line-670"><code>}</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>// setPath sets the Path and RawPath fields of the URL based on the provided</code></span>
<span class="codeline" id="line-673"><code>// escaped path p. It maintains the invariant that RawPath is only specified</code></span>
<span class="codeline" id="line-674"><code>// when it differs from the default encoding of the path.</code></span>
<span class="codeline" id="line-675"><code>// For example:</code></span>
<span class="codeline" id="line-676"><code>// - setPath("/foo/bar")   will set Path="/foo/bar" and RawPath=""</code></span>
<span class="codeline" id="line-677"><code>// - setPath("/foo%2fbar") will set Path="/foo/bar" and RawPath="/foo%2fbar"</code></span>
<span class="codeline" id="line-678"><code>// setPath will return an error only if the provided path contains an invalid</code></span>
<span class="codeline" id="line-679"><code>// escaping.</code></span>
<span class="codeline" id="line-680"><code>func (u *URL) setPath(p string) error {</code></span>
<span class="codeline" id="line-681"><code>	path, err := unescape(p, encodePath)</code></span>
<span class="codeline" id="line-682"><code>	if err != nil {</code></span>
<span class="codeline" id="line-683"><code>		return err</code></span>
<span class="codeline" id="line-684"><code>	}</code></span>
<span class="codeline" id="line-685"><code>	u.Path = path</code></span>
<span class="codeline" id="line-686"><code>	if escp := escape(path, encodePath); p == escp {</code></span>
<span class="codeline" id="line-687"><code>		// Default encoding is fine.</code></span>
<span class="codeline" id="line-688"><code>		u.RawPath = ""</code></span>
<span class="codeline" id="line-689"><code>	} else {</code></span>
<span class="codeline" id="line-690"><code>		u.RawPath = p</code></span>
<span class="codeline" id="line-691"><code>	}</code></span>
<span class="codeline" id="line-692"><code>	return nil</code></span>
<span class="codeline" id="line-693"><code>}</code></span>
<span class="codeline" id="line-694"><code></code></span>
<span class="codeline" id="line-695"><code>// EscapedPath returns the escaped form of u.Path.</code></span>
<span class="codeline" id="line-696"><code>// In general there are multiple possible escaped forms of any path.</code></span>
<span class="codeline" id="line-697"><code>// EscapedPath returns u.RawPath when it is a valid escaping of u.Path.</code></span>
<span class="codeline" id="line-698"><code>// Otherwise EscapedPath ignores u.RawPath and computes an escaped</code></span>
<span class="codeline" id="line-699"><code>// form on its own.</code></span>
<span class="codeline" id="line-700"><code>// The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct</code></span>
<span class="codeline" id="line-701"><code>// their results.</code></span>
<span class="codeline" id="line-702"><code>// In general, code should call EscapedPath instead of</code></span>
<span class="codeline" id="line-703"><code>// reading u.RawPath directly.</code></span>
<span class="codeline" id="line-704"><code>func (u *URL) EscapedPath() string {</code></span>
<span class="codeline" id="line-705"><code>	if u.RawPath != "" &amp;&amp; validEncoded(u.RawPath, encodePath) {</code></span>
<span class="codeline" id="line-706"><code>		p, err := unescape(u.RawPath, encodePath)</code></span>
<span class="codeline" id="line-707"><code>		if err == nil &amp;&amp; p == u.Path {</code></span>
<span class="codeline" id="line-708"><code>			return u.RawPath</code></span>
<span class="codeline" id="line-709"><code>		}</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>	if u.Path == "*" {</code></span>
<span class="codeline" id="line-712"><code>		return "*" // don't escape (Issue 11202)</code></span>
<span class="codeline" id="line-713"><code>	}</code></span>
<span class="codeline" id="line-714"><code>	return escape(u.Path, encodePath)</code></span>
<span class="codeline" id="line-715"><code>}</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>// validEncoded reports whether s is a valid encoded path or fragment,</code></span>
<span class="codeline" id="line-718"><code>// according to mode.</code></span>
<span class="codeline" id="line-719"><code>// It must not contain any bytes that require escaping during encoding.</code></span>
<span class="codeline" id="line-720"><code>func validEncoded(s string, mode encoding) bool {</code></span>
<span class="codeline" id="line-721"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-722"><code>		// RFC 3986, Appendix A.</code></span>
<span class="codeline" id="line-723"><code>		// pchar = unreserved / pct-encoded / sub-delims / ":" / "@".</code></span>
<span class="codeline" id="line-724"><code>		// shouldEscape is not quite compliant with the RFC,</code></span>
<span class="codeline" id="line-725"><code>		// so we check the sub-delims ourselves and let</code></span>
<span class="codeline" id="line-726"><code>		// shouldEscape handle the others.</code></span>
<span class="codeline" id="line-727"><code>		switch s[i] {</code></span>
<span class="codeline" id="line-728"><code>		case '!', '$', '&amp;', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '@':</code></span>
<span class="codeline" id="line-729"><code>			// ok</code></span>
<span class="codeline" id="line-730"><code>		case '[', ']':</code></span>
<span class="codeline" id="line-731"><code>			// ok - not specified in RFC 3986 but left alone by modern browsers</code></span>
<span class="codeline" id="line-732"><code>		case '%':</code></span>
<span class="codeline" id="line-733"><code>			// ok - percent encoded, will decode</code></span>
<span class="codeline" id="line-734"><code>		default:</code></span>
<span class="codeline" id="line-735"><code>			if shouldEscape(s[i], mode) {</code></span>
<span class="codeline" id="line-736"><code>				return false</code></span>
<span class="codeline" id="line-737"><code>			}</code></span>
<span class="codeline" id="line-738"><code>		}</code></span>
<span class="codeline" id="line-739"><code>	}</code></span>
<span class="codeline" id="line-740"><code>	return true</code></span>
<span class="codeline" id="line-741"><code>}</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>// setFragment is like setPath but for Fragment/RawFragment.</code></span>
<span class="codeline" id="line-744"><code>func (u *URL) setFragment(f string) error {</code></span>
<span class="codeline" id="line-745"><code>	frag, err := unescape(f, encodeFragment)</code></span>
<span class="codeline" id="line-746"><code>	if err != nil {</code></span>
<span class="codeline" id="line-747"><code>		return err</code></span>
<span class="codeline" id="line-748"><code>	}</code></span>
<span class="codeline" id="line-749"><code>	u.Fragment = frag</code></span>
<span class="codeline" id="line-750"><code>	if escf := escape(frag, encodeFragment); f == escf {</code></span>
<span class="codeline" id="line-751"><code>		// Default encoding is fine.</code></span>
<span class="codeline" id="line-752"><code>		u.RawFragment = ""</code></span>
<span class="codeline" id="line-753"><code>	} else {</code></span>
<span class="codeline" id="line-754"><code>		u.RawFragment = f</code></span>
<span class="codeline" id="line-755"><code>	}</code></span>
<span class="codeline" id="line-756"><code>	return nil</code></span>
<span class="codeline" id="line-757"><code>}</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>// EscapedFragment returns the escaped form of u.Fragment.</code></span>
<span class="codeline" id="line-760"><code>// In general there are multiple possible escaped forms of any fragment.</code></span>
<span class="codeline" id="line-761"><code>// EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.</code></span>
<span class="codeline" id="line-762"><code>// Otherwise EscapedFragment ignores u.RawFragment and computes an escaped</code></span>
<span class="codeline" id="line-763"><code>// form on its own.</code></span>
<span class="codeline" id="line-764"><code>// The [URL.String] method uses EscapedFragment to construct its result.</code></span>
<span class="codeline" id="line-765"><code>// In general, code should call EscapedFragment instead of</code></span>
<span class="codeline" id="line-766"><code>// reading u.RawFragment directly.</code></span>
<span class="codeline" id="line-767"><code>func (u *URL) EscapedFragment() string {</code></span>
<span class="codeline" id="line-768"><code>	if u.RawFragment != "" &amp;&amp; validEncoded(u.RawFragment, encodeFragment) {</code></span>
<span class="codeline" id="line-769"><code>		f, err := unescape(u.RawFragment, encodeFragment)</code></span>
<span class="codeline" id="line-770"><code>		if err == nil &amp;&amp; f == u.Fragment {</code></span>
<span class="codeline" id="line-771"><code>			return u.RawFragment</code></span>
<span class="codeline" id="line-772"><code>		}</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code>	return escape(u.Fragment, encodeFragment)</code></span>
<span class="codeline" id="line-775"><code>}</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>// validOptionalPort reports whether port is either an empty string</code></span>
<span class="codeline" id="line-778"><code>// or matches /^:\d*$/</code></span>
<span class="codeline" id="line-779"><code>func validOptionalPort(port string) bool {</code></span>
<span class="codeline" id="line-780"><code>	if port == "" {</code></span>
<span class="codeline" id="line-781"><code>		return true</code></span>
<span class="codeline" id="line-782"><code>	}</code></span>
<span class="codeline" id="line-783"><code>	if port[0] != ':' {</code></span>
<span class="codeline" id="line-784"><code>		return false</code></span>
<span class="codeline" id="line-785"><code>	}</code></span>
<span class="codeline" id="line-786"><code>	for _, b := range port[1:] {</code></span>
<span class="codeline" id="line-787"><code>		if b &lt; '0' || b &gt; '9' {</code></span>
<span class="codeline" id="line-788"><code>			return false</code></span>
<span class="codeline" id="line-789"><code>		}</code></span>
<span class="codeline" id="line-790"><code>	}</code></span>
<span class="codeline" id="line-791"><code>	return true</code></span>
<span class="codeline" id="line-792"><code>}</code></span>
<span class="codeline" id="line-793"><code></code></span>
<span class="codeline" id="line-794"><code>// String reassembles the [URL] into a valid URL string.</code></span>
<span class="codeline" id="line-795"><code>// The general form of the result is one of:</code></span>
<span class="codeline" id="line-796"><code>//</code></span>
<span class="codeline" id="line-797"><code>//	scheme:opaque?query#fragment</code></span>
<span class="codeline" id="line-798"><code>//	scheme://userinfo@host/path?query#fragment</code></span>
<span class="codeline" id="line-799"><code>//</code></span>
<span class="codeline" id="line-800"><code>// If u.Opaque is non-empty, String uses the first form;</code></span>
<span class="codeline" id="line-801"><code>// otherwise it uses the second form.</code></span>
<span class="codeline" id="line-802"><code>// Any non-ASCII characters in host are escaped.</code></span>
<span class="codeline" id="line-803"><code>// To obtain the path, String uses u.EscapedPath().</code></span>
<span class="codeline" id="line-804"><code>//</code></span>
<span class="codeline" id="line-805"><code>// In the second form, the following rules apply:</code></span>
<span class="codeline" id="line-806"><code>//   - if u.Scheme is empty, scheme: is omitted.</code></span>
<span class="codeline" id="line-807"><code>//   - if u.User is nil, userinfo@ is omitted.</code></span>
<span class="codeline" id="line-808"><code>//   - if u.Host is empty, host/ is omitted.</code></span>
<span class="codeline" id="line-809"><code>//   - if u.Scheme and u.Host are empty and u.User is nil,</code></span>
<span class="codeline" id="line-810"><code>//     the entire scheme://userinfo@host/ is omitted.</code></span>
<span class="codeline" id="line-811"><code>//   - if u.Host is non-empty and u.Path begins with a /,</code></span>
<span class="codeline" id="line-812"><code>//     the form host/path does not add its own /.</code></span>
<span class="codeline" id="line-813"><code>//   - if u.RawQuery is empty, ?query is omitted.</code></span>
<span class="codeline" id="line-814"><code>//   - if u.Fragment is empty, #fragment is omitted.</code></span>
<span class="codeline" id="line-815"><code>func (u *URL) String() string {</code></span>
<span class="codeline" id="line-816"><code>	var buf strings.Builder</code></span>
<span class="codeline" id="line-817"><code>	if u.Scheme != "" {</code></span>
<span class="codeline" id="line-818"><code>		buf.WriteString(u.Scheme)</code></span>
<span class="codeline" id="line-819"><code>		buf.WriteByte(':')</code></span>
<span class="codeline" id="line-820"><code>	}</code></span>
<span class="codeline" id="line-821"><code>	if u.Opaque != "" {</code></span>
<span class="codeline" id="line-822"><code>		buf.WriteString(u.Opaque)</code></span>
<span class="codeline" id="line-823"><code>	} else {</code></span>
<span class="codeline" id="line-824"><code>		if u.Scheme != "" || u.Host != "" || u.User != nil {</code></span>
<span class="codeline" id="line-825"><code>			if u.OmitHost &amp;&amp; u.Host == "" &amp;&amp; u.User == nil {</code></span>
<span class="codeline" id="line-826"><code>				// omit empty host</code></span>
<span class="codeline" id="line-827"><code>			} else {</code></span>
<span class="codeline" id="line-828"><code>				if u.Host != "" || u.Path != "" || u.User != nil {</code></span>
<span class="codeline" id="line-829"><code>					buf.WriteString("//")</code></span>
<span class="codeline" id="line-830"><code>				}</code></span>
<span class="codeline" id="line-831"><code>				if ui := u.User; ui != nil {</code></span>
<span class="codeline" id="line-832"><code>					buf.WriteString(ui.String())</code></span>
<span class="codeline" id="line-833"><code>					buf.WriteByte('@')</code></span>
<span class="codeline" id="line-834"><code>				}</code></span>
<span class="codeline" id="line-835"><code>				if h := u.Host; h != "" {</code></span>
<span class="codeline" id="line-836"><code>					buf.WriteString(escape(h, encodeHost))</code></span>
<span class="codeline" id="line-837"><code>				}</code></span>
<span class="codeline" id="line-838"><code>			}</code></span>
<span class="codeline" id="line-839"><code>		}</code></span>
<span class="codeline" id="line-840"><code>		path := u.EscapedPath()</code></span>
<span class="codeline" id="line-841"><code>		if path != "" &amp;&amp; path[0] != '/' &amp;&amp; u.Host != "" {</code></span>
<span class="codeline" id="line-842"><code>			buf.WriteByte('/')</code></span>
<span class="codeline" id="line-843"><code>		}</code></span>
<span class="codeline" id="line-844"><code>		if buf.Len() == 0 {</code></span>
<span class="codeline" id="line-845"><code>			// RFC 3986 §4.2</code></span>
<span class="codeline" id="line-846"><code>			// A path segment that contains a colon character (e.g., "this:that")</code></span>
<span class="codeline" id="line-847"><code>			// cannot be used as the first segment of a relative-path reference, as</code></span>
<span class="codeline" id="line-848"><code>			// it would be mistaken for a scheme name. Such a segment must be</code></span>
<span class="codeline" id="line-849"><code>			// preceded by a dot-segment (e.g., "./this:that") to make a relative-</code></span>
<span class="codeline" id="line-850"><code>			// path reference.</code></span>
<span class="codeline" id="line-851"><code>			if segment, _, _ := strings.Cut(path, "/"); strings.Contains(segment, ":") {</code></span>
<span class="codeline" id="line-852"><code>				buf.WriteString("./")</code></span>
<span class="codeline" id="line-853"><code>			}</code></span>
<span class="codeline" id="line-854"><code>		}</code></span>
<span class="codeline" id="line-855"><code>		buf.WriteString(path)</code></span>
<span class="codeline" id="line-856"><code>	}</code></span>
<span class="codeline" id="line-857"><code>	if u.ForceQuery || u.RawQuery != "" {</code></span>
<span class="codeline" id="line-858"><code>		buf.WriteByte('?')</code></span>
<span class="codeline" id="line-859"><code>		buf.WriteString(u.RawQuery)</code></span>
<span class="codeline" id="line-860"><code>	}</code></span>
<span class="codeline" id="line-861"><code>	if u.Fragment != "" {</code></span>
<span class="codeline" id="line-862"><code>		buf.WriteByte('#')</code></span>
<span class="codeline" id="line-863"><code>		buf.WriteString(u.EscapedFragment())</code></span>
<span class="codeline" id="line-864"><code>	}</code></span>
<span class="codeline" id="line-865"><code>	return buf.String()</code></span>
<span class="codeline" id="line-866"><code>}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>// Redacted is like [URL.String] but replaces any password with "xxxxx".</code></span>
<span class="codeline" id="line-869"><code>// Only the password in u.User is redacted.</code></span>
<span class="codeline" id="line-870"><code>func (u *URL) Redacted() string {</code></span>
<span class="codeline" id="line-871"><code>	if u == nil {</code></span>
<span class="codeline" id="line-872"><code>		return ""</code></span>
<span class="codeline" id="line-873"><code>	}</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>	ru := *u</code></span>
<span class="codeline" id="line-876"><code>	if _, has := ru.User.Password(); has {</code></span>
<span class="codeline" id="line-877"><code>		ru.User = UserPassword(ru.User.Username(), "xxxxx")</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code>	return ru.String()</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>// Values maps a string key to a list of values.</code></span>
<span class="codeline" id="line-883"><code>// It is typically used for query parameters and form values.</code></span>
<span class="codeline" id="line-884"><code>// Unlike in the http.Header map, the keys in a Values map</code></span>
<span class="codeline" id="line-885"><code>// are case-sensitive.</code></span>
<span class="codeline" id="line-886"><code>type Values map[string][]string</code></span>
<span class="codeline" id="line-887"><code></code></span>
<span class="codeline" id="line-888"><code>// Get gets the first value associated with the given key.</code></span>
<span class="codeline" id="line-889"><code>// If there are no values associated with the key, Get returns</code></span>
<span class="codeline" id="line-890"><code>// the empty string. To access multiple values, use the map</code></span>
<span class="codeline" id="line-891"><code>// directly.</code></span>
<span class="codeline" id="line-892"><code>func (v Values) Get(key string) string {</code></span>
<span class="codeline" id="line-893"><code>	vs := v[key]</code></span>
<span class="codeline" id="line-894"><code>	if len(vs) == 0 {</code></span>
<span class="codeline" id="line-895"><code>		return ""</code></span>
<span class="codeline" id="line-896"><code>	}</code></span>
<span class="codeline" id="line-897"><code>	return vs[0]</code></span>
<span class="codeline" id="line-898"><code>}</code></span>
<span class="codeline" id="line-899"><code></code></span>
<span class="codeline" id="line-900"><code>// Set sets the key to value. It replaces any existing</code></span>
<span class="codeline" id="line-901"><code>// values.</code></span>
<span class="codeline" id="line-902"><code>func (v Values) Set(key, value string) {</code></span>
<span class="codeline" id="line-903"><code>	v[key] = []string{value}</code></span>
<span class="codeline" id="line-904"><code>}</code></span>
<span class="codeline" id="line-905"><code></code></span>
<span class="codeline" id="line-906"><code>// Add adds the value to key. It appends to any existing</code></span>
<span class="codeline" id="line-907"><code>// values associated with key.</code></span>
<span class="codeline" id="line-908"><code>func (v Values) Add(key, value string) {</code></span>
<span class="codeline" id="line-909"><code>	v[key] = append(v[key], value)</code></span>
<span class="codeline" id="line-910"><code>}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>// Del deletes the values associated with key.</code></span>
<span class="codeline" id="line-913"><code>func (v Values) Del(key string) {</code></span>
<span class="codeline" id="line-914"><code>	delete(v, key)</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>// Has checks whether a given key is set.</code></span>
<span class="codeline" id="line-918"><code>func (v Values) Has(key string) bool {</code></span>
<span class="codeline" id="line-919"><code>	_, ok := v[key]</code></span>
<span class="codeline" id="line-920"><code>	return ok</code></span>
<span class="codeline" id="line-921"><code>}</code></span>
<span class="codeline" id="line-922"><code></code></span>
<span class="codeline" id="line-923"><code>// ParseQuery parses the URL-encoded query string and returns</code></span>
<span class="codeline" id="line-924"><code>// a map listing the values specified for each key.</code></span>
<span class="codeline" id="line-925"><code>// ParseQuery always returns a non-nil map containing all the</code></span>
<span class="codeline" id="line-926"><code>// valid query parameters found; err describes the first decoding error</code></span>
<span class="codeline" id="line-927"><code>// encountered, if any.</code></span>
<span class="codeline" id="line-928"><code>//</code></span>
<span class="codeline" id="line-929"><code>// Query is expected to be a list of key=value settings separated by ampersands.</code></span>
<span class="codeline" id="line-930"><code>// A setting without an equals sign is interpreted as a key set to an empty</code></span>
<span class="codeline" id="line-931"><code>// value.</code></span>
<span class="codeline" id="line-932"><code>// Settings containing a non-URL-encoded semicolon are considered invalid.</code></span>
<span class="codeline" id="line-933"><code>func ParseQuery(query string) (Values, error) {</code></span>
<span class="codeline" id="line-934"><code>	m := make(Values)</code></span>
<span class="codeline" id="line-935"><code>	err := parseQuery(m, query)</code></span>
<span class="codeline" id="line-936"><code>	return m, err</code></span>
<span class="codeline" id="line-937"><code>}</code></span>
<span class="codeline" id="line-938"><code></code></span>
<span class="codeline" id="line-939"><code>func parseQuery(m Values, query string) (err error) {</code></span>
<span class="codeline" id="line-940"><code>	for query != "" {</code></span>
<span class="codeline" id="line-941"><code>		var key string</code></span>
<span class="codeline" id="line-942"><code>		key, query, _ = strings.Cut(query, "&amp;")</code></span>
<span class="codeline" id="line-943"><code>		if strings.Contains(key, ";") {</code></span>
<span class="codeline" id="line-944"><code>			err = fmt.Errorf("invalid semicolon separator in query")</code></span>
<span class="codeline" id="line-945"><code>			continue</code></span>
<span class="codeline" id="line-946"><code>		}</code></span>
<span class="codeline" id="line-947"><code>		if key == "" {</code></span>
<span class="codeline" id="line-948"><code>			continue</code></span>
<span class="codeline" id="line-949"><code>		}</code></span>
<span class="codeline" id="line-950"><code>		key, value, _ := strings.Cut(key, "=")</code></span>
<span class="codeline" id="line-951"><code>		key, err1 := QueryUnescape(key)</code></span>
<span class="codeline" id="line-952"><code>		if err1 != nil {</code></span>
<span class="codeline" id="line-953"><code>			if err == nil {</code></span>
<span class="codeline" id="line-954"><code>				err = err1</code></span>
<span class="codeline" id="line-955"><code>			}</code></span>
<span class="codeline" id="line-956"><code>			continue</code></span>
<span class="codeline" id="line-957"><code>		}</code></span>
<span class="codeline" id="line-958"><code>		value, err1 = QueryUnescape(value)</code></span>
<span class="codeline" id="line-959"><code>		if err1 != nil {</code></span>
<span class="codeline" id="line-960"><code>			if err == nil {</code></span>
<span class="codeline" id="line-961"><code>				err = err1</code></span>
<span class="codeline" id="line-962"><code>			}</code></span>
<span class="codeline" id="line-963"><code>			continue</code></span>
<span class="codeline" id="line-964"><code>		}</code></span>
<span class="codeline" id="line-965"><code>		m[key] = append(m[key], value)</code></span>
<span class="codeline" id="line-966"><code>	}</code></span>
<span class="codeline" id="line-967"><code>	return err</code></span>
<span class="codeline" id="line-968"><code>}</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>// Encode encodes the values into “URL encoded” form</code></span>
<span class="codeline" id="line-971"><code>// ("bar=baz&amp;foo=quux") sorted by key.</code></span>
<span class="codeline" id="line-972"><code>func (v Values) Encode() string {</code></span>
<span class="codeline" id="line-973"><code>	if len(v) == 0 {</code></span>
<span class="codeline" id="line-974"><code>		return ""</code></span>
<span class="codeline" id="line-975"><code>	}</code></span>
<span class="codeline" id="line-976"><code>	var buf strings.Builder</code></span>
<span class="codeline" id="line-977"><code>	keys := make([]string, 0, len(v))</code></span>
<span class="codeline" id="line-978"><code>	for k := range v {</code></span>
<span class="codeline" id="line-979"><code>		keys = append(keys, k)</code></span>
<span class="codeline" id="line-980"><code>	}</code></span>
<span class="codeline" id="line-981"><code>	sort.Strings(keys)</code></span>
<span class="codeline" id="line-982"><code>	for _, k := range keys {</code></span>
<span class="codeline" id="line-983"><code>		vs := v[k]</code></span>
<span class="codeline" id="line-984"><code>		keyEscaped := QueryEscape(k)</code></span>
<span class="codeline" id="line-985"><code>		for _, v := range vs {</code></span>
<span class="codeline" id="line-986"><code>			if buf.Len() &gt; 0 {</code></span>
<span class="codeline" id="line-987"><code>				buf.WriteByte('&amp;')</code></span>
<span class="codeline" id="line-988"><code>			}</code></span>
<span class="codeline" id="line-989"><code>			buf.WriteString(keyEscaped)</code></span>
<span class="codeline" id="line-990"><code>			buf.WriteByte('=')</code></span>
<span class="codeline" id="line-991"><code>			buf.WriteString(QueryEscape(v))</code></span>
<span class="codeline" id="line-992"><code>		}</code></span>
<span class="codeline" id="line-993"><code>	}</code></span>
<span class="codeline" id="line-994"><code>	return buf.String()</code></span>
<span class="codeline" id="line-995"><code>}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>// resolvePath applies special path segments from refs and applies</code></span>
<span class="codeline" id="line-998"><code>// them to base, per RFC 3986.</code></span>
<span class="codeline" id="line-999"><code>func resolvePath(base, ref string) string {</code></span>
<span class="codeline" id="line-1000"><code>	var full string</code></span>
<span class="codeline" id="line-1001"><code>	if ref == "" {</code></span>
<span class="codeline" id="line-1002"><code>		full = base</code></span>
<span class="codeline" id="line-1003"><code>	} else if ref[0] != '/' {</code></span>
<span class="codeline" id="line-1004"><code>		i := strings.LastIndex(base, "/")</code></span>
<span class="codeline" id="line-1005"><code>		full = base[:i+1] + ref</code></span>
<span class="codeline" id="line-1006"><code>	} else {</code></span>
<span class="codeline" id="line-1007"><code>		full = ref</code></span>
<span class="codeline" id="line-1008"><code>	}</code></span>
<span class="codeline" id="line-1009"><code>	if full == "" {</code></span>
<span class="codeline" id="line-1010"><code>		return ""</code></span>
<span class="codeline" id="line-1011"><code>	}</code></span>
<span class="codeline" id="line-1012"><code></code></span>
<span class="codeline" id="line-1013"><code>	var (</code></span>
<span class="codeline" id="line-1014"><code>		elem string</code></span>
<span class="codeline" id="line-1015"><code>		dst  strings.Builder</code></span>
<span class="codeline" id="line-1016"><code>	)</code></span>
<span class="codeline" id="line-1017"><code>	first := true</code></span>
<span class="codeline" id="line-1018"><code>	remaining := full</code></span>
<span class="codeline" id="line-1019"><code>	// We want to return a leading '/', so write it now.</code></span>
<span class="codeline" id="line-1020"><code>	dst.WriteByte('/')</code></span>
<span class="codeline" id="line-1021"><code>	found := true</code></span>
<span class="codeline" id="line-1022"><code>	for found {</code></span>
<span class="codeline" id="line-1023"><code>		elem, remaining, found = strings.Cut(remaining, "/")</code></span>
<span class="codeline" id="line-1024"><code>		if elem == "." {</code></span>
<span class="codeline" id="line-1025"><code>			first = false</code></span>
<span class="codeline" id="line-1026"><code>			// drop</code></span>
<span class="codeline" id="line-1027"><code>			continue</code></span>
<span class="codeline" id="line-1028"><code>		}</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>		if elem == ".." {</code></span>
<span class="codeline" id="line-1031"><code>			// Ignore the leading '/' we already wrote.</code></span>
<span class="codeline" id="line-1032"><code>			str := dst.String()[1:]</code></span>
<span class="codeline" id="line-1033"><code>			index := strings.LastIndexByte(str, '/')</code></span>
<span class="codeline" id="line-1034"><code></code></span>
<span class="codeline" id="line-1035"><code>			dst.Reset()</code></span>
<span class="codeline" id="line-1036"><code>			dst.WriteByte('/')</code></span>
<span class="codeline" id="line-1037"><code>			if index == -1 {</code></span>
<span class="codeline" id="line-1038"><code>				first = true</code></span>
<span class="codeline" id="line-1039"><code>			} else {</code></span>
<span class="codeline" id="line-1040"><code>				dst.WriteString(str[:index])</code></span>
<span class="codeline" id="line-1041"><code>			}</code></span>
<span class="codeline" id="line-1042"><code>		} else {</code></span>
<span class="codeline" id="line-1043"><code>			if !first {</code></span>
<span class="codeline" id="line-1044"><code>				dst.WriteByte('/')</code></span>
<span class="codeline" id="line-1045"><code>			}</code></span>
<span class="codeline" id="line-1046"><code>			dst.WriteString(elem)</code></span>
<span class="codeline" id="line-1047"><code>			first = false</code></span>
<span class="codeline" id="line-1048"><code>		}</code></span>
<span class="codeline" id="line-1049"><code>	}</code></span>
<span class="codeline" id="line-1050"><code></code></span>
<span class="codeline" id="line-1051"><code>	if elem == "." || elem == ".." {</code></span>
<span class="codeline" id="line-1052"><code>		dst.WriteByte('/')</code></span>
<span class="codeline" id="line-1053"><code>	}</code></span>
<span class="codeline" id="line-1054"><code></code></span>
<span class="codeline" id="line-1055"><code>	// We wrote an initial '/', but we don't want two.</code></span>
<span class="codeline" id="line-1056"><code>	r := dst.String()</code></span>
<span class="codeline" id="line-1057"><code>	if len(r) &gt; 1 &amp;&amp; r[1] == '/' {</code></span>
<span class="codeline" id="line-1058"><code>		r = r[1:]</code></span>
<span class="codeline" id="line-1059"><code>	}</code></span>
<span class="codeline" id="line-1060"><code>	return r</code></span>
<span class="codeline" id="line-1061"><code>}</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>// IsAbs reports whether the [URL] is absolute.</code></span>
<span class="codeline" id="line-1064"><code>// Absolute means that it has a non-empty scheme.</code></span>
<span class="codeline" id="line-1065"><code>func (u *URL) IsAbs() bool {</code></span>
<span class="codeline" id="line-1066"><code>	return u.Scheme != ""</code></span>
<span class="codeline" id="line-1067"><code>}</code></span>
<span class="codeline" id="line-1068"><code></code></span>
<span class="codeline" id="line-1069"><code>// Parse parses a [URL] in the context of the receiver. The provided URL</code></span>
<span class="codeline" id="line-1070"><code>// may be relative or absolute. Parse returns nil, err on parse</code></span>
<span class="codeline" id="line-1071"><code>// failure, otherwise its return value is the same as [URL.ResolveReference].</code></span>
<span class="codeline" id="line-1072"><code>func (u *URL) Parse(ref string) (*URL, error) {</code></span>
<span class="codeline" id="line-1073"><code>	refURL, err := Parse(ref)</code></span>
<span class="codeline" id="line-1074"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1075"><code>		return nil, err</code></span>
<span class="codeline" id="line-1076"><code>	}</code></span>
<span class="codeline" id="line-1077"><code>	return u.ResolveReference(refURL), nil</code></span>
<span class="codeline" id="line-1078"><code>}</code></span>
<span class="codeline" id="line-1079"><code></code></span>
<span class="codeline" id="line-1080"><code>// ResolveReference resolves a URI reference to an absolute URI from</code></span>
<span class="codeline" id="line-1081"><code>// an absolute base URI u, per RFC 3986 Section 5.2. The URI reference</code></span>
<span class="codeline" id="line-1082"><code>// may be relative or absolute. ResolveReference always returns a new</code></span>
<span class="codeline" id="line-1083"><code>// [URL] instance, even if the returned URL is identical to either the</code></span>
<span class="codeline" id="line-1084"><code>// base or reference. If ref is an absolute URL, then ResolveReference</code></span>
<span class="codeline" id="line-1085"><code>// ignores base and returns a copy of ref.</code></span>
<span class="codeline" id="line-1086"><code>func (u *URL) ResolveReference(ref *URL) *URL {</code></span>
<span class="codeline" id="line-1087"><code>	url := *ref</code></span>
<span class="codeline" id="line-1088"><code>	if ref.Scheme == "" {</code></span>
<span class="codeline" id="line-1089"><code>		url.Scheme = u.Scheme</code></span>
<span class="codeline" id="line-1090"><code>	}</code></span>
<span class="codeline" id="line-1091"><code>	if ref.Scheme != "" || ref.Host != "" || ref.User != nil {</code></span>
<span class="codeline" id="line-1092"><code>		// The "absoluteURI" or "net_path" cases.</code></span>
<span class="codeline" id="line-1093"><code>		// We can ignore the error from setPath since we know we provided a</code></span>
<span class="codeline" id="line-1094"><code>		// validly-escaped path.</code></span>
<span class="codeline" id="line-1095"><code>		url.setPath(resolvePath(ref.EscapedPath(), ""))</code></span>
<span class="codeline" id="line-1096"><code>		return &amp;url</code></span>
<span class="codeline" id="line-1097"><code>	}</code></span>
<span class="codeline" id="line-1098"><code>	if ref.Opaque != "" {</code></span>
<span class="codeline" id="line-1099"><code>		url.User = nil</code></span>
<span class="codeline" id="line-1100"><code>		url.Host = ""</code></span>
<span class="codeline" id="line-1101"><code>		url.Path = ""</code></span>
<span class="codeline" id="line-1102"><code>		return &amp;url</code></span>
<span class="codeline" id="line-1103"><code>	}</code></span>
<span class="codeline" id="line-1104"><code>	if ref.Path == "" &amp;&amp; !ref.ForceQuery &amp;&amp; ref.RawQuery == "" {</code></span>
<span class="codeline" id="line-1105"><code>		url.RawQuery = u.RawQuery</code></span>
<span class="codeline" id="line-1106"><code>		if ref.Fragment == "" {</code></span>
<span class="codeline" id="line-1107"><code>			url.Fragment = u.Fragment</code></span>
<span class="codeline" id="line-1108"><code>			url.RawFragment = u.RawFragment</code></span>
<span class="codeline" id="line-1109"><code>		}</code></span>
<span class="codeline" id="line-1110"><code>	}</code></span>
<span class="codeline" id="line-1111"><code>	// The "abs_path" or "rel_path" cases.</code></span>
<span class="codeline" id="line-1112"><code>	url.Host = u.Host</code></span>
<span class="codeline" id="line-1113"><code>	url.User = u.User</code></span>
<span class="codeline" id="line-1114"><code>	url.setPath(resolvePath(u.EscapedPath(), ref.EscapedPath()))</code></span>
<span class="codeline" id="line-1115"><code>	return &amp;url</code></span>
<span class="codeline" id="line-1116"><code>}</code></span>
<span class="codeline" id="line-1117"><code></code></span>
<span class="codeline" id="line-1118"><code>// Query parses RawQuery and returns the corresponding values.</code></span>
<span class="codeline" id="line-1119"><code>// It silently discards malformed value pairs.</code></span>
<span class="codeline" id="line-1120"><code>// To check errors use [ParseQuery].</code></span>
<span class="codeline" id="line-1121"><code>func (u *URL) Query() Values {</code></span>
<span class="codeline" id="line-1122"><code>	v, _ := ParseQuery(u.RawQuery)</code></span>
<span class="codeline" id="line-1123"><code>	return v</code></span>
<span class="codeline" id="line-1124"><code>}</code></span>
<span class="codeline" id="line-1125"><code></code></span>
<span class="codeline" id="line-1126"><code>// RequestURI returns the encoded path?query or opaque?query</code></span>
<span class="codeline" id="line-1127"><code>// string that would be used in an HTTP request for u.</code></span>
<span class="codeline" id="line-1128"><code>func (u *URL) RequestURI() string {</code></span>
<span class="codeline" id="line-1129"><code>	result := u.Opaque</code></span>
<span class="codeline" id="line-1130"><code>	if result == "" {</code></span>
<span class="codeline" id="line-1131"><code>		result = u.EscapedPath()</code></span>
<span class="codeline" id="line-1132"><code>		if result == "" {</code></span>
<span class="codeline" id="line-1133"><code>			result = "/"</code></span>
<span class="codeline" id="line-1134"><code>		}</code></span>
<span class="codeline" id="line-1135"><code>	} else {</code></span>
<span class="codeline" id="line-1136"><code>		if strings.HasPrefix(result, "//") {</code></span>
<span class="codeline" id="line-1137"><code>			result = u.Scheme + ":" + result</code></span>
<span class="codeline" id="line-1138"><code>		}</code></span>
<span class="codeline" id="line-1139"><code>	}</code></span>
<span class="codeline" id="line-1140"><code>	if u.ForceQuery || u.RawQuery != "" {</code></span>
<span class="codeline" id="line-1141"><code>		result += "?" + u.RawQuery</code></span>
<span class="codeline" id="line-1142"><code>	}</code></span>
<span class="codeline" id="line-1143"><code>	return result</code></span>
<span class="codeline" id="line-1144"><code>}</code></span>
<span class="codeline" id="line-1145"><code></code></span>
<span class="codeline" id="line-1146"><code>// Hostname returns u.Host, stripping any valid port number if present.</code></span>
<span class="codeline" id="line-1147"><code>//</code></span>
<span class="codeline" id="line-1148"><code>// If the result is enclosed in square brackets, as literal IPv6 addresses are,</code></span>
<span class="codeline" id="line-1149"><code>// the square brackets are removed from the result.</code></span>
<span class="codeline" id="line-1150"><code>func (u *URL) Hostname() string {</code></span>
<span class="codeline" id="line-1151"><code>	host, _ := splitHostPort(u.Host)</code></span>
<span class="codeline" id="line-1152"><code>	return host</code></span>
<span class="codeline" id="line-1153"><code>}</code></span>
<span class="codeline" id="line-1154"><code></code></span>
<span class="codeline" id="line-1155"><code>// Port returns the port part of u.Host, without the leading colon.</code></span>
<span class="codeline" id="line-1156"><code>//</code></span>
<span class="codeline" id="line-1157"><code>// If u.Host doesn't contain a valid numeric port, Port returns an empty string.</code></span>
<span class="codeline" id="line-1158"><code>func (u *URL) Port() string {</code></span>
<span class="codeline" id="line-1159"><code>	_, port := splitHostPort(u.Host)</code></span>
<span class="codeline" id="line-1160"><code>	return port</code></span>
<span class="codeline" id="line-1161"><code>}</code></span>
<span class="codeline" id="line-1162"><code></code></span>
<span class="codeline" id="line-1163"><code>// splitHostPort separates host and port. If the port is not valid, it returns</code></span>
<span class="codeline" id="line-1164"><code>// the entire input as host, and it doesn't check the validity of the host.</code></span>
<span class="codeline" id="line-1165"><code>// Unlike net.SplitHostPort, but per RFC 3986, it requires ports to be numeric.</code></span>
<span class="codeline" id="line-1166"><code>func splitHostPort(hostPort string) (host, port string) {</code></span>
<span class="codeline" id="line-1167"><code>	host = hostPort</code></span>
<span class="codeline" id="line-1168"><code></code></span>
<span class="codeline" id="line-1169"><code>	colon := strings.LastIndexByte(host, ':')</code></span>
<span class="codeline" id="line-1170"><code>	if colon != -1 &amp;&amp; validOptionalPort(host[colon:]) {</code></span>
<span class="codeline" id="line-1171"><code>		host, port = host[:colon], host[colon+1:]</code></span>
<span class="codeline" id="line-1172"><code>	}</code></span>
<span class="codeline" id="line-1173"><code></code></span>
<span class="codeline" id="line-1174"><code>	if strings.HasPrefix(host, "[") &amp;&amp; strings.HasSuffix(host, "]") {</code></span>
<span class="codeline" id="line-1175"><code>		host = host[1 : len(host)-1]</code></span>
<span class="codeline" id="line-1176"><code>	}</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>	return</code></span>
<span class="codeline" id="line-1179"><code>}</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>// Marshaling interface implementations.</code></span>
<span class="codeline" id="line-1182"><code>// Would like to implement MarshalText/UnmarshalText but that will change the JSON representation of URLs.</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>func (u *URL) MarshalBinary() (text []byte, err error) {</code></span>
<span class="codeline" id="line-1185"><code>	return []byte(u.String()), nil</code></span>
<span class="codeline" id="line-1186"><code>}</code></span>
<span class="codeline" id="line-1187"><code></code></span>
<span class="codeline" id="line-1188"><code>func (u *URL) UnmarshalBinary(text []byte) error {</code></span>
<span class="codeline" id="line-1189"><code>	u1, err := Parse(string(text))</code></span>
<span class="codeline" id="line-1190"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1191"><code>		return err</code></span>
<span class="codeline" id="line-1192"><code>	}</code></span>
<span class="codeline" id="line-1193"><code>	*u = *u1</code></span>
<span class="codeline" id="line-1194"><code>	return nil</code></span>
<span class="codeline" id="line-1195"><code>}</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>// JoinPath returns a new [URL] with the provided path elements joined to</code></span>
<span class="codeline" id="line-1198"><code>// any existing path and the resulting path cleaned of any ./ or ../ elements.</code></span>
<span class="codeline" id="line-1199"><code>// Any sequences of multiple / characters will be reduced to a single /.</code></span>
<span class="codeline" id="line-1200"><code>func (u *URL) JoinPath(elem ...string) *URL {</code></span>
<span class="codeline" id="line-1201"><code>	elem = append([]string{u.EscapedPath()}, elem...)</code></span>
<span class="codeline" id="line-1202"><code>	var p string</code></span>
<span class="codeline" id="line-1203"><code>	if !strings.HasPrefix(elem[0], "/") {</code></span>
<span class="codeline" id="line-1204"><code>		// Return a relative path if u is relative,</code></span>
<span class="codeline" id="line-1205"><code>		// but ensure that it contains no ../ elements.</code></span>
<span class="codeline" id="line-1206"><code>		elem[0] = "/" + elem[0]</code></span>
<span class="codeline" id="line-1207"><code>		p = path.Join(elem...)[1:]</code></span>
<span class="codeline" id="line-1208"><code>	} else {</code></span>
<span class="codeline" id="line-1209"><code>		p = path.Join(elem...)</code></span>
<span class="codeline" id="line-1210"><code>	}</code></span>
<span class="codeline" id="line-1211"><code>	// path.Join will remove any trailing slashes.</code></span>
<span class="codeline" id="line-1212"><code>	// Preserve at least one.</code></span>
<span class="codeline" id="line-1213"><code>	if strings.HasSuffix(elem[len(elem)-1], "/") &amp;&amp; !strings.HasSuffix(p, "/") {</code></span>
<span class="codeline" id="line-1214"><code>		p += "/"</code></span>
<span class="codeline" id="line-1215"><code>	}</code></span>
<span class="codeline" id="line-1216"><code>	url := *u</code></span>
<span class="codeline" id="line-1217"><code>	url.setPath(p)</code></span>
<span class="codeline" id="line-1218"><code>	return &amp;url</code></span>
<span class="codeline" id="line-1219"><code>}</code></span>
<span class="codeline" id="line-1220"><code></code></span>
<span class="codeline" id="line-1221"><code>// validUserinfo reports whether s is a valid userinfo string per RFC 3986</code></span>
<span class="codeline" id="line-1222"><code>// Section 3.2.1:</code></span>
<span class="codeline" id="line-1223"><code>//</code></span>
<span class="codeline" id="line-1224"><code>//	userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )</code></span>
<span class="codeline" id="line-1225"><code>//	unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"</code></span>
<span class="codeline" id="line-1226"><code>//	sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"</code></span>
<span class="codeline" id="line-1227"><code>//	              / "*" / "+" / "," / ";" / "="</code></span>
<span class="codeline" id="line-1228"><code>//</code></span>
<span class="codeline" id="line-1229"><code>// It doesn't validate pct-encoded. The caller does that via func unescape.</code></span>
<span class="codeline" id="line-1230"><code>func validUserinfo(s string) bool {</code></span>
<span class="codeline" id="line-1231"><code>	for _, r := range s {</code></span>
<span class="codeline" id="line-1232"><code>		if 'A' &lt;= r &amp;&amp; r &lt;= 'Z' {</code></span>
<span class="codeline" id="line-1233"><code>			continue</code></span>
<span class="codeline" id="line-1234"><code>		}</code></span>
<span class="codeline" id="line-1235"><code>		if 'a' &lt;= r &amp;&amp; r &lt;= 'z' {</code></span>
<span class="codeline" id="line-1236"><code>			continue</code></span>
<span class="codeline" id="line-1237"><code>		}</code></span>
<span class="codeline" id="line-1238"><code>		if '0' &lt;= r &amp;&amp; r &lt;= '9' {</code></span>
<span class="codeline" id="line-1239"><code>			continue</code></span>
<span class="codeline" id="line-1240"><code>		}</code></span>
<span class="codeline" id="line-1241"><code>		switch r {</code></span>
<span class="codeline" id="line-1242"><code>		case '-', '.', '_', ':', '~', '!', '$', '&amp;', '\'',</code></span>
<span class="codeline" id="line-1243"><code>			'(', ')', '*', '+', ',', ';', '=', '%', '@':</code></span>
<span class="codeline" id="line-1244"><code>			continue</code></span>
<span class="codeline" id="line-1245"><code>		default:</code></span>
<span class="codeline" id="line-1246"><code>			return false</code></span>
<span class="codeline" id="line-1247"><code>		}</code></span>
<span class="codeline" id="line-1248"><code>	}</code></span>
<span class="codeline" id="line-1249"><code>	return true</code></span>
<span class="codeline" id="line-1250"><code>}</code></span>
<span class="codeline" id="line-1251"><code></code></span>
<span class="codeline" id="line-1252"><code>// stringContainsCTLByte reports whether s contains any ASCII control character.</code></span>
<span class="codeline" id="line-1253"><code>func stringContainsCTLByte(s string) bool {</code></span>
<span class="codeline" id="line-1254"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-1255"><code>		b := s[i]</code></span>
<span class="codeline" id="line-1256"><code>		if b &lt; ' ' || b == 0x7f {</code></span>
<span class="codeline" id="line-1257"><code>			return true</code></span>
<span class="codeline" id="line-1258"><code>		}</code></span>
<span class="codeline" id="line-1259"><code>	}</code></span>
<span class="codeline" id="line-1260"><code>	return false</code></span>
<span class="codeline" id="line-1261"><code>}</code></span>
<span class="codeline" id="line-1262"><code></code></span>
<span class="codeline" id="line-1263"><code>// JoinPath returns a [URL] string with the provided path elements joined to</code></span>
<span class="codeline" id="line-1264"><code>// the existing path of base and the resulting path cleaned of any ./ or ../ elements.</code></span>
<span class="codeline" id="line-1265"><code>func JoinPath(base string, elem ...string) (result string, err error) {</code></span>
<span class="codeline" id="line-1266"><code>	url, err := Parse(base)</code></span>
<span class="codeline" id="line-1267"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1268"><code>		return</code></span>
<span class="codeline" id="line-1269"><code>	}</code></span>
<span class="codeline" id="line-1270"><code>	result = url.JoinPath(elem...).String()</code></span>
<span class="codeline" id="line-1271"><code>	return</code></span>
<span class="codeline" id="line-1272"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>