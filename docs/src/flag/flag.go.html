<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: flag.go in package flag</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	flag.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/flag.html">flag</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>Package flag implements command-line flag parsing.</code></span>
<span class="codeline" id="line-7"><code></code></span>
<span class="codeline" id="line-8"><code># Usage</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>Define flags using [flag.String], [Bool], [Int], etc.</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>This declares an integer flag, -n, stored in the pointer nFlag, with type *int:</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>	import "flag"</code></span>
<span class="codeline" id="line-15"><code>	var nFlag = flag.Int("n", 1234, "help message for flag n")</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>If you like, you can bind the flag to a variable using the Var() functions.</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>	var flagvar int</code></span>
<span class="codeline" id="line-20"><code>	func init() {</code></span>
<span class="codeline" id="line-21"><code>		flag.IntVar(&amp;flagvar, "flagname", 1234, "help message for flagname")</code></span>
<span class="codeline" id="line-22"><code>	}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>Or you can create custom flags that satisfy the Value interface (with</code></span>
<span class="codeline" id="line-25"><code>pointer receivers) and couple them to flag parsing by</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>	flag.Var(&amp;flagVal, "name", "help message for flagname")</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>For such flags, the default value is just the initial value of the variable.</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>After all flags are defined, call</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>	flag.Parse()</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>to parse the command line into the defined flags.</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>Flags may then be used directly. If you're using the flags themselves,</code></span>
<span class="codeline" id="line-38"><code>they are all pointers; if you bind to variables, they're values.</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>	fmt.Println("ip has value ", *ip)</code></span>
<span class="codeline" id="line-41"><code>	fmt.Println("flagvar has value ", flagvar)</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>After parsing, the arguments following the flags are available as the</code></span>
<span class="codeline" id="line-44"><code>slice [flag.Args] or individually as [flag.Arg](i).</code></span>
<span class="codeline" id="line-45"><code>The arguments are indexed from 0 through [flag.NArg]-1.</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code># Command line flag syntax</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>The following forms are permitted:</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>	-flag</code></span>
<span class="codeline" id="line-52"><code>	--flag   // double dashes are also permitted</code></span>
<span class="codeline" id="line-53"><code>	-flag=x</code></span>
<span class="codeline" id="line-54"><code>	-flag x  // non-boolean flags only</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>One or two dashes may be used; they are equivalent.</code></span>
<span class="codeline" id="line-57"><code>The last form is not permitted for boolean flags because the</code></span>
<span class="codeline" id="line-58"><code>meaning of the command</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	cmd -x *</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>where * is a Unix shell wildcard, will change if there is a file</code></span>
<span class="codeline" id="line-63"><code>called 0, false, etc. You must use the -flag=false form to turn</code></span>
<span class="codeline" id="line-64"><code>off a boolean flag.</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>Flag parsing stops just before the first non-flag argument</code></span>
<span class="codeline" id="line-67"><code>("-" is a non-flag argument) or after the terminator "--".</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>Integer flags accept 1234, 0664, 0x1234 and may be negative.</code></span>
<span class="codeline" id="line-70"><code>Boolean flags may be:</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>	1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>Duration flags accept any input valid for time.ParseDuration.</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>The default set of command-line flags is controlled by</code></span>
<span class="codeline" id="line-77"><code>top-level functions.  The [FlagSet] type allows one to define</code></span>
<span class="codeline" id="line-78"><code>independent sets of flags, such as to implement subcommands</code></span>
<span class="codeline" id="line-79"><code>in a command-line interface. The methods of [FlagSet] are</code></span>
<span class="codeline" id="line-80"><code>analogous to the top-level functions for the command-line</code></span>
<span class="codeline" id="line-81"><code>flag set.</code></span>
<span class="codeline" id="line-82"><code>*/</code></span></div><span class="codeline" id="line-83"><code>package flag</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>import (</code></span>
<span class="codeline" id="line-86"><code>	"encoding"</code></span>
<span class="codeline" id="line-87"><code>	"errors"</code></span>
<span class="codeline" id="line-88"><code>	"fmt"</code></span>
<span class="codeline" id="line-89"><code>	"io"</code></span>
<span class="codeline" id="line-90"><code>	"os"</code></span>
<span class="codeline" id="line-91"><code>	"reflect"</code></span>
<span class="codeline" id="line-92"><code>	"runtime"</code></span>
<span class="codeline" id="line-93"><code>	"sort"</code></span>
<span class="codeline" id="line-94"><code>	"strconv"</code></span>
<span class="codeline" id="line-95"><code>	"strings"</code></span>
<span class="codeline" id="line-96"><code>	"time"</code></span>
<span class="codeline" id="line-97"><code>)</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>// ErrHelp is the error returned if the -help or -h flag is invoked</code></span>
<span class="codeline" id="line-100"><code>// but no such flag is defined.</code></span>
<span class="codeline" id="line-101"><code>var ErrHelp = errors.New("flag: help requested")</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>// errParse is returned by Set if a flag's value fails to parse, such as with an invalid integer for Int.</code></span>
<span class="codeline" id="line-104"><code>// It then gets wrapped through failf to provide more information.</code></span>
<span class="codeline" id="line-105"><code>var errParse = errors.New("parse error")</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>// errRange is returned by Set if a flag's value is out of range.</code></span>
<span class="codeline" id="line-108"><code>// It then gets wrapped through failf to provide more information.</code></span>
<span class="codeline" id="line-109"><code>var errRange = errors.New("value out of range")</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>func numError(err error) error {</code></span>
<span class="codeline" id="line-112"><code>	ne, ok := err.(*strconv.NumError)</code></span>
<span class="codeline" id="line-113"><code>	if !ok {</code></span>
<span class="codeline" id="line-114"><code>		return err</code></span>
<span class="codeline" id="line-115"><code>	}</code></span>
<span class="codeline" id="line-116"><code>	if ne.Err == strconv.ErrSyntax {</code></span>
<span class="codeline" id="line-117"><code>		return errParse</code></span>
<span class="codeline" id="line-118"><code>	}</code></span>
<span class="codeline" id="line-119"><code>	if ne.Err == strconv.ErrRange {</code></span>
<span class="codeline" id="line-120"><code>		return errRange</code></span>
<span class="codeline" id="line-121"><code>	}</code></span>
<span class="codeline" id="line-122"><code>	return err</code></span>
<span class="codeline" id="line-123"><code>}</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>// -- bool Value</code></span>
<span class="codeline" id="line-126"><code>type boolValue bool</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>func newBoolValue(val bool, p *bool) *boolValue {</code></span>
<span class="codeline" id="line-129"><code>	*p = val</code></span>
<span class="codeline" id="line-130"><code>	return (*boolValue)(p)</code></span>
<span class="codeline" id="line-131"><code>}</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>func (b *boolValue) Set(s string) error {</code></span>
<span class="codeline" id="line-134"><code>	v, err := strconv.ParseBool(s)</code></span>
<span class="codeline" id="line-135"><code>	if err != nil {</code></span>
<span class="codeline" id="line-136"><code>		err = errParse</code></span>
<span class="codeline" id="line-137"><code>	}</code></span>
<span class="codeline" id="line-138"><code>	*b = boolValue(v)</code></span>
<span class="codeline" id="line-139"><code>	return err</code></span>
<span class="codeline" id="line-140"><code>}</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>func (b *boolValue) Get() any { return bool(*b) }</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>func (b *boolValue) String() string { return strconv.FormatBool(bool(*b)) }</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>func (b *boolValue) IsBoolFlag() bool { return true }</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>// optional interface to indicate boolean flags that can be</code></span>
<span class="codeline" id="line-149"><code>// supplied without "=value" text</code></span>
<span class="codeline" id="line-150"><code>type boolFlag interface {</code></span>
<span class="codeline" id="line-151"><code>	Value</code></span>
<span class="codeline" id="line-152"><code>	IsBoolFlag() bool</code></span>
<span class="codeline" id="line-153"><code>}</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>// -- int Value</code></span>
<span class="codeline" id="line-156"><code>type intValue int</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>func newIntValue(val int, p *int) *intValue {</code></span>
<span class="codeline" id="line-159"><code>	*p = val</code></span>
<span class="codeline" id="line-160"><code>	return (*intValue)(p)</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>func (i *intValue) Set(s string) error {</code></span>
<span class="codeline" id="line-164"><code>	v, err := strconv.ParseInt(s, 0, strconv.IntSize)</code></span>
<span class="codeline" id="line-165"><code>	if err != nil {</code></span>
<span class="codeline" id="line-166"><code>		err = numError(err)</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code>	*i = intValue(v)</code></span>
<span class="codeline" id="line-169"><code>	return err</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>func (i *intValue) Get() any { return int(*i) }</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>func (i *intValue) String() string { return strconv.Itoa(int(*i)) }</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// -- int64 Value</code></span>
<span class="codeline" id="line-177"><code>type int64Value int64</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>func newInt64Value(val int64, p *int64) *int64Value {</code></span>
<span class="codeline" id="line-180"><code>	*p = val</code></span>
<span class="codeline" id="line-181"><code>	return (*int64Value)(p)</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>func (i *int64Value) Set(s string) error {</code></span>
<span class="codeline" id="line-185"><code>	v, err := strconv.ParseInt(s, 0, 64)</code></span>
<span class="codeline" id="line-186"><code>	if err != nil {</code></span>
<span class="codeline" id="line-187"><code>		err = numError(err)</code></span>
<span class="codeline" id="line-188"><code>	}</code></span>
<span class="codeline" id="line-189"><code>	*i = int64Value(v)</code></span>
<span class="codeline" id="line-190"><code>	return err</code></span>
<span class="codeline" id="line-191"><code>}</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>func (i *int64Value) Get() any { return int64(*i) }</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>func (i *int64Value) String() string { return strconv.FormatInt(int64(*i), 10) }</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>// -- uint Value</code></span>
<span class="codeline" id="line-198"><code>type uintValue uint</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>func newUintValue(val uint, p *uint) *uintValue {</code></span>
<span class="codeline" id="line-201"><code>	*p = val</code></span>
<span class="codeline" id="line-202"><code>	return (*uintValue)(p)</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>func (i *uintValue) Set(s string) error {</code></span>
<span class="codeline" id="line-206"><code>	v, err := strconv.ParseUint(s, 0, strconv.IntSize)</code></span>
<span class="codeline" id="line-207"><code>	if err != nil {</code></span>
<span class="codeline" id="line-208"><code>		err = numError(err)</code></span>
<span class="codeline" id="line-209"><code>	}</code></span>
<span class="codeline" id="line-210"><code>	*i = uintValue(v)</code></span>
<span class="codeline" id="line-211"><code>	return err</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>func (i *uintValue) Get() any { return uint(*i) }</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>func (i *uintValue) String() string { return strconv.FormatUint(uint64(*i), 10) }</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>// -- uint64 Value</code></span>
<span class="codeline" id="line-219"><code>type uint64Value uint64</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>func newUint64Value(val uint64, p *uint64) *uint64Value {</code></span>
<span class="codeline" id="line-222"><code>	*p = val</code></span>
<span class="codeline" id="line-223"><code>	return (*uint64Value)(p)</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>func (i *uint64Value) Set(s string) error {</code></span>
<span class="codeline" id="line-227"><code>	v, err := strconv.ParseUint(s, 0, 64)</code></span>
<span class="codeline" id="line-228"><code>	if err != nil {</code></span>
<span class="codeline" id="line-229"><code>		err = numError(err)</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	*i = uint64Value(v)</code></span>
<span class="codeline" id="line-232"><code>	return err</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>func (i *uint64Value) Get() any { return uint64(*i) }</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>func (i *uint64Value) String() string { return strconv.FormatUint(uint64(*i), 10) }</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>// -- string Value</code></span>
<span class="codeline" id="line-240"><code>type stringValue string</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>func newStringValue(val string, p *string) *stringValue {</code></span>
<span class="codeline" id="line-243"><code>	*p = val</code></span>
<span class="codeline" id="line-244"><code>	return (*stringValue)(p)</code></span>
<span class="codeline" id="line-245"><code>}</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>func (s *stringValue) Set(val string) error {</code></span>
<span class="codeline" id="line-248"><code>	*s = stringValue(val)</code></span>
<span class="codeline" id="line-249"><code>	return nil</code></span>
<span class="codeline" id="line-250"><code>}</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>func (s *stringValue) Get() any { return string(*s) }</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>func (s *stringValue) String() string { return string(*s) }</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// -- float64 Value</code></span>
<span class="codeline" id="line-257"><code>type float64Value float64</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>func newFloat64Value(val float64, p *float64) *float64Value {</code></span>
<span class="codeline" id="line-260"><code>	*p = val</code></span>
<span class="codeline" id="line-261"><code>	return (*float64Value)(p)</code></span>
<span class="codeline" id="line-262"><code>}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>func (f *float64Value) Set(s string) error {</code></span>
<span class="codeline" id="line-265"><code>	v, err := strconv.ParseFloat(s, 64)</code></span>
<span class="codeline" id="line-266"><code>	if err != nil {</code></span>
<span class="codeline" id="line-267"><code>		err = numError(err)</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	*f = float64Value(v)</code></span>
<span class="codeline" id="line-270"><code>	return err</code></span>
<span class="codeline" id="line-271"><code>}</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>func (f *float64Value) Get() any { return float64(*f) }</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>func (f *float64Value) String() string { return strconv.FormatFloat(float64(*f), 'g', -1, 64) }</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// -- time.Duration Value</code></span>
<span class="codeline" id="line-278"><code>type durationValue time.Duration</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>func newDurationValue(val time.Duration, p *time.Duration) *durationValue {</code></span>
<span class="codeline" id="line-281"><code>	*p = val</code></span>
<span class="codeline" id="line-282"><code>	return (*durationValue)(p)</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>func (d *durationValue) Set(s string) error {</code></span>
<span class="codeline" id="line-286"><code>	v, err := time.ParseDuration(s)</code></span>
<span class="codeline" id="line-287"><code>	if err != nil {</code></span>
<span class="codeline" id="line-288"><code>		err = errParse</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	*d = durationValue(v)</code></span>
<span class="codeline" id="line-291"><code>	return err</code></span>
<span class="codeline" id="line-292"><code>}</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>func (d *durationValue) Get() any { return time.Duration(*d) }</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>func (d *durationValue) String() string { return (*time.Duration)(d).String() }</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>// -- encoding.TextUnmarshaler Value</code></span>
<span class="codeline" id="line-299"><code>type textValue struct{ p encoding.TextUnmarshaler }</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>func newTextValue(val encoding.TextMarshaler, p encoding.TextUnmarshaler) textValue {</code></span>
<span class="codeline" id="line-302"><code>	ptrVal := reflect.ValueOf(p)</code></span>
<span class="codeline" id="line-303"><code>	if ptrVal.Kind() != reflect.Ptr {</code></span>
<span class="codeline" id="line-304"><code>		panic("variable value type must be a pointer")</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code>	defVal := reflect.ValueOf(val)</code></span>
<span class="codeline" id="line-307"><code>	if defVal.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-308"><code>		defVal = defVal.Elem()</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	if defVal.Type() != ptrVal.Type().Elem() {</code></span>
<span class="codeline" id="line-311"><code>		panic(fmt.Sprintf("default type does not match variable type: %v != %v", defVal.Type(), ptrVal.Type().Elem()))</code></span>
<span class="codeline" id="line-312"><code>	}</code></span>
<span class="codeline" id="line-313"><code>	ptrVal.Elem().Set(defVal)</code></span>
<span class="codeline" id="line-314"><code>	return textValue{p}</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>func (v textValue) Set(s string) error {</code></span>
<span class="codeline" id="line-318"><code>	return v.p.UnmarshalText([]byte(s))</code></span>
<span class="codeline" id="line-319"><code>}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>func (v textValue) Get() interface{} {</code></span>
<span class="codeline" id="line-322"><code>	return v.p</code></span>
<span class="codeline" id="line-323"><code>}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>func (v textValue) String() string {</code></span>
<span class="codeline" id="line-326"><code>	if m, ok := v.p.(encoding.TextMarshaler); ok {</code></span>
<span class="codeline" id="line-327"><code>		if b, err := m.MarshalText(); err == nil {</code></span>
<span class="codeline" id="line-328"><code>			return string(b)</code></span>
<span class="codeline" id="line-329"><code>		}</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	return ""</code></span>
<span class="codeline" id="line-332"><code>}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>// -- func Value</code></span>
<span class="codeline" id="line-335"><code>type funcValue func(string) error</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>func (f funcValue) Set(s string) error { return f(s) }</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>func (f funcValue) String() string { return "" }</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>// -- boolFunc Value</code></span>
<span class="codeline" id="line-342"><code>type boolFuncValue func(string) error</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>func (f boolFuncValue) Set(s string) error { return f(s) }</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>func (f boolFuncValue) String() string { return "" }</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>func (f boolFuncValue) IsBoolFlag() bool { return true }</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>// Value is the interface to the dynamic value stored in a flag.</code></span>
<span class="codeline" id="line-351"><code>// (The default value is represented as a string.)</code></span>
<span class="codeline" id="line-352"><code>//</code></span>
<span class="codeline" id="line-353"><code>// If a Value has an IsBoolFlag() bool method returning true,</code></span>
<span class="codeline" id="line-354"><code>// the command-line parser makes -name equivalent to -name=true</code></span>
<span class="codeline" id="line-355"><code>// rather than using the next command-line argument.</code></span>
<span class="codeline" id="line-356"><code>//</code></span>
<span class="codeline" id="line-357"><code>// Set is called once, in command line order, for each flag present.</code></span>
<span class="codeline" id="line-358"><code>// The flag package may call the [String] method with a zero-valued receiver,</code></span>
<span class="codeline" id="line-359"><code>// such as a nil pointer.</code></span>
<span class="codeline" id="line-360"><code>type Value interface {</code></span>
<span class="codeline" id="line-361"><code>	String() string</code></span>
<span class="codeline" id="line-362"><code>	Set(string) error</code></span>
<span class="codeline" id="line-363"><code>}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>// Getter is an interface that allows the contents of a [Value] to be retrieved.</code></span>
<span class="codeline" id="line-366"><code>// It wraps the [Value] interface, rather than being part of it, because it</code></span>
<span class="codeline" id="line-367"><code>// appeared after Go 1 and its compatibility rules. All [Value] types provided</code></span>
<span class="codeline" id="line-368"><code>// by this package satisfy the [Getter] interface, except the type used by [Func].</code></span>
<span class="codeline" id="line-369"><code>type Getter interface {</code></span>
<span class="codeline" id="line-370"><code>	Value</code></span>
<span class="codeline" id="line-371"><code>	Get() any</code></span>
<span class="codeline" id="line-372"><code>}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>// ErrorHandling defines how [FlagSet.Parse] behaves if the parse fails.</code></span>
<span class="codeline" id="line-375"><code>type ErrorHandling int</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>// These constants cause [FlagSet.Parse] to behave as described if the parse fails.</code></span>
<span class="codeline" id="line-378"><code>const (</code></span>
<span class="codeline" id="line-379"><code>	ContinueOnError ErrorHandling = iota // Return a descriptive error.</code></span>
<span class="codeline" id="line-380"><code>	ExitOnError                          // Call os.Exit(2) or for -h/-help Exit(0).</code></span>
<span class="codeline" id="line-381"><code>	PanicOnError                         // Call panic with a descriptive error.</code></span>
<span class="codeline" id="line-382"><code>)</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>// A FlagSet represents a set of defined flags. The zero value of a FlagSet</code></span>
<span class="codeline" id="line-385"><code>// has no name and has [ContinueOnError] error handling.</code></span>
<span class="codeline" id="line-386"><code>//</code></span>
<span class="codeline" id="line-387"><code>// [Flag] names must be unique within a FlagSet. An attempt to define a flag whose</code></span>
<span class="codeline" id="line-388"><code>// name is already in use will cause a panic.</code></span>
<span class="codeline" id="line-389"><code>type FlagSet struct {</code></span>
<span class="codeline" id="line-390"><code>	// Usage is the function called when an error occurs while parsing flags.</code></span>
<span class="codeline" id="line-391"><code>	// The field is a function (not a method) that may be changed to point to</code></span>
<span class="codeline" id="line-392"><code>	// a custom error handler. What happens after Usage is called depends</code></span>
<span class="codeline" id="line-393"><code>	// on the ErrorHandling setting; for the command line, this defaults</code></span>
<span class="codeline" id="line-394"><code>	// to ExitOnError, which exits the program after calling Usage.</code></span>
<span class="codeline" id="line-395"><code>	Usage func()</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>	name          string</code></span>
<span class="codeline" id="line-398"><code>	parsed        bool</code></span>
<span class="codeline" id="line-399"><code>	actual        map[string]*Flag</code></span>
<span class="codeline" id="line-400"><code>	formal        map[string]*Flag</code></span>
<span class="codeline" id="line-401"><code>	args          []string // arguments after flags</code></span>
<span class="codeline" id="line-402"><code>	errorHandling ErrorHandling</code></span>
<span class="codeline" id="line-403"><code>	output        io.Writer         // nil means stderr; use Output() accessor</code></span>
<span class="codeline" id="line-404"><code>	undef         map[string]string // flags which didn't exist at the time of Set</code></span>
<span class="codeline" id="line-405"><code>}</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>// A Flag represents the state of a flag.</code></span>
<span class="codeline" id="line-408"><code>type Flag struct {</code></span>
<span class="codeline" id="line-409"><code>	Name     string // name as it appears on command line</code></span>
<span class="codeline" id="line-410"><code>	Usage    string // help message</code></span>
<span class="codeline" id="line-411"><code>	Value    Value  // value as set</code></span>
<span class="codeline" id="line-412"><code>	DefValue string // default value (as text); for usage message</code></span>
<span class="codeline" id="line-413"><code>}</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>// sortFlags returns the flags as a slice in lexicographical sorted order.</code></span>
<span class="codeline" id="line-416"><code>func sortFlags(flags map[string]*Flag) []*Flag {</code></span>
<span class="codeline" id="line-417"><code>	result := make([]*Flag, len(flags))</code></span>
<span class="codeline" id="line-418"><code>	i := 0</code></span>
<span class="codeline" id="line-419"><code>	for _, f := range flags {</code></span>
<span class="codeline" id="line-420"><code>		result[i] = f</code></span>
<span class="codeline" id="line-421"><code>		i++</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code>	sort.Slice(result, func(i, j int) bool {</code></span>
<span class="codeline" id="line-424"><code>		return result[i].Name &lt; result[j].Name</code></span>
<span class="codeline" id="line-425"><code>	})</code></span>
<span class="codeline" id="line-426"><code>	return result</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>// Output returns the destination for usage and error messages. [os.Stderr] is returned if</code></span>
<span class="codeline" id="line-430"><code>// output was not set or was set to nil.</code></span>
<span class="codeline" id="line-431"><code>func (f *FlagSet) Output() io.Writer {</code></span>
<span class="codeline" id="line-432"><code>	if f.output == nil {</code></span>
<span class="codeline" id="line-433"><code>		return os.Stderr</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	return f.output</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>// Name returns the name of the flag set.</code></span>
<span class="codeline" id="line-439"><code>func (f *FlagSet) Name() string {</code></span>
<span class="codeline" id="line-440"><code>	return f.name</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>// ErrorHandling returns the error handling behavior of the flag set.</code></span>
<span class="codeline" id="line-444"><code>func (f *FlagSet) ErrorHandling() ErrorHandling {</code></span>
<span class="codeline" id="line-445"><code>	return f.errorHandling</code></span>
<span class="codeline" id="line-446"><code>}</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>// SetOutput sets the destination for usage and error messages.</code></span>
<span class="codeline" id="line-449"><code>// If output is nil, [os.Stderr] is used.</code></span>
<span class="codeline" id="line-450"><code>func (f *FlagSet) SetOutput(output io.Writer) {</code></span>
<span class="codeline" id="line-451"><code>	f.output = output</code></span>
<span class="codeline" id="line-452"><code>}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>// VisitAll visits the flags in lexicographical order, calling fn for each.</code></span>
<span class="codeline" id="line-455"><code>// It visits all flags, even those not set.</code></span>
<span class="codeline" id="line-456"><code>func (f *FlagSet) VisitAll(fn func(*Flag)) {</code></span>
<span class="codeline" id="line-457"><code>	for _, flag := range sortFlags(f.formal) {</code></span>
<span class="codeline" id="line-458"><code>		fn(flag)</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>// VisitAll visits the command-line flags in lexicographical order, calling</code></span>
<span class="codeline" id="line-463"><code>// fn for each. It visits all flags, even those not set.</code></span>
<span class="codeline" id="line-464"><code>func VisitAll(fn func(*Flag)) {</code></span>
<span class="codeline" id="line-465"><code>	CommandLine.VisitAll(fn)</code></span>
<span class="codeline" id="line-466"><code>}</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>// Visit visits the flags in lexicographical order, calling fn for each.</code></span>
<span class="codeline" id="line-469"><code>// It visits only those flags that have been set.</code></span>
<span class="codeline" id="line-470"><code>func (f *FlagSet) Visit(fn func(*Flag)) {</code></span>
<span class="codeline" id="line-471"><code>	for _, flag := range sortFlags(f.actual) {</code></span>
<span class="codeline" id="line-472"><code>		fn(flag)</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code>}</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>// Visit visits the command-line flags in lexicographical order, calling fn</code></span>
<span class="codeline" id="line-477"><code>// for each. It visits only those flags that have been set.</code></span>
<span class="codeline" id="line-478"><code>func Visit(fn func(*Flag)) {</code></span>
<span class="codeline" id="line-479"><code>	CommandLine.Visit(fn)</code></span>
<span class="codeline" id="line-480"><code>}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>// Lookup returns the [Flag] structure of the named flag, returning nil if none exists.</code></span>
<span class="codeline" id="line-483"><code>func (f *FlagSet) Lookup(name string) *Flag {</code></span>
<span class="codeline" id="line-484"><code>	return f.formal[name]</code></span>
<span class="codeline" id="line-485"><code>}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>// Lookup returns the [Flag] structure of the named command-line flag,</code></span>
<span class="codeline" id="line-488"><code>// returning nil if none exists.</code></span>
<span class="codeline" id="line-489"><code>func Lookup(name string) *Flag {</code></span>
<span class="codeline" id="line-490"><code>	return CommandLine.formal[name]</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>// Set sets the value of the named flag.</code></span>
<span class="codeline" id="line-494"><code>func (f *FlagSet) Set(name, value string) error {</code></span>
<span class="codeline" id="line-495"><code>	return f.set(name, value)</code></span>
<span class="codeline" id="line-496"><code>}</code></span>
<span class="codeline" id="line-497"><code>func (f *FlagSet) set(name, value string) error {</code></span>
<span class="codeline" id="line-498"><code>	flag, ok := f.formal[name]</code></span>
<span class="codeline" id="line-499"><code>	if !ok {</code></span>
<span class="codeline" id="line-500"><code>		// Remember that a flag that isn't defined is being set.</code></span>
<span class="codeline" id="line-501"><code>		// We return an error in this case, but in addition if</code></span>
<span class="codeline" id="line-502"><code>		// subsequently that flag is defined, we want to panic</code></span>
<span class="codeline" id="line-503"><code>		// at the definition point.</code></span>
<span class="codeline" id="line-504"><code>		// This is a problem which occurs if both the definition</code></span>
<span class="codeline" id="line-505"><code>		// and the Set call are in init code and for whatever</code></span>
<span class="codeline" id="line-506"><code>		// reason the init code changes evaluation order.</code></span>
<span class="codeline" id="line-507"><code>		// See issue 57411.</code></span>
<span class="codeline" id="line-508"><code>		_, file, line, ok := runtime.Caller(2)</code></span>
<span class="codeline" id="line-509"><code>		if !ok {</code></span>
<span class="codeline" id="line-510"><code>			file = "?"</code></span>
<span class="codeline" id="line-511"><code>			line = 0</code></span>
<span class="codeline" id="line-512"><code>		}</code></span>
<span class="codeline" id="line-513"><code>		if f.undef == nil {</code></span>
<span class="codeline" id="line-514"><code>			f.undef = map[string]string{}</code></span>
<span class="codeline" id="line-515"><code>		}</code></span>
<span class="codeline" id="line-516"><code>		f.undef[name] = fmt.Sprintf("%s:%d", file, line)</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>		return fmt.Errorf("no such flag -%v", name)</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code>	err := flag.Value.Set(value)</code></span>
<span class="codeline" id="line-521"><code>	if err != nil {</code></span>
<span class="codeline" id="line-522"><code>		return err</code></span>
<span class="codeline" id="line-523"><code>	}</code></span>
<span class="codeline" id="line-524"><code>	if f.actual == nil {</code></span>
<span class="codeline" id="line-525"><code>		f.actual = make(map[string]*Flag)</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code>	f.actual[name] = flag</code></span>
<span class="codeline" id="line-528"><code>	return nil</code></span>
<span class="codeline" id="line-529"><code>}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>// Set sets the value of the named command-line flag.</code></span>
<span class="codeline" id="line-532"><code>func Set(name, value string) error {</code></span>
<span class="codeline" id="line-533"><code>	return CommandLine.set(name, value)</code></span>
<span class="codeline" id="line-534"><code>}</code></span>
<span class="codeline" id="line-535"><code></code></span>
<span class="codeline" id="line-536"><code>// isZeroValue determines whether the string represents the zero</code></span>
<span class="codeline" id="line-537"><code>// value for a flag.</code></span>
<span class="codeline" id="line-538"><code>func isZeroValue(flag *Flag, value string) (ok bool, err error) {</code></span>
<span class="codeline" id="line-539"><code>	// Build a zero value of the flag's Value type, and see if the</code></span>
<span class="codeline" id="line-540"><code>	// result of calling its String method equals the value passed in.</code></span>
<span class="codeline" id="line-541"><code>	// This works unless the Value type is itself an interface type.</code></span>
<span class="codeline" id="line-542"><code>	typ := reflect.TypeOf(flag.Value)</code></span>
<span class="codeline" id="line-543"><code>	var z reflect.Value</code></span>
<span class="codeline" id="line-544"><code>	if typ.Kind() == reflect.Pointer {</code></span>
<span class="codeline" id="line-545"><code>		z = reflect.New(typ.Elem())</code></span>
<span class="codeline" id="line-546"><code>	} else {</code></span>
<span class="codeline" id="line-547"><code>		z = reflect.Zero(typ)</code></span>
<span class="codeline" id="line-548"><code>	}</code></span>
<span class="codeline" id="line-549"><code>	// Catch panics calling the String method, which shouldn't prevent the</code></span>
<span class="codeline" id="line-550"><code>	// usage message from being printed, but that we should report to the</code></span>
<span class="codeline" id="line-551"><code>	// user so that they know to fix their code.</code></span>
<span class="codeline" id="line-552"><code>	defer func() {</code></span>
<span class="codeline" id="line-553"><code>		if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-554"><code>			if typ.Kind() == reflect.Pointer {</code></span>
<span class="codeline" id="line-555"><code>				typ = typ.Elem()</code></span>
<span class="codeline" id="line-556"><code>			}</code></span>
<span class="codeline" id="line-557"><code>			err = fmt.Errorf("panic calling String method on zero %v for flag %s: %v", typ, flag.Name, e)</code></span>
<span class="codeline" id="line-558"><code>		}</code></span>
<span class="codeline" id="line-559"><code>	}()</code></span>
<span class="codeline" id="line-560"><code>	return value == z.Interface().(Value).String(), nil</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>// UnquoteUsage extracts a back-quoted name from the usage</code></span>
<span class="codeline" id="line-564"><code>// string for a flag and returns it and the un-quoted usage.</code></span>
<span class="codeline" id="line-565"><code>// Given "a `name` to show" it returns ("name", "a name to show").</code></span>
<span class="codeline" id="line-566"><code>// If there are no back quotes, the name is an educated guess of the</code></span>
<span class="codeline" id="line-567"><code>// type of the flag's value, or the empty string if the flag is boolean.</code></span>
<span class="codeline" id="line-568"><code>func UnquoteUsage(flag *Flag) (name string, usage string) {</code></span>
<span class="codeline" id="line-569"><code>	// Look for a back-quoted name, but avoid the strings package.</code></span>
<span class="codeline" id="line-570"><code>	usage = flag.Usage</code></span>
<span class="codeline" id="line-571"><code>	for i := 0; i &lt; len(usage); i++ {</code></span>
<span class="codeline" id="line-572"><code>		if usage[i] == '`' {</code></span>
<span class="codeline" id="line-573"><code>			for j := i + 1; j &lt; len(usage); j++ {</code></span>
<span class="codeline" id="line-574"><code>				if usage[j] == '`' {</code></span>
<span class="codeline" id="line-575"><code>					name = usage[i+1 : j]</code></span>
<span class="codeline" id="line-576"><code>					usage = usage[:i] + name + usage[j+1:]</code></span>
<span class="codeline" id="line-577"><code>					return name, usage</code></span>
<span class="codeline" id="line-578"><code>				}</code></span>
<span class="codeline" id="line-579"><code>			}</code></span>
<span class="codeline" id="line-580"><code>			break // Only one back quote; use type name.</code></span>
<span class="codeline" id="line-581"><code>		}</code></span>
<span class="codeline" id="line-582"><code>	}</code></span>
<span class="codeline" id="line-583"><code>	// No explicit name, so use type if we can find one.</code></span>
<span class="codeline" id="line-584"><code>	name = "value"</code></span>
<span class="codeline" id="line-585"><code>	switch fv := flag.Value.(type) {</code></span>
<span class="codeline" id="line-586"><code>	case boolFlag:</code></span>
<span class="codeline" id="line-587"><code>		if fv.IsBoolFlag() {</code></span>
<span class="codeline" id="line-588"><code>			name = ""</code></span>
<span class="codeline" id="line-589"><code>		}</code></span>
<span class="codeline" id="line-590"><code>	case *durationValue:</code></span>
<span class="codeline" id="line-591"><code>		name = "duration"</code></span>
<span class="codeline" id="line-592"><code>	case *float64Value:</code></span>
<span class="codeline" id="line-593"><code>		name = "float"</code></span>
<span class="codeline" id="line-594"><code>	case *intValue, *int64Value:</code></span>
<span class="codeline" id="line-595"><code>		name = "int"</code></span>
<span class="codeline" id="line-596"><code>	case *stringValue:</code></span>
<span class="codeline" id="line-597"><code>		name = "string"</code></span>
<span class="codeline" id="line-598"><code>	case *uintValue, *uint64Value:</code></span>
<span class="codeline" id="line-599"><code>		name = "uint"</code></span>
<span class="codeline" id="line-600"><code>	}</code></span>
<span class="codeline" id="line-601"><code>	return</code></span>
<span class="codeline" id="line-602"><code>}</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>// PrintDefaults prints, to standard error unless configured otherwise, the</code></span>
<span class="codeline" id="line-605"><code>// default values of all defined command-line flags in the set. See the</code></span>
<span class="codeline" id="line-606"><code>// documentation for the global function PrintDefaults for more information.</code></span>
<span class="codeline" id="line-607"><code>func (f *FlagSet) PrintDefaults() {</code></span>
<span class="codeline" id="line-608"><code>	var isZeroValueErrs []error</code></span>
<span class="codeline" id="line-609"><code>	f.VisitAll(func(flag *Flag) {</code></span>
<span class="codeline" id="line-610"><code>		var b strings.Builder</code></span>
<span class="codeline" id="line-611"><code>		fmt.Fprintf(&amp;b, "  -%s", flag.Name) // Two spaces before -; see next two comments.</code></span>
<span class="codeline" id="line-612"><code>		name, usage := UnquoteUsage(flag)</code></span>
<span class="codeline" id="line-613"><code>		if len(name) &gt; 0 {</code></span>
<span class="codeline" id="line-614"><code>			b.WriteString(" ")</code></span>
<span class="codeline" id="line-615"><code>			b.WriteString(name)</code></span>
<span class="codeline" id="line-616"><code>		}</code></span>
<span class="codeline" id="line-617"><code>		// Boolean flags of one ASCII letter are so common we</code></span>
<span class="codeline" id="line-618"><code>		// treat them specially, putting their usage on the same line.</code></span>
<span class="codeline" id="line-619"><code>		if b.Len() &lt;= 4 { // space, space, '-', 'x'.</code></span>
<span class="codeline" id="line-620"><code>			b.WriteString("\t")</code></span>
<span class="codeline" id="line-621"><code>		} else {</code></span>
<span class="codeline" id="line-622"><code>			// Four spaces before the tab triggers good alignment</code></span>
<span class="codeline" id="line-623"><code>			// for both 4- and 8-space tab stops.</code></span>
<span class="codeline" id="line-624"><code>			b.WriteString("\n    \t")</code></span>
<span class="codeline" id="line-625"><code>		}</code></span>
<span class="codeline" id="line-626"><code>		b.WriteString(strings.ReplaceAll(usage, "\n", "\n    \t"))</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>		// Print the default value only if it differs to the zero value</code></span>
<span class="codeline" id="line-629"><code>		// for this flag type.</code></span>
<span class="codeline" id="line-630"><code>		if isZero, err := isZeroValue(flag, flag.DefValue); err != nil {</code></span>
<span class="codeline" id="line-631"><code>			isZeroValueErrs = append(isZeroValueErrs, err)</code></span>
<span class="codeline" id="line-632"><code>		} else if !isZero {</code></span>
<span class="codeline" id="line-633"><code>			if _, ok := flag.Value.(*stringValue); ok {</code></span>
<span class="codeline" id="line-634"><code>				// put quotes on the value</code></span>
<span class="codeline" id="line-635"><code>				fmt.Fprintf(&amp;b, " (default %q)", flag.DefValue)</code></span>
<span class="codeline" id="line-636"><code>			} else {</code></span>
<span class="codeline" id="line-637"><code>				fmt.Fprintf(&amp;b, " (default %v)", flag.DefValue)</code></span>
<span class="codeline" id="line-638"><code>			}</code></span>
<span class="codeline" id="line-639"><code>		}</code></span>
<span class="codeline" id="line-640"><code>		fmt.Fprint(f.Output(), b.String(), "\n")</code></span>
<span class="codeline" id="line-641"><code>	})</code></span>
<span class="codeline" id="line-642"><code>	// If calling String on any zero flag.Values triggered a panic, print</code></span>
<span class="codeline" id="line-643"><code>	// the messages after the full set of defaults so that the programmer</code></span>
<span class="codeline" id="line-644"><code>	// knows to fix the panic.</code></span>
<span class="codeline" id="line-645"><code>	if errs := isZeroValueErrs; len(errs) &gt; 0 {</code></span>
<span class="codeline" id="line-646"><code>		fmt.Fprintln(f.Output())</code></span>
<span class="codeline" id="line-647"><code>		for _, err := range errs {</code></span>
<span class="codeline" id="line-648"><code>			fmt.Fprintln(f.Output(), err)</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>// PrintDefaults prints, to standard error unless configured otherwise,</code></span>
<span class="codeline" id="line-654"><code>// a usage message showing the default settings of all defined</code></span>
<span class="codeline" id="line-655"><code>// command-line flags.</code></span>
<span class="codeline" id="line-656"><code>// For an integer valued flag x, the default output has the form</code></span>
<span class="codeline" id="line-657"><code>//</code></span>
<span class="codeline" id="line-658"><code>//	-x int</code></span>
<span class="codeline" id="line-659"><code>//		usage-message-for-x (default 7)</code></span>
<span class="codeline" id="line-660"><code>//</code></span>
<span class="codeline" id="line-661"><code>// The usage message will appear on a separate line for anything but</code></span>
<span class="codeline" id="line-662"><code>// a bool flag with a one-byte name. For bool flags, the type is</code></span>
<span class="codeline" id="line-663"><code>// omitted and if the flag name is one byte the usage message appears</code></span>
<span class="codeline" id="line-664"><code>// on the same line. The parenthetical default is omitted if the</code></span>
<span class="codeline" id="line-665"><code>// default is the zero value for the type. The listed type, here int,</code></span>
<span class="codeline" id="line-666"><code>// can be changed by placing a back-quoted name in the flag's usage</code></span>
<span class="codeline" id="line-667"><code>// string; the first such item in the message is taken to be a parameter</code></span>
<span class="codeline" id="line-668"><code>// name to show in the message and the back quotes are stripped from</code></span>
<span class="codeline" id="line-669"><code>// the message when displayed. For instance, given</code></span>
<span class="codeline" id="line-670"><code>//</code></span>
<span class="codeline" id="line-671"><code>//	flag.String("I", "", "search `directory` for include files")</code></span>
<span class="codeline" id="line-672"><code>//</code></span>
<span class="codeline" id="line-673"><code>// the output will be</code></span>
<span class="codeline" id="line-674"><code>//</code></span>
<span class="codeline" id="line-675"><code>//	-I directory</code></span>
<span class="codeline" id="line-676"><code>//		search directory for include files.</code></span>
<span class="codeline" id="line-677"><code>//</code></span>
<span class="codeline" id="line-678"><code>// To change the destination for flag messages, call [CommandLine].SetOutput.</code></span>
<span class="codeline" id="line-679"><code>func PrintDefaults() {</code></span>
<span class="codeline" id="line-680"><code>	CommandLine.PrintDefaults()</code></span>
<span class="codeline" id="line-681"><code>}</code></span>
<span class="codeline" id="line-682"><code></code></span>
<span class="codeline" id="line-683"><code>// defaultUsage is the default function to print a usage message.</code></span>
<span class="codeline" id="line-684"><code>func (f *FlagSet) defaultUsage() {</code></span>
<span class="codeline" id="line-685"><code>	if f.name == "" {</code></span>
<span class="codeline" id="line-686"><code>		fmt.Fprintf(f.Output(), "Usage:\n")</code></span>
<span class="codeline" id="line-687"><code>	} else {</code></span>
<span class="codeline" id="line-688"><code>		fmt.Fprintf(f.Output(), "Usage of %s:\n", f.name)</code></span>
<span class="codeline" id="line-689"><code>	}</code></span>
<span class="codeline" id="line-690"><code>	f.PrintDefaults()</code></span>
<span class="codeline" id="line-691"><code>}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>// NOTE: Usage is not just defaultUsage(CommandLine)</code></span>
<span class="codeline" id="line-694"><code>// because it serves (via godoc flag Usage) as the example</code></span>
<span class="codeline" id="line-695"><code>// for how to write your own usage function.</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>// Usage prints a usage message documenting all defined command-line flags</code></span>
<span class="codeline" id="line-698"><code>// to [CommandLine]'s output, which by default is [os.Stderr].</code></span>
<span class="codeline" id="line-699"><code>// It is called when an error occurs while parsing flags.</code></span>
<span class="codeline" id="line-700"><code>// The function is a variable that may be changed to point to a custom function.</code></span>
<span class="codeline" id="line-701"><code>// By default it prints a simple header and calls [PrintDefaults]; for details about the</code></span>
<span class="codeline" id="line-702"><code>// format of the output and how to control it, see the documentation for [PrintDefaults].</code></span>
<span class="codeline" id="line-703"><code>// Custom usage functions may choose to exit the program; by default exiting</code></span>
<span class="codeline" id="line-704"><code>// happens anyway as the command line's error handling strategy is set to</code></span>
<span class="codeline" id="line-705"><code>// [ExitOnError].</code></span>
<span class="codeline" id="line-706"><code>var Usage = func() {</code></span>
<span class="codeline" id="line-707"><code>	fmt.Fprintf(CommandLine.Output(), "Usage of %s:\n", os.Args[0])</code></span>
<span class="codeline" id="line-708"><code>	PrintDefaults()</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>// NFlag returns the number of flags that have been set.</code></span>
<span class="codeline" id="line-712"><code>func (f *FlagSet) NFlag() int { return len(f.actual) }</code></span>
<span class="codeline" id="line-713"><code></code></span>
<span class="codeline" id="line-714"><code>// NFlag returns the number of command-line flags that have been set.</code></span>
<span class="codeline" id="line-715"><code>func NFlag() int { return len(CommandLine.actual) }</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>// Arg returns the i'th argument. Arg(0) is the first remaining argument</code></span>
<span class="codeline" id="line-718"><code>// after flags have been processed. Arg returns an empty string if the</code></span>
<span class="codeline" id="line-719"><code>// requested element does not exist.</code></span>
<span class="codeline" id="line-720"><code>func (f *FlagSet) Arg(i int) string {</code></span>
<span class="codeline" id="line-721"><code>	if i &lt; 0 || i &gt;= len(f.args) {</code></span>
<span class="codeline" id="line-722"><code>		return ""</code></span>
<span class="codeline" id="line-723"><code>	}</code></span>
<span class="codeline" id="line-724"><code>	return f.args[i]</code></span>
<span class="codeline" id="line-725"><code>}</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>// Arg returns the i'th command-line argument. Arg(0) is the first remaining argument</code></span>
<span class="codeline" id="line-728"><code>// after flags have been processed. Arg returns an empty string if the</code></span>
<span class="codeline" id="line-729"><code>// requested element does not exist.</code></span>
<span class="codeline" id="line-730"><code>func Arg(i int) string {</code></span>
<span class="codeline" id="line-731"><code>	return CommandLine.Arg(i)</code></span>
<span class="codeline" id="line-732"><code>}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>// NArg is the number of arguments remaining after flags have been processed.</code></span>
<span class="codeline" id="line-735"><code>func (f *FlagSet) NArg() int { return len(f.args) }</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>// NArg is the number of arguments remaining after flags have been processed.</code></span>
<span class="codeline" id="line-738"><code>func NArg() int { return len(CommandLine.args) }</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>// Args returns the non-flag arguments.</code></span>
<span class="codeline" id="line-741"><code>func (f *FlagSet) Args() []string { return f.args }</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>// Args returns the non-flag command-line arguments.</code></span>
<span class="codeline" id="line-744"><code>func Args() []string { return CommandLine.args }</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>// BoolVar defines a bool flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-747"><code>// The argument p points to a bool variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-748"><code>func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string) {</code></span>
<span class="codeline" id="line-749"><code>	f.Var(newBoolValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>// BoolVar defines a bool flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-753"><code>// The argument p points to a bool variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-754"><code>func BoolVar(p *bool, name string, value bool, usage string) {</code></span>
<span class="codeline" id="line-755"><code>	CommandLine.Var(newBoolValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-756"><code>}</code></span>
<span class="codeline" id="line-757"><code></code></span>
<span class="codeline" id="line-758"><code>// Bool defines a bool flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-759"><code>// The return value is the address of a bool variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-760"><code>func (f *FlagSet) Bool(name string, value bool, usage string) *bool {</code></span>
<span class="codeline" id="line-761"><code>	p := new(bool)</code></span>
<span class="codeline" id="line-762"><code>	f.BoolVar(p, name, value, usage)</code></span>
<span class="codeline" id="line-763"><code>	return p</code></span>
<span class="codeline" id="line-764"><code>}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>// Bool defines a bool flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-767"><code>// The return value is the address of a bool variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-768"><code>func Bool(name string, value bool, usage string) *bool {</code></span>
<span class="codeline" id="line-769"><code>	return CommandLine.Bool(name, value, usage)</code></span>
<span class="codeline" id="line-770"><code>}</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>// IntVar defines an int flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-773"><code>// The argument p points to an int variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-774"><code>func (f *FlagSet) IntVar(p *int, name string, value int, usage string) {</code></span>
<span class="codeline" id="line-775"><code>	f.Var(newIntValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-776"><code>}</code></span>
<span class="codeline" id="line-777"><code></code></span>
<span class="codeline" id="line-778"><code>// IntVar defines an int flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-779"><code>// The argument p points to an int variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-780"><code>func IntVar(p *int, name string, value int, usage string) {</code></span>
<span class="codeline" id="line-781"><code>	CommandLine.Var(newIntValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-782"><code>}</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>// Int defines an int flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-785"><code>// The return value is the address of an int variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-786"><code>func (f *FlagSet) Int(name string, value int, usage string) *int {</code></span>
<span class="codeline" id="line-787"><code>	p := new(int)</code></span>
<span class="codeline" id="line-788"><code>	f.IntVar(p, name, value, usage)</code></span>
<span class="codeline" id="line-789"><code>	return p</code></span>
<span class="codeline" id="line-790"><code>}</code></span>
<span class="codeline" id="line-791"><code></code></span>
<span class="codeline" id="line-792"><code>// Int defines an int flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-793"><code>// The return value is the address of an int variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-794"><code>func Int(name string, value int, usage string) *int {</code></span>
<span class="codeline" id="line-795"><code>	return CommandLine.Int(name, value, usage)</code></span>
<span class="codeline" id="line-796"><code>}</code></span>
<span class="codeline" id="line-797"><code></code></span>
<span class="codeline" id="line-798"><code>// Int64Var defines an int64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-799"><code>// The argument p points to an int64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-800"><code>func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string) {</code></span>
<span class="codeline" id="line-801"><code>	f.Var(newInt64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-802"><code>}</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>// Int64Var defines an int64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-805"><code>// The argument p points to an int64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-806"><code>func Int64Var(p *int64, name string, value int64, usage string) {</code></span>
<span class="codeline" id="line-807"><code>	CommandLine.Var(newInt64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-808"><code>}</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>// Int64 defines an int64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-811"><code>// The return value is the address of an int64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-812"><code>func (f *FlagSet) Int64(name string, value int64, usage string) *int64 {</code></span>
<span class="codeline" id="line-813"><code>	p := new(int64)</code></span>
<span class="codeline" id="line-814"><code>	f.Int64Var(p, name, value, usage)</code></span>
<span class="codeline" id="line-815"><code>	return p</code></span>
<span class="codeline" id="line-816"><code>}</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>// Int64 defines an int64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-819"><code>// The return value is the address of an int64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-820"><code>func Int64(name string, value int64, usage string) *int64 {</code></span>
<span class="codeline" id="line-821"><code>	return CommandLine.Int64(name, value, usage)</code></span>
<span class="codeline" id="line-822"><code>}</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>// UintVar defines a uint flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-825"><code>// The argument p points to a uint variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-826"><code>func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string) {</code></span>
<span class="codeline" id="line-827"><code>	f.Var(newUintValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-828"><code>}</code></span>
<span class="codeline" id="line-829"><code></code></span>
<span class="codeline" id="line-830"><code>// UintVar defines a uint flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-831"><code>// The argument p points to a uint variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-832"><code>func UintVar(p *uint, name string, value uint, usage string) {</code></span>
<span class="codeline" id="line-833"><code>	CommandLine.Var(newUintValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-834"><code>}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>// Uint defines a uint flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-837"><code>// The return value is the address of a uint variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-838"><code>func (f *FlagSet) Uint(name string, value uint, usage string) *uint {</code></span>
<span class="codeline" id="line-839"><code>	p := new(uint)</code></span>
<span class="codeline" id="line-840"><code>	f.UintVar(p, name, value, usage)</code></span>
<span class="codeline" id="line-841"><code>	return p</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>// Uint defines a uint flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-845"><code>// The return value is the address of a uint variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-846"><code>func Uint(name string, value uint, usage string) *uint {</code></span>
<span class="codeline" id="line-847"><code>	return CommandLine.Uint(name, value, usage)</code></span>
<span class="codeline" id="line-848"><code>}</code></span>
<span class="codeline" id="line-849"><code></code></span>
<span class="codeline" id="line-850"><code>// Uint64Var defines a uint64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-851"><code>// The argument p points to a uint64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-852"><code>func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string) {</code></span>
<span class="codeline" id="line-853"><code>	f.Var(newUint64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-854"><code>}</code></span>
<span class="codeline" id="line-855"><code></code></span>
<span class="codeline" id="line-856"><code>// Uint64Var defines a uint64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-857"><code>// The argument p points to a uint64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-858"><code>func Uint64Var(p *uint64, name string, value uint64, usage string) {</code></span>
<span class="codeline" id="line-859"><code>	CommandLine.Var(newUint64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-860"><code>}</code></span>
<span class="codeline" id="line-861"><code></code></span>
<span class="codeline" id="line-862"><code>// Uint64 defines a uint64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-863"><code>// The return value is the address of a uint64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-864"><code>func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64 {</code></span>
<span class="codeline" id="line-865"><code>	p := new(uint64)</code></span>
<span class="codeline" id="line-866"><code>	f.Uint64Var(p, name, value, usage)</code></span>
<span class="codeline" id="line-867"><code>	return p</code></span>
<span class="codeline" id="line-868"><code>}</code></span>
<span class="codeline" id="line-869"><code></code></span>
<span class="codeline" id="line-870"><code>// Uint64 defines a uint64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-871"><code>// The return value is the address of a uint64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-872"><code>func Uint64(name string, value uint64, usage string) *uint64 {</code></span>
<span class="codeline" id="line-873"><code>	return CommandLine.Uint64(name, value, usage)</code></span>
<span class="codeline" id="line-874"><code>}</code></span>
<span class="codeline" id="line-875"><code></code></span>
<span class="codeline" id="line-876"><code>// StringVar defines a string flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-877"><code>// The argument p points to a string variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-878"><code>func (f *FlagSet) StringVar(p *string, name string, value string, usage string) {</code></span>
<span class="codeline" id="line-879"><code>	f.Var(newStringValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>// StringVar defines a string flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-883"><code>// The argument p points to a string variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-884"><code>func StringVar(p *string, name string, value string, usage string) {</code></span>
<span class="codeline" id="line-885"><code>	CommandLine.Var(newStringValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-886"><code>}</code></span>
<span class="codeline" id="line-887"><code></code></span>
<span class="codeline" id="line-888"><code>// String defines a string flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-889"><code>// The return value is the address of a string variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-890"><code>func (f *FlagSet) String(name string, value string, usage string) *string {</code></span>
<span class="codeline" id="line-891"><code>	p := new(string)</code></span>
<span class="codeline" id="line-892"><code>	f.StringVar(p, name, value, usage)</code></span>
<span class="codeline" id="line-893"><code>	return p</code></span>
<span class="codeline" id="line-894"><code>}</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>// String defines a string flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-897"><code>// The return value is the address of a string variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-898"><code>func String(name string, value string, usage string) *string {</code></span>
<span class="codeline" id="line-899"><code>	return CommandLine.String(name, value, usage)</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// Float64Var defines a float64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-903"><code>// The argument p points to a float64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-904"><code>func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string) {</code></span>
<span class="codeline" id="line-905"><code>	f.Var(newFloat64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-906"><code>}</code></span>
<span class="codeline" id="line-907"><code></code></span>
<span class="codeline" id="line-908"><code>// Float64Var defines a float64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-909"><code>// The argument p points to a float64 variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-910"><code>func Float64Var(p *float64, name string, value float64, usage string) {</code></span>
<span class="codeline" id="line-911"><code>	CommandLine.Var(newFloat64Value(value, p), name, usage)</code></span>
<span class="codeline" id="line-912"><code>}</code></span>
<span class="codeline" id="line-913"><code></code></span>
<span class="codeline" id="line-914"><code>// Float64 defines a float64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-915"><code>// The return value is the address of a float64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-916"><code>func (f *FlagSet) Float64(name string, value float64, usage string) *float64 {</code></span>
<span class="codeline" id="line-917"><code>	p := new(float64)</code></span>
<span class="codeline" id="line-918"><code>	f.Float64Var(p, name, value, usage)</code></span>
<span class="codeline" id="line-919"><code>	return p</code></span>
<span class="codeline" id="line-920"><code>}</code></span>
<span class="codeline" id="line-921"><code></code></span>
<span class="codeline" id="line-922"><code>// Float64 defines a float64 flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-923"><code>// The return value is the address of a float64 variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-924"><code>func Float64(name string, value float64, usage string) *float64 {</code></span>
<span class="codeline" id="line-925"><code>	return CommandLine.Float64(name, value, usage)</code></span>
<span class="codeline" id="line-926"><code>}</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>// DurationVar defines a time.Duration flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-929"><code>// The argument p points to a time.Duration variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-930"><code>// The flag accepts a value acceptable to time.ParseDuration.</code></span>
<span class="codeline" id="line-931"><code>func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string) {</code></span>
<span class="codeline" id="line-932"><code>	f.Var(newDurationValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-933"><code>}</code></span>
<span class="codeline" id="line-934"><code></code></span>
<span class="codeline" id="line-935"><code>// DurationVar defines a time.Duration flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-936"><code>// The argument p points to a time.Duration variable in which to store the value of the flag.</code></span>
<span class="codeline" id="line-937"><code>// The flag accepts a value acceptable to time.ParseDuration.</code></span>
<span class="codeline" id="line-938"><code>func DurationVar(p *time.Duration, name string, value time.Duration, usage string) {</code></span>
<span class="codeline" id="line-939"><code>	CommandLine.Var(newDurationValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-940"><code>}</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>// Duration defines a time.Duration flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-943"><code>// The return value is the address of a time.Duration variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-944"><code>// The flag accepts a value acceptable to time.ParseDuration.</code></span>
<span class="codeline" id="line-945"><code>func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration {</code></span>
<span class="codeline" id="line-946"><code>	p := new(time.Duration)</code></span>
<span class="codeline" id="line-947"><code>	f.DurationVar(p, name, value, usage)</code></span>
<span class="codeline" id="line-948"><code>	return p</code></span>
<span class="codeline" id="line-949"><code>}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>// Duration defines a time.Duration flag with specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-952"><code>// The return value is the address of a time.Duration variable that stores the value of the flag.</code></span>
<span class="codeline" id="line-953"><code>// The flag accepts a value acceptable to time.ParseDuration.</code></span>
<span class="codeline" id="line-954"><code>func Duration(name string, value time.Duration, usage string) *time.Duration {</code></span>
<span class="codeline" id="line-955"><code>	return CommandLine.Duration(name, value, usage)</code></span>
<span class="codeline" id="line-956"><code>}</code></span>
<span class="codeline" id="line-957"><code></code></span>
<span class="codeline" id="line-958"><code>// TextVar defines a flag with a specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-959"><code>// The argument p must be a pointer to a variable that will hold the value</code></span>
<span class="codeline" id="line-960"><code>// of the flag, and p must implement encoding.TextUnmarshaler.</code></span>
<span class="codeline" id="line-961"><code>// If the flag is used, the flag value will be passed to p's UnmarshalText method.</code></span>
<span class="codeline" id="line-962"><code>// The type of the default value must be the same as the type of p.</code></span>
<span class="codeline" id="line-963"><code>func (f *FlagSet) TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string) {</code></span>
<span class="codeline" id="line-964"><code>	f.Var(newTextValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-965"><code>}</code></span>
<span class="codeline" id="line-966"><code></code></span>
<span class="codeline" id="line-967"><code>// TextVar defines a flag with a specified name, default value, and usage string.</code></span>
<span class="codeline" id="line-968"><code>// The argument p must be a pointer to a variable that will hold the value</code></span>
<span class="codeline" id="line-969"><code>// of the flag, and p must implement encoding.TextUnmarshaler.</code></span>
<span class="codeline" id="line-970"><code>// If the flag is used, the flag value will be passed to p's UnmarshalText method.</code></span>
<span class="codeline" id="line-971"><code>// The type of the default value must be the same as the type of p.</code></span>
<span class="codeline" id="line-972"><code>func TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string) {</code></span>
<span class="codeline" id="line-973"><code>	CommandLine.Var(newTextValue(value, p), name, usage)</code></span>
<span class="codeline" id="line-974"><code>}</code></span>
<span class="codeline" id="line-975"><code></code></span>
<span class="codeline" id="line-976"><code>// Func defines a flag with the specified name and usage string.</code></span>
<span class="codeline" id="line-977"><code>// Each time the flag is seen, fn is called with the value of the flag.</code></span>
<span class="codeline" id="line-978"><code>// If fn returns a non-nil error, it will be treated as a flag value parsing error.</code></span>
<span class="codeline" id="line-979"><code>func (f *FlagSet) Func(name, usage string, fn func(string) error) {</code></span>
<span class="codeline" id="line-980"><code>	f.Var(funcValue(fn), name, usage)</code></span>
<span class="codeline" id="line-981"><code>}</code></span>
<span class="codeline" id="line-982"><code></code></span>
<span class="codeline" id="line-983"><code>// Func defines a flag with the specified name and usage string.</code></span>
<span class="codeline" id="line-984"><code>// Each time the flag is seen, fn is called with the value of the flag.</code></span>
<span class="codeline" id="line-985"><code>// If fn returns a non-nil error, it will be treated as a flag value parsing error.</code></span>
<span class="codeline" id="line-986"><code>func Func(name, usage string, fn func(string) error) {</code></span>
<span class="codeline" id="line-987"><code>	CommandLine.Func(name, usage, fn)</code></span>
<span class="codeline" id="line-988"><code>}</code></span>
<span class="codeline" id="line-989"><code></code></span>
<span class="codeline" id="line-990"><code>// BoolFunc defines a flag with the specified name and usage string without requiring values.</code></span>
<span class="codeline" id="line-991"><code>// Each time the flag is seen, fn is called with the value of the flag.</code></span>
<span class="codeline" id="line-992"><code>// If fn returns a non-nil error, it will be treated as a flag value parsing error.</code></span>
<span class="codeline" id="line-993"><code>func (f *FlagSet) BoolFunc(name, usage string, fn func(string) error) {</code></span>
<span class="codeline" id="line-994"><code>	f.Var(boolFuncValue(fn), name, usage)</code></span>
<span class="codeline" id="line-995"><code>}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>// BoolFunc defines a flag with the specified name and usage string without requiring values.</code></span>
<span class="codeline" id="line-998"><code>// Each time the flag is seen, fn is called with the value of the flag.</code></span>
<span class="codeline" id="line-999"><code>// If fn returns a non-nil error, it will be treated as a flag value parsing error.</code></span>
<span class="codeline" id="line-1000"><code>func BoolFunc(name, usage string, fn func(string) error) {</code></span>
<span class="codeline" id="line-1001"><code>	CommandLine.BoolFunc(name, usage, fn)</code></span>
<span class="codeline" id="line-1002"><code>}</code></span>
<span class="codeline" id="line-1003"><code></code></span>
<span class="codeline" id="line-1004"><code>// Var defines a flag with the specified name and usage string. The type and</code></span>
<span class="codeline" id="line-1005"><code>// value of the flag are represented by the first argument, of type [Value], which</code></span>
<span class="codeline" id="line-1006"><code>// typically holds a user-defined implementation of [Value]. For instance, the</code></span>
<span class="codeline" id="line-1007"><code>// caller could create a flag that turns a comma-separated string into a slice</code></span>
<span class="codeline" id="line-1008"><code>// of strings by giving the slice the methods of [Value]; in particular, [Set] would</code></span>
<span class="codeline" id="line-1009"><code>// decompose the comma-separated string into the slice.</code></span>
<span class="codeline" id="line-1010"><code>func (f *FlagSet) Var(value Value, name string, usage string) {</code></span>
<span class="codeline" id="line-1011"><code>	// Flag must not begin "-" or contain "=".</code></span>
<span class="codeline" id="line-1012"><code>	if strings.HasPrefix(name, "-") {</code></span>
<span class="codeline" id="line-1013"><code>		panic(f.sprintf("flag %q begins with -", name))</code></span>
<span class="codeline" id="line-1014"><code>	} else if strings.Contains(name, "=") {</code></span>
<span class="codeline" id="line-1015"><code>		panic(f.sprintf("flag %q contains =", name))</code></span>
<span class="codeline" id="line-1016"><code>	}</code></span>
<span class="codeline" id="line-1017"><code></code></span>
<span class="codeline" id="line-1018"><code>	// Remember the default value as a string; it won't change.</code></span>
<span class="codeline" id="line-1019"><code>	flag := &amp;Flag{name, usage, value, value.String()}</code></span>
<span class="codeline" id="line-1020"><code>	_, alreadythere := f.formal[name]</code></span>
<span class="codeline" id="line-1021"><code>	if alreadythere {</code></span>
<span class="codeline" id="line-1022"><code>		var msg string</code></span>
<span class="codeline" id="line-1023"><code>		if f.name == "" {</code></span>
<span class="codeline" id="line-1024"><code>			msg = f.sprintf("flag redefined: %s", name)</code></span>
<span class="codeline" id="line-1025"><code>		} else {</code></span>
<span class="codeline" id="line-1026"><code>			msg = f.sprintf("%s flag redefined: %s", f.name, name)</code></span>
<span class="codeline" id="line-1027"><code>		}</code></span>
<span class="codeline" id="line-1028"><code>		panic(msg) // Happens only if flags are declared with identical names</code></span>
<span class="codeline" id="line-1029"><code>	}</code></span>
<span class="codeline" id="line-1030"><code>	if pos := f.undef[name]; pos != "" {</code></span>
<span class="codeline" id="line-1031"><code>		panic(fmt.Sprintf("flag %s set at %s before being defined", name, pos))</code></span>
<span class="codeline" id="line-1032"><code>	}</code></span>
<span class="codeline" id="line-1033"><code>	if f.formal == nil {</code></span>
<span class="codeline" id="line-1034"><code>		f.formal = make(map[string]*Flag)</code></span>
<span class="codeline" id="line-1035"><code>	}</code></span>
<span class="codeline" id="line-1036"><code>	f.formal[name] = flag</code></span>
<span class="codeline" id="line-1037"><code>}</code></span>
<span class="codeline" id="line-1038"><code></code></span>
<span class="codeline" id="line-1039"><code>// Var defines a flag with the specified name and usage string. The type and</code></span>
<span class="codeline" id="line-1040"><code>// value of the flag are represented by the first argument, of type [Value], which</code></span>
<span class="codeline" id="line-1041"><code>// typically holds a user-defined implementation of [Value]. For instance, the</code></span>
<span class="codeline" id="line-1042"><code>// caller could create a flag that turns a comma-separated string into a slice</code></span>
<span class="codeline" id="line-1043"><code>// of strings by giving the slice the methods of [Value]; in particular, [Set] would</code></span>
<span class="codeline" id="line-1044"><code>// decompose the comma-separated string into the slice.</code></span>
<span class="codeline" id="line-1045"><code>func Var(value Value, name string, usage string) {</code></span>
<span class="codeline" id="line-1046"><code>	CommandLine.Var(value, name, usage)</code></span>
<span class="codeline" id="line-1047"><code>}</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>// sprintf formats the message, prints it to output, and returns it.</code></span>
<span class="codeline" id="line-1050"><code>func (f *FlagSet) sprintf(format string, a ...any) string {</code></span>
<span class="codeline" id="line-1051"><code>	msg := fmt.Sprintf(format, a...)</code></span>
<span class="codeline" id="line-1052"><code>	fmt.Fprintln(f.Output(), msg)</code></span>
<span class="codeline" id="line-1053"><code>	return msg</code></span>
<span class="codeline" id="line-1054"><code>}</code></span>
<span class="codeline" id="line-1055"><code></code></span>
<span class="codeline" id="line-1056"><code>// failf prints to standard error a formatted error and usage message and</code></span>
<span class="codeline" id="line-1057"><code>// returns the error.</code></span>
<span class="codeline" id="line-1058"><code>func (f *FlagSet) failf(format string, a ...any) error {</code></span>
<span class="codeline" id="line-1059"><code>	msg := f.sprintf(format, a...)</code></span>
<span class="codeline" id="line-1060"><code>	f.usage()</code></span>
<span class="codeline" id="line-1061"><code>	return errors.New(msg)</code></span>
<span class="codeline" id="line-1062"><code>}</code></span>
<span class="codeline" id="line-1063"><code></code></span>
<span class="codeline" id="line-1064"><code>// usage calls the Usage method for the flag set if one is specified,</code></span>
<span class="codeline" id="line-1065"><code>// or the appropriate default usage function otherwise.</code></span>
<span class="codeline" id="line-1066"><code>func (f *FlagSet) usage() {</code></span>
<span class="codeline" id="line-1067"><code>	if f.Usage == nil {</code></span>
<span class="codeline" id="line-1068"><code>		f.defaultUsage()</code></span>
<span class="codeline" id="line-1069"><code>	} else {</code></span>
<span class="codeline" id="line-1070"><code>		f.Usage()</code></span>
<span class="codeline" id="line-1071"><code>	}</code></span>
<span class="codeline" id="line-1072"><code>}</code></span>
<span class="codeline" id="line-1073"><code></code></span>
<span class="codeline" id="line-1074"><code>// parseOne parses one flag. It reports whether a flag was seen.</code></span>
<span class="codeline" id="line-1075"><code>func (f *FlagSet) parseOne() (bool, error) {</code></span>
<span class="codeline" id="line-1076"><code>	if len(f.args) == 0 {</code></span>
<span class="codeline" id="line-1077"><code>		return false, nil</code></span>
<span class="codeline" id="line-1078"><code>	}</code></span>
<span class="codeline" id="line-1079"><code>	s := f.args[0]</code></span>
<span class="codeline" id="line-1080"><code>	if len(s) &lt; 2 || s[0] != '-' {</code></span>
<span class="codeline" id="line-1081"><code>		return false, nil</code></span>
<span class="codeline" id="line-1082"><code>	}</code></span>
<span class="codeline" id="line-1083"><code>	numMinuses := 1</code></span>
<span class="codeline" id="line-1084"><code>	if s[1] == '-' {</code></span>
<span class="codeline" id="line-1085"><code>		numMinuses++</code></span>
<span class="codeline" id="line-1086"><code>		if len(s) == 2 { // "--" terminates the flags</code></span>
<span class="codeline" id="line-1087"><code>			f.args = f.args[1:]</code></span>
<span class="codeline" id="line-1088"><code>			return false, nil</code></span>
<span class="codeline" id="line-1089"><code>		}</code></span>
<span class="codeline" id="line-1090"><code>	}</code></span>
<span class="codeline" id="line-1091"><code>	name := s[numMinuses:]</code></span>
<span class="codeline" id="line-1092"><code>	if len(name) == 0 || name[0] == '-' || name[0] == '=' {</code></span>
<span class="codeline" id="line-1093"><code>		return false, f.failf("bad flag syntax: %s", s)</code></span>
<span class="codeline" id="line-1094"><code>	}</code></span>
<span class="codeline" id="line-1095"><code></code></span>
<span class="codeline" id="line-1096"><code>	// it's a flag. does it have an argument?</code></span>
<span class="codeline" id="line-1097"><code>	f.args = f.args[1:]</code></span>
<span class="codeline" id="line-1098"><code>	hasValue := false</code></span>
<span class="codeline" id="line-1099"><code>	value := ""</code></span>
<span class="codeline" id="line-1100"><code>	for i := 1; i &lt; len(name); i++ { // equals cannot be first</code></span>
<span class="codeline" id="line-1101"><code>		if name[i] == '=' {</code></span>
<span class="codeline" id="line-1102"><code>			value = name[i+1:]</code></span>
<span class="codeline" id="line-1103"><code>			hasValue = true</code></span>
<span class="codeline" id="line-1104"><code>			name = name[0:i]</code></span>
<span class="codeline" id="line-1105"><code>			break</code></span>
<span class="codeline" id="line-1106"><code>		}</code></span>
<span class="codeline" id="line-1107"><code>	}</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>	flag, ok := f.formal[name]</code></span>
<span class="codeline" id="line-1110"><code>	if !ok {</code></span>
<span class="codeline" id="line-1111"><code>		if name == "help" || name == "h" { // special case for nice help message.</code></span>
<span class="codeline" id="line-1112"><code>			f.usage()</code></span>
<span class="codeline" id="line-1113"><code>			return false, ErrHelp</code></span>
<span class="codeline" id="line-1114"><code>		}</code></span>
<span class="codeline" id="line-1115"><code>		return false, f.failf("flag provided but not defined: -%s", name)</code></span>
<span class="codeline" id="line-1116"><code>	}</code></span>
<span class="codeline" id="line-1117"><code></code></span>
<span class="codeline" id="line-1118"><code>	if fv, ok := flag.Value.(boolFlag); ok &amp;&amp; fv.IsBoolFlag() { // special case: doesn't need an arg</code></span>
<span class="codeline" id="line-1119"><code>		if hasValue {</code></span>
<span class="codeline" id="line-1120"><code>			if err := fv.Set(value); err != nil {</code></span>
<span class="codeline" id="line-1121"><code>				return false, f.failf("invalid boolean value %q for -%s: %v", value, name, err)</code></span>
<span class="codeline" id="line-1122"><code>			}</code></span>
<span class="codeline" id="line-1123"><code>		} else {</code></span>
<span class="codeline" id="line-1124"><code>			if err := fv.Set("true"); err != nil {</code></span>
<span class="codeline" id="line-1125"><code>				return false, f.failf("invalid boolean flag %s: %v", name, err)</code></span>
<span class="codeline" id="line-1126"><code>			}</code></span>
<span class="codeline" id="line-1127"><code>		}</code></span>
<span class="codeline" id="line-1128"><code>	} else {</code></span>
<span class="codeline" id="line-1129"><code>		// It must have a value, which might be the next argument.</code></span>
<span class="codeline" id="line-1130"><code>		if !hasValue &amp;&amp; len(f.args) &gt; 0 {</code></span>
<span class="codeline" id="line-1131"><code>			// value is the next arg</code></span>
<span class="codeline" id="line-1132"><code>			hasValue = true</code></span>
<span class="codeline" id="line-1133"><code>			value, f.args = f.args[0], f.args[1:]</code></span>
<span class="codeline" id="line-1134"><code>		}</code></span>
<span class="codeline" id="line-1135"><code>		if !hasValue {</code></span>
<span class="codeline" id="line-1136"><code>			return false, f.failf("flag needs an argument: -%s", name)</code></span>
<span class="codeline" id="line-1137"><code>		}</code></span>
<span class="codeline" id="line-1138"><code>		if err := flag.Value.Set(value); err != nil {</code></span>
<span class="codeline" id="line-1139"><code>			return false, f.failf("invalid value %q for flag -%s: %v", value, name, err)</code></span>
<span class="codeline" id="line-1140"><code>		}</code></span>
<span class="codeline" id="line-1141"><code>	}</code></span>
<span class="codeline" id="line-1142"><code>	if f.actual == nil {</code></span>
<span class="codeline" id="line-1143"><code>		f.actual = make(map[string]*Flag)</code></span>
<span class="codeline" id="line-1144"><code>	}</code></span>
<span class="codeline" id="line-1145"><code>	f.actual[name] = flag</code></span>
<span class="codeline" id="line-1146"><code>	return true, nil</code></span>
<span class="codeline" id="line-1147"><code>}</code></span>
<span class="codeline" id="line-1148"><code></code></span>
<span class="codeline" id="line-1149"><code>// Parse parses flag definitions from the argument list, which should not</code></span>
<span class="codeline" id="line-1150"><code>// include the command name. Must be called after all flags in the [FlagSet]</code></span>
<span class="codeline" id="line-1151"><code>// are defined and before flags are accessed by the program.</code></span>
<span class="codeline" id="line-1152"><code>// The return value will be [ErrHelp] if -help or -h were set but not defined.</code></span>
<span class="codeline" id="line-1153"><code>func (f *FlagSet) Parse(arguments []string) error {</code></span>
<span class="codeline" id="line-1154"><code>	f.parsed = true</code></span>
<span class="codeline" id="line-1155"><code>	f.args = arguments</code></span>
<span class="codeline" id="line-1156"><code>	for {</code></span>
<span class="codeline" id="line-1157"><code>		seen, err := f.parseOne()</code></span>
<span class="codeline" id="line-1158"><code>		if seen {</code></span>
<span class="codeline" id="line-1159"><code>			continue</code></span>
<span class="codeline" id="line-1160"><code>		}</code></span>
<span class="codeline" id="line-1161"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1162"><code>			break</code></span>
<span class="codeline" id="line-1163"><code>		}</code></span>
<span class="codeline" id="line-1164"><code>		switch f.errorHandling {</code></span>
<span class="codeline" id="line-1165"><code>		case ContinueOnError:</code></span>
<span class="codeline" id="line-1166"><code>			return err</code></span>
<span class="codeline" id="line-1167"><code>		case ExitOnError:</code></span>
<span class="codeline" id="line-1168"><code>			if err == ErrHelp {</code></span>
<span class="codeline" id="line-1169"><code>				os.Exit(0)</code></span>
<span class="codeline" id="line-1170"><code>			}</code></span>
<span class="codeline" id="line-1171"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-1172"><code>		case PanicOnError:</code></span>
<span class="codeline" id="line-1173"><code>			panic(err)</code></span>
<span class="codeline" id="line-1174"><code>		}</code></span>
<span class="codeline" id="line-1175"><code>	}</code></span>
<span class="codeline" id="line-1176"><code>	return nil</code></span>
<span class="codeline" id="line-1177"><code>}</code></span>
<span class="codeline" id="line-1178"><code></code></span>
<span class="codeline" id="line-1179"><code>// Parsed reports whether f.Parse has been called.</code></span>
<span class="codeline" id="line-1180"><code>func (f *FlagSet) Parsed() bool {</code></span>
<span class="codeline" id="line-1181"><code>	return f.parsed</code></span>
<span class="codeline" id="line-1182"><code>}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>// Parse parses the command-line flags from [os.Args][1:]. Must be called</code></span>
<span class="codeline" id="line-1185"><code>// after all flags are defined and before flags are accessed by the program.</code></span>
<span class="codeline" id="line-1186"><code>func Parse() {</code></span>
<span class="codeline" id="line-1187"><code>	// Ignore errors; CommandLine is set for ExitOnError.</code></span>
<span class="codeline" id="line-1188"><code>	CommandLine.Parse(os.Args[1:])</code></span>
<span class="codeline" id="line-1189"><code>}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>// Parsed reports whether the command-line flags have been parsed.</code></span>
<span class="codeline" id="line-1192"><code>func Parsed() bool {</code></span>
<span class="codeline" id="line-1193"><code>	return CommandLine.Parsed()</code></span>
<span class="codeline" id="line-1194"><code>}</code></span>
<span class="codeline" id="line-1195"><code></code></span>
<span class="codeline" id="line-1196"><code>// CommandLine is the default set of command-line flags, parsed from [os.Args].</code></span>
<span class="codeline" id="line-1197"><code>// The top-level functions such as [BoolVar], [Arg], and so on are wrappers for the</code></span>
<span class="codeline" id="line-1198"><code>// methods of CommandLine.</code></span>
<span class="codeline" id="line-1199"><code>var CommandLine = NewFlagSet(os.Args[0], ExitOnError)</code></span>
<span class="codeline" id="line-1200"><code></code></span>
<span class="codeline" id="line-1201"><code>func init() {</code></span>
<span class="codeline" id="line-1202"><code>	// Override generic FlagSet default Usage with call to global Usage.</code></span>
<span class="codeline" id="line-1203"><code>	// Note: This is not CommandLine.Usage = Usage,</code></span>
<span class="codeline" id="line-1204"><code>	// because we want any eventual call to use any updated value of Usage,</code></span>
<span class="codeline" id="line-1205"><code>	// not the value it has when this line is run.</code></span>
<span class="codeline" id="line-1206"><code>	CommandLine.Usage = commandLineUsage</code></span>
<span class="codeline" id="line-1207"><code>}</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>func commandLineUsage() {</code></span>
<span class="codeline" id="line-1210"><code>	Usage()</code></span>
<span class="codeline" id="line-1211"><code>}</code></span>
<span class="codeline" id="line-1212"><code></code></span>
<span class="codeline" id="line-1213"><code>// NewFlagSet returns a new, empty flag set with the specified name and</code></span>
<span class="codeline" id="line-1214"><code>// error handling property. If the name is not empty, it will be printed</code></span>
<span class="codeline" id="line-1215"><code>// in the default usage message and in error messages.</code></span>
<span class="codeline" id="line-1216"><code>func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet {</code></span>
<span class="codeline" id="line-1217"><code>	f := &amp;FlagSet{</code></span>
<span class="codeline" id="line-1218"><code>		name:          name,</code></span>
<span class="codeline" id="line-1219"><code>		errorHandling: errorHandling,</code></span>
<span class="codeline" id="line-1220"><code>	}</code></span>
<span class="codeline" id="line-1221"><code>	f.Usage = f.defaultUsage</code></span>
<span class="codeline" id="line-1222"><code>	return f</code></span>
<span class="codeline" id="line-1223"><code>}</code></span>
<span class="codeline" id="line-1224"><code></code></span>
<span class="codeline" id="line-1225"><code>// Init sets the name and error handling property for a flag set.</code></span>
<span class="codeline" id="line-1226"><code>// By default, the zero [FlagSet] uses an empty name and the</code></span>
<span class="codeline" id="line-1227"><code>// [ContinueOnError] error handling policy.</code></span>
<span class="codeline" id="line-1228"><code>func (f *FlagSet) Init(name string, errorHandling ErrorHandling) {</code></span>
<span class="codeline" id="line-1229"><code>	f.name = name</code></span>
<span class="codeline" id="line-1230"><code>	f.errorHandling = errorHandling</code></span>
<span class="codeline" id="line-1231"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>