<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: symtab.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	symtab.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"internal/abi"</code></span>
<span class="codeline" id="line-9"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-12"><code>	"unsafe"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// Frames may be used to get function/file/line information for a</code></span>
<span class="codeline" id="line-16"><code>// slice of PC values returned by [Callers].</code></span>
<span class="codeline" id="line-17"><code>type Frames struct {</code></span>
<span class="codeline" id="line-18"><code>	// callers is a slice of PCs that have not yet been expanded to frames.</code></span>
<span class="codeline" id="line-19"><code>	callers []uintptr</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>	// frames is a slice of Frames that have yet to be returned.</code></span>
<span class="codeline" id="line-22"><code>	frames     []Frame</code></span>
<span class="codeline" id="line-23"><code>	frameStore [2]Frame</code></span>
<span class="codeline" id="line-24"><code>}</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>// Frame is the information returned by [Frames] for each call frame.</code></span>
<span class="codeline" id="line-27"><code>type Frame struct {</code></span>
<span class="codeline" id="line-28"><code>	// PC is the program counter for the location in this frame.</code></span>
<span class="codeline" id="line-29"><code>	// For a frame that calls another frame, this will be the</code></span>
<span class="codeline" id="line-30"><code>	// program counter of a call instruction. Because of inlining,</code></span>
<span class="codeline" id="line-31"><code>	// multiple frames may have the same PC value, but different</code></span>
<span class="codeline" id="line-32"><code>	// symbolic information.</code></span>
<span class="codeline" id="line-33"><code>	PC uintptr</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>	// Func is the Func value of this call frame. This may be nil</code></span>
<span class="codeline" id="line-36"><code>	// for non-Go code or fully inlined functions.</code></span>
<span class="codeline" id="line-37"><code>	Func *Func</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>	// Function is the package path-qualified function name of</code></span>
<span class="codeline" id="line-40"><code>	// this call frame. If non-empty, this string uniquely</code></span>
<span class="codeline" id="line-41"><code>	// identifies a single function in the program.</code></span>
<span class="codeline" id="line-42"><code>	// This may be the empty string if not known.</code></span>
<span class="codeline" id="line-43"><code>	// If Func is not nil then Function == Func.Name().</code></span>
<span class="codeline" id="line-44"><code>	Function string</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>	// File and Line are the file name and line number of the</code></span>
<span class="codeline" id="line-47"><code>	// location in this frame. For non-leaf frames, this will be</code></span>
<span class="codeline" id="line-48"><code>	// the location of a call. These may be the empty string and</code></span>
<span class="codeline" id="line-49"><code>	// zero, respectively, if not known.</code></span>
<span class="codeline" id="line-50"><code>	File string</code></span>
<span class="codeline" id="line-51"><code>	Line int</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>	// startLine is the line number of the beginning of the function in</code></span>
<span class="codeline" id="line-54"><code>	// this frame. Specifically, it is the line number of the func keyword</code></span>
<span class="codeline" id="line-55"><code>	// for Go functions. Note that //line directives can change the</code></span>
<span class="codeline" id="line-56"><code>	// filename and/or line number arbitrarily within a function, meaning</code></span>
<span class="codeline" id="line-57"><code>	// that the Line - startLine offset is not always meaningful.</code></span>
<span class="codeline" id="line-58"><code>	//</code></span>
<span class="codeline" id="line-59"><code>	// This may be zero if not known.</code></span>
<span class="codeline" id="line-60"><code>	startLine int</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	// Entry point program counter for the function; may be zero</code></span>
<span class="codeline" id="line-63"><code>	// if not known. If Func is not nil then Entry ==</code></span>
<span class="codeline" id="line-64"><code>	// Func.Entry().</code></span>
<span class="codeline" id="line-65"><code>	Entry uintptr</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>	// The runtime's internal view of the function. This field</code></span>
<span class="codeline" id="line-68"><code>	// is set (funcInfo.valid() returns true) only for Go functions,</code></span>
<span class="codeline" id="line-69"><code>	// not for C functions.</code></span>
<span class="codeline" id="line-70"><code>	funcInfo funcInfo</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// CallersFrames takes a slice of PC values returned by [Callers] and</code></span>
<span class="codeline" id="line-74"><code>// prepares to return function/file/line information.</code></span>
<span class="codeline" id="line-75"><code>// Do not change the slice until you are done with the [Frames].</code></span>
<span class="codeline" id="line-76"><code>func CallersFrames(callers []uintptr) *Frames {</code></span>
<span class="codeline" id="line-77"><code>	f := &amp;Frames{callers: callers}</code></span>
<span class="codeline" id="line-78"><code>	f.frames = f.frameStore[:0]</code></span>
<span class="codeline" id="line-79"><code>	return f</code></span>
<span class="codeline" id="line-80"><code>}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>// Next returns a [Frame] representing the next call frame in the slice</code></span>
<span class="codeline" id="line-83"><code>// of PC values. If it has already returned all call frames, Next</code></span>
<span class="codeline" id="line-84"><code>// returns a zero [Frame].</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// The more result indicates whether the next call to Next will return</code></span>
<span class="codeline" id="line-87"><code>// a valid [Frame]. It does not necessarily indicate whether this call</code></span>
<span class="codeline" id="line-88"><code>// returned one.</code></span>
<span class="codeline" id="line-89"><code>//</code></span>
<span class="codeline" id="line-90"><code>// See the [Frames] example for idiomatic usage.</code></span>
<span class="codeline" id="line-91"><code>func (ci *Frames) Next() (frame Frame, more bool) {</code></span>
<span class="codeline" id="line-92"><code>	for len(ci.frames) &lt; 2 {</code></span>
<span class="codeline" id="line-93"><code>		// Find the next frame.</code></span>
<span class="codeline" id="line-94"><code>		// We need to look for 2 frames so we know what</code></span>
<span class="codeline" id="line-95"><code>		// to return for the "more" result.</code></span>
<span class="codeline" id="line-96"><code>		if len(ci.callers) == 0 {</code></span>
<span class="codeline" id="line-97"><code>			break</code></span>
<span class="codeline" id="line-98"><code>		}</code></span>
<span class="codeline" id="line-99"><code>		pc := ci.callers[0]</code></span>
<span class="codeline" id="line-100"><code>		ci.callers = ci.callers[1:]</code></span>
<span class="codeline" id="line-101"><code>		funcInfo := findfunc(pc)</code></span>
<span class="codeline" id="line-102"><code>		if !funcInfo.valid() {</code></span>
<span class="codeline" id="line-103"><code>			if cgoSymbolizer != nil {</code></span>
<span class="codeline" id="line-104"><code>				// Pre-expand cgo frames. We could do this</code></span>
<span class="codeline" id="line-105"><code>				// incrementally, too, but there's no way to</code></span>
<span class="codeline" id="line-106"><code>				// avoid allocation in this case anyway.</code></span>
<span class="codeline" id="line-107"><code>				ci.frames = append(ci.frames, expandCgoFrames(pc)...)</code></span>
<span class="codeline" id="line-108"><code>			}</code></span>
<span class="codeline" id="line-109"><code>			continue</code></span>
<span class="codeline" id="line-110"><code>		}</code></span>
<span class="codeline" id="line-111"><code>		f := funcInfo._Func()</code></span>
<span class="codeline" id="line-112"><code>		entry := f.Entry()</code></span>
<span class="codeline" id="line-113"><code>		if pc &gt; entry {</code></span>
<span class="codeline" id="line-114"><code>			// We store the pc of the start of the instruction following</code></span>
<span class="codeline" id="line-115"><code>			// the instruction in question (the call or the inline mark).</code></span>
<span class="codeline" id="line-116"><code>			// This is done for historical reasons, and to make FuncForPC</code></span>
<span class="codeline" id="line-117"><code>			// work correctly for entries in the result of runtime.Callers.</code></span>
<span class="codeline" id="line-118"><code>			pc--</code></span>
<span class="codeline" id="line-119"><code>		}</code></span>
<span class="codeline" id="line-120"><code>		// It's important that interpret pc non-strictly as cgoTraceback may</code></span>
<span class="codeline" id="line-121"><code>		// have added bogus PCs with a valid funcInfo but invalid PCDATA.</code></span>
<span class="codeline" id="line-122"><code>		u, uf := newInlineUnwinder(funcInfo, pc)</code></span>
<span class="codeline" id="line-123"><code>		sf := u.srcFunc(uf)</code></span>
<span class="codeline" id="line-124"><code>		if u.isInlined(uf) {</code></span>
<span class="codeline" id="line-125"><code>			// Note: entry is not modified. It always refers to a real frame, not an inlined one.</code></span>
<span class="codeline" id="line-126"><code>			// File/line from funcline1 below are already correct.</code></span>
<span class="codeline" id="line-127"><code>			f = nil</code></span>
<span class="codeline" id="line-128"><code>		}</code></span>
<span class="codeline" id="line-129"><code>		ci.frames = append(ci.frames, Frame{</code></span>
<span class="codeline" id="line-130"><code>			PC:        pc,</code></span>
<span class="codeline" id="line-131"><code>			Func:      f,</code></span>
<span class="codeline" id="line-132"><code>			Function:  funcNameForPrint(sf.name()),</code></span>
<span class="codeline" id="line-133"><code>			Entry:     entry,</code></span>
<span class="codeline" id="line-134"><code>			startLine: int(sf.startLine),</code></span>
<span class="codeline" id="line-135"><code>			funcInfo:  funcInfo,</code></span>
<span class="codeline" id="line-136"><code>			// Note: File,Line set below</code></span>
<span class="codeline" id="line-137"><code>		})</code></span>
<span class="codeline" id="line-138"><code>	}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	// Pop one frame from the frame list. Keep the rest.</code></span>
<span class="codeline" id="line-141"><code>	// Avoid allocation in the common case, which is 1 or 2 frames.</code></span>
<span class="codeline" id="line-142"><code>	switch len(ci.frames) {</code></span>
<span class="codeline" id="line-143"><code>	case 0: // In the rare case when there are no frames at all, we return Frame{}.</code></span>
<span class="codeline" id="line-144"><code>		return</code></span>
<span class="codeline" id="line-145"><code>	case 1:</code></span>
<span class="codeline" id="line-146"><code>		frame = ci.frames[0]</code></span>
<span class="codeline" id="line-147"><code>		ci.frames = ci.frameStore[:0]</code></span>
<span class="codeline" id="line-148"><code>	case 2:</code></span>
<span class="codeline" id="line-149"><code>		frame = ci.frames[0]</code></span>
<span class="codeline" id="line-150"><code>		ci.frameStore[0] = ci.frames[1]</code></span>
<span class="codeline" id="line-151"><code>		ci.frames = ci.frameStore[:1]</code></span>
<span class="codeline" id="line-152"><code>	default:</code></span>
<span class="codeline" id="line-153"><code>		frame = ci.frames[0]</code></span>
<span class="codeline" id="line-154"><code>		ci.frames = ci.frames[1:]</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>	more = len(ci.frames) &gt; 0</code></span>
<span class="codeline" id="line-157"><code>	if frame.funcInfo.valid() {</code></span>
<span class="codeline" id="line-158"><code>		// Compute file/line just before we need to return it,</code></span>
<span class="codeline" id="line-159"><code>		// as it can be expensive. This avoids computing file/line</code></span>
<span class="codeline" id="line-160"><code>		// for the Frame we find but don't return. See issue 32093.</code></span>
<span class="codeline" id="line-161"><code>		file, line := funcline1(frame.funcInfo, frame.PC, false)</code></span>
<span class="codeline" id="line-162"><code>		frame.File, frame.Line = file, int(line)</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code>	return</code></span>
<span class="codeline" id="line-165"><code>}</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// runtime_FrameStartLine returns the start line of the function in a Frame.</code></span>
<span class="codeline" id="line-168"><code>//</code></span>
<span class="codeline" id="line-169"><code>//go:linkname runtime_FrameStartLine runtime/pprof.runtime_FrameStartLine</code></span>
<span class="codeline" id="line-170"><code>func runtime_FrameStartLine(f *Frame) int {</code></span>
<span class="codeline" id="line-171"><code>	return f.startLine</code></span>
<span class="codeline" id="line-172"><code>}</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>// runtime_FrameSymbolName returns the full symbol name of the function in a Frame.</code></span>
<span class="codeline" id="line-175"><code>// For generic functions this differs from f.Function in that this doesn't replace</code></span>
<span class="codeline" id="line-176"><code>// the shape name to "...".</code></span>
<span class="codeline" id="line-177"><code>//</code></span>
<span class="codeline" id="line-178"><code>//go:linkname runtime_FrameSymbolName runtime/pprof.runtime_FrameSymbolName</code></span>
<span class="codeline" id="line-179"><code>func runtime_FrameSymbolName(f *Frame) string {</code></span>
<span class="codeline" id="line-180"><code>	if !f.funcInfo.valid() {</code></span>
<span class="codeline" id="line-181"><code>		return f.Function</code></span>
<span class="codeline" id="line-182"><code>	}</code></span>
<span class="codeline" id="line-183"><code>	u, uf := newInlineUnwinder(f.funcInfo, f.PC)</code></span>
<span class="codeline" id="line-184"><code>	sf := u.srcFunc(uf)</code></span>
<span class="codeline" id="line-185"><code>	return sf.name()</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// runtime_expandFinalInlineFrame expands the final pc in stk to include all</code></span>
<span class="codeline" id="line-189"><code>// "callers" if pc is inline.</code></span>
<span class="codeline" id="line-190"><code>//</code></span>
<span class="codeline" id="line-191"><code>//go:linkname runtime_expandFinalInlineFrame runtime/pprof.runtime_expandFinalInlineFrame</code></span>
<span class="codeline" id="line-192"><code>func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr {</code></span>
<span class="codeline" id="line-193"><code>	// TODO: It would be more efficient to report only physical PCs to pprof and</code></span>
<span class="codeline" id="line-194"><code>	// just expand the whole stack.</code></span>
<span class="codeline" id="line-195"><code>	if len(stk) == 0 {</code></span>
<span class="codeline" id="line-196"><code>		return stk</code></span>
<span class="codeline" id="line-197"><code>	}</code></span>
<span class="codeline" id="line-198"><code>	pc := stk[len(stk)-1]</code></span>
<span class="codeline" id="line-199"><code>	tracepc := pc - 1</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>	f := findfunc(tracepc)</code></span>
<span class="codeline" id="line-202"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-203"><code>		// Not a Go function.</code></span>
<span class="codeline" id="line-204"><code>		return stk</code></span>
<span class="codeline" id="line-205"><code>	}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>	u, uf := newInlineUnwinder(f, tracepc)</code></span>
<span class="codeline" id="line-208"><code>	if !u.isInlined(uf) {</code></span>
<span class="codeline" id="line-209"><code>		// Nothing inline at tracepc.</code></span>
<span class="codeline" id="line-210"><code>		return stk</code></span>
<span class="codeline" id="line-211"><code>	}</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>	// Treat the previous func as normal. We haven't actually checked, but</code></span>
<span class="codeline" id="line-214"><code>	// since this pc was included in the stack, we know it shouldn't be</code></span>
<span class="codeline" id="line-215"><code>	// elided.</code></span>
<span class="codeline" id="line-216"><code>	calleeID := abi.FuncIDNormal</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>	// Remove pc from stk; we'll re-add it below.</code></span>
<span class="codeline" id="line-219"><code>	stk = stk[:len(stk)-1]</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>	for ; uf.valid(); uf = u.next(uf) {</code></span>
<span class="codeline" id="line-222"><code>		funcID := u.srcFunc(uf).funcID</code></span>
<span class="codeline" id="line-223"><code>		if funcID == abi.FuncIDWrapper &amp;&amp; elideWrapperCalling(calleeID) {</code></span>
<span class="codeline" id="line-224"><code>			// ignore wrappers</code></span>
<span class="codeline" id="line-225"><code>		} else {</code></span>
<span class="codeline" id="line-226"><code>			stk = append(stk, uf.pc+1)</code></span>
<span class="codeline" id="line-227"><code>		}</code></span>
<span class="codeline" id="line-228"><code>		calleeID = funcID</code></span>
<span class="codeline" id="line-229"><code>	}</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>	return stk</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// expandCgoFrames expands frame information for pc, known to be</code></span>
<span class="codeline" id="line-235"><code>// a non-Go function, using the cgoSymbolizer hook. expandCgoFrames</code></span>
<span class="codeline" id="line-236"><code>// returns nil if pc could not be expanded.</code></span>
<span class="codeline" id="line-237"><code>func expandCgoFrames(pc uintptr) []Frame {</code></span>
<span class="codeline" id="line-238"><code>	arg := cgoSymbolizerArg{pc: pc}</code></span>
<span class="codeline" id="line-239"><code>	callCgoSymbolizer(&amp;arg)</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	if arg.file == nil &amp;&amp; arg.funcName == nil {</code></span>
<span class="codeline" id="line-242"><code>		// No useful information from symbolizer.</code></span>
<span class="codeline" id="line-243"><code>		return nil</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	var frames []Frame</code></span>
<span class="codeline" id="line-247"><code>	for {</code></span>
<span class="codeline" id="line-248"><code>		frames = append(frames, Frame{</code></span>
<span class="codeline" id="line-249"><code>			PC:       pc,</code></span>
<span class="codeline" id="line-250"><code>			Func:     nil,</code></span>
<span class="codeline" id="line-251"><code>			Function: gostring(arg.funcName),</code></span>
<span class="codeline" id="line-252"><code>			File:     gostring(arg.file),</code></span>
<span class="codeline" id="line-253"><code>			Line:     int(arg.lineno),</code></span>
<span class="codeline" id="line-254"><code>			Entry:    arg.entry,</code></span>
<span class="codeline" id="line-255"><code>			// funcInfo is zero, which implies !funcInfo.valid().</code></span>
<span class="codeline" id="line-256"><code>			// That ensures that we use the File/Line info given here.</code></span>
<span class="codeline" id="line-257"><code>		})</code></span>
<span class="codeline" id="line-258"><code>		if arg.more == 0 {</code></span>
<span class="codeline" id="line-259"><code>			break</code></span>
<span class="codeline" id="line-260"><code>		}</code></span>
<span class="codeline" id="line-261"><code>		callCgoSymbolizer(&amp;arg)</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>	// No more frames for this PC. Tell the symbolizer we are done.</code></span>
<span class="codeline" id="line-265"><code>	// We don't try to maintain a single cgoSymbolizerArg for the</code></span>
<span class="codeline" id="line-266"><code>	// whole use of Frames, because there would be no good way to tell</code></span>
<span class="codeline" id="line-267"><code>	// the symbolizer when we are done.</code></span>
<span class="codeline" id="line-268"><code>	arg.pc = 0</code></span>
<span class="codeline" id="line-269"><code>	callCgoSymbolizer(&amp;arg)</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>	return frames</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// NOTE: Func does not expose the actual unexported fields, because we return *Func</code></span>
<span class="codeline" id="line-275"><code>// values to users, and we want to keep them from being able to overwrite the data</code></span>
<span class="codeline" id="line-276"><code>// with (say) *f = Func{}.</code></span>
<span class="codeline" id="line-277"><code>// All code operating on a *Func must call raw() to get the *_func</code></span>
<span class="codeline" id="line-278"><code>// or funcInfo() to get the funcInfo instead.</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>// A Func represents a Go function in the running binary.</code></span>
<span class="codeline" id="line-281"><code>type Func struct {</code></span>
<span class="codeline" id="line-282"><code>	opaque struct{} // unexported field to disallow conversions</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>func (f *Func) raw() *_func {</code></span>
<span class="codeline" id="line-286"><code>	return (*_func)(unsafe.Pointer(f))</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>func (f *Func) funcInfo() funcInfo {</code></span>
<span class="codeline" id="line-290"><code>	return f.raw().funcInfo()</code></span>
<span class="codeline" id="line-291"><code>}</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>func (f *_func) funcInfo() funcInfo {</code></span>
<span class="codeline" id="line-294"><code>	// Find the module containing fn. fn is located in the pclntable.</code></span>
<span class="codeline" id="line-295"><code>	// The unsafe.Pointer to uintptr conversions and arithmetic</code></span>
<span class="codeline" id="line-296"><code>	// are safe because we are working with module addresses.</code></span>
<span class="codeline" id="line-297"><code>	ptr := uintptr(unsafe.Pointer(f))</code></span>
<span class="codeline" id="line-298"><code>	var mod *moduledata</code></span>
<span class="codeline" id="line-299"><code>	for datap := &amp;firstmoduledata; datap != nil; datap = datap.next {</code></span>
<span class="codeline" id="line-300"><code>		if len(datap.pclntable) == 0 {</code></span>
<span class="codeline" id="line-301"><code>			continue</code></span>
<span class="codeline" id="line-302"><code>		}</code></span>
<span class="codeline" id="line-303"><code>		base := uintptr(unsafe.Pointer(&amp;datap.pclntable[0]))</code></span>
<span class="codeline" id="line-304"><code>		if base &lt;= ptr &amp;&amp; ptr &lt; base+uintptr(len(datap.pclntable)) {</code></span>
<span class="codeline" id="line-305"><code>			mod = datap</code></span>
<span class="codeline" id="line-306"><code>			break</code></span>
<span class="codeline" id="line-307"><code>		}</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>	return funcInfo{f, mod}</code></span>
<span class="codeline" id="line-310"><code>}</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// pcHeader holds data used by the pclntab lookups.</code></span>
<span class="codeline" id="line-313"><code>type pcHeader struct {</code></span>
<span class="codeline" id="line-314"><code>	magic          uint32  // 0xFFFFFFF1</code></span>
<span class="codeline" id="line-315"><code>	pad1, pad2     uint8   // 0,0</code></span>
<span class="codeline" id="line-316"><code>	minLC          uint8   // min instruction size</code></span>
<span class="codeline" id="line-317"><code>	ptrSize        uint8   // size of a ptr in bytes</code></span>
<span class="codeline" id="line-318"><code>	nfunc          int     // number of functions in the module</code></span>
<span class="codeline" id="line-319"><code>	nfiles         uint    // number of entries in the file tab</code></span>
<span class="codeline" id="line-320"><code>	textStart      uintptr // base for function entry PC offsets in this module, equal to moduledata.text</code></span>
<span class="codeline" id="line-321"><code>	funcnameOffset uintptr // offset to the funcnametab variable from pcHeader</code></span>
<span class="codeline" id="line-322"><code>	cuOffset       uintptr // offset to the cutab variable from pcHeader</code></span>
<span class="codeline" id="line-323"><code>	filetabOffset  uintptr // offset to the filetab variable from pcHeader</code></span>
<span class="codeline" id="line-324"><code>	pctabOffset    uintptr // offset to the pctab variable from pcHeader</code></span>
<span class="codeline" id="line-325"><code>	pclnOffset     uintptr // offset to the pclntab variable from pcHeader</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// moduledata records information about the layout of the executable</code></span>
<span class="codeline" id="line-329"><code>// image. It is written by the linker. Any changes here must be</code></span>
<span class="codeline" id="line-330"><code>// matched changes to the code in cmd/link/internal/ld/symtab.go:symtab.</code></span>
<span class="codeline" id="line-331"><code>// moduledata is stored in statically allocated non-pointer memory;</code></span>
<span class="codeline" id="line-332"><code>// none of the pointers here are visible to the garbage collector.</code></span>
<span class="codeline" id="line-333"><code>type moduledata struct {</code></span>
<span class="codeline" id="line-334"><code>	sys.NotInHeap // Only in static data</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>	pcHeader     *pcHeader</code></span>
<span class="codeline" id="line-337"><code>	funcnametab  []byte</code></span>
<span class="codeline" id="line-338"><code>	cutab        []uint32</code></span>
<span class="codeline" id="line-339"><code>	filetab      []byte</code></span>
<span class="codeline" id="line-340"><code>	pctab        []byte</code></span>
<span class="codeline" id="line-341"><code>	pclntable    []byte</code></span>
<span class="codeline" id="line-342"><code>	ftab         []functab</code></span>
<span class="codeline" id="line-343"><code>	findfunctab  uintptr</code></span>
<span class="codeline" id="line-344"><code>	minpc, maxpc uintptr</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>	text, etext           uintptr</code></span>
<span class="codeline" id="line-347"><code>	noptrdata, enoptrdata uintptr</code></span>
<span class="codeline" id="line-348"><code>	data, edata           uintptr</code></span>
<span class="codeline" id="line-349"><code>	bss, ebss             uintptr</code></span>
<span class="codeline" id="line-350"><code>	noptrbss, enoptrbss   uintptr</code></span>
<span class="codeline" id="line-351"><code>	covctrs, ecovctrs     uintptr</code></span>
<span class="codeline" id="line-352"><code>	end, gcdata, gcbss    uintptr</code></span>
<span class="codeline" id="line-353"><code>	types, etypes         uintptr</code></span>
<span class="codeline" id="line-354"><code>	rodata                uintptr</code></span>
<span class="codeline" id="line-355"><code>	gofunc                uintptr // go.func.*</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	textsectmap []textsect</code></span>
<span class="codeline" id="line-358"><code>	typelinks   []int32 // offsets from types</code></span>
<span class="codeline" id="line-359"><code>	itablinks   []*itab</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>	ptab []ptabEntry</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>	pluginpath string</code></span>
<span class="codeline" id="line-364"><code>	pkghashes  []modulehash</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>	// This slice records the initializing tasks that need to be</code></span>
<span class="codeline" id="line-367"><code>	// done to start up the program. It is built by the linker.</code></span>
<span class="codeline" id="line-368"><code>	inittasks []*initTask</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>	modulename   string</code></span>
<span class="codeline" id="line-371"><code>	modulehashes []modulehash</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>	hasmain uint8 // 1 if module contains the main function, 0 otherwise</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>	gcdatamask, gcbssmask bitvector</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>	typemap map[typeOff]*_type // offset to *_rtype in previous module</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>	bad bool // module failed to load and should be ignored</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>	next *moduledata</code></span>
<span class="codeline" id="line-382"><code>}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>// A modulehash is used to compare the ABI of a new module or a</code></span>
<span class="codeline" id="line-385"><code>// package in a new module with the loaded program.</code></span>
<span class="codeline" id="line-386"><code>//</code></span>
<span class="codeline" id="line-387"><code>// For each shared library a module links against, the linker creates an entry in the</code></span>
<span class="codeline" id="line-388"><code>// moduledata.modulehashes slice containing the name of the module, the abi hash seen</code></span>
<span class="codeline" id="line-389"><code>// at link time and a pointer to the runtime abi hash. These are checked in</code></span>
<span class="codeline" id="line-390"><code>// moduledataverify1 below.</code></span>
<span class="codeline" id="line-391"><code>//</code></span>
<span class="codeline" id="line-392"><code>// For each loaded plugin, the pkghashes slice has a modulehash of the</code></span>
<span class="codeline" id="line-393"><code>// newly loaded package that can be used to check the plugin's version of</code></span>
<span class="codeline" id="line-394"><code>// a package against any previously loaded version of the package.</code></span>
<span class="codeline" id="line-395"><code>// This is done in plugin.lastmoduleinit.</code></span>
<span class="codeline" id="line-396"><code>type modulehash struct {</code></span>
<span class="codeline" id="line-397"><code>	modulename   string</code></span>
<span class="codeline" id="line-398"><code>	linktimehash string</code></span>
<span class="codeline" id="line-399"><code>	runtimehash  *string</code></span>
<span class="codeline" id="line-400"><code>}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>// pinnedTypemaps are the map[typeOff]*_type from the moduledata objects.</code></span>
<span class="codeline" id="line-403"><code>//</code></span>
<span class="codeline" id="line-404"><code>// These typemap objects are allocated at run time on the heap, but the</code></span>
<span class="codeline" id="line-405"><code>// only direct reference to them is in the moduledata, created by the</code></span>
<span class="codeline" id="line-406"><code>// linker and marked SNOPTRDATA so it is ignored by the GC.</code></span>
<span class="codeline" id="line-407"><code>//</code></span>
<span class="codeline" id="line-408"><code>// To make sure the map isn't collected, we keep a second reference here.</code></span>
<span class="codeline" id="line-409"><code>var pinnedTypemaps []map[typeOff]*_type</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>var firstmoduledata moduledata  // linker symbol</code></span>
<span class="codeline" id="line-412"><code>var lastmoduledatap *moduledata // linker symbol</code></span>
<span class="codeline" id="line-413"><code>var modulesSlice *[]*moduledata // see activeModules</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>// activeModules returns a slice of active modules.</code></span>
<span class="codeline" id="line-416"><code>//</code></span>
<span class="codeline" id="line-417"><code>// A module is active once its gcdatamask and gcbssmask have been</code></span>
<span class="codeline" id="line-418"><code>// assembled and it is usable by the GC.</code></span>
<span class="codeline" id="line-419"><code>//</code></span>
<span class="codeline" id="line-420"><code>// This is nosplit/nowritebarrier because it is called by the</code></span>
<span class="codeline" id="line-421"><code>// cgo pointer checking code.</code></span>
<span class="codeline" id="line-422"><code>//</code></span>
<span class="codeline" id="line-423"><code>//go:nosplit</code></span>
<span class="codeline" id="line-424"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-425"><code>func activeModules() []*moduledata {</code></span>
<span class="codeline" id="line-426"><code>	p := (*[]*moduledata)(atomic.Loadp(unsafe.Pointer(&amp;modulesSlice)))</code></span>
<span class="codeline" id="line-427"><code>	if p == nil {</code></span>
<span class="codeline" id="line-428"><code>		return nil</code></span>
<span class="codeline" id="line-429"><code>	}</code></span>
<span class="codeline" id="line-430"><code>	return *p</code></span>
<span class="codeline" id="line-431"><code>}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>// modulesinit creates the active modules slice out of all loaded modules.</code></span>
<span class="codeline" id="line-434"><code>//</code></span>
<span class="codeline" id="line-435"><code>// When a module is first loaded by the dynamic linker, an .init_array</code></span>
<span class="codeline" id="line-436"><code>// function (written by cmd/link) is invoked to call addmoduledata,</code></span>
<span class="codeline" id="line-437"><code>// appending to the module to the linked list that starts with</code></span>
<span class="codeline" id="line-438"><code>// firstmoduledata.</code></span>
<span class="codeline" id="line-439"><code>//</code></span>
<span class="codeline" id="line-440"><code>// There are two times this can happen in the lifecycle of a Go</code></span>
<span class="codeline" id="line-441"><code>// program. First, if compiled with -linkshared, a number of modules</code></span>
<span class="codeline" id="line-442"><code>// built with -buildmode=shared can be loaded at program initialization.</code></span>
<span class="codeline" id="line-443"><code>// Second, a Go program can load a module while running that was built</code></span>
<span class="codeline" id="line-444"><code>// with -buildmode=plugin.</code></span>
<span class="codeline" id="line-445"><code>//</code></span>
<span class="codeline" id="line-446"><code>// After loading, this function is called which initializes the</code></span>
<span class="codeline" id="line-447"><code>// moduledata so it is usable by the GC and creates a new activeModules</code></span>
<span class="codeline" id="line-448"><code>// list.</code></span>
<span class="codeline" id="line-449"><code>//</code></span>
<span class="codeline" id="line-450"><code>// Only one goroutine may call modulesinit at a time.</code></span>
<span class="codeline" id="line-451"><code>func modulesinit() {</code></span>
<span class="codeline" id="line-452"><code>	modules := new([]*moduledata)</code></span>
<span class="codeline" id="line-453"><code>	for md := &amp;firstmoduledata; md != nil; md = md.next {</code></span>
<span class="codeline" id="line-454"><code>		if md.bad {</code></span>
<span class="codeline" id="line-455"><code>			continue</code></span>
<span class="codeline" id="line-456"><code>		}</code></span>
<span class="codeline" id="line-457"><code>		*modules = append(*modules, md)</code></span>
<span class="codeline" id="line-458"><code>		if md.gcdatamask == (bitvector{}) {</code></span>
<span class="codeline" id="line-459"><code>			scanDataSize := md.edata - md.data</code></span>
<span class="codeline" id="line-460"><code>			md.gcdatamask = progToPointerMask((*byte)(unsafe.Pointer(md.gcdata)), scanDataSize)</code></span>
<span class="codeline" id="line-461"><code>			scanBSSSize := md.ebss - md.bss</code></span>
<span class="codeline" id="line-462"><code>			md.gcbssmask = progToPointerMask((*byte)(unsafe.Pointer(md.gcbss)), scanBSSSize)</code></span>
<span class="codeline" id="line-463"><code>			gcController.addGlobals(int64(scanDataSize + scanBSSSize))</code></span>
<span class="codeline" id="line-464"><code>		}</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>	// Modules appear in the moduledata linked list in the order they are</code></span>
<span class="codeline" id="line-468"><code>	// loaded by the dynamic loader, with one exception: the</code></span>
<span class="codeline" id="line-469"><code>	// firstmoduledata itself the module that contains the runtime. This</code></span>
<span class="codeline" id="line-470"><code>	// is not always the first module (when using -buildmode=shared, it</code></span>
<span class="codeline" id="line-471"><code>	// is typically libstd.so, the second module). The order matters for</code></span>
<span class="codeline" id="line-472"><code>	// typelinksinit, so we swap the first module with whatever module</code></span>
<span class="codeline" id="line-473"><code>	// contains the main function.</code></span>
<span class="codeline" id="line-474"><code>	//</code></span>
<span class="codeline" id="line-475"><code>	// See Issue #18729.</code></span>
<span class="codeline" id="line-476"><code>	for i, md := range *modules {</code></span>
<span class="codeline" id="line-477"><code>		if md.hasmain != 0 {</code></span>
<span class="codeline" id="line-478"><code>			(*modules)[0] = md</code></span>
<span class="codeline" id="line-479"><code>			(*modules)[i] = &amp;firstmoduledata</code></span>
<span class="codeline" id="line-480"><code>			break</code></span>
<span class="codeline" id="line-481"><code>		}</code></span>
<span class="codeline" id="line-482"><code>	}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>	atomicstorep(unsafe.Pointer(&amp;modulesSlice), unsafe.Pointer(modules))</code></span>
<span class="codeline" id="line-485"><code>}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>type functab struct {</code></span>
<span class="codeline" id="line-488"><code>	entryoff uint32 // relative to runtime.text</code></span>
<span class="codeline" id="line-489"><code>	funcoff  uint32</code></span>
<span class="codeline" id="line-490"><code>}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>// Mapping information for secondary text sections</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>type textsect struct {</code></span>
<span class="codeline" id="line-495"><code>	vaddr    uintptr // prelinked section vaddr</code></span>
<span class="codeline" id="line-496"><code>	end      uintptr // vaddr + section length</code></span>
<span class="codeline" id="line-497"><code>	baseaddr uintptr // relocated section address</code></span>
<span class="codeline" id="line-498"><code>}</code></span>
<span class="codeline" id="line-499"><code></code></span>
<span class="codeline" id="line-500"><code>const minfunc = 16                 // minimum function size</code></span>
<span class="codeline" id="line-501"><code>const pcbucketsize = 256 * minfunc // size of bucket in the pc-&gt;func lookup table</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// findfuncbucket is an array of these structures.</code></span>
<span class="codeline" id="line-504"><code>// Each bucket represents 4096 bytes of the text segment.</code></span>
<span class="codeline" id="line-505"><code>// Each subbucket represents 256 bytes of the text segment.</code></span>
<span class="codeline" id="line-506"><code>// To find a function given a pc, locate the bucket and subbucket for</code></span>
<span class="codeline" id="line-507"><code>// that pc. Add together the idx and subbucket value to obtain a</code></span>
<span class="codeline" id="line-508"><code>// function index. Then scan the functab array starting at that</code></span>
<span class="codeline" id="line-509"><code>// index to find the target function.</code></span>
<span class="codeline" id="line-510"><code>// This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead.</code></span>
<span class="codeline" id="line-511"><code>type findfuncbucket struct {</code></span>
<span class="codeline" id="line-512"><code>	idx        uint32</code></span>
<span class="codeline" id="line-513"><code>	subbuckets [16]byte</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>func moduledataverify() {</code></span>
<span class="codeline" id="line-517"><code>	for datap := &amp;firstmoduledata; datap != nil; datap = datap.next {</code></span>
<span class="codeline" id="line-518"><code>		moduledataverify1(datap)</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>const debugPcln = false</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>func moduledataverify1(datap *moduledata) {</code></span>
<span class="codeline" id="line-525"><code>	// Check that the pclntab's format is valid.</code></span>
<span class="codeline" id="line-526"><code>	hdr := datap.pcHeader</code></span>
<span class="codeline" id="line-527"><code>	if hdr.magic != 0xfffffff1 || hdr.pad1 != 0 || hdr.pad2 != 0 ||</code></span>
<span class="codeline" id="line-528"><code>		hdr.minLC != sys.PCQuantum || hdr.ptrSize != goarch.PtrSize || hdr.textStart != datap.text {</code></span>
<span class="codeline" id="line-529"><code>		println("runtime: pcHeader: magic=", hex(hdr.magic), "pad1=", hdr.pad1, "pad2=", hdr.pad2,</code></span>
<span class="codeline" id="line-530"><code>			"minLC=", hdr.minLC, "ptrSize=", hdr.ptrSize, "pcHeader.textStart=", hex(hdr.textStart),</code></span>
<span class="codeline" id="line-531"><code>			"text=", hex(datap.text), "pluginpath=", datap.pluginpath)</code></span>
<span class="codeline" id="line-532"><code>		throw("invalid function symbol table")</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>	// ftab is lookup table for function by program counter.</code></span>
<span class="codeline" id="line-536"><code>	nftab := len(datap.ftab) - 1</code></span>
<span class="codeline" id="line-537"><code>	for i := 0; i &lt; nftab; i++ {</code></span>
<span class="codeline" id="line-538"><code>		// NOTE: ftab[nftab].entry is legal; it is the address beyond the final function.</code></span>
<span class="codeline" id="line-539"><code>		if datap.ftab[i].entryoff &gt; datap.ftab[i+1].entryoff {</code></span>
<span class="codeline" id="line-540"><code>			f1 := funcInfo{(*_func)(unsafe.Pointer(&amp;datap.pclntable[datap.ftab[i].funcoff])), datap}</code></span>
<span class="codeline" id="line-541"><code>			f2 := funcInfo{(*_func)(unsafe.Pointer(&amp;datap.pclntable[datap.ftab[i+1].funcoff])), datap}</code></span>
<span class="codeline" id="line-542"><code>			f2name := "end"</code></span>
<span class="codeline" id="line-543"><code>			if i+1 &lt; nftab {</code></span>
<span class="codeline" id="line-544"><code>				f2name = funcname(f2)</code></span>
<span class="codeline" id="line-545"><code>			}</code></span>
<span class="codeline" id="line-546"><code>			println("function symbol table not sorted by PC offset:", hex(datap.ftab[i].entryoff), funcname(f1), "&gt;", hex(datap.ftab[i+1].entryoff), f2name, ", plugin:", datap.pluginpath)</code></span>
<span class="codeline" id="line-547"><code>			for j := 0; j &lt;= i; j++ {</code></span>
<span class="codeline" id="line-548"><code>				println("\t", hex(datap.ftab[j].entryoff), funcname(funcInfo{(*_func)(unsafe.Pointer(&amp;datap.pclntable[datap.ftab[j].funcoff])), datap}))</code></span>
<span class="codeline" id="line-549"><code>			}</code></span>
<span class="codeline" id="line-550"><code>			if GOOS == "aix" &amp;&amp; isarchive {</code></span>
<span class="codeline" id="line-551"><code>				println("-Wl,-bnoobjreorder is mandatory on aix/ppc64 with c-archive")</code></span>
<span class="codeline" id="line-552"><code>			}</code></span>
<span class="codeline" id="line-553"><code>			throw("invalid runtime symbol table")</code></span>
<span class="codeline" id="line-554"><code>		}</code></span>
<span class="codeline" id="line-555"><code>	}</code></span>
<span class="codeline" id="line-556"><code></code></span>
<span class="codeline" id="line-557"><code>	min := datap.textAddr(datap.ftab[0].entryoff)</code></span>
<span class="codeline" id="line-558"><code>	max := datap.textAddr(datap.ftab[nftab].entryoff)</code></span>
<span class="codeline" id="line-559"><code>	if datap.minpc != min || datap.maxpc != max {</code></span>
<span class="codeline" id="line-560"><code>		println("minpc=", hex(datap.minpc), "min=", hex(min), "maxpc=", hex(datap.maxpc), "max=", hex(max))</code></span>
<span class="codeline" id="line-561"><code>		throw("minpc or maxpc invalid")</code></span>
<span class="codeline" id="line-562"><code>	}</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>	for _, modulehash := range datap.modulehashes {</code></span>
<span class="codeline" id="line-565"><code>		if modulehash.linktimehash != *modulehash.runtimehash {</code></span>
<span class="codeline" id="line-566"><code>			println("abi mismatch detected between", datap.modulename, "and", modulehash.modulename)</code></span>
<span class="codeline" id="line-567"><code>			throw("abi mismatch")</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>// textAddr returns md.text + off, with special handling for multiple text sections.</code></span>
<span class="codeline" id="line-573"><code>// off is a (virtual) offset computed at internal linking time,</code></span>
<span class="codeline" id="line-574"><code>// before the external linker adjusts the sections' base addresses.</code></span>
<span class="codeline" id="line-575"><code>//</code></span>
<span class="codeline" id="line-576"><code>// The text, or instruction stream is generated as one large buffer.</code></span>
<span class="codeline" id="line-577"><code>// The off (offset) for a function is its offset within this buffer.</code></span>
<span class="codeline" id="line-578"><code>// If the total text size gets too large, there can be issues on platforms like ppc64</code></span>
<span class="codeline" id="line-579"><code>// if the target of calls are too far for the call instruction.</code></span>
<span class="codeline" id="line-580"><code>// To resolve the large text issue, the text is split into multiple text sections</code></span>
<span class="codeline" id="line-581"><code>// to allow the linker to generate long calls when necessary.</code></span>
<span class="codeline" id="line-582"><code>// When this happens, the vaddr for each text section is set to its offset within the text.</code></span>
<span class="codeline" id="line-583"><code>// Each function's offset is compared against the section vaddrs and ends to determine the containing section.</code></span>
<span class="codeline" id="line-584"><code>// Then the section relative offset is added to the section's</code></span>
<span class="codeline" id="line-585"><code>// relocated baseaddr to compute the function address.</code></span>
<span class="codeline" id="line-586"><code>//</code></span>
<span class="codeline" id="line-587"><code>// It is nosplit because it is part of the findfunc implementation.</code></span>
<span class="codeline" id="line-588"><code>//</code></span>
<span class="codeline" id="line-589"><code>//go:nosplit</code></span>
<span class="codeline" id="line-590"><code>func (md *moduledata) textAddr(off32 uint32) uintptr {</code></span>
<span class="codeline" id="line-591"><code>	off := uintptr(off32)</code></span>
<span class="codeline" id="line-592"><code>	res := md.text + off</code></span>
<span class="codeline" id="line-593"><code>	if len(md.textsectmap) &gt; 1 {</code></span>
<span class="codeline" id="line-594"><code>		for i, sect := range md.textsectmap {</code></span>
<span class="codeline" id="line-595"><code>			// For the last section, include the end address (etext), as it is included in the functab.</code></span>
<span class="codeline" id="line-596"><code>			if off &gt;= sect.vaddr &amp;&amp; off &lt; sect.end || (i == len(md.textsectmap)-1 &amp;&amp; off == sect.end) {</code></span>
<span class="codeline" id="line-597"><code>				res = sect.baseaddr + off - sect.vaddr</code></span>
<span class="codeline" id="line-598"><code>				break</code></span>
<span class="codeline" id="line-599"><code>			}</code></span>
<span class="codeline" id="line-600"><code>		}</code></span>
<span class="codeline" id="line-601"><code>		if res &gt; md.etext &amp;&amp; GOARCH != "wasm" { // on wasm, functions do not live in the same address space as the linear memory</code></span>
<span class="codeline" id="line-602"><code>			println("runtime: textAddr", hex(res), "out of range", hex(md.text), "-", hex(md.etext))</code></span>
<span class="codeline" id="line-603"><code>			throw("runtime: text offset out of range")</code></span>
<span class="codeline" id="line-604"><code>		}</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code>	return res</code></span>
<span class="codeline" id="line-607"><code>}</code></span>
<span class="codeline" id="line-608"><code></code></span>
<span class="codeline" id="line-609"><code>// textOff is the opposite of textAddr. It converts a PC to a (virtual) offset</code></span>
<span class="codeline" id="line-610"><code>// to md.text, and returns if the PC is in any Go text section.</code></span>
<span class="codeline" id="line-611"><code>//</code></span>
<span class="codeline" id="line-612"><code>// It is nosplit because it is part of the findfunc implementation.</code></span>
<span class="codeline" id="line-613"><code>//</code></span>
<span class="codeline" id="line-614"><code>//go:nosplit</code></span>
<span class="codeline" id="line-615"><code>func (md *moduledata) textOff(pc uintptr) (uint32, bool) {</code></span>
<span class="codeline" id="line-616"><code>	res := uint32(pc - md.text)</code></span>
<span class="codeline" id="line-617"><code>	if len(md.textsectmap) &gt; 1 {</code></span>
<span class="codeline" id="line-618"><code>		for i, sect := range md.textsectmap {</code></span>
<span class="codeline" id="line-619"><code>			if sect.baseaddr &gt; pc {</code></span>
<span class="codeline" id="line-620"><code>				// pc is not in any section.</code></span>
<span class="codeline" id="line-621"><code>				return 0, false</code></span>
<span class="codeline" id="line-622"><code>			}</code></span>
<span class="codeline" id="line-623"><code>			end := sect.baseaddr + (sect.end - sect.vaddr)</code></span>
<span class="codeline" id="line-624"><code>			// For the last section, include the end address (etext), as it is included in the functab.</code></span>
<span class="codeline" id="line-625"><code>			if i == len(md.textsectmap)-1 {</code></span>
<span class="codeline" id="line-626"><code>				end++</code></span>
<span class="codeline" id="line-627"><code>			}</code></span>
<span class="codeline" id="line-628"><code>			if pc &lt; end {</code></span>
<span class="codeline" id="line-629"><code>				res = uint32(pc - sect.baseaddr + sect.vaddr)</code></span>
<span class="codeline" id="line-630"><code>				break</code></span>
<span class="codeline" id="line-631"><code>			}</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	return res, true</code></span>
<span class="codeline" id="line-635"><code>}</code></span>
<span class="codeline" id="line-636"><code></code></span>
<span class="codeline" id="line-637"><code>// funcName returns the string at nameOff in the function name table.</code></span>
<span class="codeline" id="line-638"><code>func (md *moduledata) funcName(nameOff int32) string {</code></span>
<span class="codeline" id="line-639"><code>	if nameOff == 0 {</code></span>
<span class="codeline" id="line-640"><code>		return ""</code></span>
<span class="codeline" id="line-641"><code>	}</code></span>
<span class="codeline" id="line-642"><code>	return gostringnocopy(&amp;md.funcnametab[nameOff])</code></span>
<span class="codeline" id="line-643"><code>}</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>// FuncForPC returns a *[Func] describing the function that contains the</code></span>
<span class="codeline" id="line-646"><code>// given program counter address, or else nil.</code></span>
<span class="codeline" id="line-647"><code>//</code></span>
<span class="codeline" id="line-648"><code>// If pc represents multiple functions because of inlining, it returns</code></span>
<span class="codeline" id="line-649"><code>// the *Func describing the innermost function, but with an entry of</code></span>
<span class="codeline" id="line-650"><code>// the outermost function.</code></span>
<span class="codeline" id="line-651"><code>func FuncForPC(pc uintptr) *Func {</code></span>
<span class="codeline" id="line-652"><code>	f := findfunc(pc)</code></span>
<span class="codeline" id="line-653"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-654"><code>		return nil</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code>	// This must interpret PC non-strictly so bad PCs (those between functions) don't crash the runtime.</code></span>
<span class="codeline" id="line-657"><code>	// We just report the preceding function in that situation. See issue 29735.</code></span>
<span class="codeline" id="line-658"><code>	// TODO: Perhaps we should report no function at all in that case.</code></span>
<span class="codeline" id="line-659"><code>	// The runtime currently doesn't have function end info, alas.</code></span>
<span class="codeline" id="line-660"><code>	u, uf := newInlineUnwinder(f, pc)</code></span>
<span class="codeline" id="line-661"><code>	if !u.isInlined(uf) {</code></span>
<span class="codeline" id="line-662"><code>		return f._Func()</code></span>
<span class="codeline" id="line-663"><code>	}</code></span>
<span class="codeline" id="line-664"><code>	sf := u.srcFunc(uf)</code></span>
<span class="codeline" id="line-665"><code>	file, line := u.fileLine(uf)</code></span>
<span class="codeline" id="line-666"><code>	fi := &amp;funcinl{</code></span>
<span class="codeline" id="line-667"><code>		ones:      ^uint32(0),</code></span>
<span class="codeline" id="line-668"><code>		entry:     f.entry(), // entry of the real (the outermost) function.</code></span>
<span class="codeline" id="line-669"><code>		name:      sf.name(),</code></span>
<span class="codeline" id="line-670"><code>		file:      file,</code></span>
<span class="codeline" id="line-671"><code>		line:      int32(line),</code></span>
<span class="codeline" id="line-672"><code>		startLine: sf.startLine,</code></span>
<span class="codeline" id="line-673"><code>	}</code></span>
<span class="codeline" id="line-674"><code>	return (*Func)(unsafe.Pointer(fi))</code></span>
<span class="codeline" id="line-675"><code>}</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>// Name returns the name of the function.</code></span>
<span class="codeline" id="line-678"><code>func (f *Func) Name() string {</code></span>
<span class="codeline" id="line-679"><code>	if f == nil {</code></span>
<span class="codeline" id="line-680"><code>		return ""</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code>	fn := f.raw()</code></span>
<span class="codeline" id="line-683"><code>	if fn.isInlined() { // inlined version</code></span>
<span class="codeline" id="line-684"><code>		fi := (*funcinl)(unsafe.Pointer(fn))</code></span>
<span class="codeline" id="line-685"><code>		return funcNameForPrint(fi.name)</code></span>
<span class="codeline" id="line-686"><code>	}</code></span>
<span class="codeline" id="line-687"><code>	return funcNameForPrint(funcname(f.funcInfo()))</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// Entry returns the entry address of the function.</code></span>
<span class="codeline" id="line-691"><code>func (f *Func) Entry() uintptr {</code></span>
<span class="codeline" id="line-692"><code>	fn := f.raw()</code></span>
<span class="codeline" id="line-693"><code>	if fn.isInlined() { // inlined version</code></span>
<span class="codeline" id="line-694"><code>		fi := (*funcinl)(unsafe.Pointer(fn))</code></span>
<span class="codeline" id="line-695"><code>		return fi.entry</code></span>
<span class="codeline" id="line-696"><code>	}</code></span>
<span class="codeline" id="line-697"><code>	return fn.funcInfo().entry()</code></span>
<span class="codeline" id="line-698"><code>}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>// FileLine returns the file name and line number of the</code></span>
<span class="codeline" id="line-701"><code>// source code corresponding to the program counter pc.</code></span>
<span class="codeline" id="line-702"><code>// The result will not be accurate if pc is not a program</code></span>
<span class="codeline" id="line-703"><code>// counter within f.</code></span>
<span class="codeline" id="line-704"><code>func (f *Func) FileLine(pc uintptr) (file string, line int) {</code></span>
<span class="codeline" id="line-705"><code>	fn := f.raw()</code></span>
<span class="codeline" id="line-706"><code>	if fn.isInlined() { // inlined version</code></span>
<span class="codeline" id="line-707"><code>		fi := (*funcinl)(unsafe.Pointer(fn))</code></span>
<span class="codeline" id="line-708"><code>		return fi.file, int(fi.line)</code></span>
<span class="codeline" id="line-709"><code>	}</code></span>
<span class="codeline" id="line-710"><code>	// Pass strict=false here, because anyone can call this function,</code></span>
<span class="codeline" id="line-711"><code>	// and they might just be wrong about targetpc belonging to f.</code></span>
<span class="codeline" id="line-712"><code>	file, line32 := funcline1(f.funcInfo(), pc, false)</code></span>
<span class="codeline" id="line-713"><code>	return file, int(line32)</code></span>
<span class="codeline" id="line-714"><code>}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>// startLine returns the starting line number of the function. i.e., the line</code></span>
<span class="codeline" id="line-717"><code>// number of the func keyword.</code></span>
<span class="codeline" id="line-718"><code>func (f *Func) startLine() int32 {</code></span>
<span class="codeline" id="line-719"><code>	fn := f.raw()</code></span>
<span class="codeline" id="line-720"><code>	if fn.isInlined() { // inlined version</code></span>
<span class="codeline" id="line-721"><code>		fi := (*funcinl)(unsafe.Pointer(fn))</code></span>
<span class="codeline" id="line-722"><code>		return fi.startLine</code></span>
<span class="codeline" id="line-723"><code>	}</code></span>
<span class="codeline" id="line-724"><code>	return fn.funcInfo().startLine</code></span>
<span class="codeline" id="line-725"><code>}</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>// findmoduledatap looks up the moduledata for a PC.</code></span>
<span class="codeline" id="line-728"><code>//</code></span>
<span class="codeline" id="line-729"><code>// It is nosplit because it's part of the isgoexception</code></span>
<span class="codeline" id="line-730"><code>// implementation.</code></span>
<span class="codeline" id="line-731"><code>//</code></span>
<span class="codeline" id="line-732"><code>//go:nosplit</code></span>
<span class="codeline" id="line-733"><code>func findmoduledatap(pc uintptr) *moduledata {</code></span>
<span class="codeline" id="line-734"><code>	for datap := &amp;firstmoduledata; datap != nil; datap = datap.next {</code></span>
<span class="codeline" id="line-735"><code>		if datap.minpc &lt;= pc &amp;&amp; pc &lt; datap.maxpc {</code></span>
<span class="codeline" id="line-736"><code>			return datap</code></span>
<span class="codeline" id="line-737"><code>		}</code></span>
<span class="codeline" id="line-738"><code>	}</code></span>
<span class="codeline" id="line-739"><code>	return nil</code></span>
<span class="codeline" id="line-740"><code>}</code></span>
<span class="codeline" id="line-741"><code></code></span>
<span class="codeline" id="line-742"><code>type funcInfo struct {</code></span>
<span class="codeline" id="line-743"><code>	*_func</code></span>
<span class="codeline" id="line-744"><code>	datap *moduledata</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>func (f funcInfo) valid() bool {</code></span>
<span class="codeline" id="line-748"><code>	return f._func != nil</code></span>
<span class="codeline" id="line-749"><code>}</code></span>
<span class="codeline" id="line-750"><code></code></span>
<span class="codeline" id="line-751"><code>func (f funcInfo) _Func() *Func {</code></span>
<span class="codeline" id="line-752"><code>	return (*Func)(unsafe.Pointer(f._func))</code></span>
<span class="codeline" id="line-753"><code>}</code></span>
<span class="codeline" id="line-754"><code></code></span>
<span class="codeline" id="line-755"><code>// isInlined reports whether f should be re-interpreted as a *funcinl.</code></span>
<span class="codeline" id="line-756"><code>func (f *_func) isInlined() bool {</code></span>
<span class="codeline" id="line-757"><code>	return f.entryOff == ^uint32(0) // see comment for funcinl.ones</code></span>
<span class="codeline" id="line-758"><code>}</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>// entry returns the entry PC for f.</code></span>
<span class="codeline" id="line-761"><code>func (f funcInfo) entry() uintptr {</code></span>
<span class="codeline" id="line-762"><code>	return f.datap.textAddr(f.entryOff)</code></span>
<span class="codeline" id="line-763"><code>}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>// findfunc looks up function metadata for a PC.</code></span>
<span class="codeline" id="line-766"><code>//</code></span>
<span class="codeline" id="line-767"><code>// It is nosplit because it's part of the isgoexception</code></span>
<span class="codeline" id="line-768"><code>// implementation.</code></span>
<span class="codeline" id="line-769"><code>//</code></span>
<span class="codeline" id="line-770"><code>//go:nosplit</code></span>
<span class="codeline" id="line-771"><code>func findfunc(pc uintptr) funcInfo {</code></span>
<span class="codeline" id="line-772"><code>	datap := findmoduledatap(pc)</code></span>
<span class="codeline" id="line-773"><code>	if datap == nil {</code></span>
<span class="codeline" id="line-774"><code>		return funcInfo{}</code></span>
<span class="codeline" id="line-775"><code>	}</code></span>
<span class="codeline" id="line-776"><code>	const nsub = uintptr(len(findfuncbucket{}.subbuckets))</code></span>
<span class="codeline" id="line-777"><code></code></span>
<span class="codeline" id="line-778"><code>	pcOff, ok := datap.textOff(pc)</code></span>
<span class="codeline" id="line-779"><code>	if !ok {</code></span>
<span class="codeline" id="line-780"><code>		return funcInfo{}</code></span>
<span class="codeline" id="line-781"><code>	}</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>	x := uintptr(pcOff) + datap.text - datap.minpc // TODO: are datap.text and datap.minpc always equal?</code></span>
<span class="codeline" id="line-784"><code>	b := x / pcbucketsize</code></span>
<span class="codeline" id="line-785"><code>	i := x % pcbucketsize / (pcbucketsize / nsub)</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{})))</code></span>
<span class="codeline" id="line-788"><code>	idx := ffb.idx + uint32(ffb.subbuckets[i])</code></span>
<span class="codeline" id="line-789"><code></code></span>
<span class="codeline" id="line-790"><code>	// Find the ftab entry.</code></span>
<span class="codeline" id="line-791"><code>	for datap.ftab[idx+1].entryoff &lt;= pcOff {</code></span>
<span class="codeline" id="line-792"><code>		idx++</code></span>
<span class="codeline" id="line-793"><code>	}</code></span>
<span class="codeline" id="line-794"><code></code></span>
<span class="codeline" id="line-795"><code>	funcoff := datap.ftab[idx].funcoff</code></span>
<span class="codeline" id="line-796"><code>	return funcInfo{(*_func)(unsafe.Pointer(&amp;datap.pclntable[funcoff])), datap}</code></span>
<span class="codeline" id="line-797"><code>}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>// A srcFunc represents a logical function in the source code. This may</code></span>
<span class="codeline" id="line-800"><code>// correspond to an actual symbol in the binary text, or it may correspond to a</code></span>
<span class="codeline" id="line-801"><code>// source function that has been inlined.</code></span>
<span class="codeline" id="line-802"><code>type srcFunc struct {</code></span>
<span class="codeline" id="line-803"><code>	datap     *moduledata</code></span>
<span class="codeline" id="line-804"><code>	nameOff   int32</code></span>
<span class="codeline" id="line-805"><code>	startLine int32</code></span>
<span class="codeline" id="line-806"><code>	funcID    abi.FuncID</code></span>
<span class="codeline" id="line-807"><code>}</code></span>
<span class="codeline" id="line-808"><code></code></span>
<span class="codeline" id="line-809"><code>func (f funcInfo) srcFunc() srcFunc {</code></span>
<span class="codeline" id="line-810"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-811"><code>		return srcFunc{}</code></span>
<span class="codeline" id="line-812"><code>	}</code></span>
<span class="codeline" id="line-813"><code>	return srcFunc{f.datap, f.nameOff, f.startLine, f.funcID}</code></span>
<span class="codeline" id="line-814"><code>}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>func (s srcFunc) name() string {</code></span>
<span class="codeline" id="line-817"><code>	if s.datap == nil {</code></span>
<span class="codeline" id="line-818"><code>		return ""</code></span>
<span class="codeline" id="line-819"><code>	}</code></span>
<span class="codeline" id="line-820"><code>	return s.datap.funcName(s.nameOff)</code></span>
<span class="codeline" id="line-821"><code>}</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>type pcvalueCache struct {</code></span>
<span class="codeline" id="line-824"><code>	entries [2][8]pcvalueCacheEnt</code></span>
<span class="codeline" id="line-825"><code>	inUse   int</code></span>
<span class="codeline" id="line-826"><code>}</code></span>
<span class="codeline" id="line-827"><code></code></span>
<span class="codeline" id="line-828"><code>type pcvalueCacheEnt struct {</code></span>
<span class="codeline" id="line-829"><code>	// targetpc and off together are the key of this cache entry.</code></span>
<span class="codeline" id="line-830"><code>	targetpc uintptr</code></span>
<span class="codeline" id="line-831"><code>	off      uint32</code></span>
<span class="codeline" id="line-832"><code></code></span>
<span class="codeline" id="line-833"><code>	val   int32   // The value of this entry.</code></span>
<span class="codeline" id="line-834"><code>	valPC uintptr // The PC at which val starts</code></span>
<span class="codeline" id="line-835"><code>}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>// pcvalueCacheKey returns the outermost index in a pcvalueCache to use for targetpc.</code></span>
<span class="codeline" id="line-838"><code>// It must be very cheap to calculate.</code></span>
<span class="codeline" id="line-839"><code>// For now, align to goarch.PtrSize and reduce mod the number of entries.</code></span>
<span class="codeline" id="line-840"><code>// In practice, this appears to be fairly randomly and evenly distributed.</code></span>
<span class="codeline" id="line-841"><code>func pcvalueCacheKey(targetpc uintptr) uintptr {</code></span>
<span class="codeline" id="line-842"><code>	return (targetpc / goarch.PtrSize) % uintptr(len(pcvalueCache{}.entries))</code></span>
<span class="codeline" id="line-843"><code>}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>// Returns the PCData value, and the PC where this value starts.</code></span>
<span class="codeline" id="line-846"><code>func pcvalue(f funcInfo, off uint32, targetpc uintptr, strict bool) (int32, uintptr) {</code></span>
<span class="codeline" id="line-847"><code>	// If true, when we get a cache hit, still look up the data and make sure it</code></span>
<span class="codeline" id="line-848"><code>	// matches the cached contents.</code></span>
<span class="codeline" id="line-849"><code>	const debugCheckCache = false</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>	if off == 0 {</code></span>
<span class="codeline" id="line-852"><code>		return -1, 0</code></span>
<span class="codeline" id="line-853"><code>	}</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>	// Check the cache. This speeds up walks of deep stacks, which</code></span>
<span class="codeline" id="line-856"><code>	// tend to have the same recursive functions over and over,</code></span>
<span class="codeline" id="line-857"><code>	// or repetitive stacks between goroutines.</code></span>
<span class="codeline" id="line-858"><code>	var checkVal int32</code></span>
<span class="codeline" id="line-859"><code>	var checkPC uintptr</code></span>
<span class="codeline" id="line-860"><code>	ck := pcvalueCacheKey(targetpc)</code></span>
<span class="codeline" id="line-861"><code>	{</code></span>
<span class="codeline" id="line-862"><code>		mp := acquirem()</code></span>
<span class="codeline" id="line-863"><code>		cache := &amp;mp.pcvalueCache</code></span>
<span class="codeline" id="line-864"><code>		// The cache can be used by the signal handler on this M. Avoid</code></span>
<span class="codeline" id="line-865"><code>		// re-entrant use of the cache. The signal handler can also write inUse,</code></span>
<span class="codeline" id="line-866"><code>		// but will always restore its value, so we can use a regular increment</code></span>
<span class="codeline" id="line-867"><code>		// even if we get signaled in the middle of it.</code></span>
<span class="codeline" id="line-868"><code>		cache.inUse++</code></span>
<span class="codeline" id="line-869"><code>		if cache.inUse == 1 {</code></span>
<span class="codeline" id="line-870"><code>			for i := range cache.entries[ck] {</code></span>
<span class="codeline" id="line-871"><code>				// We check off first because we're more</code></span>
<span class="codeline" id="line-872"><code>				// likely to have multiple entries with</code></span>
<span class="codeline" id="line-873"><code>				// different offsets for the same targetpc</code></span>
<span class="codeline" id="line-874"><code>				// than the other way around, so we'll usually</code></span>
<span class="codeline" id="line-875"><code>				// fail in the first clause.</code></span>
<span class="codeline" id="line-876"><code>				ent := &amp;cache.entries[ck][i]</code></span>
<span class="codeline" id="line-877"><code>				if ent.off == off &amp;&amp; ent.targetpc == targetpc {</code></span>
<span class="codeline" id="line-878"><code>					val, pc := ent.val, ent.valPC</code></span>
<span class="codeline" id="line-879"><code>					if debugCheckCache {</code></span>
<span class="codeline" id="line-880"><code>						checkVal, checkPC = ent.val, ent.valPC</code></span>
<span class="codeline" id="line-881"><code>						break</code></span>
<span class="codeline" id="line-882"><code>					} else {</code></span>
<span class="codeline" id="line-883"><code>						cache.inUse--</code></span>
<span class="codeline" id="line-884"><code>						releasem(mp)</code></span>
<span class="codeline" id="line-885"><code>						return val, pc</code></span>
<span class="codeline" id="line-886"><code>					}</code></span>
<span class="codeline" id="line-887"><code>				}</code></span>
<span class="codeline" id="line-888"><code>			}</code></span>
<span class="codeline" id="line-889"><code>		} else if debugCheckCache &amp;&amp; (cache.inUse &lt; 1 || cache.inUse &gt; 2) {</code></span>
<span class="codeline" id="line-890"><code>			// Catch accounting errors or deeply reentrant use. In principle</code></span>
<span class="codeline" id="line-891"><code>			// "inUse" should never exceed 2.</code></span>
<span class="codeline" id="line-892"><code>			throw("cache.inUse out of range")</code></span>
<span class="codeline" id="line-893"><code>		}</code></span>
<span class="codeline" id="line-894"><code>		cache.inUse--</code></span>
<span class="codeline" id="line-895"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-896"><code>	}</code></span>
<span class="codeline" id="line-897"><code></code></span>
<span class="codeline" id="line-898"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-899"><code>		if strict &amp;&amp; panicking.Load() == 0 {</code></span>
<span class="codeline" id="line-900"><code>			println("runtime: no module data for", hex(f.entry()))</code></span>
<span class="codeline" id="line-901"><code>			throw("no module data")</code></span>
<span class="codeline" id="line-902"><code>		}</code></span>
<span class="codeline" id="line-903"><code>		return -1, 0</code></span>
<span class="codeline" id="line-904"><code>	}</code></span>
<span class="codeline" id="line-905"><code>	datap := f.datap</code></span>
<span class="codeline" id="line-906"><code>	p := datap.pctab[off:]</code></span>
<span class="codeline" id="line-907"><code>	pc := f.entry()</code></span>
<span class="codeline" id="line-908"><code>	prevpc := pc</code></span>
<span class="codeline" id="line-909"><code>	val := int32(-1)</code></span>
<span class="codeline" id="line-910"><code>	for {</code></span>
<span class="codeline" id="line-911"><code>		var ok bool</code></span>
<span class="codeline" id="line-912"><code>		p, ok = step(p, &amp;pc, &amp;val, pc == f.entry())</code></span>
<span class="codeline" id="line-913"><code>		if !ok {</code></span>
<span class="codeline" id="line-914"><code>			break</code></span>
<span class="codeline" id="line-915"><code>		}</code></span>
<span class="codeline" id="line-916"><code>		if targetpc &lt; pc {</code></span>
<span class="codeline" id="line-917"><code>			// Replace a random entry in the cache. Random</code></span>
<span class="codeline" id="line-918"><code>			// replacement prevents a performance cliff if</code></span>
<span class="codeline" id="line-919"><code>			// a recursive stack's cycle is slightly</code></span>
<span class="codeline" id="line-920"><code>			// larger than the cache.</code></span>
<span class="codeline" id="line-921"><code>			// Put the new element at the beginning,</code></span>
<span class="codeline" id="line-922"><code>			// since it is the most likely to be newly used.</code></span>
<span class="codeline" id="line-923"><code>			if debugCheckCache &amp;&amp; checkPC != 0 {</code></span>
<span class="codeline" id="line-924"><code>				if checkVal != val || checkPC != prevpc {</code></span>
<span class="codeline" id="line-925"><code>					print("runtime: table value ", val, "@", prevpc, " != cache value ", checkVal, "@", checkPC, " at PC ", targetpc, " off ", off, "\n")</code></span>
<span class="codeline" id="line-926"><code>					throw("bad pcvalue cache")</code></span>
<span class="codeline" id="line-927"><code>				}</code></span>
<span class="codeline" id="line-928"><code>			} else {</code></span>
<span class="codeline" id="line-929"><code>				mp := acquirem()</code></span>
<span class="codeline" id="line-930"><code>				cache := &amp;mp.pcvalueCache</code></span>
<span class="codeline" id="line-931"><code>				cache.inUse++</code></span>
<span class="codeline" id="line-932"><code>				if cache.inUse == 1 {</code></span>
<span class="codeline" id="line-933"><code>					e := &amp;cache.entries[ck]</code></span>
<span class="codeline" id="line-934"><code>					ci := cheaprandn(uint32(len(cache.entries[ck])))</code></span>
<span class="codeline" id="line-935"><code>					e[ci] = e[0]</code></span>
<span class="codeline" id="line-936"><code>					e[0] = pcvalueCacheEnt{</code></span>
<span class="codeline" id="line-937"><code>						targetpc: targetpc,</code></span>
<span class="codeline" id="line-938"><code>						off:      off,</code></span>
<span class="codeline" id="line-939"><code>						val:      val,</code></span>
<span class="codeline" id="line-940"><code>						valPC:    prevpc,</code></span>
<span class="codeline" id="line-941"><code>					}</code></span>
<span class="codeline" id="line-942"><code>				}</code></span>
<span class="codeline" id="line-943"><code>				cache.inUse--</code></span>
<span class="codeline" id="line-944"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-945"><code>			}</code></span>
<span class="codeline" id="line-946"><code></code></span>
<span class="codeline" id="line-947"><code>			return val, prevpc</code></span>
<span class="codeline" id="line-948"><code>		}</code></span>
<span class="codeline" id="line-949"><code>		prevpc = pc</code></span>
<span class="codeline" id="line-950"><code>	}</code></span>
<span class="codeline" id="line-951"><code></code></span>
<span class="codeline" id="line-952"><code>	// If there was a table, it should have covered all program counters.</code></span>
<span class="codeline" id="line-953"><code>	// If not, something is wrong.</code></span>
<span class="codeline" id="line-954"><code>	if panicking.Load() != 0 || !strict {</code></span>
<span class="codeline" id="line-955"><code>		return -1, 0</code></span>
<span class="codeline" id="line-956"><code>	}</code></span>
<span class="codeline" id="line-957"><code></code></span>
<span class="codeline" id="line-958"><code>	print("runtime: invalid pc-encoded table f=", funcname(f), " pc=", hex(pc), " targetpc=", hex(targetpc), " tab=", p, "\n")</code></span>
<span class="codeline" id="line-959"><code></code></span>
<span class="codeline" id="line-960"><code>	p = datap.pctab[off:]</code></span>
<span class="codeline" id="line-961"><code>	pc = f.entry()</code></span>
<span class="codeline" id="line-962"><code>	val = -1</code></span>
<span class="codeline" id="line-963"><code>	for {</code></span>
<span class="codeline" id="line-964"><code>		var ok bool</code></span>
<span class="codeline" id="line-965"><code>		p, ok = step(p, &amp;pc, &amp;val, pc == f.entry())</code></span>
<span class="codeline" id="line-966"><code>		if !ok {</code></span>
<span class="codeline" id="line-967"><code>			break</code></span>
<span class="codeline" id="line-968"><code>		}</code></span>
<span class="codeline" id="line-969"><code>		print("\tvalue=", val, " until pc=", hex(pc), "\n")</code></span>
<span class="codeline" id="line-970"><code>	}</code></span>
<span class="codeline" id="line-971"><code></code></span>
<span class="codeline" id="line-972"><code>	throw("invalid runtime symbol table")</code></span>
<span class="codeline" id="line-973"><code>	return -1, 0</code></span>
<span class="codeline" id="line-974"><code>}</code></span>
<span class="codeline" id="line-975"><code></code></span>
<span class="codeline" id="line-976"><code>func funcname(f funcInfo) string {</code></span>
<span class="codeline" id="line-977"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-978"><code>		return ""</code></span>
<span class="codeline" id="line-979"><code>	}</code></span>
<span class="codeline" id="line-980"><code>	return f.datap.funcName(f.nameOff)</code></span>
<span class="codeline" id="line-981"><code>}</code></span>
<span class="codeline" id="line-982"><code></code></span>
<span class="codeline" id="line-983"><code>func funcpkgpath(f funcInfo) string {</code></span>
<span class="codeline" id="line-984"><code>	name := funcNameForPrint(funcname(f))</code></span>
<span class="codeline" id="line-985"><code>	i := len(name) - 1</code></span>
<span class="codeline" id="line-986"><code>	for ; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-987"><code>		if name[i] == '/' {</code></span>
<span class="codeline" id="line-988"><code>			break</code></span>
<span class="codeline" id="line-989"><code>		}</code></span>
<span class="codeline" id="line-990"><code>	}</code></span>
<span class="codeline" id="line-991"><code>	for ; i &lt; len(name); i++ {</code></span>
<span class="codeline" id="line-992"><code>		if name[i] == '.' {</code></span>
<span class="codeline" id="line-993"><code>			break</code></span>
<span class="codeline" id="line-994"><code>		}</code></span>
<span class="codeline" id="line-995"><code>	}</code></span>
<span class="codeline" id="line-996"><code>	return name[:i]</code></span>
<span class="codeline" id="line-997"><code>}</code></span>
<span class="codeline" id="line-998"><code></code></span>
<span class="codeline" id="line-999"><code>func funcfile(f funcInfo, fileno int32) string {</code></span>
<span class="codeline" id="line-1000"><code>	datap := f.datap</code></span>
<span class="codeline" id="line-1001"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-1002"><code>		return "?"</code></span>
<span class="codeline" id="line-1003"><code>	}</code></span>
<span class="codeline" id="line-1004"><code>	// Make sure the cu index and file offset are valid</code></span>
<span class="codeline" id="line-1005"><code>	if fileoff := datap.cutab[f.cuOffset+uint32(fileno)]; fileoff != ^uint32(0) {</code></span>
<span class="codeline" id="line-1006"><code>		return gostringnocopy(&amp;datap.filetab[fileoff])</code></span>
<span class="codeline" id="line-1007"><code>	}</code></span>
<span class="codeline" id="line-1008"><code>	// pcln section is corrupt.</code></span>
<span class="codeline" id="line-1009"><code>	return "?"</code></span>
<span class="codeline" id="line-1010"><code>}</code></span>
<span class="codeline" id="line-1011"><code></code></span>
<span class="codeline" id="line-1012"><code>func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32) {</code></span>
<span class="codeline" id="line-1013"><code>	datap := f.datap</code></span>
<span class="codeline" id="line-1014"><code>	if !f.valid() {</code></span>
<span class="codeline" id="line-1015"><code>		return "?", 0</code></span>
<span class="codeline" id="line-1016"><code>	}</code></span>
<span class="codeline" id="line-1017"><code>	fileno, _ := pcvalue(f, f.pcfile, targetpc, strict)</code></span>
<span class="codeline" id="line-1018"><code>	line, _ = pcvalue(f, f.pcln, targetpc, strict)</code></span>
<span class="codeline" id="line-1019"><code>	if fileno == -1 || line == -1 || int(fileno) &gt;= len(datap.filetab) {</code></span>
<span class="codeline" id="line-1020"><code>		// print("looking for ", hex(targetpc), " in ", funcname(f), " got file=", fileno, " line=", lineno, "\n")</code></span>
<span class="codeline" id="line-1021"><code>		return "?", 0</code></span>
<span class="codeline" id="line-1022"><code>	}</code></span>
<span class="codeline" id="line-1023"><code>	file = funcfile(f, fileno)</code></span>
<span class="codeline" id="line-1024"><code>	return</code></span>
<span class="codeline" id="line-1025"><code>}</code></span>
<span class="codeline" id="line-1026"><code></code></span>
<span class="codeline" id="line-1027"><code>func funcline(f funcInfo, targetpc uintptr) (file string, line int32) {</code></span>
<span class="codeline" id="line-1028"><code>	return funcline1(f, targetpc, true)</code></span>
<span class="codeline" id="line-1029"><code>}</code></span>
<span class="codeline" id="line-1030"><code></code></span>
<span class="codeline" id="line-1031"><code>func funcspdelta(f funcInfo, targetpc uintptr) int32 {</code></span>
<span class="codeline" id="line-1032"><code>	x, _ := pcvalue(f, f.pcsp, targetpc, true)</code></span>
<span class="codeline" id="line-1033"><code>	if debugPcln &amp;&amp; x&amp;(goarch.PtrSize-1) != 0 {</code></span>
<span class="codeline" id="line-1034"><code>		print("invalid spdelta ", funcname(f), " ", hex(f.entry()), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")</code></span>
<span class="codeline" id="line-1035"><code>		throw("bad spdelta")</code></span>
<span class="codeline" id="line-1036"><code>	}</code></span>
<span class="codeline" id="line-1037"><code>	return x</code></span>
<span class="codeline" id="line-1038"><code>}</code></span>
<span class="codeline" id="line-1039"><code></code></span>
<span class="codeline" id="line-1040"><code>// funcMaxSPDelta returns the maximum spdelta at any point in f.</code></span>
<span class="codeline" id="line-1041"><code>func funcMaxSPDelta(f funcInfo) int32 {</code></span>
<span class="codeline" id="line-1042"><code>	datap := f.datap</code></span>
<span class="codeline" id="line-1043"><code>	p := datap.pctab[f.pcsp:]</code></span>
<span class="codeline" id="line-1044"><code>	pc := f.entry()</code></span>
<span class="codeline" id="line-1045"><code>	val := int32(-1)</code></span>
<span class="codeline" id="line-1046"><code>	most := int32(0)</code></span>
<span class="codeline" id="line-1047"><code>	for {</code></span>
<span class="codeline" id="line-1048"><code>		var ok bool</code></span>
<span class="codeline" id="line-1049"><code>		p, ok = step(p, &amp;pc, &amp;val, pc == f.entry())</code></span>
<span class="codeline" id="line-1050"><code>		if !ok {</code></span>
<span class="codeline" id="line-1051"><code>			return most</code></span>
<span class="codeline" id="line-1052"><code>		}</code></span>
<span class="codeline" id="line-1053"><code>		most = max(most, val)</code></span>
<span class="codeline" id="line-1054"><code>	}</code></span>
<span class="codeline" id="line-1055"><code>}</code></span>
<span class="codeline" id="line-1056"><code></code></span>
<span class="codeline" id="line-1057"><code>func pcdatastart(f funcInfo, table uint32) uint32 {</code></span>
<span class="codeline" id="line-1058"><code>	return *(*uint32)(add(unsafe.Pointer(&amp;f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))</code></span>
<span class="codeline" id="line-1059"><code>}</code></span>
<span class="codeline" id="line-1060"><code></code></span>
<span class="codeline" id="line-1061"><code>func pcdatavalue(f funcInfo, table uint32, targetpc uintptr) int32 {</code></span>
<span class="codeline" id="line-1062"><code>	if table &gt;= f.npcdata {</code></span>
<span class="codeline" id="line-1063"><code>		return -1</code></span>
<span class="codeline" id="line-1064"><code>	}</code></span>
<span class="codeline" id="line-1065"><code>	r, _ := pcvalue(f, pcdatastart(f, table), targetpc, true)</code></span>
<span class="codeline" id="line-1066"><code>	return r</code></span>
<span class="codeline" id="line-1067"><code>}</code></span>
<span class="codeline" id="line-1068"><code></code></span>
<span class="codeline" id="line-1069"><code>func pcdatavalue1(f funcInfo, table uint32, targetpc uintptr, strict bool) int32 {</code></span>
<span class="codeline" id="line-1070"><code>	if table &gt;= f.npcdata {</code></span>
<span class="codeline" id="line-1071"><code>		return -1</code></span>
<span class="codeline" id="line-1072"><code>	}</code></span>
<span class="codeline" id="line-1073"><code>	r, _ := pcvalue(f, pcdatastart(f, table), targetpc, strict)</code></span>
<span class="codeline" id="line-1074"><code>	return r</code></span>
<span class="codeline" id="line-1075"><code>}</code></span>
<span class="codeline" id="line-1076"><code></code></span>
<span class="codeline" id="line-1077"><code>// Like pcdatavalue, but also return the start PC of this PCData value.</code></span>
<span class="codeline" id="line-1078"><code>func pcdatavalue2(f funcInfo, table uint32, targetpc uintptr) (int32, uintptr) {</code></span>
<span class="codeline" id="line-1079"><code>	if table &gt;= f.npcdata {</code></span>
<span class="codeline" id="line-1080"><code>		return -1, 0</code></span>
<span class="codeline" id="line-1081"><code>	}</code></span>
<span class="codeline" id="line-1082"><code>	return pcvalue(f, pcdatastart(f, table), targetpc, true)</code></span>
<span class="codeline" id="line-1083"><code>}</code></span>
<span class="codeline" id="line-1084"><code></code></span>
<span class="codeline" id="line-1085"><code>// funcdata returns a pointer to the ith funcdata for f.</code></span>
<span class="codeline" id="line-1086"><code>// funcdata should be kept in sync with cmd/link:writeFuncs.</code></span>
<span class="codeline" id="line-1087"><code>func funcdata(f funcInfo, i uint8) unsafe.Pointer {</code></span>
<span class="codeline" id="line-1088"><code>	if i &lt; 0 || i &gt;= f.nfuncdata {</code></span>
<span class="codeline" id="line-1089"><code>		return nil</code></span>
<span class="codeline" id="line-1090"><code>	}</code></span>
<span class="codeline" id="line-1091"><code>	base := f.datap.gofunc // load gofunc address early so that we calculate during cache misses</code></span>
<span class="codeline" id="line-1092"><code>	p := uintptr(unsafe.Pointer(&amp;f.nfuncdata)) + unsafe.Sizeof(f.nfuncdata) + uintptr(f.npcdata)*4 + uintptr(i)*4</code></span>
<span class="codeline" id="line-1093"><code>	off := *(*uint32)(unsafe.Pointer(p))</code></span>
<span class="codeline" id="line-1094"><code>	// Return off == ^uint32(0) ? 0 : f.datap.gofunc + uintptr(off), but without branches.</code></span>
<span class="codeline" id="line-1095"><code>	// The compiler calculates mask on most architectures using conditional assignment.</code></span>
<span class="codeline" id="line-1096"><code>	var mask uintptr</code></span>
<span class="codeline" id="line-1097"><code>	if off == ^uint32(0) {</code></span>
<span class="codeline" id="line-1098"><code>		mask = 1</code></span>
<span class="codeline" id="line-1099"><code>	}</code></span>
<span class="codeline" id="line-1100"><code>	mask--</code></span>
<span class="codeline" id="line-1101"><code>	raw := base + uintptr(off)</code></span>
<span class="codeline" id="line-1102"><code>	return unsafe.Pointer(raw &amp; mask)</code></span>
<span class="codeline" id="line-1103"><code>}</code></span>
<span class="codeline" id="line-1104"><code></code></span>
<span class="codeline" id="line-1105"><code>// step advances to the next pc, value pair in the encoded table.</code></span>
<span class="codeline" id="line-1106"><code>func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {</code></span>
<span class="codeline" id="line-1107"><code>	// For both uvdelta and pcdelta, the common case (~70%)</code></span>
<span class="codeline" id="line-1108"><code>	// is that they are a single byte. If so, avoid calling readvarint.</code></span>
<span class="codeline" id="line-1109"><code>	uvdelta := uint32(p[0])</code></span>
<span class="codeline" id="line-1110"><code>	if uvdelta == 0 &amp;&amp; !first {</code></span>
<span class="codeline" id="line-1111"><code>		return nil, false</code></span>
<span class="codeline" id="line-1112"><code>	}</code></span>
<span class="codeline" id="line-1113"><code>	n := uint32(1)</code></span>
<span class="codeline" id="line-1114"><code>	if uvdelta&amp;0x80 != 0 {</code></span>
<span class="codeline" id="line-1115"><code>		n, uvdelta = readvarint(p)</code></span>
<span class="codeline" id="line-1116"><code>	}</code></span>
<span class="codeline" id="line-1117"><code>	*val += int32(-(uvdelta &amp; 1) ^ (uvdelta &gt;&gt; 1))</code></span>
<span class="codeline" id="line-1118"><code>	p = p[n:]</code></span>
<span class="codeline" id="line-1119"><code></code></span>
<span class="codeline" id="line-1120"><code>	pcdelta := uint32(p[0])</code></span>
<span class="codeline" id="line-1121"><code>	n = 1</code></span>
<span class="codeline" id="line-1122"><code>	if pcdelta&amp;0x80 != 0 {</code></span>
<span class="codeline" id="line-1123"><code>		n, pcdelta = readvarint(p)</code></span>
<span class="codeline" id="line-1124"><code>	}</code></span>
<span class="codeline" id="line-1125"><code>	p = p[n:]</code></span>
<span class="codeline" id="line-1126"><code>	*pc += uintptr(pcdelta * sys.PCQuantum)</code></span>
<span class="codeline" id="line-1127"><code>	return p, true</code></span>
<span class="codeline" id="line-1128"><code>}</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>// readvarint reads a varint from p.</code></span>
<span class="codeline" id="line-1131"><code>func readvarint(p []byte) (read uint32, val uint32) {</code></span>
<span class="codeline" id="line-1132"><code>	var v, shift, n uint32</code></span>
<span class="codeline" id="line-1133"><code>	for {</code></span>
<span class="codeline" id="line-1134"><code>		b := p[n]</code></span>
<span class="codeline" id="line-1135"><code>		n++</code></span>
<span class="codeline" id="line-1136"><code>		v |= uint32(b&amp;0x7F) &lt;&lt; (shift &amp; 31)</code></span>
<span class="codeline" id="line-1137"><code>		if b&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-1138"><code>			break</code></span>
<span class="codeline" id="line-1139"><code>		}</code></span>
<span class="codeline" id="line-1140"><code>		shift += 7</code></span>
<span class="codeline" id="line-1141"><code>	}</code></span>
<span class="codeline" id="line-1142"><code>	return n, v</code></span>
<span class="codeline" id="line-1143"><code>}</code></span>
<span class="codeline" id="line-1144"><code></code></span>
<span class="codeline" id="line-1145"><code>type stackmap struct {</code></span>
<span class="codeline" id="line-1146"><code>	n        int32   // number of bitmaps</code></span>
<span class="codeline" id="line-1147"><code>	nbit     int32   // number of bits in each bitmap</code></span>
<span class="codeline" id="line-1148"><code>	bytedata [1]byte // bitmaps, each starting on a byte boundary</code></span>
<span class="codeline" id="line-1149"><code>}</code></span>
<span class="codeline" id="line-1150"><code></code></span>
<span class="codeline" id="line-1151"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-1152"><code>func stackmapdata(stkmap *stackmap, n int32) bitvector {</code></span>
<span class="codeline" id="line-1153"><code>	// Check this invariant only when stackDebug is on at all.</code></span>
<span class="codeline" id="line-1154"><code>	// The invariant is already checked by many of stackmapdata's callers,</code></span>
<span class="codeline" id="line-1155"><code>	// and disabling it by default allows stackmapdata to be inlined.</code></span>
<span class="codeline" id="line-1156"><code>	if stackDebug &gt; 0 &amp;&amp; (n &lt; 0 || n &gt;= stkmap.n) {</code></span>
<span class="codeline" id="line-1157"><code>		throw("stackmapdata: index out of range")</code></span>
<span class="codeline" id="line-1158"><code>	}</code></span>
<span class="codeline" id="line-1159"><code>	return bitvector{stkmap.nbit, addb(&amp;stkmap.bytedata[0], uintptr(n*((stkmap.nbit+7)&gt;&gt;3)))}</code></span>
<span class="codeline" id="line-1160"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>