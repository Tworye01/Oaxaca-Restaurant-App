<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: trace2.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	trace2.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2023 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>//go:build goexperiment.exectracer2</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// Go execution tracer.</code></span>
<span class="codeline" id="line-8"><code>// The tracer captures a wide range of execution events like goroutine</code></span>
<span class="codeline" id="line-9"><code>// creation/blocking/unblocking, syscall enter/exit/block, GC-related events,</code></span>
<span class="codeline" id="line-10"><code>// changes of heap size, processor start/stop, etc and writes them to a buffer</code></span>
<span class="codeline" id="line-11"><code>// in a compact form. A precise nanosecond-precision timestamp and a stack</code></span>
<span class="codeline" id="line-12"><code>// trace is captured for most events.</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// Tracer invariants (to keep the synchronization making sense):</code></span>
<span class="codeline" id="line-15"><code>// - An m that has a trace buffer must be on either the allm or sched.freem lists.</code></span>
<span class="codeline" id="line-16"><code>// - Any trace buffer mutation must either be happening in traceAdvance or between</code></span>
<span class="codeline" id="line-17"><code>//   a traceAcquire and a subsequent traceRelease.</code></span>
<span class="codeline" id="line-18"><code>// - traceAdvance cannot return until the previous generation's buffers are all flushed.</code></span>
<span class="codeline" id="line-19"><code>//</code></span>
<span class="codeline" id="line-20"><code>// See https://go.dev/issue/60773 for a link to the full design.</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>package runtime</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>import (</code></span>
<span class="codeline" id="line-25"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-26"><code>	"unsafe"</code></span>
<span class="codeline" id="line-27"><code>)</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// Trace state.</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// trace is global tracing context.</code></span>
<span class="codeline" id="line-32"><code>var trace struct {</code></span>
<span class="codeline" id="line-33"><code>	// trace.lock must only be acquired on the system stack where</code></span>
<span class="codeline" id="line-34"><code>	// stack splits cannot happen while it is held.</code></span>
<span class="codeline" id="line-35"><code>	lock mutex</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>	// Trace buffer management.</code></span>
<span class="codeline" id="line-38"><code>	//</code></span>
<span class="codeline" id="line-39"><code>	// First we check the empty list for any free buffers. If not, buffers</code></span>
<span class="codeline" id="line-40"><code>	// are allocated directly from the OS. Once they're filled up and/or</code></span>
<span class="codeline" id="line-41"><code>	// flushed, they end up on the full queue for trace.gen%2.</code></span>
<span class="codeline" id="line-42"><code>	//</code></span>
<span class="codeline" id="line-43"><code>	// The trace reader takes buffers off the full list one-by-one and</code></span>
<span class="codeline" id="line-44"><code>	// places them into reading until they're finished being read from.</code></span>
<span class="codeline" id="line-45"><code>	// Then they're placed onto the empty list.</code></span>
<span class="codeline" id="line-46"><code>	//</code></span>
<span class="codeline" id="line-47"><code>	// Protected by trace.lock.</code></span>
<span class="codeline" id="line-48"><code>	reading       *traceBuf // buffer currently handed off to user</code></span>
<span class="codeline" id="line-49"><code>	empty         *traceBuf // stack of empty buffers</code></span>
<span class="codeline" id="line-50"><code>	full          [2]traceBufQueue</code></span>
<span class="codeline" id="line-51"><code>	workAvailable atomic.Bool</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>	// State for the trace reader goroutine.</code></span>
<span class="codeline" id="line-54"><code>	//</code></span>
<span class="codeline" id="line-55"><code>	// Protected by trace.lock.</code></span>
<span class="codeline" id="line-56"><code>	readerGen     atomic.Uintptr // the generation the reader is currently reading for</code></span>
<span class="codeline" id="line-57"><code>	flushedGen    atomic.Uintptr // the last completed generation</code></span>
<span class="codeline" id="line-58"><code>	headerWritten bool           // whether ReadTrace has emitted trace header</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	// doneSema is used to synchronize the reader and traceAdvance. Specifically,</code></span>
<span class="codeline" id="line-61"><code>	// it notifies traceAdvance that the reader is done with a generation.</code></span>
<span class="codeline" id="line-62"><code>	// Both semaphores are 0 by default (so, acquires block). traceAdvance</code></span>
<span class="codeline" id="line-63"><code>	// attempts to acquire for gen%2 after flushing the last buffers for gen.</code></span>
<span class="codeline" id="line-64"><code>	// Meanwhile the reader releases the sema for gen%2 when it has finished</code></span>
<span class="codeline" id="line-65"><code>	// processing gen.</code></span>
<span class="codeline" id="line-66"><code>	doneSema [2]uint32</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>	// Trace data tables for deduplicating data going into the trace.</code></span>
<span class="codeline" id="line-69"><code>	// There are 2 of each: one for gen%2, one for 1-gen%2.</code></span>
<span class="codeline" id="line-70"><code>	stackTab  [2]traceStackTable  // maps stack traces to unique ids</code></span>
<span class="codeline" id="line-71"><code>	stringTab [2]traceStringTable // maps strings to unique ids</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>	// cpuLogRead accepts CPU profile samples from the signal handler where</code></span>
<span class="codeline" id="line-74"><code>	// they're generated. There are two profBufs here: one for gen%2, one for</code></span>
<span class="codeline" id="line-75"><code>	// 1-gen%2. These profBufs use a three-word header to hold the IDs of the P, G,</code></span>
<span class="codeline" id="line-76"><code>	// and M (respectively) that were active at the time of the sample. Because</code></span>
<span class="codeline" id="line-77"><code>	// profBuf uses a record with all zeros in its header to indicate overflow,</code></span>
<span class="codeline" id="line-78"><code>	// we make sure to make the P field always non-zero: The ID of a real P will</code></span>
<span class="codeline" id="line-79"><code>	// start at bit 1, and bit 0 will be set. Samples that arrive while no P is</code></span>
<span class="codeline" id="line-80"><code>	// running (such as near syscalls) will set the first header field to 0b10.</code></span>
<span class="codeline" id="line-81"><code>	// This careful handling of the first header field allows us to store ID of</code></span>
<span class="codeline" id="line-82"><code>	// the active G directly in the second field, even though that will be 0</code></span>
<span class="codeline" id="line-83"><code>	// when sampling g0.</code></span>
<span class="codeline" id="line-84"><code>	//</code></span>
<span class="codeline" id="line-85"><code>	// Initialization and teardown of these fields is protected by traceAdvanceSema.</code></span>
<span class="codeline" id="line-86"><code>	cpuLogRead  [2]*profBuf</code></span>
<span class="codeline" id="line-87"><code>	signalLock  atomic.Uint32              // protects use of the following member, only usable in signal handlers</code></span>
<span class="codeline" id="line-88"><code>	cpuLogWrite [2]atomic.Pointer[profBuf] // copy of cpuLogRead for use in signal handlers, set without signalLock</code></span>
<span class="codeline" id="line-89"><code>	cpuSleep    *wakeableSleep</code></span>
<span class="codeline" id="line-90"><code>	cpuLogDone  &lt;-chan struct{}</code></span>
<span class="codeline" id="line-91"><code>	cpuBuf      [2]*traceBuf</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>	reader atomic.Pointer[g] // goroutine that called ReadTrace, or nil</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>	// Fast mappings from enumerations to string IDs that are prepopulated</code></span>
<span class="codeline" id="line-96"><code>	// in the trace.</code></span>
<span class="codeline" id="line-97"><code>	markWorkerLabels [2][len(gcMarkWorkerModeStrings)]traceArg</code></span>
<span class="codeline" id="line-98"><code>	goStopReasons    [2][len(traceGoStopReasonStrings)]traceArg</code></span>
<span class="codeline" id="line-99"><code>	goBlockReasons   [2][len(traceBlockReasonStrings)]traceArg</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>	// Trace generation counter.</code></span>
<span class="codeline" id="line-102"><code>	gen            atomic.Uintptr</code></span>
<span class="codeline" id="line-103"><code>	lastNonZeroGen uintptr // last non-zero value of gen</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>	// shutdown is set when we are waiting for trace reader to finish after setting gen to 0</code></span>
<span class="codeline" id="line-106"><code>	//</code></span>
<span class="codeline" id="line-107"><code>	// Writes protected by trace.lock.</code></span>
<span class="codeline" id="line-108"><code>	shutdown atomic.Bool</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>	// Number of goroutines in syscall exiting slow path.</code></span>
<span class="codeline" id="line-111"><code>	exitingSyscall atomic.Int32</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>	// seqGC is the sequence counter for GC begin/end.</code></span>
<span class="codeline" id="line-114"><code>	//</code></span>
<span class="codeline" id="line-115"><code>	// Mutated only during stop-the-world.</code></span>
<span class="codeline" id="line-116"><code>	seqGC uint64</code></span>
<span class="codeline" id="line-117"><code>}</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>// Trace public API.</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>var (</code></span>
<span class="codeline" id="line-122"><code>	traceAdvanceSema  uint32 = 1</code></span>
<span class="codeline" id="line-123"><code>	traceShutdownSema uint32 = 1</code></span>
<span class="codeline" id="line-124"><code>)</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>// StartTrace enables tracing for the current process.</code></span>
<span class="codeline" id="line-127"><code>// While tracing, the data will be buffered and available via [ReadTrace].</code></span>
<span class="codeline" id="line-128"><code>// StartTrace returns an error if tracing is already enabled.</code></span>
<span class="codeline" id="line-129"><code>// Most clients should use the [runtime/trace] package or the [testing] package's</code></span>
<span class="codeline" id="line-130"><code>// -test.trace flag instead of calling StartTrace directly.</code></span>
<span class="codeline" id="line-131"><code>func StartTrace() error {</code></span>
<span class="codeline" id="line-132"><code>	if traceEnabled() || traceShuttingDown() {</code></span>
<span class="codeline" id="line-133"><code>		return errorString("tracing is already enabled")</code></span>
<span class="codeline" id="line-134"><code>	}</code></span>
<span class="codeline" id="line-135"><code>	// Block until cleanup of the last trace is done.</code></span>
<span class="codeline" id="line-136"><code>	semacquire(&amp;traceShutdownSema)</code></span>
<span class="codeline" id="line-137"><code>	semrelease(&amp;traceShutdownSema)</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>	// Hold traceAdvanceSema across trace start, since we'll want it on</code></span>
<span class="codeline" id="line-140"><code>	// the other side of tracing being enabled globally.</code></span>
<span class="codeline" id="line-141"><code>	semacquire(&amp;traceAdvanceSema)</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>	// Initialize CPU profile -&gt; trace ingestion.</code></span>
<span class="codeline" id="line-144"><code>	traceInitReadCPU()</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	// Compute the first generation for this StartTrace.</code></span>
<span class="codeline" id="line-147"><code>	//</code></span>
<span class="codeline" id="line-148"><code>	// Note: we start from the last non-zero generation rather than 1 so we</code></span>
<span class="codeline" id="line-149"><code>	// can avoid resetting all the arrays indexed by gen%2 or gen%3. There's</code></span>
<span class="codeline" id="line-150"><code>	// more than one of each per m, p, and goroutine.</code></span>
<span class="codeline" id="line-151"><code>	firstGen := traceNextGen(trace.lastNonZeroGen)</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>	// Reset GC sequencer.</code></span>
<span class="codeline" id="line-154"><code>	trace.seqGC = 1</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>	// Reset trace reader state.</code></span>
<span class="codeline" id="line-157"><code>	trace.headerWritten = false</code></span>
<span class="codeline" id="line-158"><code>	trace.readerGen.Store(firstGen)</code></span>
<span class="codeline" id="line-159"><code>	trace.flushedGen.Store(0)</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	// Register some basic strings in the string tables.</code></span>
<span class="codeline" id="line-162"><code>	traceRegisterLabelsAndReasons(firstGen)</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	// Stop the world.</code></span>
<span class="codeline" id="line-165"><code>	//</code></span>
<span class="codeline" id="line-166"><code>	// The purpose of stopping the world is to make sure that no goroutine is in a</code></span>
<span class="codeline" id="line-167"><code>	// context where it could emit an event by bringing all goroutines to a safe point</code></span>
<span class="codeline" id="line-168"><code>	// with no opportunity to transition.</code></span>
<span class="codeline" id="line-169"><code>	//</code></span>
<span class="codeline" id="line-170"><code>	// The exception to this rule are goroutines that are concurrently exiting a syscall.</code></span>
<span class="codeline" id="line-171"><code>	// Those will all be forced into the syscalling slow path, and we'll just make sure</code></span>
<span class="codeline" id="line-172"><code>	// that we don't observe any goroutines in that critical section before starting</code></span>
<span class="codeline" id="line-173"><code>	// the world again.</code></span>
<span class="codeline" id="line-174"><code>	//</code></span>
<span class="codeline" id="line-175"><code>	// A good follow-up question to this is why stopping the world is necessary at all</code></span>
<span class="codeline" id="line-176"><code>	// given that we have traceAcquire and traceRelease. Unfortunately, those only help</code></span>
<span class="codeline" id="line-177"><code>	// us when tracing is already active (for performance, so when tracing is off the</code></span>
<span class="codeline" id="line-178"><code>	// tracing seqlock is left untouched). The main issue here is subtle: we're going to</code></span>
<span class="codeline" id="line-179"><code>	// want to obtain a correct starting status for each goroutine, but there are windows</code></span>
<span class="codeline" id="line-180"><code>	// of time in which we could read and emit an incorrect status. Specifically:</code></span>
<span class="codeline" id="line-181"><code>	//</code></span>
<span class="codeline" id="line-182"><code>	//	trace := traceAcquire()</code></span>
<span class="codeline" id="line-183"><code>	//  // &lt;----&gt; problem window</code></span>
<span class="codeline" id="line-184"><code>	//	casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-185"><code>	//	if trace.ok() {</code></span>
<span class="codeline" id="line-186"><code>	//		trace.GoUnpark(gp, 2)</code></span>
<span class="codeline" id="line-187"><code>	//		traceRelease(trace)</code></span>
<span class="codeline" id="line-188"><code>	//	}</code></span>
<span class="codeline" id="line-189"><code>	//</code></span>
<span class="codeline" id="line-190"><code>	// More precisely, if we readgstatus for a gp while another goroutine is in the problem</code></span>
<span class="codeline" id="line-191"><code>	// window and that goroutine didn't observe that tracing had begun, then we might write</code></span>
<span class="codeline" id="line-192"><code>	// a GoStatus(GoWaiting) event for that goroutine, but it won't trace an event marking</code></span>
<span class="codeline" id="line-193"><code>	// the transition from GoWaiting to GoRunnable. The trace will then be broken, because</code></span>
<span class="codeline" id="line-194"><code>	// future events will be emitted assuming the tracer sees GoRunnable.</code></span>
<span class="codeline" id="line-195"><code>	//</code></span>
<span class="codeline" id="line-196"><code>	// In short, what we really need here is to make sure that the next time *any goroutine*</code></span>
<span class="codeline" id="line-197"><code>	// hits a traceAcquire, it sees that the trace is enabled.</code></span>
<span class="codeline" id="line-198"><code>	//</code></span>
<span class="codeline" id="line-199"><code>	// Note also that stopping the world is necessary to make sure sweep-related events are</code></span>
<span class="codeline" id="line-200"><code>	// coherent. Since the world is stopped and sweeps are non-preemptible, we can never start</code></span>
<span class="codeline" id="line-201"><code>	// the world and see an unpaired sweep 'end' event. Other parts of the tracer rely on this.</code></span>
<span class="codeline" id="line-202"><code>	stw := stopTheWorld(stwStartTrace)</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	// Prevent sysmon from running any code that could generate events.</code></span>
<span class="codeline" id="line-205"><code>	lock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>	// Reset mSyscallID on all Ps while we have them stationary and the trace is disabled.</code></span>
<span class="codeline" id="line-208"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-209"><code>		pp.trace.mSyscallID = -1</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	// Start tracing.</code></span>
<span class="codeline" id="line-213"><code>	//</code></span>
<span class="codeline" id="line-214"><code>	// After this executes, other Ms may start creating trace buffers and emitting</code></span>
<span class="codeline" id="line-215"><code>	// data into them.</code></span>
<span class="codeline" id="line-216"><code>	trace.gen.Store(firstGen)</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>	// Wait for exitingSyscall to drain.</code></span>
<span class="codeline" id="line-219"><code>	//</code></span>
<span class="codeline" id="line-220"><code>	// It may not monotonically decrease to zero, but in the limit it will always become</code></span>
<span class="codeline" id="line-221"><code>	// zero because the world is stopped and there are no available Ps for syscall-exited</code></span>
<span class="codeline" id="line-222"><code>	// goroutines to run on.</code></span>
<span class="codeline" id="line-223"><code>	//</code></span>
<span class="codeline" id="line-224"><code>	// Because we set gen before checking this, and because exitingSyscall is always incremented</code></span>
<span class="codeline" id="line-225"><code>	// *after* traceAcquire (which checks gen), we can be certain that when exitingSyscall is zero</code></span>
<span class="codeline" id="line-226"><code>	// that any goroutine that goes to exit a syscall from then on *must* observe the new gen.</code></span>
<span class="codeline" id="line-227"><code>	//</code></span>
<span class="codeline" id="line-228"><code>	// The critical section on each goroutine here is going to be quite short, so the likelihood</code></span>
<span class="codeline" id="line-229"><code>	// that we observe a zero value is high.</code></span>
<span class="codeline" id="line-230"><code>	for trace.exitingSyscall.Load() != 0 {</code></span>
<span class="codeline" id="line-231"><code>		osyield()</code></span>
<span class="codeline" id="line-232"><code>	}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>	// Record some initial pieces of information.</code></span>
<span class="codeline" id="line-235"><code>	//</code></span>
<span class="codeline" id="line-236"><code>	// N.B. This will also emit a status event for this goroutine.</code></span>
<span class="codeline" id="line-237"><code>	tl := traceAcquire()</code></span>
<span class="codeline" id="line-238"><code>	tl.Gomaxprocs(gomaxprocs)  // Get this as early in the trace as possible. See comment in traceAdvance.</code></span>
<span class="codeline" id="line-239"><code>	tl.STWStart(stwStartTrace) // We didn't trace this above, so trace it now.</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	// Record the fact that a GC is active, if applicable.</code></span>
<span class="codeline" id="line-242"><code>	if gcphase == _GCmark || gcphase == _GCmarktermination {</code></span>
<span class="codeline" id="line-243"><code>		tl.GCActive()</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	// Record the heap goal so we have it at the very beginning of the trace.</code></span>
<span class="codeline" id="line-247"><code>	tl.HeapGoal()</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>	// Make sure a ProcStatus is emitted for every P, while we're here.</code></span>
<span class="codeline" id="line-250"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-251"><code>		tl.writer().writeProcStatusForP(pp, pp == tl.mp.p.ptr()).end()</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code>	traceRelease(tl)</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>	unlock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-256"><code>	startTheWorld(stw)</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>	traceStartReadCPU()</code></span>
<span class="codeline" id="line-259"><code>	traceAdvancer.start()</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>	semrelease(&amp;traceAdvanceSema)</code></span>
<span class="codeline" id="line-262"><code>	return nil</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// StopTrace stops tracing, if it was previously enabled.</code></span>
<span class="codeline" id="line-266"><code>// StopTrace only returns after all the reads for the trace have completed.</code></span>
<span class="codeline" id="line-267"><code>func StopTrace() {</code></span>
<span class="codeline" id="line-268"><code>	traceAdvance(true)</code></span>
<span class="codeline" id="line-269"><code>}</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>// traceAdvance moves tracing to the next generation, and cleans up the current generation,</code></span>
<span class="codeline" id="line-272"><code>// ensuring that it's flushed out before returning. If stopTrace is true, it disables tracing</code></span>
<span class="codeline" id="line-273"><code>// altogether instead of advancing to the next generation.</code></span>
<span class="codeline" id="line-274"><code>//</code></span>
<span class="codeline" id="line-275"><code>// traceAdvanceSema must not be held.</code></span>
<span class="codeline" id="line-276"><code>func traceAdvance(stopTrace bool) {</code></span>
<span class="codeline" id="line-277"><code>	semacquire(&amp;traceAdvanceSema)</code></span>
<span class="codeline" id="line-278"><code></code></span>
<span class="codeline" id="line-279"><code>	// Get the gen that we're advancing from. In this function we don't really care much</code></span>
<span class="codeline" id="line-280"><code>	// about the generation we're advancing _into_ since we'll do all the cleanup in this</code></span>
<span class="codeline" id="line-281"><code>	// generation for the next advancement.</code></span>
<span class="codeline" id="line-282"><code>	gen := trace.gen.Load()</code></span>
<span class="codeline" id="line-283"><code>	if gen == 0 {</code></span>
<span class="codeline" id="line-284"><code>		// We may end up here traceAdvance is called concurrently with StopTrace.</code></span>
<span class="codeline" id="line-285"><code>		semrelease(&amp;traceAdvanceSema)</code></span>
<span class="codeline" id="line-286"><code>		return</code></span>
<span class="codeline" id="line-287"><code>	}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>	// Write an EvFrequency event for this generation.</code></span>
<span class="codeline" id="line-290"><code>	//</code></span>
<span class="codeline" id="line-291"><code>	// N.B. This may block for quite a while to get a good frequency estimate, so make sure we do</code></span>
<span class="codeline" id="line-292"><code>	// this here and not e.g. on the trace reader.</code></span>
<span class="codeline" id="line-293"><code>	traceFrequency(gen)</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>	// Collect all the untraced Gs.</code></span>
<span class="codeline" id="line-296"><code>	type untracedG struct {</code></span>
<span class="codeline" id="line-297"><code>		gp           *g</code></span>
<span class="codeline" id="line-298"><code>		goid         uint64</code></span>
<span class="codeline" id="line-299"><code>		mid          int64</code></span>
<span class="codeline" id="line-300"><code>		status       uint32</code></span>
<span class="codeline" id="line-301"><code>		waitreason   waitReason</code></span>
<span class="codeline" id="line-302"><code>		inMarkAssist bool</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code>	var untracedGs []untracedG</code></span>
<span class="codeline" id="line-305"><code>	forEachGRace(func(gp *g) {</code></span>
<span class="codeline" id="line-306"><code>		// Make absolutely sure all Gs are ready for the next</code></span>
<span class="codeline" id="line-307"><code>		// generation. We need to do this even for dead Gs because</code></span>
<span class="codeline" id="line-308"><code>		// they may come alive with a new identity, and its status</code></span>
<span class="codeline" id="line-309"><code>		// traced bookkeeping might end up being stale.</code></span>
<span class="codeline" id="line-310"><code>		// We may miss totally new goroutines, but they'll always</code></span>
<span class="codeline" id="line-311"><code>		// have clean bookkeeping.</code></span>
<span class="codeline" id="line-312"><code>		gp.trace.readyNextGen(gen)</code></span>
<span class="codeline" id="line-313"><code>		// If the status was traced, nothing else to do.</code></span>
<span class="codeline" id="line-314"><code>		if gp.trace.statusWasTraced(gen) {</code></span>
<span class="codeline" id="line-315"><code>			return</code></span>
<span class="codeline" id="line-316"><code>		}</code></span>
<span class="codeline" id="line-317"><code>		// Scribble down information about this goroutine.</code></span>
<span class="codeline" id="line-318"><code>		ug := untracedG{gp: gp, mid: -1}</code></span>
<span class="codeline" id="line-319"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-320"><code>			me := getg().m.curg</code></span>
<span class="codeline" id="line-321"><code>			// We don't have to handle this G status transition because we</code></span>
<span class="codeline" id="line-322"><code>			// already eliminated ourselves from consideration above.</code></span>
<span class="codeline" id="line-323"><code>			casGToWaiting(me, _Grunning, waitReasonTraceGoroutineStatus)</code></span>
<span class="codeline" id="line-324"><code>			// We need to suspend and take ownership of the G to safely read its</code></span>
<span class="codeline" id="line-325"><code>			// goid. Note that we can't actually emit the event at this point</code></span>
<span class="codeline" id="line-326"><code>			// because we might stop the G in a window where it's unsafe to write</code></span>
<span class="codeline" id="line-327"><code>			// events based on the G's status. We need the global trace buffer flush</code></span>
<span class="codeline" id="line-328"><code>			// coming up to make sure we're not racing with the G.</code></span>
<span class="codeline" id="line-329"><code>			//</code></span>
<span class="codeline" id="line-330"><code>			// It should be very unlikely that we try to preempt a running G here.</code></span>
<span class="codeline" id="line-331"><code>			// The only situation that we might is that we're racing with a G</code></span>
<span class="codeline" id="line-332"><code>			// that's running for the first time in this generation. Therefore,</code></span>
<span class="codeline" id="line-333"><code>			// this should be relatively fast.</code></span>
<span class="codeline" id="line-334"><code>			s := suspendG(gp)</code></span>
<span class="codeline" id="line-335"><code>			if !s.dead {</code></span>
<span class="codeline" id="line-336"><code>				ug.goid = s.g.goid</code></span>
<span class="codeline" id="line-337"><code>				if s.g.m != nil {</code></span>
<span class="codeline" id="line-338"><code>					ug.mid = int64(s.g.m.procid)</code></span>
<span class="codeline" id="line-339"><code>				}</code></span>
<span class="codeline" id="line-340"><code>				ug.status = readgstatus(s.g) &amp;^ _Gscan</code></span>
<span class="codeline" id="line-341"><code>				ug.waitreason = s.g.waitreason</code></span>
<span class="codeline" id="line-342"><code>				ug.inMarkAssist = s.g.inMarkAssist</code></span>
<span class="codeline" id="line-343"><code>			}</code></span>
<span class="codeline" id="line-344"><code>			resumeG(s)</code></span>
<span class="codeline" id="line-345"><code>			casgstatus(me, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-346"><code>		})</code></span>
<span class="codeline" id="line-347"><code>		if ug.goid != 0 {</code></span>
<span class="codeline" id="line-348"><code>			untracedGs = append(untracedGs, ug)</code></span>
<span class="codeline" id="line-349"><code>		}</code></span>
<span class="codeline" id="line-350"><code>	})</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>	if !stopTrace {</code></span>
<span class="codeline" id="line-353"><code>		// Re-register runtime goroutine labels and stop/block reasons.</code></span>
<span class="codeline" id="line-354"><code>		traceRegisterLabelsAndReasons(traceNextGen(gen))</code></span>
<span class="codeline" id="line-355"><code>	}</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	// Now that we've done some of the heavy stuff, prevent the world from stopping.</code></span>
<span class="codeline" id="line-358"><code>	// This is necessary to ensure the consistency of the STW events. If we're feeling</code></span>
<span class="codeline" id="line-359"><code>	// adventurous we could lift this restriction and add a STWActive event, but the</code></span>
<span class="codeline" id="line-360"><code>	// cost of maintaining this consistency is low. We're not going to hold this semaphore</code></span>
<span class="codeline" id="line-361"><code>	// for very long and most STW periods are very short.</code></span>
<span class="codeline" id="line-362"><code>	// Once we hold worldsema, prevent preemption as well so we're not interrupted partway</code></span>
<span class="codeline" id="line-363"><code>	// through this. We want to get this done as soon as possible.</code></span>
<span class="codeline" id="line-364"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-365"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-366"><code></code></span>
<span class="codeline" id="line-367"><code>	// Advance the generation or stop the trace.</code></span>
<span class="codeline" id="line-368"><code>	trace.lastNonZeroGen = gen</code></span>
<span class="codeline" id="line-369"><code>	if stopTrace {</code></span>
<span class="codeline" id="line-370"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-371"><code>			// Ordering is important here. Set shutdown first, then disable tracing,</code></span>
<span class="codeline" id="line-372"><code>			// so that conditions like (traceEnabled() || traceShuttingDown()) have</code></span>
<span class="codeline" id="line-373"><code>			// no opportunity to be false. Hold the trace lock so this update appears</code></span>
<span class="codeline" id="line-374"><code>			// atomic to the trace reader.</code></span>
<span class="codeline" id="line-375"><code>			lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-376"><code>			trace.shutdown.Store(true)</code></span>
<span class="codeline" id="line-377"><code>			trace.gen.Store(0)</code></span>
<span class="codeline" id="line-378"><code>			unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-379"><code>		})</code></span>
<span class="codeline" id="line-380"><code>	} else {</code></span>
<span class="codeline" id="line-381"><code>		trace.gen.Store(traceNextGen(gen))</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	// Emit a ProcsChange event so we have one on record for each generation.</code></span>
<span class="codeline" id="line-385"><code>	// Let's emit it as soon as possible so that downstream tools can rely on the value</code></span>
<span class="codeline" id="line-386"><code>	// being there fairly soon in a generation.</code></span>
<span class="codeline" id="line-387"><code>	//</code></span>
<span class="codeline" id="line-388"><code>	// It's important that we do this before allowing stop-the-worlds again,</code></span>
<span class="codeline" id="line-389"><code>	// because the procs count could change.</code></span>
<span class="codeline" id="line-390"><code>	if !stopTrace {</code></span>
<span class="codeline" id="line-391"><code>		tl := traceAcquire()</code></span>
<span class="codeline" id="line-392"><code>		tl.Gomaxprocs(gomaxprocs)</code></span>
<span class="codeline" id="line-393"><code>		traceRelease(tl)</code></span>
<span class="codeline" id="line-394"><code>	}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	// Emit a GCActive event in the new generation if necessary.</code></span>
<span class="codeline" id="line-397"><code>	//</code></span>
<span class="codeline" id="line-398"><code>	// It's important that we do this before allowing stop-the-worlds again,</code></span>
<span class="codeline" id="line-399"><code>	// because that could emit global GC-related events.</code></span>
<span class="codeline" id="line-400"><code>	if !stopTrace &amp;&amp; (gcphase == _GCmark || gcphase == _GCmarktermination) {</code></span>
<span class="codeline" id="line-401"><code>		tl := traceAcquire()</code></span>
<span class="codeline" id="line-402"><code>		tl.GCActive()</code></span>
<span class="codeline" id="line-403"><code>		traceRelease(tl)</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>	// Preemption is OK again after this. If the world stops or whatever it's fine.</code></span>
<span class="codeline" id="line-407"><code>	// We're just cleaning up the last generation after this point.</code></span>
<span class="codeline" id="line-408"><code>	//</code></span>
<span class="codeline" id="line-409"><code>	// We also don't care if the GC starts again after this for the same reasons.</code></span>
<span class="codeline" id="line-410"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-411"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	// Snapshot allm and freem.</code></span>
<span class="codeline" id="line-414"><code>	//</code></span>
<span class="codeline" id="line-415"><code>	// Snapshotting after the generation counter update is sufficient.</code></span>
<span class="codeline" id="line-416"><code>	// Because an m must be on either allm or sched.freem if it has an active trace</code></span>
<span class="codeline" id="line-417"><code>	// buffer, new threads added to allm after this point must necessarily observe</code></span>
<span class="codeline" id="line-418"><code>	// the new generation number (sched.lock acts as a barrier).</code></span>
<span class="codeline" id="line-419"><code>	//</code></span>
<span class="codeline" id="line-420"><code>	// Threads that exit before this point and are on neither list explicitly</code></span>
<span class="codeline" id="line-421"><code>	// flush their own buffers in traceThreadDestroy.</code></span>
<span class="codeline" id="line-422"><code>	//</code></span>
<span class="codeline" id="line-423"><code>	// Snapshotting freem is necessary because Ms can continue to emit events</code></span>
<span class="codeline" id="line-424"><code>	// while they're still on that list. Removal from sched.freem is serialized with</code></span>
<span class="codeline" id="line-425"><code>	// this snapshot, so either we'll capture an m on sched.freem and race with</code></span>
<span class="codeline" id="line-426"><code>	// the removal to flush its buffers (resolved by traceThreadDestroy acquiring</code></span>
<span class="codeline" id="line-427"><code>	// the thread's seqlock, which one of us must win, so at least its old gen buffer</code></span>
<span class="codeline" id="line-428"><code>	// will be flushed in time for the new generation) or it will have flushed its</code></span>
<span class="codeline" id="line-429"><code>	// buffers before we snapshotted it to begin with.</code></span>
<span class="codeline" id="line-430"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-431"><code>	mToFlush := allm</code></span>
<span class="codeline" id="line-432"><code>	for mp := mToFlush; mp != nil; mp = mp.alllink {</code></span>
<span class="codeline" id="line-433"><code>		mp.trace.link = mp.alllink</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	for mp := sched.freem; mp != nil; mp = mp.freelink {</code></span>
<span class="codeline" id="line-436"><code>		mp.trace.link = mToFlush</code></span>
<span class="codeline" id="line-437"><code>		mToFlush = mp</code></span>
<span class="codeline" id="line-438"><code>	}</code></span>
<span class="codeline" id="line-439"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>	// Iterate over our snapshot, flushing every buffer until we're done.</code></span>
<span class="codeline" id="line-442"><code>	//</code></span>
<span class="codeline" id="line-443"><code>	// Because trace writers read the generation while the seqlock is</code></span>
<span class="codeline" id="line-444"><code>	// held, we can be certain that when there are no writers there are</code></span>
<span class="codeline" id="line-445"><code>	// also no stale generation values left. Therefore, it's safe to flush</code></span>
<span class="codeline" id="line-446"><code>	// any buffers that remain in that generation's slot.</code></span>
<span class="codeline" id="line-447"><code>	const debugDeadlock = false</code></span>
<span class="codeline" id="line-448"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-449"><code>		// Track iterations for some rudimentary deadlock detection.</code></span>
<span class="codeline" id="line-450"><code>		i := 0</code></span>
<span class="codeline" id="line-451"><code>		detectedDeadlock := false</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>		for mToFlush != nil {</code></span>
<span class="codeline" id="line-454"><code>			prev := &amp;mToFlush</code></span>
<span class="codeline" id="line-455"><code>			for mp := *prev; mp != nil; {</code></span>
<span class="codeline" id="line-456"><code>				if mp.trace.seqlock.Load()%2 != 0 {</code></span>
<span class="codeline" id="line-457"><code>					// The M is writing. Come back to it later.</code></span>
<span class="codeline" id="line-458"><code>					prev = &amp;mp.trace.link</code></span>
<span class="codeline" id="line-459"><code>					mp = mp.trace.link</code></span>
<span class="codeline" id="line-460"><code>					continue</code></span>
<span class="codeline" id="line-461"><code>				}</code></span>
<span class="codeline" id="line-462"><code>				// Flush the trace buffer.</code></span>
<span class="codeline" id="line-463"><code>				//</code></span>
<span class="codeline" id="line-464"><code>				// trace.lock needed for traceBufFlush, but also to synchronize</code></span>
<span class="codeline" id="line-465"><code>				// with traceThreadDestroy, which flushes both buffers unconditionally.</code></span>
<span class="codeline" id="line-466"><code>				lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-467"><code>				bufp := &amp;mp.trace.buf[gen%2]</code></span>
<span class="codeline" id="line-468"><code>				if *bufp != nil {</code></span>
<span class="codeline" id="line-469"><code>					traceBufFlush(*bufp, gen)</code></span>
<span class="codeline" id="line-470"><code>					*bufp = nil</code></span>
<span class="codeline" id="line-471"><code>				}</code></span>
<span class="codeline" id="line-472"><code>				unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>				// Remove the m from the flush list.</code></span>
<span class="codeline" id="line-475"><code>				*prev = mp.trace.link</code></span>
<span class="codeline" id="line-476"><code>				mp.trace.link = nil</code></span>
<span class="codeline" id="line-477"><code>				mp = *prev</code></span>
<span class="codeline" id="line-478"><code>			}</code></span>
<span class="codeline" id="line-479"><code>			// Yield only if we're going to be going around the loop again.</code></span>
<span class="codeline" id="line-480"><code>			if mToFlush != nil {</code></span>
<span class="codeline" id="line-481"><code>				osyield()</code></span>
<span class="codeline" id="line-482"><code>			}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>			if debugDeadlock {</code></span>
<span class="codeline" id="line-485"><code>				// Try to detect a deadlock. We probably shouldn't loop here</code></span>
<span class="codeline" id="line-486"><code>				// this many times.</code></span>
<span class="codeline" id="line-487"><code>				if i &gt; 100000 &amp;&amp; !detectedDeadlock {</code></span>
<span class="codeline" id="line-488"><code>					detectedDeadlock = true</code></span>
<span class="codeline" id="line-489"><code>					println("runtime: failing to flush")</code></span>
<span class="codeline" id="line-490"><code>					for mp := mToFlush; mp != nil; mp = mp.trace.link {</code></span>
<span class="codeline" id="line-491"><code>						print("runtime: m=", mp.id, "\n")</code></span>
<span class="codeline" id="line-492"><code>					}</code></span>
<span class="codeline" id="line-493"><code>				}</code></span>
<span class="codeline" id="line-494"><code>				i++</code></span>
<span class="codeline" id="line-495"><code>			}</code></span>
<span class="codeline" id="line-496"><code>		}</code></span>
<span class="codeline" id="line-497"><code>	})</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>	// At this point, the old generation is fully flushed minus stack and string</code></span>
<span class="codeline" id="line-500"><code>	// tables, CPU samples, and goroutines that haven't run at all during the last</code></span>
<span class="codeline" id="line-501"><code>	// generation.</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>	// Check to see if any Gs still haven't had events written out for them.</code></span>
<span class="codeline" id="line-504"><code>	statusWriter := unsafeTraceWriter(gen, nil)</code></span>
<span class="codeline" id="line-505"><code>	for _, ug := range untracedGs {</code></span>
<span class="codeline" id="line-506"><code>		if ug.gp.trace.statusWasTraced(gen) {</code></span>
<span class="codeline" id="line-507"><code>			// It was traced, we don't need to do anything.</code></span>
<span class="codeline" id="line-508"><code>			continue</code></span>
<span class="codeline" id="line-509"><code>		}</code></span>
<span class="codeline" id="line-510"><code>		// It still wasn't traced. Because we ensured all Ms stopped writing trace</code></span>
<span class="codeline" id="line-511"><code>		// events to the last generation, that must mean the G never had its status</code></span>
<span class="codeline" id="line-512"><code>		// traced in gen between when we recorded it and now. If that's true, the goid</code></span>
<span class="codeline" id="line-513"><code>		// and status we recorded then is exactly what we want right now.</code></span>
<span class="codeline" id="line-514"><code>		status := goStatusToTraceGoStatus(ug.status, ug.waitreason)</code></span>
<span class="codeline" id="line-515"><code>		statusWriter = statusWriter.writeGoStatus(ug.goid, ug.mid, status, ug.inMarkAssist)</code></span>
<span class="codeline" id="line-516"><code>	}</code></span>
<span class="codeline" id="line-517"><code>	statusWriter.flush().end()</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>	// Read everything out of the last gen's CPU profile buffer.</code></span>
<span class="codeline" id="line-520"><code>	traceReadCPU(gen)</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-523"><code>		// Flush CPU samples, stacks, and strings for the last generation. This is safe,</code></span>
<span class="codeline" id="line-524"><code>		// because we're now certain no M is writing to the last generation.</code></span>
<span class="codeline" id="line-525"><code>		//</code></span>
<span class="codeline" id="line-526"><code>		// Ordering is important here. traceCPUFlush may generate new stacks and dumping</code></span>
<span class="codeline" id="line-527"><code>		// stacks may generate new strings.</code></span>
<span class="codeline" id="line-528"><code>		traceCPUFlush(gen)</code></span>
<span class="codeline" id="line-529"><code>		trace.stackTab[gen%2].dump(gen)</code></span>
<span class="codeline" id="line-530"><code>		trace.stringTab[gen%2].reset(gen)</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>		// That's it. This generation is done producing buffers.</code></span>
<span class="codeline" id="line-533"><code>		lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-534"><code>		trace.flushedGen.Store(gen)</code></span>
<span class="codeline" id="line-535"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-536"><code>	})</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>	if stopTrace {</code></span>
<span class="codeline" id="line-539"><code>		semacquire(&amp;traceShutdownSema)</code></span>
<span class="codeline" id="line-540"><code></code></span>
<span class="codeline" id="line-541"><code>		// Finish off CPU profile reading.</code></span>
<span class="codeline" id="line-542"><code>		traceStopReadCPU()</code></span>
<span class="codeline" id="line-543"><code>	} else {</code></span>
<span class="codeline" id="line-544"><code>		// Go over each P and emit a status event for it if necessary.</code></span>
<span class="codeline" id="line-545"><code>		//</code></span>
<span class="codeline" id="line-546"><code>		// We do this at the beginning of the new generation instead of the</code></span>
<span class="codeline" id="line-547"><code>		// end like we do for goroutines because forEachP doesn't give us a</code></span>
<span class="codeline" id="line-548"><code>		// hook to skip Ps that have already been traced. Since we have to</code></span>
<span class="codeline" id="line-549"><code>		// preempt all Ps anyway, might as well stay consistent with StartTrace</code></span>
<span class="codeline" id="line-550"><code>		// which does this during the STW.</code></span>
<span class="codeline" id="line-551"><code>		semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-552"><code>		forEachP(waitReasonTraceProcStatus, func(pp *p) {</code></span>
<span class="codeline" id="line-553"><code>			tl := traceAcquire()</code></span>
<span class="codeline" id="line-554"><code>			if !pp.trace.statusWasTraced(tl.gen) {</code></span>
<span class="codeline" id="line-555"><code>				tl.writer().writeProcStatusForP(pp, false).end()</code></span>
<span class="codeline" id="line-556"><code>			}</code></span>
<span class="codeline" id="line-557"><code>			traceRelease(tl)</code></span>
<span class="codeline" id="line-558"><code>		})</code></span>
<span class="codeline" id="line-559"><code>		// Perform status reset on dead Ps because they just appear as idle.</code></span>
<span class="codeline" id="line-560"><code>		//</code></span>
<span class="codeline" id="line-561"><code>		// Holding worldsema prevents allp from changing.</code></span>
<span class="codeline" id="line-562"><code>		//</code></span>
<span class="codeline" id="line-563"><code>		// TODO(mknyszek): Consider explicitly emitting ProcCreate and ProcDestroy</code></span>
<span class="codeline" id="line-564"><code>		// events to indicate whether a P exists, rather than just making its</code></span>
<span class="codeline" id="line-565"><code>		// existence implicit.</code></span>
<span class="codeline" id="line-566"><code>		for _, pp := range allp[len(allp):cap(allp)] {</code></span>
<span class="codeline" id="line-567"><code>			pp.trace.readyNextGen(traceNextGen(gen))</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code>		semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-570"><code>	}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>	// Block until the trace reader has finished processing the last generation.</code></span>
<span class="codeline" id="line-573"><code>	semacquire(&amp;trace.doneSema[gen%2])</code></span>
<span class="codeline" id="line-574"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-575"><code>		raceacquire(unsafe.Pointer(&amp;trace.doneSema[gen%2]))</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>	// Double-check that things look as we expect after advancing and perform some</code></span>
<span class="codeline" id="line-579"><code>	// final cleanup if the trace has fully stopped.</code></span>
<span class="codeline" id="line-580"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-581"><code>		lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-582"><code>		if !trace.full[gen%2].empty() {</code></span>
<span class="codeline" id="line-583"><code>			throw("trace: non-empty full trace buffer for done generation")</code></span>
<span class="codeline" id="line-584"><code>		}</code></span>
<span class="codeline" id="line-585"><code>		if stopTrace {</code></span>
<span class="codeline" id="line-586"><code>			if !trace.full[1-(gen%2)].empty() {</code></span>
<span class="codeline" id="line-587"><code>				throw("trace: non-empty full trace buffer for next generation")</code></span>
<span class="codeline" id="line-588"><code>			}</code></span>
<span class="codeline" id="line-589"><code>			if trace.reading != nil || trace.reader.Load() != nil {</code></span>
<span class="codeline" id="line-590"><code>				throw("trace: reading after shutdown")</code></span>
<span class="codeline" id="line-591"><code>			}</code></span>
<span class="codeline" id="line-592"><code>			// Free all the empty buffers.</code></span>
<span class="codeline" id="line-593"><code>			for trace.empty != nil {</code></span>
<span class="codeline" id="line-594"><code>				buf := trace.empty</code></span>
<span class="codeline" id="line-595"><code>				trace.empty = buf.link</code></span>
<span class="codeline" id="line-596"><code>				sysFree(unsafe.Pointer(buf), unsafe.Sizeof(*buf), &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-597"><code>			}</code></span>
<span class="codeline" id="line-598"><code>			// Clear trace.shutdown and other flags.</code></span>
<span class="codeline" id="line-599"><code>			trace.headerWritten = false</code></span>
<span class="codeline" id="line-600"><code>			trace.shutdown.Store(false)</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-603"><code>	})</code></span>
<span class="codeline" id="line-604"><code></code></span>
<span class="codeline" id="line-605"><code>	if stopTrace {</code></span>
<span class="codeline" id="line-606"><code>		// Clear the sweep state on every P for the next time tracing is enabled.</code></span>
<span class="codeline" id="line-607"><code>		//</code></span>
<span class="codeline" id="line-608"><code>		// It may be stale in the next trace because we may have ended tracing in</code></span>
<span class="codeline" id="line-609"><code>		// the middle of a sweep on a P.</code></span>
<span class="codeline" id="line-610"><code>		//</code></span>
<span class="codeline" id="line-611"><code>		// It's fine not to call forEachP here because tracing is disabled and we</code></span>
<span class="codeline" id="line-612"><code>		// know at this point that nothing is calling into the tracer, but we do</code></span>
<span class="codeline" id="line-613"><code>		// need to look at dead Ps too just because GOMAXPROCS could have been called</code></span>
<span class="codeline" id="line-614"><code>		// at any point since we stopped tracing, and we have to ensure there's no</code></span>
<span class="codeline" id="line-615"><code>		// bad state on dead Ps too. Prevent a STW and a concurrent GOMAXPROCS that</code></span>
<span class="codeline" id="line-616"><code>		// might mutate allp by making ourselves briefly non-preemptible.</code></span>
<span class="codeline" id="line-617"><code>		mp := acquirem()</code></span>
<span class="codeline" id="line-618"><code>		for _, pp := range allp[:cap(allp)] {</code></span>
<span class="codeline" id="line-619"><code>			pp.trace.inSweep = false</code></span>
<span class="codeline" id="line-620"><code>			pp.trace.maySweep = false</code></span>
<span class="codeline" id="line-621"><code>			pp.trace.swept = 0</code></span>
<span class="codeline" id="line-622"><code>			pp.trace.reclaimed = 0</code></span>
<span class="codeline" id="line-623"><code>		}</code></span>
<span class="codeline" id="line-624"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>	// Release the advance semaphore. If stopTrace is true we're still holding onto</code></span>
<span class="codeline" id="line-628"><code>	// traceShutdownSema.</code></span>
<span class="codeline" id="line-629"><code>	//</code></span>
<span class="codeline" id="line-630"><code>	// Do a direct handoff. Don't let one caller of traceAdvance starve</code></span>
<span class="codeline" id="line-631"><code>	// other calls to traceAdvance.</code></span>
<span class="codeline" id="line-632"><code>	semrelease1(&amp;traceAdvanceSema, true, 0)</code></span>
<span class="codeline" id="line-633"><code></code></span>
<span class="codeline" id="line-634"><code>	if stopTrace {</code></span>
<span class="codeline" id="line-635"><code>		// Stop the traceAdvancer. We can't be holding traceAdvanceSema here because</code></span>
<span class="codeline" id="line-636"><code>		// we'll deadlock (we're blocked on the advancer goroutine exiting, but it</code></span>
<span class="codeline" id="line-637"><code>		// may be currently trying to acquire traceAdvanceSema).</code></span>
<span class="codeline" id="line-638"><code>		traceAdvancer.stop()</code></span>
<span class="codeline" id="line-639"><code>		semrelease(&amp;traceShutdownSema)</code></span>
<span class="codeline" id="line-640"><code>	}</code></span>
<span class="codeline" id="line-641"><code>}</code></span>
<span class="codeline" id="line-642"><code></code></span>
<span class="codeline" id="line-643"><code>func traceNextGen(gen uintptr) uintptr {</code></span>
<span class="codeline" id="line-644"><code>	if gen == ^uintptr(0) {</code></span>
<span class="codeline" id="line-645"><code>		// gen is used both %2 and %3 and we want both patterns to continue when we loop around.</code></span>
<span class="codeline" id="line-646"><code>		// ^uint32(0) and ^uint64(0) are both odd and multiples of 3. Therefore the next generation</code></span>
<span class="codeline" id="line-647"><code>		// we want is even and one more than a multiple of 3. The smallest such number is 4.</code></span>
<span class="codeline" id="line-648"><code>		return 4</code></span>
<span class="codeline" id="line-649"><code>	}</code></span>
<span class="codeline" id="line-650"><code>	return gen + 1</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>// traceRegisterLabelsAndReasons re-registers mark worker labels and</code></span>
<span class="codeline" id="line-654"><code>// goroutine stop/block reasons in the string table for the provided</code></span>
<span class="codeline" id="line-655"><code>// generation. Note: the provided generation must not have started yet.</code></span>
<span class="codeline" id="line-656"><code>func traceRegisterLabelsAndReasons(gen uintptr) {</code></span>
<span class="codeline" id="line-657"><code>	for i, label := range gcMarkWorkerModeStrings[:] {</code></span>
<span class="codeline" id="line-658"><code>		trace.markWorkerLabels[gen%2][i] = traceArg(trace.stringTab[gen%2].put(gen, label))</code></span>
<span class="codeline" id="line-659"><code>	}</code></span>
<span class="codeline" id="line-660"><code>	for i, str := range traceBlockReasonStrings[:] {</code></span>
<span class="codeline" id="line-661"><code>		trace.goBlockReasons[gen%2][i] = traceArg(trace.stringTab[gen%2].put(gen, str))</code></span>
<span class="codeline" id="line-662"><code>	}</code></span>
<span class="codeline" id="line-663"><code>	for i, str := range traceGoStopReasonStrings[:] {</code></span>
<span class="codeline" id="line-664"><code>		trace.goStopReasons[gen%2][i] = traceArg(trace.stringTab[gen%2].put(gen, str))</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>}</code></span>
<span class="codeline" id="line-667"><code></code></span>
<span class="codeline" id="line-668"><code>// ReadTrace returns the next chunk of binary tracing data, blocking until data</code></span>
<span class="codeline" id="line-669"><code>// is available. If tracing is turned off and all the data accumulated while it</code></span>
<span class="codeline" id="line-670"><code>// was on has been returned, ReadTrace returns nil. The caller must copy the</code></span>
<span class="codeline" id="line-671"><code>// returned data before calling ReadTrace again.</code></span>
<span class="codeline" id="line-672"><code>// ReadTrace must be called from one goroutine at a time.</code></span>
<span class="codeline" id="line-673"><code>func ReadTrace() []byte {</code></span>
<span class="codeline" id="line-674"><code>top:</code></span>
<span class="codeline" id="line-675"><code>	var buf []byte</code></span>
<span class="codeline" id="line-676"><code>	var park bool</code></span>
<span class="codeline" id="line-677"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-678"><code>		buf, park = readTrace0()</code></span>
<span class="codeline" id="line-679"><code>	})</code></span>
<span class="codeline" id="line-680"><code>	if park {</code></span>
<span class="codeline" id="line-681"><code>		gopark(func(gp *g, _ unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-682"><code>			if !trace.reader.CompareAndSwapNoWB(nil, gp) {</code></span>
<span class="codeline" id="line-683"><code>				// We're racing with another reader.</code></span>
<span class="codeline" id="line-684"><code>				// Wake up and handle this case.</code></span>
<span class="codeline" id="line-685"><code>				return false</code></span>
<span class="codeline" id="line-686"><code>			}</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>			if g2 := traceReader(); gp == g2 {</code></span>
<span class="codeline" id="line-689"><code>				// New data arrived between unlocking</code></span>
<span class="codeline" id="line-690"><code>				// and the CAS and we won the wake-up</code></span>
<span class="codeline" id="line-691"><code>				// race, so wake up directly.</code></span>
<span class="codeline" id="line-692"><code>				return false</code></span>
<span class="codeline" id="line-693"><code>			} else if g2 != nil {</code></span>
<span class="codeline" id="line-694"><code>				printlock()</code></span>
<span class="codeline" id="line-695"><code>				println("runtime: got trace reader", g2, g2.goid)</code></span>
<span class="codeline" id="line-696"><code>				throw("unexpected trace reader")</code></span>
<span class="codeline" id="line-697"><code>			}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>			return true</code></span>
<span class="codeline" id="line-700"><code>		}, nil, waitReasonTraceReaderBlocked, traceBlockSystemGoroutine, 2)</code></span>
<span class="codeline" id="line-701"><code>		goto top</code></span>
<span class="codeline" id="line-702"><code>	}</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>	return buf</code></span>
<span class="codeline" id="line-705"><code>}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>// readTrace0 is ReadTrace's continuation on g0. This must run on the</code></span>
<span class="codeline" id="line-708"><code>// system stack because it acquires trace.lock.</code></span>
<span class="codeline" id="line-709"><code>//</code></span>
<span class="codeline" id="line-710"><code>//go:systemstack</code></span>
<span class="codeline" id="line-711"><code>func readTrace0() (buf []byte, park bool) {</code></span>
<span class="codeline" id="line-712"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-713"><code>		// g0 doesn't have a race context. Borrow the user G's.</code></span>
<span class="codeline" id="line-714"><code>		if getg().racectx != 0 {</code></span>
<span class="codeline" id="line-715"><code>			throw("expected racectx == 0")</code></span>
<span class="codeline" id="line-716"><code>		}</code></span>
<span class="codeline" id="line-717"><code>		getg().racectx = getg().m.curg.racectx</code></span>
<span class="codeline" id="line-718"><code>		// (This defer should get open-coded, which is safe on</code></span>
<span class="codeline" id="line-719"><code>		// the system stack.)</code></span>
<span class="codeline" id="line-720"><code>		defer func() { getg().racectx = 0 }()</code></span>
<span class="codeline" id="line-721"><code>	}</code></span>
<span class="codeline" id="line-722"><code></code></span>
<span class="codeline" id="line-723"><code>	// This function must not allocate while holding trace.lock:</code></span>
<span class="codeline" id="line-724"><code>	// allocation can call heap allocate, which will try to emit a trace</code></span>
<span class="codeline" id="line-725"><code>	// event while holding heap lock.</code></span>
<span class="codeline" id="line-726"><code>	lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>	if trace.reader.Load() != nil {</code></span>
<span class="codeline" id="line-729"><code>		// More than one goroutine reads trace. This is bad.</code></span>
<span class="codeline" id="line-730"><code>		// But we rather do not crash the program because of tracing,</code></span>
<span class="codeline" id="line-731"><code>		// because tracing can be enabled at runtime on prod servers.</code></span>
<span class="codeline" id="line-732"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-733"><code>		println("runtime: ReadTrace called from multiple goroutines simultaneously")</code></span>
<span class="codeline" id="line-734"><code>		return nil, false</code></span>
<span class="codeline" id="line-735"><code>	}</code></span>
<span class="codeline" id="line-736"><code>	// Recycle the old buffer.</code></span>
<span class="codeline" id="line-737"><code>	if buf := trace.reading; buf != nil {</code></span>
<span class="codeline" id="line-738"><code>		buf.link = trace.empty</code></span>
<span class="codeline" id="line-739"><code>		trace.empty = buf</code></span>
<span class="codeline" id="line-740"><code>		trace.reading = nil</code></span>
<span class="codeline" id="line-741"><code>	}</code></span>
<span class="codeline" id="line-742"><code>	// Write trace header.</code></span>
<span class="codeline" id="line-743"><code>	if !trace.headerWritten {</code></span>
<span class="codeline" id="line-744"><code>		trace.headerWritten = true</code></span>
<span class="codeline" id="line-745"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-746"><code>		return []byte("go 1.22 trace\x00\x00\x00"), false</code></span>
<span class="codeline" id="line-747"><code>	}</code></span>
<span class="codeline" id="line-748"><code></code></span>
<span class="codeline" id="line-749"><code>	// Read the next buffer.</code></span>
<span class="codeline" id="line-750"><code></code></span>
<span class="codeline" id="line-751"><code>	if trace.readerGen.Load() == 0 {</code></span>
<span class="codeline" id="line-752"><code>		trace.readerGen.Store(1)</code></span>
<span class="codeline" id="line-753"><code>	}</code></span>
<span class="codeline" id="line-754"><code>	var gen uintptr</code></span>
<span class="codeline" id="line-755"><code>	for {</code></span>
<span class="codeline" id="line-756"><code>		assertLockHeld(&amp;trace.lock)</code></span>
<span class="codeline" id="line-757"><code>		gen = trace.readerGen.Load()</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>		// Check to see if we need to block for more data in this generation</code></span>
<span class="codeline" id="line-760"><code>		// or if we need to move our generation forward.</code></span>
<span class="codeline" id="line-761"><code>		if !trace.full[gen%2].empty() {</code></span>
<span class="codeline" id="line-762"><code>			break</code></span>
<span class="codeline" id="line-763"><code>		}</code></span>
<span class="codeline" id="line-764"><code>		// Most of the time readerGen is one generation ahead of flushedGen, as the</code></span>
<span class="codeline" id="line-765"><code>		// current generation is being read from. Then, once the last buffer is flushed</code></span>
<span class="codeline" id="line-766"><code>		// into readerGen, flushedGen will rise to meet it. At this point, the tracer</code></span>
<span class="codeline" id="line-767"><code>		// is waiting on the reader to finish flushing the last generation so that it</code></span>
<span class="codeline" id="line-768"><code>		// can continue to advance.</code></span>
<span class="codeline" id="line-769"><code>		if trace.flushedGen.Load() == gen {</code></span>
<span class="codeline" id="line-770"><code>			if trace.shutdown.Load() {</code></span>
<span class="codeline" id="line-771"><code>				unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>				// Wake up anyone waiting for us to be done with this generation.</code></span>
<span class="codeline" id="line-774"><code>				//</code></span>
<span class="codeline" id="line-775"><code>				// Do this after reading trace.shutdown, because the thread we're</code></span>
<span class="codeline" id="line-776"><code>				// waking up is going to clear trace.shutdown.</code></span>
<span class="codeline" id="line-777"><code>				if raceenabled {</code></span>
<span class="codeline" id="line-778"><code>					// Model synchronization on trace.doneSema, which te race</code></span>
<span class="codeline" id="line-779"><code>					// detector does not see. This is required to avoid false</code></span>
<span class="codeline" id="line-780"><code>					// race reports on writer passed to trace.Start.</code></span>
<span class="codeline" id="line-781"><code>					racerelease(unsafe.Pointer(&amp;trace.doneSema[gen%2]))</code></span>
<span class="codeline" id="line-782"><code>				}</code></span>
<span class="codeline" id="line-783"><code>				semrelease(&amp;trace.doneSema[gen%2])</code></span>
<span class="codeline" id="line-784"><code></code></span>
<span class="codeline" id="line-785"><code>				// We're shutting down, and the last generation is fully</code></span>
<span class="codeline" id="line-786"><code>				// read. We're done.</code></span>
<span class="codeline" id="line-787"><code>				return nil, false</code></span>
<span class="codeline" id="line-788"><code>			}</code></span>
<span class="codeline" id="line-789"><code>			// The previous gen has had all of its buffers flushed, and</code></span>
<span class="codeline" id="line-790"><code>			// there's nothing else for us to read. Advance the generation</code></span>
<span class="codeline" id="line-791"><code>			// we're reading from and try again.</code></span>
<span class="codeline" id="line-792"><code>			trace.readerGen.Store(trace.gen.Load())</code></span>
<span class="codeline" id="line-793"><code>			unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-794"><code></code></span>
<span class="codeline" id="line-795"><code>			// Wake up anyone waiting for us to be done with this generation.</code></span>
<span class="codeline" id="line-796"><code>			//</code></span>
<span class="codeline" id="line-797"><code>			// Do this after reading gen to make sure we can't have the trace</code></span>
<span class="codeline" id="line-798"><code>			// advance until we've read it.</code></span>
<span class="codeline" id="line-799"><code>			if raceenabled {</code></span>
<span class="codeline" id="line-800"><code>				// See comment above in the shutdown case.</code></span>
<span class="codeline" id="line-801"><code>				racerelease(unsafe.Pointer(&amp;trace.doneSema[gen%2]))</code></span>
<span class="codeline" id="line-802"><code>			}</code></span>
<span class="codeline" id="line-803"><code>			semrelease(&amp;trace.doneSema[gen%2])</code></span>
<span class="codeline" id="line-804"><code></code></span>
<span class="codeline" id="line-805"><code>			// Reacquire the lock and go back to the top of the loop.</code></span>
<span class="codeline" id="line-806"><code>			lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-807"><code>			continue</code></span>
<span class="codeline" id="line-808"><code>		}</code></span>
<span class="codeline" id="line-809"><code>		// Wait for new data.</code></span>
<span class="codeline" id="line-810"><code>		//</code></span>
<span class="codeline" id="line-811"><code>		// We don't simply use a note because the scheduler</code></span>
<span class="codeline" id="line-812"><code>		// executes this goroutine directly when it wakes up</code></span>
<span class="codeline" id="line-813"><code>		// (also a note would consume an M).</code></span>
<span class="codeline" id="line-814"><code>		//</code></span>
<span class="codeline" id="line-815"><code>		// Before we drop the lock, clear the workAvailable flag. Work can</code></span>
<span class="codeline" id="line-816"><code>		// only be queued with trace.lock held, so this is at least true until</code></span>
<span class="codeline" id="line-817"><code>		// we drop the lock.</code></span>
<span class="codeline" id="line-818"><code>		trace.workAvailable.Store(false)</code></span>
<span class="codeline" id="line-819"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-820"><code>		return nil, true</code></span>
<span class="codeline" id="line-821"><code>	}</code></span>
<span class="codeline" id="line-822"><code>	// Pull a buffer.</code></span>
<span class="codeline" id="line-823"><code>	tbuf := trace.full[gen%2].pop()</code></span>
<span class="codeline" id="line-824"><code>	trace.reading = tbuf</code></span>
<span class="codeline" id="line-825"><code>	unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-826"><code>	return tbuf.arr[:tbuf.pos], false</code></span>
<span class="codeline" id="line-827"><code>}</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>// traceReader returns the trace reader that should be woken up, if any.</code></span>
<span class="codeline" id="line-830"><code>// Callers should first check (traceEnabled() || traceShuttingDown()).</code></span>
<span class="codeline" id="line-831"><code>//</code></span>
<span class="codeline" id="line-832"><code>// This must run on the system stack because it acquires trace.lock.</code></span>
<span class="codeline" id="line-833"><code>//</code></span>
<span class="codeline" id="line-834"><code>//go:systemstack</code></span>
<span class="codeline" id="line-835"><code>func traceReader() *g {</code></span>
<span class="codeline" id="line-836"><code>	gp := traceReaderAvailable()</code></span>
<span class="codeline" id="line-837"><code>	if gp == nil || !trace.reader.CompareAndSwapNoWB(gp, nil) {</code></span>
<span class="codeline" id="line-838"><code>		return nil</code></span>
<span class="codeline" id="line-839"><code>	}</code></span>
<span class="codeline" id="line-840"><code>	return gp</code></span>
<span class="codeline" id="line-841"><code>}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>// traceReaderAvailable returns the trace reader if it is not currently</code></span>
<span class="codeline" id="line-844"><code>// scheduled and should be. Callers should first check that</code></span>
<span class="codeline" id="line-845"><code>// (traceEnabled() || traceShuttingDown()) is true.</code></span>
<span class="codeline" id="line-846"><code>func traceReaderAvailable() *g {</code></span>
<span class="codeline" id="line-847"><code>	// There are three conditions under which we definitely want to schedule</code></span>
<span class="codeline" id="line-848"><code>	// the reader:</code></span>
<span class="codeline" id="line-849"><code>	// - The reader is lagging behind in finishing off the last generation.</code></span>
<span class="codeline" id="line-850"><code>	//   In this case, trace buffers could even be empty, but the trace</code></span>
<span class="codeline" id="line-851"><code>	//   advancer will be waiting on the reader, so we have to make sure</code></span>
<span class="codeline" id="line-852"><code>	//   to schedule the reader ASAP.</code></span>
<span class="codeline" id="line-853"><code>	// - The reader has pending work to process for it's reader generation</code></span>
<span class="codeline" id="line-854"><code>	//   (assuming readerGen is not lagging behind). Note that we also want</code></span>
<span class="codeline" id="line-855"><code>	//   to be careful *not* to schedule the reader if there's no work to do.</code></span>
<span class="codeline" id="line-856"><code>	// - The trace is shutting down. The trace stopper blocks on the reader</code></span>
<span class="codeline" id="line-857"><code>	//   to finish, much like trace advancement.</code></span>
<span class="codeline" id="line-858"><code>	//</code></span>
<span class="codeline" id="line-859"><code>	// We also want to be careful not to schedule the reader if there's no</code></span>
<span class="codeline" id="line-860"><code>	// reason to.</code></span>
<span class="codeline" id="line-861"><code>	if trace.flushedGen.Load() == trace.readerGen.Load() || trace.workAvailable.Load() || trace.shutdown.Load() {</code></span>
<span class="codeline" id="line-862"><code>		return trace.reader.Load()</code></span>
<span class="codeline" id="line-863"><code>	}</code></span>
<span class="codeline" id="line-864"><code>	return nil</code></span>
<span class="codeline" id="line-865"><code>}</code></span>
<span class="codeline" id="line-866"><code></code></span>
<span class="codeline" id="line-867"><code>// Trace advancer goroutine.</code></span>
<span class="codeline" id="line-868"><code>var traceAdvancer traceAdvancerState</code></span>
<span class="codeline" id="line-869"><code></code></span>
<span class="codeline" id="line-870"><code>type traceAdvancerState struct {</code></span>
<span class="codeline" id="line-871"><code>	timer *wakeableSleep</code></span>
<span class="codeline" id="line-872"><code>	done  chan struct{}</code></span>
<span class="codeline" id="line-873"><code>}</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>// start starts a new traceAdvancer.</code></span>
<span class="codeline" id="line-876"><code>func (s *traceAdvancerState) start() {</code></span>
<span class="codeline" id="line-877"><code>	// Start a goroutine to periodically advance the trace generation.</code></span>
<span class="codeline" id="line-878"><code>	s.done = make(chan struct{})</code></span>
<span class="codeline" id="line-879"><code>	s.timer = newWakeableSleep()</code></span>
<span class="codeline" id="line-880"><code>	go func() {</code></span>
<span class="codeline" id="line-881"><code>		for traceEnabled() {</code></span>
<span class="codeline" id="line-882"><code>			// Set a timer to wake us up</code></span>
<span class="codeline" id="line-883"><code>			s.timer.sleep(int64(debug.traceadvanceperiod))</code></span>
<span class="codeline" id="line-884"><code></code></span>
<span class="codeline" id="line-885"><code>			// Try to advance the trace.</code></span>
<span class="codeline" id="line-886"><code>			traceAdvance(false)</code></span>
<span class="codeline" id="line-887"><code>		}</code></span>
<span class="codeline" id="line-888"><code>		s.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-889"><code>	}()</code></span>
<span class="codeline" id="line-890"><code>}</code></span>
<span class="codeline" id="line-891"><code></code></span>
<span class="codeline" id="line-892"><code>// stop stops a traceAdvancer and blocks until it exits.</code></span>
<span class="codeline" id="line-893"><code>func (s *traceAdvancerState) stop() {</code></span>
<span class="codeline" id="line-894"><code>	s.timer.wake()</code></span>
<span class="codeline" id="line-895"><code>	&lt;-s.done</code></span>
<span class="codeline" id="line-896"><code>	close(s.done)</code></span>
<span class="codeline" id="line-897"><code>	s.timer.close()</code></span>
<span class="codeline" id="line-898"><code>}</code></span>
<span class="codeline" id="line-899"><code></code></span>
<span class="codeline" id="line-900"><code>// traceAdvancePeriod is the approximate period between</code></span>
<span class="codeline" id="line-901"><code>// new generations.</code></span>
<span class="codeline" id="line-902"><code>const defaultTraceAdvancePeriod = 1e9 // 1 second.</code></span>
<span class="codeline" id="line-903"><code></code></span>
<span class="codeline" id="line-904"><code>// wakeableSleep manages a wakeable goroutine sleep.</code></span>
<span class="codeline" id="line-905"><code>//</code></span>
<span class="codeline" id="line-906"><code>// Users of this type must call init before first use and</code></span>
<span class="codeline" id="line-907"><code>// close to free up resources. Once close is called, init</code></span>
<span class="codeline" id="line-908"><code>// must be called before another use.</code></span>
<span class="codeline" id="line-909"><code>type wakeableSleep struct {</code></span>
<span class="codeline" id="line-910"><code>	timer *timer</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>	// lock protects access to wakeup, but not send/recv on it.</code></span>
<span class="codeline" id="line-913"><code>	lock   mutex</code></span>
<span class="codeline" id="line-914"><code>	wakeup chan struct{}</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>// newWakeableSleep initializes a new wakeableSleep and returns it.</code></span>
<span class="codeline" id="line-918"><code>func newWakeableSleep() *wakeableSleep {</code></span>
<span class="codeline" id="line-919"><code>	s := new(wakeableSleep)</code></span>
<span class="codeline" id="line-920"><code>	lockInit(&amp;s.lock, lockRankWakeableSleep)</code></span>
<span class="codeline" id="line-921"><code>	s.wakeup = make(chan struct{}, 1)</code></span>
<span class="codeline" id="line-922"><code>	s.timer = new(timer)</code></span>
<span class="codeline" id="line-923"><code>	s.timer.arg = s</code></span>
<span class="codeline" id="line-924"><code>	s.timer.f = func(s any, _ uintptr) {</code></span>
<span class="codeline" id="line-925"><code>		s.(*wakeableSleep).wake()</code></span>
<span class="codeline" id="line-926"><code>	}</code></span>
<span class="codeline" id="line-927"><code>	return s</code></span>
<span class="codeline" id="line-928"><code>}</code></span>
<span class="codeline" id="line-929"><code></code></span>
<span class="codeline" id="line-930"><code>// sleep sleeps for the provided duration in nanoseconds or until</code></span>
<span class="codeline" id="line-931"><code>// another goroutine calls wake.</code></span>
<span class="codeline" id="line-932"><code>//</code></span>
<span class="codeline" id="line-933"><code>// Must not be called by more than one goroutine at a time and</code></span>
<span class="codeline" id="line-934"><code>// must not be called concurrently with close.</code></span>
<span class="codeline" id="line-935"><code>func (s *wakeableSleep) sleep(ns int64) {</code></span>
<span class="codeline" id="line-936"><code>	resetTimer(s.timer, nanotime()+ns)</code></span>
<span class="codeline" id="line-937"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-938"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-939"><code>		raceacquire(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-940"><code>	}</code></span>
<span class="codeline" id="line-941"><code>	wakeup := s.wakeup</code></span>
<span class="codeline" id="line-942"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-943"><code>		racerelease(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-944"><code>	}</code></span>
<span class="codeline" id="line-945"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-946"><code>	&lt;-wakeup</code></span>
<span class="codeline" id="line-947"><code>	stopTimer(s.timer)</code></span>
<span class="codeline" id="line-948"><code>}</code></span>
<span class="codeline" id="line-949"><code></code></span>
<span class="codeline" id="line-950"><code>// wake awakens any goroutine sleeping on the timer.</code></span>
<span class="codeline" id="line-951"><code>//</code></span>
<span class="codeline" id="line-952"><code>// Safe for concurrent use with all other methods.</code></span>
<span class="codeline" id="line-953"><code>func (s *wakeableSleep) wake() {</code></span>
<span class="codeline" id="line-954"><code>	// Grab the wakeup channel, which may be nil if we're</code></span>
<span class="codeline" id="line-955"><code>	// racing with close.</code></span>
<span class="codeline" id="line-956"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-957"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-958"><code>		raceacquire(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-959"><code>	}</code></span>
<span class="codeline" id="line-960"><code>	if s.wakeup != nil {</code></span>
<span class="codeline" id="line-961"><code>		// Non-blocking send.</code></span>
<span class="codeline" id="line-962"><code>		//</code></span>
<span class="codeline" id="line-963"><code>		// Others may also write to this channel and we don't</code></span>
<span class="codeline" id="line-964"><code>		// want to block on the receiver waking up. This also</code></span>
<span class="codeline" id="line-965"><code>		// effectively batches together wakeup notifications.</code></span>
<span class="codeline" id="line-966"><code>		select {</code></span>
<span class="codeline" id="line-967"><code>		case s.wakeup &lt;- struct{}{}:</code></span>
<span class="codeline" id="line-968"><code>		default:</code></span>
<span class="codeline" id="line-969"><code>		}</code></span>
<span class="codeline" id="line-970"><code>	}</code></span>
<span class="codeline" id="line-971"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-972"><code>		racerelease(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-973"><code>	}</code></span>
<span class="codeline" id="line-974"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-975"><code>}</code></span>
<span class="codeline" id="line-976"><code></code></span>
<span class="codeline" id="line-977"><code>// close wakes any goroutine sleeping on the timer and prevents</code></span>
<span class="codeline" id="line-978"><code>// further sleeping on it.</code></span>
<span class="codeline" id="line-979"><code>//</code></span>
<span class="codeline" id="line-980"><code>// Once close is called, the wakeableSleep must no longer be used.</code></span>
<span class="codeline" id="line-981"><code>//</code></span>
<span class="codeline" id="line-982"><code>// It must only be called once no goroutine is sleeping on the</code></span>
<span class="codeline" id="line-983"><code>// timer *and* nothing else will call wake concurrently.</code></span>
<span class="codeline" id="line-984"><code>func (s *wakeableSleep) close() {</code></span>
<span class="codeline" id="line-985"><code>	// Set wakeup to nil so that a late timer ends up being a no-op.</code></span>
<span class="codeline" id="line-986"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-987"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-988"><code>		raceacquire(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-989"><code>	}</code></span>
<span class="codeline" id="line-990"><code>	wakeup := s.wakeup</code></span>
<span class="codeline" id="line-991"><code>	s.wakeup = nil</code></span>
<span class="codeline" id="line-992"><code></code></span>
<span class="codeline" id="line-993"><code>	// Close the channel.</code></span>
<span class="codeline" id="line-994"><code>	close(wakeup)</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-997"><code>		racerelease(unsafe.Pointer(&amp;s.lock))</code></span>
<span class="codeline" id="line-998"><code>	}</code></span>
<span class="codeline" id="line-999"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-1000"><code>	return</code></span>
<span class="codeline" id="line-1001"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>