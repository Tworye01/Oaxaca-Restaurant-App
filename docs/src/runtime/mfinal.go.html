<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mfinal.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mfinal.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Garbage collector: finalizers and block profiling.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"internal/abi"</code></span>
<span class="codeline" id="line-11"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-12"><code>	"internal/goexperiment"</code></span>
<span class="codeline" id="line-13"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-14"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-15"><code>	"unsafe"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// finblock is an array of finalizers to be executed. finblocks are</code></span>
<span class="codeline" id="line-19"><code>// arranged in a linked list for the finalizer queue.</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>// finblock is allocated from non-GC'd memory, so any heap pointers</code></span>
<span class="codeline" id="line-22"><code>// must be specially handled. GC currently assumes that the finalizer</code></span>
<span class="codeline" id="line-23"><code>// queue does not grow during marking (but it can shrink).</code></span>
<span class="codeline" id="line-24"><code>type finblock struct {</code></span>
<span class="codeline" id="line-25"><code>	_       sys.NotInHeap</code></span>
<span class="codeline" id="line-26"><code>	alllink *finblock</code></span>
<span class="codeline" id="line-27"><code>	next    *finblock</code></span>
<span class="codeline" id="line-28"><code>	cnt     uint32</code></span>
<span class="codeline" id="line-29"><code>	_       int32</code></span>
<span class="codeline" id="line-30"><code>	fin     [(_FinBlockSize - 2*goarch.PtrSize - 2*4) / unsafe.Sizeof(finalizer{})]finalizer</code></span>
<span class="codeline" id="line-31"><code>}</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>var fingStatus atomic.Uint32</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>// finalizer goroutine status.</code></span>
<span class="codeline" id="line-36"><code>const (</code></span>
<span class="codeline" id="line-37"><code>	fingUninitialized uint32 = iota</code></span>
<span class="codeline" id="line-38"><code>	fingCreated       uint32 = 1 &lt;&lt; (iota - 1)</code></span>
<span class="codeline" id="line-39"><code>	fingRunningFinalizer</code></span>
<span class="codeline" id="line-40"><code>	fingWait</code></span>
<span class="codeline" id="line-41"><code>	fingWake</code></span>
<span class="codeline" id="line-42"><code>)</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>var finlock mutex  // protects the following variables</code></span>
<span class="codeline" id="line-45"><code>var fing *g        // goroutine that runs finalizers</code></span>
<span class="codeline" id="line-46"><code>var finq *finblock // list of finalizers that are to be executed</code></span>
<span class="codeline" id="line-47"><code>var finc *finblock // cache of free blocks</code></span>
<span class="codeline" id="line-48"><code>var finptrmask [_FinBlockSize / goarch.PtrSize / 8]byte</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>var allfin *finblock // list of all blocks</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>// NOTE: Layout known to queuefinalizer.</code></span>
<span class="codeline" id="line-53"><code>type finalizer struct {</code></span>
<span class="codeline" id="line-54"><code>	fn   *funcval       // function to call (may be a heap pointer)</code></span>
<span class="codeline" id="line-55"><code>	arg  unsafe.Pointer // ptr to object (may be a heap pointer)</code></span>
<span class="codeline" id="line-56"><code>	nret uintptr        // bytes of return values from fn</code></span>
<span class="codeline" id="line-57"><code>	fint *_type         // type of first argument of fn</code></span>
<span class="codeline" id="line-58"><code>	ot   *ptrtype       // type of ptr to object (may be a heap pointer)</code></span>
<span class="codeline" id="line-59"><code>}</code></span>
<span class="codeline" id="line-60"><code></code></span>
<span class="codeline" id="line-61"><code>var finalizer1 = [...]byte{</code></span>
<span class="codeline" id="line-62"><code>	// Each Finalizer is 5 words, ptr ptr INT ptr ptr (INT = uintptr here)</code></span>
<span class="codeline" id="line-63"><code>	// Each byte describes 8 words.</code></span>
<span class="codeline" id="line-64"><code>	// Need 8 Finalizers described by 5 bytes before pattern repeats:</code></span>
<span class="codeline" id="line-65"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-66"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-67"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-68"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-69"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-70"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-71"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-72"><code>	//	ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-73"><code>	// aka</code></span>
<span class="codeline" id="line-74"><code>	//</code></span>
<span class="codeline" id="line-75"><code>	//	ptr ptr INT ptr ptr ptr ptr INT</code></span>
<span class="codeline" id="line-76"><code>	//	ptr ptr ptr ptr INT ptr ptr ptr</code></span>
<span class="codeline" id="line-77"><code>	//	ptr INT ptr ptr ptr ptr INT ptr</code></span>
<span class="codeline" id="line-78"><code>	//	ptr ptr ptr INT ptr ptr ptr ptr</code></span>
<span class="codeline" id="line-79"><code>	//	INT ptr ptr ptr ptr INT ptr ptr</code></span>
<span class="codeline" id="line-80"><code>	//</code></span>
<span class="codeline" id="line-81"><code>	// Assumptions about Finalizer layout checked below.</code></span>
<span class="codeline" id="line-82"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 0&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 0&lt;&lt;7,</code></span>
<span class="codeline" id="line-83"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 0&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-84"><code>	1&lt;&lt;0 | 0&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 0&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-85"><code>	1&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 0&lt;&lt;3 | 1&lt;&lt;4 | 1&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-86"><code>	0&lt;&lt;0 | 1&lt;&lt;1 | 1&lt;&lt;2 | 1&lt;&lt;3 | 1&lt;&lt;4 | 0&lt;&lt;5 | 1&lt;&lt;6 | 1&lt;&lt;7,</code></span>
<span class="codeline" id="line-87"><code>}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>// lockRankMayQueueFinalizer records the lock ranking effects of a</code></span>
<span class="codeline" id="line-90"><code>// function that may call queuefinalizer.</code></span>
<span class="codeline" id="line-91"><code>func lockRankMayQueueFinalizer() {</code></span>
<span class="codeline" id="line-92"><code>	lockWithRankMayAcquire(&amp;finlock, getLockRank(&amp;finlock))</code></span>
<span class="codeline" id="line-93"><code>}</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype) {</code></span>
<span class="codeline" id="line-96"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-97"><code>		// Currently we assume that the finalizer queue won't</code></span>
<span class="codeline" id="line-98"><code>		// grow during marking so we don't have to rescan it</code></span>
<span class="codeline" id="line-99"><code>		// during mark termination. If we ever need to lift</code></span>
<span class="codeline" id="line-100"><code>		// this assumption, we can do it by adding the</code></span>
<span class="codeline" id="line-101"><code>		// necessary barriers to queuefinalizer (which it may</code></span>
<span class="codeline" id="line-102"><code>		// have automatically).</code></span>
<span class="codeline" id="line-103"><code>		throw("queuefinalizer during GC")</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>	lock(&amp;finlock)</code></span>
<span class="codeline" id="line-107"><code>	if finq == nil || finq.cnt == uint32(len(finq.fin)) {</code></span>
<span class="codeline" id="line-108"><code>		if finc == nil {</code></span>
<span class="codeline" id="line-109"><code>			finc = (*finblock)(persistentalloc(_FinBlockSize, 0, &amp;memstats.gcMiscSys))</code></span>
<span class="codeline" id="line-110"><code>			finc.alllink = allfin</code></span>
<span class="codeline" id="line-111"><code>			allfin = finc</code></span>
<span class="codeline" id="line-112"><code>			if finptrmask[0] == 0 {</code></span>
<span class="codeline" id="line-113"><code>				// Build pointer mask for Finalizer array in block.</code></span>
<span class="codeline" id="line-114"><code>				// Check assumptions made in finalizer1 array above.</code></span>
<span class="codeline" id="line-115"><code>				if (unsafe.Sizeof(finalizer{}) != 5*goarch.PtrSize ||</code></span>
<span class="codeline" id="line-116"><code>					unsafe.Offsetof(finalizer{}.fn) != 0 ||</code></span>
<span class="codeline" id="line-117"><code>					unsafe.Offsetof(finalizer{}.arg) != goarch.PtrSize ||</code></span>
<span class="codeline" id="line-118"><code>					unsafe.Offsetof(finalizer{}.nret) != 2*goarch.PtrSize ||</code></span>
<span class="codeline" id="line-119"><code>					unsafe.Offsetof(finalizer{}.fint) != 3*goarch.PtrSize ||</code></span>
<span class="codeline" id="line-120"><code>					unsafe.Offsetof(finalizer{}.ot) != 4*goarch.PtrSize) {</code></span>
<span class="codeline" id="line-121"><code>					throw("finalizer out of sync")</code></span>
<span class="codeline" id="line-122"><code>				}</code></span>
<span class="codeline" id="line-123"><code>				for i := range finptrmask {</code></span>
<span class="codeline" id="line-124"><code>					finptrmask[i] = finalizer1[i%len(finalizer1)]</code></span>
<span class="codeline" id="line-125"><code>				}</code></span>
<span class="codeline" id="line-126"><code>			}</code></span>
<span class="codeline" id="line-127"><code>		}</code></span>
<span class="codeline" id="line-128"><code>		block := finc</code></span>
<span class="codeline" id="line-129"><code>		finc = block.next</code></span>
<span class="codeline" id="line-130"><code>		block.next = finq</code></span>
<span class="codeline" id="line-131"><code>		finq = block</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	f := &amp;finq.fin[finq.cnt]</code></span>
<span class="codeline" id="line-134"><code>	atomic.Xadd(&amp;finq.cnt, +1) // Sync with markroots</code></span>
<span class="codeline" id="line-135"><code>	f.fn = fn</code></span>
<span class="codeline" id="line-136"><code>	f.nret = nret</code></span>
<span class="codeline" id="line-137"><code>	f.fint = fint</code></span>
<span class="codeline" id="line-138"><code>	f.ot = ot</code></span>
<span class="codeline" id="line-139"><code>	f.arg = p</code></span>
<span class="codeline" id="line-140"><code>	unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-141"><code>	fingStatus.Or(fingWake)</code></span>
<span class="codeline" id="line-142"><code>}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-145"><code>func iterate_finq(callback func(*funcval, unsafe.Pointer, uintptr, *_type, *ptrtype)) {</code></span>
<span class="codeline" id="line-146"><code>	for fb := allfin; fb != nil; fb = fb.alllink {</code></span>
<span class="codeline" id="line-147"><code>		for i := uint32(0); i &lt; fb.cnt; i++ {</code></span>
<span class="codeline" id="line-148"><code>			f := &amp;fb.fin[i]</code></span>
<span class="codeline" id="line-149"><code>			callback(f.fn, f.arg, f.nret, f.fint, f.ot)</code></span>
<span class="codeline" id="line-150"><code>		}</code></span>
<span class="codeline" id="line-151"><code>	}</code></span>
<span class="codeline" id="line-152"><code>}</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>func wakefing() *g {</code></span>
<span class="codeline" id="line-155"><code>	if ok := fingStatus.CompareAndSwap(fingCreated|fingWait|fingWake, fingCreated); ok {</code></span>
<span class="codeline" id="line-156"><code>		return fing</code></span>
<span class="codeline" id="line-157"><code>	}</code></span>
<span class="codeline" id="line-158"><code>	return nil</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>func createfing() {</code></span>
<span class="codeline" id="line-162"><code>	// start the finalizer goroutine exactly once</code></span>
<span class="codeline" id="line-163"><code>	if fingStatus.Load() == fingUninitialized &amp;&amp; fingStatus.CompareAndSwap(fingUninitialized, fingCreated) {</code></span>
<span class="codeline" id="line-164"><code>		go runfinq()</code></span>
<span class="codeline" id="line-165"><code>	}</code></span>
<span class="codeline" id="line-166"><code>}</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>func finalizercommit(gp *g, lock unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-169"><code>	unlock((*mutex)(lock))</code></span>
<span class="codeline" id="line-170"><code>	// fingStatus should be modified after fing is put into a waiting state</code></span>
<span class="codeline" id="line-171"><code>	// to avoid waking fing in running state, even if it is about to be parked.</code></span>
<span class="codeline" id="line-172"><code>	fingStatus.Or(fingWait)</code></span>
<span class="codeline" id="line-173"><code>	return true</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// This is the goroutine that runs all of the finalizers.</code></span>
<span class="codeline" id="line-177"><code>func runfinq() {</code></span>
<span class="codeline" id="line-178"><code>	var (</code></span>
<span class="codeline" id="line-179"><code>		frame    unsafe.Pointer</code></span>
<span class="codeline" id="line-180"><code>		framecap uintptr</code></span>
<span class="codeline" id="line-181"><code>		argRegs  int</code></span>
<span class="codeline" id="line-182"><code>	)</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	gp := getg()</code></span>
<span class="codeline" id="line-185"><code>	lock(&amp;finlock)</code></span>
<span class="codeline" id="line-186"><code>	fing = gp</code></span>
<span class="codeline" id="line-187"><code>	unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	for {</code></span>
<span class="codeline" id="line-190"><code>		lock(&amp;finlock)</code></span>
<span class="codeline" id="line-191"><code>		fb := finq</code></span>
<span class="codeline" id="line-192"><code>		finq = nil</code></span>
<span class="codeline" id="line-193"><code>		if fb == nil {</code></span>
<span class="codeline" id="line-194"><code>			gopark(finalizercommit, unsafe.Pointer(&amp;finlock), waitReasonFinalizerWait, traceBlockSystemGoroutine, 1)</code></span>
<span class="codeline" id="line-195"><code>			continue</code></span>
<span class="codeline" id="line-196"><code>		}</code></span>
<span class="codeline" id="line-197"><code>		argRegs = intArgRegs</code></span>
<span class="codeline" id="line-198"><code>		unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-199"><code>		if raceenabled {</code></span>
<span class="codeline" id="line-200"><code>			racefingo()</code></span>
<span class="codeline" id="line-201"><code>		}</code></span>
<span class="codeline" id="line-202"><code>		for fb != nil {</code></span>
<span class="codeline" id="line-203"><code>			for i := fb.cnt; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-204"><code>				f := &amp;fb.fin[i-1]</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>				var regs abi.RegArgs</code></span>
<span class="codeline" id="line-207"><code>				// The args may be passed in registers or on stack. Even for</code></span>
<span class="codeline" id="line-208"><code>				// the register case, we still need the spill slots.</code></span>
<span class="codeline" id="line-209"><code>				// TODO: revisit if we remove spill slots.</code></span>
<span class="codeline" id="line-210"><code>				//</code></span>
<span class="codeline" id="line-211"><code>				// Unfortunately because we can have an arbitrary</code></span>
<span class="codeline" id="line-212"><code>				// amount of returns and it would be complex to try and</code></span>
<span class="codeline" id="line-213"><code>				// figure out how many of those can get passed in registers,</code></span>
<span class="codeline" id="line-214"><code>				// just conservatively assume none of them do.</code></span>
<span class="codeline" id="line-215"><code>				framesz := unsafe.Sizeof((any)(nil)) + f.nret</code></span>
<span class="codeline" id="line-216"><code>				if framecap &lt; framesz {</code></span>
<span class="codeline" id="line-217"><code>					// The frame does not contain pointers interesting for GC,</code></span>
<span class="codeline" id="line-218"><code>					// all not yet finalized objects are stored in finq.</code></span>
<span class="codeline" id="line-219"><code>					// If we do not mark it as FlagNoScan,</code></span>
<span class="codeline" id="line-220"><code>					// the last finalized object is not collected.</code></span>
<span class="codeline" id="line-221"><code>					frame = mallocgc(framesz, nil, true)</code></span>
<span class="codeline" id="line-222"><code>					framecap = framesz</code></span>
<span class="codeline" id="line-223"><code>				}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>				if f.fint == nil {</code></span>
<span class="codeline" id="line-226"><code>					throw("missing type in runfinq")</code></span>
<span class="codeline" id="line-227"><code>				}</code></span>
<span class="codeline" id="line-228"><code>				r := frame</code></span>
<span class="codeline" id="line-229"><code>				if argRegs &gt; 0 {</code></span>
<span class="codeline" id="line-230"><code>					r = unsafe.Pointer(&amp;regs.Ints)</code></span>
<span class="codeline" id="line-231"><code>				} else {</code></span>
<span class="codeline" id="line-232"><code>					// frame is effectively uninitialized</code></span>
<span class="codeline" id="line-233"><code>					// memory. That means we have to clear</code></span>
<span class="codeline" id="line-234"><code>					// it before writing to it to avoid</code></span>
<span class="codeline" id="line-235"><code>					// confusing the write barrier.</code></span>
<span class="codeline" id="line-236"><code>					*(*[2]uintptr)(frame) = [2]uintptr{}</code></span>
<span class="codeline" id="line-237"><code>				}</code></span>
<span class="codeline" id="line-238"><code>				switch f.fint.Kind_ &amp; kindMask {</code></span>
<span class="codeline" id="line-239"><code>				case kindPtr:</code></span>
<span class="codeline" id="line-240"><code>					// direct use of pointer</code></span>
<span class="codeline" id="line-241"><code>					*(*unsafe.Pointer)(r) = f.arg</code></span>
<span class="codeline" id="line-242"><code>				case kindInterface:</code></span>
<span class="codeline" id="line-243"><code>					ityp := (*interfacetype)(unsafe.Pointer(f.fint))</code></span>
<span class="codeline" id="line-244"><code>					// set up with empty interface</code></span>
<span class="codeline" id="line-245"><code>					(*eface)(r)._type = &amp;f.ot.Type</code></span>
<span class="codeline" id="line-246"><code>					(*eface)(r).data = f.arg</code></span>
<span class="codeline" id="line-247"><code>					if len(ityp.Methods) != 0 {</code></span>
<span class="codeline" id="line-248"><code>						// convert to interface with methods</code></span>
<span class="codeline" id="line-249"><code>						// this conversion is guaranteed to succeed - we checked in SetFinalizer</code></span>
<span class="codeline" id="line-250"><code>						(*iface)(r).tab = assertE2I(ityp, (*eface)(r)._type)</code></span>
<span class="codeline" id="line-251"><code>					}</code></span>
<span class="codeline" id="line-252"><code>				default:</code></span>
<span class="codeline" id="line-253"><code>					throw("bad kind in runfinq")</code></span>
<span class="codeline" id="line-254"><code>				}</code></span>
<span class="codeline" id="line-255"><code>				fingStatus.Or(fingRunningFinalizer)</code></span>
<span class="codeline" id="line-256"><code>				reflectcall(nil, unsafe.Pointer(f.fn), frame, uint32(framesz), uint32(framesz), uint32(framesz), &amp;regs)</code></span>
<span class="codeline" id="line-257"><code>				fingStatus.And(^fingRunningFinalizer)</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>				// Drop finalizer queue heap references</code></span>
<span class="codeline" id="line-260"><code>				// before hiding them from markroot.</code></span>
<span class="codeline" id="line-261"><code>				// This also ensures these will be</code></span>
<span class="codeline" id="line-262"><code>				// clear if we reuse the finalizer.</code></span>
<span class="codeline" id="line-263"><code>				f.fn = nil</code></span>
<span class="codeline" id="line-264"><code>				f.arg = nil</code></span>
<span class="codeline" id="line-265"><code>				f.ot = nil</code></span>
<span class="codeline" id="line-266"><code>				atomic.Store(&amp;fb.cnt, i-1)</code></span>
<span class="codeline" id="line-267"><code>			}</code></span>
<span class="codeline" id="line-268"><code>			next := fb.next</code></span>
<span class="codeline" id="line-269"><code>			lock(&amp;finlock)</code></span>
<span class="codeline" id="line-270"><code>			fb.next = finc</code></span>
<span class="codeline" id="line-271"><code>			finc = fb</code></span>
<span class="codeline" id="line-272"><code>			unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-273"><code>			fb = next</code></span>
<span class="codeline" id="line-274"><code>		}</code></span>
<span class="codeline" id="line-275"><code>	}</code></span>
<span class="codeline" id="line-276"><code>}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>func isGoPointerWithoutSpan(p unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-279"><code>	// 0-length objects are okay.</code></span>
<span class="codeline" id="line-280"><code>	if p == unsafe.Pointer(&amp;zerobase) {</code></span>
<span class="codeline" id="line-281"><code>		return true</code></span>
<span class="codeline" id="line-282"><code>	}</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>	// Global initializers might be linker-allocated.</code></span>
<span class="codeline" id="line-285"><code>	//	var Foo = &amp;Object{}</code></span>
<span class="codeline" id="line-286"><code>	//	func main() {</code></span>
<span class="codeline" id="line-287"><code>	//		runtime.SetFinalizer(Foo, nil)</code></span>
<span class="codeline" id="line-288"><code>	//	}</code></span>
<span class="codeline" id="line-289"><code>	// The relevant segments are: noptrdata, data, bss, noptrbss.</code></span>
<span class="codeline" id="line-290"><code>	// We cannot assume they are in any order or even contiguous,</code></span>
<span class="codeline" id="line-291"><code>	// due to external linking.</code></span>
<span class="codeline" id="line-292"><code>	for datap := &amp;firstmoduledata; datap != nil; datap = datap.next {</code></span>
<span class="codeline" id="line-293"><code>		if datap.noptrdata &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; datap.enoptrdata ||</code></span>
<span class="codeline" id="line-294"><code>			datap.data &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; datap.edata ||</code></span>
<span class="codeline" id="line-295"><code>			datap.bss &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; datap.ebss ||</code></span>
<span class="codeline" id="line-296"><code>			datap.noptrbss &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; datap.enoptrbss {</code></span>
<span class="codeline" id="line-297"><code>			return true</code></span>
<span class="codeline" id="line-298"><code>		}</code></span>
<span class="codeline" id="line-299"><code>	}</code></span>
<span class="codeline" id="line-300"><code>	return false</code></span>
<span class="codeline" id="line-301"><code>}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>// blockUntilEmptyFinalizerQueue blocks until either the finalizer</code></span>
<span class="codeline" id="line-304"><code>// queue is emptied (and the finalizers have executed) or the timeout</code></span>
<span class="codeline" id="line-305"><code>// is reached. Returns true if the finalizer queue was emptied.</code></span>
<span class="codeline" id="line-306"><code>// This is used by the runtime and sync tests.</code></span>
<span class="codeline" id="line-307"><code>func blockUntilEmptyFinalizerQueue(timeout int64) bool {</code></span>
<span class="codeline" id="line-308"><code>	start := nanotime()</code></span>
<span class="codeline" id="line-309"><code>	for nanotime()-start &lt; timeout {</code></span>
<span class="codeline" id="line-310"><code>		lock(&amp;finlock)</code></span>
<span class="codeline" id="line-311"><code>		// We know the queue has been drained when both finq is nil</code></span>
<span class="codeline" id="line-312"><code>		// and the finalizer g has stopped executing.</code></span>
<span class="codeline" id="line-313"><code>		empty := finq == nil</code></span>
<span class="codeline" id="line-314"><code>		empty = empty &amp;&amp; readgstatus(fing) == _Gwaiting &amp;&amp; fing.waitreason == waitReasonFinalizerWait</code></span>
<span class="codeline" id="line-315"><code>		unlock(&amp;finlock)</code></span>
<span class="codeline" id="line-316"><code>		if empty {</code></span>
<span class="codeline" id="line-317"><code>			return true</code></span>
<span class="codeline" id="line-318"><code>		}</code></span>
<span class="codeline" id="line-319"><code>		Gosched()</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	return false</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// SetFinalizer sets the finalizer associated with obj to the provided</code></span>
<span class="codeline" id="line-325"><code>// finalizer function. When the garbage collector finds an unreachable block</code></span>
<span class="codeline" id="line-326"><code>// with an associated finalizer, it clears the association and runs</code></span>
<span class="codeline" id="line-327"><code>// finalizer(obj) in a separate goroutine. This makes obj reachable again,</code></span>
<span class="codeline" id="line-328"><code>// but now without an associated finalizer. Assuming that SetFinalizer</code></span>
<span class="codeline" id="line-329"><code>// is not called again, the next time the garbage collector sees</code></span>
<span class="codeline" id="line-330"><code>// that obj is unreachable, it will free obj.</code></span>
<span class="codeline" id="line-331"><code>//</code></span>
<span class="codeline" id="line-332"><code>// SetFinalizer(obj, nil) clears any finalizer associated with obj.</code></span>
<span class="codeline" id="line-333"><code>//</code></span>
<span class="codeline" id="line-334"><code>// The argument obj must be a pointer to an object allocated by calling</code></span>
<span class="codeline" id="line-335"><code>// new, by taking the address of a composite literal, or by taking the</code></span>
<span class="codeline" id="line-336"><code>// address of a local variable.</code></span>
<span class="codeline" id="line-337"><code>// The argument finalizer must be a function that takes a single argument</code></span>
<span class="codeline" id="line-338"><code>// to which obj's type can be assigned, and can have arbitrary ignored return</code></span>
<span class="codeline" id="line-339"><code>// values. If either of these is not true, SetFinalizer may abort the</code></span>
<span class="codeline" id="line-340"><code>// program.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// Finalizers are run in dependency order: if A points at B, both have</code></span>
<span class="codeline" id="line-343"><code>// finalizers, and they are otherwise unreachable, only the finalizer</code></span>
<span class="codeline" id="line-344"><code>// for A runs; once A is freed, the finalizer for B can run.</code></span>
<span class="codeline" id="line-345"><code>// If a cyclic structure includes a block with a finalizer, that</code></span>
<span class="codeline" id="line-346"><code>// cycle is not guaranteed to be garbage collected and the finalizer</code></span>
<span class="codeline" id="line-347"><code>// is not guaranteed to run, because there is no ordering that</code></span>
<span class="codeline" id="line-348"><code>// respects the dependencies.</code></span>
<span class="codeline" id="line-349"><code>//</code></span>
<span class="codeline" id="line-350"><code>// The finalizer is scheduled to run at some arbitrary time after the</code></span>
<span class="codeline" id="line-351"><code>// program can no longer reach the object to which obj points.</code></span>
<span class="codeline" id="line-352"><code>// There is no guarantee that finalizers will run before a program exits,</code></span>
<span class="codeline" id="line-353"><code>// so typically they are useful only for releasing non-memory resources</code></span>
<span class="codeline" id="line-354"><code>// associated with an object during a long-running program.</code></span>
<span class="codeline" id="line-355"><code>// For example, an [os.File] object could use a finalizer to close the</code></span>
<span class="codeline" id="line-356"><code>// associated operating system file descriptor when a program discards</code></span>
<span class="codeline" id="line-357"><code>// an os.File without calling Close, but it would be a mistake</code></span>
<span class="codeline" id="line-358"><code>// to depend on a finalizer to flush an in-memory I/O buffer such as a</code></span>
<span class="codeline" id="line-359"><code>// [bufio.Writer], because the buffer would not be flushed at program exit.</code></span>
<span class="codeline" id="line-360"><code>//</code></span>
<span class="codeline" id="line-361"><code>// It is not guaranteed that a finalizer will run if the size of *obj is</code></span>
<span class="codeline" id="line-362"><code>// zero bytes, because it may share same address with other zero-size</code></span>
<span class="codeline" id="line-363"><code>// objects in memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees.</code></span>
<span class="codeline" id="line-364"><code>//</code></span>
<span class="codeline" id="line-365"><code>// It is not guaranteed that a finalizer will run for objects allocated</code></span>
<span class="codeline" id="line-366"><code>// in initializers for package-level variables. Such objects may be</code></span>
<span class="codeline" id="line-367"><code>// linker-allocated, not heap-allocated.</code></span>
<span class="codeline" id="line-368"><code>//</code></span>
<span class="codeline" id="line-369"><code>// Note that because finalizers may execute arbitrarily far into the future</code></span>
<span class="codeline" id="line-370"><code>// after an object is no longer referenced, the runtime is allowed to perform</code></span>
<span class="codeline" id="line-371"><code>// a space-saving optimization that batches objects together in a single</code></span>
<span class="codeline" id="line-372"><code>// allocation slot. The finalizer for an unreferenced object in such an</code></span>
<span class="codeline" id="line-373"><code>// allocation may never run if it always exists in the same batch as a</code></span>
<span class="codeline" id="line-374"><code>// referenced object. Typically, this batching only happens for tiny</code></span>
<span class="codeline" id="line-375"><code>// (on the order of 16 bytes or less) and pointer-free objects.</code></span>
<span class="codeline" id="line-376"><code>//</code></span>
<span class="codeline" id="line-377"><code>// A finalizer may run as soon as an object becomes unreachable.</code></span>
<span class="codeline" id="line-378"><code>// In order to use finalizers correctly, the program must ensure that</code></span>
<span class="codeline" id="line-379"><code>// the object is reachable until it is no longer required.</code></span>
<span class="codeline" id="line-380"><code>// Objects stored in global variables, or that can be found by tracing</code></span>
<span class="codeline" id="line-381"><code>// pointers from a global variable, are reachable. For other objects,</code></span>
<span class="codeline" id="line-382"><code>// pass the object to a call of the [KeepAlive] function to mark the</code></span>
<span class="codeline" id="line-383"><code>// last point in the function where the object must be reachable.</code></span>
<span class="codeline" id="line-384"><code>//</code></span>
<span class="codeline" id="line-385"><code>// For example, if p points to a struct, such as os.File, that contains</code></span>
<span class="codeline" id="line-386"><code>// a file descriptor d, and p has a finalizer that closes that file</code></span>
<span class="codeline" id="line-387"><code>// descriptor, and if the last use of p in a function is a call to</code></span>
<span class="codeline" id="line-388"><code>// syscall.Write(p.d, buf, size), then p may be unreachable as soon as</code></span>
<span class="codeline" id="line-389"><code>// the program enters [syscall.Write]. The finalizer may run at that moment,</code></span>
<span class="codeline" id="line-390"><code>// closing p.d, causing syscall.Write to fail because it is writing to</code></span>
<span class="codeline" id="line-391"><code>// a closed file descriptor (or, worse, to an entirely different</code></span>
<span class="codeline" id="line-392"><code>// file descriptor opened by a different goroutine). To avoid this problem,</code></span>
<span class="codeline" id="line-393"><code>// call KeepAlive(p) after the call to syscall.Write.</code></span>
<span class="codeline" id="line-394"><code>//</code></span>
<span class="codeline" id="line-395"><code>// A single goroutine runs all finalizers for a program, sequentially.</code></span>
<span class="codeline" id="line-396"><code>// If a finalizer must run for a long time, it should do so by starting</code></span>
<span class="codeline" id="line-397"><code>// a new goroutine.</code></span>
<span class="codeline" id="line-398"><code>//</code></span>
<span class="codeline" id="line-399"><code>// In the terminology of the Go memory model, a call</code></span>
<span class="codeline" id="line-400"><code>// SetFinalizer(x, f) “synchronizes before” the finalization call f(x).</code></span>
<span class="codeline" id="line-401"><code>// However, there is no guarantee that KeepAlive(x) or any other use of x</code></span>
<span class="codeline" id="line-402"><code>// “synchronizes before” f(x), so in general a finalizer should use a mutex</code></span>
<span class="codeline" id="line-403"><code>// or other synchronization mechanism if it needs to access mutable state in x.</code></span>
<span class="codeline" id="line-404"><code>// For example, consider a finalizer that inspects a mutable field in x</code></span>
<span class="codeline" id="line-405"><code>// that is modified from time to time in the main program before x</code></span>
<span class="codeline" id="line-406"><code>// becomes unreachable and the finalizer is invoked.</code></span>
<span class="codeline" id="line-407"><code>// The modifications in the main program and the inspection in the finalizer</code></span>
<span class="codeline" id="line-408"><code>// need to use appropriate synchronization, such as mutexes or atomic updates,</code></span>
<span class="codeline" id="line-409"><code>// to avoid read-write races.</code></span>
<span class="codeline" id="line-410"><code>func SetFinalizer(obj any, finalizer any) {</code></span>
<span class="codeline" id="line-411"><code>	if debug.sbrk != 0 {</code></span>
<span class="codeline" id="line-412"><code>		// debug.sbrk never frees memory, so no finalizers run</code></span>
<span class="codeline" id="line-413"><code>		// (and we don't have the data structures to record them).</code></span>
<span class="codeline" id="line-414"><code>		return</code></span>
<span class="codeline" id="line-415"><code>	}</code></span>
<span class="codeline" id="line-416"><code>	e := efaceOf(&amp;obj)</code></span>
<span class="codeline" id="line-417"><code>	etyp := e._type</code></span>
<span class="codeline" id="line-418"><code>	if etyp == nil {</code></span>
<span class="codeline" id="line-419"><code>		throw("runtime.SetFinalizer: first argument is nil")</code></span>
<span class="codeline" id="line-420"><code>	}</code></span>
<span class="codeline" id="line-421"><code>	if etyp.Kind_&amp;kindMask != kindPtr {</code></span>
<span class="codeline" id="line-422"><code>		throw("runtime.SetFinalizer: first argument is " + toRType(etyp).string() + ", not pointer")</code></span>
<span class="codeline" id="line-423"><code>	}</code></span>
<span class="codeline" id="line-424"><code>	ot := (*ptrtype)(unsafe.Pointer(etyp))</code></span>
<span class="codeline" id="line-425"><code>	if ot.Elem == nil {</code></span>
<span class="codeline" id="line-426"><code>		throw("nil elem type!")</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>	if inUserArenaChunk(uintptr(e.data)) {</code></span>
<span class="codeline" id="line-430"><code>		// Arena-allocated objects are not eligible for finalizers.</code></span>
<span class="codeline" id="line-431"><code>		throw("runtime.SetFinalizer: first argument was allocated into an arena")</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>	// find the containing object</code></span>
<span class="codeline" id="line-435"><code>	base, span, _ := findObject(uintptr(e.data), 0, 0)</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	if base == 0 {</code></span>
<span class="codeline" id="line-438"><code>		if isGoPointerWithoutSpan(e.data) {</code></span>
<span class="codeline" id="line-439"><code>			return</code></span>
<span class="codeline" id="line-440"><code>		}</code></span>
<span class="codeline" id="line-441"><code>		throw("runtime.SetFinalizer: pointer not in allocated block")</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>	// Move base forward if we've got an allocation header.</code></span>
<span class="codeline" id="line-445"><code>	if goexperiment.AllocHeaders &amp;&amp; !span.spanclass.noscan() &amp;&amp; !heapBitsInSpan(span.elemsize) &amp;&amp; span.spanclass.sizeclass() != 0 {</code></span>
<span class="codeline" id="line-446"><code>		base += mallocHeaderSize</code></span>
<span class="codeline" id="line-447"><code>	}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>	if uintptr(e.data) != base {</code></span>
<span class="codeline" id="line-450"><code>		// As an implementation detail we allow to set finalizers for an inner byte</code></span>
<span class="codeline" id="line-451"><code>		// of an object if it could come from tiny alloc (see mallocgc for details).</code></span>
<span class="codeline" id="line-452"><code>		if ot.Elem == nil || ot.Elem.PtrBytes != 0 || ot.Elem.Size_ &gt;= maxTinySize {</code></span>
<span class="codeline" id="line-453"><code>			throw("runtime.SetFinalizer: pointer not at beginning of allocated block")</code></span>
<span class="codeline" id="line-454"><code>		}</code></span>
<span class="codeline" id="line-455"><code>	}</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>	f := efaceOf(&amp;finalizer)</code></span>
<span class="codeline" id="line-458"><code>	ftyp := f._type</code></span>
<span class="codeline" id="line-459"><code>	if ftyp == nil {</code></span>
<span class="codeline" id="line-460"><code>		// switch to system stack and remove finalizer</code></span>
<span class="codeline" id="line-461"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-462"><code>			removefinalizer(e.data)</code></span>
<span class="codeline" id="line-463"><code>		})</code></span>
<span class="codeline" id="line-464"><code>		return</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>	if ftyp.Kind_&amp;kindMask != kindFunc {</code></span>
<span class="codeline" id="line-468"><code>		throw("runtime.SetFinalizer: second argument is " + toRType(ftyp).string() + ", not a function")</code></span>
<span class="codeline" id="line-469"><code>	}</code></span>
<span class="codeline" id="line-470"><code>	ft := (*functype)(unsafe.Pointer(ftyp))</code></span>
<span class="codeline" id="line-471"><code>	if ft.IsVariadic() {</code></span>
<span class="codeline" id="line-472"><code>		throw("runtime.SetFinalizer: cannot pass " + toRType(etyp).string() + " to finalizer " + toRType(ftyp).string() + " because dotdotdot")</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code>	if ft.InCount != 1 {</code></span>
<span class="codeline" id="line-475"><code>		throw("runtime.SetFinalizer: cannot pass " + toRType(etyp).string() + " to finalizer " + toRType(ftyp).string())</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code>	fint := ft.InSlice()[0]</code></span>
<span class="codeline" id="line-478"><code>	switch {</code></span>
<span class="codeline" id="line-479"><code>	case fint == etyp:</code></span>
<span class="codeline" id="line-480"><code>		// ok - same type</code></span>
<span class="codeline" id="line-481"><code>		goto okarg</code></span>
<span class="codeline" id="line-482"><code>	case fint.Kind_&amp;kindMask == kindPtr:</code></span>
<span class="codeline" id="line-483"><code>		if (fint.Uncommon() == nil || etyp.Uncommon() == nil) &amp;&amp; (*ptrtype)(unsafe.Pointer(fint)).Elem == ot.Elem {</code></span>
<span class="codeline" id="line-484"><code>			// ok - not same type, but both pointers,</code></span>
<span class="codeline" id="line-485"><code>			// one or the other is unnamed, and same element type, so assignable.</code></span>
<span class="codeline" id="line-486"><code>			goto okarg</code></span>
<span class="codeline" id="line-487"><code>		}</code></span>
<span class="codeline" id="line-488"><code>	case fint.Kind_&amp;kindMask == kindInterface:</code></span>
<span class="codeline" id="line-489"><code>		ityp := (*interfacetype)(unsafe.Pointer(fint))</code></span>
<span class="codeline" id="line-490"><code>		if len(ityp.Methods) == 0 {</code></span>
<span class="codeline" id="line-491"><code>			// ok - satisfies empty interface</code></span>
<span class="codeline" id="line-492"><code>			goto okarg</code></span>
<span class="codeline" id="line-493"><code>		}</code></span>
<span class="codeline" id="line-494"><code>		if itab := assertE2I2(ityp, efaceOf(&amp;obj)._type); itab != nil {</code></span>
<span class="codeline" id="line-495"><code>			goto okarg</code></span>
<span class="codeline" id="line-496"><code>		}</code></span>
<span class="codeline" id="line-497"><code>	}</code></span>
<span class="codeline" id="line-498"><code>	throw("runtime.SetFinalizer: cannot pass " + toRType(etyp).string() + " to finalizer " + toRType(ftyp).string())</code></span>
<span class="codeline" id="line-499"><code>okarg:</code></span>
<span class="codeline" id="line-500"><code>	// compute size needed for return parameters</code></span>
<span class="codeline" id="line-501"><code>	nret := uintptr(0)</code></span>
<span class="codeline" id="line-502"><code>	for _, t := range ft.OutSlice() {</code></span>
<span class="codeline" id="line-503"><code>		nret = alignUp(nret, uintptr(t.Align_)) + t.Size_</code></span>
<span class="codeline" id="line-504"><code>	}</code></span>
<span class="codeline" id="line-505"><code>	nret = alignUp(nret, goarch.PtrSize)</code></span>
<span class="codeline" id="line-506"><code></code></span>
<span class="codeline" id="line-507"><code>	// make sure we have a finalizer goroutine</code></span>
<span class="codeline" id="line-508"><code>	createfing()</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-511"><code>		if !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) {</code></span>
<span class="codeline" id="line-512"><code>			throw("runtime.SetFinalizer: finalizer already set")</code></span>
<span class="codeline" id="line-513"><code>		}</code></span>
<span class="codeline" id="line-514"><code>	})</code></span>
<span class="codeline" id="line-515"><code>}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>// Mark KeepAlive as noinline so that it is easily detectable as an intrinsic.</code></span>
<span class="codeline" id="line-518"><code>//</code></span>
<span class="codeline" id="line-519"><code>//go:noinline</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>// KeepAlive marks its argument as currently reachable.</code></span>
<span class="codeline" id="line-522"><code>// This ensures that the object is not freed, and its finalizer is not run,</code></span>
<span class="codeline" id="line-523"><code>// before the point in the program where KeepAlive is called.</code></span>
<span class="codeline" id="line-524"><code>//</code></span>
<span class="codeline" id="line-525"><code>// A very simplified example showing where KeepAlive is required:</code></span>
<span class="codeline" id="line-526"><code>//</code></span>
<span class="codeline" id="line-527"><code>//	type File struct { d int }</code></span>
<span class="codeline" id="line-528"><code>//	d, err := syscall.Open("/file/path", syscall.O_RDONLY, 0)</code></span>
<span class="codeline" id="line-529"><code>//	// ... do something if err != nil ...</code></span>
<span class="codeline" id="line-530"><code>//	p := &amp;File{d}</code></span>
<span class="codeline" id="line-531"><code>//	runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })</code></span>
<span class="codeline" id="line-532"><code>//	var buf [10]byte</code></span>
<span class="codeline" id="line-533"><code>//	n, err := syscall.Read(p.d, buf[:])</code></span>
<span class="codeline" id="line-534"><code>//	// Ensure p is not finalized until Read returns.</code></span>
<span class="codeline" id="line-535"><code>//	runtime.KeepAlive(p)</code></span>
<span class="codeline" id="line-536"><code>//	// No more uses of p after this point.</code></span>
<span class="codeline" id="line-537"><code>//</code></span>
<span class="codeline" id="line-538"><code>// Without the KeepAlive call, the finalizer could run at the start of</code></span>
<span class="codeline" id="line-539"><code>// [syscall.Read], closing the file descriptor before syscall.Read makes</code></span>
<span class="codeline" id="line-540"><code>// the actual system call.</code></span>
<span class="codeline" id="line-541"><code>//</code></span>
<span class="codeline" id="line-542"><code>// Note: KeepAlive should only be used to prevent finalizers from</code></span>
<span class="codeline" id="line-543"><code>// running prematurely. In particular, when used with [unsafe.Pointer],</code></span>
<span class="codeline" id="line-544"><code>// the rules for valid uses of unsafe.Pointer still apply.</code></span>
<span class="codeline" id="line-545"><code>func KeepAlive(x any) {</code></span>
<span class="codeline" id="line-546"><code>	// Introduce a use of x that the compiler can't eliminate.</code></span>
<span class="codeline" id="line-547"><code>	// This makes sure x is alive on entry. We need x to be alive</code></span>
<span class="codeline" id="line-548"><code>	// on entry for "defer runtime.KeepAlive(x)"; see issue 21402.</code></span>
<span class="codeline" id="line-549"><code>	if cgoAlwaysFalse {</code></span>
<span class="codeline" id="line-550"><code>		println(x)</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>