<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mgcscavenge.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mgcscavenge.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2019 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Scavenging free pages.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// This file implements scavenging (the release of physical pages backing mapped</code></span>
<span class="codeline" id="line-8"><code>// memory) of free and unused pages in the heap as a way to deal with page-level</code></span>
<span class="codeline" id="line-9"><code>// fragmentation and reduce the RSS of Go applications.</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// Scavenging in Go happens on two fronts: there's the background</code></span>
<span class="codeline" id="line-12"><code>// (asynchronous) scavenger and the allocation-time (synchronous) scavenger.</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// The former happens on a goroutine much like the background sweeper which is</code></span>
<span class="codeline" id="line-15"><code>// soft-capped at using scavengePercent of the mutator's time, based on</code></span>
<span class="codeline" id="line-16"><code>// order-of-magnitude estimates of the costs of scavenging. The latter happens</code></span>
<span class="codeline" id="line-17"><code>// when allocating pages from the heap.</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// The scavenger's primary goal is to bring the estimated heap RSS of the</code></span>
<span class="codeline" id="line-20"><code>// application down to a goal.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// Before we consider what this looks like, we need to split the world into two</code></span>
<span class="codeline" id="line-23"><code>// halves. One in which a memory limit is not set, and one in which it is.</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// For the former, the goal is defined as:</code></span>
<span class="codeline" id="line-26"><code>//   (retainExtraPercent+100) / 100 * (heapGoal / lastHeapGoal) * lastHeapInUse</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>// Essentially, we wish to have the application's RSS track the heap goal, but</code></span>
<span class="codeline" id="line-29"><code>// the heap goal is defined in terms of bytes of objects, rather than pages like</code></span>
<span class="codeline" id="line-30"><code>// RSS. As a result, we need to take into account for fragmentation internal to</code></span>
<span class="codeline" id="line-31"><code>// spans. heapGoal / lastHeapGoal defines the ratio between the current heap goal</code></span>
<span class="codeline" id="line-32"><code>// and the last heap goal, which tells us by how much the heap is growing and</code></span>
<span class="codeline" id="line-33"><code>// shrinking. We estimate what the heap will grow to in terms of pages by taking</code></span>
<span class="codeline" id="line-34"><code>// this ratio and multiplying it by heapInUse at the end of the last GC, which</code></span>
<span class="codeline" id="line-35"><code>// allows us to account for this additional fragmentation. Note that this</code></span>
<span class="codeline" id="line-36"><code>// procedure makes the assumption that the degree of fragmentation won't change</code></span>
<span class="codeline" id="line-37"><code>// dramatically over the next GC cycle. Overestimating the amount of</code></span>
<span class="codeline" id="line-38"><code>// fragmentation simply results in higher memory use, which will be accounted</code></span>
<span class="codeline" id="line-39"><code>// for by the next pacing up date. Underestimating the fragmentation however</code></span>
<span class="codeline" id="line-40"><code>// could lead to performance degradation. Handling this case is not within the</code></span>
<span class="codeline" id="line-41"><code>// scope of the scavenger. Situations where the amount of fragmentation balloons</code></span>
<span class="codeline" id="line-42"><code>// over the course of a single GC cycle should be considered pathologies,</code></span>
<span class="codeline" id="line-43"><code>// flagged as bugs, and fixed appropriately.</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>// An additional factor of retainExtraPercent is added as a buffer to help ensure</code></span>
<span class="codeline" id="line-46"><code>// that there's more unscavenged memory to allocate out of, since each allocation</code></span>
<span class="codeline" id="line-47"><code>// out of scavenged memory incurs a potentially expensive page fault.</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// If a memory limit is set, then we wish to pick a scavenge goal that maintains</code></span>
<span class="codeline" id="line-50"><code>// that memory limit. For that, we look at total memory that has been committed</code></span>
<span class="codeline" id="line-51"><code>// (memstats.mappedReady) and try to bring that down below the limit. In this case,</code></span>
<span class="codeline" id="line-52"><code>// we want to give buffer space in the *opposite* direction. When the application</code></span>
<span class="codeline" id="line-53"><code>// is close to the limit, we want to make sure we push harder to keep it under, so</code></span>
<span class="codeline" id="line-54"><code>// if we target below the memory limit, we ensure that the background scavenger is</code></span>
<span class="codeline" id="line-55"><code>// giving the situation the urgency it deserves.</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>// In this case, the goal is defined as:</code></span>
<span class="codeline" id="line-58"><code>//    (100-reduceExtraPercent) / 100 * memoryLimit</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>// We compute both of these goals, and check whether either of them have been met.</code></span>
<span class="codeline" id="line-61"><code>// The background scavenger continues operating as long as either one of the goals</code></span>
<span class="codeline" id="line-62"><code>// has not been met.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// The goals are updated after each GC.</code></span>
<span class="codeline" id="line-65"><code>//</code></span>
<span class="codeline" id="line-66"><code>// Synchronous scavenging happens for one of two reasons: if an allocation would</code></span>
<span class="codeline" id="line-67"><code>// exceed the memory limit or whenever the heap grows in size, for some</code></span>
<span class="codeline" id="line-68"><code>// definition of heap-growth. The intuition behind this second reason is that the</code></span>
<span class="codeline" id="line-69"><code>// application had to grow the heap because existing fragments were not sufficiently</code></span>
<span class="codeline" id="line-70"><code>// large to satisfy a page-level memory allocation, so we scavenge those fragments</code></span>
<span class="codeline" id="line-71"><code>// eagerly to offset the growth in RSS that results.</code></span>
<span class="codeline" id="line-72"><code>//</code></span>
<span class="codeline" id="line-73"><code>// Lastly, not all pages are available for scavenging at all times and in all cases.</code></span>
<span class="codeline" id="line-74"><code>// The background scavenger and heap-growth scavenger only release memory in chunks</code></span>
<span class="codeline" id="line-75"><code>// that have not been densely-allocated for at least 1 full GC cycle. The reason</code></span>
<span class="codeline" id="line-76"><code>// behind this is likelihood of reuse: the Go heap is allocated in a first-fit order</code></span>
<span class="codeline" id="line-77"><code>// and by the end of the GC mark phase, the heap tends to be densely packed. Releasing</code></span>
<span class="codeline" id="line-78"><code>// memory in these densely packed chunks while they're being packed is counter-productive,</code></span>
<span class="codeline" id="line-79"><code>// and worse, it breaks up huge pages on systems that support them. The scavenger (invoked</code></span>
<span class="codeline" id="line-80"><code>// during memory allocation) further ensures that chunks it identifies as "dense" are</code></span>
<span class="codeline" id="line-81"><code>// immediately eligible for being backed by huge pages. Note that for the most part these</code></span>
<span class="codeline" id="line-82"><code>// density heuristics are best-effort heuristics. It's totally possible (but unlikely)</code></span>
<span class="codeline" id="line-83"><code>// that a chunk that just became dense is scavenged in the case of a race between memory</code></span>
<span class="codeline" id="line-84"><code>// allocation and scavenging.</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// When synchronously scavenging for the memory limit or for debug.FreeOSMemory, these</code></span>
<span class="codeline" id="line-87"><code>// "dense" packing heuristics are ignored (in other words, scavenging is "forced") because</code></span>
<span class="codeline" id="line-88"><code>// in these scenarios returning memory to the OS is more important than keeping CPU</code></span>
<span class="codeline" id="line-89"><code>// overheads low.</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>package runtime</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>import (</code></span>
<span class="codeline" id="line-94"><code>	"internal/goos"</code></span>
<span class="codeline" id="line-95"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-96"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-97"><code>	"unsafe"</code></span>
<span class="codeline" id="line-98"><code>)</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>const (</code></span>
<span class="codeline" id="line-101"><code>	// The background scavenger is paced according to these parameters.</code></span>
<span class="codeline" id="line-102"><code>	//</code></span>
<span class="codeline" id="line-103"><code>	// scavengePercent represents the portion of mutator time we're willing</code></span>
<span class="codeline" id="line-104"><code>	// to spend on scavenging in percent.</code></span>
<span class="codeline" id="line-105"><code>	scavengePercent = 1 // 1%</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	// retainExtraPercent represents the amount of memory over the heap goal</code></span>
<span class="codeline" id="line-108"><code>	// that the scavenger should keep as a buffer space for the allocator.</code></span>
<span class="codeline" id="line-109"><code>	// This constant is used when we do not have a memory limit set.</code></span>
<span class="codeline" id="line-110"><code>	//</code></span>
<span class="codeline" id="line-111"><code>	// The purpose of maintaining this overhead is to have a greater pool of</code></span>
<span class="codeline" id="line-112"><code>	// unscavenged memory available for allocation (since using scavenged memory</code></span>
<span class="codeline" id="line-113"><code>	// incurs an additional cost), to account for heap fragmentation and</code></span>
<span class="codeline" id="line-114"><code>	// the ever-changing layout of the heap.</code></span>
<span class="codeline" id="line-115"><code>	retainExtraPercent = 10</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// reduceExtraPercent represents the amount of memory under the limit</code></span>
<span class="codeline" id="line-118"><code>	// that the scavenger should target. For example, 5 means we target 95%</code></span>
<span class="codeline" id="line-119"><code>	// of the limit.</code></span>
<span class="codeline" id="line-120"><code>	//</code></span>
<span class="codeline" id="line-121"><code>	// The purpose of shooting lower than the limit is to ensure that, once</code></span>
<span class="codeline" id="line-122"><code>	// close to the limit, the scavenger is working hard to maintain it. If</code></span>
<span class="codeline" id="line-123"><code>	// we have a memory limit set but are far away from it, there's no harm</code></span>
<span class="codeline" id="line-124"><code>	// in leaving up to 100-retainExtraPercent live, and it's more efficient</code></span>
<span class="codeline" id="line-125"><code>	// anyway, for the same reasons that retainExtraPercent exists.</code></span>
<span class="codeline" id="line-126"><code>	reduceExtraPercent = 5</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>	// maxPagesPerPhysPage is the maximum number of supported runtime pages per</code></span>
<span class="codeline" id="line-129"><code>	// physical page, based on maxPhysPageSize.</code></span>
<span class="codeline" id="line-130"><code>	maxPagesPerPhysPage = maxPhysPageSize / pageSize</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>	// scavengeCostRatio is the approximate ratio between the costs of using previously</code></span>
<span class="codeline" id="line-133"><code>	// scavenged memory and scavenging memory.</code></span>
<span class="codeline" id="line-134"><code>	//</code></span>
<span class="codeline" id="line-135"><code>	// For most systems the cost of scavenging greatly outweighs the costs</code></span>
<span class="codeline" id="line-136"><code>	// associated with using scavenged memory, making this constant 0. On other systems</code></span>
<span class="codeline" id="line-137"><code>	// (especially ones where "sysUsed" is not just a no-op) this cost is non-trivial.</code></span>
<span class="codeline" id="line-138"><code>	//</code></span>
<span class="codeline" id="line-139"><code>	// This ratio is used as part of multiplicative factor to help the scavenger account</code></span>
<span class="codeline" id="line-140"><code>	// for the additional costs of using scavenged memory in its pacing.</code></span>
<span class="codeline" id="line-141"><code>	scavengeCostRatio = 0.7 * (goos.IsDarwin + goos.IsIos)</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>	// scavChunkHiOcFrac indicates the fraction of pages that need to be allocated</code></span>
<span class="codeline" id="line-144"><code>	// in the chunk in a single GC cycle for it to be considered high density.</code></span>
<span class="codeline" id="line-145"><code>	scavChunkHiOccFrac  = 0.96875</code></span>
<span class="codeline" id="line-146"><code>	scavChunkHiOccPages = uint16(scavChunkHiOccFrac * pallocChunkPages)</code></span>
<span class="codeline" id="line-147"><code>)</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>// heapRetained returns an estimate of the current heap RSS.</code></span>
<span class="codeline" id="line-150"><code>func heapRetained() uint64 {</code></span>
<span class="codeline" id="line-151"><code>	return gcController.heapInUse.load() + gcController.heapFree.load()</code></span>
<span class="codeline" id="line-152"><code>}</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>// gcPaceScavenger updates the scavenger's pacing, particularly</code></span>
<span class="codeline" id="line-155"><code>// its rate and RSS goal. For this, it requires the current heapGoal,</code></span>
<span class="codeline" id="line-156"><code>// and the heapGoal for the previous GC cycle.</code></span>
<span class="codeline" id="line-157"><code>//</code></span>
<span class="codeline" id="line-158"><code>// The RSS goal is based on the current heap goal with a small overhead</code></span>
<span class="codeline" id="line-159"><code>// to accommodate non-determinism in the allocator.</code></span>
<span class="codeline" id="line-160"><code>//</code></span>
<span class="codeline" id="line-161"><code>// The pacing is based on scavengePageRate, which applies to both regular and</code></span>
<span class="codeline" id="line-162"><code>// huge pages. See that constant for more information.</code></span>
<span class="codeline" id="line-163"><code>//</code></span>
<span class="codeline" id="line-164"><code>// Must be called whenever GC pacing is updated.</code></span>
<span class="codeline" id="line-165"><code>//</code></span>
<span class="codeline" id="line-166"><code>// mheap_.lock must be held or the world must be stopped.</code></span>
<span class="codeline" id="line-167"><code>func gcPaceScavenger(memoryLimit int64, heapGoal, lastHeapGoal uint64) {</code></span>
<span class="codeline" id="line-168"><code>	assertWorldStoppedOrLockHeld(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>	// As described at the top of this file, there are two scavenge goals here: one</code></span>
<span class="codeline" id="line-171"><code>	// for gcPercent and one for memoryLimit. Let's handle the latter first because</code></span>
<span class="codeline" id="line-172"><code>	// it's simpler.</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	// We want to target retaining (100-reduceExtraPercent)% of the heap.</code></span>
<span class="codeline" id="line-175"><code>	memoryLimitGoal := uint64(float64(memoryLimit) * (1 - reduceExtraPercent/100.0))</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// mappedReady is comparable to memoryLimit, and represents how much total memory</code></span>
<span class="codeline" id="line-178"><code>	// the Go runtime has committed now (estimated).</code></span>
<span class="codeline" id="line-179"><code>	mappedReady := gcController.mappedReady.Load()</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>	// If we're below the goal already indicate that we don't need the background</code></span>
<span class="codeline" id="line-182"><code>	// scavenger for the memory limit. This may seems worrisome at first, but note</code></span>
<span class="codeline" id="line-183"><code>	// that the allocator will assist the background scavenger in the face of a memory</code></span>
<span class="codeline" id="line-184"><code>	// limit, so we'll be safe even if we stop the scavenger when we shouldn't have.</code></span>
<span class="codeline" id="line-185"><code>	if mappedReady &lt;= memoryLimitGoal {</code></span>
<span class="codeline" id="line-186"><code>		scavenge.memoryLimitGoal.Store(^uint64(0))</code></span>
<span class="codeline" id="line-187"><code>	} else {</code></span>
<span class="codeline" id="line-188"><code>		scavenge.memoryLimitGoal.Store(memoryLimitGoal)</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>	// Now handle the gcPercent goal.</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>	// If we're called before the first GC completed, disable scavenging.</code></span>
<span class="codeline" id="line-194"><code>	// We never scavenge before the 2nd GC cycle anyway (we don't have enough</code></span>
<span class="codeline" id="line-195"><code>	// information about the heap yet) so this is fine, and avoids a fault</code></span>
<span class="codeline" id="line-196"><code>	// or garbage data later.</code></span>
<span class="codeline" id="line-197"><code>	if lastHeapGoal == 0 {</code></span>
<span class="codeline" id="line-198"><code>		scavenge.gcPercentGoal.Store(^uint64(0))</code></span>
<span class="codeline" id="line-199"><code>		return</code></span>
<span class="codeline" id="line-200"><code>	}</code></span>
<span class="codeline" id="line-201"><code>	// Compute our scavenging goal.</code></span>
<span class="codeline" id="line-202"><code>	goalRatio := float64(heapGoal) / float64(lastHeapGoal)</code></span>
<span class="codeline" id="line-203"><code>	gcPercentGoal := uint64(float64(memstats.lastHeapInUse) * goalRatio)</code></span>
<span class="codeline" id="line-204"><code>	// Add retainExtraPercent overhead to retainedGoal. This calculation</code></span>
<span class="codeline" id="line-205"><code>	// looks strange but the purpose is to arrive at an integer division</code></span>
<span class="codeline" id="line-206"><code>	// (e.g. if retainExtraPercent = 12.5, then we get a divisor of 8)</code></span>
<span class="codeline" id="line-207"><code>	// that also avoids the overflow from a multiplication.</code></span>
<span class="codeline" id="line-208"><code>	gcPercentGoal += gcPercentGoal / (1.0 / (retainExtraPercent / 100.0))</code></span>
<span class="codeline" id="line-209"><code>	// Align it to a physical page boundary to make the following calculations</code></span>
<span class="codeline" id="line-210"><code>	// a bit more exact.</code></span>
<span class="codeline" id="line-211"><code>	gcPercentGoal = (gcPercentGoal + uint64(physPageSize) - 1) &amp;^ (uint64(physPageSize) - 1)</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>	// Represents where we are now in the heap's contribution to RSS in bytes.</code></span>
<span class="codeline" id="line-214"><code>	//</code></span>
<span class="codeline" id="line-215"><code>	// Guaranteed to always be a multiple of physPageSize on systems where</code></span>
<span class="codeline" id="line-216"><code>	// physPageSize &lt;= pageSize since we map new heap memory at a size larger than</code></span>
<span class="codeline" id="line-217"><code>	// any physPageSize and released memory in multiples of the physPageSize.</code></span>
<span class="codeline" id="line-218"><code>	//</code></span>
<span class="codeline" id="line-219"><code>	// However, certain functions recategorize heap memory as other stats (e.g.</code></span>
<span class="codeline" id="line-220"><code>	// stacks) and this happens in multiples of pageSize, so on systems</code></span>
<span class="codeline" id="line-221"><code>	// where physPageSize &gt; pageSize the calculations below will not be exact.</code></span>
<span class="codeline" id="line-222"><code>	// Generally this is OK since we'll be off by at most one regular</code></span>
<span class="codeline" id="line-223"><code>	// physical page.</code></span>
<span class="codeline" id="line-224"><code>	heapRetainedNow := heapRetained()</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	// If we're already below our goal, or within one page of our goal, then indicate</code></span>
<span class="codeline" id="line-227"><code>	// that we don't need the background scavenger for maintaining a memory overhead</code></span>
<span class="codeline" id="line-228"><code>	// proportional to the heap goal.</code></span>
<span class="codeline" id="line-229"><code>	if heapRetainedNow &lt;= gcPercentGoal || heapRetainedNow-gcPercentGoal &lt; uint64(physPageSize) {</code></span>
<span class="codeline" id="line-230"><code>		scavenge.gcPercentGoal.Store(^uint64(0))</code></span>
<span class="codeline" id="line-231"><code>	} else {</code></span>
<span class="codeline" id="line-232"><code>		scavenge.gcPercentGoal.Store(gcPercentGoal)</code></span>
<span class="codeline" id="line-233"><code>	}</code></span>
<span class="codeline" id="line-234"><code>}</code></span>
<span class="codeline" id="line-235"><code></code></span>
<span class="codeline" id="line-236"><code>var scavenge struct {</code></span>
<span class="codeline" id="line-237"><code>	// gcPercentGoal is the amount of retained heap memory (measured by</code></span>
<span class="codeline" id="line-238"><code>	// heapRetained) that the runtime will try to maintain by returning</code></span>
<span class="codeline" id="line-239"><code>	// memory to the OS. This goal is derived from gcController.gcPercent</code></span>
<span class="codeline" id="line-240"><code>	// by choosing to retain enough memory to allocate heap memory up to</code></span>
<span class="codeline" id="line-241"><code>	// the heap goal.</code></span>
<span class="codeline" id="line-242"><code>	gcPercentGoal atomic.Uint64</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>	// memoryLimitGoal is the amount of memory retained by the runtime (</code></span>
<span class="codeline" id="line-245"><code>	// measured by gcController.mappedReady) that the runtime will try to</code></span>
<span class="codeline" id="line-246"><code>	// maintain by returning memory to the OS. This goal is derived from</code></span>
<span class="codeline" id="line-247"><code>	// gcController.memoryLimit by choosing to target the memory limit or</code></span>
<span class="codeline" id="line-248"><code>	// some lower target to keep the scavenger working.</code></span>
<span class="codeline" id="line-249"><code>	memoryLimitGoal atomic.Uint64</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>	// assistTime is the time spent by the allocator scavenging in the last GC cycle.</code></span>
<span class="codeline" id="line-252"><code>	//</code></span>
<span class="codeline" id="line-253"><code>	// This is reset once a GC cycle ends.</code></span>
<span class="codeline" id="line-254"><code>	assistTime atomic.Int64</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>	// backgroundTime is the time spent by the background scavenger in the last GC cycle.</code></span>
<span class="codeline" id="line-257"><code>	//</code></span>
<span class="codeline" id="line-258"><code>	// This is reset once a GC cycle ends.</code></span>
<span class="codeline" id="line-259"><code>	backgroundTime atomic.Int64</code></span>
<span class="codeline" id="line-260"><code>}</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>const (</code></span>
<span class="codeline" id="line-263"><code>	// It doesn't really matter what value we start at, but we can't be zero, because</code></span>
<span class="codeline" id="line-264"><code>	// that'll cause divide-by-zero issues. Pick something conservative which we'll</code></span>
<span class="codeline" id="line-265"><code>	// also use as a fallback.</code></span>
<span class="codeline" id="line-266"><code>	startingScavSleepRatio = 0.001</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>	// Spend at least 1 ms scavenging, otherwise the corresponding</code></span>
<span class="codeline" id="line-269"><code>	// sleep time to maintain our desired utilization is too low to</code></span>
<span class="codeline" id="line-270"><code>	// be reliable.</code></span>
<span class="codeline" id="line-271"><code>	minScavWorkTime = 1e6</code></span>
<span class="codeline" id="line-272"><code>)</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// Sleep/wait state of the background scavenger.</code></span>
<span class="codeline" id="line-275"><code>var scavenger scavengerState</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>type scavengerState struct {</code></span>
<span class="codeline" id="line-278"><code>	// lock protects all fields below.</code></span>
<span class="codeline" id="line-279"><code>	lock mutex</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// g is the goroutine the scavenger is bound to.</code></span>
<span class="codeline" id="line-282"><code>	g *g</code></span>
<span class="codeline" id="line-283"><code></code></span>
<span class="codeline" id="line-284"><code>	// parked is whether or not the scavenger is parked.</code></span>
<span class="codeline" id="line-285"><code>	parked bool</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	// timer is the timer used for the scavenger to sleep.</code></span>
<span class="codeline" id="line-288"><code>	timer *timer</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>	// sysmonWake signals to sysmon that it should wake the scavenger.</code></span>
<span class="codeline" id="line-291"><code>	sysmonWake atomic.Uint32</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>	// targetCPUFraction is the target CPU overhead for the scavenger.</code></span>
<span class="codeline" id="line-294"><code>	targetCPUFraction float64</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>	// sleepRatio is the ratio of time spent doing scavenging work to</code></span>
<span class="codeline" id="line-297"><code>	// time spent sleeping. This is used to decide how long the scavenger</code></span>
<span class="codeline" id="line-298"><code>	// should sleep for in between batches of work. It is set by</code></span>
<span class="codeline" id="line-299"><code>	// critSleepController in order to maintain a CPU overhead of</code></span>
<span class="codeline" id="line-300"><code>	// targetCPUFraction.</code></span>
<span class="codeline" id="line-301"><code>	//</code></span>
<span class="codeline" id="line-302"><code>	// Lower means more sleep, higher means more aggressive scavenging.</code></span>
<span class="codeline" id="line-303"><code>	sleepRatio float64</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>	// sleepController controls sleepRatio.</code></span>
<span class="codeline" id="line-306"><code>	//</code></span>
<span class="codeline" id="line-307"><code>	// See sleepRatio for more details.</code></span>
<span class="codeline" id="line-308"><code>	sleepController piController</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>	// controllerCooldown is the time left in nanoseconds during which we avoid</code></span>
<span class="codeline" id="line-311"><code>	// using the controller and we hold sleepRatio at a conservative</code></span>
<span class="codeline" id="line-312"><code>	// value. Used if the controller's assumptions fail to hold.</code></span>
<span class="codeline" id="line-313"><code>	controllerCooldown int64</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>	// printControllerReset instructs printScavTrace to signal that</code></span>
<span class="codeline" id="line-316"><code>	// the controller was reset.</code></span>
<span class="codeline" id="line-317"><code>	printControllerReset bool</code></span>
<span class="codeline" id="line-318"><code></code></span>
<span class="codeline" id="line-319"><code>	// sleepStub is a stub used for testing to avoid actually having</code></span>
<span class="codeline" id="line-320"><code>	// the scavenger sleep.</code></span>
<span class="codeline" id="line-321"><code>	//</code></span>
<span class="codeline" id="line-322"><code>	// Unlike the other stubs, this is not populated if left nil</code></span>
<span class="codeline" id="line-323"><code>	// Instead, it is called when non-nil because any valid implementation</code></span>
<span class="codeline" id="line-324"><code>	// of this function basically requires closing over this scavenger</code></span>
<span class="codeline" id="line-325"><code>	// state, and allocating a closure is not allowed in the runtime as</code></span>
<span class="codeline" id="line-326"><code>	// a matter of policy.</code></span>
<span class="codeline" id="line-327"><code>	sleepStub func(n int64) int64</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>	// scavenge is a function that scavenges n bytes of memory.</code></span>
<span class="codeline" id="line-330"><code>	// Returns how many bytes of memory it actually scavenged, as</code></span>
<span class="codeline" id="line-331"><code>	// well as the time it took in nanoseconds. Usually mheap.pages.scavenge</code></span>
<span class="codeline" id="line-332"><code>	// with nanotime called around it, but stubbed out for testing.</code></span>
<span class="codeline" id="line-333"><code>	// Like mheap.pages.scavenge, if it scavenges less than n bytes of</code></span>
<span class="codeline" id="line-334"><code>	// memory, the caller may assume the heap is exhausted of scavengable</code></span>
<span class="codeline" id="line-335"><code>	// memory for now.</code></span>
<span class="codeline" id="line-336"><code>	//</code></span>
<span class="codeline" id="line-337"><code>	// If this is nil, it is populated with the real thing in init.</code></span>
<span class="codeline" id="line-338"><code>	scavenge func(n uintptr) (uintptr, int64)</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>	// shouldStop is a callback called in the work loop and provides a</code></span>
<span class="codeline" id="line-341"><code>	// point that can force the scavenger to stop early, for example because</code></span>
<span class="codeline" id="line-342"><code>	// the scavenge policy dictates too much has been scavenged already.</code></span>
<span class="codeline" id="line-343"><code>	//</code></span>
<span class="codeline" id="line-344"><code>	// If this is nil, it is populated with the real thing in init.</code></span>
<span class="codeline" id="line-345"><code>	shouldStop func() bool</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>	// gomaxprocs returns the current value of gomaxprocs. Stub for testing.</code></span>
<span class="codeline" id="line-348"><code>	//</code></span>
<span class="codeline" id="line-349"><code>	// If this is nil, it is populated with the real thing in init.</code></span>
<span class="codeline" id="line-350"><code>	gomaxprocs func() int32</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>// init initializes a scavenger state and wires to the current G.</code></span>
<span class="codeline" id="line-354"><code>//</code></span>
<span class="codeline" id="line-355"><code>// Must be called from a regular goroutine that can allocate.</code></span>
<span class="codeline" id="line-356"><code>func (s *scavengerState) init() {</code></span>
<span class="codeline" id="line-357"><code>	if s.g != nil {</code></span>
<span class="codeline" id="line-358"><code>		throw("scavenger state is already wired")</code></span>
<span class="codeline" id="line-359"><code>	}</code></span>
<span class="codeline" id="line-360"><code>	lockInit(&amp;s.lock, lockRankScavenge)</code></span>
<span class="codeline" id="line-361"><code>	s.g = getg()</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>	s.timer = new(timer)</code></span>
<span class="codeline" id="line-364"><code>	s.timer.arg = s</code></span>
<span class="codeline" id="line-365"><code>	s.timer.f = func(s any, _ uintptr) {</code></span>
<span class="codeline" id="line-366"><code>		s.(*scavengerState).wake()</code></span>
<span class="codeline" id="line-367"><code>	}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>	// input: fraction of CPU time actually used.</code></span>
<span class="codeline" id="line-370"><code>	// setpoint: ideal CPU fraction.</code></span>
<span class="codeline" id="line-371"><code>	// output: ratio of time worked to time slept (determines sleep time).</code></span>
<span class="codeline" id="line-372"><code>	//</code></span>
<span class="codeline" id="line-373"><code>	// The output of this controller is somewhat indirect to what we actually</code></span>
<span class="codeline" id="line-374"><code>	// want to achieve: how much time to sleep for. The reason for this definition</code></span>
<span class="codeline" id="line-375"><code>	// is to ensure that the controller's outputs have a direct relationship with</code></span>
<span class="codeline" id="line-376"><code>	// its inputs (as opposed to an inverse relationship), making it somewhat</code></span>
<span class="codeline" id="line-377"><code>	// easier to reason about for tuning purposes.</code></span>
<span class="codeline" id="line-378"><code>	s.sleepController = piController{</code></span>
<span class="codeline" id="line-379"><code>		// Tuned loosely via Ziegler-Nichols process.</code></span>
<span class="codeline" id="line-380"><code>		kp: 0.3375,</code></span>
<span class="codeline" id="line-381"><code>		ti: 3.2e6,</code></span>
<span class="codeline" id="line-382"><code>		tt: 1e9, // 1 second reset time.</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>		// These ranges seem wide, but we want to give the controller plenty of</code></span>
<span class="codeline" id="line-385"><code>		// room to hunt for the optimal value.</code></span>
<span class="codeline" id="line-386"><code>		min: 0.001,  // 1:1000</code></span>
<span class="codeline" id="line-387"><code>		max: 1000.0, // 1000:1</code></span>
<span class="codeline" id="line-388"><code>	}</code></span>
<span class="codeline" id="line-389"><code>	s.sleepRatio = startingScavSleepRatio</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>	// Install real functions if stubs aren't present.</code></span>
<span class="codeline" id="line-392"><code>	if s.scavenge == nil {</code></span>
<span class="codeline" id="line-393"><code>		s.scavenge = func(n uintptr) (uintptr, int64) {</code></span>
<span class="codeline" id="line-394"><code>			start := nanotime()</code></span>
<span class="codeline" id="line-395"><code>			r := mheap_.pages.scavenge(n, nil, false)</code></span>
<span class="codeline" id="line-396"><code>			end := nanotime()</code></span>
<span class="codeline" id="line-397"><code>			if start &gt;= end {</code></span>
<span class="codeline" id="line-398"><code>				return r, 0</code></span>
<span class="codeline" id="line-399"><code>			}</code></span>
<span class="codeline" id="line-400"><code>			scavenge.backgroundTime.Add(end - start)</code></span>
<span class="codeline" id="line-401"><code>			return r, end - start</code></span>
<span class="codeline" id="line-402"><code>		}</code></span>
<span class="codeline" id="line-403"><code>	}</code></span>
<span class="codeline" id="line-404"><code>	if s.shouldStop == nil {</code></span>
<span class="codeline" id="line-405"><code>		s.shouldStop = func() bool {</code></span>
<span class="codeline" id="line-406"><code>			// If background scavenging is disabled or if there's no work to do just stop.</code></span>
<span class="codeline" id="line-407"><code>			return heapRetained() &lt;= scavenge.gcPercentGoal.Load() &amp;&amp;</code></span>
<span class="codeline" id="line-408"><code>				gcController.mappedReady.Load() &lt;= scavenge.memoryLimitGoal.Load()</code></span>
<span class="codeline" id="line-409"><code>		}</code></span>
<span class="codeline" id="line-410"><code>	}</code></span>
<span class="codeline" id="line-411"><code>	if s.gomaxprocs == nil {</code></span>
<span class="codeline" id="line-412"><code>		s.gomaxprocs = func() int32 {</code></span>
<span class="codeline" id="line-413"><code>			return gomaxprocs</code></span>
<span class="codeline" id="line-414"><code>		}</code></span>
<span class="codeline" id="line-415"><code>	}</code></span>
<span class="codeline" id="line-416"><code>}</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>// park parks the scavenger goroutine.</code></span>
<span class="codeline" id="line-419"><code>func (s *scavengerState) park() {</code></span>
<span class="codeline" id="line-420"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-421"><code>	if getg() != s.g {</code></span>
<span class="codeline" id="line-422"><code>		throw("tried to park scavenger from another goroutine")</code></span>
<span class="codeline" id="line-423"><code>	}</code></span>
<span class="codeline" id="line-424"><code>	s.parked = true</code></span>
<span class="codeline" id="line-425"><code>	goparkunlock(&amp;s.lock, waitReasonGCScavengeWait, traceBlockSystemGoroutine, 2)</code></span>
<span class="codeline" id="line-426"><code>}</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>// ready signals to sysmon that the scavenger should be awoken.</code></span>
<span class="codeline" id="line-429"><code>func (s *scavengerState) ready() {</code></span>
<span class="codeline" id="line-430"><code>	s.sysmonWake.Store(1)</code></span>
<span class="codeline" id="line-431"><code>}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>// wake immediately unparks the scavenger if necessary.</code></span>
<span class="codeline" id="line-434"><code>//</code></span>
<span class="codeline" id="line-435"><code>// Safe to run without a P.</code></span>
<span class="codeline" id="line-436"><code>func (s *scavengerState) wake() {</code></span>
<span class="codeline" id="line-437"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-438"><code>	if s.parked {</code></span>
<span class="codeline" id="line-439"><code>		// Unset sysmonWake, since the scavenger is now being awoken.</code></span>
<span class="codeline" id="line-440"><code>		s.sysmonWake.Store(0)</code></span>
<span class="codeline" id="line-441"><code></code></span>
<span class="codeline" id="line-442"><code>		// s.parked is unset to prevent a double wake-up.</code></span>
<span class="codeline" id="line-443"><code>		s.parked = false</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>		// Ready the goroutine by injecting it. We use injectglist instead</code></span>
<span class="codeline" id="line-446"><code>		// of ready or goready in order to allow us to run this function</code></span>
<span class="codeline" id="line-447"><code>		// without a P. injectglist also avoids placing the goroutine in</code></span>
<span class="codeline" id="line-448"><code>		// the current P's runnext slot, which is desirable to prevent</code></span>
<span class="codeline" id="line-449"><code>		// the scavenger from interfering with user goroutine scheduling</code></span>
<span class="codeline" id="line-450"><code>		// too much.</code></span>
<span class="codeline" id="line-451"><code>		var list gList</code></span>
<span class="codeline" id="line-452"><code>		list.push(s.g)</code></span>
<span class="codeline" id="line-453"><code>		injectglist(&amp;list)</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-456"><code>}</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>// sleep puts the scavenger to sleep based on the amount of time that it worked</code></span>
<span class="codeline" id="line-459"><code>// in nanoseconds.</code></span>
<span class="codeline" id="line-460"><code>//</code></span>
<span class="codeline" id="line-461"><code>// Note that this function should only be called by the scavenger.</code></span>
<span class="codeline" id="line-462"><code>//</code></span>
<span class="codeline" id="line-463"><code>// The scavenger may be woken up earlier by a pacing change, and it may not go</code></span>
<span class="codeline" id="line-464"><code>// to sleep at all if there's a pending pacing change.</code></span>
<span class="codeline" id="line-465"><code>func (s *scavengerState) sleep(worked float64) {</code></span>
<span class="codeline" id="line-466"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-467"><code>	if getg() != s.g {</code></span>
<span class="codeline" id="line-468"><code>		throw("tried to sleep scavenger from another goroutine")</code></span>
<span class="codeline" id="line-469"><code>	}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	if worked &lt; minScavWorkTime {</code></span>
<span class="codeline" id="line-472"><code>		// This means there wasn't enough work to actually fill up minScavWorkTime.</code></span>
<span class="codeline" id="line-473"><code>		// That's fine; we shouldn't try to do anything with this information</code></span>
<span class="codeline" id="line-474"><code>		// because it's going result in a short enough sleep request that things</code></span>
<span class="codeline" id="line-475"><code>		// will get messy. Just assume we did at least this much work.</code></span>
<span class="codeline" id="line-476"><code>		// All this means is that we'll sleep longer than we otherwise would have.</code></span>
<span class="codeline" id="line-477"><code>		worked = minScavWorkTime</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	// Multiply the critical time by 1 + the ratio of the costs of using</code></span>
<span class="codeline" id="line-481"><code>	// scavenged memory vs. scavenging memory. This forces us to pay down</code></span>
<span class="codeline" id="line-482"><code>	// the cost of reusing this memory eagerly by sleeping for a longer period</code></span>
<span class="codeline" id="line-483"><code>	// of time and scavenging less frequently. More concretely, we avoid situations</code></span>
<span class="codeline" id="line-484"><code>	// where we end up scavenging so often that we hurt allocation performance</code></span>
<span class="codeline" id="line-485"><code>	// because of the additional overheads of using scavenged memory.</code></span>
<span class="codeline" id="line-486"><code>	worked *= 1 + scavengeCostRatio</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>	// sleepTime is the amount of time we're going to sleep, based on the amount</code></span>
<span class="codeline" id="line-489"><code>	// of time we worked, and the sleepRatio.</code></span>
<span class="codeline" id="line-490"><code>	sleepTime := int64(worked / s.sleepRatio)</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>	var slept int64</code></span>
<span class="codeline" id="line-493"><code>	if s.sleepStub == nil {</code></span>
<span class="codeline" id="line-494"><code>		// Set the timer.</code></span>
<span class="codeline" id="line-495"><code>		//</code></span>
<span class="codeline" id="line-496"><code>		// This must happen here instead of inside gopark</code></span>
<span class="codeline" id="line-497"><code>		// because we can't close over any variables without</code></span>
<span class="codeline" id="line-498"><code>		// failing escape analysis.</code></span>
<span class="codeline" id="line-499"><code>		start := nanotime()</code></span>
<span class="codeline" id="line-500"><code>		resetTimer(s.timer, start+sleepTime)</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>		// Mark ourselves as asleep and go to sleep.</code></span>
<span class="codeline" id="line-503"><code>		s.parked = true</code></span>
<span class="codeline" id="line-504"><code>		goparkunlock(&amp;s.lock, waitReasonSleep, traceBlockSleep, 2)</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>		// How long we actually slept for.</code></span>
<span class="codeline" id="line-507"><code>		slept = nanotime() - start</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>		lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-510"><code>		// Stop the timer here because s.wake is unable to do it for us.</code></span>
<span class="codeline" id="line-511"><code>		// We don't really care if we succeed in stopping the timer. One</code></span>
<span class="codeline" id="line-512"><code>		// reason we might fail is that we've already woken up, but the timer</code></span>
<span class="codeline" id="line-513"><code>		// might be in the process of firing on some other P; essentially we're</code></span>
<span class="codeline" id="line-514"><code>		// racing with it. That's totally OK. Double wake-ups are perfectly safe.</code></span>
<span class="codeline" id="line-515"><code>		stopTimer(s.timer)</code></span>
<span class="codeline" id="line-516"><code>		unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-517"><code>	} else {</code></span>
<span class="codeline" id="line-518"><code>		unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-519"><code>		slept = s.sleepStub(sleepTime)</code></span>
<span class="codeline" id="line-520"><code>	}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>	// Stop here if we're cooling down from the controller.</code></span>
<span class="codeline" id="line-523"><code>	if s.controllerCooldown &gt; 0 {</code></span>
<span class="codeline" id="line-524"><code>		// worked and slept aren't exact measures of time, but it's OK to be a bit</code></span>
<span class="codeline" id="line-525"><code>		// sloppy here. We're just hoping we're avoiding some transient bad behavior.</code></span>
<span class="codeline" id="line-526"><code>		t := slept + int64(worked)</code></span>
<span class="codeline" id="line-527"><code>		if t &gt; s.controllerCooldown {</code></span>
<span class="codeline" id="line-528"><code>			s.controllerCooldown = 0</code></span>
<span class="codeline" id="line-529"><code>		} else {</code></span>
<span class="codeline" id="line-530"><code>			s.controllerCooldown -= t</code></span>
<span class="codeline" id="line-531"><code>		}</code></span>
<span class="codeline" id="line-532"><code>		return</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>	// idealFraction is the ideal % of overall application CPU time that we</code></span>
<span class="codeline" id="line-536"><code>	// spend scavenging.</code></span>
<span class="codeline" id="line-537"><code>	idealFraction := float64(scavengePercent) / 100.0</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>	// Calculate the CPU time spent.</code></span>
<span class="codeline" id="line-540"><code>	//</code></span>
<span class="codeline" id="line-541"><code>	// This may be slightly inaccurate with respect to GOMAXPROCS, but we're</code></span>
<span class="codeline" id="line-542"><code>	// recomputing this often enough relative to GOMAXPROCS changes in general</code></span>
<span class="codeline" id="line-543"><code>	// (it only changes when the world is stopped, and not during a GC) that</code></span>
<span class="codeline" id="line-544"><code>	// that small inaccuracy is in the noise.</code></span>
<span class="codeline" id="line-545"><code>	cpuFraction := worked / ((float64(slept) + worked) * float64(s.gomaxprocs()))</code></span>
<span class="codeline" id="line-546"><code></code></span>
<span class="codeline" id="line-547"><code>	// Update the critSleepRatio, adjusting until we reach our ideal fraction.</code></span>
<span class="codeline" id="line-548"><code>	var ok bool</code></span>
<span class="codeline" id="line-549"><code>	s.sleepRatio, ok = s.sleepController.next(cpuFraction, idealFraction, float64(slept)+worked)</code></span>
<span class="codeline" id="line-550"><code>	if !ok {</code></span>
<span class="codeline" id="line-551"><code>		// The core assumption of the controller, that we can get a proportional</code></span>
<span class="codeline" id="line-552"><code>		// response, broke down. This may be transient, so temporarily switch to</code></span>
<span class="codeline" id="line-553"><code>		// sleeping a fixed, conservative amount.</code></span>
<span class="codeline" id="line-554"><code>		s.sleepRatio = startingScavSleepRatio</code></span>
<span class="codeline" id="line-555"><code>		s.controllerCooldown = 5e9 // 5 seconds.</code></span>
<span class="codeline" id="line-556"><code></code></span>
<span class="codeline" id="line-557"><code>		// Signal the scav trace printer to output this.</code></span>
<span class="codeline" id="line-558"><code>		s.controllerFailed()</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// controllerFailed indicates that the scavenger's scheduling</code></span>
<span class="codeline" id="line-563"><code>// controller failed.</code></span>
<span class="codeline" id="line-564"><code>func (s *scavengerState) controllerFailed() {</code></span>
<span class="codeline" id="line-565"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-566"><code>	s.printControllerReset = true</code></span>
<span class="codeline" id="line-567"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-568"><code>}</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>// run is the body of the main scavenging loop.</code></span>
<span class="codeline" id="line-571"><code>//</code></span>
<span class="codeline" id="line-572"><code>// Returns the number of bytes released and the estimated time spent</code></span>
<span class="codeline" id="line-573"><code>// releasing those bytes.</code></span>
<span class="codeline" id="line-574"><code>//</code></span>
<span class="codeline" id="line-575"><code>// Must be run on the scavenger goroutine.</code></span>
<span class="codeline" id="line-576"><code>func (s *scavengerState) run() (released uintptr, worked float64) {</code></span>
<span class="codeline" id="line-577"><code>	lock(&amp;s.lock)</code></span>
<span class="codeline" id="line-578"><code>	if getg() != s.g {</code></span>
<span class="codeline" id="line-579"><code>		throw("tried to run scavenger from another goroutine")</code></span>
<span class="codeline" id="line-580"><code>	}</code></span>
<span class="codeline" id="line-581"><code>	unlock(&amp;s.lock)</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>	for worked &lt; minScavWorkTime {</code></span>
<span class="codeline" id="line-584"><code>		// If something from outside tells us to stop early, stop.</code></span>
<span class="codeline" id="line-585"><code>		if s.shouldStop() {</code></span>
<span class="codeline" id="line-586"><code>			break</code></span>
<span class="codeline" id="line-587"><code>		}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>		// scavengeQuantum is the amount of memory we try to scavenge</code></span>
<span class="codeline" id="line-590"><code>		// in one go. A smaller value means the scavenger is more responsive</code></span>
<span class="codeline" id="line-591"><code>		// to the scheduler in case of e.g. preemption. A larger value means</code></span>
<span class="codeline" id="line-592"><code>		// that the overheads of scavenging are better amortized, so better</code></span>
<span class="codeline" id="line-593"><code>		// scavenging throughput.</code></span>
<span class="codeline" id="line-594"><code>		//</code></span>
<span class="codeline" id="line-595"><code>		// The current value is chosen assuming a cost of ~10µs/physical page</code></span>
<span class="codeline" id="line-596"><code>		// (this is somewhat pessimistic), which implies a worst-case latency of</code></span>
<span class="codeline" id="line-597"><code>		// about 160µs for 4 KiB physical pages. The current value is biased</code></span>
<span class="codeline" id="line-598"><code>		// toward latency over throughput.</code></span>
<span class="codeline" id="line-599"><code>		const scavengeQuantum = 64 &lt;&lt; 10</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>		// Accumulate the amount of time spent scavenging.</code></span>
<span class="codeline" id="line-602"><code>		r, duration := s.scavenge(scavengeQuantum)</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>		// On some platforms we may see end &gt;= start if the time it takes to scavenge</code></span>
<span class="codeline" id="line-605"><code>		// memory is less than the minimum granularity of its clock (e.g. Windows) or</code></span>
<span class="codeline" id="line-606"><code>		// due to clock bugs.</code></span>
<span class="codeline" id="line-607"><code>		//</code></span>
<span class="codeline" id="line-608"><code>		// In this case, just assume scavenging takes 10 µs per regular physical page</code></span>
<span class="codeline" id="line-609"><code>		// (determined empirically), and conservatively ignore the impact of huge pages</code></span>
<span class="codeline" id="line-610"><code>		// on timing.</code></span>
<span class="codeline" id="line-611"><code>		const approxWorkedNSPerPhysicalPage = 10e3</code></span>
<span class="codeline" id="line-612"><code>		if duration == 0 {</code></span>
<span class="codeline" id="line-613"><code>			worked += approxWorkedNSPerPhysicalPage * float64(r/physPageSize)</code></span>
<span class="codeline" id="line-614"><code>		} else {</code></span>
<span class="codeline" id="line-615"><code>			// TODO(mknyszek): If duration is small compared to worked, it could be</code></span>
<span class="codeline" id="line-616"><code>			// rounded down to zero. Probably not a problem in practice because the</code></span>
<span class="codeline" id="line-617"><code>			// values are all within a few orders of magnitude of each other but maybe</code></span>
<span class="codeline" id="line-618"><code>			// worth worrying about.</code></span>
<span class="codeline" id="line-619"><code>			worked += float64(duration)</code></span>
<span class="codeline" id="line-620"><code>		}</code></span>
<span class="codeline" id="line-621"><code>		released += r</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>		// scavenge does not return until it either finds the requisite amount of</code></span>
<span class="codeline" id="line-624"><code>		// memory to scavenge, or exhausts the heap. If we haven't found enough</code></span>
<span class="codeline" id="line-625"><code>		// to scavenge, then the heap must be exhausted.</code></span>
<span class="codeline" id="line-626"><code>		if r &lt; scavengeQuantum {</code></span>
<span class="codeline" id="line-627"><code>			break</code></span>
<span class="codeline" id="line-628"><code>		}</code></span>
<span class="codeline" id="line-629"><code>		// When using fake time just do one loop.</code></span>
<span class="codeline" id="line-630"><code>		if faketime != 0 {</code></span>
<span class="codeline" id="line-631"><code>			break</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	if released &gt; 0 &amp;&amp; released &lt; physPageSize {</code></span>
<span class="codeline" id="line-635"><code>		// If this happens, it means that we may have attempted to release part</code></span>
<span class="codeline" id="line-636"><code>		// of a physical page, but the likely effect of that is that it released</code></span>
<span class="codeline" id="line-637"><code>		// the whole physical page, some of which may have still been in-use.</code></span>
<span class="codeline" id="line-638"><code>		// This could lead to memory corruption. Throw.</code></span>
<span class="codeline" id="line-639"><code>		throw("released less than one physical page of memory")</code></span>
<span class="codeline" id="line-640"><code>	}</code></span>
<span class="codeline" id="line-641"><code>	return</code></span>
<span class="codeline" id="line-642"><code>}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>// Background scavenger.</code></span>
<span class="codeline" id="line-645"><code>//</code></span>
<span class="codeline" id="line-646"><code>// The background scavenger maintains the RSS of the application below</code></span>
<span class="codeline" id="line-647"><code>// the line described by the proportional scavenging statistics in</code></span>
<span class="codeline" id="line-648"><code>// the mheap struct.</code></span>
<span class="codeline" id="line-649"><code>func bgscavenge(c chan int) {</code></span>
<span class="codeline" id="line-650"><code>	scavenger.init()</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>	c &lt;- 1</code></span>
<span class="codeline" id="line-653"><code>	scavenger.park()</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>	for {</code></span>
<span class="codeline" id="line-656"><code>		released, workTime := scavenger.run()</code></span>
<span class="codeline" id="line-657"><code>		if released == 0 {</code></span>
<span class="codeline" id="line-658"><code>			scavenger.park()</code></span>
<span class="codeline" id="line-659"><code>			continue</code></span>
<span class="codeline" id="line-660"><code>		}</code></span>
<span class="codeline" id="line-661"><code>		mheap_.pages.scav.releasedBg.Add(released)</code></span>
<span class="codeline" id="line-662"><code>		scavenger.sleep(workTime)</code></span>
<span class="codeline" id="line-663"><code>	}</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>// scavenge scavenges nbytes worth of free pages, starting with the</code></span>
<span class="codeline" id="line-667"><code>// highest address first. Successive calls continue from where it left</code></span>
<span class="codeline" id="line-668"><code>// off until the heap is exhausted. force makes all memory available to</code></span>
<span class="codeline" id="line-669"><code>// scavenge, ignoring huge page heuristics.</code></span>
<span class="codeline" id="line-670"><code>//</code></span>
<span class="codeline" id="line-671"><code>// Returns the amount of memory scavenged in bytes.</code></span>
<span class="codeline" id="line-672"><code>//</code></span>
<span class="codeline" id="line-673"><code>// scavenge always tries to scavenge nbytes worth of memory, and will</code></span>
<span class="codeline" id="line-674"><code>// only fail to do so if the heap is exhausted for now.</code></span>
<span class="codeline" id="line-675"><code>func (p *pageAlloc) scavenge(nbytes uintptr, shouldStop func() bool, force bool) uintptr {</code></span>
<span class="codeline" id="line-676"><code>	released := uintptr(0)</code></span>
<span class="codeline" id="line-677"><code>	for released &lt; nbytes {</code></span>
<span class="codeline" id="line-678"><code>		ci, pageIdx := p.scav.index.find(force)</code></span>
<span class="codeline" id="line-679"><code>		if ci == 0 {</code></span>
<span class="codeline" id="line-680"><code>			break</code></span>
<span class="codeline" id="line-681"><code>		}</code></span>
<span class="codeline" id="line-682"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-683"><code>			released += p.scavengeOne(ci, pageIdx, nbytes-released)</code></span>
<span class="codeline" id="line-684"><code>		})</code></span>
<span class="codeline" id="line-685"><code>		if shouldStop != nil &amp;&amp; shouldStop() {</code></span>
<span class="codeline" id="line-686"><code>			break</code></span>
<span class="codeline" id="line-687"><code>		}</code></span>
<span class="codeline" id="line-688"><code>	}</code></span>
<span class="codeline" id="line-689"><code>	return released</code></span>
<span class="codeline" id="line-690"><code>}</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>// printScavTrace prints a scavenge trace line to standard error.</code></span>
<span class="codeline" id="line-693"><code>//</code></span>
<span class="codeline" id="line-694"><code>// released should be the amount of memory released since the last time this</code></span>
<span class="codeline" id="line-695"><code>// was called, and forced indicates whether the scavenge was forced by the</code></span>
<span class="codeline" id="line-696"><code>// application.</code></span>
<span class="codeline" id="line-697"><code>//</code></span>
<span class="codeline" id="line-698"><code>// scavenger.lock must be held.</code></span>
<span class="codeline" id="line-699"><code>func printScavTrace(releasedBg, releasedEager uintptr, forced bool) {</code></span>
<span class="codeline" id="line-700"><code>	assertLockHeld(&amp;scavenger.lock)</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>	printlock()</code></span>
<span class="codeline" id="line-703"><code>	print("scav ",</code></span>
<span class="codeline" id="line-704"><code>		releasedBg&gt;&gt;10, " KiB work (bg), ",</code></span>
<span class="codeline" id="line-705"><code>		releasedEager&gt;&gt;10, " KiB work (eager), ",</code></span>
<span class="codeline" id="line-706"><code>		gcController.heapReleased.load()&gt;&gt;10, " KiB now, ",</code></span>
<span class="codeline" id="line-707"><code>		(gcController.heapInUse.load()*100)/heapRetained(), "% util",</code></span>
<span class="codeline" id="line-708"><code>	)</code></span>
<span class="codeline" id="line-709"><code>	if forced {</code></span>
<span class="codeline" id="line-710"><code>		print(" (forced)")</code></span>
<span class="codeline" id="line-711"><code>	} else if scavenger.printControllerReset {</code></span>
<span class="codeline" id="line-712"><code>		print(" [controller reset]")</code></span>
<span class="codeline" id="line-713"><code>		scavenger.printControllerReset = false</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>	println()</code></span>
<span class="codeline" id="line-716"><code>	printunlock()</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>// scavengeOne walks over the chunk at chunk index ci and searches for</code></span>
<span class="codeline" id="line-720"><code>// a contiguous run of pages to scavenge. It will try to scavenge</code></span>
<span class="codeline" id="line-721"><code>// at most max bytes at once, but may scavenge more to avoid</code></span>
<span class="codeline" id="line-722"><code>// breaking huge pages. Once it scavenges some memory it returns</code></span>
<span class="codeline" id="line-723"><code>// how much it scavenged in bytes.</code></span>
<span class="codeline" id="line-724"><code>//</code></span>
<span class="codeline" id="line-725"><code>// searchIdx is the page index to start searching from in ci.</code></span>
<span class="codeline" id="line-726"><code>//</code></span>
<span class="codeline" id="line-727"><code>// Returns the number of bytes scavenged.</code></span>
<span class="codeline" id="line-728"><code>//</code></span>
<span class="codeline" id="line-729"><code>// Must run on the systemstack because it acquires p.mheapLock.</code></span>
<span class="codeline" id="line-730"><code>//</code></span>
<span class="codeline" id="line-731"><code>//go:systemstack</code></span>
<span class="codeline" id="line-732"><code>func (p *pageAlloc) scavengeOne(ci chunkIdx, searchIdx uint, max uintptr) uintptr {</code></span>
<span class="codeline" id="line-733"><code>	// Calculate the maximum number of pages to scavenge.</code></span>
<span class="codeline" id="line-734"><code>	//</code></span>
<span class="codeline" id="line-735"><code>	// This should be alignUp(max, pageSize) / pageSize but max can and will</code></span>
<span class="codeline" id="line-736"><code>	// be ^uintptr(0), so we need to be very careful not to overflow here.</code></span>
<span class="codeline" id="line-737"><code>	// Rather than use alignUp, calculate the number of pages rounded down</code></span>
<span class="codeline" id="line-738"><code>	// first, then add back one if necessary.</code></span>
<span class="codeline" id="line-739"><code>	maxPages := max / pageSize</code></span>
<span class="codeline" id="line-740"><code>	if max%pageSize != 0 {</code></span>
<span class="codeline" id="line-741"><code>		maxPages++</code></span>
<span class="codeline" id="line-742"><code>	}</code></span>
<span class="codeline" id="line-743"><code></code></span>
<span class="codeline" id="line-744"><code>	// Calculate the minimum number of pages we can scavenge.</code></span>
<span class="codeline" id="line-745"><code>	//</code></span>
<span class="codeline" id="line-746"><code>	// Because we can only scavenge whole physical pages, we must</code></span>
<span class="codeline" id="line-747"><code>	// ensure that we scavenge at least minPages each time, aligned</code></span>
<span class="codeline" id="line-748"><code>	// to minPages*pageSize.</code></span>
<span class="codeline" id="line-749"><code>	minPages := physPageSize / pageSize</code></span>
<span class="codeline" id="line-750"><code>	if minPages &lt; 1 {</code></span>
<span class="codeline" id="line-751"><code>		minPages = 1</code></span>
<span class="codeline" id="line-752"><code>	}</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>	lock(p.mheapLock)</code></span>
<span class="codeline" id="line-755"><code>	if p.summary[len(p.summary)-1][ci].max() &gt;= uint(minPages) {</code></span>
<span class="codeline" id="line-756"><code>		// We only bother looking for a candidate if there at least</code></span>
<span class="codeline" id="line-757"><code>		// minPages free pages at all.</code></span>
<span class="codeline" id="line-758"><code>		base, npages := p.chunkOf(ci).findScavengeCandidate(searchIdx, minPages, maxPages)</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>		// If we found something, scavenge it and return!</code></span>
<span class="codeline" id="line-761"><code>		if npages != 0 {</code></span>
<span class="codeline" id="line-762"><code>			// Compute the full address for the start of the range.</code></span>
<span class="codeline" id="line-763"><code>			addr := chunkBase(ci) + uintptr(base)*pageSize</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>			// Mark the range we're about to scavenge as allocated, because</code></span>
<span class="codeline" id="line-766"><code>			// we don't want any allocating goroutines to grab it while</code></span>
<span class="codeline" id="line-767"><code>			// the scavenging is in progress. Be careful here -- just do the</code></span>
<span class="codeline" id="line-768"><code>			// bare minimum to avoid stepping on our own scavenging stats.</code></span>
<span class="codeline" id="line-769"><code>			p.chunkOf(ci).allocRange(base, npages)</code></span>
<span class="codeline" id="line-770"><code>			p.update(addr, uintptr(npages), true, true)</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>			// With that done, it's safe to unlock.</code></span>
<span class="codeline" id="line-773"><code>			unlock(p.mheapLock)</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>			if !p.test {</code></span>
<span class="codeline" id="line-776"><code>				pageTraceScav(getg().m.p.ptr(), 0, addr, uintptr(npages))</code></span>
<span class="codeline" id="line-777"><code></code></span>
<span class="codeline" id="line-778"><code>				// Only perform sys* operations if we're not in a test.</code></span>
<span class="codeline" id="line-779"><code>				// It's dangerous to do so otherwise.</code></span>
<span class="codeline" id="line-780"><code>				sysUnused(unsafe.Pointer(addr), uintptr(npages)*pageSize)</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>				// Update global accounting only when not in test, otherwise</code></span>
<span class="codeline" id="line-783"><code>				// the runtime's accounting will be wrong.</code></span>
<span class="codeline" id="line-784"><code>				nbytes := int64(npages * pageSize)</code></span>
<span class="codeline" id="line-785"><code>				gcController.heapReleased.add(nbytes)</code></span>
<span class="codeline" id="line-786"><code>				gcController.heapFree.add(-nbytes)</code></span>
<span class="codeline" id="line-787"><code></code></span>
<span class="codeline" id="line-788"><code>				stats := memstats.heapStats.acquire()</code></span>
<span class="codeline" id="line-789"><code>				atomic.Xaddint64(&amp;stats.committed, -nbytes)</code></span>
<span class="codeline" id="line-790"><code>				atomic.Xaddint64(&amp;stats.released, nbytes)</code></span>
<span class="codeline" id="line-791"><code>				memstats.heapStats.release()</code></span>
<span class="codeline" id="line-792"><code>			}</code></span>
<span class="codeline" id="line-793"><code></code></span>
<span class="codeline" id="line-794"><code>			// Relock the heap, because now we need to make these pages</code></span>
<span class="codeline" id="line-795"><code>			// available allocation. Free them back to the page allocator.</code></span>
<span class="codeline" id="line-796"><code>			lock(p.mheapLock)</code></span>
<span class="codeline" id="line-797"><code>			if b := (offAddr{addr}); b.lessThan(p.searchAddr) {</code></span>
<span class="codeline" id="line-798"><code>				p.searchAddr = b</code></span>
<span class="codeline" id="line-799"><code>			}</code></span>
<span class="codeline" id="line-800"><code>			p.chunkOf(ci).free(base, npages)</code></span>
<span class="codeline" id="line-801"><code>			p.update(addr, uintptr(npages), true, false)</code></span>
<span class="codeline" id="line-802"><code></code></span>
<span class="codeline" id="line-803"><code>			// Mark the range as scavenged.</code></span>
<span class="codeline" id="line-804"><code>			p.chunkOf(ci).scavenged.setRange(base, npages)</code></span>
<span class="codeline" id="line-805"><code>			unlock(p.mheapLock)</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>			return uintptr(npages) * pageSize</code></span>
<span class="codeline" id="line-808"><code>		}</code></span>
<span class="codeline" id="line-809"><code>	}</code></span>
<span class="codeline" id="line-810"><code>	// Mark this chunk as having no free pages.</code></span>
<span class="codeline" id="line-811"><code>	p.scav.index.setEmpty(ci)</code></span>
<span class="codeline" id="line-812"><code>	unlock(p.mheapLock)</code></span>
<span class="codeline" id="line-813"><code></code></span>
<span class="codeline" id="line-814"><code>	return 0</code></span>
<span class="codeline" id="line-815"><code>}</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>// fillAligned returns x but with all zeroes in m-aligned</code></span>
<span class="codeline" id="line-818"><code>// groups of m bits set to 1 if any bit in the group is non-zero.</code></span>
<span class="codeline" id="line-819"><code>//</code></span>
<span class="codeline" id="line-820"><code>// For example, fillAligned(0x0100a3, 8) == 0xff00ff.</code></span>
<span class="codeline" id="line-821"><code>//</code></span>
<span class="codeline" id="line-822"><code>// Note that if m == 1, this is a no-op.</code></span>
<span class="codeline" id="line-823"><code>//</code></span>
<span class="codeline" id="line-824"><code>// m must be a power of 2 &lt;= maxPagesPerPhysPage.</code></span>
<span class="codeline" id="line-825"><code>func fillAligned(x uint64, m uint) uint64 {</code></span>
<span class="codeline" id="line-826"><code>	apply := func(x uint64, c uint64) uint64 {</code></span>
<span class="codeline" id="line-827"><code>		// The technique used it here is derived from</code></span>
<span class="codeline" id="line-828"><code>		// https://graphics.stanford.edu/~seander/bithacks.html#ZeroInWord</code></span>
<span class="codeline" id="line-829"><code>		// and extended for more than just bytes (like nibbles</code></span>
<span class="codeline" id="line-830"><code>		// and uint16s) by using an appropriate constant.</code></span>
<span class="codeline" id="line-831"><code>		//</code></span>
<span class="codeline" id="line-832"><code>		// To summarize the technique, quoting from that page:</code></span>
<span class="codeline" id="line-833"><code>		// "[It] works by first zeroing the high bits of the [8]</code></span>
<span class="codeline" id="line-834"><code>		// bytes in the word. Subsequently, it adds a number that</code></span>
<span class="codeline" id="line-835"><code>		// will result in an overflow to the high bit of a byte if</code></span>
<span class="codeline" id="line-836"><code>		// any of the low bits were initially set. Next the high</code></span>
<span class="codeline" id="line-837"><code>		// bits of the original word are ORed with these values;</code></span>
<span class="codeline" id="line-838"><code>		// thus, the high bit of a byte is set iff any bit in the</code></span>
<span class="codeline" id="line-839"><code>		// byte was set. Finally, we determine if any of these high</code></span>
<span class="codeline" id="line-840"><code>		// bits are zero by ORing with ones everywhere except the</code></span>
<span class="codeline" id="line-841"><code>		// high bits and inverting the result."</code></span>
<span class="codeline" id="line-842"><code>		return ^((((x &amp; c) + c) | x) | c)</code></span>
<span class="codeline" id="line-843"><code>	}</code></span>
<span class="codeline" id="line-844"><code>	// Transform x to contain a 1 bit at the top of each m-aligned</code></span>
<span class="codeline" id="line-845"><code>	// group of m zero bits.</code></span>
<span class="codeline" id="line-846"><code>	switch m {</code></span>
<span class="codeline" id="line-847"><code>	case 1:</code></span>
<span class="codeline" id="line-848"><code>		return x</code></span>
<span class="codeline" id="line-849"><code>	case 2:</code></span>
<span class="codeline" id="line-850"><code>		x = apply(x, 0x5555555555555555)</code></span>
<span class="codeline" id="line-851"><code>	case 4:</code></span>
<span class="codeline" id="line-852"><code>		x = apply(x, 0x7777777777777777)</code></span>
<span class="codeline" id="line-853"><code>	case 8:</code></span>
<span class="codeline" id="line-854"><code>		x = apply(x, 0x7f7f7f7f7f7f7f7f)</code></span>
<span class="codeline" id="line-855"><code>	case 16:</code></span>
<span class="codeline" id="line-856"><code>		x = apply(x, 0x7fff7fff7fff7fff)</code></span>
<span class="codeline" id="line-857"><code>	case 32:</code></span>
<span class="codeline" id="line-858"><code>		x = apply(x, 0x7fffffff7fffffff)</code></span>
<span class="codeline" id="line-859"><code>	case 64: // == maxPagesPerPhysPage</code></span>
<span class="codeline" id="line-860"><code>		x = apply(x, 0x7fffffffffffffff)</code></span>
<span class="codeline" id="line-861"><code>	default:</code></span>
<span class="codeline" id="line-862"><code>		throw("bad m value")</code></span>
<span class="codeline" id="line-863"><code>	}</code></span>
<span class="codeline" id="line-864"><code>	// Now, the top bit of each m-aligned group in x is set</code></span>
<span class="codeline" id="line-865"><code>	// that group was all zero in the original x.</code></span>
<span class="codeline" id="line-866"><code></code></span>
<span class="codeline" id="line-867"><code>	// From each group of m bits subtract 1.</code></span>
<span class="codeline" id="line-868"><code>	// Because we know only the top bits of each</code></span>
<span class="codeline" id="line-869"><code>	// m-aligned group are set, we know this will</code></span>
<span class="codeline" id="line-870"><code>	// set each group to have all the bits set except</code></span>
<span class="codeline" id="line-871"><code>	// the top bit, so just OR with the original</code></span>
<span class="codeline" id="line-872"><code>	// result to set all the bits.</code></span>
<span class="codeline" id="line-873"><code>	return ^((x - (x &gt;&gt; (m - 1))) | x)</code></span>
<span class="codeline" id="line-874"><code>}</code></span>
<span class="codeline" id="line-875"><code></code></span>
<span class="codeline" id="line-876"><code>// findScavengeCandidate returns a start index and a size for this pallocData</code></span>
<span class="codeline" id="line-877"><code>// segment which represents a contiguous region of free and unscavenged memory.</code></span>
<span class="codeline" id="line-878"><code>//</code></span>
<span class="codeline" id="line-879"><code>// searchIdx indicates the page index within this chunk to start the search, but</code></span>
<span class="codeline" id="line-880"><code>// note that findScavengeCandidate searches backwards through the pallocData. As</code></span>
<span class="codeline" id="line-881"><code>// a result, it will return the highest scavenge candidate in address order.</code></span>
<span class="codeline" id="line-882"><code>//</code></span>
<span class="codeline" id="line-883"><code>// min indicates a hard minimum size and alignment for runs of pages. That is,</code></span>
<span class="codeline" id="line-884"><code>// findScavengeCandidate will not return a region smaller than min pages in size,</code></span>
<span class="codeline" id="line-885"><code>// or that is min pages or greater in size but not aligned to min. min must be</code></span>
<span class="codeline" id="line-886"><code>// a non-zero power of 2 &lt;= maxPagesPerPhysPage.</code></span>
<span class="codeline" id="line-887"><code>//</code></span>
<span class="codeline" id="line-888"><code>// max is a hint for how big of a region is desired. If max &gt;= pallocChunkPages, then</code></span>
<span class="codeline" id="line-889"><code>// findScavengeCandidate effectively returns entire free and unscavenged regions.</code></span>
<span class="codeline" id="line-890"><code>// If max &lt; pallocChunkPages, it may truncate the returned region such that size is</code></span>
<span class="codeline" id="line-891"><code>// max. However, findScavengeCandidate may still return a larger region if, for</code></span>
<span class="codeline" id="line-892"><code>// example, it chooses to preserve huge pages, or if max is not aligned to min (it</code></span>
<span class="codeline" id="line-893"><code>// will round up). That is, even if max is small, the returned size is not guaranteed</code></span>
<span class="codeline" id="line-894"><code>// to be equal to max. max is allowed to be less than min, in which case it is as if</code></span>
<span class="codeline" id="line-895"><code>// max == min.</code></span>
<span class="codeline" id="line-896"><code>func (m *pallocData) findScavengeCandidate(searchIdx uint, minimum, max uintptr) (uint, uint) {</code></span>
<span class="codeline" id="line-897"><code>	if minimum&amp;(minimum-1) != 0 || minimum == 0 {</code></span>
<span class="codeline" id="line-898"><code>		print("runtime: min = ", minimum, "\n")</code></span>
<span class="codeline" id="line-899"><code>		throw("min must be a non-zero power of 2")</code></span>
<span class="codeline" id="line-900"><code>	} else if minimum &gt; maxPagesPerPhysPage {</code></span>
<span class="codeline" id="line-901"><code>		print("runtime: min = ", minimum, "\n")</code></span>
<span class="codeline" id="line-902"><code>		throw("min too large")</code></span>
<span class="codeline" id="line-903"><code>	}</code></span>
<span class="codeline" id="line-904"><code>	// max may not be min-aligned, so we might accidentally truncate to</code></span>
<span class="codeline" id="line-905"><code>	// a max value which causes us to return a non-min-aligned value.</code></span>
<span class="codeline" id="line-906"><code>	// To prevent this, align max up to a multiple of min (which is always</code></span>
<span class="codeline" id="line-907"><code>	// a power of 2). This also prevents max from ever being less than</code></span>
<span class="codeline" id="line-908"><code>	// min, unless it's zero, so handle that explicitly.</code></span>
<span class="codeline" id="line-909"><code>	if max == 0 {</code></span>
<span class="codeline" id="line-910"><code>		max = minimum</code></span>
<span class="codeline" id="line-911"><code>	} else {</code></span>
<span class="codeline" id="line-912"><code>		max = alignUp(max, minimum)</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code></code></span>
<span class="codeline" id="line-915"><code>	i := int(searchIdx / 64)</code></span>
<span class="codeline" id="line-916"><code>	// Start by quickly skipping over blocks of non-free or scavenged pages.</code></span>
<span class="codeline" id="line-917"><code>	for ; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-918"><code>		// 1s are scavenged OR non-free =&gt; 0s are unscavenged AND free</code></span>
<span class="codeline" id="line-919"><code>		x := fillAligned(m.scavenged[i]|m.pallocBits[i], uint(minimum))</code></span>
<span class="codeline" id="line-920"><code>		if x != ^uint64(0) {</code></span>
<span class="codeline" id="line-921"><code>			break</code></span>
<span class="codeline" id="line-922"><code>		}</code></span>
<span class="codeline" id="line-923"><code>	}</code></span>
<span class="codeline" id="line-924"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-925"><code>		// Failed to find any free/unscavenged pages.</code></span>
<span class="codeline" id="line-926"><code>		return 0, 0</code></span>
<span class="codeline" id="line-927"><code>	}</code></span>
<span class="codeline" id="line-928"><code>	// We have something in the 64-bit chunk at i, but it could</code></span>
<span class="codeline" id="line-929"><code>	// extend further. Loop until we find the extent of it.</code></span>
<span class="codeline" id="line-930"><code></code></span>
<span class="codeline" id="line-931"><code>	// 1s are scavenged OR non-free =&gt; 0s are unscavenged AND free</code></span>
<span class="codeline" id="line-932"><code>	x := fillAligned(m.scavenged[i]|m.pallocBits[i], uint(minimum))</code></span>
<span class="codeline" id="line-933"><code>	z1 := uint(sys.LeadingZeros64(^x))</code></span>
<span class="codeline" id="line-934"><code>	run, end := uint(0), uint(i)*64+(64-z1)</code></span>
<span class="codeline" id="line-935"><code>	if x&lt;&lt;z1 != 0 {</code></span>
<span class="codeline" id="line-936"><code>		// After shifting out z1 bits, we still have 1s,</code></span>
<span class="codeline" id="line-937"><code>		// so the run ends inside this word.</code></span>
<span class="codeline" id="line-938"><code>		run = uint(sys.LeadingZeros64(x &lt;&lt; z1))</code></span>
<span class="codeline" id="line-939"><code>	} else {</code></span>
<span class="codeline" id="line-940"><code>		// After shifting out z1 bits, we have no more 1s.</code></span>
<span class="codeline" id="line-941"><code>		// This means the run extends to the bottom of the</code></span>
<span class="codeline" id="line-942"><code>		// word so it may extend into further words.</code></span>
<span class="codeline" id="line-943"><code>		run = 64 - z1</code></span>
<span class="codeline" id="line-944"><code>		for j := i - 1; j &gt;= 0; j-- {</code></span>
<span class="codeline" id="line-945"><code>			x := fillAligned(m.scavenged[j]|m.pallocBits[j], uint(minimum))</code></span>
<span class="codeline" id="line-946"><code>			run += uint(sys.LeadingZeros64(x))</code></span>
<span class="codeline" id="line-947"><code>			if x != 0 {</code></span>
<span class="codeline" id="line-948"><code>				// The run stopped in this word.</code></span>
<span class="codeline" id="line-949"><code>				break</code></span>
<span class="codeline" id="line-950"><code>			}</code></span>
<span class="codeline" id="line-951"><code>		}</code></span>
<span class="codeline" id="line-952"><code>	}</code></span>
<span class="codeline" id="line-953"><code></code></span>
<span class="codeline" id="line-954"><code>	// Split the run we found if it's larger than max but hold on to</code></span>
<span class="codeline" id="line-955"><code>	// our original length, since we may need it later.</code></span>
<span class="codeline" id="line-956"><code>	size := min(run, uint(max))</code></span>
<span class="codeline" id="line-957"><code>	start := end - size</code></span>
<span class="codeline" id="line-958"><code></code></span>
<span class="codeline" id="line-959"><code>	// Each huge page is guaranteed to fit in a single palloc chunk.</code></span>
<span class="codeline" id="line-960"><code>	//</code></span>
<span class="codeline" id="line-961"><code>	// TODO(mknyszek): Support larger huge page sizes.</code></span>
<span class="codeline" id="line-962"><code>	// TODO(mknyszek): Consider taking pages-per-huge-page as a parameter</code></span>
<span class="codeline" id="line-963"><code>	// so we can write tests for this.</code></span>
<span class="codeline" id="line-964"><code>	if physHugePageSize &gt; pageSize &amp;&amp; physHugePageSize &gt; physPageSize {</code></span>
<span class="codeline" id="line-965"><code>		// We have huge pages, so let's ensure we don't break one by scavenging</code></span>
<span class="codeline" id="line-966"><code>		// over a huge page boundary. If the range [start, start+size) overlaps with</code></span>
<span class="codeline" id="line-967"><code>		// a free-and-unscavenged huge page, we want to grow the region we scavenge</code></span>
<span class="codeline" id="line-968"><code>		// to include that huge page.</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>		// Compute the huge page boundary above our candidate.</code></span>
<span class="codeline" id="line-971"><code>		pagesPerHugePage := physHugePageSize / pageSize</code></span>
<span class="codeline" id="line-972"><code>		hugePageAbove := uint(alignUp(uintptr(start), pagesPerHugePage))</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>		// If that boundary is within our current candidate, then we may be breaking</code></span>
<span class="codeline" id="line-975"><code>		// a huge page.</code></span>
<span class="codeline" id="line-976"><code>		if hugePageAbove &lt;= end {</code></span>
<span class="codeline" id="line-977"><code>			// Compute the huge page boundary below our candidate.</code></span>
<span class="codeline" id="line-978"><code>			hugePageBelow := uint(alignDown(uintptr(start), pagesPerHugePage))</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>			if hugePageBelow &gt;= end-run {</code></span>
<span class="codeline" id="line-981"><code>				// We're in danger of breaking apart a huge page since start+size crosses</code></span>
<span class="codeline" id="line-982"><code>				// a huge page boundary and rounding down start to the nearest huge</code></span>
<span class="codeline" id="line-983"><code>				// page boundary is included in the full run we found. Include the entire</code></span>
<span class="codeline" id="line-984"><code>				// huge page in the bound by rounding down to the huge page size.</code></span>
<span class="codeline" id="line-985"><code>				size = size + (start - hugePageBelow)</code></span>
<span class="codeline" id="line-986"><code>				start = hugePageBelow</code></span>
<span class="codeline" id="line-987"><code>			}</code></span>
<span class="codeline" id="line-988"><code>		}</code></span>
<span class="codeline" id="line-989"><code>	}</code></span>
<span class="codeline" id="line-990"><code>	return start, size</code></span>
<span class="codeline" id="line-991"><code>}</code></span>
<span class="codeline" id="line-992"><code></code></span>
<span class="codeline" id="line-993"><code>// scavengeIndex is a structure for efficiently managing which pageAlloc chunks have</code></span>
<span class="codeline" id="line-994"><code>// memory available to scavenge.</code></span>
<span class="codeline" id="line-995"><code>type scavengeIndex struct {</code></span>
<span class="codeline" id="line-996"><code>	// chunks is a scavChunkData-per-chunk structure that indicates the presence of pages</code></span>
<span class="codeline" id="line-997"><code>	// available for scavenging. Updates to the index are serialized by the pageAlloc lock.</code></span>
<span class="codeline" id="line-998"><code>	//</code></span>
<span class="codeline" id="line-999"><code>	// It tracks chunk occupancy and a generation counter per chunk. If a chunk's occupancy</code></span>
<span class="codeline" id="line-1000"><code>	// never exceeds pallocChunkDensePages over the course of a single GC cycle, the chunk</code></span>
<span class="codeline" id="line-1001"><code>	// becomes eligible for scavenging on the next cycle. If a chunk ever hits this density</code></span>
<span class="codeline" id="line-1002"><code>	// threshold it immediately becomes unavailable for scavenging in the current cycle as</code></span>
<span class="codeline" id="line-1003"><code>	// well as the next.</code></span>
<span class="codeline" id="line-1004"><code>	//</code></span>
<span class="codeline" id="line-1005"><code>	// [min, max) represents the range of chunks that is safe to access (i.e. will not cause</code></span>
<span class="codeline" id="line-1006"><code>	// a fault). As an optimization minHeapIdx represents the true minimum chunk that has been</code></span>
<span class="codeline" id="line-1007"><code>	// mapped, since min is likely rounded down to include the system page containing minHeapIdx.</code></span>
<span class="codeline" id="line-1008"><code>	//</code></span>
<span class="codeline" id="line-1009"><code>	// For a chunk size of 4 MiB this structure will only use 2 MiB for a 1 TiB contiguous heap.</code></span>
<span class="codeline" id="line-1010"><code>	chunks     []atomicScavChunkData</code></span>
<span class="codeline" id="line-1011"><code>	min, max   atomic.Uintptr</code></span>
<span class="codeline" id="line-1012"><code>	minHeapIdx atomic.Uintptr</code></span>
<span class="codeline" id="line-1013"><code></code></span>
<span class="codeline" id="line-1014"><code>	// searchAddr* is the maximum address (in the offset address space, so we have a linear</code></span>
<span class="codeline" id="line-1015"><code>	// view of the address space; see mranges.go:offAddr) containing memory available to</code></span>
<span class="codeline" id="line-1016"><code>	// scavenge. It is a hint to the find operation to avoid O(n^2) behavior in repeated lookups.</code></span>
<span class="codeline" id="line-1017"><code>	//</code></span>
<span class="codeline" id="line-1018"><code>	// searchAddr* is always inclusive and should be the base address of the highest runtime</code></span>
<span class="codeline" id="line-1019"><code>	// page available for scavenging.</code></span>
<span class="codeline" id="line-1020"><code>	//</code></span>
<span class="codeline" id="line-1021"><code>	// searchAddrForce is managed by find and free.</code></span>
<span class="codeline" id="line-1022"><code>	// searchAddrBg is managed by find and nextGen.</code></span>
<span class="codeline" id="line-1023"><code>	//</code></span>
<span class="codeline" id="line-1024"><code>	// Normally, find monotonically decreases searchAddr* as it finds no more free pages to</code></span>
<span class="codeline" id="line-1025"><code>	// scavenge. However, mark, when marking a new chunk at an index greater than the current</code></span>
<span class="codeline" id="line-1026"><code>	// searchAddr, sets searchAddr to the *negative* index into chunks of that page. The trick here</code></span>
<span class="codeline" id="line-1027"><code>	// is that concurrent calls to find will fail to monotonically decrease searchAddr*, and so they</code></span>
<span class="codeline" id="line-1028"><code>	// won't barge over new memory becoming available to scavenge. Furthermore, this ensures</code></span>
<span class="codeline" id="line-1029"><code>	// that some future caller of find *must* observe the new high index. That caller</code></span>
<span class="codeline" id="line-1030"><code>	// (or any other racing with it), then makes searchAddr positive before continuing, bringing</code></span>
<span class="codeline" id="line-1031"><code>	// us back to our monotonically decreasing steady-state.</code></span>
<span class="codeline" id="line-1032"><code>	//</code></span>
<span class="codeline" id="line-1033"><code>	// A pageAlloc lock serializes updates between min, max, and searchAddr, so abs(searchAddr)</code></span>
<span class="codeline" id="line-1034"><code>	// is always guaranteed to be &gt;= min and &lt; max (converted to heap addresses).</code></span>
<span class="codeline" id="line-1035"><code>	//</code></span>
<span class="codeline" id="line-1036"><code>	// searchAddrBg is increased only on each new generation and is mainly used by the</code></span>
<span class="codeline" id="line-1037"><code>	// background scavenger and heap-growth scavenging. searchAddrForce is increased continuously</code></span>
<span class="codeline" id="line-1038"><code>	// as memory gets freed and is mainly used by eager memory reclaim such as debug.FreeOSMemory</code></span>
<span class="codeline" id="line-1039"><code>	// and scavenging to maintain the memory limit.</code></span>
<span class="codeline" id="line-1040"><code>	searchAddrBg    atomicOffAddr</code></span>
<span class="codeline" id="line-1041"><code>	searchAddrForce atomicOffAddr</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>	// freeHWM is the highest address (in offset address space) that was freed</code></span>
<span class="codeline" id="line-1044"><code>	// this generation.</code></span>
<span class="codeline" id="line-1045"><code>	freeHWM offAddr</code></span>
<span class="codeline" id="line-1046"><code></code></span>
<span class="codeline" id="line-1047"><code>	// Generation counter. Updated by nextGen at the end of each mark phase.</code></span>
<span class="codeline" id="line-1048"><code>	gen uint32</code></span>
<span class="codeline" id="line-1049"><code></code></span>
<span class="codeline" id="line-1050"><code>	// test indicates whether or not we're in a test.</code></span>
<span class="codeline" id="line-1051"><code>	test bool</code></span>
<span class="codeline" id="line-1052"><code>}</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>// init initializes the scavengeIndex.</code></span>
<span class="codeline" id="line-1055"><code>//</code></span>
<span class="codeline" id="line-1056"><code>// Returns the amount added to sysStat.</code></span>
<span class="codeline" id="line-1057"><code>func (s *scavengeIndex) init(test bool, sysStat *sysMemStat) uintptr {</code></span>
<span class="codeline" id="line-1058"><code>	s.searchAddrBg.Clear()</code></span>
<span class="codeline" id="line-1059"><code>	s.searchAddrForce.Clear()</code></span>
<span class="codeline" id="line-1060"><code>	s.freeHWM = minOffAddr</code></span>
<span class="codeline" id="line-1061"><code>	s.test = test</code></span>
<span class="codeline" id="line-1062"><code>	return s.sysInit(test, sysStat)</code></span>
<span class="codeline" id="line-1063"><code>}</code></span>
<span class="codeline" id="line-1064"><code></code></span>
<span class="codeline" id="line-1065"><code>// sysGrow updates the index's backing store in response to a heap growth.</code></span>
<span class="codeline" id="line-1066"><code>//</code></span>
<span class="codeline" id="line-1067"><code>// Returns the amount of memory added to sysStat.</code></span>
<span class="codeline" id="line-1068"><code>func (s *scavengeIndex) grow(base, limit uintptr, sysStat *sysMemStat) uintptr {</code></span>
<span class="codeline" id="line-1069"><code>	// Update minHeapIdx. Note that even if there's no mapping work to do,</code></span>
<span class="codeline" id="line-1070"><code>	// we may still have a new, lower minimum heap address.</code></span>
<span class="codeline" id="line-1071"><code>	minHeapIdx := s.minHeapIdx.Load()</code></span>
<span class="codeline" id="line-1072"><code>	if baseIdx := uintptr(chunkIndex(base)); minHeapIdx == 0 || baseIdx &lt; minHeapIdx {</code></span>
<span class="codeline" id="line-1073"><code>		s.minHeapIdx.Store(baseIdx)</code></span>
<span class="codeline" id="line-1074"><code>	}</code></span>
<span class="codeline" id="line-1075"><code>	return s.sysGrow(base, limit, sysStat)</code></span>
<span class="codeline" id="line-1076"><code>}</code></span>
<span class="codeline" id="line-1077"><code></code></span>
<span class="codeline" id="line-1078"><code>// find returns the highest chunk index that may contain pages available to scavenge.</code></span>
<span class="codeline" id="line-1079"><code>// It also returns an offset to start searching in the highest chunk.</code></span>
<span class="codeline" id="line-1080"><code>func (s *scavengeIndex) find(force bool) (chunkIdx, uint) {</code></span>
<span class="codeline" id="line-1081"><code>	cursor := &amp;s.searchAddrBg</code></span>
<span class="codeline" id="line-1082"><code>	if force {</code></span>
<span class="codeline" id="line-1083"><code>		cursor = &amp;s.searchAddrForce</code></span>
<span class="codeline" id="line-1084"><code>	}</code></span>
<span class="codeline" id="line-1085"><code>	searchAddr, marked := cursor.Load()</code></span>
<span class="codeline" id="line-1086"><code>	if searchAddr == minOffAddr.addr() {</code></span>
<span class="codeline" id="line-1087"><code>		// We got a cleared search addr.</code></span>
<span class="codeline" id="line-1088"><code>		return 0, 0</code></span>
<span class="codeline" id="line-1089"><code>	}</code></span>
<span class="codeline" id="line-1090"><code></code></span>
<span class="codeline" id="line-1091"><code>	// Starting from searchAddr's chunk, iterate until we find a chunk with pages to scavenge.</code></span>
<span class="codeline" id="line-1092"><code>	gen := s.gen</code></span>
<span class="codeline" id="line-1093"><code>	min := chunkIdx(s.minHeapIdx.Load())</code></span>
<span class="codeline" id="line-1094"><code>	start := chunkIndex(searchAddr)</code></span>
<span class="codeline" id="line-1095"><code>	// N.B. We'll never map the 0'th chunk, so minHeapIdx ensures this loop overflow.</code></span>
<span class="codeline" id="line-1096"><code>	for i := start; i &gt;= min; i-- {</code></span>
<span class="codeline" id="line-1097"><code>		// Skip over chunks.</code></span>
<span class="codeline" id="line-1098"><code>		if !s.chunks[i].load().shouldScavenge(gen, force) {</code></span>
<span class="codeline" id="line-1099"><code>			continue</code></span>
<span class="codeline" id="line-1100"><code>		}</code></span>
<span class="codeline" id="line-1101"><code>		// We're still scavenging this chunk.</code></span>
<span class="codeline" id="line-1102"><code>		if i == start {</code></span>
<span class="codeline" id="line-1103"><code>			return i, chunkPageIndex(searchAddr)</code></span>
<span class="codeline" id="line-1104"><code>		}</code></span>
<span class="codeline" id="line-1105"><code>		// Try to reduce searchAddr to newSearchAddr.</code></span>
<span class="codeline" id="line-1106"><code>		newSearchAddr := chunkBase(i) + pallocChunkBytes - pageSize</code></span>
<span class="codeline" id="line-1107"><code>		if marked {</code></span>
<span class="codeline" id="line-1108"><code>			// Attempt to be the first one to decrease the searchAddr</code></span>
<span class="codeline" id="line-1109"><code>			// after an increase. If we fail, that means there was another</code></span>
<span class="codeline" id="line-1110"><code>			// increase, or somebody else got to it before us. Either way,</code></span>
<span class="codeline" id="line-1111"><code>			// it doesn't matter. We may lose some performance having an</code></span>
<span class="codeline" id="line-1112"><code>			// incorrect search address, but it's far more important that</code></span>
<span class="codeline" id="line-1113"><code>			// we don't miss updates.</code></span>
<span class="codeline" id="line-1114"><code>			cursor.StoreUnmark(searchAddr, newSearchAddr)</code></span>
<span class="codeline" id="line-1115"><code>		} else {</code></span>
<span class="codeline" id="line-1116"><code>			// Decrease searchAddr.</code></span>
<span class="codeline" id="line-1117"><code>			cursor.StoreMin(newSearchAddr)</code></span>
<span class="codeline" id="line-1118"><code>		}</code></span>
<span class="codeline" id="line-1119"><code>		return i, pallocChunkPages - 1</code></span>
<span class="codeline" id="line-1120"><code>	}</code></span>
<span class="codeline" id="line-1121"><code>	// Clear searchAddr, because we've exhausted the heap.</code></span>
<span class="codeline" id="line-1122"><code>	cursor.Clear()</code></span>
<span class="codeline" id="line-1123"><code>	return 0, 0</code></span>
<span class="codeline" id="line-1124"><code>}</code></span>
<span class="codeline" id="line-1125"><code></code></span>
<span class="codeline" id="line-1126"><code>// alloc updates metadata for chunk at index ci with the fact that</code></span>
<span class="codeline" id="line-1127"><code>// an allocation of npages occurred. It also eagerly attempts to collapse</code></span>
<span class="codeline" id="line-1128"><code>// the chunk's memory into hugepage if the chunk has become sufficiently</code></span>
<span class="codeline" id="line-1129"><code>// dense and we're not allocating the whole chunk at once (which suggests</code></span>
<span class="codeline" id="line-1130"><code>// the allocation is part of a bigger one and it's probably not worth</code></span>
<span class="codeline" id="line-1131"><code>// eagerly collapsing).</code></span>
<span class="codeline" id="line-1132"><code>//</code></span>
<span class="codeline" id="line-1133"><code>// alloc may only run concurrently with find.</code></span>
<span class="codeline" id="line-1134"><code>func (s *scavengeIndex) alloc(ci chunkIdx, npages uint) {</code></span>
<span class="codeline" id="line-1135"><code>	sc := s.chunks[ci].load()</code></span>
<span class="codeline" id="line-1136"><code>	sc.alloc(npages, s.gen)</code></span>
<span class="codeline" id="line-1137"><code>	// TODO(mknyszek): Consider eagerly backing memory with huge pages</code></span>
<span class="codeline" id="line-1138"><code>	// here and track whether we believe this chunk is backed by huge pages.</code></span>
<span class="codeline" id="line-1139"><code>	// In the past we've attempted to use sysHugePageCollapse (which uses</code></span>
<span class="codeline" id="line-1140"><code>	// MADV_COLLAPSE on Linux, and is unsupported elswhere) for this purpose,</code></span>
<span class="codeline" id="line-1141"><code>	// but that caused performance issues in production environments.</code></span>
<span class="codeline" id="line-1142"><code>	s.chunks[ci].store(sc)</code></span>
<span class="codeline" id="line-1143"><code>}</code></span>
<span class="codeline" id="line-1144"><code></code></span>
<span class="codeline" id="line-1145"><code>// free updates metadata for chunk at index ci with the fact that</code></span>
<span class="codeline" id="line-1146"><code>// a free of npages occurred.</code></span>
<span class="codeline" id="line-1147"><code>//</code></span>
<span class="codeline" id="line-1148"><code>// free may only run concurrently with find.</code></span>
<span class="codeline" id="line-1149"><code>func (s *scavengeIndex) free(ci chunkIdx, page, npages uint) {</code></span>
<span class="codeline" id="line-1150"><code>	sc := s.chunks[ci].load()</code></span>
<span class="codeline" id="line-1151"><code>	sc.free(npages, s.gen)</code></span>
<span class="codeline" id="line-1152"><code>	s.chunks[ci].store(sc)</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>	// Update scavenge search addresses.</code></span>
<span class="codeline" id="line-1155"><code>	addr := chunkBase(ci) + uintptr(page+npages-1)*pageSize</code></span>
<span class="codeline" id="line-1156"><code>	if s.freeHWM.lessThan(offAddr{addr}) {</code></span>
<span class="codeline" id="line-1157"><code>		s.freeHWM = offAddr{addr}</code></span>
<span class="codeline" id="line-1158"><code>	}</code></span>
<span class="codeline" id="line-1159"><code>	// N.B. Because free is serialized, it's not necessary to do a</code></span>
<span class="codeline" id="line-1160"><code>	// full CAS here. free only ever increases searchAddr, while</code></span>
<span class="codeline" id="line-1161"><code>	// find only ever decreases it. Since we only ever race with</code></span>
<span class="codeline" id="line-1162"><code>	// decreases, even if the value we loaded is stale, the actual</code></span>
<span class="codeline" id="line-1163"><code>	// value will never be larger.</code></span>
<span class="codeline" id="line-1164"><code>	searchAddr, _ := s.searchAddrForce.Load()</code></span>
<span class="codeline" id="line-1165"><code>	if (offAddr{searchAddr}).lessThan(offAddr{addr}) {</code></span>
<span class="codeline" id="line-1166"><code>		s.searchAddrForce.StoreMarked(addr)</code></span>
<span class="codeline" id="line-1167"><code>	}</code></span>
<span class="codeline" id="line-1168"><code>}</code></span>
<span class="codeline" id="line-1169"><code></code></span>
<span class="codeline" id="line-1170"><code>// nextGen moves the scavenger forward one generation. Must be called</code></span>
<span class="codeline" id="line-1171"><code>// once per GC cycle, but may be called more often to force more memory</code></span>
<span class="codeline" id="line-1172"><code>// to be released.</code></span>
<span class="codeline" id="line-1173"><code>//</code></span>
<span class="codeline" id="line-1174"><code>// nextGen may only run concurrently with find.</code></span>
<span class="codeline" id="line-1175"><code>func (s *scavengeIndex) nextGen() {</code></span>
<span class="codeline" id="line-1176"><code>	s.gen++</code></span>
<span class="codeline" id="line-1177"><code>	searchAddr, _ := s.searchAddrBg.Load()</code></span>
<span class="codeline" id="line-1178"><code>	if (offAddr{searchAddr}).lessThan(s.freeHWM) {</code></span>
<span class="codeline" id="line-1179"><code>		s.searchAddrBg.StoreMarked(s.freeHWM.addr())</code></span>
<span class="codeline" id="line-1180"><code>	}</code></span>
<span class="codeline" id="line-1181"><code>	s.freeHWM = minOffAddr</code></span>
<span class="codeline" id="line-1182"><code>}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>// setEmpty marks that the scavenger has finished looking at ci</code></span>
<span class="codeline" id="line-1185"><code>// for now to prevent the scavenger from getting stuck looking</code></span>
<span class="codeline" id="line-1186"><code>// at the same chunk.</code></span>
<span class="codeline" id="line-1187"><code>//</code></span>
<span class="codeline" id="line-1188"><code>// setEmpty may only run concurrently with find.</code></span>
<span class="codeline" id="line-1189"><code>func (s *scavengeIndex) setEmpty(ci chunkIdx) {</code></span>
<span class="codeline" id="line-1190"><code>	val := s.chunks[ci].load()</code></span>
<span class="codeline" id="line-1191"><code>	val.setEmpty()</code></span>
<span class="codeline" id="line-1192"><code>	s.chunks[ci].store(val)</code></span>
<span class="codeline" id="line-1193"><code>}</code></span>
<span class="codeline" id="line-1194"><code></code></span>
<span class="codeline" id="line-1195"><code>// atomicScavChunkData is an atomic wrapper around a scavChunkData</code></span>
<span class="codeline" id="line-1196"><code>// that stores it in its packed form.</code></span>
<span class="codeline" id="line-1197"><code>type atomicScavChunkData struct {</code></span>
<span class="codeline" id="line-1198"><code>	value atomic.Uint64</code></span>
<span class="codeline" id="line-1199"><code>}</code></span>
<span class="codeline" id="line-1200"><code></code></span>
<span class="codeline" id="line-1201"><code>// load loads and unpacks a scavChunkData.</code></span>
<span class="codeline" id="line-1202"><code>func (sc *atomicScavChunkData) load() scavChunkData {</code></span>
<span class="codeline" id="line-1203"><code>	return unpackScavChunkData(sc.value.Load())</code></span>
<span class="codeline" id="line-1204"><code>}</code></span>
<span class="codeline" id="line-1205"><code></code></span>
<span class="codeline" id="line-1206"><code>// store packs and writes a new scavChunkData. store must be serialized</code></span>
<span class="codeline" id="line-1207"><code>// with other calls to store.</code></span>
<span class="codeline" id="line-1208"><code>func (sc *atomicScavChunkData) store(ssc scavChunkData) {</code></span>
<span class="codeline" id="line-1209"><code>	sc.value.Store(ssc.pack())</code></span>
<span class="codeline" id="line-1210"><code>}</code></span>
<span class="codeline" id="line-1211"><code></code></span>
<span class="codeline" id="line-1212"><code>// scavChunkData tracks information about a palloc chunk for</code></span>
<span class="codeline" id="line-1213"><code>// scavenging. It packs well into 64 bits.</code></span>
<span class="codeline" id="line-1214"><code>//</code></span>
<span class="codeline" id="line-1215"><code>// The zero value always represents a valid newly-grown chunk.</code></span>
<span class="codeline" id="line-1216"><code>type scavChunkData struct {</code></span>
<span class="codeline" id="line-1217"><code>	// inUse indicates how many pages in this chunk are currently</code></span>
<span class="codeline" id="line-1218"><code>	// allocated.</code></span>
<span class="codeline" id="line-1219"><code>	//</code></span>
<span class="codeline" id="line-1220"><code>	// Only the first 10 bits are used.</code></span>
<span class="codeline" id="line-1221"><code>	inUse uint16</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>	// lastInUse indicates how many pages in this chunk were allocated</code></span>
<span class="codeline" id="line-1224"><code>	// when we transitioned from gen-1 to gen.</code></span>
<span class="codeline" id="line-1225"><code>	//</code></span>
<span class="codeline" id="line-1226"><code>	// Only the first 10 bits are used.</code></span>
<span class="codeline" id="line-1227"><code>	lastInUse uint16</code></span>
<span class="codeline" id="line-1228"><code></code></span>
<span class="codeline" id="line-1229"><code>	// gen is the generation counter from a scavengeIndex from the</code></span>
<span class="codeline" id="line-1230"><code>	// last time this scavChunkData was updated.</code></span>
<span class="codeline" id="line-1231"><code>	gen uint32</code></span>
<span class="codeline" id="line-1232"><code></code></span>
<span class="codeline" id="line-1233"><code>	// scavChunkFlags represents additional flags</code></span>
<span class="codeline" id="line-1234"><code>	//</code></span>
<span class="codeline" id="line-1235"><code>	// Note: only 6 bits are available.</code></span>
<span class="codeline" id="line-1236"><code>	scavChunkFlags</code></span>
<span class="codeline" id="line-1237"><code>}</code></span>
<span class="codeline" id="line-1238"><code></code></span>
<span class="codeline" id="line-1239"><code>// unpackScavChunkData unpacks a scavChunkData from a uint64.</code></span>
<span class="codeline" id="line-1240"><code>func unpackScavChunkData(sc uint64) scavChunkData {</code></span>
<span class="codeline" id="line-1241"><code>	return scavChunkData{</code></span>
<span class="codeline" id="line-1242"><code>		inUse:          uint16(sc),</code></span>
<span class="codeline" id="line-1243"><code>		lastInUse:      uint16(sc&gt;&gt;16) &amp; scavChunkInUseMask,</code></span>
<span class="codeline" id="line-1244"><code>		gen:            uint32(sc &gt;&gt; 32),</code></span>
<span class="codeline" id="line-1245"><code>		scavChunkFlags: scavChunkFlags(uint8(sc&gt;&gt;(16+logScavChunkInUseMax)) &amp; scavChunkFlagsMask),</code></span>
<span class="codeline" id="line-1246"><code>	}</code></span>
<span class="codeline" id="line-1247"><code>}</code></span>
<span class="codeline" id="line-1248"><code></code></span>
<span class="codeline" id="line-1249"><code>// pack returns sc packed into a uint64.</code></span>
<span class="codeline" id="line-1250"><code>func (sc scavChunkData) pack() uint64 {</code></span>
<span class="codeline" id="line-1251"><code>	return uint64(sc.inUse) |</code></span>
<span class="codeline" id="line-1252"><code>		(uint64(sc.lastInUse) &lt;&lt; 16) |</code></span>
<span class="codeline" id="line-1253"><code>		(uint64(sc.scavChunkFlags) &lt;&lt; (16 + logScavChunkInUseMax)) |</code></span>
<span class="codeline" id="line-1254"><code>		(uint64(sc.gen) &lt;&lt; 32)</code></span>
<span class="codeline" id="line-1255"><code>}</code></span>
<span class="codeline" id="line-1256"><code></code></span>
<span class="codeline" id="line-1257"><code>const (</code></span>
<span class="codeline" id="line-1258"><code>	// scavChunkHasFree indicates whether the chunk has anything left to</code></span>
<span class="codeline" id="line-1259"><code>	// scavenge. This is the opposite of "empty," used elsewhere in this</code></span>
<span class="codeline" id="line-1260"><code>	// file. The reason we say "HasFree" here is so the zero value is</code></span>
<span class="codeline" id="line-1261"><code>	// correct for a newly-grown chunk. (New memory is scavenged.)</code></span>
<span class="codeline" id="line-1262"><code>	scavChunkHasFree scavChunkFlags = 1 &lt;&lt; iota</code></span>
<span class="codeline" id="line-1263"><code></code></span>
<span class="codeline" id="line-1264"><code>	// scavChunkMaxFlags is the maximum number of flags we can have, given how</code></span>
<span class="codeline" id="line-1265"><code>	// a scavChunkData is packed into 8 bytes.</code></span>
<span class="codeline" id="line-1266"><code>	scavChunkMaxFlags  = 6</code></span>
<span class="codeline" id="line-1267"><code>	scavChunkFlagsMask = (1 &lt;&lt; scavChunkMaxFlags) - 1</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>	// logScavChunkInUseMax is the number of bits needed to represent the number</code></span>
<span class="codeline" id="line-1270"><code>	// of pages allocated in a single chunk. This is 1 more than log2 of the</code></span>
<span class="codeline" id="line-1271"><code>	// number of pages in the chunk because we need to represent a fully-allocated</code></span>
<span class="codeline" id="line-1272"><code>	// chunk.</code></span>
<span class="codeline" id="line-1273"><code>	logScavChunkInUseMax = logPallocChunkPages + 1</code></span>
<span class="codeline" id="line-1274"><code>	scavChunkInUseMask   = (1 &lt;&lt; logScavChunkInUseMax) - 1</code></span>
<span class="codeline" id="line-1275"><code>)</code></span>
<span class="codeline" id="line-1276"><code></code></span>
<span class="codeline" id="line-1277"><code>// scavChunkFlags is a set of bit-flags for the scavenger for each palloc chunk.</code></span>
<span class="codeline" id="line-1278"><code>type scavChunkFlags uint8</code></span>
<span class="codeline" id="line-1279"><code></code></span>
<span class="codeline" id="line-1280"><code>// isEmpty returns true if the hasFree flag is unset.</code></span>
<span class="codeline" id="line-1281"><code>func (sc *scavChunkFlags) isEmpty() bool {</code></span>
<span class="codeline" id="line-1282"><code>	return (*sc)&amp;scavChunkHasFree == 0</code></span>
<span class="codeline" id="line-1283"><code>}</code></span>
<span class="codeline" id="line-1284"><code></code></span>
<span class="codeline" id="line-1285"><code>// setEmpty clears the hasFree flag.</code></span>
<span class="codeline" id="line-1286"><code>func (sc *scavChunkFlags) setEmpty() {</code></span>
<span class="codeline" id="line-1287"><code>	*sc &amp;^= scavChunkHasFree</code></span>
<span class="codeline" id="line-1288"><code>}</code></span>
<span class="codeline" id="line-1289"><code></code></span>
<span class="codeline" id="line-1290"><code>// setNonEmpty sets the hasFree flag.</code></span>
<span class="codeline" id="line-1291"><code>func (sc *scavChunkFlags) setNonEmpty() {</code></span>
<span class="codeline" id="line-1292"><code>	*sc |= scavChunkHasFree</code></span>
<span class="codeline" id="line-1293"><code>}</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>// shouldScavenge returns true if the corresponding chunk should be interrogated</code></span>
<span class="codeline" id="line-1296"><code>// by the scavenger.</code></span>
<span class="codeline" id="line-1297"><code>func (sc scavChunkData) shouldScavenge(currGen uint32, force bool) bool {</code></span>
<span class="codeline" id="line-1298"><code>	if sc.isEmpty() {</code></span>
<span class="codeline" id="line-1299"><code>		// Nothing to scavenge.</code></span>
<span class="codeline" id="line-1300"><code>		return false</code></span>
<span class="codeline" id="line-1301"><code>	}</code></span>
<span class="codeline" id="line-1302"><code>	if force {</code></span>
<span class="codeline" id="line-1303"><code>		// We're forcing the memory to be scavenged.</code></span>
<span class="codeline" id="line-1304"><code>		return true</code></span>
<span class="codeline" id="line-1305"><code>	}</code></span>
<span class="codeline" id="line-1306"><code>	if sc.gen == currGen {</code></span>
<span class="codeline" id="line-1307"><code>		// In the current generation, if either the current or last generation</code></span>
<span class="codeline" id="line-1308"><code>		// is dense, then skip scavenging. Inverting that, we should scavenge</code></span>
<span class="codeline" id="line-1309"><code>		// if both the current and last generation were not dense.</code></span>
<span class="codeline" id="line-1310"><code>		return sc.inUse &lt; scavChunkHiOccPages &amp;&amp; sc.lastInUse &lt; scavChunkHiOccPages</code></span>
<span class="codeline" id="line-1311"><code>	}</code></span>
<span class="codeline" id="line-1312"><code>	// If we're one or more generations ahead, we know inUse represents the current</code></span>
<span class="codeline" id="line-1313"><code>	// state of the chunk, since otherwise it would've been updated already.</code></span>
<span class="codeline" id="line-1314"><code>	return sc.inUse &lt; scavChunkHiOccPages</code></span>
<span class="codeline" id="line-1315"><code>}</code></span>
<span class="codeline" id="line-1316"><code></code></span>
<span class="codeline" id="line-1317"><code>// alloc updates sc given that npages were allocated in the corresponding chunk.</code></span>
<span class="codeline" id="line-1318"><code>func (sc *scavChunkData) alloc(npages uint, newGen uint32) {</code></span>
<span class="codeline" id="line-1319"><code>	if uint(sc.inUse)+npages &gt; pallocChunkPages {</code></span>
<span class="codeline" id="line-1320"><code>		print("runtime: inUse=", sc.inUse, " npages=", npages, "\n")</code></span>
<span class="codeline" id="line-1321"><code>		throw("too many pages allocated in chunk?")</code></span>
<span class="codeline" id="line-1322"><code>	}</code></span>
<span class="codeline" id="line-1323"><code>	if sc.gen != newGen {</code></span>
<span class="codeline" id="line-1324"><code>		sc.lastInUse = sc.inUse</code></span>
<span class="codeline" id="line-1325"><code>		sc.gen = newGen</code></span>
<span class="codeline" id="line-1326"><code>	}</code></span>
<span class="codeline" id="line-1327"><code>	sc.inUse += uint16(npages)</code></span>
<span class="codeline" id="line-1328"><code>	if sc.inUse == pallocChunkPages {</code></span>
<span class="codeline" id="line-1329"><code>		// There's nothing for the scavenger to take from here.</code></span>
<span class="codeline" id="line-1330"><code>		sc.setEmpty()</code></span>
<span class="codeline" id="line-1331"><code>	}</code></span>
<span class="codeline" id="line-1332"><code>}</code></span>
<span class="codeline" id="line-1333"><code></code></span>
<span class="codeline" id="line-1334"><code>// free updates sc given that npages was freed in the corresponding chunk.</code></span>
<span class="codeline" id="line-1335"><code>func (sc *scavChunkData) free(npages uint, newGen uint32) {</code></span>
<span class="codeline" id="line-1336"><code>	if uint(sc.inUse) &lt; npages {</code></span>
<span class="codeline" id="line-1337"><code>		print("runtime: inUse=", sc.inUse, " npages=", npages, "\n")</code></span>
<span class="codeline" id="line-1338"><code>		throw("allocated pages below zero?")</code></span>
<span class="codeline" id="line-1339"><code>	}</code></span>
<span class="codeline" id="line-1340"><code>	if sc.gen != newGen {</code></span>
<span class="codeline" id="line-1341"><code>		sc.lastInUse = sc.inUse</code></span>
<span class="codeline" id="line-1342"><code>		sc.gen = newGen</code></span>
<span class="codeline" id="line-1343"><code>	}</code></span>
<span class="codeline" id="line-1344"><code>	sc.inUse -= uint16(npages)</code></span>
<span class="codeline" id="line-1345"><code>	// The scavenger can no longer be done with this chunk now that</code></span>
<span class="codeline" id="line-1346"><code>	// new memory has been freed into it.</code></span>
<span class="codeline" id="line-1347"><code>	sc.setNonEmpty()</code></span>
<span class="codeline" id="line-1348"><code>}</code></span>
<span class="codeline" id="line-1349"><code></code></span>
<span class="codeline" id="line-1350"><code>type piController struct {</code></span>
<span class="codeline" id="line-1351"><code>	kp float64 // Proportional constant.</code></span>
<span class="codeline" id="line-1352"><code>	ti float64 // Integral time constant.</code></span>
<span class="codeline" id="line-1353"><code>	tt float64 // Reset time.</code></span>
<span class="codeline" id="line-1354"><code></code></span>
<span class="codeline" id="line-1355"><code>	min, max float64 // Output boundaries.</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>	// PI controller state.</code></span>
<span class="codeline" id="line-1358"><code></code></span>
<span class="codeline" id="line-1359"><code>	errIntegral float64 // Integral of the error from t=0 to now.</code></span>
<span class="codeline" id="line-1360"><code></code></span>
<span class="codeline" id="line-1361"><code>	// Error flags.</code></span>
<span class="codeline" id="line-1362"><code>	errOverflow   bool // Set if errIntegral ever overflowed.</code></span>
<span class="codeline" id="line-1363"><code>	inputOverflow bool // Set if an operation with the input overflowed.</code></span>
<span class="codeline" id="line-1364"><code>}</code></span>
<span class="codeline" id="line-1365"><code></code></span>
<span class="codeline" id="line-1366"><code>// next provides a new sample to the controller.</code></span>
<span class="codeline" id="line-1367"><code>//</code></span>
<span class="codeline" id="line-1368"><code>// input is the sample, setpoint is the desired point, and period is how much</code></span>
<span class="codeline" id="line-1369"><code>// time (in whatever unit makes the most sense) has passed since the last sample.</code></span>
<span class="codeline" id="line-1370"><code>//</code></span>
<span class="codeline" id="line-1371"><code>// Returns a new value for the variable it's controlling, and whether the operation</code></span>
<span class="codeline" id="line-1372"><code>// completed successfully. One reason this might fail is if error has been growing</code></span>
<span class="codeline" id="line-1373"><code>// in an unbounded manner, to the point of overflow.</code></span>
<span class="codeline" id="line-1374"><code>//</code></span>
<span class="codeline" id="line-1375"><code>// In the specific case of an error overflow occurs, the errOverflow field will be</code></span>
<span class="codeline" id="line-1376"><code>// set and the rest of the controller's internal state will be fully reset.</code></span>
<span class="codeline" id="line-1377"><code>func (c *piController) next(input, setpoint, period float64) (float64, bool) {</code></span>
<span class="codeline" id="line-1378"><code>	// Compute the raw output value.</code></span>
<span class="codeline" id="line-1379"><code>	prop := c.kp * (setpoint - input)</code></span>
<span class="codeline" id="line-1380"><code>	rawOutput := prop + c.errIntegral</code></span>
<span class="codeline" id="line-1381"><code></code></span>
<span class="codeline" id="line-1382"><code>	// Clamp rawOutput into output.</code></span>
<span class="codeline" id="line-1383"><code>	output := rawOutput</code></span>
<span class="codeline" id="line-1384"><code>	if isInf(output) || isNaN(output) {</code></span>
<span class="codeline" id="line-1385"><code>		// The input had a large enough magnitude that either it was already</code></span>
<span class="codeline" id="line-1386"><code>		// overflowed, or some operation with it overflowed.</code></span>
<span class="codeline" id="line-1387"><code>		// Set a flag and reset. That's the safest thing to do.</code></span>
<span class="codeline" id="line-1388"><code>		c.reset()</code></span>
<span class="codeline" id="line-1389"><code>		c.inputOverflow = true</code></span>
<span class="codeline" id="line-1390"><code>		return c.min, false</code></span>
<span class="codeline" id="line-1391"><code>	}</code></span>
<span class="codeline" id="line-1392"><code>	if output &lt; c.min {</code></span>
<span class="codeline" id="line-1393"><code>		output = c.min</code></span>
<span class="codeline" id="line-1394"><code>	} else if output &gt; c.max {</code></span>
<span class="codeline" id="line-1395"><code>		output = c.max</code></span>
<span class="codeline" id="line-1396"><code>	}</code></span>
<span class="codeline" id="line-1397"><code></code></span>
<span class="codeline" id="line-1398"><code>	// Update the controller's state.</code></span>
<span class="codeline" id="line-1399"><code>	if c.ti != 0 &amp;&amp; c.tt != 0 {</code></span>
<span class="codeline" id="line-1400"><code>		c.errIntegral += (c.kp*period/c.ti)*(setpoint-input) + (period/c.tt)*(output-rawOutput)</code></span>
<span class="codeline" id="line-1401"><code>		if isInf(c.errIntegral) || isNaN(c.errIntegral) {</code></span>
<span class="codeline" id="line-1402"><code>			// So much error has accumulated that we managed to overflow.</code></span>
<span class="codeline" id="line-1403"><code>			// The assumptions around the controller have likely broken down.</code></span>
<span class="codeline" id="line-1404"><code>			// Set a flag and reset. That's the safest thing to do.</code></span>
<span class="codeline" id="line-1405"><code>			c.reset()</code></span>
<span class="codeline" id="line-1406"><code>			c.errOverflow = true</code></span>
<span class="codeline" id="line-1407"><code>			return c.min, false</code></span>
<span class="codeline" id="line-1408"><code>		}</code></span>
<span class="codeline" id="line-1409"><code>	}</code></span>
<span class="codeline" id="line-1410"><code>	return output, true</code></span>
<span class="codeline" id="line-1411"><code>}</code></span>
<span class="codeline" id="line-1412"><code></code></span>
<span class="codeline" id="line-1413"><code>// reset resets the controller state, except for controller error flags.</code></span>
<span class="codeline" id="line-1414"><code>func (c *piController) reset() {</code></span>
<span class="codeline" id="line-1415"><code>	c.errIntegral = 0</code></span>
<span class="codeline" id="line-1416"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>