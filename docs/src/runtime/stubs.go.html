<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: stubs.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	stubs.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"internal/abi"</code></span>
<span class="codeline" id="line-9"><code>	"unsafe"</code></span>
<span class="codeline" id="line-10"><code>)</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>// Should be a built-in for unsafe.Pointer?</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>//go:nosplit</code></span>
<span class="codeline" id="line-15"><code>func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {</code></span>
<span class="codeline" id="line-16"><code>	return unsafe.Pointer(uintptr(p) + x)</code></span>
<span class="codeline" id="line-17"><code>}</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// getg returns the pointer to the current g.</code></span>
<span class="codeline" id="line-20"><code>// The compiler rewrites calls to this function into instructions</code></span>
<span class="codeline" id="line-21"><code>// that fetch the g directly (from TLS or from the dedicated register).</code></span>
<span class="codeline" id="line-22"><code>func getg() *g</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>// mcall switches from the g to the g0 stack and invokes fn(g),</code></span>
<span class="codeline" id="line-25"><code>// where g is the goroutine that made the call.</code></span>
<span class="codeline" id="line-26"><code>// mcall saves g's current PC/SP in g-&gt;sched so that it can be restored later.</code></span>
<span class="codeline" id="line-27"><code>// It is up to fn to arrange for that later execution, typically by recording</code></span>
<span class="codeline" id="line-28"><code>// g in a data structure, causing something to call ready(g) later.</code></span>
<span class="codeline" id="line-29"><code>// mcall returns to the original goroutine g later, when g has been rescheduled.</code></span>
<span class="codeline" id="line-30"><code>// fn must not return at all; typically it ends by calling schedule, to let the m</code></span>
<span class="codeline" id="line-31"><code>// run other goroutines.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// mcall can only be called from g stacks (not g0, not gsignal).</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// This must NOT be go:noescape: if fn is a stack-allocated closure,</code></span>
<span class="codeline" id="line-36"><code>// fn puts g on a run queue, and g executes before fn returns, the</code></span>
<span class="codeline" id="line-37"><code>// closure will be invalidated while it is still executing.</code></span>
<span class="codeline" id="line-38"><code>func mcall(fn func(*g))</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>// systemstack runs fn on a system stack.</code></span>
<span class="codeline" id="line-41"><code>// If systemstack is called from the per-OS-thread (g0) stack, or</code></span>
<span class="codeline" id="line-42"><code>// if systemstack is called from the signal handling (gsignal) stack,</code></span>
<span class="codeline" id="line-43"><code>// systemstack calls fn directly and returns.</code></span>
<span class="codeline" id="line-44"><code>// Otherwise, systemstack is being called from the limited stack</code></span>
<span class="codeline" id="line-45"><code>// of an ordinary goroutine. In this case, systemstack switches</code></span>
<span class="codeline" id="line-46"><code>// to the per-OS-thread stack, calls fn, and switches back.</code></span>
<span class="codeline" id="line-47"><code>// It is common to use a func literal as the argument, in order</code></span>
<span class="codeline" id="line-48"><code>// to share inputs and outputs with the code around the call</code></span>
<span class="codeline" id="line-49"><code>// to system stack:</code></span>
<span class="codeline" id="line-50"><code>//</code></span>
<span class="codeline" id="line-51"><code>//	... set up y ...</code></span>
<span class="codeline" id="line-52"><code>//	systemstack(func() {</code></span>
<span class="codeline" id="line-53"><code>//		x = bigcall(y)</code></span>
<span class="codeline" id="line-54"><code>//	})</code></span>
<span class="codeline" id="line-55"><code>//	... use x ...</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>//go:noescape</code></span>
<span class="codeline" id="line-58"><code>func systemstack(fn func())</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>//go:nosplit</code></span>
<span class="codeline" id="line-61"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-62"><code>func badsystemstack() {</code></span>
<span class="codeline" id="line-63"><code>	writeErrStr("fatal: systemstack called from unexpected goroutine")</code></span>
<span class="codeline" id="line-64"><code>}</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// memclrNoHeapPointers clears n bytes starting at ptr.</code></span>
<span class="codeline" id="line-67"><code>//</code></span>
<span class="codeline" id="line-68"><code>// Usually you should use typedmemclr. memclrNoHeapPointers should be</code></span>
<span class="codeline" id="line-69"><code>// used only when the caller knows that *ptr contains no heap pointers</code></span>
<span class="codeline" id="line-70"><code>// because either:</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>// *ptr is initialized memory and its type is pointer-free, or</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>// *ptr is uninitialized memory (e.g., memory that's being reused</code></span>
<span class="codeline" id="line-75"><code>// for a new allocation) and hence contains only "junk".</code></span>
<span class="codeline" id="line-76"><code>//</code></span>
<span class="codeline" id="line-77"><code>// memclrNoHeapPointers ensures that if ptr is pointer-aligned, and n</code></span>
<span class="codeline" id="line-78"><code>// is a multiple of the pointer size, then any pointer-aligned,</code></span>
<span class="codeline" id="line-79"><code>// pointer-sized portion is cleared atomically. Despite the function</code></span>
<span class="codeline" id="line-80"><code>// name, this is necessary because this function is the underlying</code></span>
<span class="codeline" id="line-81"><code>// implementation of typedmemclr and memclrHasPointers. See the doc of</code></span>
<span class="codeline" id="line-82"><code>// memmove for more details.</code></span>
<span class="codeline" id="line-83"><code>//</code></span>
<span class="codeline" id="line-84"><code>// The (CPU-specific) implementations of this function are in memclr_*.s.</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>//go:noescape</code></span>
<span class="codeline" id="line-87"><code>func memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>//go:linkname reflect_memclrNoHeapPointers reflect.memclrNoHeapPointers</code></span>
<span class="codeline" id="line-90"><code>func reflect_memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr) {</code></span>
<span class="codeline" id="line-91"><code>	memclrNoHeapPointers(ptr, n)</code></span>
<span class="codeline" id="line-92"><code>}</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>// memmove copies n bytes from "from" to "to".</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// memmove ensures that any pointer in "from" is written to "to" with</code></span>
<span class="codeline" id="line-97"><code>// an indivisible write, so that racy reads cannot observe a</code></span>
<span class="codeline" id="line-98"><code>// half-written pointer. This is necessary to prevent the garbage</code></span>
<span class="codeline" id="line-99"><code>// collector from observing invalid pointers, and differs from memmove</code></span>
<span class="codeline" id="line-100"><code>// in unmanaged languages. However, memmove is only required to do</code></span>
<span class="codeline" id="line-101"><code>// this if "from" and "to" may contain pointers, which can only be the</code></span>
<span class="codeline" id="line-102"><code>// case if "from", "to", and "n" are all be word-aligned.</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>// Implementations are in memmove_*.s.</code></span>
<span class="codeline" id="line-105"><code>//</code></span>
<span class="codeline" id="line-106"><code>//go:noescape</code></span>
<span class="codeline" id="line-107"><code>func memmove(to, from unsafe.Pointer, n uintptr)</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// Outside assembly calls memmove. Make sure it has ABI wrappers.</code></span>
<span class="codeline" id="line-110"><code>//</code></span>
<span class="codeline" id="line-111"><code>//go:linkname memmove</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>//go:linkname reflect_memmove reflect.memmove</code></span>
<span class="codeline" id="line-114"><code>func reflect_memmove(to, from unsafe.Pointer, n uintptr) {</code></span>
<span class="codeline" id="line-115"><code>	memmove(to, from, n)</code></span>
<span class="codeline" id="line-116"><code>}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>// exported value for testing</code></span>
<span class="codeline" id="line-119"><code>const hashLoad = float32(loadFactorNum) / float32(loadFactorDen)</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>// in internal/bytealg/equal_*.s</code></span>
<span class="codeline" id="line-122"><code>//</code></span>
<span class="codeline" id="line-123"><code>//go:noescape</code></span>
<span class="codeline" id="line-124"><code>func memequal(a, b unsafe.Pointer, size uintptr) bool</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>// noescape hides a pointer from escape analysis.  noescape is</code></span>
<span class="codeline" id="line-127"><code>// the identity function but escape analysis doesn't think the</code></span>
<span class="codeline" id="line-128"><code>// output depends on the input.  noescape is inlined and currently</code></span>
<span class="codeline" id="line-129"><code>// compiles down to zero instructions.</code></span>
<span class="codeline" id="line-130"><code>// USE CAREFULLY!</code></span>
<span class="codeline" id="line-131"><code>//</code></span>
<span class="codeline" id="line-132"><code>//go:nosplit</code></span>
<span class="codeline" id="line-133"><code>func noescape(p unsafe.Pointer) unsafe.Pointer {</code></span>
<span class="codeline" id="line-134"><code>	x := uintptr(p)</code></span>
<span class="codeline" id="line-135"><code>	return unsafe.Pointer(x ^ 0)</code></span>
<span class="codeline" id="line-136"><code>}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>// noEscapePtr hides a pointer from escape analysis. See noescape.</code></span>
<span class="codeline" id="line-139"><code>// USE CAREFULLY!</code></span>
<span class="codeline" id="line-140"><code>//</code></span>
<span class="codeline" id="line-141"><code>//go:nosplit</code></span>
<span class="codeline" id="line-142"><code>func noEscapePtr[T any](p *T) *T {</code></span>
<span class="codeline" id="line-143"><code>	x := uintptr(unsafe.Pointer(p))</code></span>
<span class="codeline" id="line-144"><code>	return (*T)(unsafe.Pointer(x ^ 0))</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// Not all cgocallback frames are actually cgocallback,</code></span>
<span class="codeline" id="line-148"><code>// so not all have these arguments. Mark them uintptr so that the GC</code></span>
<span class="codeline" id="line-149"><code>// does not misinterpret memory when the arguments are not present.</code></span>
<span class="codeline" id="line-150"><code>// cgocallback is not called from Go, only from crosscall2.</code></span>
<span class="codeline" id="line-151"><code>// This in turn calls cgocallbackg, which is where we'll find</code></span>
<span class="codeline" id="line-152"><code>// pointer-declared arguments.</code></span>
<span class="codeline" id="line-153"><code>//</code></span>
<span class="codeline" id="line-154"><code>// When fn is nil (frame is saved g), call dropm instead,</code></span>
<span class="codeline" id="line-155"><code>// this is used when the C thread is exiting.</code></span>
<span class="codeline" id="line-156"><code>func cgocallback(fn, frame, ctxt uintptr)</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>func gogo(buf *gobuf)</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>func asminit()</code></span>
<span class="codeline" id="line-161"><code>func setg(gg *g)</code></span>
<span class="codeline" id="line-162"><code>func breakpoint()</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>// reflectcall calls fn with arguments described by stackArgs, stackArgsSize,</code></span>
<span class="codeline" id="line-165"><code>// frameSize, and regArgs.</code></span>
<span class="codeline" id="line-166"><code>//</code></span>
<span class="codeline" id="line-167"><code>// Arguments passed on the stack and space for return values passed on the stack</code></span>
<span class="codeline" id="line-168"><code>// must be laid out at the space pointed to by stackArgs (with total length</code></span>
<span class="codeline" id="line-169"><code>// stackArgsSize) according to the ABI.</code></span>
<span class="codeline" id="line-170"><code>//</code></span>
<span class="codeline" id="line-171"><code>// stackRetOffset must be some value &lt;= stackArgsSize that indicates the</code></span>
<span class="codeline" id="line-172"><code>// offset within stackArgs where the return value space begins.</code></span>
<span class="codeline" id="line-173"><code>//</code></span>
<span class="codeline" id="line-174"><code>// frameSize is the total size of the argument frame at stackArgs and must</code></span>
<span class="codeline" id="line-175"><code>// therefore be &gt;= stackArgsSize. It must include additional space for spilling</code></span>
<span class="codeline" id="line-176"><code>// register arguments for stack growth and preemption.</code></span>
<span class="codeline" id="line-177"><code>//</code></span>
<span class="codeline" id="line-178"><code>// TODO(mknyszek): Once we don't need the additional spill space, remove frameSize,</code></span>
<span class="codeline" id="line-179"><code>// since frameSize will be redundant with stackArgsSize.</code></span>
<span class="codeline" id="line-180"><code>//</code></span>
<span class="codeline" id="line-181"><code>// Arguments passed in registers must be laid out in regArgs according to the ABI.</code></span>
<span class="codeline" id="line-182"><code>// regArgs will hold any return values passed in registers after the call.</code></span>
<span class="codeline" id="line-183"><code>//</code></span>
<span class="codeline" id="line-184"><code>// reflectcall copies stack arguments from stackArgs to the goroutine stack, and</code></span>
<span class="codeline" id="line-185"><code>// then copies back stackArgsSize-stackRetOffset bytes back to the return space</code></span>
<span class="codeline" id="line-186"><code>// in stackArgs once fn has completed. It also "unspills" argument registers from</code></span>
<span class="codeline" id="line-187"><code>// regArgs before calling fn, and spills them back into regArgs immediately</code></span>
<span class="codeline" id="line-188"><code>// following the call to fn. If there are results being returned on the stack,</code></span>
<span class="codeline" id="line-189"><code>// the caller should pass the argument frame type as stackArgsType so that</code></span>
<span class="codeline" id="line-190"><code>// reflectcall can execute appropriate write barriers during the copy.</code></span>
<span class="codeline" id="line-191"><code>//</code></span>
<span class="codeline" id="line-192"><code>// reflectcall expects regArgs.ReturnIsPtr to be populated indicating which</code></span>
<span class="codeline" id="line-193"><code>// registers on the return path will contain Go pointers. It will then store</code></span>
<span class="codeline" id="line-194"><code>// these pointers in regArgs.Ptrs such that they are visible to the GC.</code></span>
<span class="codeline" id="line-195"><code>//</code></span>
<span class="codeline" id="line-196"><code>// Package reflect passes a frame type. In package runtime, there is only</code></span>
<span class="codeline" id="line-197"><code>// one call that copies results back, in callbackWrap in syscall_windows.go, and it</code></span>
<span class="codeline" id="line-198"><code>// does NOT pass a frame type, meaning there are no write barriers invoked. See that</code></span>
<span class="codeline" id="line-199"><code>// call site for justification.</code></span>
<span class="codeline" id="line-200"><code>//</code></span>
<span class="codeline" id="line-201"><code>// Package reflect accesses this symbol through a linkname.</code></span>
<span class="codeline" id="line-202"><code>//</code></span>
<span class="codeline" id="line-203"><code>// Arguments passed through to reflectcall do not escape. The type is used</code></span>
<span class="codeline" id="line-204"><code>// only in a very limited callee of reflectcall, the stackArgs are copied, and</code></span>
<span class="codeline" id="line-205"><code>// regArgs is only used in the reflectcall frame.</code></span>
<span class="codeline" id="line-206"><code>//</code></span>
<span class="codeline" id="line-207"><code>//go:noescape</code></span>
<span class="codeline" id="line-208"><code>func reflectcall(stackArgsType *_type, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>func procyield(cycles uint32)</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>type neverCallThisFunction struct{}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// goexit is the return stub at the top of every goroutine call stack.</code></span>
<span class="codeline" id="line-215"><code>// Each goroutine stack is constructed as if goexit called the</code></span>
<span class="codeline" id="line-216"><code>// goroutine's entry point function, so that when the entry point</code></span>
<span class="codeline" id="line-217"><code>// function returns, it will return to goexit, which will call goexit1</code></span>
<span class="codeline" id="line-218"><code>// to perform the actual exit.</code></span>
<span class="codeline" id="line-219"><code>//</code></span>
<span class="codeline" id="line-220"><code>// This function must never be called directly. Call goexit1 instead.</code></span>
<span class="codeline" id="line-221"><code>// gentraceback assumes that goexit terminates the stack. A direct</code></span>
<span class="codeline" id="line-222"><code>// call on the stack will cause gentraceback to stop walking the stack</code></span>
<span class="codeline" id="line-223"><code>// prematurely and if there is leftover state it may panic.</code></span>
<span class="codeline" id="line-224"><code>func goexit(neverCallThisFunction)</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// publicationBarrier performs a store/store barrier (a "publication"</code></span>
<span class="codeline" id="line-227"><code>// or "export" barrier). Some form of synchronization is required</code></span>
<span class="codeline" id="line-228"><code>// between initializing an object and making that object accessible to</code></span>
<span class="codeline" id="line-229"><code>// another processor. Without synchronization, the initialization</code></span>
<span class="codeline" id="line-230"><code>// writes and the "publication" write may be reordered, allowing the</code></span>
<span class="codeline" id="line-231"><code>// other processor to follow the pointer and observe an uninitialized</code></span>
<span class="codeline" id="line-232"><code>// object. In general, higher-level synchronization should be used,</code></span>
<span class="codeline" id="line-233"><code>// such as locking or an atomic pointer write. publicationBarrier is</code></span>
<span class="codeline" id="line-234"><code>// for when those aren't an option, such as in the implementation of</code></span>
<span class="codeline" id="line-235"><code>// the memory manager.</code></span>
<span class="codeline" id="line-236"><code>//</code></span>
<span class="codeline" id="line-237"><code>// There's no corresponding barrier for the read side because the read</code></span>
<span class="codeline" id="line-238"><code>// side naturally has a data dependency order. All architectures that</code></span>
<span class="codeline" id="line-239"><code>// Go supports or seems likely to ever support automatically enforce</code></span>
<span class="codeline" id="line-240"><code>// data dependency ordering.</code></span>
<span class="codeline" id="line-241"><code>func publicationBarrier()</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>// getcallerpc returns the program counter (PC) of its caller's caller.</code></span>
<span class="codeline" id="line-244"><code>// getcallersp returns the stack pointer (SP) of its caller's caller.</code></span>
<span class="codeline" id="line-245"><code>// The implementation may be a compiler intrinsic; there is not</code></span>
<span class="codeline" id="line-246"><code>// necessarily code implementing this on every platform.</code></span>
<span class="codeline" id="line-247"><code>//</code></span>
<span class="codeline" id="line-248"><code>// For example:</code></span>
<span class="codeline" id="line-249"><code>//</code></span>
<span class="codeline" id="line-250"><code>//	func f(arg1, arg2, arg3 int) {</code></span>
<span class="codeline" id="line-251"><code>//		pc := getcallerpc()</code></span>
<span class="codeline" id="line-252"><code>//		sp := getcallersp()</code></span>
<span class="codeline" id="line-253"><code>//	}</code></span>
<span class="codeline" id="line-254"><code>//</code></span>
<span class="codeline" id="line-255"><code>// These two lines find the PC and SP immediately following</code></span>
<span class="codeline" id="line-256"><code>// the call to f (where f will return).</code></span>
<span class="codeline" id="line-257"><code>//</code></span>
<span class="codeline" id="line-258"><code>// The call to getcallerpc and getcallersp must be done in the</code></span>
<span class="codeline" id="line-259"><code>// frame being asked about.</code></span>
<span class="codeline" id="line-260"><code>//</code></span>
<span class="codeline" id="line-261"><code>// The result of getcallersp is correct at the time of the return,</code></span>
<span class="codeline" id="line-262"><code>// but it may be invalidated by any subsequent call to a function</code></span>
<span class="codeline" id="line-263"><code>// that might relocate the stack in order to grow or shrink it.</code></span>
<span class="codeline" id="line-264"><code>// A general rule is that the result of getcallersp should be used</code></span>
<span class="codeline" id="line-265"><code>// immediately and can only be passed to nosplit functions.</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>//go:noescape</code></span>
<span class="codeline" id="line-268"><code>func getcallerpc() uintptr</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>//go:noescape</code></span>
<span class="codeline" id="line-271"><code>func getcallersp() uintptr // implemented as an intrinsic on all platforms</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>// getclosureptr returns the pointer to the current closure.</code></span>
<span class="codeline" id="line-274"><code>// getclosureptr can only be used in an assignment statement</code></span>
<span class="codeline" id="line-275"><code>// at the entry of a function. Moreover, go:nosplit directive</code></span>
<span class="codeline" id="line-276"><code>// must be specified at the declaration of caller function,</code></span>
<span class="codeline" id="line-277"><code>// so that the function prolog does not clobber the closure register.</code></span>
<span class="codeline" id="line-278"><code>// for example:</code></span>
<span class="codeline" id="line-279"><code>//</code></span>
<span class="codeline" id="line-280"><code>//	//go:nosplit</code></span>
<span class="codeline" id="line-281"><code>//	func f(arg1, arg2, arg3 int) {</code></span>
<span class="codeline" id="line-282"><code>//		dx := getclosureptr()</code></span>
<span class="codeline" id="line-283"><code>//	}</code></span>
<span class="codeline" id="line-284"><code>//</code></span>
<span class="codeline" id="line-285"><code>// The compiler rewrites calls to this function into instructions that fetch the</code></span>
<span class="codeline" id="line-286"><code>// pointer from a well-known register (DX on x86 architecture, etc.) directly.</code></span>
<span class="codeline" id="line-287"><code>//</code></span>
<span class="codeline" id="line-288"><code>// WARNING: PGO-based devirtualization cannot detect that caller of</code></span>
<span class="codeline" id="line-289"><code>// getclosureptr require closure context, and thus must maintain a list of</code></span>
<span class="codeline" id="line-290"><code>// these functions, which is in</code></span>
<span class="codeline" id="line-291"><code>// cmd/compile/internal/devirtualize/pgo.maybeDevirtualizeFunctionCall.</code></span>
<span class="codeline" id="line-292"><code>func getclosureptr() uintptr</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>//go:noescape</code></span>
<span class="codeline" id="line-295"><code>func asmcgocall(fn, arg unsafe.Pointer) int32</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>func morestack()</code></span>
<span class="codeline" id="line-298"><code>func morestack_noctxt()</code></span>
<span class="codeline" id="line-299"><code>func rt0_go()</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// return0 is a stub used to return 0 from deferproc.</code></span>
<span class="codeline" id="line-302"><code>// It is called at the very end of deferproc to signal</code></span>
<span class="codeline" id="line-303"><code>// the calling Go function that it should not jump</code></span>
<span class="codeline" id="line-304"><code>// to deferreturn.</code></span>
<span class="codeline" id="line-305"><code>// in asm_*.s</code></span>
<span class="codeline" id="line-306"><code>func return0()</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>// in asm_*.s</code></span>
<span class="codeline" id="line-309"><code>// not called directly; definitions here supply type information for traceback.</code></span>
<span class="codeline" id="line-310"><code>// These must have the same signature (arg pointer map) as reflectcall.</code></span>
<span class="codeline" id="line-311"><code>func call16(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-312"><code>func call32(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-313"><code>func call64(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-314"><code>func call128(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-315"><code>func call256(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-316"><code>func call512(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-317"><code>func call1024(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-318"><code>func call2048(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-319"><code>func call4096(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-320"><code>func call8192(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-321"><code>func call16384(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-322"><code>func call32768(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-323"><code>func call65536(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-324"><code>func call131072(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-325"><code>func call262144(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-326"><code>func call524288(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-327"><code>func call1048576(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-328"><code>func call2097152(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-329"><code>func call4194304(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-330"><code>func call8388608(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-331"><code>func call16777216(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-332"><code>func call33554432(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-333"><code>func call67108864(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-334"><code>func call134217728(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-335"><code>func call268435456(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-336"><code>func call536870912(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-337"><code>func call1073741824(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>func systemstack_switch()</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>// alignUp rounds n up to a multiple of a. a must be a power of 2.</code></span>
<span class="codeline" id="line-342"><code>//</code></span>
<span class="codeline" id="line-343"><code>//go:nosplit</code></span>
<span class="codeline" id="line-344"><code>func alignUp(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-345"><code>	return (n + a - 1) &amp;^ (a - 1)</code></span>
<span class="codeline" id="line-346"><code>}</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>// alignDown rounds n down to a multiple of a. a must be a power of 2.</code></span>
<span class="codeline" id="line-349"><code>//</code></span>
<span class="codeline" id="line-350"><code>//go:nosplit</code></span>
<span class="codeline" id="line-351"><code>func alignDown(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-352"><code>	return n &amp;^ (a - 1)</code></span>
<span class="codeline" id="line-353"><code>}</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>// divRoundUp returns ceil(n / a).</code></span>
<span class="codeline" id="line-356"><code>func divRoundUp(n, a uintptr) uintptr {</code></span>
<span class="codeline" id="line-357"><code>	// a is generally a power of two. This will get inlined and</code></span>
<span class="codeline" id="line-358"><code>	// the compiler will optimize the division.</code></span>
<span class="codeline" id="line-359"><code>	return (n + a - 1) / a</code></span>
<span class="codeline" id="line-360"><code>}</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>// checkASM reports whether assembly runtime checks have passed.</code></span>
<span class="codeline" id="line-363"><code>func checkASM() bool</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>func memequal_varlen(a, b unsafe.Pointer) bool</code></span>
<span class="codeline" id="line-366"><code></code></span>
<span class="codeline" id="line-367"><code>// bool2int returns 0 if x is false or 1 if x is true.</code></span>
<span class="codeline" id="line-368"><code>func bool2int(x bool) int {</code></span>
<span class="codeline" id="line-369"><code>	// Avoid branches. In the SSA compiler, this compiles to</code></span>
<span class="codeline" id="line-370"><code>	// exactly what you would want it to.</code></span>
<span class="codeline" id="line-371"><code>	return int(*(*uint8)(unsafe.Pointer(&amp;x)))</code></span>
<span class="codeline" id="line-372"><code>}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>// abort crashes the runtime in situations where even throw might not</code></span>
<span class="codeline" id="line-375"><code>// work. In general it should do something a debugger will recognize</code></span>
<span class="codeline" id="line-376"><code>// (e.g., an INT3 on x86). A crash in abort is recognized by the</code></span>
<span class="codeline" id="line-377"><code>// signal handler, which will attempt to tear down the runtime</code></span>
<span class="codeline" id="line-378"><code>// immediately.</code></span>
<span class="codeline" id="line-379"><code>func abort()</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>// Called from compiled code; declared for vet; do NOT call from Go.</code></span>
<span class="codeline" id="line-382"><code>func gcWriteBarrier1()</code></span>
<span class="codeline" id="line-383"><code>func gcWriteBarrier2()</code></span>
<span class="codeline" id="line-384"><code>func gcWriteBarrier3()</code></span>
<span class="codeline" id="line-385"><code>func gcWriteBarrier4()</code></span>
<span class="codeline" id="line-386"><code>func gcWriteBarrier5()</code></span>
<span class="codeline" id="line-387"><code>func gcWriteBarrier6()</code></span>
<span class="codeline" id="line-388"><code>func gcWriteBarrier7()</code></span>
<span class="codeline" id="line-389"><code>func gcWriteBarrier8()</code></span>
<span class="codeline" id="line-390"><code>func duffzero()</code></span>
<span class="codeline" id="line-391"><code>func duffcopy()</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>// Called from linker-generated .initarray; declared for go vet; do NOT call from Go.</code></span>
<span class="codeline" id="line-394"><code>func addmoduledata()</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>// Injected by the signal handler for panicking signals.</code></span>
<span class="codeline" id="line-397"><code>// Initializes any registers that have fixed meaning at calls but</code></span>
<span class="codeline" id="line-398"><code>// are scratch in bodies and calls sigpanic.</code></span>
<span class="codeline" id="line-399"><code>// On many platforms it just jumps to sigpanic.</code></span>
<span class="codeline" id="line-400"><code>func sigpanic0()</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>// intArgRegs is used by the various register assignment</code></span>
<span class="codeline" id="line-403"><code>// algorithm implementations in the runtime. These include:.</code></span>
<span class="codeline" id="line-404"><code>// - Finalizers (mfinal.go)</code></span>
<span class="codeline" id="line-405"><code>// - Windows callbacks (syscall_windows.go)</code></span>
<span class="codeline" id="line-406"><code>//</code></span>
<span class="codeline" id="line-407"><code>// Both are stripped-down versions of the algorithm since they</code></span>
<span class="codeline" id="line-408"><code>// only have to deal with a subset of cases (finalizers only</code></span>
<span class="codeline" id="line-409"><code>// take a pointer or interface argument, Go Windows callbacks</code></span>
<span class="codeline" id="line-410"><code>// don't support floating point).</code></span>
<span class="codeline" id="line-411"><code>//</code></span>
<span class="codeline" id="line-412"><code>// It should be modified with care and are generally only</code></span>
<span class="codeline" id="line-413"><code>// modified when testing this package.</code></span>
<span class="codeline" id="line-414"><code>//</code></span>
<span class="codeline" id="line-415"><code>// It should never be set higher than its internal/abi</code></span>
<span class="codeline" id="line-416"><code>// constant counterparts, because the system relies on a</code></span>
<span class="codeline" id="line-417"><code>// structure that is at least large enough to hold the</code></span>
<span class="codeline" id="line-418"><code>// registers the system supports.</code></span>
<span class="codeline" id="line-419"><code>//</code></span>
<span class="codeline" id="line-420"><code>// Protected by finlock.</code></span>
<span class="codeline" id="line-421"><code>var intArgRegs = abi.IntArgRegs</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>