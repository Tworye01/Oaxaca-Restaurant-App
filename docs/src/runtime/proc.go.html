<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: proc.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	proc.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"internal/abi"</code></span>
<span class="codeline" id="line-9"><code>	"internal/cpu"</code></span>
<span class="codeline" id="line-10"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-11"><code>	"internal/goexperiment"</code></span>
<span class="codeline" id="line-12"><code>	"internal/goos"</code></span>
<span class="codeline" id="line-13"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-14"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-15"><code>	"unsafe"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// set using cmd/go/internal/modload.ModInfoProg</code></span>
<span class="codeline" id="line-19"><code>var modinfo string</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>// Goroutine scheduler</code></span>
<span class="codeline" id="line-22"><code>// The scheduler's job is to distribute ready-to-run goroutines over worker threads.</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>// The main concepts are:</code></span>
<span class="codeline" id="line-25"><code>// G - goroutine.</code></span>
<span class="codeline" id="line-26"><code>// M - worker thread, or machine.</code></span>
<span class="codeline" id="line-27"><code>// P - processor, a resource that is required to execute Go code.</code></span>
<span class="codeline" id="line-28"><code>//     M must have an associated P to execute Go code, however it can be</code></span>
<span class="codeline" id="line-29"><code>//     blocked or in a syscall w/o an associated P.</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// Design doc at https://golang.org/s/go11sched.</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>// Worker thread parking/unparking.</code></span>
<span class="codeline" id="line-34"><code>// We need to balance between keeping enough running worker threads to utilize</code></span>
<span class="codeline" id="line-35"><code>// available hardware parallelism and parking excessive running worker threads</code></span>
<span class="codeline" id="line-36"><code>// to conserve CPU resources and power. This is not simple for two reasons:</code></span>
<span class="codeline" id="line-37"><code>// (1) scheduler state is intentionally distributed (in particular, per-P work</code></span>
<span class="codeline" id="line-38"><code>// queues), so it is not possible to compute global predicates on fast paths;</code></span>
<span class="codeline" id="line-39"><code>// (2) for optimal thread management we would need to know the future (don't park</code></span>
<span class="codeline" id="line-40"><code>// a worker thread when a new goroutine will be readied in near future).</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// Three rejected approaches that would work badly:</code></span>
<span class="codeline" id="line-43"><code>// 1. Centralize all scheduler state (would inhibit scalability).</code></span>
<span class="codeline" id="line-44"><code>// 2. Direct goroutine handoff. That is, when we ready a new goroutine and there</code></span>
<span class="codeline" id="line-45"><code>//    is a spare P, unpark a thread and handoff it the thread and the goroutine.</code></span>
<span class="codeline" id="line-46"><code>//    This would lead to thread state thrashing, as the thread that readied the</code></span>
<span class="codeline" id="line-47"><code>//    goroutine can be out of work the very next moment, we will need to park it.</code></span>
<span class="codeline" id="line-48"><code>//    Also, it would destroy locality of computation as we want to preserve</code></span>
<span class="codeline" id="line-49"><code>//    dependent goroutines on the same thread; and introduce additional latency.</code></span>
<span class="codeline" id="line-50"><code>// 3. Unpark an additional thread whenever we ready a goroutine and there is an</code></span>
<span class="codeline" id="line-51"><code>//    idle P, but don't do handoff. This would lead to excessive thread parking/</code></span>
<span class="codeline" id="line-52"><code>//    unparking as the additional threads will instantly park without discovering</code></span>
<span class="codeline" id="line-53"><code>//    any work to do.</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// The current approach:</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>// This approach applies to three primary sources of potential work: readying a</code></span>
<span class="codeline" id="line-58"><code>// goroutine, new/modified-earlier timers, and idle-priority GC. See below for</code></span>
<span class="codeline" id="line-59"><code>// additional details.</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// We unpark an additional thread when we submit work if (this is wakep()):</code></span>
<span class="codeline" id="line-62"><code>// 1. There is an idle P, and</code></span>
<span class="codeline" id="line-63"><code>// 2. There are no "spinning" worker threads.</code></span>
<span class="codeline" id="line-64"><code>//</code></span>
<span class="codeline" id="line-65"><code>// A worker thread is considered spinning if it is out of local work and did</code></span>
<span class="codeline" id="line-66"><code>// not find work in the global run queue or netpoller; the spinning state is</code></span>
<span class="codeline" id="line-67"><code>// denoted in m.spinning and in sched.nmspinning. Threads unparked this way are</code></span>
<span class="codeline" id="line-68"><code>// also considered spinning; we don't do goroutine handoff so such threads are</code></span>
<span class="codeline" id="line-69"><code>// out of work initially. Spinning threads spin on looking for work in per-P</code></span>
<span class="codeline" id="line-70"><code>// run queues and timer heaps or from the GC before parking. If a spinning</code></span>
<span class="codeline" id="line-71"><code>// thread finds work it takes itself out of the spinning state and proceeds to</code></span>
<span class="codeline" id="line-72"><code>// execution. If it does not find work it takes itself out of the spinning</code></span>
<span class="codeline" id="line-73"><code>// state and then parks.</code></span>
<span class="codeline" id="line-74"><code>//</code></span>
<span class="codeline" id="line-75"><code>// If there is at least one spinning thread (sched.nmspinning&gt;1), we don't</code></span>
<span class="codeline" id="line-76"><code>// unpark new threads when submitting work. To compensate for that, if the last</code></span>
<span class="codeline" id="line-77"><code>// spinning thread finds work and stops spinning, it must unpark a new spinning</code></span>
<span class="codeline" id="line-78"><code>// thread. This approach smooths out unjustified spikes of thread unparking,</code></span>
<span class="codeline" id="line-79"><code>// but at the same time guarantees eventual maximal CPU parallelism</code></span>
<span class="codeline" id="line-80"><code>// utilization.</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// The main implementation complication is that we need to be very careful</code></span>
<span class="codeline" id="line-83"><code>// during spinning-&gt;non-spinning thread transition. This transition can race</code></span>
<span class="codeline" id="line-84"><code>// with submission of new work, and either one part or another needs to unpark</code></span>
<span class="codeline" id="line-85"><code>// another worker thread. If they both fail to do that, we can end up with</code></span>
<span class="codeline" id="line-86"><code>// semi-persistent CPU underutilization.</code></span>
<span class="codeline" id="line-87"><code>//</code></span>
<span class="codeline" id="line-88"><code>// The general pattern for submission is:</code></span>
<span class="codeline" id="line-89"><code>// 1. Submit work to the local or global run queue, timer heap, or GC state.</code></span>
<span class="codeline" id="line-90"><code>// 2. #StoreLoad-style memory barrier.</code></span>
<span class="codeline" id="line-91"><code>// 3. Check sched.nmspinning.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// The general pattern for spinning-&gt;non-spinning transition is:</code></span>
<span class="codeline" id="line-94"><code>// 1. Decrement nmspinning.</code></span>
<span class="codeline" id="line-95"><code>// 2. #StoreLoad-style memory barrier.</code></span>
<span class="codeline" id="line-96"><code>// 3. Check all per-P work queues and GC for new work.</code></span>
<span class="codeline" id="line-97"><code>//</code></span>
<span class="codeline" id="line-98"><code>// Note that all this complexity does not apply to global run queue as we are</code></span>
<span class="codeline" id="line-99"><code>// not sloppy about thread unparking when submitting to global queue. Also see</code></span>
<span class="codeline" id="line-100"><code>// comments for nmspinning manipulation.</code></span>
<span class="codeline" id="line-101"><code>//</code></span>
<span class="codeline" id="line-102"><code>// How these different sources of work behave varies, though it doesn't affect</code></span>
<span class="codeline" id="line-103"><code>// the synchronization approach:</code></span>
<span class="codeline" id="line-104"><code>// * Ready goroutine: this is an obvious source of work; the goroutine is</code></span>
<span class="codeline" id="line-105"><code>//   immediately ready and must run on some thread eventually.</code></span>
<span class="codeline" id="line-106"><code>// * New/modified-earlier timer: The current timer implementation (see time.go)</code></span>
<span class="codeline" id="line-107"><code>//   uses netpoll in a thread with no work available to wait for the soonest</code></span>
<span class="codeline" id="line-108"><code>//   timer. If there is no thread waiting, we want a new spinning thread to go</code></span>
<span class="codeline" id="line-109"><code>//   wait.</code></span>
<span class="codeline" id="line-110"><code>// * Idle-priority GC: The GC wakes a stopped idle thread to contribute to</code></span>
<span class="codeline" id="line-111"><code>//   background GC work (note: currently disabled per golang.org/issue/19112).</code></span>
<span class="codeline" id="line-112"><code>//   Also see golang.org/issue/44313, as this should be extended to all GC</code></span>
<span class="codeline" id="line-113"><code>//   workers.</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>var (</code></span>
<span class="codeline" id="line-116"><code>	m0           m</code></span>
<span class="codeline" id="line-117"><code>	g0           g</code></span>
<span class="codeline" id="line-118"><code>	mcache0      *mcache</code></span>
<span class="codeline" id="line-119"><code>	raceprocctx0 uintptr</code></span>
<span class="codeline" id="line-120"><code>	raceFiniLock mutex</code></span>
<span class="codeline" id="line-121"><code>)</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// This slice records the initializing tasks that need to be</code></span>
<span class="codeline" id="line-124"><code>// done to start up the runtime. It is built by the linker.</code></span>
<span class="codeline" id="line-125"><code>var runtime_inittasks []*initTask</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// main_init_done is a signal used by cgocallbackg that initialization</code></span>
<span class="codeline" id="line-128"><code>// has been completed. It is made before _cgo_notify_runtime_init_done,</code></span>
<span class="codeline" id="line-129"><code>// so all cgo calls can rely on it existing. When main_init is complete,</code></span>
<span class="codeline" id="line-130"><code>// it is closed, meaning cgocallbackg can reliably receive from it.</code></span>
<span class="codeline" id="line-131"><code>var main_init_done chan bool</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>//go:linkname main_main main.main</code></span>
<span class="codeline" id="line-134"><code>func main_main()</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// mainStarted indicates that the main M has started.</code></span>
<span class="codeline" id="line-137"><code>var mainStarted bool</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// runtimeInitTime is the nanotime() at which the runtime started.</code></span>
<span class="codeline" id="line-140"><code>var runtimeInitTime int64</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>// Value to use for signal mask for newly created M's.</code></span>
<span class="codeline" id="line-143"><code>var initSigmask sigset</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// The main goroutine.</code></span>
<span class="codeline" id="line-146"><code>func main() {</code></span>
<span class="codeline" id="line-147"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>	// Racectx of m0-&gt;g0 is used only as the parent of the main goroutine.</code></span>
<span class="codeline" id="line-150"><code>	// It must not be used for anything else.</code></span>
<span class="codeline" id="line-151"><code>	mp.g0.racectx = 0</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>	// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.</code></span>
<span class="codeline" id="line-154"><code>	// Using decimal instead of binary GB and MB because</code></span>
<span class="codeline" id="line-155"><code>	// they look nicer in the stack overflow failure message.</code></span>
<span class="codeline" id="line-156"><code>	if goarch.PtrSize == 8 {</code></span>
<span class="codeline" id="line-157"><code>		maxstacksize = 1000000000</code></span>
<span class="codeline" id="line-158"><code>	} else {</code></span>
<span class="codeline" id="line-159"><code>		maxstacksize = 250000000</code></span>
<span class="codeline" id="line-160"><code>	}</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>	// An upper limit for max stack size. Used to avoid random crashes</code></span>
<span class="codeline" id="line-163"><code>	// after calling SetMaxStack and trying to allocate a stack that is too big,</code></span>
<span class="codeline" id="line-164"><code>	// since stackalloc works with 32-bit sizes.</code></span>
<span class="codeline" id="line-165"><code>	maxstackceiling = 2 * maxstacksize</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>	// Allow newproc to start new Ms.</code></span>
<span class="codeline" id="line-168"><code>	mainStarted = true</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>	if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon</code></span>
<span class="codeline" id="line-171"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-172"><code>			newm(sysmon, nil, -1)</code></span>
<span class="codeline" id="line-173"><code>		})</code></span>
<span class="codeline" id="line-174"><code>	}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>	// Lock the main goroutine onto this, the main OS thread,</code></span>
<span class="codeline" id="line-177"><code>	// during initialization. Most programs won't care, but a few</code></span>
<span class="codeline" id="line-178"><code>	// do require certain calls to be made by the main thread.</code></span>
<span class="codeline" id="line-179"><code>	// Those can arrange for main.main to run in the main thread</code></span>
<span class="codeline" id="line-180"><code>	// by calling runtime.LockOSThread during initialization</code></span>
<span class="codeline" id="line-181"><code>	// to preserve the lock.</code></span>
<span class="codeline" id="line-182"><code>	lockOSThread()</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	if mp != &amp;m0 {</code></span>
<span class="codeline" id="line-185"><code>		throw("runtime.main not on m0")</code></span>
<span class="codeline" id="line-186"><code>	}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>	// Record when the world started.</code></span>
<span class="codeline" id="line-189"><code>	// Must be before doInit for tracing init.</code></span>
<span class="codeline" id="line-190"><code>	runtimeInitTime = nanotime()</code></span>
<span class="codeline" id="line-191"><code>	if runtimeInitTime == 0 {</code></span>
<span class="codeline" id="line-192"><code>		throw("nanotime returning zero")</code></span>
<span class="codeline" id="line-193"><code>	}</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	if debug.inittrace != 0 {</code></span>
<span class="codeline" id="line-196"><code>		inittrace.id = getg().goid</code></span>
<span class="codeline" id="line-197"><code>		inittrace.active = true</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>	doInit(runtime_inittasks) // Must be before defer.</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>	// Defer unlock so that runtime.Goexit during init does the unlock too.</code></span>
<span class="codeline" id="line-203"><code>	needUnlock := true</code></span>
<span class="codeline" id="line-204"><code>	defer func() {</code></span>
<span class="codeline" id="line-205"><code>		if needUnlock {</code></span>
<span class="codeline" id="line-206"><code>			unlockOSThread()</code></span>
<span class="codeline" id="line-207"><code>		}</code></span>
<span class="codeline" id="line-208"><code>	}()</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>	gcenable()</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	main_init_done = make(chan bool)</code></span>
<span class="codeline" id="line-213"><code>	if iscgo {</code></span>
<span class="codeline" id="line-214"><code>		if _cgo_pthread_key_created == nil {</code></span>
<span class="codeline" id="line-215"><code>			throw("_cgo_pthread_key_created missing")</code></span>
<span class="codeline" id="line-216"><code>		}</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>		if _cgo_thread_start == nil {</code></span>
<span class="codeline" id="line-219"><code>			throw("_cgo_thread_start missing")</code></span>
<span class="codeline" id="line-220"><code>		}</code></span>
<span class="codeline" id="line-221"><code>		if GOOS != "windows" {</code></span>
<span class="codeline" id="line-222"><code>			if _cgo_setenv == nil {</code></span>
<span class="codeline" id="line-223"><code>				throw("_cgo_setenv missing")</code></span>
<span class="codeline" id="line-224"><code>			}</code></span>
<span class="codeline" id="line-225"><code>			if _cgo_unsetenv == nil {</code></span>
<span class="codeline" id="line-226"><code>				throw("_cgo_unsetenv missing")</code></span>
<span class="codeline" id="line-227"><code>			}</code></span>
<span class="codeline" id="line-228"><code>		}</code></span>
<span class="codeline" id="line-229"><code>		if _cgo_notify_runtime_init_done == nil {</code></span>
<span class="codeline" id="line-230"><code>			throw("_cgo_notify_runtime_init_done missing")</code></span>
<span class="codeline" id="line-231"><code>		}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>		// Set the x_crosscall2_ptr C function pointer variable point to crosscall2.</code></span>
<span class="codeline" id="line-234"><code>		if set_crosscall2 == nil {</code></span>
<span class="codeline" id="line-235"><code>			throw("set_crosscall2 missing")</code></span>
<span class="codeline" id="line-236"><code>		}</code></span>
<span class="codeline" id="line-237"><code>		set_crosscall2()</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>		// Start the template thread in case we enter Go from</code></span>
<span class="codeline" id="line-240"><code>		// a C-created thread and need to create a new thread.</code></span>
<span class="codeline" id="line-241"><code>		startTemplateThread()</code></span>
<span class="codeline" id="line-242"><code>		cgocall(_cgo_notify_runtime_init_done, nil)</code></span>
<span class="codeline" id="line-243"><code>	}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>	// Run the initializing tasks. Depending on build mode this</code></span>
<span class="codeline" id="line-246"><code>	// list can arrive a few different ways, but it will always</code></span>
<span class="codeline" id="line-247"><code>	// contain the init tasks computed by the linker for all the</code></span>
<span class="codeline" id="line-248"><code>	// packages in the program (excluding those added at runtime</code></span>
<span class="codeline" id="line-249"><code>	// by package plugin). Run through the modules in dependency</code></span>
<span class="codeline" id="line-250"><code>	// order (the order they are initialized by the dynamic</code></span>
<span class="codeline" id="line-251"><code>	// loader, i.e. they are added to the moduledata linked list).</code></span>
<span class="codeline" id="line-252"><code>	for m := &amp;firstmoduledata; m != nil; m = m.next {</code></span>
<span class="codeline" id="line-253"><code>		doInit(m.inittasks)</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>	// Disable init tracing after main init done to avoid overhead</code></span>
<span class="codeline" id="line-257"><code>	// of collecting statistics in malloc and newproc</code></span>
<span class="codeline" id="line-258"><code>	inittrace.active = false</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>	close(main_init_done)</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	needUnlock = false</code></span>
<span class="codeline" id="line-263"><code>	unlockOSThread()</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>	if isarchive || islibrary {</code></span>
<span class="codeline" id="line-266"><code>		// A program compiled with -buildmode=c-archive or c-shared</code></span>
<span class="codeline" id="line-267"><code>		// has a main, but it is not executed.</code></span>
<span class="codeline" id="line-268"><code>		return</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</code></span>
<span class="codeline" id="line-271"><code>	fn()</code></span>
<span class="codeline" id="line-272"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-273"><code>		runExitHooks(0) // run hooks now, since racefini does not return</code></span>
<span class="codeline" id="line-274"><code>		racefini()</code></span>
<span class="codeline" id="line-275"><code>	}</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>	// Make racy client program work: if panicking on</code></span>
<span class="codeline" id="line-278"><code>	// another goroutine at the same time as main returns,</code></span>
<span class="codeline" id="line-279"><code>	// let the other goroutine finish printing the panic trace.</code></span>
<span class="codeline" id="line-280"><code>	// Once it does, it will exit. See issues 3934 and 20018.</code></span>
<span class="codeline" id="line-281"><code>	if runningPanicDefers.Load() != 0 {</code></span>
<span class="codeline" id="line-282"><code>		// Running deferred functions should not take long.</code></span>
<span class="codeline" id="line-283"><code>		for c := 0; c &lt; 1000; c++ {</code></span>
<span class="codeline" id="line-284"><code>			if runningPanicDefers.Load() == 0 {</code></span>
<span class="codeline" id="line-285"><code>				break</code></span>
<span class="codeline" id="line-286"><code>			}</code></span>
<span class="codeline" id="line-287"><code>			Gosched()</code></span>
<span class="codeline" id="line-288"><code>		}</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>	if panicking.Load() != 0 {</code></span>
<span class="codeline" id="line-291"><code>		gopark(nil, nil, waitReasonPanicWait, traceBlockForever, 1)</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	runExitHooks(0)</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>	exit(0)</code></span>
<span class="codeline" id="line-296"><code>	for {</code></span>
<span class="codeline" id="line-297"><code>		var x *int32</code></span>
<span class="codeline" id="line-298"><code>		*x = 0</code></span>
<span class="codeline" id="line-299"><code>	}</code></span>
<span class="codeline" id="line-300"><code>}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>// os_beforeExit is called from os.Exit(0).</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>//go:linkname os_beforeExit os.runtime_beforeExit</code></span>
<span class="codeline" id="line-305"><code>func os_beforeExit(exitCode int) {</code></span>
<span class="codeline" id="line-306"><code>	runExitHooks(exitCode)</code></span>
<span class="codeline" id="line-307"><code>	if exitCode == 0 &amp;&amp; raceenabled {</code></span>
<span class="codeline" id="line-308"><code>		racefini()</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>}</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// start forcegc helper goroutine</code></span>
<span class="codeline" id="line-313"><code>func init() {</code></span>
<span class="codeline" id="line-314"><code>	go forcegchelper()</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>func forcegchelper() {</code></span>
<span class="codeline" id="line-318"><code>	forcegc.g = getg()</code></span>
<span class="codeline" id="line-319"><code>	lockInit(&amp;forcegc.lock, lockRankForcegc)</code></span>
<span class="codeline" id="line-320"><code>	for {</code></span>
<span class="codeline" id="line-321"><code>		lock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-322"><code>		if forcegc.idle.Load() {</code></span>
<span class="codeline" id="line-323"><code>			throw("forcegc: phase error")</code></span>
<span class="codeline" id="line-324"><code>		}</code></span>
<span class="codeline" id="line-325"><code>		forcegc.idle.Store(true)</code></span>
<span class="codeline" id="line-326"><code>		goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceBlockSystemGoroutine, 1)</code></span>
<span class="codeline" id="line-327"><code>		// this goroutine is explicitly resumed by sysmon</code></span>
<span class="codeline" id="line-328"><code>		if debug.gctrace &gt; 0 {</code></span>
<span class="codeline" id="line-329"><code>			println("GC forced")</code></span>
<span class="codeline" id="line-330"><code>		}</code></span>
<span class="codeline" id="line-331"><code>		// Time-triggered, fully concurrent.</code></span>
<span class="codeline" id="line-332"><code>		gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// Gosched yields the processor, allowing other goroutines to run. It does not</code></span>
<span class="codeline" id="line-337"><code>// suspend the current goroutine, so execution resumes automatically.</code></span>
<span class="codeline" id="line-338"><code>//</code></span>
<span class="codeline" id="line-339"><code>//go:nosplit</code></span>
<span class="codeline" id="line-340"><code>func Gosched() {</code></span>
<span class="codeline" id="line-341"><code>	checkTimeouts()</code></span>
<span class="codeline" id="line-342"><code>	mcall(gosched_m)</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>// goschedguarded yields the processor like gosched, but also checks</code></span>
<span class="codeline" id="line-346"><code>// for forbidden states and opts out of the yield in those cases.</code></span>
<span class="codeline" id="line-347"><code>//</code></span>
<span class="codeline" id="line-348"><code>//go:nosplit</code></span>
<span class="codeline" id="line-349"><code>func goschedguarded() {</code></span>
<span class="codeline" id="line-350"><code>	mcall(goschedguarded_m)</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>// goschedIfBusy yields the processor like gosched, but only does so if</code></span>
<span class="codeline" id="line-354"><code>// there are no idle Ps or if we're on the only P and there's nothing in</code></span>
<span class="codeline" id="line-355"><code>// the run queue. In both cases, there is freely available idle time.</code></span>
<span class="codeline" id="line-356"><code>//</code></span>
<span class="codeline" id="line-357"><code>//go:nosplit</code></span>
<span class="codeline" id="line-358"><code>func goschedIfBusy() {</code></span>
<span class="codeline" id="line-359"><code>	gp := getg()</code></span>
<span class="codeline" id="line-360"><code>	// Call gosched if gp.preempt is set; we may be in a tight loop that</code></span>
<span class="codeline" id="line-361"><code>	// doesn't otherwise yield.</code></span>
<span class="codeline" id="line-362"><code>	if !gp.preempt &amp;&amp; sched.npidle.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-363"><code>		return</code></span>
<span class="codeline" id="line-364"><code>	}</code></span>
<span class="codeline" id="line-365"><code>	mcall(gosched_m)</code></span>
<span class="codeline" id="line-366"><code>}</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>// Puts the current goroutine into a waiting state and calls unlockf on the</code></span>
<span class="codeline" id="line-369"><code>// system stack.</code></span>
<span class="codeline" id="line-370"><code>//</code></span>
<span class="codeline" id="line-371"><code>// If unlockf returns false, the goroutine is resumed.</code></span>
<span class="codeline" id="line-372"><code>//</code></span>
<span class="codeline" id="line-373"><code>// unlockf must not access this G's stack, as it may be moved between</code></span>
<span class="codeline" id="line-374"><code>// the call to gopark and the call to unlockf.</code></span>
<span class="codeline" id="line-375"><code>//</code></span>
<span class="codeline" id="line-376"><code>// Note that because unlockf is called after putting the G into a waiting</code></span>
<span class="codeline" id="line-377"><code>// state, the G may have already been readied by the time unlockf is called</code></span>
<span class="codeline" id="line-378"><code>// unless there is external synchronization preventing the G from being</code></span>
<span class="codeline" id="line-379"><code>// readied. If unlockf returns false, it must guarantee that the G cannot be</code></span>
<span class="codeline" id="line-380"><code>// externally readied.</code></span>
<span class="codeline" id="line-381"><code>//</code></span>
<span class="codeline" id="line-382"><code>// Reason explains why the goroutine has been parked. It is displayed in stack</code></span>
<span class="codeline" id="line-383"><code>// traces and heap dumps. Reasons should be unique and descriptive. Do not</code></span>
<span class="codeline" id="line-384"><code>// re-use reasons, add new ones.</code></span>
<span class="codeline" id="line-385"><code>func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip int) {</code></span>
<span class="codeline" id="line-386"><code>	if reason != waitReasonSleep {</code></span>
<span class="codeline" id="line-387"><code>		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy</code></span>
<span class="codeline" id="line-388"><code>	}</code></span>
<span class="codeline" id="line-389"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-390"><code>	gp := mp.curg</code></span>
<span class="codeline" id="line-391"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-392"><code>	if status != _Grunning &amp;&amp; status != _Gscanrunning {</code></span>
<span class="codeline" id="line-393"><code>		throw("gopark: bad g status")</code></span>
<span class="codeline" id="line-394"><code>	}</code></span>
<span class="codeline" id="line-395"><code>	mp.waitlock = lock</code></span>
<span class="codeline" id="line-396"><code>	mp.waitunlockf = unlockf</code></span>
<span class="codeline" id="line-397"><code>	gp.waitreason = reason</code></span>
<span class="codeline" id="line-398"><code>	mp.waitTraceBlockReason = traceReason</code></span>
<span class="codeline" id="line-399"><code>	mp.waitTraceSkip = traceskip</code></span>
<span class="codeline" id="line-400"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-401"><code>	// can't do anything that might move the G between Ms here.</code></span>
<span class="codeline" id="line-402"><code>	mcall(park_m)</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>// Puts the current goroutine into a waiting state and unlocks the lock.</code></span>
<span class="codeline" id="line-406"><code>// The goroutine can be made runnable again by calling goready(gp).</code></span>
<span class="codeline" id="line-407"><code>func goparkunlock(lock *mutex, reason waitReason, traceReason traceBlockReason, traceskip int) {</code></span>
<span class="codeline" id="line-408"><code>	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceReason, traceskip)</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>func goready(gp *g, traceskip int) {</code></span>
<span class="codeline" id="line-412"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-413"><code>		ready(gp, traceskip, true)</code></span>
<span class="codeline" id="line-414"><code>	})</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>//go:nosplit</code></span>
<span class="codeline" id="line-418"><code>func acquireSudog() *sudog {</code></span>
<span class="codeline" id="line-419"><code>	// Delicate dance: the semaphore implementation calls</code></span>
<span class="codeline" id="line-420"><code>	// acquireSudog, acquireSudog calls new(sudog),</code></span>
<span class="codeline" id="line-421"><code>	// new calls malloc, malloc can call the garbage collector,</code></span>
<span class="codeline" id="line-422"><code>	// and the garbage collector calls the semaphore implementation</code></span>
<span class="codeline" id="line-423"><code>	// in stopTheWorld.</code></span>
<span class="codeline" id="line-424"><code>	// Break the cycle by doing acquirem/releasem around new(sudog).</code></span>
<span class="codeline" id="line-425"><code>	// The acquirem/releasem increments m.locks during new(sudog),</code></span>
<span class="codeline" id="line-426"><code>	// which keeps the garbage collector from being invoked.</code></span>
<span class="codeline" id="line-427"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-428"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-429"><code>	if len(pp.sudogcache) == 0 {</code></span>
<span class="codeline" id="line-430"><code>		lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-431"><code>		// First, try to grab a batch from central cache.</code></span>
<span class="codeline" id="line-432"><code>		for len(pp.sudogcache) &lt; cap(pp.sudogcache)/2 &amp;&amp; sched.sudogcache != nil {</code></span>
<span class="codeline" id="line-433"><code>			s := sched.sudogcache</code></span>
<span class="codeline" id="line-434"><code>			sched.sudogcache = s.next</code></span>
<span class="codeline" id="line-435"><code>			s.next = nil</code></span>
<span class="codeline" id="line-436"><code>			pp.sudogcache = append(pp.sudogcache, s)</code></span>
<span class="codeline" id="line-437"><code>		}</code></span>
<span class="codeline" id="line-438"><code>		unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-439"><code>		// If the central cache is empty, allocate a new one.</code></span>
<span class="codeline" id="line-440"><code>		if len(pp.sudogcache) == 0 {</code></span>
<span class="codeline" id="line-441"><code>			pp.sudogcache = append(pp.sudogcache, new(sudog))</code></span>
<span class="codeline" id="line-442"><code>		}</code></span>
<span class="codeline" id="line-443"><code>	}</code></span>
<span class="codeline" id="line-444"><code>	n := len(pp.sudogcache)</code></span>
<span class="codeline" id="line-445"><code>	s := pp.sudogcache[n-1]</code></span>
<span class="codeline" id="line-446"><code>	pp.sudogcache[n-1] = nil</code></span>
<span class="codeline" id="line-447"><code>	pp.sudogcache = pp.sudogcache[:n-1]</code></span>
<span class="codeline" id="line-448"><code>	if s.elem != nil {</code></span>
<span class="codeline" id="line-449"><code>		throw("acquireSudog: found s.elem != nil in cache")</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-452"><code>	return s</code></span>
<span class="codeline" id="line-453"><code>}</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>//go:nosplit</code></span>
<span class="codeline" id="line-456"><code>func releaseSudog(s *sudog) {</code></span>
<span class="codeline" id="line-457"><code>	if s.elem != nil {</code></span>
<span class="codeline" id="line-458"><code>		throw("runtime: sudog with non-nil elem")</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code>	if s.isSelect {</code></span>
<span class="codeline" id="line-461"><code>		throw("runtime: sudog with non-false isSelect")</code></span>
<span class="codeline" id="line-462"><code>	}</code></span>
<span class="codeline" id="line-463"><code>	if s.next != nil {</code></span>
<span class="codeline" id="line-464"><code>		throw("runtime: sudog with non-nil next")</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code>	if s.prev != nil {</code></span>
<span class="codeline" id="line-467"><code>		throw("runtime: sudog with non-nil prev")</code></span>
<span class="codeline" id="line-468"><code>	}</code></span>
<span class="codeline" id="line-469"><code>	if s.waitlink != nil {</code></span>
<span class="codeline" id="line-470"><code>		throw("runtime: sudog with non-nil waitlink")</code></span>
<span class="codeline" id="line-471"><code>	}</code></span>
<span class="codeline" id="line-472"><code>	if s.c != nil {</code></span>
<span class="codeline" id="line-473"><code>		throw("runtime: sudog with non-nil c")</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>	gp := getg()</code></span>
<span class="codeline" id="line-476"><code>	if gp.param != nil {</code></span>
<span class="codeline" id="line-477"><code>		throw("runtime: releaseSudog with non-nil gp.param")</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code>	mp := acquirem() // avoid rescheduling to another P</code></span>
<span class="codeline" id="line-480"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-481"><code>	if len(pp.sudogcache) == cap(pp.sudogcache) {</code></span>
<span class="codeline" id="line-482"><code>		// Transfer half of local cache to the central cache.</code></span>
<span class="codeline" id="line-483"><code>		var first, last *sudog</code></span>
<span class="codeline" id="line-484"><code>		for len(pp.sudogcache) &gt; cap(pp.sudogcache)/2 {</code></span>
<span class="codeline" id="line-485"><code>			n := len(pp.sudogcache)</code></span>
<span class="codeline" id="line-486"><code>			p := pp.sudogcache[n-1]</code></span>
<span class="codeline" id="line-487"><code>			pp.sudogcache[n-1] = nil</code></span>
<span class="codeline" id="line-488"><code>			pp.sudogcache = pp.sudogcache[:n-1]</code></span>
<span class="codeline" id="line-489"><code>			if first == nil {</code></span>
<span class="codeline" id="line-490"><code>				first = p</code></span>
<span class="codeline" id="line-491"><code>			} else {</code></span>
<span class="codeline" id="line-492"><code>				last.next = p</code></span>
<span class="codeline" id="line-493"><code>			}</code></span>
<span class="codeline" id="line-494"><code>			last = p</code></span>
<span class="codeline" id="line-495"><code>		}</code></span>
<span class="codeline" id="line-496"><code>		lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-497"><code>		last.next = sched.sudogcache</code></span>
<span class="codeline" id="line-498"><code>		sched.sudogcache = first</code></span>
<span class="codeline" id="line-499"><code>		unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code>	pp.sudogcache = append(pp.sudogcache, s)</code></span>
<span class="codeline" id="line-502"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>// called from assembly.</code></span>
<span class="codeline" id="line-506"><code>func badmcall(fn func(*g)) {</code></span>
<span class="codeline" id="line-507"><code>	throw("runtime: mcall called on m-&gt;g0 stack")</code></span>
<span class="codeline" id="line-508"><code>}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>func badmcall2(fn func(*g)) {</code></span>
<span class="codeline" id="line-511"><code>	throw("runtime: mcall function returned")</code></span>
<span class="codeline" id="line-512"><code>}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>func badreflectcall() {</code></span>
<span class="codeline" id="line-515"><code>	panic(plainError("arg size to reflect.call more than 1GB"))</code></span>
<span class="codeline" id="line-516"><code>}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>//go:nosplit</code></span>
<span class="codeline" id="line-519"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-520"><code>func badmorestackg0() {</code></span>
<span class="codeline" id="line-521"><code>	if !crashStackImplemented {</code></span>
<span class="codeline" id="line-522"><code>		writeErrStr("fatal: morestack on g0\n")</code></span>
<span class="codeline" id="line-523"><code>		return</code></span>
<span class="codeline" id="line-524"><code>	}</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>	g := getg()</code></span>
<span class="codeline" id="line-527"><code>	switchToCrashStack(func() {</code></span>
<span class="codeline" id="line-528"><code>		print("runtime: morestack on g0, stack [", hex(g.stack.lo), " ", hex(g.stack.hi), "], sp=", hex(g.sched.sp), ", called from\n")</code></span>
<span class="codeline" id="line-529"><code>		g.m.traceback = 2 // include pc and sp in stack trace</code></span>
<span class="codeline" id="line-530"><code>		traceback1(g.sched.pc, g.sched.sp, g.sched.lr, g, 0)</code></span>
<span class="codeline" id="line-531"><code>		print("\n")</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>		throw("morestack on g0")</code></span>
<span class="codeline" id="line-534"><code>	})</code></span>
<span class="codeline" id="line-535"><code>}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>//go:nosplit</code></span>
<span class="codeline" id="line-538"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-539"><code>func badmorestackgsignal() {</code></span>
<span class="codeline" id="line-540"><code>	writeErrStr("fatal: morestack on gsignal\n")</code></span>
<span class="codeline" id="line-541"><code>}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>//go:nosplit</code></span>
<span class="codeline" id="line-544"><code>func badctxt() {</code></span>
<span class="codeline" id="line-545"><code>	throw("ctxt != 0")</code></span>
<span class="codeline" id="line-546"><code>}</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>// gcrash is a fake g that can be used when crashing due to bad</code></span>
<span class="codeline" id="line-549"><code>// stack conditions.</code></span>
<span class="codeline" id="line-550"><code>var gcrash g</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>var crashingG atomic.Pointer[g]</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>// Switch to crashstack and call fn, with special handling of</code></span>
<span class="codeline" id="line-555"><code>// concurrent and recursive cases.</code></span>
<span class="codeline" id="line-556"><code>//</code></span>
<span class="codeline" id="line-557"><code>// Nosplit as it is called in a bad stack condition (we know</code></span>
<span class="codeline" id="line-558"><code>// morestack would fail).</code></span>
<span class="codeline" id="line-559"><code>//</code></span>
<span class="codeline" id="line-560"><code>//go:nosplit</code></span>
<span class="codeline" id="line-561"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-562"><code>func switchToCrashStack(fn func()) {</code></span>
<span class="codeline" id="line-563"><code>	me := getg()</code></span>
<span class="codeline" id="line-564"><code>	if crashingG.CompareAndSwapNoWB(nil, me) {</code></span>
<span class="codeline" id="line-565"><code>		switchToCrashStack0(fn) // should never return</code></span>
<span class="codeline" id="line-566"><code>		abort()</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code>	if crashingG.Load() == me {</code></span>
<span class="codeline" id="line-569"><code>		// recursive crashing. too bad.</code></span>
<span class="codeline" id="line-570"><code>		writeErrStr("fatal: recursive switchToCrashStack\n")</code></span>
<span class="codeline" id="line-571"><code>		abort()</code></span>
<span class="codeline" id="line-572"><code>	}</code></span>
<span class="codeline" id="line-573"><code>	// Another g is crashing. Give it some time, hopefully it will finish traceback.</code></span>
<span class="codeline" id="line-574"><code>	usleep_no_g(100)</code></span>
<span class="codeline" id="line-575"><code>	writeErrStr("fatal: concurrent switchToCrashStack\n")</code></span>
<span class="codeline" id="line-576"><code>	abort()</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// Disable crash stack on Windows for now. Apparently, throwing an exception</code></span>
<span class="codeline" id="line-580"><code>// on a non-system-allocated crash stack causes EXCEPTION_STACK_OVERFLOW and</code></span>
<span class="codeline" id="line-581"><code>// hangs the process (see issue 63938).</code></span>
<span class="codeline" id="line-582"><code>const crashStackImplemented = (GOARCH == "amd64" || GOARCH == "arm64" || GOARCH == "mips64" || GOARCH == "mips64le" || GOARCH == "ppc64" || GOARCH == "ppc64le" || GOARCH == "riscv64" || GOARCH == "wasm") &amp;&amp; GOOS != "windows"</code></span>
<span class="codeline" id="line-583"><code></code></span>
<span class="codeline" id="line-584"><code>//go:noescape</code></span>
<span class="codeline" id="line-585"><code>func switchToCrashStack0(fn func()) // in assembly</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>func lockedOSThread() bool {</code></span>
<span class="codeline" id="line-588"><code>	gp := getg()</code></span>
<span class="codeline" id="line-589"><code>	return gp.lockedm != 0 &amp;&amp; gp.m.lockedg != 0</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>var (</code></span>
<span class="codeline" id="line-593"><code>	// allgs contains all Gs ever created (including dead Gs), and thus</code></span>
<span class="codeline" id="line-594"><code>	// never shrinks.</code></span>
<span class="codeline" id="line-595"><code>	//</code></span>
<span class="codeline" id="line-596"><code>	// Access via the slice is protected by allglock or stop-the-world.</code></span>
<span class="codeline" id="line-597"><code>	// Readers that cannot take the lock may (carefully!) use the atomic</code></span>
<span class="codeline" id="line-598"><code>	// variables below.</code></span>
<span class="codeline" id="line-599"><code>	allglock mutex</code></span>
<span class="codeline" id="line-600"><code>	allgs    []*g</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>	// allglen and allgptr are atomic variables that contain len(allgs) and</code></span>
<span class="codeline" id="line-603"><code>	// &amp;allgs[0] respectively. Proper ordering depends on totally-ordered</code></span>
<span class="codeline" id="line-604"><code>	// loads and stores. Writes are protected by allglock.</code></span>
<span class="codeline" id="line-605"><code>	//</code></span>
<span class="codeline" id="line-606"><code>	// allgptr is updated before allglen. Readers should read allglen</code></span>
<span class="codeline" id="line-607"><code>	// before allgptr to ensure that allglen is always &lt;= len(allgptr). New</code></span>
<span class="codeline" id="line-608"><code>	// Gs appended during the race can be missed. For a consistent view of</code></span>
<span class="codeline" id="line-609"><code>	// all Gs, allglock must be held.</code></span>
<span class="codeline" id="line-610"><code>	//</code></span>
<span class="codeline" id="line-611"><code>	// allgptr copies should always be stored as a concrete type or</code></span>
<span class="codeline" id="line-612"><code>	// unsafe.Pointer, not uintptr, to ensure that GC can still reach it</code></span>
<span class="codeline" id="line-613"><code>	// even if it points to a stale array.</code></span>
<span class="codeline" id="line-614"><code>	allglen uintptr</code></span>
<span class="codeline" id="line-615"><code>	allgptr **g</code></span>
<span class="codeline" id="line-616"><code>)</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>func allgadd(gp *g) {</code></span>
<span class="codeline" id="line-619"><code>	if readgstatus(gp) == _Gidle {</code></span>
<span class="codeline" id="line-620"><code>		throw("allgadd: bad status Gidle")</code></span>
<span class="codeline" id="line-621"><code>	}</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-624"><code>	allgs = append(allgs, gp)</code></span>
<span class="codeline" id="line-625"><code>	if &amp;allgs[0] != allgptr {</code></span>
<span class="codeline" id="line-626"><code>		atomicstorep(unsafe.Pointer(&amp;allgptr), unsafe.Pointer(&amp;allgs[0]))</code></span>
<span class="codeline" id="line-627"><code>	}</code></span>
<span class="codeline" id="line-628"><code>	atomic.Storeuintptr(&amp;allglen, uintptr(len(allgs)))</code></span>
<span class="codeline" id="line-629"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-630"><code>}</code></span>
<span class="codeline" id="line-631"><code></code></span>
<span class="codeline" id="line-632"><code>// allGsSnapshot returns a snapshot of the slice of all Gs.</code></span>
<span class="codeline" id="line-633"><code>//</code></span>
<span class="codeline" id="line-634"><code>// The world must be stopped or allglock must be held.</code></span>
<span class="codeline" id="line-635"><code>func allGsSnapshot() []*g {</code></span>
<span class="codeline" id="line-636"><code>	assertWorldStoppedOrLockHeld(&amp;allglock)</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>	// Because the world is stopped or allglock is held, allgadd</code></span>
<span class="codeline" id="line-639"><code>	// cannot happen concurrently with this. allgs grows</code></span>
<span class="codeline" id="line-640"><code>	// monotonically and existing entries never change, so we can</code></span>
<span class="codeline" id="line-641"><code>	// simply return a copy of the slice header. For added safety,</code></span>
<span class="codeline" id="line-642"><code>	// we trim everything past len because that can still change.</code></span>
<span class="codeline" id="line-643"><code>	return allgs[:len(allgs):len(allgs)]</code></span>
<span class="codeline" id="line-644"><code>}</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>// atomicAllG returns &amp;allgs[0] and len(allgs) for use with atomicAllGIndex.</code></span>
<span class="codeline" id="line-647"><code>func atomicAllG() (**g, uintptr) {</code></span>
<span class="codeline" id="line-648"><code>	length := atomic.Loaduintptr(&amp;allglen)</code></span>
<span class="codeline" id="line-649"><code>	ptr := (**g)(atomic.Loadp(unsafe.Pointer(&amp;allgptr)))</code></span>
<span class="codeline" id="line-650"><code>	return ptr, length</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>// atomicAllGIndex returns ptr[i] with the allgptr returned from atomicAllG.</code></span>
<span class="codeline" id="line-654"><code>func atomicAllGIndex(ptr **g, i uintptr) *g {</code></span>
<span class="codeline" id="line-655"><code>	return *(**g)(add(unsafe.Pointer(ptr), i*goarch.PtrSize))</code></span>
<span class="codeline" id="line-656"><code>}</code></span>
<span class="codeline" id="line-657"><code></code></span>
<span class="codeline" id="line-658"><code>// forEachG calls fn on every G from allgs.</code></span>
<span class="codeline" id="line-659"><code>//</code></span>
<span class="codeline" id="line-660"><code>// forEachG takes a lock to exclude concurrent addition of new Gs.</code></span>
<span class="codeline" id="line-661"><code>func forEachG(fn func(gp *g)) {</code></span>
<span class="codeline" id="line-662"><code>	lock(&amp;allglock)</code></span>
<span class="codeline" id="line-663"><code>	for _, gp := range allgs {</code></span>
<span class="codeline" id="line-664"><code>		fn(gp)</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>	unlock(&amp;allglock)</code></span>
<span class="codeline" id="line-667"><code>}</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>// forEachGRace calls fn on every G from allgs.</code></span>
<span class="codeline" id="line-670"><code>//</code></span>
<span class="codeline" id="line-671"><code>// forEachGRace avoids locking, but does not exclude addition of new Gs during</code></span>
<span class="codeline" id="line-672"><code>// execution, which may be missed.</code></span>
<span class="codeline" id="line-673"><code>func forEachGRace(fn func(gp *g)) {</code></span>
<span class="codeline" id="line-674"><code>	ptr, length := atomicAllG()</code></span>
<span class="codeline" id="line-675"><code>	for i := uintptr(0); i &lt; length; i++ {</code></span>
<span class="codeline" id="line-676"><code>		gp := atomicAllGIndex(ptr, i)</code></span>
<span class="codeline" id="line-677"><code>		fn(gp)</code></span>
<span class="codeline" id="line-678"><code>	}</code></span>
<span class="codeline" id="line-679"><code>	return</code></span>
<span class="codeline" id="line-680"><code>}</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>const (</code></span>
<span class="codeline" id="line-683"><code>	// Number of goroutine ids to grab from sched.goidgen to local per-P cache at once.</code></span>
<span class="codeline" id="line-684"><code>	// 16 seems to provide enough amortization, but other than that it's mostly arbitrary number.</code></span>
<span class="codeline" id="line-685"><code>	_GoidCacheBatch = 16</code></span>
<span class="codeline" id="line-686"><code>)</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>// cpuinit sets up CPU feature flags and calls internal/cpu.Initialize. env should be the complete</code></span>
<span class="codeline" id="line-689"><code>// value of the GODEBUG environment variable.</code></span>
<span class="codeline" id="line-690"><code>func cpuinit(env string) {</code></span>
<span class="codeline" id="line-691"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-692"><code>	case "aix", "darwin", "ios", "dragonfly", "freebsd", "netbsd", "openbsd", "illumos", "solaris", "linux":</code></span>
<span class="codeline" id="line-693"><code>		cpu.DebugOptions = true</code></span>
<span class="codeline" id="line-694"><code>	}</code></span>
<span class="codeline" id="line-695"><code>	cpu.Initialize(env)</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	// Support cpu feature variables are used in code generated by the compiler</code></span>
<span class="codeline" id="line-698"><code>	// to guard execution of instructions that can not be assumed to be always supported.</code></span>
<span class="codeline" id="line-699"><code>	switch GOARCH {</code></span>
<span class="codeline" id="line-700"><code>	case "386", "amd64":</code></span>
<span class="codeline" id="line-701"><code>		x86HasPOPCNT = cpu.X86.HasPOPCNT</code></span>
<span class="codeline" id="line-702"><code>		x86HasSSE41 = cpu.X86.HasSSE41</code></span>
<span class="codeline" id="line-703"><code>		x86HasFMA = cpu.X86.HasFMA</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>	case "arm":</code></span>
<span class="codeline" id="line-706"><code>		armHasVFPv4 = cpu.ARM.HasVFPv4</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>	case "arm64":</code></span>
<span class="codeline" id="line-709"><code>		arm64HasATOMICS = cpu.ARM64.HasATOMICS</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>// getGodebugEarly extracts the environment variable GODEBUG from the environment on</code></span>
<span class="codeline" id="line-714"><code>// Unix-like operating systems and returns it. This function exists to extract GODEBUG</code></span>
<span class="codeline" id="line-715"><code>// early before much of the runtime is initialized.</code></span>
<span class="codeline" id="line-716"><code>func getGodebugEarly() string {</code></span>
<span class="codeline" id="line-717"><code>	const prefix = "GODEBUG="</code></span>
<span class="codeline" id="line-718"><code>	var env string</code></span>
<span class="codeline" id="line-719"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-720"><code>	case "aix", "darwin", "ios", "dragonfly", "freebsd", "netbsd", "openbsd", "illumos", "solaris", "linux":</code></span>
<span class="codeline" id="line-721"><code>		// Similar to goenv_unix but extracts the environment value for</code></span>
<span class="codeline" id="line-722"><code>		// GODEBUG directly.</code></span>
<span class="codeline" id="line-723"><code>		// TODO(moehrmann): remove when general goenvs() can be called before cpuinit()</code></span>
<span class="codeline" id="line-724"><code>		n := int32(0)</code></span>
<span class="codeline" id="line-725"><code>		for argv_index(argv, argc+1+n) != nil {</code></span>
<span class="codeline" id="line-726"><code>			n++</code></span>
<span class="codeline" id="line-727"><code>		}</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>		for i := int32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-730"><code>			p := argv_index(argv, argc+1+i)</code></span>
<span class="codeline" id="line-731"><code>			s := unsafe.String(p, findnull(p))</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>			if hasPrefix(s, prefix) {</code></span>
<span class="codeline" id="line-734"><code>				env = gostring(p)[len(prefix):]</code></span>
<span class="codeline" id="line-735"><code>				break</code></span>
<span class="codeline" id="line-736"><code>			}</code></span>
<span class="codeline" id="line-737"><code>		}</code></span>
<span class="codeline" id="line-738"><code>	}</code></span>
<span class="codeline" id="line-739"><code>	return env</code></span>
<span class="codeline" id="line-740"><code>}</code></span>
<span class="codeline" id="line-741"><code></code></span>
<span class="codeline" id="line-742"><code>// The bootstrap sequence is:</code></span>
<span class="codeline" id="line-743"><code>//</code></span>
<span class="codeline" id="line-744"><code>//	call osinit</code></span>
<span class="codeline" id="line-745"><code>//	call schedinit</code></span>
<span class="codeline" id="line-746"><code>//	make &amp; queue new G</code></span>
<span class="codeline" id="line-747"><code>//	call runtimemstart</code></span>
<span class="codeline" id="line-748"><code>//</code></span>
<span class="codeline" id="line-749"><code>// The new G calls runtimemain.</code></span>
<span class="codeline" id="line-750"><code>func schedinit() {</code></span>
<span class="codeline" id="line-751"><code>	lockInit(&amp;sched.lock, lockRankSched)</code></span>
<span class="codeline" id="line-752"><code>	lockInit(&amp;sched.sysmonlock, lockRankSysmon)</code></span>
<span class="codeline" id="line-753"><code>	lockInit(&amp;sched.deferlock, lockRankDefer)</code></span>
<span class="codeline" id="line-754"><code>	lockInit(&amp;sched.sudoglock, lockRankSudog)</code></span>
<span class="codeline" id="line-755"><code>	lockInit(&amp;deadlock, lockRankDeadlock)</code></span>
<span class="codeline" id="line-756"><code>	lockInit(&amp;paniclk, lockRankPanic)</code></span>
<span class="codeline" id="line-757"><code>	lockInit(&amp;allglock, lockRankAllg)</code></span>
<span class="codeline" id="line-758"><code>	lockInit(&amp;allpLock, lockRankAllp)</code></span>
<span class="codeline" id="line-759"><code>	lockInit(&amp;reflectOffs.lock, lockRankReflectOffs)</code></span>
<span class="codeline" id="line-760"><code>	lockInit(&amp;finlock, lockRankFin)</code></span>
<span class="codeline" id="line-761"><code>	lockInit(&amp;cpuprof.lock, lockRankCpuprof)</code></span>
<span class="codeline" id="line-762"><code>	allocmLock.init(lockRankAllocmR, lockRankAllocmRInternal, lockRankAllocmW)</code></span>
<span class="codeline" id="line-763"><code>	execLock.init(lockRankExecR, lockRankExecRInternal, lockRankExecW)</code></span>
<span class="codeline" id="line-764"><code>	traceLockInit()</code></span>
<span class="codeline" id="line-765"><code>	// Enforce that this lock is always a leaf lock.</code></span>
<span class="codeline" id="line-766"><code>	// All of this lock's critical sections should be</code></span>
<span class="codeline" id="line-767"><code>	// extremely short.</code></span>
<span class="codeline" id="line-768"><code>	lockInit(&amp;memstats.heapStats.noPLock, lockRankLeafRank)</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	// raceinit must be the first call to race detector.</code></span>
<span class="codeline" id="line-771"><code>	// In particular, it must be done before mallocinit below calls racemapshadow.</code></span>
<span class="codeline" id="line-772"><code>	gp := getg()</code></span>
<span class="codeline" id="line-773"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-774"><code>		gp.racectx, raceprocctx0 = raceinit()</code></span>
<span class="codeline" id="line-775"><code>	}</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>	sched.maxmcount = 10000</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>	// The world starts stopped.</code></span>
<span class="codeline" id="line-780"><code>	worldStopped()</code></span>
<span class="codeline" id="line-781"><code></code></span>
<span class="codeline" id="line-782"><code>	ticks.init() // run as early as possible</code></span>
<span class="codeline" id="line-783"><code>	moduledataverify()</code></span>
<span class="codeline" id="line-784"><code>	stackinit()</code></span>
<span class="codeline" id="line-785"><code>	mallocinit()</code></span>
<span class="codeline" id="line-786"><code>	godebug := getGodebugEarly()</code></span>
<span class="codeline" id="line-787"><code>	initPageTrace(godebug) // must run after mallocinit but before anything allocates</code></span>
<span class="codeline" id="line-788"><code>	cpuinit(godebug)       // must run before alginit</code></span>
<span class="codeline" id="line-789"><code>	randinit()             // must run before alginit, mcommoninit</code></span>
<span class="codeline" id="line-790"><code>	alginit()              // maps, hash, rand must not be used before this call</code></span>
<span class="codeline" id="line-791"><code>	mcommoninit(gp.m, -1)</code></span>
<span class="codeline" id="line-792"><code>	modulesinit()   // provides activeModules</code></span>
<span class="codeline" id="line-793"><code>	typelinksinit() // uses maps, activeModules</code></span>
<span class="codeline" id="line-794"><code>	itabsinit()     // uses activeModules</code></span>
<span class="codeline" id="line-795"><code>	stkobjinit()    // must run before GC starts</code></span>
<span class="codeline" id="line-796"><code></code></span>
<span class="codeline" id="line-797"><code>	sigsave(&amp;gp.m.sigmask)</code></span>
<span class="codeline" id="line-798"><code>	initSigmask = gp.m.sigmask</code></span>
<span class="codeline" id="line-799"><code></code></span>
<span class="codeline" id="line-800"><code>	goargs()</code></span>
<span class="codeline" id="line-801"><code>	goenvs()</code></span>
<span class="codeline" id="line-802"><code>	secure()</code></span>
<span class="codeline" id="line-803"><code>	checkfds()</code></span>
<span class="codeline" id="line-804"><code>	parsedebugvars()</code></span>
<span class="codeline" id="line-805"><code>	gcinit()</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>	// Allocate stack space that can be used when crashing due to bad stack</code></span>
<span class="codeline" id="line-808"><code>	// conditions, e.g. morestack on g0.</code></span>
<span class="codeline" id="line-809"><code>	gcrash.stack = stackalloc(16384)</code></span>
<span class="codeline" id="line-810"><code>	gcrash.stackguard0 = gcrash.stack.lo + 1000</code></span>
<span class="codeline" id="line-811"><code>	gcrash.stackguard1 = gcrash.stack.lo + 1000</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>	// if disableMemoryProfiling is set, update MemProfileRate to 0 to turn off memprofile.</code></span>
<span class="codeline" id="line-814"><code>	// Note: parsedebugvars may update MemProfileRate, but when disableMemoryProfiling is</code></span>
<span class="codeline" id="line-815"><code>	// set to true by the linker, it means that nothing is consuming the profile, it is</code></span>
<span class="codeline" id="line-816"><code>	// safe to set MemProfileRate to 0.</code></span>
<span class="codeline" id="line-817"><code>	if disableMemoryProfiling {</code></span>
<span class="codeline" id="line-818"><code>		MemProfileRate = 0</code></span>
<span class="codeline" id="line-819"><code>	}</code></span>
<span class="codeline" id="line-820"><code></code></span>
<span class="codeline" id="line-821"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-822"><code>	sched.lastpoll.Store(nanotime())</code></span>
<span class="codeline" id="line-823"><code>	procs := ncpu</code></span>
<span class="codeline" id="line-824"><code>	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok &amp;&amp; n &gt; 0 {</code></span>
<span class="codeline" id="line-825"><code>		procs = n</code></span>
<span class="codeline" id="line-826"><code>	}</code></span>
<span class="codeline" id="line-827"><code>	if procresize(procs) != nil {</code></span>
<span class="codeline" id="line-828"><code>		throw("unknown runnable goroutine during bootstrap")</code></span>
<span class="codeline" id="line-829"><code>	}</code></span>
<span class="codeline" id="line-830"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>	// World is effectively started now, as P's can run.</code></span>
<span class="codeline" id="line-833"><code>	worldStarted()</code></span>
<span class="codeline" id="line-834"><code></code></span>
<span class="codeline" id="line-835"><code>	if buildVersion == "" {</code></span>
<span class="codeline" id="line-836"><code>		// Condition should never trigger. This code just serves</code></span>
<span class="codeline" id="line-837"><code>		// to ensure runtimebuildVersion is kept in the resulting binary.</code></span>
<span class="codeline" id="line-838"><code>		buildVersion = "unknown"</code></span>
<span class="codeline" id="line-839"><code>	}</code></span>
<span class="codeline" id="line-840"><code>	if len(modinfo) == 1 {</code></span>
<span class="codeline" id="line-841"><code>		// Condition should never trigger. This code just serves</code></span>
<span class="codeline" id="line-842"><code>		// to ensure runtimemodinfo is kept in the resulting binary.</code></span>
<span class="codeline" id="line-843"><code>		modinfo = ""</code></span>
<span class="codeline" id="line-844"><code>	}</code></span>
<span class="codeline" id="line-845"><code>}</code></span>
<span class="codeline" id="line-846"><code></code></span>
<span class="codeline" id="line-847"><code>func dumpgstatus(gp *g) {</code></span>
<span class="codeline" id="line-848"><code>	thisg := getg()</code></span>
<span class="codeline" id="line-849"><code>	print("runtime:   gp: gp=", gp, ", goid=", gp.goid, ", gp-&gt;atomicstatus=", readgstatus(gp), "\n")</code></span>
<span class="codeline" id="line-850"><code>	print("runtime: getg:  g=", thisg, ", goid=", thisg.goid, ",  g-&gt;atomicstatus=", readgstatus(thisg), "\n")</code></span>
<span class="codeline" id="line-851"><code>}</code></span>
<span class="codeline" id="line-852"><code></code></span>
<span class="codeline" id="line-853"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-854"><code>func checkmcount() {</code></span>
<span class="codeline" id="line-855"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>	// Exclude extra M's, which are used for cgocallback from threads</code></span>
<span class="codeline" id="line-858"><code>	// created in C.</code></span>
<span class="codeline" id="line-859"><code>	//</code></span>
<span class="codeline" id="line-860"><code>	// The purpose of the SetMaxThreads limit is to avoid accidental fork</code></span>
<span class="codeline" id="line-861"><code>	// bomb from something like millions of goroutines blocking on system</code></span>
<span class="codeline" id="line-862"><code>	// calls, causing the runtime to create millions of threads. By</code></span>
<span class="codeline" id="line-863"><code>	// definition, this isn't a problem for threads created in C, so we</code></span>
<span class="codeline" id="line-864"><code>	// exclude them from the limit. See https://go.dev/issue/60004.</code></span>
<span class="codeline" id="line-865"><code>	count := mcount() - int32(extraMInUse.Load()) - int32(extraMLength.Load())</code></span>
<span class="codeline" id="line-866"><code>	if count &gt; sched.maxmcount {</code></span>
<span class="codeline" id="line-867"><code>		print("runtime: program exceeds ", sched.maxmcount, "-thread limit\n")</code></span>
<span class="codeline" id="line-868"><code>		throw("thread exhaustion")</code></span>
<span class="codeline" id="line-869"><code>	}</code></span>
<span class="codeline" id="line-870"><code>}</code></span>
<span class="codeline" id="line-871"><code></code></span>
<span class="codeline" id="line-872"><code>// mReserveID returns the next ID to use for a new m. This new m is immediately</code></span>
<span class="codeline" id="line-873"><code>// considered 'running' by checkdead.</code></span>
<span class="codeline" id="line-874"><code>//</code></span>
<span class="codeline" id="line-875"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-876"><code>func mReserveID() int64 {</code></span>
<span class="codeline" id="line-877"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-878"><code></code></span>
<span class="codeline" id="line-879"><code>	if sched.mnext+1 &lt; sched.mnext {</code></span>
<span class="codeline" id="line-880"><code>		throw("runtime: thread ID overflow")</code></span>
<span class="codeline" id="line-881"><code>	}</code></span>
<span class="codeline" id="line-882"><code>	id := sched.mnext</code></span>
<span class="codeline" id="line-883"><code>	sched.mnext++</code></span>
<span class="codeline" id="line-884"><code>	checkmcount()</code></span>
<span class="codeline" id="line-885"><code>	return id</code></span>
<span class="codeline" id="line-886"><code>}</code></span>
<span class="codeline" id="line-887"><code></code></span>
<span class="codeline" id="line-888"><code>// Pre-allocated ID may be passed as 'id', or omitted by passing -1.</code></span>
<span class="codeline" id="line-889"><code>func mcommoninit(mp *m, id int64) {</code></span>
<span class="codeline" id="line-890"><code>	gp := getg()</code></span>
<span class="codeline" id="line-891"><code></code></span>
<span class="codeline" id="line-892"><code>	// g0 stack won't make sense for user (and is not necessary unwindable).</code></span>
<span class="codeline" id="line-893"><code>	if gp != gp.m.g0 {</code></span>
<span class="codeline" id="line-894"><code>		callers(1, mp.createstack[:])</code></span>
<span class="codeline" id="line-895"><code>	}</code></span>
<span class="codeline" id="line-896"><code></code></span>
<span class="codeline" id="line-897"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>	if id &gt;= 0 {</code></span>
<span class="codeline" id="line-900"><code>		mp.id = id</code></span>
<span class="codeline" id="line-901"><code>	} else {</code></span>
<span class="codeline" id="line-902"><code>		mp.id = mReserveID()</code></span>
<span class="codeline" id="line-903"><code>	}</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>	mrandinit(mp)</code></span>
<span class="codeline" id="line-906"><code></code></span>
<span class="codeline" id="line-907"><code>	mpreinit(mp)</code></span>
<span class="codeline" id="line-908"><code>	if mp.gsignal != nil {</code></span>
<span class="codeline" id="line-909"><code>		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-910"><code>	}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>	// Add to allm so garbage collector doesn't free g-&gt;m</code></span>
<span class="codeline" id="line-913"><code>	// when it is just in a register or thread-local storage.</code></span>
<span class="codeline" id="line-914"><code>	mp.alllink = allm</code></span>
<span class="codeline" id="line-915"><code></code></span>
<span class="codeline" id="line-916"><code>	// NumCgoCall() and others iterate over allm w/o schedlock,</code></span>
<span class="codeline" id="line-917"><code>	// so we need to publish it safely.</code></span>
<span class="codeline" id="line-918"><code>	atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</code></span>
<span class="codeline" id="line-919"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>	// Allocate memory to hold a cgo traceback if the cgo call crashes.</code></span>
<span class="codeline" id="line-922"><code>	if iscgo || GOOS == "solaris" || GOOS == "illumos" || GOOS == "windows" {</code></span>
<span class="codeline" id="line-923"><code>		mp.cgoCallers = new(cgoCallers)</code></span>
<span class="codeline" id="line-924"><code>	}</code></span>
<span class="codeline" id="line-925"><code>}</code></span>
<span class="codeline" id="line-926"><code></code></span>
<span class="codeline" id="line-927"><code>func (mp *m) becomeSpinning() {</code></span>
<span class="codeline" id="line-928"><code>	mp.spinning = true</code></span>
<span class="codeline" id="line-929"><code>	sched.nmspinning.Add(1)</code></span>
<span class="codeline" id="line-930"><code>	sched.needspinning.Store(0)</code></span>
<span class="codeline" id="line-931"><code>}</code></span>
<span class="codeline" id="line-932"><code></code></span>
<span class="codeline" id="line-933"><code>func (mp *m) hasCgoOnStack() bool {</code></span>
<span class="codeline" id="line-934"><code>	return mp.ncgo &gt; 0 || mp.isextra</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>const (</code></span>
<span class="codeline" id="line-938"><code>	// osHasLowResTimer indicates that the platform's internal timer system has a low resolution,</code></span>
<span class="codeline" id="line-939"><code>	// typically on the order of 1 ms or more.</code></span>
<span class="codeline" id="line-940"><code>	osHasLowResTimer = GOOS == "windows" || GOOS == "openbsd" || GOOS == "netbsd"</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>	// osHasLowResClockInt is osHasLowResClock but in integer form, so it can be used to create</code></span>
<span class="codeline" id="line-943"><code>	// constants conditionally.</code></span>
<span class="codeline" id="line-944"><code>	osHasLowResClockInt = goos.IsWindows</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>	// osHasLowResClock indicates that timestamps produced by nanotime on the platform have a</code></span>
<span class="codeline" id="line-947"><code>	// low resolution, typically on the order of 1 ms or more.</code></span>
<span class="codeline" id="line-948"><code>	osHasLowResClock = osHasLowResClockInt &gt; 0</code></span>
<span class="codeline" id="line-949"><code>)</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>// Mark gp ready to run.</code></span>
<span class="codeline" id="line-952"><code>func ready(gp *g, traceskip int, next bool) {</code></span>
<span class="codeline" id="line-953"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-954"><code></code></span>
<span class="codeline" id="line-955"><code>	// Mark runnable.</code></span>
<span class="codeline" id="line-956"><code>	mp := acquirem() // disable preemption because it can be holding p in a local var</code></span>
<span class="codeline" id="line-957"><code>	if status&amp;^_Gscan != _Gwaiting {</code></span>
<span class="codeline" id="line-958"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-959"><code>		throw("bad g-&gt;status in ready")</code></span>
<span class="codeline" id="line-960"><code>	}</code></span>
<span class="codeline" id="line-961"><code></code></span>
<span class="codeline" id="line-962"><code>	// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</code></span>
<span class="codeline" id="line-963"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-964"><code>	casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-965"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-966"><code>		trace.GoUnpark(gp, traceskip)</code></span>
<span class="codeline" id="line-967"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-968"><code>	}</code></span>
<span class="codeline" id="line-969"><code>	runqput(mp.p.ptr(), gp, next)</code></span>
<span class="codeline" id="line-970"><code>	wakep()</code></span>
<span class="codeline" id="line-971"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-972"><code>}</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>// freezeStopWait is a large value that freezetheworld sets</code></span>
<span class="codeline" id="line-975"><code>// sched.stopwait to in order to request that all Gs permanently stop.</code></span>
<span class="codeline" id="line-976"><code>const freezeStopWait = 0x7fffffff</code></span>
<span class="codeline" id="line-977"><code></code></span>
<span class="codeline" id="line-978"><code>// freezing is set to non-zero if the runtime is trying to freeze the</code></span>
<span class="codeline" id="line-979"><code>// world.</code></span>
<span class="codeline" id="line-980"><code>var freezing atomic.Bool</code></span>
<span class="codeline" id="line-981"><code></code></span>
<span class="codeline" id="line-982"><code>// Similar to stopTheWorld but best-effort and can be called several times.</code></span>
<span class="codeline" id="line-983"><code>// There is no reverse operation, used during crashing.</code></span>
<span class="codeline" id="line-984"><code>// This function must not lock any mutexes.</code></span>
<span class="codeline" id="line-985"><code>func freezetheworld() {</code></span>
<span class="codeline" id="line-986"><code>	freezing.Store(true)</code></span>
<span class="codeline" id="line-987"><code>	if debug.dontfreezetheworld &gt; 0 {</code></span>
<span class="codeline" id="line-988"><code>		// Don't prempt Ps to stop goroutines. That will perturb</code></span>
<span class="codeline" id="line-989"><code>		// scheduler state, making debugging more difficult. Instead,</code></span>
<span class="codeline" id="line-990"><code>		// allow goroutines to continue execution.</code></span>
<span class="codeline" id="line-991"><code>		//</code></span>
<span class="codeline" id="line-992"><code>		// fatalpanic will tracebackothers to trace all goroutines. It</code></span>
<span class="codeline" id="line-993"><code>		// is unsafe to trace a running goroutine, so tracebackothers</code></span>
<span class="codeline" id="line-994"><code>		// will skip running goroutines. That is OK and expected, we</code></span>
<span class="codeline" id="line-995"><code>		// expect users of dontfreezetheworld to use core files anyway.</code></span>
<span class="codeline" id="line-996"><code>		//</code></span>
<span class="codeline" id="line-997"><code>		// However, allowing the scheduler to continue running free</code></span>
<span class="codeline" id="line-998"><code>		// introduces a race: a goroutine may be stopped when</code></span>
<span class="codeline" id="line-999"><code>		// tracebackothers checks its status, and then start running</code></span>
<span class="codeline" id="line-1000"><code>		// later when we are in the middle of traceback, potentially</code></span>
<span class="codeline" id="line-1001"><code>		// causing a crash.</code></span>
<span class="codeline" id="line-1002"><code>		//</code></span>
<span class="codeline" id="line-1003"><code>		// To mitigate this, when an M naturally enters the scheduler,</code></span>
<span class="codeline" id="line-1004"><code>		// schedule checks if freezing is set and if so stops</code></span>
<span class="codeline" id="line-1005"><code>		// execution. This guarantees that while Gs can transition from</code></span>
<span class="codeline" id="line-1006"><code>		// running to stopped, they can never transition from stopped</code></span>
<span class="codeline" id="line-1007"><code>		// to running.</code></span>
<span class="codeline" id="line-1008"><code>		//</code></span>
<span class="codeline" id="line-1009"><code>		// The sleep here allows racing Ms that missed freezing and are</code></span>
<span class="codeline" id="line-1010"><code>		// about to run a G to complete the transition to running</code></span>
<span class="codeline" id="line-1011"><code>		// before we start traceback.</code></span>
<span class="codeline" id="line-1012"><code>		usleep(1000)</code></span>
<span class="codeline" id="line-1013"><code>		return</code></span>
<span class="codeline" id="line-1014"><code>	}</code></span>
<span class="codeline" id="line-1015"><code></code></span>
<span class="codeline" id="line-1016"><code>	// stopwait and preemption requests can be lost</code></span>
<span class="codeline" id="line-1017"><code>	// due to races with concurrently executing threads,</code></span>
<span class="codeline" id="line-1018"><code>	// so try several times</code></span>
<span class="codeline" id="line-1019"><code>	for i := 0; i &lt; 5; i++ {</code></span>
<span class="codeline" id="line-1020"><code>		// this should tell the scheduler to not start any new goroutines</code></span>
<span class="codeline" id="line-1021"><code>		sched.stopwait = freezeStopWait</code></span>
<span class="codeline" id="line-1022"><code>		sched.gcwaiting.Store(true)</code></span>
<span class="codeline" id="line-1023"><code>		// this should stop running goroutines</code></span>
<span class="codeline" id="line-1024"><code>		if !preemptall() {</code></span>
<span class="codeline" id="line-1025"><code>			break // no running goroutines</code></span>
<span class="codeline" id="line-1026"><code>		}</code></span>
<span class="codeline" id="line-1027"><code>		usleep(1000)</code></span>
<span class="codeline" id="line-1028"><code>	}</code></span>
<span class="codeline" id="line-1029"><code>	// to be sure</code></span>
<span class="codeline" id="line-1030"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-1031"><code>	preemptall()</code></span>
<span class="codeline" id="line-1032"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-1033"><code>}</code></span>
<span class="codeline" id="line-1034"><code></code></span>
<span class="codeline" id="line-1035"><code>// All reads and writes of g's status go through readgstatus, casgstatus</code></span>
<span class="codeline" id="line-1036"><code>// castogscanstatus, casfrom_Gscanstatus.</code></span>
<span class="codeline" id="line-1037"><code>//</code></span>
<span class="codeline" id="line-1038"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1039"><code>func readgstatus(gp *g) uint32 {</code></span>
<span class="codeline" id="line-1040"><code>	return gp.atomicstatus.Load()</code></span>
<span class="codeline" id="line-1041"><code>}</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>// The Gscanstatuses are acting like locks and this releases them.</code></span>
<span class="codeline" id="line-1044"><code>// If it proves to be a performance hit we should be able to make these</code></span>
<span class="codeline" id="line-1045"><code>// simple atomic stores but for now we are going to throw if</code></span>
<span class="codeline" id="line-1046"><code>// we see an inconsistent state.</code></span>
<span class="codeline" id="line-1047"><code>func casfrom_Gscanstatus(gp *g, oldval, newval uint32) {</code></span>
<span class="codeline" id="line-1048"><code>	success := false</code></span>
<span class="codeline" id="line-1049"><code></code></span>
<span class="codeline" id="line-1050"><code>	// Check that transition is valid.</code></span>
<span class="codeline" id="line-1051"><code>	switch oldval {</code></span>
<span class="codeline" id="line-1052"><code>	default:</code></span>
<span class="codeline" id="line-1053"><code>		print("runtime: casfrom_Gscanstatus bad oldval gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-1054"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-1055"><code>		throw("casfrom_Gscanstatus:top gp-&gt;status is not in scan state")</code></span>
<span class="codeline" id="line-1056"><code>	case _Gscanrunnable,</code></span>
<span class="codeline" id="line-1057"><code>		_Gscanwaiting,</code></span>
<span class="codeline" id="line-1058"><code>		_Gscanrunning,</code></span>
<span class="codeline" id="line-1059"><code>		_Gscansyscall,</code></span>
<span class="codeline" id="line-1060"><code>		_Gscanpreempted:</code></span>
<span class="codeline" id="line-1061"><code>		if newval == oldval&amp;^_Gscan {</code></span>
<span class="codeline" id="line-1062"><code>			success = gp.atomicstatus.CompareAndSwap(oldval, newval)</code></span>
<span class="codeline" id="line-1063"><code>		}</code></span>
<span class="codeline" id="line-1064"><code>	}</code></span>
<span class="codeline" id="line-1065"><code>	if !success {</code></span>
<span class="codeline" id="line-1066"><code>		print("runtime: casfrom_Gscanstatus failed gp=", gp, ", oldval=", hex(oldval), ", newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-1067"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-1068"><code>		throw("casfrom_Gscanstatus: gp-&gt;status is not in scan state")</code></span>
<span class="codeline" id="line-1069"><code>	}</code></span>
<span class="codeline" id="line-1070"><code>	releaseLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-1071"><code>}</code></span>
<span class="codeline" id="line-1072"><code></code></span>
<span class="codeline" id="line-1073"><code>// This will return false if the gp is not in the expected status and the cas fails.</code></span>
<span class="codeline" id="line-1074"><code>// This acts like a lock acquire while the casfromgstatus acts like a lock release.</code></span>
<span class="codeline" id="line-1075"><code>func castogscanstatus(gp *g, oldval, newval uint32) bool {</code></span>
<span class="codeline" id="line-1076"><code>	switch oldval {</code></span>
<span class="codeline" id="line-1077"><code>	case _Grunnable,</code></span>
<span class="codeline" id="line-1078"><code>		_Grunning,</code></span>
<span class="codeline" id="line-1079"><code>		_Gwaiting,</code></span>
<span class="codeline" id="line-1080"><code>		_Gsyscall:</code></span>
<span class="codeline" id="line-1081"><code>		if newval == oldval|_Gscan {</code></span>
<span class="codeline" id="line-1082"><code>			r := gp.atomicstatus.CompareAndSwap(oldval, newval)</code></span>
<span class="codeline" id="line-1083"><code>			if r {</code></span>
<span class="codeline" id="line-1084"><code>				acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-1085"><code>			}</code></span>
<span class="codeline" id="line-1086"><code>			return r</code></span>
<span class="codeline" id="line-1087"><code></code></span>
<span class="codeline" id="line-1088"><code>		}</code></span>
<span class="codeline" id="line-1089"><code>	}</code></span>
<span class="codeline" id="line-1090"><code>	print("runtime: castogscanstatus oldval=", hex(oldval), " newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-1091"><code>	throw("castogscanstatus")</code></span>
<span class="codeline" id="line-1092"><code>	panic("not reached")</code></span>
<span class="codeline" id="line-1093"><code>}</code></span>
<span class="codeline" id="line-1094"><code></code></span>
<span class="codeline" id="line-1095"><code>// casgstatusAlwaysTrack is a debug flag that causes casgstatus to always track</code></span>
<span class="codeline" id="line-1096"><code>// various latencies on every transition instead of sampling them.</code></span>
<span class="codeline" id="line-1097"><code>var casgstatusAlwaysTrack = false</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>// If asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus</code></span>
<span class="codeline" id="line-1100"><code>// and casfrom_Gscanstatus instead.</code></span>
<span class="codeline" id="line-1101"><code>// casgstatus will loop if the g-&gt;atomicstatus is in a Gscan status until the routine that</code></span>
<span class="codeline" id="line-1102"><code>// put it in the Gscan state is finished.</code></span>
<span class="codeline" id="line-1103"><code>//</code></span>
<span class="codeline" id="line-1104"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1105"><code>func casgstatus(gp *g, oldval, newval uint32) {</code></span>
<span class="codeline" id="line-1106"><code>	if (oldval&amp;_Gscan != 0) || (newval&amp;_Gscan != 0) || oldval == newval {</code></span>
<span class="codeline" id="line-1107"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-1108"><code>			print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n")</code></span>
<span class="codeline" id="line-1109"><code>			throw("casgstatus: bad incoming values")</code></span>
<span class="codeline" id="line-1110"><code>		})</code></span>
<span class="codeline" id="line-1111"><code>	}</code></span>
<span class="codeline" id="line-1112"><code></code></span>
<span class="codeline" id="line-1113"><code>	acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-1114"><code>	releaseLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-1115"><code></code></span>
<span class="codeline" id="line-1116"><code>	// See https://golang.org/cl/21503 for justification of the yield delay.</code></span>
<span class="codeline" id="line-1117"><code>	const yieldDelay = 5 * 1000</code></span>
<span class="codeline" id="line-1118"><code>	var nextYield int64</code></span>
<span class="codeline" id="line-1119"><code></code></span>
<span class="codeline" id="line-1120"><code>	// loop if gp-&gt;atomicstatus is in a scan state giving</code></span>
<span class="codeline" id="line-1121"><code>	// GC time to finish and change the state to oldval.</code></span>
<span class="codeline" id="line-1122"><code>	for i := 0; !gp.atomicstatus.CompareAndSwap(oldval, newval); i++ {</code></span>
<span class="codeline" id="line-1123"><code>		if oldval == _Gwaiting &amp;&amp; gp.atomicstatus.Load() == _Grunnable {</code></span>
<span class="codeline" id="line-1124"><code>			throw("casgstatus: waiting for Gwaiting but is Grunnable")</code></span>
<span class="codeline" id="line-1125"><code>		}</code></span>
<span class="codeline" id="line-1126"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-1127"><code>			nextYield = nanotime() + yieldDelay</code></span>
<span class="codeline" id="line-1128"><code>		}</code></span>
<span class="codeline" id="line-1129"><code>		if nanotime() &lt; nextYield {</code></span>
<span class="codeline" id="line-1130"><code>			for x := 0; x &lt; 10 &amp;&amp; gp.atomicstatus.Load() != oldval; x++ {</code></span>
<span class="codeline" id="line-1131"><code>				procyield(1)</code></span>
<span class="codeline" id="line-1132"><code>			}</code></span>
<span class="codeline" id="line-1133"><code>		} else {</code></span>
<span class="codeline" id="line-1134"><code>			osyield()</code></span>
<span class="codeline" id="line-1135"><code>			nextYield = nanotime() + yieldDelay/2</code></span>
<span class="codeline" id="line-1136"><code>		}</code></span>
<span class="codeline" id="line-1137"><code>	}</code></span>
<span class="codeline" id="line-1138"><code></code></span>
<span class="codeline" id="line-1139"><code>	if oldval == _Grunning {</code></span>
<span class="codeline" id="line-1140"><code>		// Track every gTrackingPeriod time a goroutine transitions out of running.</code></span>
<span class="codeline" id="line-1141"><code>		if casgstatusAlwaysTrack || gp.trackingSeq%gTrackingPeriod == 0 {</code></span>
<span class="codeline" id="line-1142"><code>			gp.tracking = true</code></span>
<span class="codeline" id="line-1143"><code>		}</code></span>
<span class="codeline" id="line-1144"><code>		gp.trackingSeq++</code></span>
<span class="codeline" id="line-1145"><code>	}</code></span>
<span class="codeline" id="line-1146"><code>	if !gp.tracking {</code></span>
<span class="codeline" id="line-1147"><code>		return</code></span>
<span class="codeline" id="line-1148"><code>	}</code></span>
<span class="codeline" id="line-1149"><code></code></span>
<span class="codeline" id="line-1150"><code>	// Handle various kinds of tracking.</code></span>
<span class="codeline" id="line-1151"><code>	//</code></span>
<span class="codeline" id="line-1152"><code>	// Currently:</code></span>
<span class="codeline" id="line-1153"><code>	// - Time spent in runnable.</code></span>
<span class="codeline" id="line-1154"><code>	// - Time spent blocked on a sync.Mutex or sync.RWMutex.</code></span>
<span class="codeline" id="line-1155"><code>	switch oldval {</code></span>
<span class="codeline" id="line-1156"><code>	case _Grunnable:</code></span>
<span class="codeline" id="line-1157"><code>		// We transitioned out of runnable, so measure how much</code></span>
<span class="codeline" id="line-1158"><code>		// time we spent in this state and add it to</code></span>
<span class="codeline" id="line-1159"><code>		// runnableTime.</code></span>
<span class="codeline" id="line-1160"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-1161"><code>		gp.runnableTime += now - gp.trackingStamp</code></span>
<span class="codeline" id="line-1162"><code>		gp.trackingStamp = 0</code></span>
<span class="codeline" id="line-1163"><code>	case _Gwaiting:</code></span>
<span class="codeline" id="line-1164"><code>		if !gp.waitreason.isMutexWait() {</code></span>
<span class="codeline" id="line-1165"><code>			// Not blocking on a lock.</code></span>
<span class="codeline" id="line-1166"><code>			break</code></span>
<span class="codeline" id="line-1167"><code>		}</code></span>
<span class="codeline" id="line-1168"><code>		// Blocking on a lock, measure it. Note that because we're</code></span>
<span class="codeline" id="line-1169"><code>		// sampling, we have to multiply by our sampling period to get</code></span>
<span class="codeline" id="line-1170"><code>		// a more representative estimate of the absolute value.</code></span>
<span class="codeline" id="line-1171"><code>		// gTrackingPeriod also represents an accurate sampling period</code></span>
<span class="codeline" id="line-1172"><code>		// because we can only enter this state from _Grunning.</code></span>
<span class="codeline" id="line-1173"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-1174"><code>		sched.totalMutexWaitTime.Add((now - gp.trackingStamp) * gTrackingPeriod)</code></span>
<span class="codeline" id="line-1175"><code>		gp.trackingStamp = 0</code></span>
<span class="codeline" id="line-1176"><code>	}</code></span>
<span class="codeline" id="line-1177"><code>	switch newval {</code></span>
<span class="codeline" id="line-1178"><code>	case _Gwaiting:</code></span>
<span class="codeline" id="line-1179"><code>		if !gp.waitreason.isMutexWait() {</code></span>
<span class="codeline" id="line-1180"><code>			// Not blocking on a lock.</code></span>
<span class="codeline" id="line-1181"><code>			break</code></span>
<span class="codeline" id="line-1182"><code>		}</code></span>
<span class="codeline" id="line-1183"><code>		// Blocking on a lock. Write down the timestamp.</code></span>
<span class="codeline" id="line-1184"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-1185"><code>		gp.trackingStamp = now</code></span>
<span class="codeline" id="line-1186"><code>	case _Grunnable:</code></span>
<span class="codeline" id="line-1187"><code>		// We just transitioned into runnable, so record what</code></span>
<span class="codeline" id="line-1188"><code>		// time that happened.</code></span>
<span class="codeline" id="line-1189"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-1190"><code>		gp.trackingStamp = now</code></span>
<span class="codeline" id="line-1191"><code>	case _Grunning:</code></span>
<span class="codeline" id="line-1192"><code>		// We're transitioning into running, so turn off</code></span>
<span class="codeline" id="line-1193"><code>		// tracking and record how much time we spent in</code></span>
<span class="codeline" id="line-1194"><code>		// runnable.</code></span>
<span class="codeline" id="line-1195"><code>		gp.tracking = false</code></span>
<span class="codeline" id="line-1196"><code>		sched.timeToRun.record(gp.runnableTime)</code></span>
<span class="codeline" id="line-1197"><code>		gp.runnableTime = 0</code></span>
<span class="codeline" id="line-1198"><code>	}</code></span>
<span class="codeline" id="line-1199"><code>}</code></span>
<span class="codeline" id="line-1200"><code></code></span>
<span class="codeline" id="line-1201"><code>// casGToWaiting transitions gp from old to _Gwaiting, and sets the wait reason.</code></span>
<span class="codeline" id="line-1202"><code>//</code></span>
<span class="codeline" id="line-1203"><code>// Use this over casgstatus when possible to ensure that a waitreason is set.</code></span>
<span class="codeline" id="line-1204"><code>func casGToWaiting(gp *g, old uint32, reason waitReason) {</code></span>
<span class="codeline" id="line-1205"><code>	// Set the wait reason before calling casgstatus, because casgstatus will use it.</code></span>
<span class="codeline" id="line-1206"><code>	gp.waitreason = reason</code></span>
<span class="codeline" id="line-1207"><code>	casgstatus(gp, old, _Gwaiting)</code></span>
<span class="codeline" id="line-1208"><code>}</code></span>
<span class="codeline" id="line-1209"><code></code></span>
<span class="codeline" id="line-1210"><code>// casgstatus(gp, oldstatus, Gcopystack), assuming oldstatus is Gwaiting or Grunnable.</code></span>
<span class="codeline" id="line-1211"><code>// Returns old status. Cannot call casgstatus directly, because we are racing with an</code></span>
<span class="codeline" id="line-1212"><code>// async wakeup that might come in from netpoll. If we see Gwaiting from the readgstatus,</code></span>
<span class="codeline" id="line-1213"><code>// it might have become Grunnable by the time we get to the cas. If we called casgstatus,</code></span>
<span class="codeline" id="line-1214"><code>// it would loop waiting for the status to go back to Gwaiting, which it never will.</code></span>
<span class="codeline" id="line-1215"><code>//</code></span>
<span class="codeline" id="line-1216"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1217"><code>func casgcopystack(gp *g) uint32 {</code></span>
<span class="codeline" id="line-1218"><code>	for {</code></span>
<span class="codeline" id="line-1219"><code>		oldstatus := readgstatus(gp) &amp;^ _Gscan</code></span>
<span class="codeline" id="line-1220"><code>		if oldstatus != _Gwaiting &amp;&amp; oldstatus != _Grunnable {</code></span>
<span class="codeline" id="line-1221"><code>			throw("copystack: bad status, not Gwaiting or Grunnable")</code></span>
<span class="codeline" id="line-1222"><code>		}</code></span>
<span class="codeline" id="line-1223"><code>		if gp.atomicstatus.CompareAndSwap(oldstatus, _Gcopystack) {</code></span>
<span class="codeline" id="line-1224"><code>			return oldstatus</code></span>
<span class="codeline" id="line-1225"><code>		}</code></span>
<span class="codeline" id="line-1226"><code>	}</code></span>
<span class="codeline" id="line-1227"><code>}</code></span>
<span class="codeline" id="line-1228"><code></code></span>
<span class="codeline" id="line-1229"><code>// casGToPreemptScan transitions gp from _Grunning to _Gscan|_Gpreempted.</code></span>
<span class="codeline" id="line-1230"><code>//</code></span>
<span class="codeline" id="line-1231"><code>// TODO(austin): This is the only status operation that both changes</code></span>
<span class="codeline" id="line-1232"><code>// the status and locks the _Gscan bit. Rethink this.</code></span>
<span class="codeline" id="line-1233"><code>func casGToPreemptScan(gp *g, old, new uint32) {</code></span>
<span class="codeline" id="line-1234"><code>	if old != _Grunning || new != _Gscan|_Gpreempted {</code></span>
<span class="codeline" id="line-1235"><code>		throw("bad g transition")</code></span>
<span class="codeline" id="line-1236"><code>	}</code></span>
<span class="codeline" id="line-1237"><code>	acquireLockRank(lockRankGscan)</code></span>
<span class="codeline" id="line-1238"><code>	for !gp.atomicstatus.CompareAndSwap(_Grunning, _Gscan|_Gpreempted) {</code></span>
<span class="codeline" id="line-1239"><code>	}</code></span>
<span class="codeline" id="line-1240"><code>}</code></span>
<span class="codeline" id="line-1241"><code></code></span>
<span class="codeline" id="line-1242"><code>// casGFromPreempted attempts to transition gp from _Gpreempted to</code></span>
<span class="codeline" id="line-1243"><code>// _Gwaiting. If successful, the caller is responsible for</code></span>
<span class="codeline" id="line-1244"><code>// re-scheduling gp.</code></span>
<span class="codeline" id="line-1245"><code>func casGFromPreempted(gp *g, old, new uint32) bool {</code></span>
<span class="codeline" id="line-1246"><code>	if old != _Gpreempted || new != _Gwaiting {</code></span>
<span class="codeline" id="line-1247"><code>		throw("bad g transition")</code></span>
<span class="codeline" id="line-1248"><code>	}</code></span>
<span class="codeline" id="line-1249"><code>	gp.waitreason = waitReasonPreempted</code></span>
<span class="codeline" id="line-1250"><code>	return gp.atomicstatus.CompareAndSwap(_Gpreempted, _Gwaiting)</code></span>
<span class="codeline" id="line-1251"><code>}</code></span>
<span class="codeline" id="line-1252"><code></code></span>
<span class="codeline" id="line-1253"><code>// stwReason is an enumeration of reasons the world is stopping.</code></span>
<span class="codeline" id="line-1254"><code>type stwReason uint8</code></span>
<span class="codeline" id="line-1255"><code></code></span>
<span class="codeline" id="line-1256"><code>// Reasons to stop-the-world.</code></span>
<span class="codeline" id="line-1257"><code>//</code></span>
<span class="codeline" id="line-1258"><code>// Avoid reusing reasons and add new ones instead.</code></span>
<span class="codeline" id="line-1259"><code>const (</code></span>
<span class="codeline" id="line-1260"><code>	stwUnknown                     stwReason = iota // "unknown"</code></span>
<span class="codeline" id="line-1261"><code>	stwGCMarkTerm                                   // "GC mark termination"</code></span>
<span class="codeline" id="line-1262"><code>	stwGCSweepTerm                                  // "GC sweep termination"</code></span>
<span class="codeline" id="line-1263"><code>	stwWriteHeapDump                                // "write heap dump"</code></span>
<span class="codeline" id="line-1264"><code>	stwGoroutineProfile                             // "goroutine profile"</code></span>
<span class="codeline" id="line-1265"><code>	stwGoroutineProfileCleanup                      // "goroutine profile cleanup"</code></span>
<span class="codeline" id="line-1266"><code>	stwAllGoroutinesStack                           // "all goroutines stack trace"</code></span>
<span class="codeline" id="line-1267"><code>	stwReadMemStats                                 // "read mem stats"</code></span>
<span class="codeline" id="line-1268"><code>	stwAllThreadsSyscall                            // "AllThreadsSyscall"</code></span>
<span class="codeline" id="line-1269"><code>	stwGOMAXPROCS                                   // "GOMAXPROCS"</code></span>
<span class="codeline" id="line-1270"><code>	stwStartTrace                                   // "start trace"</code></span>
<span class="codeline" id="line-1271"><code>	stwStopTrace                                    // "stop trace"</code></span>
<span class="codeline" id="line-1272"><code>	stwForTestCountPagesInUse                       // "CountPagesInUse (test)"</code></span>
<span class="codeline" id="line-1273"><code>	stwForTestReadMetricsSlow                       // "ReadMetricsSlow (test)"</code></span>
<span class="codeline" id="line-1274"><code>	stwForTestReadMemStatsSlow                      // "ReadMemStatsSlow (test)"</code></span>
<span class="codeline" id="line-1275"><code>	stwForTestPageCachePagesLeaked                  // "PageCachePagesLeaked (test)"</code></span>
<span class="codeline" id="line-1276"><code>	stwForTestResetDebugLog                         // "ResetDebugLog (test)"</code></span>
<span class="codeline" id="line-1277"><code>)</code></span>
<span class="codeline" id="line-1278"><code></code></span>
<span class="codeline" id="line-1279"><code>func (r stwReason) String() string {</code></span>
<span class="codeline" id="line-1280"><code>	return stwReasonStrings[r]</code></span>
<span class="codeline" id="line-1281"><code>}</code></span>
<span class="codeline" id="line-1282"><code></code></span>
<span class="codeline" id="line-1283"><code>func (r stwReason) isGC() bool {</code></span>
<span class="codeline" id="line-1284"><code>	return r == stwGCMarkTerm || r == stwGCSweepTerm</code></span>
<span class="codeline" id="line-1285"><code>}</code></span>
<span class="codeline" id="line-1286"><code></code></span>
<span class="codeline" id="line-1287"><code>// If you add to this list, also add it to src/internal/trace/parser.go.</code></span>
<span class="codeline" id="line-1288"><code>// If you change the values of any of the stw* constants, bump the trace</code></span>
<span class="codeline" id="line-1289"><code>// version number and make a copy of this.</code></span>
<span class="codeline" id="line-1290"><code>var stwReasonStrings = [...]string{</code></span>
<span class="codeline" id="line-1291"><code>	stwUnknown:                     "unknown",</code></span>
<span class="codeline" id="line-1292"><code>	stwGCMarkTerm:                  "GC mark termination",</code></span>
<span class="codeline" id="line-1293"><code>	stwGCSweepTerm:                 "GC sweep termination",</code></span>
<span class="codeline" id="line-1294"><code>	stwWriteHeapDump:               "write heap dump",</code></span>
<span class="codeline" id="line-1295"><code>	stwGoroutineProfile:            "goroutine profile",</code></span>
<span class="codeline" id="line-1296"><code>	stwGoroutineProfileCleanup:     "goroutine profile cleanup",</code></span>
<span class="codeline" id="line-1297"><code>	stwAllGoroutinesStack:          "all goroutines stack trace",</code></span>
<span class="codeline" id="line-1298"><code>	stwReadMemStats:                "read mem stats",</code></span>
<span class="codeline" id="line-1299"><code>	stwAllThreadsSyscall:           "AllThreadsSyscall",</code></span>
<span class="codeline" id="line-1300"><code>	stwGOMAXPROCS:                  "GOMAXPROCS",</code></span>
<span class="codeline" id="line-1301"><code>	stwStartTrace:                  "start trace",</code></span>
<span class="codeline" id="line-1302"><code>	stwStopTrace:                   "stop trace",</code></span>
<span class="codeline" id="line-1303"><code>	stwForTestCountPagesInUse:      "CountPagesInUse (test)",</code></span>
<span class="codeline" id="line-1304"><code>	stwForTestReadMetricsSlow:      "ReadMetricsSlow (test)",</code></span>
<span class="codeline" id="line-1305"><code>	stwForTestReadMemStatsSlow:     "ReadMemStatsSlow (test)",</code></span>
<span class="codeline" id="line-1306"><code>	stwForTestPageCachePagesLeaked: "PageCachePagesLeaked (test)",</code></span>
<span class="codeline" id="line-1307"><code>	stwForTestResetDebugLog:        "ResetDebugLog (test)",</code></span>
<span class="codeline" id="line-1308"><code>}</code></span>
<span class="codeline" id="line-1309"><code></code></span>
<span class="codeline" id="line-1310"><code>// worldStop provides context from the stop-the-world required by the</code></span>
<span class="codeline" id="line-1311"><code>// start-the-world.</code></span>
<span class="codeline" id="line-1312"><code>type worldStop struct {</code></span>
<span class="codeline" id="line-1313"><code>	reason stwReason</code></span>
<span class="codeline" id="line-1314"><code>	start  int64</code></span>
<span class="codeline" id="line-1315"><code>}</code></span>
<span class="codeline" id="line-1316"><code></code></span>
<span class="codeline" id="line-1317"><code>// Temporary variable for stopTheWorld, when it can't write to the stack.</code></span>
<span class="codeline" id="line-1318"><code>//</code></span>
<span class="codeline" id="line-1319"><code>// Protected by worldsema.</code></span>
<span class="codeline" id="line-1320"><code>var stopTheWorldContext worldStop</code></span>
<span class="codeline" id="line-1321"><code></code></span>
<span class="codeline" id="line-1322"><code>// stopTheWorld stops all P's from executing goroutines, interrupting</code></span>
<span class="codeline" id="line-1323"><code>// all goroutines at GC safe points and records reason as the reason</code></span>
<span class="codeline" id="line-1324"><code>// for the stop. On return, only the current goroutine's P is running.</code></span>
<span class="codeline" id="line-1325"><code>// stopTheWorld must not be called from a system stack and the caller</code></span>
<span class="codeline" id="line-1326"><code>// must not hold worldsema. The caller must call startTheWorld when</code></span>
<span class="codeline" id="line-1327"><code>// other P's should resume execution.</code></span>
<span class="codeline" id="line-1328"><code>//</code></span>
<span class="codeline" id="line-1329"><code>// stopTheWorld is safe for multiple goroutines to call at the</code></span>
<span class="codeline" id="line-1330"><code>// same time. Each will execute its own stop, and the stops will</code></span>
<span class="codeline" id="line-1331"><code>// be serialized.</code></span>
<span class="codeline" id="line-1332"><code>//</code></span>
<span class="codeline" id="line-1333"><code>// This is also used by routines that do stack dumps. If the system is</code></span>
<span class="codeline" id="line-1334"><code>// in panic or being exited, this may not reliably stop all</code></span>
<span class="codeline" id="line-1335"><code>// goroutines.</code></span>
<span class="codeline" id="line-1336"><code>//</code></span>
<span class="codeline" id="line-1337"><code>// Returns the STW context. When starting the world, this context must be</code></span>
<span class="codeline" id="line-1338"><code>// passed to startTheWorld.</code></span>
<span class="codeline" id="line-1339"><code>func stopTheWorld(reason stwReason) worldStop {</code></span>
<span class="codeline" id="line-1340"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-1341"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1342"><code>	gp.m.preemptoff = reason.String()</code></span>
<span class="codeline" id="line-1343"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1344"><code>		// Mark the goroutine which called stopTheWorld preemptible so its</code></span>
<span class="codeline" id="line-1345"><code>		// stack may be scanned.</code></span>
<span class="codeline" id="line-1346"><code>		// This lets a mark worker scan us while we try to stop the world</code></span>
<span class="codeline" id="line-1347"><code>		// since otherwise we could get in a mutual preemption deadlock.</code></span>
<span class="codeline" id="line-1348"><code>		// We must not modify anything on the G stack because a stack shrink</code></span>
<span class="codeline" id="line-1349"><code>		// may occur. A stack shrink is otherwise OK though because in order</code></span>
<span class="codeline" id="line-1350"><code>		// to return from this function (and to leave the system stack) we</code></span>
<span class="codeline" id="line-1351"><code>		// must have preempted all goroutines, including any attempting</code></span>
<span class="codeline" id="line-1352"><code>		// to scan our stack, in which case, any stack shrinking will</code></span>
<span class="codeline" id="line-1353"><code>		// have already completed by the time we exit.</code></span>
<span class="codeline" id="line-1354"><code>		//</code></span>
<span class="codeline" id="line-1355"><code>		// N.B. The execution tracer is not aware of this status</code></span>
<span class="codeline" id="line-1356"><code>		// transition and handles it specially based on the</code></span>
<span class="codeline" id="line-1357"><code>		// wait reason.</code></span>
<span class="codeline" id="line-1358"><code>		casGToWaiting(gp, _Grunning, waitReasonStoppingTheWorld)</code></span>
<span class="codeline" id="line-1359"><code>		stopTheWorldContext = stopTheWorldWithSema(reason) // avoid write to stack</code></span>
<span class="codeline" id="line-1360"><code>		casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1361"><code>	})</code></span>
<span class="codeline" id="line-1362"><code>	return stopTheWorldContext</code></span>
<span class="codeline" id="line-1363"><code>}</code></span>
<span class="codeline" id="line-1364"><code></code></span>
<span class="codeline" id="line-1365"><code>// startTheWorld undoes the effects of stopTheWorld.</code></span>
<span class="codeline" id="line-1366"><code>//</code></span>
<span class="codeline" id="line-1367"><code>// w must be the worldStop returned by stopTheWorld.</code></span>
<span class="codeline" id="line-1368"><code>func startTheWorld(w worldStop) {</code></span>
<span class="codeline" id="line-1369"><code>	systemstack(func() { startTheWorldWithSema(0, w) })</code></span>
<span class="codeline" id="line-1370"><code></code></span>
<span class="codeline" id="line-1371"><code>	// worldsema must be held over startTheWorldWithSema to ensure</code></span>
<span class="codeline" id="line-1372"><code>	// gomaxprocs cannot change while worldsema is held.</code></span>
<span class="codeline" id="line-1373"><code>	//</code></span>
<span class="codeline" id="line-1374"><code>	// Release worldsema with direct handoff to the next waiter, but</code></span>
<span class="codeline" id="line-1375"><code>	// acquirem so that semrelease1 doesn't try to yield our time.</code></span>
<span class="codeline" id="line-1376"><code>	//</code></span>
<span class="codeline" id="line-1377"><code>	// Otherwise if e.g. ReadMemStats is being called in a loop,</code></span>
<span class="codeline" id="line-1378"><code>	// it might stomp on other attempts to stop the world, such as</code></span>
<span class="codeline" id="line-1379"><code>	// for starting or ending GC. The operation this blocks is</code></span>
<span class="codeline" id="line-1380"><code>	// so heavy-weight that we should just try to be as fair as</code></span>
<span class="codeline" id="line-1381"><code>	// possible here.</code></span>
<span class="codeline" id="line-1382"><code>	//</code></span>
<span class="codeline" id="line-1383"><code>	// We don't want to just allow us to get preempted between now</code></span>
<span class="codeline" id="line-1384"><code>	// and releasing the semaphore because then we keep everyone</code></span>
<span class="codeline" id="line-1385"><code>	// (including, for example, GCs) waiting longer.</code></span>
<span class="codeline" id="line-1386"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1387"><code>	mp.preemptoff = ""</code></span>
<span class="codeline" id="line-1388"><code>	semrelease1(&amp;worldsema, true, 0)</code></span>
<span class="codeline" id="line-1389"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1390"><code>}</code></span>
<span class="codeline" id="line-1391"><code></code></span>
<span class="codeline" id="line-1392"><code>// stopTheWorldGC has the same effect as stopTheWorld, but blocks</code></span>
<span class="codeline" id="line-1393"><code>// until the GC is not running. It also blocks a GC from starting</code></span>
<span class="codeline" id="line-1394"><code>// until startTheWorldGC is called.</code></span>
<span class="codeline" id="line-1395"><code>func stopTheWorldGC(reason stwReason) worldStop {</code></span>
<span class="codeline" id="line-1396"><code>	semacquire(&amp;gcsema)</code></span>
<span class="codeline" id="line-1397"><code>	return stopTheWorld(reason)</code></span>
<span class="codeline" id="line-1398"><code>}</code></span>
<span class="codeline" id="line-1399"><code></code></span>
<span class="codeline" id="line-1400"><code>// startTheWorldGC undoes the effects of stopTheWorldGC.</code></span>
<span class="codeline" id="line-1401"><code>//</code></span>
<span class="codeline" id="line-1402"><code>// w must be the worldStop returned by stopTheWorld.</code></span>
<span class="codeline" id="line-1403"><code>func startTheWorldGC(w worldStop) {</code></span>
<span class="codeline" id="line-1404"><code>	startTheWorld(w)</code></span>
<span class="codeline" id="line-1405"><code>	semrelease(&amp;gcsema)</code></span>
<span class="codeline" id="line-1406"><code>}</code></span>
<span class="codeline" id="line-1407"><code></code></span>
<span class="codeline" id="line-1408"><code>// Holding worldsema grants an M the right to try to stop the world.</code></span>
<span class="codeline" id="line-1409"><code>var worldsema uint32 = 1</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>// Holding gcsema grants the M the right to block a GC, and blocks</code></span>
<span class="codeline" id="line-1412"><code>// until the current GC is done. In particular, it prevents gomaxprocs</code></span>
<span class="codeline" id="line-1413"><code>// from changing concurrently.</code></span>
<span class="codeline" id="line-1414"><code>//</code></span>
<span class="codeline" id="line-1415"><code>// TODO(mknyszek): Once gomaxprocs and the execution tracer can handle</code></span>
<span class="codeline" id="line-1416"><code>// being changed/enabled during a GC, remove this.</code></span>
<span class="codeline" id="line-1417"><code>var gcsema uint32 = 1</code></span>
<span class="codeline" id="line-1418"><code></code></span>
<span class="codeline" id="line-1419"><code>// stopTheWorldWithSema is the core implementation of stopTheWorld.</code></span>
<span class="codeline" id="line-1420"><code>// The caller is responsible for acquiring worldsema and disabling</code></span>
<span class="codeline" id="line-1421"><code>// preemption first and then should stopTheWorldWithSema on the system</code></span>
<span class="codeline" id="line-1422"><code>// stack:</code></span>
<span class="codeline" id="line-1423"><code>//</code></span>
<span class="codeline" id="line-1424"><code>//	semacquire(&amp;worldsema, 0)</code></span>
<span class="codeline" id="line-1425"><code>//	m.preemptoff = "reason"</code></span>
<span class="codeline" id="line-1426"><code>//	var stw worldStop</code></span>
<span class="codeline" id="line-1427"><code>//	systemstack(func() {</code></span>
<span class="codeline" id="line-1428"><code>//		stw = stopTheWorldWithSema(reason)</code></span>
<span class="codeline" id="line-1429"><code>//	})</code></span>
<span class="codeline" id="line-1430"><code>//</code></span>
<span class="codeline" id="line-1431"><code>// When finished, the caller must either call startTheWorld or undo</code></span>
<span class="codeline" id="line-1432"><code>// these three operations separately:</code></span>
<span class="codeline" id="line-1433"><code>//</code></span>
<span class="codeline" id="line-1434"><code>//	m.preemptoff = ""</code></span>
<span class="codeline" id="line-1435"><code>//	systemstack(func() {</code></span>
<span class="codeline" id="line-1436"><code>//		now = startTheWorldWithSema(stw)</code></span>
<span class="codeline" id="line-1437"><code>//	})</code></span>
<span class="codeline" id="line-1438"><code>//	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1439"><code>//</code></span>
<span class="codeline" id="line-1440"><code>// It is allowed to acquire worldsema once and then execute multiple</code></span>
<span class="codeline" id="line-1441"><code>// startTheWorldWithSema/stopTheWorldWithSema pairs.</code></span>
<span class="codeline" id="line-1442"><code>// Other P's are able to execute between successive calls to</code></span>
<span class="codeline" id="line-1443"><code>// startTheWorldWithSema and stopTheWorldWithSema.</code></span>
<span class="codeline" id="line-1444"><code>// Holding worldsema causes any other goroutines invoking</code></span>
<span class="codeline" id="line-1445"><code>// stopTheWorld to block.</code></span>
<span class="codeline" id="line-1446"><code>//</code></span>
<span class="codeline" id="line-1447"><code>// Returns the STW context. When starting the world, this context must be</code></span>
<span class="codeline" id="line-1448"><code>// passed to startTheWorldWithSema.</code></span>
<span class="codeline" id="line-1449"><code>func stopTheWorldWithSema(reason stwReason) worldStop {</code></span>
<span class="codeline" id="line-1450"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-1451"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-1452"><code>		trace.STWStart(reason)</code></span>
<span class="codeline" id="line-1453"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-1454"><code>	}</code></span>
<span class="codeline" id="line-1455"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1456"><code></code></span>
<span class="codeline" id="line-1457"><code>	// If we hold a lock, then we won't be able to stop another M</code></span>
<span class="codeline" id="line-1458"><code>	// that is blocked trying to acquire the lock.</code></span>
<span class="codeline" id="line-1459"><code>	if gp.m.locks &gt; 0 {</code></span>
<span class="codeline" id="line-1460"><code>		throw("stopTheWorld: holding locks")</code></span>
<span class="codeline" id="line-1461"><code>	}</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1464"><code>	start := nanotime() // exclude time waiting for sched.lock from start and total time metrics.</code></span>
<span class="codeline" id="line-1465"><code>	sched.stopwait = gomaxprocs</code></span>
<span class="codeline" id="line-1466"><code>	sched.gcwaiting.Store(true)</code></span>
<span class="codeline" id="line-1467"><code>	preemptall()</code></span>
<span class="codeline" id="line-1468"><code>	// stop current P</code></span>
<span class="codeline" id="line-1469"><code>	gp.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.</code></span>
<span class="codeline" id="line-1470"><code>	sched.stopwait--</code></span>
<span class="codeline" id="line-1471"><code>	// try to retake all P's in Psyscall status</code></span>
<span class="codeline" id="line-1472"><code>	trace = traceAcquire()</code></span>
<span class="codeline" id="line-1473"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-1474"><code>		s := pp.status</code></span>
<span class="codeline" id="line-1475"><code>		if s == _Psyscall &amp;&amp; atomic.Cas(&amp;pp.status, s, _Pgcstop) {</code></span>
<span class="codeline" id="line-1476"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-1477"><code>				trace.GoSysBlock(pp)</code></span>
<span class="codeline" id="line-1478"><code>				trace.ProcSteal(pp, false)</code></span>
<span class="codeline" id="line-1479"><code>			}</code></span>
<span class="codeline" id="line-1480"><code>			pp.syscalltick++</code></span>
<span class="codeline" id="line-1481"><code>			sched.stopwait--</code></span>
<span class="codeline" id="line-1482"><code>		}</code></span>
<span class="codeline" id="line-1483"><code>	}</code></span>
<span class="codeline" id="line-1484"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-1485"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-1486"><code>	}</code></span>
<span class="codeline" id="line-1487"><code></code></span>
<span class="codeline" id="line-1488"><code>	// stop idle P's</code></span>
<span class="codeline" id="line-1489"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-1490"><code>	for {</code></span>
<span class="codeline" id="line-1491"><code>		pp, _ := pidleget(now)</code></span>
<span class="codeline" id="line-1492"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-1493"><code>			break</code></span>
<span class="codeline" id="line-1494"><code>		}</code></span>
<span class="codeline" id="line-1495"><code>		pp.status = _Pgcstop</code></span>
<span class="codeline" id="line-1496"><code>		sched.stopwait--</code></span>
<span class="codeline" id="line-1497"><code>	}</code></span>
<span class="codeline" id="line-1498"><code>	wait := sched.stopwait &gt; 0</code></span>
<span class="codeline" id="line-1499"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1500"><code></code></span>
<span class="codeline" id="line-1501"><code>	// wait for remaining P's to stop voluntarily</code></span>
<span class="codeline" id="line-1502"><code>	if wait {</code></span>
<span class="codeline" id="line-1503"><code>		for {</code></span>
<span class="codeline" id="line-1504"><code>			// wait for 100us, then try to re-preempt in case of any races</code></span>
<span class="codeline" id="line-1505"><code>			if notetsleep(&amp;sched.stopnote, 100*1000) {</code></span>
<span class="codeline" id="line-1506"><code>				noteclear(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-1507"><code>				break</code></span>
<span class="codeline" id="line-1508"><code>			}</code></span>
<span class="codeline" id="line-1509"><code>			preemptall()</code></span>
<span class="codeline" id="line-1510"><code>		}</code></span>
<span class="codeline" id="line-1511"><code>	}</code></span>
<span class="codeline" id="line-1512"><code></code></span>
<span class="codeline" id="line-1513"><code>	startTime := nanotime() - start</code></span>
<span class="codeline" id="line-1514"><code>	if reason.isGC() {</code></span>
<span class="codeline" id="line-1515"><code>		sched.stwStoppingTimeGC.record(startTime)</code></span>
<span class="codeline" id="line-1516"><code>	} else {</code></span>
<span class="codeline" id="line-1517"><code>		sched.stwStoppingTimeOther.record(startTime)</code></span>
<span class="codeline" id="line-1518"><code>	}</code></span>
<span class="codeline" id="line-1519"><code></code></span>
<span class="codeline" id="line-1520"><code>	// sanity checks</code></span>
<span class="codeline" id="line-1521"><code>	bad := ""</code></span>
<span class="codeline" id="line-1522"><code>	if sched.stopwait != 0 {</code></span>
<span class="codeline" id="line-1523"><code>		bad = "stopTheWorld: not stopped (stopwait != 0)"</code></span>
<span class="codeline" id="line-1524"><code>	} else {</code></span>
<span class="codeline" id="line-1525"><code>		for _, pp := range allp {</code></span>
<span class="codeline" id="line-1526"><code>			if pp.status != _Pgcstop {</code></span>
<span class="codeline" id="line-1527"><code>				bad = "stopTheWorld: not stopped (status != _Pgcstop)"</code></span>
<span class="codeline" id="line-1528"><code>			}</code></span>
<span class="codeline" id="line-1529"><code>		}</code></span>
<span class="codeline" id="line-1530"><code>	}</code></span>
<span class="codeline" id="line-1531"><code>	if freezing.Load() {</code></span>
<span class="codeline" id="line-1532"><code>		// Some other thread is panicking. This can cause the</code></span>
<span class="codeline" id="line-1533"><code>		// sanity checks above to fail if the panic happens in</code></span>
<span class="codeline" id="line-1534"><code>		// the signal handler on a stopped thread. Either way,</code></span>
<span class="codeline" id="line-1535"><code>		// we should halt this thread.</code></span>
<span class="codeline" id="line-1536"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-1537"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-1538"><code>	}</code></span>
<span class="codeline" id="line-1539"><code>	if bad != "" {</code></span>
<span class="codeline" id="line-1540"><code>		throw(bad)</code></span>
<span class="codeline" id="line-1541"><code>	}</code></span>
<span class="codeline" id="line-1542"><code></code></span>
<span class="codeline" id="line-1543"><code>	worldStopped()</code></span>
<span class="codeline" id="line-1544"><code></code></span>
<span class="codeline" id="line-1545"><code>	return worldStop{reason: reason, start: start}</code></span>
<span class="codeline" id="line-1546"><code>}</code></span>
<span class="codeline" id="line-1547"><code></code></span>
<span class="codeline" id="line-1548"><code>// reason is the same STW reason passed to stopTheWorld. start is the start</code></span>
<span class="codeline" id="line-1549"><code>// time returned by stopTheWorld.</code></span>
<span class="codeline" id="line-1550"><code>//</code></span>
<span class="codeline" id="line-1551"><code>// now is the current time; prefer to pass 0 to capture a fresh timestamp.</code></span>
<span class="codeline" id="line-1552"><code>//</code></span>
<span class="codeline" id="line-1553"><code>// stattTheWorldWithSema returns now.</code></span>
<span class="codeline" id="line-1554"><code>func startTheWorldWithSema(now int64, w worldStop) int64 {</code></span>
<span class="codeline" id="line-1555"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-1556"><code></code></span>
<span class="codeline" id="line-1557"><code>	mp := acquirem() // disable preemption because it can be holding p in a local var</code></span>
<span class="codeline" id="line-1558"><code>	if netpollinited() {</code></span>
<span class="codeline" id="line-1559"><code>		list, delta := netpoll(0) // non-blocking</code></span>
<span class="codeline" id="line-1560"><code>		injectglist(&amp;list)</code></span>
<span class="codeline" id="line-1561"><code>		netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-1562"><code>	}</code></span>
<span class="codeline" id="line-1563"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1564"><code></code></span>
<span class="codeline" id="line-1565"><code>	procs := gomaxprocs</code></span>
<span class="codeline" id="line-1566"><code>	if newprocs != 0 {</code></span>
<span class="codeline" id="line-1567"><code>		procs = newprocs</code></span>
<span class="codeline" id="line-1568"><code>		newprocs = 0</code></span>
<span class="codeline" id="line-1569"><code>	}</code></span>
<span class="codeline" id="line-1570"><code>	p1 := procresize(procs)</code></span>
<span class="codeline" id="line-1571"><code>	sched.gcwaiting.Store(false)</code></span>
<span class="codeline" id="line-1572"><code>	if sched.sysmonwait.Load() {</code></span>
<span class="codeline" id="line-1573"><code>		sched.sysmonwait.Store(false)</code></span>
<span class="codeline" id="line-1574"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-1575"><code>	}</code></span>
<span class="codeline" id="line-1576"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1577"><code></code></span>
<span class="codeline" id="line-1578"><code>	worldStarted()</code></span>
<span class="codeline" id="line-1579"><code></code></span>
<span class="codeline" id="line-1580"><code>	for p1 != nil {</code></span>
<span class="codeline" id="line-1581"><code>		p := p1</code></span>
<span class="codeline" id="line-1582"><code>		p1 = p1.link.ptr()</code></span>
<span class="codeline" id="line-1583"><code>		if p.m != 0 {</code></span>
<span class="codeline" id="line-1584"><code>			mp := p.m.ptr()</code></span>
<span class="codeline" id="line-1585"><code>			p.m = 0</code></span>
<span class="codeline" id="line-1586"><code>			if mp.nextp != 0 {</code></span>
<span class="codeline" id="line-1587"><code>				throw("startTheWorld: inconsistent mp-&gt;nextp")</code></span>
<span class="codeline" id="line-1588"><code>			}</code></span>
<span class="codeline" id="line-1589"><code>			mp.nextp.set(p)</code></span>
<span class="codeline" id="line-1590"><code>			notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-1591"><code>		} else {</code></span>
<span class="codeline" id="line-1592"><code>			// Start M to run P.  Do not start another M below.</code></span>
<span class="codeline" id="line-1593"><code>			newm(nil, p, -1)</code></span>
<span class="codeline" id="line-1594"><code>		}</code></span>
<span class="codeline" id="line-1595"><code>	}</code></span>
<span class="codeline" id="line-1596"><code></code></span>
<span class="codeline" id="line-1597"><code>	// Capture start-the-world time before doing clean-up tasks.</code></span>
<span class="codeline" id="line-1598"><code>	if now == 0 {</code></span>
<span class="codeline" id="line-1599"><code>		now = nanotime()</code></span>
<span class="codeline" id="line-1600"><code>	}</code></span>
<span class="codeline" id="line-1601"><code>	totalTime := now - w.start</code></span>
<span class="codeline" id="line-1602"><code>	if w.reason.isGC() {</code></span>
<span class="codeline" id="line-1603"><code>		sched.stwTotalTimeGC.record(totalTime)</code></span>
<span class="codeline" id="line-1604"><code>	} else {</code></span>
<span class="codeline" id="line-1605"><code>		sched.stwTotalTimeOther.record(totalTime)</code></span>
<span class="codeline" id="line-1606"><code>	}</code></span>
<span class="codeline" id="line-1607"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-1608"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-1609"><code>		trace.STWDone()</code></span>
<span class="codeline" id="line-1610"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-1611"><code>	}</code></span>
<span class="codeline" id="line-1612"><code></code></span>
<span class="codeline" id="line-1613"><code>	// Wakeup an additional proc in case we have excessive runnable goroutines</code></span>
<span class="codeline" id="line-1614"><code>	// in local queues or in the global queue. If we don't, the proc will park itself.</code></span>
<span class="codeline" id="line-1615"><code>	// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.</code></span>
<span class="codeline" id="line-1616"><code>	wakep()</code></span>
<span class="codeline" id="line-1617"><code></code></span>
<span class="codeline" id="line-1618"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>	return now</code></span>
<span class="codeline" id="line-1621"><code>}</code></span>
<span class="codeline" id="line-1622"><code></code></span>
<span class="codeline" id="line-1623"><code>// usesLibcall indicates whether this runtime performs system calls</code></span>
<span class="codeline" id="line-1624"><code>// via libcall.</code></span>
<span class="codeline" id="line-1625"><code>func usesLibcall() bool {</code></span>
<span class="codeline" id="line-1626"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-1627"><code>	case "aix", "darwin", "illumos", "ios", "solaris", "windows":</code></span>
<span class="codeline" id="line-1628"><code>		return true</code></span>
<span class="codeline" id="line-1629"><code>	case "openbsd":</code></span>
<span class="codeline" id="line-1630"><code>		return GOARCH != "mips64"</code></span>
<span class="codeline" id="line-1631"><code>	}</code></span>
<span class="codeline" id="line-1632"><code>	return false</code></span>
<span class="codeline" id="line-1633"><code>}</code></span>
<span class="codeline" id="line-1634"><code></code></span>
<span class="codeline" id="line-1635"><code>// mStackIsSystemAllocated indicates whether this runtime starts on a</code></span>
<span class="codeline" id="line-1636"><code>// system-allocated stack.</code></span>
<span class="codeline" id="line-1637"><code>func mStackIsSystemAllocated() bool {</code></span>
<span class="codeline" id="line-1638"><code>	switch GOOS {</code></span>
<span class="codeline" id="line-1639"><code>	case "aix", "darwin", "plan9", "illumos", "ios", "solaris", "windows":</code></span>
<span class="codeline" id="line-1640"><code>		return true</code></span>
<span class="codeline" id="line-1641"><code>	case "openbsd":</code></span>
<span class="codeline" id="line-1642"><code>		return GOARCH != "mips64"</code></span>
<span class="codeline" id="line-1643"><code>	}</code></span>
<span class="codeline" id="line-1644"><code>	return false</code></span>
<span class="codeline" id="line-1645"><code>}</code></span>
<span class="codeline" id="line-1646"><code></code></span>
<span class="codeline" id="line-1647"><code>// mstart is the entry-point for new Ms.</code></span>
<span class="codeline" id="line-1648"><code>// It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0.</code></span>
<span class="codeline" id="line-1649"><code>func mstart()</code></span>
<span class="codeline" id="line-1650"><code></code></span>
<span class="codeline" id="line-1651"><code>// mstart0 is the Go entry-point for new Ms.</code></span>
<span class="codeline" id="line-1652"><code>// This must not split the stack because we may not even have stack</code></span>
<span class="codeline" id="line-1653"><code>// bounds set up yet.</code></span>
<span class="codeline" id="line-1654"><code>//</code></span>
<span class="codeline" id="line-1655"><code>// May run during STW (because it doesn't have a P yet), so write</code></span>
<span class="codeline" id="line-1656"><code>// barriers are not allowed.</code></span>
<span class="codeline" id="line-1657"><code>//</code></span>
<span class="codeline" id="line-1658"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1659"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1660"><code>func mstart0() {</code></span>
<span class="codeline" id="line-1661"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1662"><code></code></span>
<span class="codeline" id="line-1663"><code>	osStack := gp.stack.lo == 0</code></span>
<span class="codeline" id="line-1664"><code>	if osStack {</code></span>
<span class="codeline" id="line-1665"><code>		// Initialize stack bounds from system stack.</code></span>
<span class="codeline" id="line-1666"><code>		// Cgo may have left stack size in stack.hi.</code></span>
<span class="codeline" id="line-1667"><code>		// minit may update the stack bounds.</code></span>
<span class="codeline" id="line-1668"><code>		//</code></span>
<span class="codeline" id="line-1669"><code>		// Note: these bounds may not be very accurate.</code></span>
<span class="codeline" id="line-1670"><code>		// We set hi to &amp;size, but there are things above</code></span>
<span class="codeline" id="line-1671"><code>		// it. The 1024 is supposed to compensate this,</code></span>
<span class="codeline" id="line-1672"><code>		// but is somewhat arbitrary.</code></span>
<span class="codeline" id="line-1673"><code>		size := gp.stack.hi</code></span>
<span class="codeline" id="line-1674"><code>		if size == 0 {</code></span>
<span class="codeline" id="line-1675"><code>			size = 16384 * sys.StackGuardMultiplier</code></span>
<span class="codeline" id="line-1676"><code>		}</code></span>
<span class="codeline" id="line-1677"><code>		gp.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;size)))</code></span>
<span class="codeline" id="line-1678"><code>		gp.stack.lo = gp.stack.hi - size + 1024</code></span>
<span class="codeline" id="line-1679"><code>	}</code></span>
<span class="codeline" id="line-1680"><code>	// Initialize stack guard so that we can start calling regular</code></span>
<span class="codeline" id="line-1681"><code>	// Go code.</code></span>
<span class="codeline" id="line-1682"><code>	gp.stackguard0 = gp.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-1683"><code>	// This is the g0, so we can also call go:systemstack</code></span>
<span class="codeline" id="line-1684"><code>	// functions, which check stackguard1.</code></span>
<span class="codeline" id="line-1685"><code>	gp.stackguard1 = gp.stackguard0</code></span>
<span class="codeline" id="line-1686"><code>	mstart1()</code></span>
<span class="codeline" id="line-1687"><code></code></span>
<span class="codeline" id="line-1688"><code>	// Exit this thread.</code></span>
<span class="codeline" id="line-1689"><code>	if mStackIsSystemAllocated() {</code></span>
<span class="codeline" id="line-1690"><code>		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</code></span>
<span class="codeline" id="line-1691"><code>		// the stack, but put it in gp.stack before mstart,</code></span>
<span class="codeline" id="line-1692"><code>		// so the logic above hasn't set osStack yet.</code></span>
<span class="codeline" id="line-1693"><code>		osStack = true</code></span>
<span class="codeline" id="line-1694"><code>	}</code></span>
<span class="codeline" id="line-1695"><code>	mexit(osStack)</code></span>
<span class="codeline" id="line-1696"><code>}</code></span>
<span class="codeline" id="line-1697"><code></code></span>
<span class="codeline" id="line-1698"><code>// The go:noinline is to guarantee the getcallerpc/getcallersp below are safe,</code></span>
<span class="codeline" id="line-1699"><code>// so that we can set up g0.sched to return to the call of mstart1 above.</code></span>
<span class="codeline" id="line-1700"><code>//</code></span>
<span class="codeline" id="line-1701"><code>//go:noinline</code></span>
<span class="codeline" id="line-1702"><code>func mstart1() {</code></span>
<span class="codeline" id="line-1703"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1704"><code></code></span>
<span class="codeline" id="line-1705"><code>	if gp != gp.m.g0 {</code></span>
<span class="codeline" id="line-1706"><code>		throw("bad runtimemstart")</code></span>
<span class="codeline" id="line-1707"><code>	}</code></span>
<span class="codeline" id="line-1708"><code></code></span>
<span class="codeline" id="line-1709"><code>	// Set up m.g0.sched as a label returning to just</code></span>
<span class="codeline" id="line-1710"><code>	// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.</code></span>
<span class="codeline" id="line-1711"><code>	// We're never coming back to mstart1 after we call schedule,</code></span>
<span class="codeline" id="line-1712"><code>	// so other calls can reuse the current frame.</code></span>
<span class="codeline" id="line-1713"><code>	// And goexit0 does a gogo that needs to return from mstart1</code></span>
<span class="codeline" id="line-1714"><code>	// and let mstart0 exit the thread.</code></span>
<span class="codeline" id="line-1715"><code>	gp.sched.g = guintptr(unsafe.Pointer(gp))</code></span>
<span class="codeline" id="line-1716"><code>	gp.sched.pc = getcallerpc()</code></span>
<span class="codeline" id="line-1717"><code>	gp.sched.sp = getcallersp()</code></span>
<span class="codeline" id="line-1718"><code></code></span>
<span class="codeline" id="line-1719"><code>	asminit()</code></span>
<span class="codeline" id="line-1720"><code>	minit()</code></span>
<span class="codeline" id="line-1721"><code></code></span>
<span class="codeline" id="line-1722"><code>	// Install signal handlers; after minit so that minit can</code></span>
<span class="codeline" id="line-1723"><code>	// prepare the thread to be able to handle the signals.</code></span>
<span class="codeline" id="line-1724"><code>	if gp.m == &amp;m0 {</code></span>
<span class="codeline" id="line-1725"><code>		mstartm0()</code></span>
<span class="codeline" id="line-1726"><code>	}</code></span>
<span class="codeline" id="line-1727"><code></code></span>
<span class="codeline" id="line-1728"><code>	if fn := gp.m.mstartfn; fn != nil {</code></span>
<span class="codeline" id="line-1729"><code>		fn()</code></span>
<span class="codeline" id="line-1730"><code>	}</code></span>
<span class="codeline" id="line-1731"><code></code></span>
<span class="codeline" id="line-1732"><code>	if gp.m != &amp;m0 {</code></span>
<span class="codeline" id="line-1733"><code>		acquirep(gp.m.nextp.ptr())</code></span>
<span class="codeline" id="line-1734"><code>		gp.m.nextp = 0</code></span>
<span class="codeline" id="line-1735"><code>	}</code></span>
<span class="codeline" id="line-1736"><code>	schedule()</code></span>
<span class="codeline" id="line-1737"><code>}</code></span>
<span class="codeline" id="line-1738"><code></code></span>
<span class="codeline" id="line-1739"><code>// mstartm0 implements part of mstart1 that only runs on the m0.</code></span>
<span class="codeline" id="line-1740"><code>//</code></span>
<span class="codeline" id="line-1741"><code>// Write barriers are allowed here because we know the GC can't be</code></span>
<span class="codeline" id="line-1742"><code>// running yet, so they'll be no-ops.</code></span>
<span class="codeline" id="line-1743"><code>//</code></span>
<span class="codeline" id="line-1744"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-1745"><code>func mstartm0() {</code></span>
<span class="codeline" id="line-1746"><code>	// Create an extra M for callbacks on threads not created by Go.</code></span>
<span class="codeline" id="line-1747"><code>	// An extra M is also needed on Windows for callbacks created by</code></span>
<span class="codeline" id="line-1748"><code>	// syscall.NewCallback. See issue #6751 for details.</code></span>
<span class="codeline" id="line-1749"><code>	if (iscgo || GOOS == "windows") &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-1750"><code>		cgoHasExtraM = true</code></span>
<span class="codeline" id="line-1751"><code>		newextram()</code></span>
<span class="codeline" id="line-1752"><code>	}</code></span>
<span class="codeline" id="line-1753"><code>	initsig(false)</code></span>
<span class="codeline" id="line-1754"><code>}</code></span>
<span class="codeline" id="line-1755"><code></code></span>
<span class="codeline" id="line-1756"><code>// mPark causes a thread to park itself, returning once woken.</code></span>
<span class="codeline" id="line-1757"><code>//</code></span>
<span class="codeline" id="line-1758"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1759"><code>func mPark() {</code></span>
<span class="codeline" id="line-1760"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1761"><code>	notesleep(&amp;gp.m.park)</code></span>
<span class="codeline" id="line-1762"><code>	noteclear(&amp;gp.m.park)</code></span>
<span class="codeline" id="line-1763"><code>}</code></span>
<span class="codeline" id="line-1764"><code></code></span>
<span class="codeline" id="line-1765"><code>// mexit tears down and exits the current thread.</code></span>
<span class="codeline" id="line-1766"><code>//</code></span>
<span class="codeline" id="line-1767"><code>// Don't call this directly to exit the thread, since it must run at</code></span>
<span class="codeline" id="line-1768"><code>// the top of the thread stack. Instead, use gogo(&amp;gp.m.g0.sched) to</code></span>
<span class="codeline" id="line-1769"><code>// unwind the stack to the point that exits the thread.</code></span>
<span class="codeline" id="line-1770"><code>//</code></span>
<span class="codeline" id="line-1771"><code>// It is entered with m.p != nil, so write barriers are allowed. It</code></span>
<span class="codeline" id="line-1772"><code>// will release the P before exiting.</code></span>
<span class="codeline" id="line-1773"><code>//</code></span>
<span class="codeline" id="line-1774"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-1775"><code>func mexit(osStack bool) {</code></span>
<span class="codeline" id="line-1776"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-1777"><code></code></span>
<span class="codeline" id="line-1778"><code>	if mp == &amp;m0 {</code></span>
<span class="codeline" id="line-1779"><code>		// This is the main thread. Just wedge it.</code></span>
<span class="codeline" id="line-1780"><code>		//</code></span>
<span class="codeline" id="line-1781"><code>		// On Linux, exiting the main thread puts the process</code></span>
<span class="codeline" id="line-1782"><code>		// into a non-waitable zombie state. On Plan 9,</code></span>
<span class="codeline" id="line-1783"><code>		// exiting the main thread unblocks wait even though</code></span>
<span class="codeline" id="line-1784"><code>		// other threads are still running. On Solaris we can</code></span>
<span class="codeline" id="line-1785"><code>		// neither exitThread nor return from mstart. Other</code></span>
<span class="codeline" id="line-1786"><code>		// bad things probably happen on other platforms.</code></span>
<span class="codeline" id="line-1787"><code>		//</code></span>
<span class="codeline" id="line-1788"><code>		// We could try to clean up this M more before wedging</code></span>
<span class="codeline" id="line-1789"><code>		// it, but that complicates signal handling.</code></span>
<span class="codeline" id="line-1790"><code>		handoffp(releasep())</code></span>
<span class="codeline" id="line-1791"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1792"><code>		sched.nmfreed++</code></span>
<span class="codeline" id="line-1793"><code>		checkdead()</code></span>
<span class="codeline" id="line-1794"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1795"><code>		mPark()</code></span>
<span class="codeline" id="line-1796"><code>		throw("locked m0 woke up")</code></span>
<span class="codeline" id="line-1797"><code>	}</code></span>
<span class="codeline" id="line-1798"><code></code></span>
<span class="codeline" id="line-1799"><code>	sigblock(true)</code></span>
<span class="codeline" id="line-1800"><code>	unminit()</code></span>
<span class="codeline" id="line-1801"><code></code></span>
<span class="codeline" id="line-1802"><code>	// Free the gsignal stack.</code></span>
<span class="codeline" id="line-1803"><code>	if mp.gsignal != nil {</code></span>
<span class="codeline" id="line-1804"><code>		stackfree(mp.gsignal.stack)</code></span>
<span class="codeline" id="line-1805"><code>		// On some platforms, when calling into VDSO (e.g. nanotime)</code></span>
<span class="codeline" id="line-1806"><code>		// we store our g on the gsignal stack, if there is one.</code></span>
<span class="codeline" id="line-1807"><code>		// Now the stack is freed, unlink it from the m, so we</code></span>
<span class="codeline" id="line-1808"><code>		// won't write to it when calling VDSO code.</code></span>
<span class="codeline" id="line-1809"><code>		mp.gsignal = nil</code></span>
<span class="codeline" id="line-1810"><code>	}</code></span>
<span class="codeline" id="line-1811"><code></code></span>
<span class="codeline" id="line-1812"><code>	// Remove m from allm.</code></span>
<span class="codeline" id="line-1813"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1814"><code>	for pprev := &amp;allm; *pprev != nil; pprev = &amp;(*pprev).alllink {</code></span>
<span class="codeline" id="line-1815"><code>		if *pprev == mp {</code></span>
<span class="codeline" id="line-1816"><code>			*pprev = mp.alllink</code></span>
<span class="codeline" id="line-1817"><code>			goto found</code></span>
<span class="codeline" id="line-1818"><code>		}</code></span>
<span class="codeline" id="line-1819"><code>	}</code></span>
<span class="codeline" id="line-1820"><code>	throw("m not found in allm")</code></span>
<span class="codeline" id="line-1821"><code>found:</code></span>
<span class="codeline" id="line-1822"><code>	// Events must not be traced after this point.</code></span>
<span class="codeline" id="line-1823"><code></code></span>
<span class="codeline" id="line-1824"><code>	// Delay reaping m until it's done with the stack.</code></span>
<span class="codeline" id="line-1825"><code>	//</code></span>
<span class="codeline" id="line-1826"><code>	// Put mp on the free list, though it will not be reaped while freeWait</code></span>
<span class="codeline" id="line-1827"><code>	// is freeMWait. mp is no longer reachable via allm, so even if it is</code></span>
<span class="codeline" id="line-1828"><code>	// on an OS stack, we must keep a reference to mp alive so that the GC</code></span>
<span class="codeline" id="line-1829"><code>	// doesn't free mp while we are still using it.</code></span>
<span class="codeline" id="line-1830"><code>	//</code></span>
<span class="codeline" id="line-1831"><code>	// Note that the free list must not be linked through alllink because</code></span>
<span class="codeline" id="line-1832"><code>	// some functions walk allm without locking, so may be using alllink.</code></span>
<span class="codeline" id="line-1833"><code>	//</code></span>
<span class="codeline" id="line-1834"><code>	// N.B. It's important that the M appears on the free list simultaneously</code></span>
<span class="codeline" id="line-1835"><code>	// with it being removed so that the tracer can find it.</code></span>
<span class="codeline" id="line-1836"><code>	mp.freeWait.Store(freeMWait)</code></span>
<span class="codeline" id="line-1837"><code>	mp.freelink = sched.freem</code></span>
<span class="codeline" id="line-1838"><code>	sched.freem = mp</code></span>
<span class="codeline" id="line-1839"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1840"><code></code></span>
<span class="codeline" id="line-1841"><code>	atomic.Xadd64(&amp;ncgocall, int64(mp.ncgocall))</code></span>
<span class="codeline" id="line-1842"><code>	sched.totalRuntimeLockWaitTime.Add(mp.mLockProfile.waitTime.Load())</code></span>
<span class="codeline" id="line-1843"><code></code></span>
<span class="codeline" id="line-1844"><code>	// Release the P.</code></span>
<span class="codeline" id="line-1845"><code>	handoffp(releasep())</code></span>
<span class="codeline" id="line-1846"><code>	// After this point we must not have write barriers.</code></span>
<span class="codeline" id="line-1847"><code></code></span>
<span class="codeline" id="line-1848"><code>	// Invoke the deadlock detector. This must happen after</code></span>
<span class="codeline" id="line-1849"><code>	// handoffp because it may have started a new M to take our</code></span>
<span class="codeline" id="line-1850"><code>	// P's work.</code></span>
<span class="codeline" id="line-1851"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1852"><code>	sched.nmfreed++</code></span>
<span class="codeline" id="line-1853"><code>	checkdead()</code></span>
<span class="codeline" id="line-1854"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1855"><code></code></span>
<span class="codeline" id="line-1856"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-1857"><code>		// Make sure pendingPreemptSignals is correct when an M exits.</code></span>
<span class="codeline" id="line-1858"><code>		// For #41702.</code></span>
<span class="codeline" id="line-1859"><code>		if mp.signalPending.Load() != 0 {</code></span>
<span class="codeline" id="line-1860"><code>			pendingPreemptSignals.Add(-1)</code></span>
<span class="codeline" id="line-1861"><code>		}</code></span>
<span class="codeline" id="line-1862"><code>	}</code></span>
<span class="codeline" id="line-1863"><code></code></span>
<span class="codeline" id="line-1864"><code>	// Destroy all allocated resources. After this is called, we may no</code></span>
<span class="codeline" id="line-1865"><code>	// longer take any locks.</code></span>
<span class="codeline" id="line-1866"><code>	mdestroy(mp)</code></span>
<span class="codeline" id="line-1867"><code></code></span>
<span class="codeline" id="line-1868"><code>	if osStack {</code></span>
<span class="codeline" id="line-1869"><code>		// No more uses of mp, so it is safe to drop the reference.</code></span>
<span class="codeline" id="line-1870"><code>		mp.freeWait.Store(freeMRef)</code></span>
<span class="codeline" id="line-1871"><code></code></span>
<span class="codeline" id="line-1872"><code>		// Return from mstart and let the system thread</code></span>
<span class="codeline" id="line-1873"><code>		// library free the g0 stack and terminate the thread.</code></span>
<span class="codeline" id="line-1874"><code>		return</code></span>
<span class="codeline" id="line-1875"><code>	}</code></span>
<span class="codeline" id="line-1876"><code></code></span>
<span class="codeline" id="line-1877"><code>	// mstart is the thread's entry point, so there's nothing to</code></span>
<span class="codeline" id="line-1878"><code>	// return to. Exit the thread directly. exitThread will clear</code></span>
<span class="codeline" id="line-1879"><code>	// m.freeWait when it's done with the stack and the m can be</code></span>
<span class="codeline" id="line-1880"><code>	// reaped.</code></span>
<span class="codeline" id="line-1881"><code>	exitThread(&amp;mp.freeWait)</code></span>
<span class="codeline" id="line-1882"><code>}</code></span>
<span class="codeline" id="line-1883"><code></code></span>
<span class="codeline" id="line-1884"><code>// forEachP calls fn(p) for every P p when p reaches a GC safe point.</code></span>
<span class="codeline" id="line-1885"><code>// If a P is currently executing code, this will bring the P to a GC</code></span>
<span class="codeline" id="line-1886"><code>// safe point and execute fn on that P. If the P is not executing code</code></span>
<span class="codeline" id="line-1887"><code>// (it is idle or in a syscall), this will call fn(p) directly while</code></span>
<span class="codeline" id="line-1888"><code>// preventing the P from exiting its state. This does not ensure that</code></span>
<span class="codeline" id="line-1889"><code>// fn will run on every CPU executing Go code, but it acts as a global</code></span>
<span class="codeline" id="line-1890"><code>// memory barrier. GC uses this as a "ragged barrier."</code></span>
<span class="codeline" id="line-1891"><code>//</code></span>
<span class="codeline" id="line-1892"><code>// The caller must hold worldsema. fn must not refer to any</code></span>
<span class="codeline" id="line-1893"><code>// part of the current goroutine's stack, since the GC may move it.</code></span>
<span class="codeline" id="line-1894"><code>func forEachP(reason waitReason, fn func(*p)) {</code></span>
<span class="codeline" id="line-1895"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1896"><code>		gp := getg().m.curg</code></span>
<span class="codeline" id="line-1897"><code>		// Mark the user stack as preemptible so that it may be scanned.</code></span>
<span class="codeline" id="line-1898"><code>		// Otherwise, our attempt to force all P's to a safepoint could</code></span>
<span class="codeline" id="line-1899"><code>		// result in a deadlock as we attempt to preempt a worker that's</code></span>
<span class="codeline" id="line-1900"><code>		// trying to preempt us (e.g. for a stack scan).</code></span>
<span class="codeline" id="line-1901"><code>		//</code></span>
<span class="codeline" id="line-1902"><code>		// N.B. The execution tracer is not aware of this status</code></span>
<span class="codeline" id="line-1903"><code>		// transition and handles it specially based on the</code></span>
<span class="codeline" id="line-1904"><code>		// wait reason.</code></span>
<span class="codeline" id="line-1905"><code>		casGToWaiting(gp, _Grunning, reason)</code></span>
<span class="codeline" id="line-1906"><code>		forEachPInternal(fn)</code></span>
<span class="codeline" id="line-1907"><code>		casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1908"><code>	})</code></span>
<span class="codeline" id="line-1909"><code>}</code></span>
<span class="codeline" id="line-1910"><code></code></span>
<span class="codeline" id="line-1911"><code>// forEachPInternal calls fn(p) for every P p when p reaches a GC safe point.</code></span>
<span class="codeline" id="line-1912"><code>// It is the internal implementation of forEachP.</code></span>
<span class="codeline" id="line-1913"><code>//</code></span>
<span class="codeline" id="line-1914"><code>// The caller must hold worldsema and either must ensure that a GC is not</code></span>
<span class="codeline" id="line-1915"><code>// running (otherwise this may deadlock with the GC trying to preempt this P)</code></span>
<span class="codeline" id="line-1916"><code>// or it must leave its goroutine in a preemptible state before it switches</code></span>
<span class="codeline" id="line-1917"><code>// to the systemstack. Due to these restrictions, prefer forEachP when possible.</code></span>
<span class="codeline" id="line-1918"><code>//</code></span>
<span class="codeline" id="line-1919"><code>//go:systemstack</code></span>
<span class="codeline" id="line-1920"><code>func forEachPInternal(fn func(*p)) {</code></span>
<span class="codeline" id="line-1921"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-1922"><code>	pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-1923"><code></code></span>
<span class="codeline" id="line-1924"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1925"><code>	if sched.safePointWait != 0 {</code></span>
<span class="codeline" id="line-1926"><code>		throw("forEachP: sched.safePointWait != 0")</code></span>
<span class="codeline" id="line-1927"><code>	}</code></span>
<span class="codeline" id="line-1928"><code>	sched.safePointWait = gomaxprocs - 1</code></span>
<span class="codeline" id="line-1929"><code>	sched.safePointFn = fn</code></span>
<span class="codeline" id="line-1930"><code></code></span>
<span class="codeline" id="line-1931"><code>	// Ask all Ps to run the safe point function.</code></span>
<span class="codeline" id="line-1932"><code>	for _, p2 := range allp {</code></span>
<span class="codeline" id="line-1933"><code>		if p2 != pp {</code></span>
<span class="codeline" id="line-1934"><code>			atomic.Store(&amp;p2.runSafePointFn, 1)</code></span>
<span class="codeline" id="line-1935"><code>		}</code></span>
<span class="codeline" id="line-1936"><code>	}</code></span>
<span class="codeline" id="line-1937"><code>	preemptall()</code></span>
<span class="codeline" id="line-1938"><code></code></span>
<span class="codeline" id="line-1939"><code>	// Any P entering _Pidle or _Psyscall from now on will observe</code></span>
<span class="codeline" id="line-1940"><code>	// p.runSafePointFn == 1 and will call runSafePointFn when</code></span>
<span class="codeline" id="line-1941"><code>	// changing its status to _Pidle/_Psyscall.</code></span>
<span class="codeline" id="line-1942"><code></code></span>
<span class="codeline" id="line-1943"><code>	// Run safe point function for all idle Ps. sched.pidle will</code></span>
<span class="codeline" id="line-1944"><code>	// not change because we hold sched.lock.</code></span>
<span class="codeline" id="line-1945"><code>	for p := sched.pidle.ptr(); p != nil; p = p.link.ptr() {</code></span>
<span class="codeline" id="line-1946"><code>		if atomic.Cas(&amp;p.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-1947"><code>			fn(p)</code></span>
<span class="codeline" id="line-1948"><code>			sched.safePointWait--</code></span>
<span class="codeline" id="line-1949"><code>		}</code></span>
<span class="codeline" id="line-1950"><code>	}</code></span>
<span class="codeline" id="line-1951"><code></code></span>
<span class="codeline" id="line-1952"><code>	wait := sched.safePointWait &gt; 0</code></span>
<span class="codeline" id="line-1953"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1954"><code></code></span>
<span class="codeline" id="line-1955"><code>	// Run fn for the current P.</code></span>
<span class="codeline" id="line-1956"><code>	fn(pp)</code></span>
<span class="codeline" id="line-1957"><code></code></span>
<span class="codeline" id="line-1958"><code>	// Force Ps currently in _Psyscall into _Pidle and hand them</code></span>
<span class="codeline" id="line-1959"><code>	// off to induce safe point function execution.</code></span>
<span class="codeline" id="line-1960"><code>	for _, p2 := range allp {</code></span>
<span class="codeline" id="line-1961"><code>		s := p2.status</code></span>
<span class="codeline" id="line-1962"><code></code></span>
<span class="codeline" id="line-1963"><code>		// We need to be fine-grained about tracing here, since handoffp</code></span>
<span class="codeline" id="line-1964"><code>		// might call into the tracer, and the tracer is non-reentrant.</code></span>
<span class="codeline" id="line-1965"><code>		trace := traceAcquire()</code></span>
<span class="codeline" id="line-1966"><code>		if s == _Psyscall &amp;&amp; p2.runSafePointFn == 1 &amp;&amp; atomic.Cas(&amp;p2.status, s, _Pidle) {</code></span>
<span class="codeline" id="line-1967"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-1968"><code>				// It's important that we traceRelease before we call handoffp, which may also traceAcquire.</code></span>
<span class="codeline" id="line-1969"><code>				trace.GoSysBlock(p2)</code></span>
<span class="codeline" id="line-1970"><code>				trace.ProcSteal(p2, false)</code></span>
<span class="codeline" id="line-1971"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-1972"><code>			}</code></span>
<span class="codeline" id="line-1973"><code>			p2.syscalltick++</code></span>
<span class="codeline" id="line-1974"><code>			handoffp(p2)</code></span>
<span class="codeline" id="line-1975"><code>		} else if trace.ok() {</code></span>
<span class="codeline" id="line-1976"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-1977"><code>		}</code></span>
<span class="codeline" id="line-1978"><code>	}</code></span>
<span class="codeline" id="line-1979"><code></code></span>
<span class="codeline" id="line-1980"><code>	// Wait for remaining Ps to run fn.</code></span>
<span class="codeline" id="line-1981"><code>	if wait {</code></span>
<span class="codeline" id="line-1982"><code>		for {</code></span>
<span class="codeline" id="line-1983"><code>			// Wait for 100us, then try to re-preempt in</code></span>
<span class="codeline" id="line-1984"><code>			// case of any races.</code></span>
<span class="codeline" id="line-1985"><code>			//</code></span>
<span class="codeline" id="line-1986"><code>			// Requires system stack.</code></span>
<span class="codeline" id="line-1987"><code>			if notetsleep(&amp;sched.safePointNote, 100*1000) {</code></span>
<span class="codeline" id="line-1988"><code>				noteclear(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-1989"><code>				break</code></span>
<span class="codeline" id="line-1990"><code>			}</code></span>
<span class="codeline" id="line-1991"><code>			preemptall()</code></span>
<span class="codeline" id="line-1992"><code>		}</code></span>
<span class="codeline" id="line-1993"><code>	}</code></span>
<span class="codeline" id="line-1994"><code>	if sched.safePointWait != 0 {</code></span>
<span class="codeline" id="line-1995"><code>		throw("forEachP: not done")</code></span>
<span class="codeline" id="line-1996"><code>	}</code></span>
<span class="codeline" id="line-1997"><code>	for _, p2 := range allp {</code></span>
<span class="codeline" id="line-1998"><code>		if p2.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-1999"><code>			throw("forEachP: P did not run fn")</code></span>
<span class="codeline" id="line-2000"><code>		}</code></span>
<span class="codeline" id="line-2001"><code>	}</code></span>
<span class="codeline" id="line-2002"><code></code></span>
<span class="codeline" id="line-2003"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2004"><code>	sched.safePointFn = nil</code></span>
<span class="codeline" id="line-2005"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2006"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-2007"><code>}</code></span>
<span class="codeline" id="line-2008"><code></code></span>
<span class="codeline" id="line-2009"><code>// runSafePointFn runs the safe point function, if any, for this P.</code></span>
<span class="codeline" id="line-2010"><code>// This should be called like</code></span>
<span class="codeline" id="line-2011"><code>//</code></span>
<span class="codeline" id="line-2012"><code>//	if getg().m.p.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-2013"><code>//	    runSafePointFn()</code></span>
<span class="codeline" id="line-2014"><code>//	}</code></span>
<span class="codeline" id="line-2015"><code>//</code></span>
<span class="codeline" id="line-2016"><code>// runSafePointFn must be checked on any transition in to _Pidle or</code></span>
<span class="codeline" id="line-2017"><code>// _Psyscall to avoid a race where forEachP sees that the P is running</code></span>
<span class="codeline" id="line-2018"><code>// just before the P goes into _Pidle/_Psyscall and neither forEachP</code></span>
<span class="codeline" id="line-2019"><code>// nor the P run the safe-point function.</code></span>
<span class="codeline" id="line-2020"><code>func runSafePointFn() {</code></span>
<span class="codeline" id="line-2021"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-2022"><code>	// Resolve the race between forEachP running the safe-point</code></span>
<span class="codeline" id="line-2023"><code>	// function on this P's behalf and this P running the</code></span>
<span class="codeline" id="line-2024"><code>	// safe-point function directly.</code></span>
<span class="codeline" id="line-2025"><code>	if !atomic.Cas(&amp;p.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-2026"><code>		return</code></span>
<span class="codeline" id="line-2027"><code>	}</code></span>
<span class="codeline" id="line-2028"><code>	sched.safePointFn(p)</code></span>
<span class="codeline" id="line-2029"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2030"><code>	sched.safePointWait--</code></span>
<span class="codeline" id="line-2031"><code>	if sched.safePointWait == 0 {</code></span>
<span class="codeline" id="line-2032"><code>		notewakeup(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-2033"><code>	}</code></span>
<span class="codeline" id="line-2034"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2035"><code>}</code></span>
<span class="codeline" id="line-2036"><code></code></span>
<span class="codeline" id="line-2037"><code>// When running with cgo, we call _cgo_thread_start</code></span>
<span class="codeline" id="line-2038"><code>// to start threads for us so that we can play nicely with</code></span>
<span class="codeline" id="line-2039"><code>// foreign code.</code></span>
<span class="codeline" id="line-2040"><code>var cgoThreadStart unsafe.Pointer</code></span>
<span class="codeline" id="line-2041"><code></code></span>
<span class="codeline" id="line-2042"><code>type cgothreadstart struct {</code></span>
<span class="codeline" id="line-2043"><code>	g   guintptr</code></span>
<span class="codeline" id="line-2044"><code>	tls *uint64</code></span>
<span class="codeline" id="line-2045"><code>	fn  unsafe.Pointer</code></span>
<span class="codeline" id="line-2046"><code>}</code></span>
<span class="codeline" id="line-2047"><code></code></span>
<span class="codeline" id="line-2048"><code>// Allocate a new m unassociated with any thread.</code></span>
<span class="codeline" id="line-2049"><code>// Can use p for allocation context if needed.</code></span>
<span class="codeline" id="line-2050"><code>// fn is recorded as the new m's m.mstartfn.</code></span>
<span class="codeline" id="line-2051"><code>// id is optional pre-allocated m ID. Omit by passing -1.</code></span>
<span class="codeline" id="line-2052"><code>//</code></span>
<span class="codeline" id="line-2053"><code>// This function is allowed to have write barriers even if the caller</code></span>
<span class="codeline" id="line-2054"><code>// isn't because it borrows pp.</code></span>
<span class="codeline" id="line-2055"><code>//</code></span>
<span class="codeline" id="line-2056"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-2057"><code>func allocm(pp *p, fn func(), id int64) *m {</code></span>
<span class="codeline" id="line-2058"><code>	allocmLock.rlock()</code></span>
<span class="codeline" id="line-2059"><code></code></span>
<span class="codeline" id="line-2060"><code>	// The caller owns pp, but we may borrow (i.e., acquirep) it. We must</code></span>
<span class="codeline" id="line-2061"><code>	// disable preemption to ensure it is not stolen, which would make the</code></span>
<span class="codeline" id="line-2062"><code>	// caller lose ownership.</code></span>
<span class="codeline" id="line-2063"><code>	acquirem()</code></span>
<span class="codeline" id="line-2064"><code></code></span>
<span class="codeline" id="line-2065"><code>	gp := getg()</code></span>
<span class="codeline" id="line-2066"><code>	if gp.m.p == 0 {</code></span>
<span class="codeline" id="line-2067"><code>		acquirep(pp) // temporarily borrow p for mallocs in this function</code></span>
<span class="codeline" id="line-2068"><code>	}</code></span>
<span class="codeline" id="line-2069"><code></code></span>
<span class="codeline" id="line-2070"><code>	// Release the free M list. We need to do this somewhere and</code></span>
<span class="codeline" id="line-2071"><code>	// this may free up a stack we can use.</code></span>
<span class="codeline" id="line-2072"><code>	if sched.freem != nil {</code></span>
<span class="codeline" id="line-2073"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2074"><code>		var newList *m</code></span>
<span class="codeline" id="line-2075"><code>		for freem := sched.freem; freem != nil; {</code></span>
<span class="codeline" id="line-2076"><code>			// Wait for freeWait to indicate that freem's stack is unused.</code></span>
<span class="codeline" id="line-2077"><code>			wait := freem.freeWait.Load()</code></span>
<span class="codeline" id="line-2078"><code>			if wait == freeMWait {</code></span>
<span class="codeline" id="line-2079"><code>				next := freem.freelink</code></span>
<span class="codeline" id="line-2080"><code>				freem.freelink = newList</code></span>
<span class="codeline" id="line-2081"><code>				newList = freem</code></span>
<span class="codeline" id="line-2082"><code>				freem = next</code></span>
<span class="codeline" id="line-2083"><code>				continue</code></span>
<span class="codeline" id="line-2084"><code>			}</code></span>
<span class="codeline" id="line-2085"><code>			// Drop any remaining trace resources.</code></span>
<span class="codeline" id="line-2086"><code>			// Ms can continue to emit events all the way until wait != freeMWait,</code></span>
<span class="codeline" id="line-2087"><code>			// so it's only safe to call traceThreadDestroy at this point.</code></span>
<span class="codeline" id="line-2088"><code>			if traceEnabled() || traceShuttingDown() {</code></span>
<span class="codeline" id="line-2089"><code>				traceThreadDestroy(freem)</code></span>
<span class="codeline" id="line-2090"><code>			}</code></span>
<span class="codeline" id="line-2091"><code>			// Free the stack if needed. For freeMRef, there is</code></span>
<span class="codeline" id="line-2092"><code>			// nothing to do except drop freem from the sched.freem</code></span>
<span class="codeline" id="line-2093"><code>			// list.</code></span>
<span class="codeline" id="line-2094"><code>			if wait == freeMStack {</code></span>
<span class="codeline" id="line-2095"><code>				// stackfree must be on the system stack, but allocm is</code></span>
<span class="codeline" id="line-2096"><code>				// reachable off the system stack transitively from</code></span>
<span class="codeline" id="line-2097"><code>				// startm.</code></span>
<span class="codeline" id="line-2098"><code>				systemstack(func() {</code></span>
<span class="codeline" id="line-2099"><code>					stackfree(freem.g0.stack)</code></span>
<span class="codeline" id="line-2100"><code>				})</code></span>
<span class="codeline" id="line-2101"><code>			}</code></span>
<span class="codeline" id="line-2102"><code>			freem = freem.freelink</code></span>
<span class="codeline" id="line-2103"><code>		}</code></span>
<span class="codeline" id="line-2104"><code>		sched.freem = newList</code></span>
<span class="codeline" id="line-2105"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2106"><code>	}</code></span>
<span class="codeline" id="line-2107"><code></code></span>
<span class="codeline" id="line-2108"><code>	mp := new(m)</code></span>
<span class="codeline" id="line-2109"><code>	mp.mstartfn = fn</code></span>
<span class="codeline" id="line-2110"><code>	mcommoninit(mp, id)</code></span>
<span class="codeline" id="line-2111"><code></code></span>
<span class="codeline" id="line-2112"><code>	// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.</code></span>
<span class="codeline" id="line-2113"><code>	// Windows and Plan 9 will layout sched stack on OS stack.</code></span>
<span class="codeline" id="line-2114"><code>	if iscgo || mStackIsSystemAllocated() {</code></span>
<span class="codeline" id="line-2115"><code>		mp.g0 = malg(-1)</code></span>
<span class="codeline" id="line-2116"><code>	} else {</code></span>
<span class="codeline" id="line-2117"><code>		mp.g0 = malg(16384 * sys.StackGuardMultiplier)</code></span>
<span class="codeline" id="line-2118"><code>	}</code></span>
<span class="codeline" id="line-2119"><code>	mp.g0.m = mp</code></span>
<span class="codeline" id="line-2120"><code></code></span>
<span class="codeline" id="line-2121"><code>	if pp == gp.m.p.ptr() {</code></span>
<span class="codeline" id="line-2122"><code>		releasep()</code></span>
<span class="codeline" id="line-2123"><code>	}</code></span>
<span class="codeline" id="line-2124"><code></code></span>
<span class="codeline" id="line-2125"><code>	releasem(gp.m)</code></span>
<span class="codeline" id="line-2126"><code>	allocmLock.runlock()</code></span>
<span class="codeline" id="line-2127"><code>	return mp</code></span>
<span class="codeline" id="line-2128"><code>}</code></span>
<span class="codeline" id="line-2129"><code></code></span>
<span class="codeline" id="line-2130"><code>// needm is called when a cgo callback happens on a</code></span>
<span class="codeline" id="line-2131"><code>// thread without an m (a thread not created by Go).</code></span>
<span class="codeline" id="line-2132"><code>// In this case, needm is expected to find an m to use</code></span>
<span class="codeline" id="line-2133"><code>// and return with m, g initialized correctly.</code></span>
<span class="codeline" id="line-2134"><code>// Since m and g are not set now (likely nil, but see below)</code></span>
<span class="codeline" id="line-2135"><code>// needm is limited in what routines it can call. In particular</code></span>
<span class="codeline" id="line-2136"><code>// it can only call nosplit functions (textflag 7) and cannot</code></span>
<span class="codeline" id="line-2137"><code>// do any scheduling that requires an m.</code></span>
<span class="codeline" id="line-2138"><code>//</code></span>
<span class="codeline" id="line-2139"><code>// In order to avoid needing heavy lifting here, we adopt</code></span>
<span class="codeline" id="line-2140"><code>// the following strategy: there is a stack of available m's</code></span>
<span class="codeline" id="line-2141"><code>// that can be stolen. Using compare-and-swap</code></span>
<span class="codeline" id="line-2142"><code>// to pop from the stack has ABA races, so we simulate</code></span>
<span class="codeline" id="line-2143"><code>// a lock by doing an exchange (via Casuintptr) to steal the stack</code></span>
<span class="codeline" id="line-2144"><code>// head and replace the top pointer with MLOCKED (1).</code></span>
<span class="codeline" id="line-2145"><code>// This serves as a simple spin lock that we can use even</code></span>
<span class="codeline" id="line-2146"><code>// without an m. The thread that locks the stack in this way</code></span>
<span class="codeline" id="line-2147"><code>// unlocks the stack by storing a valid stack head pointer.</code></span>
<span class="codeline" id="line-2148"><code>//</code></span>
<span class="codeline" id="line-2149"><code>// In order to make sure that there is always an m structure</code></span>
<span class="codeline" id="line-2150"><code>// available to be stolen, we maintain the invariant that there</code></span>
<span class="codeline" id="line-2151"><code>// is always one more than needed. At the beginning of the</code></span>
<span class="codeline" id="line-2152"><code>// program (if cgo is in use) the list is seeded with a single m.</code></span>
<span class="codeline" id="line-2153"><code>// If needm finds that it has taken the last m off the list, its job</code></span>
<span class="codeline" id="line-2154"><code>// is - once it has installed its own m so that it can do things like</code></span>
<span class="codeline" id="line-2155"><code>// allocate memory - to create a spare m and put it on the list.</code></span>
<span class="codeline" id="line-2156"><code>//</code></span>
<span class="codeline" id="line-2157"><code>// Each of these extra m's also has a g0 and a curg that are</code></span>
<span class="codeline" id="line-2158"><code>// pressed into service as the scheduling stack and current</code></span>
<span class="codeline" id="line-2159"><code>// goroutine for the duration of the cgo callback.</code></span>
<span class="codeline" id="line-2160"><code>//</code></span>
<span class="codeline" id="line-2161"><code>// It calls dropm to put the m back on the list,</code></span>
<span class="codeline" id="line-2162"><code>// 1. when the callback is done with the m in non-pthread platforms,</code></span>
<span class="codeline" id="line-2163"><code>// 2. or when the C thread exiting on pthread platforms.</code></span>
<span class="codeline" id="line-2164"><code>//</code></span>
<span class="codeline" id="line-2165"><code>// The signal argument indicates whether we're called from a signal</code></span>
<span class="codeline" id="line-2166"><code>// handler.</code></span>
<span class="codeline" id="line-2167"><code>//</code></span>
<span class="codeline" id="line-2168"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2169"><code>func needm(signal bool) {</code></span>
<span class="codeline" id="line-2170"><code>	if (iscgo || GOOS == "windows") &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-2171"><code>		// Can happen if C/C++ code calls Go from a global ctor.</code></span>
<span class="codeline" id="line-2172"><code>		// Can also happen on Windows if a global ctor uses a</code></span>
<span class="codeline" id="line-2173"><code>		// callback created by syscall.NewCallback. See issue #6751</code></span>
<span class="codeline" id="line-2174"><code>		// for details.</code></span>
<span class="codeline" id="line-2175"><code>		//</code></span>
<span class="codeline" id="line-2176"><code>		// Can not throw, because scheduler is not initialized yet.</code></span>
<span class="codeline" id="line-2177"><code>		writeErrStr("fatal error: cgo callback before cgo call\n")</code></span>
<span class="codeline" id="line-2178"><code>		exit(1)</code></span>
<span class="codeline" id="line-2179"><code>	}</code></span>
<span class="codeline" id="line-2180"><code></code></span>
<span class="codeline" id="line-2181"><code>	// Save and block signals before getting an M.</code></span>
<span class="codeline" id="line-2182"><code>	// The signal handler may call needm itself,</code></span>
<span class="codeline" id="line-2183"><code>	// and we must avoid a deadlock. Also, once g is installed,</code></span>
<span class="codeline" id="line-2184"><code>	// any incoming signals will try to execute,</code></span>
<span class="codeline" id="line-2185"><code>	// but we won't have the sigaltstack settings and other data</code></span>
<span class="codeline" id="line-2186"><code>	// set up appropriately until the end of minit, which will</code></span>
<span class="codeline" id="line-2187"><code>	// unblock the signals. This is the same dance as when</code></span>
<span class="codeline" id="line-2188"><code>	// starting a new m to run Go code via newosproc.</code></span>
<span class="codeline" id="line-2189"><code>	var sigmask sigset</code></span>
<span class="codeline" id="line-2190"><code>	sigsave(&amp;sigmask)</code></span>
<span class="codeline" id="line-2191"><code>	sigblock(false)</code></span>
<span class="codeline" id="line-2192"><code></code></span>
<span class="codeline" id="line-2193"><code>	// getExtraM is safe here because of the invariant above,</code></span>
<span class="codeline" id="line-2194"><code>	// that the extra list always contains or will soon contain</code></span>
<span class="codeline" id="line-2195"><code>	// at least one m.</code></span>
<span class="codeline" id="line-2196"><code>	mp, last := getExtraM()</code></span>
<span class="codeline" id="line-2197"><code></code></span>
<span class="codeline" id="line-2198"><code>	// Set needextram when we've just emptied the list,</code></span>
<span class="codeline" id="line-2199"><code>	// so that the eventual call into cgocallbackg will</code></span>
<span class="codeline" id="line-2200"><code>	// allocate a new m for the extra list. We delay the</code></span>
<span class="codeline" id="line-2201"><code>	// allocation until then so that it can be done</code></span>
<span class="codeline" id="line-2202"><code>	// after exitsyscall makes sure it is okay to be</code></span>
<span class="codeline" id="line-2203"><code>	// running at all (that is, there's no garbage collection</code></span>
<span class="codeline" id="line-2204"><code>	// running right now).</code></span>
<span class="codeline" id="line-2205"><code>	mp.needextram = last</code></span>
<span class="codeline" id="line-2206"><code></code></span>
<span class="codeline" id="line-2207"><code>	// Store the original signal mask for use by minit.</code></span>
<span class="codeline" id="line-2208"><code>	mp.sigmask = sigmask</code></span>
<span class="codeline" id="line-2209"><code></code></span>
<span class="codeline" id="line-2210"><code>	// Install TLS on some platforms (previously setg</code></span>
<span class="codeline" id="line-2211"><code>	// would do this if necessary).</code></span>
<span class="codeline" id="line-2212"><code>	osSetupTLS(mp)</code></span>
<span class="codeline" id="line-2213"><code></code></span>
<span class="codeline" id="line-2214"><code>	// Install g (= m-&gt;g0) and set the stack bounds</code></span>
<span class="codeline" id="line-2215"><code>	// to match the current stack.</code></span>
<span class="codeline" id="line-2216"><code>	setg(mp.g0)</code></span>
<span class="codeline" id="line-2217"><code>	sp := getcallersp()</code></span>
<span class="codeline" id="line-2218"><code>	callbackUpdateSystemStack(mp, sp, signal)</code></span>
<span class="codeline" id="line-2219"><code></code></span>
<span class="codeline" id="line-2220"><code>	// Should mark we are already in Go now.</code></span>
<span class="codeline" id="line-2221"><code>	// Otherwise, we may call needm again when we get a signal, before cgocallbackg1,</code></span>
<span class="codeline" id="line-2222"><code>	// which means the extram list may be empty, that will cause a deadlock.</code></span>
<span class="codeline" id="line-2223"><code>	mp.isExtraInC = false</code></span>
<span class="codeline" id="line-2224"><code></code></span>
<span class="codeline" id="line-2225"><code>	// Initialize this thread to use the m.</code></span>
<span class="codeline" id="line-2226"><code>	asminit()</code></span>
<span class="codeline" id="line-2227"><code>	minit()</code></span>
<span class="codeline" id="line-2228"><code></code></span>
<span class="codeline" id="line-2229"><code>	// Emit a trace event for this dead -&gt; syscall transition,</code></span>
<span class="codeline" id="line-2230"><code>	// but only in the new tracer and only if we're not in a signal handler.</code></span>
<span class="codeline" id="line-2231"><code>	//</code></span>
<span class="codeline" id="line-2232"><code>	// N.B. the tracer can run on a bare M just fine, we just have</code></span>
<span class="codeline" id="line-2233"><code>	// to make sure to do this before setg(nil) and unminit.</code></span>
<span class="codeline" id="line-2234"><code>	var trace traceLocker</code></span>
<span class="codeline" id="line-2235"><code>	if goexperiment.ExecTracer2 &amp;&amp; !signal {</code></span>
<span class="codeline" id="line-2236"><code>		trace = traceAcquire()</code></span>
<span class="codeline" id="line-2237"><code>	}</code></span>
<span class="codeline" id="line-2238"><code></code></span>
<span class="codeline" id="line-2239"><code>	// mp.curg is now a real goroutine.</code></span>
<span class="codeline" id="line-2240"><code>	casgstatus(mp.curg, _Gdead, _Gsyscall)</code></span>
<span class="codeline" id="line-2241"><code>	sched.ngsys.Add(-1)</code></span>
<span class="codeline" id="line-2242"><code></code></span>
<span class="codeline" id="line-2243"><code>	if goexperiment.ExecTracer2 &amp;&amp; !signal {</code></span>
<span class="codeline" id="line-2244"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-2245"><code>			trace.GoCreateSyscall(mp.curg)</code></span>
<span class="codeline" id="line-2246"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-2247"><code>		}</code></span>
<span class="codeline" id="line-2248"><code>	}</code></span>
<span class="codeline" id="line-2249"><code>	mp.isExtraInSig = signal</code></span>
<span class="codeline" id="line-2250"><code>}</code></span>
<span class="codeline" id="line-2251"><code></code></span>
<span class="codeline" id="line-2252"><code>// Acquire an extra m and bind it to the C thread when a pthread key has been created.</code></span>
<span class="codeline" id="line-2253"><code>//</code></span>
<span class="codeline" id="line-2254"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2255"><code>func needAndBindM() {</code></span>
<span class="codeline" id="line-2256"><code>	needm(false)</code></span>
<span class="codeline" id="line-2257"><code></code></span>
<span class="codeline" id="line-2258"><code>	if _cgo_pthread_key_created != nil &amp;&amp; *(*uintptr)(_cgo_pthread_key_created) != 0 {</code></span>
<span class="codeline" id="line-2259"><code>		cgoBindM()</code></span>
<span class="codeline" id="line-2260"><code>	}</code></span>
<span class="codeline" id="line-2261"><code>}</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>// newextram allocates m's and puts them on the extra list.</code></span>
<span class="codeline" id="line-2264"><code>// It is called with a working local m, so that it can do things</code></span>
<span class="codeline" id="line-2265"><code>// like call schedlock and allocate.</code></span>
<span class="codeline" id="line-2266"><code>func newextram() {</code></span>
<span class="codeline" id="line-2267"><code>	c := extraMWaiters.Swap(0)</code></span>
<span class="codeline" id="line-2268"><code>	if c &gt; 0 {</code></span>
<span class="codeline" id="line-2269"><code>		for i := uint32(0); i &lt; c; i++ {</code></span>
<span class="codeline" id="line-2270"><code>			oneNewExtraM()</code></span>
<span class="codeline" id="line-2271"><code>		}</code></span>
<span class="codeline" id="line-2272"><code>	} else if extraMLength.Load() == 0 {</code></span>
<span class="codeline" id="line-2273"><code>		// Make sure there is at least one extra M.</code></span>
<span class="codeline" id="line-2274"><code>		oneNewExtraM()</code></span>
<span class="codeline" id="line-2275"><code>	}</code></span>
<span class="codeline" id="line-2276"><code>}</code></span>
<span class="codeline" id="line-2277"><code></code></span>
<span class="codeline" id="line-2278"><code>// oneNewExtraM allocates an m and puts it on the extra list.</code></span>
<span class="codeline" id="line-2279"><code>func oneNewExtraM() {</code></span>
<span class="codeline" id="line-2280"><code>	// Create extra goroutine locked to extra m.</code></span>
<span class="codeline" id="line-2281"><code>	// The goroutine is the context in which the cgo callback will run.</code></span>
<span class="codeline" id="line-2282"><code>	// The sched.pc will never be returned to, but setting it to</code></span>
<span class="codeline" id="line-2283"><code>	// goexit makes clear to the traceback routines where</code></span>
<span class="codeline" id="line-2284"><code>	// the goroutine stack ends.</code></span>
<span class="codeline" id="line-2285"><code>	mp := allocm(nil, nil, -1)</code></span>
<span class="codeline" id="line-2286"><code>	gp := malg(4096)</code></span>
<span class="codeline" id="line-2287"><code>	gp.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum</code></span>
<span class="codeline" id="line-2288"><code>	gp.sched.sp = gp.stack.hi</code></span>
<span class="codeline" id="line-2289"><code>	gp.sched.sp -= 4 * goarch.PtrSize // extra space in case of reads slightly beyond frame</code></span>
<span class="codeline" id="line-2290"><code>	gp.sched.lr = 0</code></span>
<span class="codeline" id="line-2291"><code>	gp.sched.g = guintptr(unsafe.Pointer(gp))</code></span>
<span class="codeline" id="line-2292"><code>	gp.syscallpc = gp.sched.pc</code></span>
<span class="codeline" id="line-2293"><code>	gp.syscallsp = gp.sched.sp</code></span>
<span class="codeline" id="line-2294"><code>	gp.stktopsp = gp.sched.sp</code></span>
<span class="codeline" id="line-2295"><code>	// malg returns status as _Gidle. Change to _Gdead before</code></span>
<span class="codeline" id="line-2296"><code>	// adding to allg where GC can see it. We use _Gdead to hide</code></span>
<span class="codeline" id="line-2297"><code>	// this from tracebacks and stack scans since it isn't a</code></span>
<span class="codeline" id="line-2298"><code>	// "real" goroutine until needm grabs it.</code></span>
<span class="codeline" id="line-2299"><code>	casgstatus(gp, _Gidle, _Gdead)</code></span>
<span class="codeline" id="line-2300"><code>	gp.m = mp</code></span>
<span class="codeline" id="line-2301"><code>	mp.curg = gp</code></span>
<span class="codeline" id="line-2302"><code>	mp.isextra = true</code></span>
<span class="codeline" id="line-2303"><code>	// mark we are in C by default.</code></span>
<span class="codeline" id="line-2304"><code>	mp.isExtraInC = true</code></span>
<span class="codeline" id="line-2305"><code>	mp.lockedInt++</code></span>
<span class="codeline" id="line-2306"><code>	mp.lockedg.set(gp)</code></span>
<span class="codeline" id="line-2307"><code>	gp.lockedm.set(mp)</code></span>
<span class="codeline" id="line-2308"><code>	gp.goid = sched.goidgen.Add(1)</code></span>
<span class="codeline" id="line-2309"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-2310"><code>		gp.racectx = racegostart(abi.FuncPCABIInternal(newextram) + sys.PCQuantum)</code></span>
<span class="codeline" id="line-2311"><code>	}</code></span>
<span class="codeline" id="line-2312"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-2313"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-2314"><code>		trace.OneNewExtraM(gp)</code></span>
<span class="codeline" id="line-2315"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-2316"><code>	}</code></span>
<span class="codeline" id="line-2317"><code>	// put on allg for garbage collector</code></span>
<span class="codeline" id="line-2318"><code>	allgadd(gp)</code></span>
<span class="codeline" id="line-2319"><code></code></span>
<span class="codeline" id="line-2320"><code>	// gp is now on the allg list, but we don't want it to be</code></span>
<span class="codeline" id="line-2321"><code>	// counted by gcount. It would be more "proper" to increment</code></span>
<span class="codeline" id="line-2322"><code>	// sched.ngfree, but that requires locking. Incrementing ngsys</code></span>
<span class="codeline" id="line-2323"><code>	// has the same effect.</code></span>
<span class="codeline" id="line-2324"><code>	sched.ngsys.Add(1)</code></span>
<span class="codeline" id="line-2325"><code></code></span>
<span class="codeline" id="line-2326"><code>	// Add m to the extra list.</code></span>
<span class="codeline" id="line-2327"><code>	addExtraM(mp)</code></span>
<span class="codeline" id="line-2328"><code>}</code></span>
<span class="codeline" id="line-2329"><code></code></span>
<span class="codeline" id="line-2330"><code>// dropm puts the current m back onto the extra list.</code></span>
<span class="codeline" id="line-2331"><code>//</code></span>
<span class="codeline" id="line-2332"><code>// 1. On systems without pthreads, like Windows</code></span>
<span class="codeline" id="line-2333"><code>// dropm is called when a cgo callback has called needm but is now</code></span>
<span class="codeline" id="line-2334"><code>// done with the callback and returning back into the non-Go thread.</code></span>
<span class="codeline" id="line-2335"><code>//</code></span>
<span class="codeline" id="line-2336"><code>// The main expense here is the call to signalstack to release the</code></span>
<span class="codeline" id="line-2337"><code>// m's signal stack, and then the call to needm on the next callback</code></span>
<span class="codeline" id="line-2338"><code>// from this thread. It is tempting to try to save the m for next time,</code></span>
<span class="codeline" id="line-2339"><code>// which would eliminate both these costs, but there might not be</code></span>
<span class="codeline" id="line-2340"><code>// a next time: the current thread (which Go does not control) might exit.</code></span>
<span class="codeline" id="line-2341"><code>// If we saved the m for that thread, there would be an m leak each time</code></span>
<span class="codeline" id="line-2342"><code>// such a thread exited. Instead, we acquire and release an m on each</code></span>
<span class="codeline" id="line-2343"><code>// call. These should typically not be scheduling operations, just a few</code></span>
<span class="codeline" id="line-2344"><code>// atomics, so the cost should be small.</code></span>
<span class="codeline" id="line-2345"><code>//</code></span>
<span class="codeline" id="line-2346"><code>// 2. On systems with pthreads</code></span>
<span class="codeline" id="line-2347"><code>// dropm is called while a non-Go thread is exiting.</code></span>
<span class="codeline" id="line-2348"><code>// We allocate a pthread per-thread variable using pthread_key_create,</code></span>
<span class="codeline" id="line-2349"><code>// to register a thread-exit-time destructor.</code></span>
<span class="codeline" id="line-2350"><code>// And store the g into a thread-specific value associated with the pthread key,</code></span>
<span class="codeline" id="line-2351"><code>// when first return back to C.</code></span>
<span class="codeline" id="line-2352"><code>// So that the destructor would invoke dropm while the non-Go thread is exiting.</code></span>
<span class="codeline" id="line-2353"><code>// This is much faster since it avoids expensive signal-related syscalls.</code></span>
<span class="codeline" id="line-2354"><code>//</code></span>
<span class="codeline" id="line-2355"><code>// This always runs without a P, so //go:nowritebarrierrec is required.</code></span>
<span class="codeline" id="line-2356"><code>//</code></span>
<span class="codeline" id="line-2357"><code>// This may run with a different stack than was recorded in g0 (there is no</code></span>
<span class="codeline" id="line-2358"><code>// call to callbackUpdateSystemStack prior to dropm), so this must be</code></span>
<span class="codeline" id="line-2359"><code>// //go:nosplit to avoid the stack bounds check.</code></span>
<span class="codeline" id="line-2360"><code>//</code></span>
<span class="codeline" id="line-2361"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2362"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2363"><code>func dropm() {</code></span>
<span class="codeline" id="line-2364"><code>	// Clear m and g, and return m to the extra list.</code></span>
<span class="codeline" id="line-2365"><code>	// After the call to setg we can only call nosplit functions</code></span>
<span class="codeline" id="line-2366"><code>	// with no pointer manipulation.</code></span>
<span class="codeline" id="line-2367"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-2368"><code></code></span>
<span class="codeline" id="line-2369"><code>	// Emit a trace event for this syscall -&gt; dead transition,</code></span>
<span class="codeline" id="line-2370"><code>	// but only in the new tracer.</code></span>
<span class="codeline" id="line-2371"><code>	//</code></span>
<span class="codeline" id="line-2372"><code>	// N.B. the tracer can run on a bare M just fine, we just have</code></span>
<span class="codeline" id="line-2373"><code>	// to make sure to do this before setg(nil) and unminit.</code></span>
<span class="codeline" id="line-2374"><code>	var trace traceLocker</code></span>
<span class="codeline" id="line-2375"><code>	if goexperiment.ExecTracer2 &amp;&amp; !mp.isExtraInSig {</code></span>
<span class="codeline" id="line-2376"><code>		trace = traceAcquire()</code></span>
<span class="codeline" id="line-2377"><code>	}</code></span>
<span class="codeline" id="line-2378"><code></code></span>
<span class="codeline" id="line-2379"><code>	// Return mp.curg to dead state.</code></span>
<span class="codeline" id="line-2380"><code>	casgstatus(mp.curg, _Gsyscall, _Gdead)</code></span>
<span class="codeline" id="line-2381"><code>	mp.curg.preemptStop = false</code></span>
<span class="codeline" id="line-2382"><code>	sched.ngsys.Add(1)</code></span>
<span class="codeline" id="line-2383"><code></code></span>
<span class="codeline" id="line-2384"><code>	if goexperiment.ExecTracer2 &amp;&amp; !mp.isExtraInSig {</code></span>
<span class="codeline" id="line-2385"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-2386"><code>			trace.GoDestroySyscall()</code></span>
<span class="codeline" id="line-2387"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-2388"><code>		}</code></span>
<span class="codeline" id="line-2389"><code>	}</code></span>
<span class="codeline" id="line-2390"><code></code></span>
<span class="codeline" id="line-2391"><code>	if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-2392"><code>		// Trash syscalltick so that it doesn't line up with mp.old.syscalltick anymore.</code></span>
<span class="codeline" id="line-2393"><code>		//</code></span>
<span class="codeline" id="line-2394"><code>		// In the new tracer, we model needm and dropm and a goroutine being created and</code></span>
<span class="codeline" id="line-2395"><code>		// destroyed respectively. The m then might get reused with a different procid but</code></span>
<span class="codeline" id="line-2396"><code>		// still with a reference to oldp, and still with the same syscalltick. The next</code></span>
<span class="codeline" id="line-2397"><code>		// time a G is "created" in needm, it'll return and quietly reacquire its P from a</code></span>
<span class="codeline" id="line-2398"><code>		// different m with a different procid, which will confuse the trace parser. By</code></span>
<span class="codeline" id="line-2399"><code>		// trashing syscalltick, we ensure that it'll appear as if we lost the P to the</code></span>
<span class="codeline" id="line-2400"><code>		// tracer parser and that we just reacquired it.</code></span>
<span class="codeline" id="line-2401"><code>		//</code></span>
<span class="codeline" id="line-2402"><code>		// Trash the value by decrementing because that gets us as far away from the value</code></span>
<span class="codeline" id="line-2403"><code>		// the syscall exit code expects as possible. Setting to zero is risky because</code></span>
<span class="codeline" id="line-2404"><code>		// syscalltick could already be zero (and in fact, is initialized to zero).</code></span>
<span class="codeline" id="line-2405"><code>		mp.syscalltick--</code></span>
<span class="codeline" id="line-2406"><code>	}</code></span>
<span class="codeline" id="line-2407"><code></code></span>
<span class="codeline" id="line-2408"><code>	// Reset trace state unconditionally. This goroutine is being 'destroyed'</code></span>
<span class="codeline" id="line-2409"><code>	// from the perspective of the tracer.</code></span>
<span class="codeline" id="line-2410"><code>	mp.curg.trace.reset()</code></span>
<span class="codeline" id="line-2411"><code></code></span>
<span class="codeline" id="line-2412"><code>	// Flush all the M's buffers. This is necessary because the M might</code></span>
<span class="codeline" id="line-2413"><code>	// be used on a different thread with a different procid, so we have</code></span>
<span class="codeline" id="line-2414"><code>	// to make sure we don't write into the same buffer.</code></span>
<span class="codeline" id="line-2415"><code>	//</code></span>
<span class="codeline" id="line-2416"><code>	// N.B. traceThreadDestroy is a no-op in the old tracer, so avoid the</code></span>
<span class="codeline" id="line-2417"><code>	// unnecessary acquire/release of the lock.</code></span>
<span class="codeline" id="line-2418"><code>	if goexperiment.ExecTracer2 &amp;&amp; (traceEnabled() || traceShuttingDown()) {</code></span>
<span class="codeline" id="line-2419"><code>		// Acquire sched.lock across thread destruction. One of the invariants of the tracer</code></span>
<span class="codeline" id="line-2420"><code>		// is that a thread cannot disappear from the tracer's view (allm or freem) without</code></span>
<span class="codeline" id="line-2421"><code>		// it noticing, so it requires that sched.lock be held over traceThreadDestroy.</code></span>
<span class="codeline" id="line-2422"><code>		//</code></span>
<span class="codeline" id="line-2423"><code>		// This isn't strictly necessary in this case, because this thread never leaves allm,</code></span>
<span class="codeline" id="line-2424"><code>		// but the critical section is short and dropm is rare on pthread platforms, so just</code></span>
<span class="codeline" id="line-2425"><code>		// take the lock and play it safe. traceThreadDestroy also asserts that the lock is held.</code></span>
<span class="codeline" id="line-2426"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2427"><code>		traceThreadDestroy(mp)</code></span>
<span class="codeline" id="line-2428"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2429"><code>	}</code></span>
<span class="codeline" id="line-2430"><code>	mp.isExtraInSig = false</code></span>
<span class="codeline" id="line-2431"><code></code></span>
<span class="codeline" id="line-2432"><code>	// Block signals before unminit.</code></span>
<span class="codeline" id="line-2433"><code>	// Unminit unregisters the signal handling stack (but needs g on some systems).</code></span>
<span class="codeline" id="line-2434"><code>	// Setg(nil) clears g, which is the signal handler's cue not to run Go handlers.</code></span>
<span class="codeline" id="line-2435"><code>	// It's important not to try to handle a signal between those two steps.</code></span>
<span class="codeline" id="line-2436"><code>	sigmask := mp.sigmask</code></span>
<span class="codeline" id="line-2437"><code>	sigblock(false)</code></span>
<span class="codeline" id="line-2438"><code>	unminit()</code></span>
<span class="codeline" id="line-2439"><code></code></span>
<span class="codeline" id="line-2440"><code>	setg(nil)</code></span>
<span class="codeline" id="line-2441"><code></code></span>
<span class="codeline" id="line-2442"><code>	// Clear g0 stack bounds to ensure that needm always refreshes the</code></span>
<span class="codeline" id="line-2443"><code>	// bounds when reusing this M.</code></span>
<span class="codeline" id="line-2444"><code>	g0 := mp.g0</code></span>
<span class="codeline" id="line-2445"><code>	g0.stack.hi = 0</code></span>
<span class="codeline" id="line-2446"><code>	g0.stack.lo = 0</code></span>
<span class="codeline" id="line-2447"><code>	g0.stackguard0 = 0</code></span>
<span class="codeline" id="line-2448"><code>	g0.stackguard1 = 0</code></span>
<span class="codeline" id="line-2449"><code></code></span>
<span class="codeline" id="line-2450"><code>	putExtraM(mp)</code></span>
<span class="codeline" id="line-2451"><code></code></span>
<span class="codeline" id="line-2452"><code>	msigrestore(sigmask)</code></span>
<span class="codeline" id="line-2453"><code>}</code></span>
<span class="codeline" id="line-2454"><code></code></span>
<span class="codeline" id="line-2455"><code>// bindm store the g0 of the current m into a thread-specific value.</code></span>
<span class="codeline" id="line-2456"><code>//</code></span>
<span class="codeline" id="line-2457"><code>// We allocate a pthread per-thread variable using pthread_key_create,</code></span>
<span class="codeline" id="line-2458"><code>// to register a thread-exit-time destructor.</code></span>
<span class="codeline" id="line-2459"><code>// We are here setting the thread-specific value of the pthread key, to enable the destructor.</code></span>
<span class="codeline" id="line-2460"><code>// So that the pthread_key_destructor would dropm while the C thread is exiting.</code></span>
<span class="codeline" id="line-2461"><code>//</code></span>
<span class="codeline" id="line-2462"><code>// And the saved g will be used in pthread_key_destructor,</code></span>
<span class="codeline" id="line-2463"><code>// since the g stored in the TLS by Go might be cleared in some platforms,</code></span>
<span class="codeline" id="line-2464"><code>// before the destructor invoked, so, we restore g by the stored g, before dropm.</code></span>
<span class="codeline" id="line-2465"><code>//</code></span>
<span class="codeline" id="line-2466"><code>// We store g0 instead of m, to make the assembly code simpler,</code></span>
<span class="codeline" id="line-2467"><code>// since we need to restore g0 in runtime.cgocallback.</code></span>
<span class="codeline" id="line-2468"><code>//</code></span>
<span class="codeline" id="line-2469"><code>// On systems without pthreads, like Windows, bindm shouldn't be used.</code></span>
<span class="codeline" id="line-2470"><code>//</code></span>
<span class="codeline" id="line-2471"><code>// NOTE: this always runs without a P, so, nowritebarrierrec required.</code></span>
<span class="codeline" id="line-2472"><code>//</code></span>
<span class="codeline" id="line-2473"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2474"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2475"><code>func cgoBindM() {</code></span>
<span class="codeline" id="line-2476"><code>	if GOOS == "windows" || GOOS == "plan9" {</code></span>
<span class="codeline" id="line-2477"><code>		fatal("bindm in unexpected GOOS")</code></span>
<span class="codeline" id="line-2478"><code>	}</code></span>
<span class="codeline" id="line-2479"><code>	g := getg()</code></span>
<span class="codeline" id="line-2480"><code>	if g.m.g0 != g {</code></span>
<span class="codeline" id="line-2481"><code>		fatal("the current g is not g0")</code></span>
<span class="codeline" id="line-2482"><code>	}</code></span>
<span class="codeline" id="line-2483"><code>	if _cgo_bindm != nil {</code></span>
<span class="codeline" id="line-2484"><code>		asmcgocall(_cgo_bindm, unsafe.Pointer(g))</code></span>
<span class="codeline" id="line-2485"><code>	}</code></span>
<span class="codeline" id="line-2486"><code>}</code></span>
<span class="codeline" id="line-2487"><code></code></span>
<span class="codeline" id="line-2488"><code>// A helper function for EnsureDropM.</code></span>
<span class="codeline" id="line-2489"><code>func getm() uintptr {</code></span>
<span class="codeline" id="line-2490"><code>	return uintptr(unsafe.Pointer(getg().m))</code></span>
<span class="codeline" id="line-2491"><code>}</code></span>
<span class="codeline" id="line-2492"><code></code></span>
<span class="codeline" id="line-2493"><code>var (</code></span>
<span class="codeline" id="line-2494"><code>	// Locking linked list of extra M's, via mp.schedlink. Must be accessed</code></span>
<span class="codeline" id="line-2495"><code>	// only via lockextra/unlockextra.</code></span>
<span class="codeline" id="line-2496"><code>	//</code></span>
<span class="codeline" id="line-2497"><code>	// Can't be atomic.Pointer[m] because we use an invalid pointer as a</code></span>
<span class="codeline" id="line-2498"><code>	// "locked" sentinel value. M's on this list remain visible to the GC</code></span>
<span class="codeline" id="line-2499"><code>	// because their mp.curg is on allgs.</code></span>
<span class="codeline" id="line-2500"><code>	extraM atomic.Uintptr</code></span>
<span class="codeline" id="line-2501"><code>	// Number of M's in the extraM list.</code></span>
<span class="codeline" id="line-2502"><code>	extraMLength atomic.Uint32</code></span>
<span class="codeline" id="line-2503"><code>	// Number of waiters in lockextra.</code></span>
<span class="codeline" id="line-2504"><code>	extraMWaiters atomic.Uint32</code></span>
<span class="codeline" id="line-2505"><code></code></span>
<span class="codeline" id="line-2506"><code>	// Number of extra M's in use by threads.</code></span>
<span class="codeline" id="line-2507"><code>	extraMInUse atomic.Uint32</code></span>
<span class="codeline" id="line-2508"><code>)</code></span>
<span class="codeline" id="line-2509"><code></code></span>
<span class="codeline" id="line-2510"><code>// lockextra locks the extra list and returns the list head.</code></span>
<span class="codeline" id="line-2511"><code>// The caller must unlock the list by storing a new list head</code></span>
<span class="codeline" id="line-2512"><code>// to extram. If nilokay is true, then lockextra will</code></span>
<span class="codeline" id="line-2513"><code>// return a nil list head if that's what it finds. If nilokay is false,</code></span>
<span class="codeline" id="line-2514"><code>// lockextra will keep waiting until the list head is no longer nil.</code></span>
<span class="codeline" id="line-2515"><code>//</code></span>
<span class="codeline" id="line-2516"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2517"><code>func lockextra(nilokay bool) *m {</code></span>
<span class="codeline" id="line-2518"><code>	const locked = 1</code></span>
<span class="codeline" id="line-2519"><code></code></span>
<span class="codeline" id="line-2520"><code>	incr := false</code></span>
<span class="codeline" id="line-2521"><code>	for {</code></span>
<span class="codeline" id="line-2522"><code>		old := extraM.Load()</code></span>
<span class="codeline" id="line-2523"><code>		if old == locked {</code></span>
<span class="codeline" id="line-2524"><code>			osyield_no_g()</code></span>
<span class="codeline" id="line-2525"><code>			continue</code></span>
<span class="codeline" id="line-2526"><code>		}</code></span>
<span class="codeline" id="line-2527"><code>		if old == 0 &amp;&amp; !nilokay {</code></span>
<span class="codeline" id="line-2528"><code>			if !incr {</code></span>
<span class="codeline" id="line-2529"><code>				// Add 1 to the number of threads</code></span>
<span class="codeline" id="line-2530"><code>				// waiting for an M.</code></span>
<span class="codeline" id="line-2531"><code>				// This is cleared by newextram.</code></span>
<span class="codeline" id="line-2532"><code>				extraMWaiters.Add(1)</code></span>
<span class="codeline" id="line-2533"><code>				incr = true</code></span>
<span class="codeline" id="line-2534"><code>			}</code></span>
<span class="codeline" id="line-2535"><code>			usleep_no_g(1)</code></span>
<span class="codeline" id="line-2536"><code>			continue</code></span>
<span class="codeline" id="line-2537"><code>		}</code></span>
<span class="codeline" id="line-2538"><code>		if extraM.CompareAndSwap(old, locked) {</code></span>
<span class="codeline" id="line-2539"><code>			return (*m)(unsafe.Pointer(old))</code></span>
<span class="codeline" id="line-2540"><code>		}</code></span>
<span class="codeline" id="line-2541"><code>		osyield_no_g()</code></span>
<span class="codeline" id="line-2542"><code>		continue</code></span>
<span class="codeline" id="line-2543"><code>	}</code></span>
<span class="codeline" id="line-2544"><code>}</code></span>
<span class="codeline" id="line-2545"><code></code></span>
<span class="codeline" id="line-2546"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2547"><code>func unlockextra(mp *m, delta int32) {</code></span>
<span class="codeline" id="line-2548"><code>	extraMLength.Add(delta)</code></span>
<span class="codeline" id="line-2549"><code>	extraM.Store(uintptr(unsafe.Pointer(mp)))</code></span>
<span class="codeline" id="line-2550"><code>}</code></span>
<span class="codeline" id="line-2551"><code></code></span>
<span class="codeline" id="line-2552"><code>// Return an M from the extra M list. Returns last == true if the list becomes</code></span>
<span class="codeline" id="line-2553"><code>// empty because of this call.</code></span>
<span class="codeline" id="line-2554"><code>//</code></span>
<span class="codeline" id="line-2555"><code>// Spins waiting for an extra M, so caller must ensure that the list always</code></span>
<span class="codeline" id="line-2556"><code>// contains or will soon contain at least one M.</code></span>
<span class="codeline" id="line-2557"><code>//</code></span>
<span class="codeline" id="line-2558"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2559"><code>func getExtraM() (mp *m, last bool) {</code></span>
<span class="codeline" id="line-2560"><code>	mp = lockextra(false)</code></span>
<span class="codeline" id="line-2561"><code>	extraMInUse.Add(1)</code></span>
<span class="codeline" id="line-2562"><code>	unlockextra(mp.schedlink.ptr(), -1)</code></span>
<span class="codeline" id="line-2563"><code>	return mp, mp.schedlink.ptr() == nil</code></span>
<span class="codeline" id="line-2564"><code>}</code></span>
<span class="codeline" id="line-2565"><code></code></span>
<span class="codeline" id="line-2566"><code>// Returns an extra M back to the list. mp must be from getExtraM. Newly</code></span>
<span class="codeline" id="line-2567"><code>// allocated M's should use addExtraM.</code></span>
<span class="codeline" id="line-2568"><code>//</code></span>
<span class="codeline" id="line-2569"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2570"><code>func putExtraM(mp *m) {</code></span>
<span class="codeline" id="line-2571"><code>	extraMInUse.Add(-1)</code></span>
<span class="codeline" id="line-2572"><code>	addExtraM(mp)</code></span>
<span class="codeline" id="line-2573"><code>}</code></span>
<span class="codeline" id="line-2574"><code></code></span>
<span class="codeline" id="line-2575"><code>// Adds a newly allocated M to the extra M list.</code></span>
<span class="codeline" id="line-2576"><code>//</code></span>
<span class="codeline" id="line-2577"><code>//go:nosplit</code></span>
<span class="codeline" id="line-2578"><code>func addExtraM(mp *m) {</code></span>
<span class="codeline" id="line-2579"><code>	mnext := lockextra(true)</code></span>
<span class="codeline" id="line-2580"><code>	mp.schedlink.set(mnext)</code></span>
<span class="codeline" id="line-2581"><code>	unlockextra(mp, 1)</code></span>
<span class="codeline" id="line-2582"><code>}</code></span>
<span class="codeline" id="line-2583"><code></code></span>
<span class="codeline" id="line-2584"><code>var (</code></span>
<span class="codeline" id="line-2585"><code>	// allocmLock is locked for read when creating new Ms in allocm and their</code></span>
<span class="codeline" id="line-2586"><code>	// addition to allm. Thus acquiring this lock for write blocks the</code></span>
<span class="codeline" id="line-2587"><code>	// creation of new Ms.</code></span>
<span class="codeline" id="line-2588"><code>	allocmLock rwmutex</code></span>
<span class="codeline" id="line-2589"><code></code></span>
<span class="codeline" id="line-2590"><code>	// execLock serializes exec and clone to avoid bugs or unspecified</code></span>
<span class="codeline" id="line-2591"><code>	// behaviour around exec'ing while creating/destroying threads. See</code></span>
<span class="codeline" id="line-2592"><code>	// issue #19546.</code></span>
<span class="codeline" id="line-2593"><code>	execLock rwmutex</code></span>
<span class="codeline" id="line-2594"><code>)</code></span>
<span class="codeline" id="line-2595"><code></code></span>
<span class="codeline" id="line-2596"><code>// These errors are reported (via writeErrStr) by some OS-specific</code></span>
<span class="codeline" id="line-2597"><code>// versions of newosproc and newosproc0.</code></span>
<span class="codeline" id="line-2598"><code>const (</code></span>
<span class="codeline" id="line-2599"><code>	failthreadcreate  = "runtime: failed to create new OS thread\n"</code></span>
<span class="codeline" id="line-2600"><code>	failallocatestack = "runtime: failed to allocate stack for the new OS thread\n"</code></span>
<span class="codeline" id="line-2601"><code>)</code></span>
<span class="codeline" id="line-2602"><code></code></span>
<span class="codeline" id="line-2603"><code>// newmHandoff contains a list of m structures that need new OS threads.</code></span>
<span class="codeline" id="line-2604"><code>// This is used by newm in situations where newm itself can't safely</code></span>
<span class="codeline" id="line-2605"><code>// start an OS thread.</code></span>
<span class="codeline" id="line-2606"><code>var newmHandoff struct {</code></span>
<span class="codeline" id="line-2607"><code>	lock mutex</code></span>
<span class="codeline" id="line-2608"><code></code></span>
<span class="codeline" id="line-2609"><code>	// newm points to a list of M structures that need new OS</code></span>
<span class="codeline" id="line-2610"><code>	// threads. The list is linked through m.schedlink.</code></span>
<span class="codeline" id="line-2611"><code>	newm muintptr</code></span>
<span class="codeline" id="line-2612"><code></code></span>
<span class="codeline" id="line-2613"><code>	// waiting indicates that wake needs to be notified when an m</code></span>
<span class="codeline" id="line-2614"><code>	// is put on the list.</code></span>
<span class="codeline" id="line-2615"><code>	waiting bool</code></span>
<span class="codeline" id="line-2616"><code>	wake    note</code></span>
<span class="codeline" id="line-2617"><code></code></span>
<span class="codeline" id="line-2618"><code>	// haveTemplateThread indicates that the templateThread has</code></span>
<span class="codeline" id="line-2619"><code>	// been started. This is not protected by lock. Use cas to set</code></span>
<span class="codeline" id="line-2620"><code>	// to 1.</code></span>
<span class="codeline" id="line-2621"><code>	haveTemplateThread uint32</code></span>
<span class="codeline" id="line-2622"><code>}</code></span>
<span class="codeline" id="line-2623"><code></code></span>
<span class="codeline" id="line-2624"><code>// Create a new m. It will start off with a call to fn, or else the scheduler.</code></span>
<span class="codeline" id="line-2625"><code>// fn needs to be static and not a heap allocated closure.</code></span>
<span class="codeline" id="line-2626"><code>// May run with m.p==nil, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-2627"><code>//</code></span>
<span class="codeline" id="line-2628"><code>// id is optional pre-allocated m ID. Omit by passing -1.</code></span>
<span class="codeline" id="line-2629"><code>//</code></span>
<span class="codeline" id="line-2630"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2631"><code>func newm(fn func(), pp *p, id int64) {</code></span>
<span class="codeline" id="line-2632"><code>	// allocm adds a new M to allm, but they do not start until created by</code></span>
<span class="codeline" id="line-2633"><code>	// the OS in newm1 or the template thread.</code></span>
<span class="codeline" id="line-2634"><code>	//</code></span>
<span class="codeline" id="line-2635"><code>	// doAllThreadsSyscall requires that every M in allm will eventually</code></span>
<span class="codeline" id="line-2636"><code>	// start and be signal-able, even with a STW.</code></span>
<span class="codeline" id="line-2637"><code>	//</code></span>
<span class="codeline" id="line-2638"><code>	// Disable preemption here until we start the thread to ensure that</code></span>
<span class="codeline" id="line-2639"><code>	// newm is not preempted between allocm and starting the new thread,</code></span>
<span class="codeline" id="line-2640"><code>	// ensuring that anything added to allm is guaranteed to eventually</code></span>
<span class="codeline" id="line-2641"><code>	// start.</code></span>
<span class="codeline" id="line-2642"><code>	acquirem()</code></span>
<span class="codeline" id="line-2643"><code></code></span>
<span class="codeline" id="line-2644"><code>	mp := allocm(pp, fn, id)</code></span>
<span class="codeline" id="line-2645"><code>	mp.nextp.set(pp)</code></span>
<span class="codeline" id="line-2646"><code>	mp.sigmask = initSigmask</code></span>
<span class="codeline" id="line-2647"><code>	if gp := getg(); gp != nil &amp;&amp; gp.m != nil &amp;&amp; (gp.m.lockedExt != 0 || gp.m.incgo) &amp;&amp; GOOS != "plan9" {</code></span>
<span class="codeline" id="line-2648"><code>		// We're on a locked M or a thread that may have been</code></span>
<span class="codeline" id="line-2649"><code>		// started by C. The kernel state of this thread may</code></span>
<span class="codeline" id="line-2650"><code>		// be strange (the user may have locked it for that</code></span>
<span class="codeline" id="line-2651"><code>		// purpose). We don't want to clone that into another</code></span>
<span class="codeline" id="line-2652"><code>		// thread. Instead, ask a known-good thread to create</code></span>
<span class="codeline" id="line-2653"><code>		// the thread for us.</code></span>
<span class="codeline" id="line-2654"><code>		//</code></span>
<span class="codeline" id="line-2655"><code>		// This is disabled on Plan 9. See golang.org/issue/22227.</code></span>
<span class="codeline" id="line-2656"><code>		//</code></span>
<span class="codeline" id="line-2657"><code>		// TODO: This may be unnecessary on Windows, which</code></span>
<span class="codeline" id="line-2658"><code>		// doesn't model thread creation off fork.</code></span>
<span class="codeline" id="line-2659"><code>		lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2660"><code>		if newmHandoff.haveTemplateThread == 0 {</code></span>
<span class="codeline" id="line-2661"><code>			throw("on a locked thread with no template thread")</code></span>
<span class="codeline" id="line-2662"><code>		}</code></span>
<span class="codeline" id="line-2663"><code>		mp.schedlink = newmHandoff.newm</code></span>
<span class="codeline" id="line-2664"><code>		newmHandoff.newm.set(mp)</code></span>
<span class="codeline" id="line-2665"><code>		if newmHandoff.waiting {</code></span>
<span class="codeline" id="line-2666"><code>			newmHandoff.waiting = false</code></span>
<span class="codeline" id="line-2667"><code>			notewakeup(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-2668"><code>		}</code></span>
<span class="codeline" id="line-2669"><code>		unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2670"><code>		// The M has not started yet, but the template thread does not</code></span>
<span class="codeline" id="line-2671"><code>		// participate in STW, so it will always process queued Ms and</code></span>
<span class="codeline" id="line-2672"><code>		// it is safe to releasem.</code></span>
<span class="codeline" id="line-2673"><code>		releasem(getg().m)</code></span>
<span class="codeline" id="line-2674"><code>		return</code></span>
<span class="codeline" id="line-2675"><code>	}</code></span>
<span class="codeline" id="line-2676"><code>	newm1(mp)</code></span>
<span class="codeline" id="line-2677"><code>	releasem(getg().m)</code></span>
<span class="codeline" id="line-2678"><code>}</code></span>
<span class="codeline" id="line-2679"><code></code></span>
<span class="codeline" id="line-2680"><code>func newm1(mp *m) {</code></span>
<span class="codeline" id="line-2681"><code>	if iscgo {</code></span>
<span class="codeline" id="line-2682"><code>		var ts cgothreadstart</code></span>
<span class="codeline" id="line-2683"><code>		if _cgo_thread_start == nil {</code></span>
<span class="codeline" id="line-2684"><code>			throw("_cgo_thread_start missing")</code></span>
<span class="codeline" id="line-2685"><code>		}</code></span>
<span class="codeline" id="line-2686"><code>		ts.g.set(mp.g0)</code></span>
<span class="codeline" id="line-2687"><code>		ts.tls = (*uint64)(unsafe.Pointer(&amp;mp.tls[0]))</code></span>
<span class="codeline" id="line-2688"><code>		ts.fn = unsafe.Pointer(abi.FuncPCABI0(mstart))</code></span>
<span class="codeline" id="line-2689"><code>		if msanenabled {</code></span>
<span class="codeline" id="line-2690"><code>			msanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</code></span>
<span class="codeline" id="line-2691"><code>		}</code></span>
<span class="codeline" id="line-2692"><code>		if asanenabled {</code></span>
<span class="codeline" id="line-2693"><code>			asanwrite(unsafe.Pointer(&amp;ts), unsafe.Sizeof(ts))</code></span>
<span class="codeline" id="line-2694"><code>		}</code></span>
<span class="codeline" id="line-2695"><code>		execLock.rlock() // Prevent process clone.</code></span>
<span class="codeline" id="line-2696"><code>		asmcgocall(_cgo_thread_start, unsafe.Pointer(&amp;ts))</code></span>
<span class="codeline" id="line-2697"><code>		execLock.runlock()</code></span>
<span class="codeline" id="line-2698"><code>		return</code></span>
<span class="codeline" id="line-2699"><code>	}</code></span>
<span class="codeline" id="line-2700"><code>	execLock.rlock() // Prevent process clone.</code></span>
<span class="codeline" id="line-2701"><code>	newosproc(mp)</code></span>
<span class="codeline" id="line-2702"><code>	execLock.runlock()</code></span>
<span class="codeline" id="line-2703"><code>}</code></span>
<span class="codeline" id="line-2704"><code></code></span>
<span class="codeline" id="line-2705"><code>// startTemplateThread starts the template thread if it is not already</code></span>
<span class="codeline" id="line-2706"><code>// running.</code></span>
<span class="codeline" id="line-2707"><code>//</code></span>
<span class="codeline" id="line-2708"><code>// The calling thread must itself be in a known-good state.</code></span>
<span class="codeline" id="line-2709"><code>func startTemplateThread() {</code></span>
<span class="codeline" id="line-2710"><code>	if GOARCH == "wasm" { // no threads on wasm yet</code></span>
<span class="codeline" id="line-2711"><code>		return</code></span>
<span class="codeline" id="line-2712"><code>	}</code></span>
<span class="codeline" id="line-2713"><code></code></span>
<span class="codeline" id="line-2714"><code>	// Disable preemption to guarantee that the template thread will be</code></span>
<span class="codeline" id="line-2715"><code>	// created before a park once haveTemplateThread is set.</code></span>
<span class="codeline" id="line-2716"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-2717"><code>	if !atomic.Cas(&amp;newmHandoff.haveTemplateThread, 0, 1) {</code></span>
<span class="codeline" id="line-2718"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-2719"><code>		return</code></span>
<span class="codeline" id="line-2720"><code>	}</code></span>
<span class="codeline" id="line-2721"><code>	newm(templateThread, nil, -1)</code></span>
<span class="codeline" id="line-2722"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-2723"><code>}</code></span>
<span class="codeline" id="line-2724"><code></code></span>
<span class="codeline" id="line-2725"><code>// templateThread is a thread in a known-good state that exists solely</code></span>
<span class="codeline" id="line-2726"><code>// to start new threads in known-good states when the calling thread</code></span>
<span class="codeline" id="line-2727"><code>// may not be in a good state.</code></span>
<span class="codeline" id="line-2728"><code>//</code></span>
<span class="codeline" id="line-2729"><code>// Many programs never need this, so templateThread is started lazily</code></span>
<span class="codeline" id="line-2730"><code>// when we first enter a state that might lead to running on a thread</code></span>
<span class="codeline" id="line-2731"><code>// in an unknown state.</code></span>
<span class="codeline" id="line-2732"><code>//</code></span>
<span class="codeline" id="line-2733"><code>// templateThread runs on an M without a P, so it must not have write</code></span>
<span class="codeline" id="line-2734"><code>// barriers.</code></span>
<span class="codeline" id="line-2735"><code>//</code></span>
<span class="codeline" id="line-2736"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2737"><code>func templateThread() {</code></span>
<span class="codeline" id="line-2738"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2739"><code>	sched.nmsys++</code></span>
<span class="codeline" id="line-2740"><code>	checkdead()</code></span>
<span class="codeline" id="line-2741"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2742"><code></code></span>
<span class="codeline" id="line-2743"><code>	for {</code></span>
<span class="codeline" id="line-2744"><code>		lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2745"><code>		for newmHandoff.newm != 0 {</code></span>
<span class="codeline" id="line-2746"><code>			newm := newmHandoff.newm.ptr()</code></span>
<span class="codeline" id="line-2747"><code>			newmHandoff.newm = 0</code></span>
<span class="codeline" id="line-2748"><code>			unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2749"><code>			for newm != nil {</code></span>
<span class="codeline" id="line-2750"><code>				next := newm.schedlink.ptr()</code></span>
<span class="codeline" id="line-2751"><code>				newm.schedlink = 0</code></span>
<span class="codeline" id="line-2752"><code>				newm1(newm)</code></span>
<span class="codeline" id="line-2753"><code>				newm = next</code></span>
<span class="codeline" id="line-2754"><code>			}</code></span>
<span class="codeline" id="line-2755"><code>			lock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2756"><code>		}</code></span>
<span class="codeline" id="line-2757"><code>		newmHandoff.waiting = true</code></span>
<span class="codeline" id="line-2758"><code>		noteclear(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-2759"><code>		unlock(&amp;newmHandoff.lock)</code></span>
<span class="codeline" id="line-2760"><code>		notesleep(&amp;newmHandoff.wake)</code></span>
<span class="codeline" id="line-2761"><code>	}</code></span>
<span class="codeline" id="line-2762"><code>}</code></span>
<span class="codeline" id="line-2763"><code></code></span>
<span class="codeline" id="line-2764"><code>// Stops execution of the current m until new work is available.</code></span>
<span class="codeline" id="line-2765"><code>// Returns with acquired P.</code></span>
<span class="codeline" id="line-2766"><code>func stopm() {</code></span>
<span class="codeline" id="line-2767"><code>	gp := getg()</code></span>
<span class="codeline" id="line-2768"><code></code></span>
<span class="codeline" id="line-2769"><code>	if gp.m.locks != 0 {</code></span>
<span class="codeline" id="line-2770"><code>		throw("stopm holding locks")</code></span>
<span class="codeline" id="line-2771"><code>	}</code></span>
<span class="codeline" id="line-2772"><code>	if gp.m.p != 0 {</code></span>
<span class="codeline" id="line-2773"><code>		throw("stopm holding p")</code></span>
<span class="codeline" id="line-2774"><code>	}</code></span>
<span class="codeline" id="line-2775"><code>	if gp.m.spinning {</code></span>
<span class="codeline" id="line-2776"><code>		throw("stopm spinning")</code></span>
<span class="codeline" id="line-2777"><code>	}</code></span>
<span class="codeline" id="line-2778"><code></code></span>
<span class="codeline" id="line-2779"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2780"><code>	mput(gp.m)</code></span>
<span class="codeline" id="line-2781"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2782"><code>	mPark()</code></span>
<span class="codeline" id="line-2783"><code>	acquirep(gp.m.nextp.ptr())</code></span>
<span class="codeline" id="line-2784"><code>	gp.m.nextp = 0</code></span>
<span class="codeline" id="line-2785"><code>}</code></span>
<span class="codeline" id="line-2786"><code></code></span>
<span class="codeline" id="line-2787"><code>func mspinning() {</code></span>
<span class="codeline" id="line-2788"><code>	// startm's caller incremented nmspinning. Set the new M's spinning.</code></span>
<span class="codeline" id="line-2789"><code>	getg().m.spinning = true</code></span>
<span class="codeline" id="line-2790"><code>}</code></span>
<span class="codeline" id="line-2791"><code></code></span>
<span class="codeline" id="line-2792"><code>// Schedules some M to run the p (creates an M if necessary).</code></span>
<span class="codeline" id="line-2793"><code>// If p==nil, tries to get an idle P, if no idle P's does nothing.</code></span>
<span class="codeline" id="line-2794"><code>// May run with m.p==nil, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-2795"><code>// If spinning is set, the caller has incremented nmspinning and must provide a</code></span>
<span class="codeline" id="line-2796"><code>// P. startm will set m.spinning in the newly started M.</code></span>
<span class="codeline" id="line-2797"><code>//</code></span>
<span class="codeline" id="line-2798"><code>// Callers passing a non-nil P must call from a non-preemptible context. See</code></span>
<span class="codeline" id="line-2799"><code>// comment on acquirem below.</code></span>
<span class="codeline" id="line-2800"><code>//</code></span>
<span class="codeline" id="line-2801"><code>// Argument lockheld indicates whether the caller already acquired the</code></span>
<span class="codeline" id="line-2802"><code>// scheduler lock. Callers holding the lock when making the call must pass</code></span>
<span class="codeline" id="line-2803"><code>// true. The lock might be temporarily dropped, but will be reacquired before</code></span>
<span class="codeline" id="line-2804"><code>// returning.</code></span>
<span class="codeline" id="line-2805"><code>//</code></span>
<span class="codeline" id="line-2806"><code>// Must not have write barriers because this may be called without a P.</code></span>
<span class="codeline" id="line-2807"><code>//</code></span>
<span class="codeline" id="line-2808"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2809"><code>func startm(pp *p, spinning, lockheld bool) {</code></span>
<span class="codeline" id="line-2810"><code>	// Disable preemption.</code></span>
<span class="codeline" id="line-2811"><code>	//</code></span>
<span class="codeline" id="line-2812"><code>	// Every owned P must have an owner that will eventually stop it in the</code></span>
<span class="codeline" id="line-2813"><code>	// event of a GC stop request. startm takes transient ownership of a P</code></span>
<span class="codeline" id="line-2814"><code>	// (either from argument or pidleget below) and transfers ownership to</code></span>
<span class="codeline" id="line-2815"><code>	// a started M, which will be responsible for performing the stop.</code></span>
<span class="codeline" id="line-2816"><code>	//</code></span>
<span class="codeline" id="line-2817"><code>	// Preemption must be disabled during this transient ownership,</code></span>
<span class="codeline" id="line-2818"><code>	// otherwise the P this is running on may enter GC stop while still</code></span>
<span class="codeline" id="line-2819"><code>	// holding the transient P, leaving that P in limbo and deadlocking the</code></span>
<span class="codeline" id="line-2820"><code>	// STW.</code></span>
<span class="codeline" id="line-2821"><code>	//</code></span>
<span class="codeline" id="line-2822"><code>	// Callers passing a non-nil P must already be in non-preemptible</code></span>
<span class="codeline" id="line-2823"><code>	// context, otherwise such preemption could occur on function entry to</code></span>
<span class="codeline" id="line-2824"><code>	// startm. Callers passing a nil P may be preemptible, so we must</code></span>
<span class="codeline" id="line-2825"><code>	// disable preemption before acquiring a P from pidleget below.</code></span>
<span class="codeline" id="line-2826"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-2827"><code>	if !lockheld {</code></span>
<span class="codeline" id="line-2828"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2829"><code>	}</code></span>
<span class="codeline" id="line-2830"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-2831"><code>		if spinning {</code></span>
<span class="codeline" id="line-2832"><code>			// TODO(prattmic): All remaining calls to this function</code></span>
<span class="codeline" id="line-2833"><code>			// with _p_ == nil could be cleaned up to find a P</code></span>
<span class="codeline" id="line-2834"><code>			// before calling startm.</code></span>
<span class="codeline" id="line-2835"><code>			throw("startm: P required for spinning=true")</code></span>
<span class="codeline" id="line-2836"><code>		}</code></span>
<span class="codeline" id="line-2837"><code>		pp, _ = pidleget(0)</code></span>
<span class="codeline" id="line-2838"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-2839"><code>			if !lockheld {</code></span>
<span class="codeline" id="line-2840"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2841"><code>			}</code></span>
<span class="codeline" id="line-2842"><code>			releasem(mp)</code></span>
<span class="codeline" id="line-2843"><code>			return</code></span>
<span class="codeline" id="line-2844"><code>		}</code></span>
<span class="codeline" id="line-2845"><code>	}</code></span>
<span class="codeline" id="line-2846"><code>	nmp := mget()</code></span>
<span class="codeline" id="line-2847"><code>	if nmp == nil {</code></span>
<span class="codeline" id="line-2848"><code>		// No M is available, we must drop sched.lock and call newm.</code></span>
<span class="codeline" id="line-2849"><code>		// However, we already own a P to assign to the M.</code></span>
<span class="codeline" id="line-2850"><code>		//</code></span>
<span class="codeline" id="line-2851"><code>		// Once sched.lock is released, another G (e.g., in a syscall),</code></span>
<span class="codeline" id="line-2852"><code>		// could find no idle P while checkdead finds a runnable G but</code></span>
<span class="codeline" id="line-2853"><code>		// no running M's because this new M hasn't started yet, thus</code></span>
<span class="codeline" id="line-2854"><code>		// throwing in an apparent deadlock.</code></span>
<span class="codeline" id="line-2855"><code>		// This apparent deadlock is possible when startm is called</code></span>
<span class="codeline" id="line-2856"><code>		// from sysmon, which doesn't count as a running M.</code></span>
<span class="codeline" id="line-2857"><code>		//</code></span>
<span class="codeline" id="line-2858"><code>		// Avoid this situation by pre-allocating the ID for the new M,</code></span>
<span class="codeline" id="line-2859"><code>		// thus marking it as 'running' before we drop sched.lock. This</code></span>
<span class="codeline" id="line-2860"><code>		// new M will eventually run the scheduler to execute any</code></span>
<span class="codeline" id="line-2861"><code>		// queued G's.</code></span>
<span class="codeline" id="line-2862"><code>		id := mReserveID()</code></span>
<span class="codeline" id="line-2863"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2864"><code></code></span>
<span class="codeline" id="line-2865"><code>		var fn func()</code></span>
<span class="codeline" id="line-2866"><code>		if spinning {</code></span>
<span class="codeline" id="line-2867"><code>			// The caller incremented nmspinning, so set m.spinning in the new M.</code></span>
<span class="codeline" id="line-2868"><code>			fn = mspinning</code></span>
<span class="codeline" id="line-2869"><code>		}</code></span>
<span class="codeline" id="line-2870"><code>		newm(fn, pp, id)</code></span>
<span class="codeline" id="line-2871"><code></code></span>
<span class="codeline" id="line-2872"><code>		if lockheld {</code></span>
<span class="codeline" id="line-2873"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2874"><code>		}</code></span>
<span class="codeline" id="line-2875"><code>		// Ownership transfer of pp committed by start in newm.</code></span>
<span class="codeline" id="line-2876"><code>		// Preemption is now safe.</code></span>
<span class="codeline" id="line-2877"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-2878"><code>		return</code></span>
<span class="codeline" id="line-2879"><code>	}</code></span>
<span class="codeline" id="line-2880"><code>	if !lockheld {</code></span>
<span class="codeline" id="line-2881"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2882"><code>	}</code></span>
<span class="codeline" id="line-2883"><code>	if nmp.spinning {</code></span>
<span class="codeline" id="line-2884"><code>		throw("startm: m is spinning")</code></span>
<span class="codeline" id="line-2885"><code>	}</code></span>
<span class="codeline" id="line-2886"><code>	if nmp.nextp != 0 {</code></span>
<span class="codeline" id="line-2887"><code>		throw("startm: m has p")</code></span>
<span class="codeline" id="line-2888"><code>	}</code></span>
<span class="codeline" id="line-2889"><code>	if spinning &amp;&amp; !runqempty(pp) {</code></span>
<span class="codeline" id="line-2890"><code>		throw("startm: p has runnable gs")</code></span>
<span class="codeline" id="line-2891"><code>	}</code></span>
<span class="codeline" id="line-2892"><code>	// The caller incremented nmspinning, so set m.spinning in the new M.</code></span>
<span class="codeline" id="line-2893"><code>	nmp.spinning = spinning</code></span>
<span class="codeline" id="line-2894"><code>	nmp.nextp.set(pp)</code></span>
<span class="codeline" id="line-2895"><code>	notewakeup(&amp;nmp.park)</code></span>
<span class="codeline" id="line-2896"><code>	// Ownership transfer of pp committed by wakeup. Preemption is now</code></span>
<span class="codeline" id="line-2897"><code>	// safe.</code></span>
<span class="codeline" id="line-2898"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-2899"><code>}</code></span>
<span class="codeline" id="line-2900"><code></code></span>
<span class="codeline" id="line-2901"><code>// Hands off P from syscall or locked M.</code></span>
<span class="codeline" id="line-2902"><code>// Always runs without a P, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-2903"><code>//</code></span>
<span class="codeline" id="line-2904"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-2905"><code>func handoffp(pp *p) {</code></span>
<span class="codeline" id="line-2906"><code>	// handoffp must start an M in any situation where</code></span>
<span class="codeline" id="line-2907"><code>	// findrunnable would return a G to run on pp.</code></span>
<span class="codeline" id="line-2908"><code></code></span>
<span class="codeline" id="line-2909"><code>	// if it has local work, start it straight away</code></span>
<span class="codeline" id="line-2910"><code>	if !runqempty(pp) || sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2911"><code>		startm(pp, false, false)</code></span>
<span class="codeline" id="line-2912"><code>		return</code></span>
<span class="codeline" id="line-2913"><code>	}</code></span>
<span class="codeline" id="line-2914"><code>	// if there's trace work to do, start it straight away</code></span>
<span class="codeline" id="line-2915"><code>	if (traceEnabled() || traceShuttingDown()) &amp;&amp; traceReaderAvailable() != nil {</code></span>
<span class="codeline" id="line-2916"><code>		startm(pp, false, false)</code></span>
<span class="codeline" id="line-2917"><code>		return</code></span>
<span class="codeline" id="line-2918"><code>	}</code></span>
<span class="codeline" id="line-2919"><code>	// if it has GC work, start it straight away</code></span>
<span class="codeline" id="line-2920"><code>	if gcBlackenEnabled != 0 &amp;&amp; gcMarkWorkAvailable(pp) {</code></span>
<span class="codeline" id="line-2921"><code>		startm(pp, false, false)</code></span>
<span class="codeline" id="line-2922"><code>		return</code></span>
<span class="codeline" id="line-2923"><code>	}</code></span>
<span class="codeline" id="line-2924"><code>	// no local work, check that there are no spinning/idle M's,</code></span>
<span class="codeline" id="line-2925"><code>	// otherwise our help is not required</code></span>
<span class="codeline" id="line-2926"><code>	if sched.nmspinning.Load()+sched.npidle.Load() == 0 &amp;&amp; sched.nmspinning.CompareAndSwap(0, 1) { // TODO: fast atomic</code></span>
<span class="codeline" id="line-2927"><code>		sched.needspinning.Store(0)</code></span>
<span class="codeline" id="line-2928"><code>		startm(pp, true, false)</code></span>
<span class="codeline" id="line-2929"><code>		return</code></span>
<span class="codeline" id="line-2930"><code>	}</code></span>
<span class="codeline" id="line-2931"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2932"><code>	if sched.gcwaiting.Load() {</code></span>
<span class="codeline" id="line-2933"><code>		pp.status = _Pgcstop</code></span>
<span class="codeline" id="line-2934"><code>		sched.stopwait--</code></span>
<span class="codeline" id="line-2935"><code>		if sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-2936"><code>			notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-2937"><code>		}</code></span>
<span class="codeline" id="line-2938"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2939"><code>		return</code></span>
<span class="codeline" id="line-2940"><code>	}</code></span>
<span class="codeline" id="line-2941"><code>	if pp.runSafePointFn != 0 &amp;&amp; atomic.Cas(&amp;pp.runSafePointFn, 1, 0) {</code></span>
<span class="codeline" id="line-2942"><code>		sched.safePointFn(pp)</code></span>
<span class="codeline" id="line-2943"><code>		sched.safePointWait--</code></span>
<span class="codeline" id="line-2944"><code>		if sched.safePointWait == 0 {</code></span>
<span class="codeline" id="line-2945"><code>			notewakeup(&amp;sched.safePointNote)</code></span>
<span class="codeline" id="line-2946"><code>		}</code></span>
<span class="codeline" id="line-2947"><code>	}</code></span>
<span class="codeline" id="line-2948"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-2949"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2950"><code>		startm(pp, false, false)</code></span>
<span class="codeline" id="line-2951"><code>		return</code></span>
<span class="codeline" id="line-2952"><code>	}</code></span>
<span class="codeline" id="line-2953"><code>	// If this is the last running P and nobody is polling network,</code></span>
<span class="codeline" id="line-2954"><code>	// need to wakeup another M to poll network.</code></span>
<span class="codeline" id="line-2955"><code>	if sched.npidle.Load() == gomaxprocs-1 &amp;&amp; sched.lastpoll.Load() != 0 {</code></span>
<span class="codeline" id="line-2956"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2957"><code>		startm(pp, false, false)</code></span>
<span class="codeline" id="line-2958"><code>		return</code></span>
<span class="codeline" id="line-2959"><code>	}</code></span>
<span class="codeline" id="line-2960"><code></code></span>
<span class="codeline" id="line-2961"><code>	// The scheduler lock cannot be held when calling wakeNetPoller below</code></span>
<span class="codeline" id="line-2962"><code>	// because wakeNetPoller may call wakep which may call startm.</code></span>
<span class="codeline" id="line-2963"><code>	when := nobarrierWakeTime(pp)</code></span>
<span class="codeline" id="line-2964"><code>	pidleput(pp, 0)</code></span>
<span class="codeline" id="line-2965"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2966"><code></code></span>
<span class="codeline" id="line-2967"><code>	if when != 0 {</code></span>
<span class="codeline" id="line-2968"><code>		wakeNetPoller(when)</code></span>
<span class="codeline" id="line-2969"><code>	}</code></span>
<span class="codeline" id="line-2970"><code>}</code></span>
<span class="codeline" id="line-2971"><code></code></span>
<span class="codeline" id="line-2972"><code>// Tries to add one more P to execute G's.</code></span>
<span class="codeline" id="line-2973"><code>// Called when a G is made runnable (newproc, ready).</code></span>
<span class="codeline" id="line-2974"><code>// Must be called with a P.</code></span>
<span class="codeline" id="line-2975"><code>func wakep() {</code></span>
<span class="codeline" id="line-2976"><code>	// Be conservative about spinning threads, only start one if none exist</code></span>
<span class="codeline" id="line-2977"><code>	// already.</code></span>
<span class="codeline" id="line-2978"><code>	if sched.nmspinning.Load() != 0 || !sched.nmspinning.CompareAndSwap(0, 1) {</code></span>
<span class="codeline" id="line-2979"><code>		return</code></span>
<span class="codeline" id="line-2980"><code>	}</code></span>
<span class="codeline" id="line-2981"><code></code></span>
<span class="codeline" id="line-2982"><code>	// Disable preemption until ownership of pp transfers to the next M in</code></span>
<span class="codeline" id="line-2983"><code>	// startm. Otherwise preemption here would leave pp stuck waiting to</code></span>
<span class="codeline" id="line-2984"><code>	// enter _Pgcstop.</code></span>
<span class="codeline" id="line-2985"><code>	//</code></span>
<span class="codeline" id="line-2986"><code>	// See preemption comment on acquirem in startm for more details.</code></span>
<span class="codeline" id="line-2987"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-2988"><code></code></span>
<span class="codeline" id="line-2989"><code>	var pp *p</code></span>
<span class="codeline" id="line-2990"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2991"><code>	pp, _ = pidlegetSpinning(0)</code></span>
<span class="codeline" id="line-2992"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-2993"><code>		if sched.nmspinning.Add(-1) &lt; 0 {</code></span>
<span class="codeline" id="line-2994"><code>			throw("wakep: negative nmspinning")</code></span>
<span class="codeline" id="line-2995"><code>		}</code></span>
<span class="codeline" id="line-2996"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-2997"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-2998"><code>		return</code></span>
<span class="codeline" id="line-2999"><code>	}</code></span>
<span class="codeline" id="line-3000"><code>	// Since we always have a P, the race in the "No M is available"</code></span>
<span class="codeline" id="line-3001"><code>	// comment in startm doesn't apply during the small window between the</code></span>
<span class="codeline" id="line-3002"><code>	// unlock here and lock in startm. A checkdead in between will always</code></span>
<span class="codeline" id="line-3003"><code>	// see at least one running M (ours).</code></span>
<span class="codeline" id="line-3004"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3005"><code></code></span>
<span class="codeline" id="line-3006"><code>	startm(pp, true, false)</code></span>
<span class="codeline" id="line-3007"><code></code></span>
<span class="codeline" id="line-3008"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-3009"><code>}</code></span>
<span class="codeline" id="line-3010"><code></code></span>
<span class="codeline" id="line-3011"><code>// Stops execution of the current m that is locked to a g until the g is runnable again.</code></span>
<span class="codeline" id="line-3012"><code>// Returns with acquired P.</code></span>
<span class="codeline" id="line-3013"><code>func stoplockedm() {</code></span>
<span class="codeline" id="line-3014"><code>	gp := getg()</code></span>
<span class="codeline" id="line-3015"><code></code></span>
<span class="codeline" id="line-3016"><code>	if gp.m.lockedg == 0 || gp.m.lockedg.ptr().lockedm.ptr() != gp.m {</code></span>
<span class="codeline" id="line-3017"><code>		throw("stoplockedm: inconsistent locking")</code></span>
<span class="codeline" id="line-3018"><code>	}</code></span>
<span class="codeline" id="line-3019"><code>	if gp.m.p != 0 {</code></span>
<span class="codeline" id="line-3020"><code>		// Schedule another M to run this p.</code></span>
<span class="codeline" id="line-3021"><code>		pp := releasep()</code></span>
<span class="codeline" id="line-3022"><code>		handoffp(pp)</code></span>
<span class="codeline" id="line-3023"><code>	}</code></span>
<span class="codeline" id="line-3024"><code>	incidlelocked(1)</code></span>
<span class="codeline" id="line-3025"><code>	// Wait until another thread schedules lockedg again.</code></span>
<span class="codeline" id="line-3026"><code>	mPark()</code></span>
<span class="codeline" id="line-3027"><code>	status := readgstatus(gp.m.lockedg.ptr())</code></span>
<span class="codeline" id="line-3028"><code>	if status&amp;^_Gscan != _Grunnable {</code></span>
<span class="codeline" id="line-3029"><code>		print("runtime:stoplockedm: lockedg (atomicstatus=", status, ") is not Grunnable or Gscanrunnable\n")</code></span>
<span class="codeline" id="line-3030"><code>		dumpgstatus(gp.m.lockedg.ptr())</code></span>
<span class="codeline" id="line-3031"><code>		throw("stoplockedm: not runnable")</code></span>
<span class="codeline" id="line-3032"><code>	}</code></span>
<span class="codeline" id="line-3033"><code>	acquirep(gp.m.nextp.ptr())</code></span>
<span class="codeline" id="line-3034"><code>	gp.m.nextp = 0</code></span>
<span class="codeline" id="line-3035"><code>}</code></span>
<span class="codeline" id="line-3036"><code></code></span>
<span class="codeline" id="line-3037"><code>// Schedules the locked m to run the locked gp.</code></span>
<span class="codeline" id="line-3038"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-3039"><code>//</code></span>
<span class="codeline" id="line-3040"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-3041"><code>func startlockedm(gp *g) {</code></span>
<span class="codeline" id="line-3042"><code>	mp := gp.lockedm.ptr()</code></span>
<span class="codeline" id="line-3043"><code>	if mp == getg().m {</code></span>
<span class="codeline" id="line-3044"><code>		throw("startlockedm: locked to me")</code></span>
<span class="codeline" id="line-3045"><code>	}</code></span>
<span class="codeline" id="line-3046"><code>	if mp.nextp != 0 {</code></span>
<span class="codeline" id="line-3047"><code>		throw("startlockedm: m has p")</code></span>
<span class="codeline" id="line-3048"><code>	}</code></span>
<span class="codeline" id="line-3049"><code>	// directly handoff current P to the locked m</code></span>
<span class="codeline" id="line-3050"><code>	incidlelocked(-1)</code></span>
<span class="codeline" id="line-3051"><code>	pp := releasep()</code></span>
<span class="codeline" id="line-3052"><code>	mp.nextp.set(pp)</code></span>
<span class="codeline" id="line-3053"><code>	notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-3054"><code>	stopm()</code></span>
<span class="codeline" id="line-3055"><code>}</code></span>
<span class="codeline" id="line-3056"><code></code></span>
<span class="codeline" id="line-3057"><code>// Stops the current m for stopTheWorld.</code></span>
<span class="codeline" id="line-3058"><code>// Returns when the world is restarted.</code></span>
<span class="codeline" id="line-3059"><code>func gcstopm() {</code></span>
<span class="codeline" id="line-3060"><code>	gp := getg()</code></span>
<span class="codeline" id="line-3061"><code></code></span>
<span class="codeline" id="line-3062"><code>	if !sched.gcwaiting.Load() {</code></span>
<span class="codeline" id="line-3063"><code>		throw("gcstopm: not waiting for gc")</code></span>
<span class="codeline" id="line-3064"><code>	}</code></span>
<span class="codeline" id="line-3065"><code>	if gp.m.spinning {</code></span>
<span class="codeline" id="line-3066"><code>		gp.m.spinning = false</code></span>
<span class="codeline" id="line-3067"><code>		// OK to just drop nmspinning here,</code></span>
<span class="codeline" id="line-3068"><code>		// startTheWorld will unpark threads as necessary.</code></span>
<span class="codeline" id="line-3069"><code>		if sched.nmspinning.Add(-1) &lt; 0 {</code></span>
<span class="codeline" id="line-3070"><code>			throw("gcstopm: negative nmspinning")</code></span>
<span class="codeline" id="line-3071"><code>		}</code></span>
<span class="codeline" id="line-3072"><code>	}</code></span>
<span class="codeline" id="line-3073"><code>	pp := releasep()</code></span>
<span class="codeline" id="line-3074"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3075"><code>	pp.status = _Pgcstop</code></span>
<span class="codeline" id="line-3076"><code>	sched.stopwait--</code></span>
<span class="codeline" id="line-3077"><code>	if sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-3078"><code>		notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-3079"><code>	}</code></span>
<span class="codeline" id="line-3080"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3081"><code>	stopm()</code></span>
<span class="codeline" id="line-3082"><code>}</code></span>
<span class="codeline" id="line-3083"><code></code></span>
<span class="codeline" id="line-3084"><code>// Schedules gp to run on the current M.</code></span>
<span class="codeline" id="line-3085"><code>// If inheritTime is true, gp inherits the remaining time in the</code></span>
<span class="codeline" id="line-3086"><code>// current time slice. Otherwise, it starts a new time slice.</code></span>
<span class="codeline" id="line-3087"><code>// Never returns.</code></span>
<span class="codeline" id="line-3088"><code>//</code></span>
<span class="codeline" id="line-3089"><code>// Write barriers are allowed because this is called immediately after</code></span>
<span class="codeline" id="line-3090"><code>// acquiring a P in several places.</code></span>
<span class="codeline" id="line-3091"><code>//</code></span>
<span class="codeline" id="line-3092"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-3093"><code>func execute(gp *g, inheritTime bool) {</code></span>
<span class="codeline" id="line-3094"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-3095"><code></code></span>
<span class="codeline" id="line-3096"><code>	if goroutineProfile.active {</code></span>
<span class="codeline" id="line-3097"><code>		// Make sure that gp has had its stack written out to the goroutine</code></span>
<span class="codeline" id="line-3098"><code>		// profile, exactly as it was when the goroutine profiler first stopped</code></span>
<span class="codeline" id="line-3099"><code>		// the world.</code></span>
<span class="codeline" id="line-3100"><code>		tryRecordGoroutineProfile(gp, osyield)</code></span>
<span class="codeline" id="line-3101"><code>	}</code></span>
<span class="codeline" id="line-3102"><code></code></span>
<span class="codeline" id="line-3103"><code>	// Assign gp.m before entering _Grunning so running Gs have an</code></span>
<span class="codeline" id="line-3104"><code>	// M.</code></span>
<span class="codeline" id="line-3105"><code>	mp.curg = gp</code></span>
<span class="codeline" id="line-3106"><code>	gp.m = mp</code></span>
<span class="codeline" id="line-3107"><code>	casgstatus(gp, _Grunnable, _Grunning)</code></span>
<span class="codeline" id="line-3108"><code>	gp.waitsince = 0</code></span>
<span class="codeline" id="line-3109"><code>	gp.preempt = false</code></span>
<span class="codeline" id="line-3110"><code>	gp.stackguard0 = gp.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-3111"><code>	if !inheritTime {</code></span>
<span class="codeline" id="line-3112"><code>		mp.p.ptr().schedtick++</code></span>
<span class="codeline" id="line-3113"><code>	}</code></span>
<span class="codeline" id="line-3114"><code></code></span>
<span class="codeline" id="line-3115"><code>	// Check whether the profiler needs to be turned on or off.</code></span>
<span class="codeline" id="line-3116"><code>	hz := sched.profilehz</code></span>
<span class="codeline" id="line-3117"><code>	if mp.profilehz != hz {</code></span>
<span class="codeline" id="line-3118"><code>		setThreadCPUProfiler(hz)</code></span>
<span class="codeline" id="line-3119"><code>	}</code></span>
<span class="codeline" id="line-3120"><code></code></span>
<span class="codeline" id="line-3121"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-3122"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-3123"><code>		// GoSysExit has to happen when we have a P, but before GoStart.</code></span>
<span class="codeline" id="line-3124"><code>		// So we emit it here.</code></span>
<span class="codeline" id="line-3125"><code>		if !goexperiment.ExecTracer2 &amp;&amp; gp.syscallsp != 0 {</code></span>
<span class="codeline" id="line-3126"><code>			trace.GoSysExit(true)</code></span>
<span class="codeline" id="line-3127"><code>		}</code></span>
<span class="codeline" id="line-3128"><code>		trace.GoStart()</code></span>
<span class="codeline" id="line-3129"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-3130"><code>	}</code></span>
<span class="codeline" id="line-3131"><code></code></span>
<span class="codeline" id="line-3132"><code>	gogo(&amp;gp.sched)</code></span>
<span class="codeline" id="line-3133"><code>}</code></span>
<span class="codeline" id="line-3134"><code></code></span>
<span class="codeline" id="line-3135"><code>// Finds a runnable goroutine to execute.</code></span>
<span class="codeline" id="line-3136"><code>// Tries to steal from other P's, get g from local or global queue, poll network.</code></span>
<span class="codeline" id="line-3137"><code>// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace</code></span>
<span class="codeline" id="line-3138"><code>// reader) so the caller should try to wake a P.</code></span>
<span class="codeline" id="line-3139"><code>func findRunnable() (gp *g, inheritTime, tryWakeP bool) {</code></span>
<span class="codeline" id="line-3140"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-3141"><code></code></span>
<span class="codeline" id="line-3142"><code>	// The conditions here and in handoffp must agree: if</code></span>
<span class="codeline" id="line-3143"><code>	// findrunnable would return a G to run, handoffp must start</code></span>
<span class="codeline" id="line-3144"><code>	// an M.</code></span>
<span class="codeline" id="line-3145"><code></code></span>
<span class="codeline" id="line-3146"><code>top:</code></span>
<span class="codeline" id="line-3147"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-3148"><code>	if sched.gcwaiting.Load() {</code></span>
<span class="codeline" id="line-3149"><code>		gcstopm()</code></span>
<span class="codeline" id="line-3150"><code>		goto top</code></span>
<span class="codeline" id="line-3151"><code>	}</code></span>
<span class="codeline" id="line-3152"><code>	if pp.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-3153"><code>		runSafePointFn()</code></span>
<span class="codeline" id="line-3154"><code>	}</code></span>
<span class="codeline" id="line-3155"><code></code></span>
<span class="codeline" id="line-3156"><code>	// now and pollUntil are saved for work stealing later,</code></span>
<span class="codeline" id="line-3157"><code>	// which may steal timers. It's important that between now</code></span>
<span class="codeline" id="line-3158"><code>	// and then, nothing blocks, so these numbers remain mostly</code></span>
<span class="codeline" id="line-3159"><code>	// relevant.</code></span>
<span class="codeline" id="line-3160"><code>	now, pollUntil, _ := checkTimers(pp, 0)</code></span>
<span class="codeline" id="line-3161"><code></code></span>
<span class="codeline" id="line-3162"><code>	// Try to schedule the trace reader.</code></span>
<span class="codeline" id="line-3163"><code>	if traceEnabled() || traceShuttingDown() {</code></span>
<span class="codeline" id="line-3164"><code>		gp := traceReader()</code></span>
<span class="codeline" id="line-3165"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-3166"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-3167"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3168"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-3169"><code>				trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3170"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-3171"><code>			}</code></span>
<span class="codeline" id="line-3172"><code>			return gp, false, true</code></span>
<span class="codeline" id="line-3173"><code>		}</code></span>
<span class="codeline" id="line-3174"><code>	}</code></span>
<span class="codeline" id="line-3175"><code></code></span>
<span class="codeline" id="line-3176"><code>	// Try to schedule a GC worker.</code></span>
<span class="codeline" id="line-3177"><code>	if gcBlackenEnabled != 0 {</code></span>
<span class="codeline" id="line-3178"><code>		gp, tnow := gcController.findRunnableGCWorker(pp, now)</code></span>
<span class="codeline" id="line-3179"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-3180"><code>			return gp, false, true</code></span>
<span class="codeline" id="line-3181"><code>		}</code></span>
<span class="codeline" id="line-3182"><code>		now = tnow</code></span>
<span class="codeline" id="line-3183"><code>	}</code></span>
<span class="codeline" id="line-3184"><code></code></span>
<span class="codeline" id="line-3185"><code>	// Check the global runnable queue once in a while to ensure fairness.</code></span>
<span class="codeline" id="line-3186"><code>	// Otherwise two goroutines can completely occupy the local runqueue</code></span>
<span class="codeline" id="line-3187"><code>	// by constantly respawning each other.</code></span>
<span class="codeline" id="line-3188"><code>	if pp.schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {</code></span>
<span class="codeline" id="line-3189"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3190"><code>		gp := globrunqget(pp, 1)</code></span>
<span class="codeline" id="line-3191"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3192"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-3193"><code>			return gp, false, false</code></span>
<span class="codeline" id="line-3194"><code>		}</code></span>
<span class="codeline" id="line-3195"><code>	}</code></span>
<span class="codeline" id="line-3196"><code></code></span>
<span class="codeline" id="line-3197"><code>	// Wake up the finalizer G.</code></span>
<span class="codeline" id="line-3198"><code>	if fingStatus.Load()&amp;(fingWait|fingWake) == fingWait|fingWake {</code></span>
<span class="codeline" id="line-3199"><code>		if gp := wakefing(); gp != nil {</code></span>
<span class="codeline" id="line-3200"><code>			ready(gp, 0, true)</code></span>
<span class="codeline" id="line-3201"><code>		}</code></span>
<span class="codeline" id="line-3202"><code>	}</code></span>
<span class="codeline" id="line-3203"><code>	if *cgo_yield != nil {</code></span>
<span class="codeline" id="line-3204"><code>		asmcgocall(*cgo_yield, nil)</code></span>
<span class="codeline" id="line-3205"><code>	}</code></span>
<span class="codeline" id="line-3206"><code></code></span>
<span class="codeline" id="line-3207"><code>	// local runq</code></span>
<span class="codeline" id="line-3208"><code>	if gp, inheritTime := runqget(pp); gp != nil {</code></span>
<span class="codeline" id="line-3209"><code>		return gp, inheritTime, false</code></span>
<span class="codeline" id="line-3210"><code>	}</code></span>
<span class="codeline" id="line-3211"><code></code></span>
<span class="codeline" id="line-3212"><code>	// global runq</code></span>
<span class="codeline" id="line-3213"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-3214"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3215"><code>		gp := globrunqget(pp, 0)</code></span>
<span class="codeline" id="line-3216"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3217"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-3218"><code>			return gp, false, false</code></span>
<span class="codeline" id="line-3219"><code>		}</code></span>
<span class="codeline" id="line-3220"><code>	}</code></span>
<span class="codeline" id="line-3221"><code></code></span>
<span class="codeline" id="line-3222"><code>	// Poll network.</code></span>
<span class="codeline" id="line-3223"><code>	// This netpoll is only an optimization before we resort to stealing.</code></span>
<span class="codeline" id="line-3224"><code>	// We can safely skip it if there are no waiters or a thread is blocked</code></span>
<span class="codeline" id="line-3225"><code>	// in netpoll already. If there is any kind of logical race with that</code></span>
<span class="codeline" id="line-3226"><code>	// blocked thread (e.g. it has already returned from netpoll, but does</code></span>
<span class="codeline" id="line-3227"><code>	// not set lastpoll yet), this thread will do blocking netpoll below</code></span>
<span class="codeline" id="line-3228"><code>	// anyway.</code></span>
<span class="codeline" id="line-3229"><code>	if netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != 0 {</code></span>
<span class="codeline" id="line-3230"><code>		if list, delta := netpoll(0); !list.empty() { // non-blocking</code></span>
<span class="codeline" id="line-3231"><code>			gp := list.pop()</code></span>
<span class="codeline" id="line-3232"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-3233"><code>			netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-3234"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-3235"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3236"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-3237"><code>				trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3238"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-3239"><code>			}</code></span>
<span class="codeline" id="line-3240"><code>			return gp, false, false</code></span>
<span class="codeline" id="line-3241"><code>		}</code></span>
<span class="codeline" id="line-3242"><code>	}</code></span>
<span class="codeline" id="line-3243"><code></code></span>
<span class="codeline" id="line-3244"><code>	// Spinning Ms: steal work from other Ps.</code></span>
<span class="codeline" id="line-3245"><code>	//</code></span>
<span class="codeline" id="line-3246"><code>	// Limit the number of spinning Ms to half the number of busy Ps.</code></span>
<span class="codeline" id="line-3247"><code>	// This is necessary to prevent excessive CPU consumption when</code></span>
<span class="codeline" id="line-3248"><code>	// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</code></span>
<span class="codeline" id="line-3249"><code>	if mp.spinning || 2*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() {</code></span>
<span class="codeline" id="line-3250"><code>		if !mp.spinning {</code></span>
<span class="codeline" id="line-3251"><code>			mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3252"><code>		}</code></span>
<span class="codeline" id="line-3253"><code></code></span>
<span class="codeline" id="line-3254"><code>		gp, inheritTime, tnow, w, newWork := stealWork(now)</code></span>
<span class="codeline" id="line-3255"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-3256"><code>			// Successfully stole.</code></span>
<span class="codeline" id="line-3257"><code>			return gp, inheritTime, false</code></span>
<span class="codeline" id="line-3258"><code>		}</code></span>
<span class="codeline" id="line-3259"><code>		if newWork {</code></span>
<span class="codeline" id="line-3260"><code>			// There may be new timer or GC work; restart to</code></span>
<span class="codeline" id="line-3261"><code>			// discover.</code></span>
<span class="codeline" id="line-3262"><code>			goto top</code></span>
<span class="codeline" id="line-3263"><code>		}</code></span>
<span class="codeline" id="line-3264"><code></code></span>
<span class="codeline" id="line-3265"><code>		now = tnow</code></span>
<span class="codeline" id="line-3266"><code>		if w != 0 &amp;&amp; (pollUntil == 0 || w &lt; pollUntil) {</code></span>
<span class="codeline" id="line-3267"><code>			// Earlier timer to wait for.</code></span>
<span class="codeline" id="line-3268"><code>			pollUntil = w</code></span>
<span class="codeline" id="line-3269"><code>		}</code></span>
<span class="codeline" id="line-3270"><code>	}</code></span>
<span class="codeline" id="line-3271"><code></code></span>
<span class="codeline" id="line-3272"><code>	// We have nothing to do.</code></span>
<span class="codeline" id="line-3273"><code>	//</code></span>
<span class="codeline" id="line-3274"><code>	// If we're in the GC mark phase, can safely scan and blacken objects,</code></span>
<span class="codeline" id="line-3275"><code>	// and have work to do, run idle-time marking rather than give up the P.</code></span>
<span class="codeline" id="line-3276"><code>	if gcBlackenEnabled != 0 &amp;&amp; gcMarkWorkAvailable(pp) &amp;&amp; gcController.addIdleMarkWorker() {</code></span>
<span class="codeline" id="line-3277"><code>		node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</code></span>
<span class="codeline" id="line-3278"><code>		if node != nil {</code></span>
<span class="codeline" id="line-3279"><code>			pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</code></span>
<span class="codeline" id="line-3280"><code>			gp := node.gp.ptr()</code></span>
<span class="codeline" id="line-3281"><code></code></span>
<span class="codeline" id="line-3282"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-3283"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3284"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-3285"><code>				trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3286"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-3287"><code>			}</code></span>
<span class="codeline" id="line-3288"><code>			return gp, false, false</code></span>
<span class="codeline" id="line-3289"><code>		}</code></span>
<span class="codeline" id="line-3290"><code>		gcController.removeIdleMarkWorker()</code></span>
<span class="codeline" id="line-3291"><code>	}</code></span>
<span class="codeline" id="line-3292"><code></code></span>
<span class="codeline" id="line-3293"><code>	// wasm only:</code></span>
<span class="codeline" id="line-3294"><code>	// If a callback returned and no other goroutine is awake,</code></span>
<span class="codeline" id="line-3295"><code>	// then wake event handler goroutine which pauses execution</code></span>
<span class="codeline" id="line-3296"><code>	// until a callback was triggered.</code></span>
<span class="codeline" id="line-3297"><code>	gp, otherReady := beforeIdle(now, pollUntil)</code></span>
<span class="codeline" id="line-3298"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-3299"><code>		trace := traceAcquire()</code></span>
<span class="codeline" id="line-3300"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3301"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-3302"><code>			trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3303"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-3304"><code>		}</code></span>
<span class="codeline" id="line-3305"><code>		return gp, false, false</code></span>
<span class="codeline" id="line-3306"><code>	}</code></span>
<span class="codeline" id="line-3307"><code>	if otherReady {</code></span>
<span class="codeline" id="line-3308"><code>		goto top</code></span>
<span class="codeline" id="line-3309"><code>	}</code></span>
<span class="codeline" id="line-3310"><code></code></span>
<span class="codeline" id="line-3311"><code>	// Before we drop our P, make a snapshot of the allp slice,</code></span>
<span class="codeline" id="line-3312"><code>	// which can change underfoot once we no longer block</code></span>
<span class="codeline" id="line-3313"><code>	// safe-points. We don't need to snapshot the contents because</code></span>
<span class="codeline" id="line-3314"><code>	// everything up to cap(allp) is immutable.</code></span>
<span class="codeline" id="line-3315"><code>	allpSnapshot := allp</code></span>
<span class="codeline" id="line-3316"><code>	// Also snapshot masks. Value changes are OK, but we can't allow</code></span>
<span class="codeline" id="line-3317"><code>	// len to change out from under us.</code></span>
<span class="codeline" id="line-3318"><code>	idlepMaskSnapshot := idlepMask</code></span>
<span class="codeline" id="line-3319"><code>	timerpMaskSnapshot := timerpMask</code></span>
<span class="codeline" id="line-3320"><code></code></span>
<span class="codeline" id="line-3321"><code>	// return P and block</code></span>
<span class="codeline" id="line-3322"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3323"><code>	if sched.gcwaiting.Load() || pp.runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-3324"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3325"><code>		goto top</code></span>
<span class="codeline" id="line-3326"><code>	}</code></span>
<span class="codeline" id="line-3327"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-3328"><code>		gp := globrunqget(pp, 0)</code></span>
<span class="codeline" id="line-3329"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3330"><code>		return gp, false, false</code></span>
<span class="codeline" id="line-3331"><code>	}</code></span>
<span class="codeline" id="line-3332"><code>	if !mp.spinning &amp;&amp; sched.needspinning.Load() == 1 {</code></span>
<span class="codeline" id="line-3333"><code>		// See "Delicate dance" comment below.</code></span>
<span class="codeline" id="line-3334"><code>		mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3335"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3336"><code>		goto top</code></span>
<span class="codeline" id="line-3337"><code>	}</code></span>
<span class="codeline" id="line-3338"><code>	if releasep() != pp {</code></span>
<span class="codeline" id="line-3339"><code>		throw("findrunnable: wrong p")</code></span>
<span class="codeline" id="line-3340"><code>	}</code></span>
<span class="codeline" id="line-3341"><code>	now = pidleput(pp, now)</code></span>
<span class="codeline" id="line-3342"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3343"><code></code></span>
<span class="codeline" id="line-3344"><code>	// Delicate dance: thread transitions from spinning to non-spinning</code></span>
<span class="codeline" id="line-3345"><code>	// state, potentially concurrently with submission of new work. We must</code></span>
<span class="codeline" id="line-3346"><code>	// drop nmspinning first and then check all sources again (with</code></span>
<span class="codeline" id="line-3347"><code>	// #StoreLoad memory barrier in between). If we do it the other way</code></span>
<span class="codeline" id="line-3348"><code>	// around, another thread can submit work after we've checked all</code></span>
<span class="codeline" id="line-3349"><code>	// sources but before we drop nmspinning; as a result nobody will</code></span>
<span class="codeline" id="line-3350"><code>	// unpark a thread to run the work.</code></span>
<span class="codeline" id="line-3351"><code>	//</code></span>
<span class="codeline" id="line-3352"><code>	// This applies to the following sources of work:</code></span>
<span class="codeline" id="line-3353"><code>	//</code></span>
<span class="codeline" id="line-3354"><code>	// * Goroutines added to the global or a per-P run queue.</code></span>
<span class="codeline" id="line-3355"><code>	// * New/modified-earlier timers on a per-P timer heap.</code></span>
<span class="codeline" id="line-3356"><code>	// * Idle-priority GC work (barring golang.org/issue/19112).</code></span>
<span class="codeline" id="line-3357"><code>	//</code></span>
<span class="codeline" id="line-3358"><code>	// If we discover new work below, we need to restore m.spinning as a</code></span>
<span class="codeline" id="line-3359"><code>	// signal for resetspinning to unpark a new worker thread (because</code></span>
<span class="codeline" id="line-3360"><code>	// there can be more than one starving goroutine).</code></span>
<span class="codeline" id="line-3361"><code>	//</code></span>
<span class="codeline" id="line-3362"><code>	// However, if after discovering new work we also observe no idle Ps</code></span>
<span class="codeline" id="line-3363"><code>	// (either here or in resetspinning), we have a problem. We may be</code></span>
<span class="codeline" id="line-3364"><code>	// racing with a non-spinning M in the block above, having found no</code></span>
<span class="codeline" id="line-3365"><code>	// work and preparing to release its P and park. Allowing that P to go</code></span>
<span class="codeline" id="line-3366"><code>	// idle will result in loss of work conservation (idle P while there is</code></span>
<span class="codeline" id="line-3367"><code>	// runnable work). This could result in complete deadlock in the</code></span>
<span class="codeline" id="line-3368"><code>	// unlikely event that we discover new work (from netpoll) right as we</code></span>
<span class="codeline" id="line-3369"><code>	// are racing with _all_ other Ps going idle.</code></span>
<span class="codeline" id="line-3370"><code>	//</code></span>
<span class="codeline" id="line-3371"><code>	// We use sched.needspinning to synchronize with non-spinning Ms going</code></span>
<span class="codeline" id="line-3372"><code>	// idle. If needspinning is set when they are about to drop their P,</code></span>
<span class="codeline" id="line-3373"><code>	// they abort the drop and instead become a new spinning M on our</code></span>
<span class="codeline" id="line-3374"><code>	// behalf. If we are not racing and the system is truly fully loaded</code></span>
<span class="codeline" id="line-3375"><code>	// then no spinning threads are required, and the next thread to</code></span>
<span class="codeline" id="line-3376"><code>	// naturally become spinning will clear the flag.</code></span>
<span class="codeline" id="line-3377"><code>	//</code></span>
<span class="codeline" id="line-3378"><code>	// Also see "Worker thread parking/unparking" comment at the top of the</code></span>
<span class="codeline" id="line-3379"><code>	// file.</code></span>
<span class="codeline" id="line-3380"><code>	wasSpinning := mp.spinning</code></span>
<span class="codeline" id="line-3381"><code>	if mp.spinning {</code></span>
<span class="codeline" id="line-3382"><code>		mp.spinning = false</code></span>
<span class="codeline" id="line-3383"><code>		if sched.nmspinning.Add(-1) &lt; 0 {</code></span>
<span class="codeline" id="line-3384"><code>			throw("findrunnable: negative nmspinning")</code></span>
<span class="codeline" id="line-3385"><code>		}</code></span>
<span class="codeline" id="line-3386"><code></code></span>
<span class="codeline" id="line-3387"><code>		// Note the for correctness, only the last M transitioning from</code></span>
<span class="codeline" id="line-3388"><code>		// spinning to non-spinning must perform these rechecks to</code></span>
<span class="codeline" id="line-3389"><code>		// ensure no missed work. However, the runtime has some cases</code></span>
<span class="codeline" id="line-3390"><code>		// of transient increments of nmspinning that are decremented</code></span>
<span class="codeline" id="line-3391"><code>		// without going through this path, so we must be conservative</code></span>
<span class="codeline" id="line-3392"><code>		// and perform the check on all spinning Ms.</code></span>
<span class="codeline" id="line-3393"><code>		//</code></span>
<span class="codeline" id="line-3394"><code>		// See https://go.dev/issue/43997.</code></span>
<span class="codeline" id="line-3395"><code></code></span>
<span class="codeline" id="line-3396"><code>		// Check global and P runqueues again.</code></span>
<span class="codeline" id="line-3397"><code></code></span>
<span class="codeline" id="line-3398"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3399"><code>		if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-3400"><code>			pp, _ := pidlegetSpinning(0)</code></span>
<span class="codeline" id="line-3401"><code>			if pp != nil {</code></span>
<span class="codeline" id="line-3402"><code>				gp := globrunqget(pp, 0)</code></span>
<span class="codeline" id="line-3403"><code>				if gp == nil {</code></span>
<span class="codeline" id="line-3404"><code>					throw("global runq empty with non-zero runqsize")</code></span>
<span class="codeline" id="line-3405"><code>				}</code></span>
<span class="codeline" id="line-3406"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3407"><code>				acquirep(pp)</code></span>
<span class="codeline" id="line-3408"><code>				mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3409"><code>				return gp, false, false</code></span>
<span class="codeline" id="line-3410"><code>			}</code></span>
<span class="codeline" id="line-3411"><code>		}</code></span>
<span class="codeline" id="line-3412"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3413"><code></code></span>
<span class="codeline" id="line-3414"><code>		pp := checkRunqsNoP(allpSnapshot, idlepMaskSnapshot)</code></span>
<span class="codeline" id="line-3415"><code>		if pp != nil {</code></span>
<span class="codeline" id="line-3416"><code>			acquirep(pp)</code></span>
<span class="codeline" id="line-3417"><code>			mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3418"><code>			goto top</code></span>
<span class="codeline" id="line-3419"><code>		}</code></span>
<span class="codeline" id="line-3420"><code></code></span>
<span class="codeline" id="line-3421"><code>		// Check for idle-priority GC work again.</code></span>
<span class="codeline" id="line-3422"><code>		pp, gp := checkIdleGCNoP()</code></span>
<span class="codeline" id="line-3423"><code>		if pp != nil {</code></span>
<span class="codeline" id="line-3424"><code>			acquirep(pp)</code></span>
<span class="codeline" id="line-3425"><code>			mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3426"><code></code></span>
<span class="codeline" id="line-3427"><code>			// Run the idle worker.</code></span>
<span class="codeline" id="line-3428"><code>			pp.gcMarkWorkerMode = gcMarkWorkerIdleMode</code></span>
<span class="codeline" id="line-3429"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-3430"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3431"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-3432"><code>				trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3433"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-3434"><code>			}</code></span>
<span class="codeline" id="line-3435"><code>			return gp, false, false</code></span>
<span class="codeline" id="line-3436"><code>		}</code></span>
<span class="codeline" id="line-3437"><code></code></span>
<span class="codeline" id="line-3438"><code>		// Finally, check for timer creation or expiry concurrently with</code></span>
<span class="codeline" id="line-3439"><code>		// transitioning from spinning to non-spinning.</code></span>
<span class="codeline" id="line-3440"><code>		//</code></span>
<span class="codeline" id="line-3441"><code>		// Note that we cannot use checkTimers here because it calls</code></span>
<span class="codeline" id="line-3442"><code>		// adjusttimers which may need to allocate memory, and that isn't</code></span>
<span class="codeline" id="line-3443"><code>		// allowed when we don't have an active P.</code></span>
<span class="codeline" id="line-3444"><code>		pollUntil = checkTimersNoP(allpSnapshot, timerpMaskSnapshot, pollUntil)</code></span>
<span class="codeline" id="line-3445"><code>	}</code></span>
<span class="codeline" id="line-3446"><code></code></span>
<span class="codeline" id="line-3447"><code>	// Poll network until next timer.</code></span>
<span class="codeline" id="line-3448"><code>	if netpollinited() &amp;&amp; (netpollAnyWaiters() || pollUntil != 0) &amp;&amp; sched.lastpoll.Swap(0) != 0 {</code></span>
<span class="codeline" id="line-3449"><code>		sched.pollUntil.Store(pollUntil)</code></span>
<span class="codeline" id="line-3450"><code>		if mp.p != 0 {</code></span>
<span class="codeline" id="line-3451"><code>			throw("findrunnable: netpoll with p")</code></span>
<span class="codeline" id="line-3452"><code>		}</code></span>
<span class="codeline" id="line-3453"><code>		if mp.spinning {</code></span>
<span class="codeline" id="line-3454"><code>			throw("findrunnable: netpoll with spinning")</code></span>
<span class="codeline" id="line-3455"><code>		}</code></span>
<span class="codeline" id="line-3456"><code>		delay := int64(-1)</code></span>
<span class="codeline" id="line-3457"><code>		if pollUntil != 0 {</code></span>
<span class="codeline" id="line-3458"><code>			if now == 0 {</code></span>
<span class="codeline" id="line-3459"><code>				now = nanotime()</code></span>
<span class="codeline" id="line-3460"><code>			}</code></span>
<span class="codeline" id="line-3461"><code>			delay = pollUntil - now</code></span>
<span class="codeline" id="line-3462"><code>			if delay &lt; 0 {</code></span>
<span class="codeline" id="line-3463"><code>				delay = 0</code></span>
<span class="codeline" id="line-3464"><code>			}</code></span>
<span class="codeline" id="line-3465"><code>		}</code></span>
<span class="codeline" id="line-3466"><code>		if faketime != 0 {</code></span>
<span class="codeline" id="line-3467"><code>			// When using fake time, just poll.</code></span>
<span class="codeline" id="line-3468"><code>			delay = 0</code></span>
<span class="codeline" id="line-3469"><code>		}</code></span>
<span class="codeline" id="line-3470"><code>		list, delta := netpoll(delay) // block until new work is available</code></span>
<span class="codeline" id="line-3471"><code>		// Refresh now again, after potentially blocking.</code></span>
<span class="codeline" id="line-3472"><code>		now = nanotime()</code></span>
<span class="codeline" id="line-3473"><code>		sched.pollUntil.Store(0)</code></span>
<span class="codeline" id="line-3474"><code>		sched.lastpoll.Store(now)</code></span>
<span class="codeline" id="line-3475"><code>		if faketime != 0 &amp;&amp; list.empty() {</code></span>
<span class="codeline" id="line-3476"><code>			// Using fake time and nothing is ready; stop M.</code></span>
<span class="codeline" id="line-3477"><code>			// When all M's stop, checkdead will call timejump.</code></span>
<span class="codeline" id="line-3478"><code>			stopm()</code></span>
<span class="codeline" id="line-3479"><code>			goto top</code></span>
<span class="codeline" id="line-3480"><code>		}</code></span>
<span class="codeline" id="line-3481"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3482"><code>		pp, _ := pidleget(now)</code></span>
<span class="codeline" id="line-3483"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3484"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-3485"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-3486"><code>			netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-3487"><code>		} else {</code></span>
<span class="codeline" id="line-3488"><code>			acquirep(pp)</code></span>
<span class="codeline" id="line-3489"><code>			if !list.empty() {</code></span>
<span class="codeline" id="line-3490"><code>				gp := list.pop()</code></span>
<span class="codeline" id="line-3491"><code>				injectglist(&amp;list)</code></span>
<span class="codeline" id="line-3492"><code>				netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-3493"><code>				trace := traceAcquire()</code></span>
<span class="codeline" id="line-3494"><code>				casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3495"><code>				if trace.ok() {</code></span>
<span class="codeline" id="line-3496"><code>					trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3497"><code>					traceRelease(trace)</code></span>
<span class="codeline" id="line-3498"><code>				}</code></span>
<span class="codeline" id="line-3499"><code>				return gp, false, false</code></span>
<span class="codeline" id="line-3500"><code>			}</code></span>
<span class="codeline" id="line-3501"><code>			if wasSpinning {</code></span>
<span class="codeline" id="line-3502"><code>				mp.becomeSpinning()</code></span>
<span class="codeline" id="line-3503"><code>			}</code></span>
<span class="codeline" id="line-3504"><code>			goto top</code></span>
<span class="codeline" id="line-3505"><code>		}</code></span>
<span class="codeline" id="line-3506"><code>	} else if pollUntil != 0 &amp;&amp; netpollinited() {</code></span>
<span class="codeline" id="line-3507"><code>		pollerPollUntil := sched.pollUntil.Load()</code></span>
<span class="codeline" id="line-3508"><code>		if pollerPollUntil == 0 || pollerPollUntil &gt; pollUntil {</code></span>
<span class="codeline" id="line-3509"><code>			netpollBreak()</code></span>
<span class="codeline" id="line-3510"><code>		}</code></span>
<span class="codeline" id="line-3511"><code>	}</code></span>
<span class="codeline" id="line-3512"><code>	stopm()</code></span>
<span class="codeline" id="line-3513"><code>	goto top</code></span>
<span class="codeline" id="line-3514"><code>}</code></span>
<span class="codeline" id="line-3515"><code></code></span>
<span class="codeline" id="line-3516"><code>// pollWork reports whether there is non-background work this P could</code></span>
<span class="codeline" id="line-3517"><code>// be doing. This is a fairly lightweight check to be used for</code></span>
<span class="codeline" id="line-3518"><code>// background work loops, like idle GC. It checks a subset of the</code></span>
<span class="codeline" id="line-3519"><code>// conditions checked by the actual scheduler.</code></span>
<span class="codeline" id="line-3520"><code>func pollWork() bool {</code></span>
<span class="codeline" id="line-3521"><code>	if sched.runqsize != 0 {</code></span>
<span class="codeline" id="line-3522"><code>		return true</code></span>
<span class="codeline" id="line-3523"><code>	}</code></span>
<span class="codeline" id="line-3524"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-3525"><code>	if !runqempty(p) {</code></span>
<span class="codeline" id="line-3526"><code>		return true</code></span>
<span class="codeline" id="line-3527"><code>	}</code></span>
<span class="codeline" id="line-3528"><code>	if netpollinited() &amp;&amp; netpollAnyWaiters() &amp;&amp; sched.lastpoll.Load() != 0 {</code></span>
<span class="codeline" id="line-3529"><code>		if list, delta := netpoll(0); !list.empty() {</code></span>
<span class="codeline" id="line-3530"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-3531"><code>			netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-3532"><code>			return true</code></span>
<span class="codeline" id="line-3533"><code>		}</code></span>
<span class="codeline" id="line-3534"><code>	}</code></span>
<span class="codeline" id="line-3535"><code>	return false</code></span>
<span class="codeline" id="line-3536"><code>}</code></span>
<span class="codeline" id="line-3537"><code></code></span>
<span class="codeline" id="line-3538"><code>// stealWork attempts to steal a runnable goroutine or timer from any P.</code></span>
<span class="codeline" id="line-3539"><code>//</code></span>
<span class="codeline" id="line-3540"><code>// If newWork is true, new work may have been readied.</code></span>
<span class="codeline" id="line-3541"><code>//</code></span>
<span class="codeline" id="line-3542"><code>// If now is not 0 it is the current time. stealWork returns the passed time or</code></span>
<span class="codeline" id="line-3543"><code>// the current time if now was passed as 0.</code></span>
<span class="codeline" id="line-3544"><code>func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool) {</code></span>
<span class="codeline" id="line-3545"><code>	pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-3546"><code></code></span>
<span class="codeline" id="line-3547"><code>	ranTimer := false</code></span>
<span class="codeline" id="line-3548"><code></code></span>
<span class="codeline" id="line-3549"><code>	const stealTries = 4</code></span>
<span class="codeline" id="line-3550"><code>	for i := 0; i &lt; stealTries; i++ {</code></span>
<span class="codeline" id="line-3551"><code>		stealTimersOrRunNextG := i == stealTries-1</code></span>
<span class="codeline" id="line-3552"><code></code></span>
<span class="codeline" id="line-3553"><code>		for enum := stealOrder.start(cheaprand()); !enum.done(); enum.next() {</code></span>
<span class="codeline" id="line-3554"><code>			if sched.gcwaiting.Load() {</code></span>
<span class="codeline" id="line-3555"><code>				// GC work may be available.</code></span>
<span class="codeline" id="line-3556"><code>				return nil, false, now, pollUntil, true</code></span>
<span class="codeline" id="line-3557"><code>			}</code></span>
<span class="codeline" id="line-3558"><code>			p2 := allp[enum.position()]</code></span>
<span class="codeline" id="line-3559"><code>			if pp == p2 {</code></span>
<span class="codeline" id="line-3560"><code>				continue</code></span>
<span class="codeline" id="line-3561"><code>			}</code></span>
<span class="codeline" id="line-3562"><code></code></span>
<span class="codeline" id="line-3563"><code>			// Steal timers from p2. This call to checkTimers is the only place</code></span>
<span class="codeline" id="line-3564"><code>			// where we might hold a lock on a different P's timers. We do this</code></span>
<span class="codeline" id="line-3565"><code>			// once on the last pass before checking runnext because stealing</code></span>
<span class="codeline" id="line-3566"><code>			// from the other P's runnext should be the last resort, so if there</code></span>
<span class="codeline" id="line-3567"><code>			// are timers to steal do that first.</code></span>
<span class="codeline" id="line-3568"><code>			//</code></span>
<span class="codeline" id="line-3569"><code>			// We only check timers on one of the stealing iterations because</code></span>
<span class="codeline" id="line-3570"><code>			// the time stored in now doesn't change in this loop and checking</code></span>
<span class="codeline" id="line-3571"><code>			// the timers for each P more than once with the same value of now</code></span>
<span class="codeline" id="line-3572"><code>			// is probably a waste of time.</code></span>
<span class="codeline" id="line-3573"><code>			//</code></span>
<span class="codeline" id="line-3574"><code>			// timerpMask tells us whether the P may have timers at all. If it</code></span>
<span class="codeline" id="line-3575"><code>			// can't, no need to check at all.</code></span>
<span class="codeline" id="line-3576"><code>			if stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) {</code></span>
<span class="codeline" id="line-3577"><code>				tnow, w, ran := checkTimers(p2, now)</code></span>
<span class="codeline" id="line-3578"><code>				now = tnow</code></span>
<span class="codeline" id="line-3579"><code>				if w != 0 &amp;&amp; (pollUntil == 0 || w &lt; pollUntil) {</code></span>
<span class="codeline" id="line-3580"><code>					pollUntil = w</code></span>
<span class="codeline" id="line-3581"><code>				}</code></span>
<span class="codeline" id="line-3582"><code>				if ran {</code></span>
<span class="codeline" id="line-3583"><code>					// Running the timers may have</code></span>
<span class="codeline" id="line-3584"><code>					// made an arbitrary number of G's</code></span>
<span class="codeline" id="line-3585"><code>					// ready and added them to this P's</code></span>
<span class="codeline" id="line-3586"><code>					// local run queue. That invalidates</code></span>
<span class="codeline" id="line-3587"><code>					// the assumption of runqsteal</code></span>
<span class="codeline" id="line-3588"><code>					// that it always has room to add</code></span>
<span class="codeline" id="line-3589"><code>					// stolen G's. So check now if there</code></span>
<span class="codeline" id="line-3590"><code>					// is a local G to run.</code></span>
<span class="codeline" id="line-3591"><code>					if gp, inheritTime := runqget(pp); gp != nil {</code></span>
<span class="codeline" id="line-3592"><code>						return gp, inheritTime, now, pollUntil, ranTimer</code></span>
<span class="codeline" id="line-3593"><code>					}</code></span>
<span class="codeline" id="line-3594"><code>					ranTimer = true</code></span>
<span class="codeline" id="line-3595"><code>				}</code></span>
<span class="codeline" id="line-3596"><code>			}</code></span>
<span class="codeline" id="line-3597"><code></code></span>
<span class="codeline" id="line-3598"><code>			// Don't bother to attempt to steal if p2 is idle.</code></span>
<span class="codeline" id="line-3599"><code>			if !idlepMask.read(enum.position()) {</code></span>
<span class="codeline" id="line-3600"><code>				if gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != nil {</code></span>
<span class="codeline" id="line-3601"><code>					return gp, false, now, pollUntil, ranTimer</code></span>
<span class="codeline" id="line-3602"><code>				}</code></span>
<span class="codeline" id="line-3603"><code>			}</code></span>
<span class="codeline" id="line-3604"><code>		}</code></span>
<span class="codeline" id="line-3605"><code>	}</code></span>
<span class="codeline" id="line-3606"><code></code></span>
<span class="codeline" id="line-3607"><code>	// No goroutines found to steal. Regardless, running a timer may have</code></span>
<span class="codeline" id="line-3608"><code>	// made some goroutine ready that we missed. Indicate the next timer to</code></span>
<span class="codeline" id="line-3609"><code>	// wait for.</code></span>
<span class="codeline" id="line-3610"><code>	return nil, false, now, pollUntil, ranTimer</code></span>
<span class="codeline" id="line-3611"><code>}</code></span>
<span class="codeline" id="line-3612"><code></code></span>
<span class="codeline" id="line-3613"><code>// Check all Ps for a runnable G to steal.</code></span>
<span class="codeline" id="line-3614"><code>//</code></span>
<span class="codeline" id="line-3615"><code>// On entry we have no P. If a G is available to steal and a P is available,</code></span>
<span class="codeline" id="line-3616"><code>// the P is returned which the caller should acquire and attempt to steal the</code></span>
<span class="codeline" id="line-3617"><code>// work to.</code></span>
<span class="codeline" id="line-3618"><code>func checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p {</code></span>
<span class="codeline" id="line-3619"><code>	for id, p2 := range allpSnapshot {</code></span>
<span class="codeline" id="line-3620"><code>		if !idlepMaskSnapshot.read(uint32(id)) &amp;&amp; !runqempty(p2) {</code></span>
<span class="codeline" id="line-3621"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3622"><code>			pp, _ := pidlegetSpinning(0)</code></span>
<span class="codeline" id="line-3623"><code>			if pp == nil {</code></span>
<span class="codeline" id="line-3624"><code>				// Can't get a P, don't bother checking remaining Ps.</code></span>
<span class="codeline" id="line-3625"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3626"><code>				return nil</code></span>
<span class="codeline" id="line-3627"><code>			}</code></span>
<span class="codeline" id="line-3628"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3629"><code>			return pp</code></span>
<span class="codeline" id="line-3630"><code>		}</code></span>
<span class="codeline" id="line-3631"><code>	}</code></span>
<span class="codeline" id="line-3632"><code></code></span>
<span class="codeline" id="line-3633"><code>	// No work available.</code></span>
<span class="codeline" id="line-3634"><code>	return nil</code></span>
<span class="codeline" id="line-3635"><code>}</code></span>
<span class="codeline" id="line-3636"><code></code></span>
<span class="codeline" id="line-3637"><code>// Check all Ps for a timer expiring sooner than pollUntil.</code></span>
<span class="codeline" id="line-3638"><code>//</code></span>
<span class="codeline" id="line-3639"><code>// Returns updated pollUntil value.</code></span>
<span class="codeline" id="line-3640"><code>func checkTimersNoP(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil int64) int64 {</code></span>
<span class="codeline" id="line-3641"><code>	for id, p2 := range allpSnapshot {</code></span>
<span class="codeline" id="line-3642"><code>		if timerpMaskSnapshot.read(uint32(id)) {</code></span>
<span class="codeline" id="line-3643"><code>			w := nobarrierWakeTime(p2)</code></span>
<span class="codeline" id="line-3644"><code>			if w != 0 &amp;&amp; (pollUntil == 0 || w &lt; pollUntil) {</code></span>
<span class="codeline" id="line-3645"><code>				pollUntil = w</code></span>
<span class="codeline" id="line-3646"><code>			}</code></span>
<span class="codeline" id="line-3647"><code>		}</code></span>
<span class="codeline" id="line-3648"><code>	}</code></span>
<span class="codeline" id="line-3649"><code></code></span>
<span class="codeline" id="line-3650"><code>	return pollUntil</code></span>
<span class="codeline" id="line-3651"><code>}</code></span>
<span class="codeline" id="line-3652"><code></code></span>
<span class="codeline" id="line-3653"><code>// Check for idle-priority GC, without a P on entry.</code></span>
<span class="codeline" id="line-3654"><code>//</code></span>
<span class="codeline" id="line-3655"><code>// If some GC work, a P, and a worker G are all available, the P and G will be</code></span>
<span class="codeline" id="line-3656"><code>// returned. The returned P has not been wired yet.</code></span>
<span class="codeline" id="line-3657"><code>func checkIdleGCNoP() (*p, *g) {</code></span>
<span class="codeline" id="line-3658"><code>	// N.B. Since we have no P, gcBlackenEnabled may change at any time; we</code></span>
<span class="codeline" id="line-3659"><code>	// must check again after acquiring a P. As an optimization, we also check</code></span>
<span class="codeline" id="line-3660"><code>	// if an idle mark worker is needed at all. This is OK here, because if we</code></span>
<span class="codeline" id="line-3661"><code>	// observe that one isn't needed, at least one is currently running. Even if</code></span>
<span class="codeline" id="line-3662"><code>	// it stops running, its own journey into the scheduler should schedule it</code></span>
<span class="codeline" id="line-3663"><code>	// again, if need be (at which point, this check will pass, if relevant).</code></span>
<span class="codeline" id="line-3664"><code>	if atomic.Load(&amp;gcBlackenEnabled) == 0 || !gcController.needIdleMarkWorker() {</code></span>
<span class="codeline" id="line-3665"><code>		return nil, nil</code></span>
<span class="codeline" id="line-3666"><code>	}</code></span>
<span class="codeline" id="line-3667"><code>	if !gcMarkWorkAvailable(nil) {</code></span>
<span class="codeline" id="line-3668"><code>		return nil, nil</code></span>
<span class="codeline" id="line-3669"><code>	}</code></span>
<span class="codeline" id="line-3670"><code></code></span>
<span class="codeline" id="line-3671"><code>	// Work is available; we can start an idle GC worker only if there is</code></span>
<span class="codeline" id="line-3672"><code>	// an available P and available worker G.</code></span>
<span class="codeline" id="line-3673"><code>	//</code></span>
<span class="codeline" id="line-3674"><code>	// We can attempt to acquire these in either order, though both have</code></span>
<span class="codeline" id="line-3675"><code>	// synchronization concerns (see below). Workers are almost always</code></span>
<span class="codeline" id="line-3676"><code>	// available (see comment in findRunnableGCWorker for the one case</code></span>
<span class="codeline" id="line-3677"><code>	// there may be none). Since we're slightly less likely to find a P,</code></span>
<span class="codeline" id="line-3678"><code>	// check for that first.</code></span>
<span class="codeline" id="line-3679"><code>	//</code></span>
<span class="codeline" id="line-3680"><code>	// Synchronization: note that we must hold sched.lock until we are</code></span>
<span class="codeline" id="line-3681"><code>	// committed to keeping it. Otherwise we cannot put the unnecessary P</code></span>
<span class="codeline" id="line-3682"><code>	// back in sched.pidle without performing the full set of idle</code></span>
<span class="codeline" id="line-3683"><code>	// transition checks.</code></span>
<span class="codeline" id="line-3684"><code>	//</code></span>
<span class="codeline" id="line-3685"><code>	// If we were to check gcBgMarkWorkerPool first, we must somehow handle</code></span>
<span class="codeline" id="line-3686"><code>	// the assumption in gcControllerState.findRunnableGCWorker that an</code></span>
<span class="codeline" id="line-3687"><code>	// empty gcBgMarkWorkerPool is only possible if gcMarkDone is running.</code></span>
<span class="codeline" id="line-3688"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3689"><code>	pp, now := pidlegetSpinning(0)</code></span>
<span class="codeline" id="line-3690"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-3691"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3692"><code>		return nil, nil</code></span>
<span class="codeline" id="line-3693"><code>	}</code></span>
<span class="codeline" id="line-3694"><code></code></span>
<span class="codeline" id="line-3695"><code>	// Now that we own a P, gcBlackenEnabled can't change (as it requires STW).</code></span>
<span class="codeline" id="line-3696"><code>	if gcBlackenEnabled == 0 || !gcController.addIdleMarkWorker() {</code></span>
<span class="codeline" id="line-3697"><code>		pidleput(pp, now)</code></span>
<span class="codeline" id="line-3698"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3699"><code>		return nil, nil</code></span>
<span class="codeline" id="line-3700"><code>	}</code></span>
<span class="codeline" id="line-3701"><code></code></span>
<span class="codeline" id="line-3702"><code>	node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</code></span>
<span class="codeline" id="line-3703"><code>	if node == nil {</code></span>
<span class="codeline" id="line-3704"><code>		pidleput(pp, now)</code></span>
<span class="codeline" id="line-3705"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3706"><code>		gcController.removeIdleMarkWorker()</code></span>
<span class="codeline" id="line-3707"><code>		return nil, nil</code></span>
<span class="codeline" id="line-3708"><code>	}</code></span>
<span class="codeline" id="line-3709"><code></code></span>
<span class="codeline" id="line-3710"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3711"><code></code></span>
<span class="codeline" id="line-3712"><code>	return pp, node.gp.ptr()</code></span>
<span class="codeline" id="line-3713"><code>}</code></span>
<span class="codeline" id="line-3714"><code></code></span>
<span class="codeline" id="line-3715"><code>// wakeNetPoller wakes up the thread sleeping in the network poller if it isn't</code></span>
<span class="codeline" id="line-3716"><code>// going to wake up before the when argument; or it wakes an idle P to service</code></span>
<span class="codeline" id="line-3717"><code>// timers and the network poller if there isn't one already.</code></span>
<span class="codeline" id="line-3718"><code>func wakeNetPoller(when int64) {</code></span>
<span class="codeline" id="line-3719"><code>	if sched.lastpoll.Load() == 0 {</code></span>
<span class="codeline" id="line-3720"><code>		// In findrunnable we ensure that when polling the pollUntil</code></span>
<span class="codeline" id="line-3721"><code>		// field is either zero or the time to which the current</code></span>
<span class="codeline" id="line-3722"><code>		// poll is expected to run. This can have a spurious wakeup</code></span>
<span class="codeline" id="line-3723"><code>		// but should never miss a wakeup.</code></span>
<span class="codeline" id="line-3724"><code>		pollerPollUntil := sched.pollUntil.Load()</code></span>
<span class="codeline" id="line-3725"><code>		if pollerPollUntil == 0 || pollerPollUntil &gt; when {</code></span>
<span class="codeline" id="line-3726"><code>			netpollBreak()</code></span>
<span class="codeline" id="line-3727"><code>		}</code></span>
<span class="codeline" id="line-3728"><code>	} else {</code></span>
<span class="codeline" id="line-3729"><code>		// There are no threads in the network poller, try to get</code></span>
<span class="codeline" id="line-3730"><code>		// one there so it can handle new timers.</code></span>
<span class="codeline" id="line-3731"><code>		if GOOS != "plan9" { // Temporary workaround - see issue #42303.</code></span>
<span class="codeline" id="line-3732"><code>			wakep()</code></span>
<span class="codeline" id="line-3733"><code>		}</code></span>
<span class="codeline" id="line-3734"><code>	}</code></span>
<span class="codeline" id="line-3735"><code>}</code></span>
<span class="codeline" id="line-3736"><code></code></span>
<span class="codeline" id="line-3737"><code>func resetspinning() {</code></span>
<span class="codeline" id="line-3738"><code>	gp := getg()</code></span>
<span class="codeline" id="line-3739"><code>	if !gp.m.spinning {</code></span>
<span class="codeline" id="line-3740"><code>		throw("resetspinning: not a spinning m")</code></span>
<span class="codeline" id="line-3741"><code>	}</code></span>
<span class="codeline" id="line-3742"><code>	gp.m.spinning = false</code></span>
<span class="codeline" id="line-3743"><code>	nmspinning := sched.nmspinning.Add(-1)</code></span>
<span class="codeline" id="line-3744"><code>	if nmspinning &lt; 0 {</code></span>
<span class="codeline" id="line-3745"><code>		throw("findrunnable: negative nmspinning")</code></span>
<span class="codeline" id="line-3746"><code>	}</code></span>
<span class="codeline" id="line-3747"><code>	// M wakeup policy is deliberately somewhat conservative, so check if we</code></span>
<span class="codeline" id="line-3748"><code>	// need to wakeup another P here. See "Worker thread parking/unparking"</code></span>
<span class="codeline" id="line-3749"><code>	// comment at the top of the file for details.</code></span>
<span class="codeline" id="line-3750"><code>	wakep()</code></span>
<span class="codeline" id="line-3751"><code>}</code></span>
<span class="codeline" id="line-3752"><code></code></span>
<span class="codeline" id="line-3753"><code>// injectglist adds each runnable G on the list to some run queue,</code></span>
<span class="codeline" id="line-3754"><code>// and clears glist. If there is no current P, they are added to the</code></span>
<span class="codeline" id="line-3755"><code>// global queue, and up to npidle M's are started to run them.</code></span>
<span class="codeline" id="line-3756"><code>// Otherwise, for each idle P, this adds a G to the global queue</code></span>
<span class="codeline" id="line-3757"><code>// and starts an M. Any remaining G's are added to the current P's</code></span>
<span class="codeline" id="line-3758"><code>// local run queue.</code></span>
<span class="codeline" id="line-3759"><code>// This may temporarily acquire sched.lock.</code></span>
<span class="codeline" id="line-3760"><code>// Can run concurrently with GC.</code></span>
<span class="codeline" id="line-3761"><code>func injectglist(glist *gList) {</code></span>
<span class="codeline" id="line-3762"><code>	if glist.empty() {</code></span>
<span class="codeline" id="line-3763"><code>		return</code></span>
<span class="codeline" id="line-3764"><code>	}</code></span>
<span class="codeline" id="line-3765"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-3766"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-3767"><code>		for gp := glist.head.ptr(); gp != nil; gp = gp.schedlink.ptr() {</code></span>
<span class="codeline" id="line-3768"><code>			trace.GoUnpark(gp, 0)</code></span>
<span class="codeline" id="line-3769"><code>		}</code></span>
<span class="codeline" id="line-3770"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-3771"><code>	}</code></span>
<span class="codeline" id="line-3772"><code></code></span>
<span class="codeline" id="line-3773"><code>	// Mark all the goroutines as runnable before we put them</code></span>
<span class="codeline" id="line-3774"><code>	// on the run queues.</code></span>
<span class="codeline" id="line-3775"><code>	head := glist.head.ptr()</code></span>
<span class="codeline" id="line-3776"><code>	var tail *g</code></span>
<span class="codeline" id="line-3777"><code>	qsize := 0</code></span>
<span class="codeline" id="line-3778"><code>	for gp := head; gp != nil; gp = gp.schedlink.ptr() {</code></span>
<span class="codeline" id="line-3779"><code>		tail = gp</code></span>
<span class="codeline" id="line-3780"><code>		qsize++</code></span>
<span class="codeline" id="line-3781"><code>		casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-3782"><code>	}</code></span>
<span class="codeline" id="line-3783"><code></code></span>
<span class="codeline" id="line-3784"><code>	// Turn the gList into a gQueue.</code></span>
<span class="codeline" id="line-3785"><code>	var q gQueue</code></span>
<span class="codeline" id="line-3786"><code>	q.head.set(head)</code></span>
<span class="codeline" id="line-3787"><code>	q.tail.set(tail)</code></span>
<span class="codeline" id="line-3788"><code>	*glist = gList{}</code></span>
<span class="codeline" id="line-3789"><code></code></span>
<span class="codeline" id="line-3790"><code>	startIdle := func(n int) {</code></span>
<span class="codeline" id="line-3791"><code>		for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-3792"><code>			mp := acquirem() // See comment in startm.</code></span>
<span class="codeline" id="line-3793"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3794"><code></code></span>
<span class="codeline" id="line-3795"><code>			pp, _ := pidlegetSpinning(0)</code></span>
<span class="codeline" id="line-3796"><code>			if pp == nil {</code></span>
<span class="codeline" id="line-3797"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3798"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-3799"><code>				break</code></span>
<span class="codeline" id="line-3800"><code>			}</code></span>
<span class="codeline" id="line-3801"><code></code></span>
<span class="codeline" id="line-3802"><code>			startm(pp, false, true)</code></span>
<span class="codeline" id="line-3803"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3804"><code>			releasem(mp)</code></span>
<span class="codeline" id="line-3805"><code>		}</code></span>
<span class="codeline" id="line-3806"><code>	}</code></span>
<span class="codeline" id="line-3807"><code></code></span>
<span class="codeline" id="line-3808"><code>	pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-3809"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-3810"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3811"><code>		globrunqputbatch(&amp;q, int32(qsize))</code></span>
<span class="codeline" id="line-3812"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3813"><code>		startIdle(qsize)</code></span>
<span class="codeline" id="line-3814"><code>		return</code></span>
<span class="codeline" id="line-3815"><code>	}</code></span>
<span class="codeline" id="line-3816"><code></code></span>
<span class="codeline" id="line-3817"><code>	npidle := int(sched.npidle.Load())</code></span>
<span class="codeline" id="line-3818"><code>	var globq gQueue</code></span>
<span class="codeline" id="line-3819"><code>	var n int</code></span>
<span class="codeline" id="line-3820"><code>	for n = 0; n &lt; npidle &amp;&amp; !q.empty(); n++ {</code></span>
<span class="codeline" id="line-3821"><code>		g := q.pop()</code></span>
<span class="codeline" id="line-3822"><code>		globq.pushBack(g)</code></span>
<span class="codeline" id="line-3823"><code>	}</code></span>
<span class="codeline" id="line-3824"><code>	if n &gt; 0 {</code></span>
<span class="codeline" id="line-3825"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3826"><code>		globrunqputbatch(&amp;globq, int32(n))</code></span>
<span class="codeline" id="line-3827"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3828"><code>		startIdle(n)</code></span>
<span class="codeline" id="line-3829"><code>		qsize -= n</code></span>
<span class="codeline" id="line-3830"><code>	}</code></span>
<span class="codeline" id="line-3831"><code></code></span>
<span class="codeline" id="line-3832"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-3833"><code>		runqputbatch(pp, &amp;q, qsize)</code></span>
<span class="codeline" id="line-3834"><code>	}</code></span>
<span class="codeline" id="line-3835"><code>}</code></span>
<span class="codeline" id="line-3836"><code></code></span>
<span class="codeline" id="line-3837"><code>// One round of scheduler: find a runnable goroutine and execute it.</code></span>
<span class="codeline" id="line-3838"><code>// Never returns.</code></span>
<span class="codeline" id="line-3839"><code>func schedule() {</code></span>
<span class="codeline" id="line-3840"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-3841"><code></code></span>
<span class="codeline" id="line-3842"><code>	if mp.locks != 0 {</code></span>
<span class="codeline" id="line-3843"><code>		throw("schedule: holding locks")</code></span>
<span class="codeline" id="line-3844"><code>	}</code></span>
<span class="codeline" id="line-3845"><code></code></span>
<span class="codeline" id="line-3846"><code>	if mp.lockedg != 0 {</code></span>
<span class="codeline" id="line-3847"><code>		stoplockedm()</code></span>
<span class="codeline" id="line-3848"><code>		execute(mp.lockedg.ptr(), false) // Never returns.</code></span>
<span class="codeline" id="line-3849"><code>	}</code></span>
<span class="codeline" id="line-3850"><code></code></span>
<span class="codeline" id="line-3851"><code>	// We should not schedule away from a g that is executing a cgo call,</code></span>
<span class="codeline" id="line-3852"><code>	// since the cgo call is using the m's g0 stack.</code></span>
<span class="codeline" id="line-3853"><code>	if mp.incgo {</code></span>
<span class="codeline" id="line-3854"><code>		throw("schedule: in cgo")</code></span>
<span class="codeline" id="line-3855"><code>	}</code></span>
<span class="codeline" id="line-3856"><code></code></span>
<span class="codeline" id="line-3857"><code>top:</code></span>
<span class="codeline" id="line-3858"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-3859"><code>	pp.preempt = false</code></span>
<span class="codeline" id="line-3860"><code></code></span>
<span class="codeline" id="line-3861"><code>	// Safety check: if we are spinning, the run queue should be empty.</code></span>
<span class="codeline" id="line-3862"><code>	// Check this before calling checkTimers, as that might call</code></span>
<span class="codeline" id="line-3863"><code>	// goready to put a ready goroutine on the local run queue.</code></span>
<span class="codeline" id="line-3864"><code>	if mp.spinning &amp;&amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) {</code></span>
<span class="codeline" id="line-3865"><code>		throw("schedule: spinning with local work")</code></span>
<span class="codeline" id="line-3866"><code>	}</code></span>
<span class="codeline" id="line-3867"><code></code></span>
<span class="codeline" id="line-3868"><code>	gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available</code></span>
<span class="codeline" id="line-3869"><code></code></span>
<span class="codeline" id="line-3870"><code>	if debug.dontfreezetheworld &gt; 0 &amp;&amp; freezing.Load() {</code></span>
<span class="codeline" id="line-3871"><code>		// See comment in freezetheworld. We don't want to perturb</code></span>
<span class="codeline" id="line-3872"><code>		// scheduler state, so we didn't gcstopm in findRunnable, but</code></span>
<span class="codeline" id="line-3873"><code>		// also don't want to allow new goroutines to run.</code></span>
<span class="codeline" id="line-3874"><code>		//</code></span>
<span class="codeline" id="line-3875"><code>		// Deadlock here rather than in the findRunnable loop so if</code></span>
<span class="codeline" id="line-3876"><code>		// findRunnable is stuck in a loop we don't perturb that</code></span>
<span class="codeline" id="line-3877"><code>		// either.</code></span>
<span class="codeline" id="line-3878"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-3879"><code>		lock(&amp;deadlock)</code></span>
<span class="codeline" id="line-3880"><code>	}</code></span>
<span class="codeline" id="line-3881"><code></code></span>
<span class="codeline" id="line-3882"><code>	// This thread is going to run a goroutine and is not spinning anymore,</code></span>
<span class="codeline" id="line-3883"><code>	// so if it was marked as spinning we need to reset it now and potentially</code></span>
<span class="codeline" id="line-3884"><code>	// start a new spinning M.</code></span>
<span class="codeline" id="line-3885"><code>	if mp.spinning {</code></span>
<span class="codeline" id="line-3886"><code>		resetspinning()</code></span>
<span class="codeline" id="line-3887"><code>	}</code></span>
<span class="codeline" id="line-3888"><code></code></span>
<span class="codeline" id="line-3889"><code>	if sched.disable.user &amp;&amp; !schedEnabled(gp) {</code></span>
<span class="codeline" id="line-3890"><code>		// Scheduling of this goroutine is disabled. Put it on</code></span>
<span class="codeline" id="line-3891"><code>		// the list of pending runnable goroutines for when we</code></span>
<span class="codeline" id="line-3892"><code>		// re-enable user scheduling and look again.</code></span>
<span class="codeline" id="line-3893"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3894"><code>		if schedEnabled(gp) {</code></span>
<span class="codeline" id="line-3895"><code>			// Something re-enabled scheduling while we</code></span>
<span class="codeline" id="line-3896"><code>			// were acquiring the lock.</code></span>
<span class="codeline" id="line-3897"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3898"><code>		} else {</code></span>
<span class="codeline" id="line-3899"><code>			sched.disable.runnable.pushBack(gp)</code></span>
<span class="codeline" id="line-3900"><code>			sched.disable.n++</code></span>
<span class="codeline" id="line-3901"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-3902"><code>			goto top</code></span>
<span class="codeline" id="line-3903"><code>		}</code></span>
<span class="codeline" id="line-3904"><code>	}</code></span>
<span class="codeline" id="line-3905"><code></code></span>
<span class="codeline" id="line-3906"><code>	// If about to schedule a not-normal goroutine (a GCworker or tracereader),</code></span>
<span class="codeline" id="line-3907"><code>	// wake a P if there is one.</code></span>
<span class="codeline" id="line-3908"><code>	if tryWakeP {</code></span>
<span class="codeline" id="line-3909"><code>		wakep()</code></span>
<span class="codeline" id="line-3910"><code>	}</code></span>
<span class="codeline" id="line-3911"><code>	if gp.lockedm != 0 {</code></span>
<span class="codeline" id="line-3912"><code>		// Hands off own p to the locked m,</code></span>
<span class="codeline" id="line-3913"><code>		// then blocks waiting for a new p.</code></span>
<span class="codeline" id="line-3914"><code>		startlockedm(gp)</code></span>
<span class="codeline" id="line-3915"><code>		goto top</code></span>
<span class="codeline" id="line-3916"><code>	}</code></span>
<span class="codeline" id="line-3917"><code></code></span>
<span class="codeline" id="line-3918"><code>	execute(gp, inheritTime)</code></span>
<span class="codeline" id="line-3919"><code>}</code></span>
<span class="codeline" id="line-3920"><code></code></span>
<span class="codeline" id="line-3921"><code>// dropg removes the association between m and the current goroutine m-&gt;curg (gp for short).</code></span>
<span class="codeline" id="line-3922"><code>// Typically a caller sets gp's status away from Grunning and then</code></span>
<span class="codeline" id="line-3923"><code>// immediately calls dropg to finish the job. The caller is also responsible</code></span>
<span class="codeline" id="line-3924"><code>// for arranging that gp will be restarted using ready at an</code></span>
<span class="codeline" id="line-3925"><code>// appropriate time. After calling dropg and arranging for gp to be</code></span>
<span class="codeline" id="line-3926"><code>// readied later, the caller can do other work but eventually should</code></span>
<span class="codeline" id="line-3927"><code>// call schedule to restart the scheduling of goroutines on this m.</code></span>
<span class="codeline" id="line-3928"><code>func dropg() {</code></span>
<span class="codeline" id="line-3929"><code>	gp := getg()</code></span>
<span class="codeline" id="line-3930"><code></code></span>
<span class="codeline" id="line-3931"><code>	setMNoWB(&amp;gp.m.curg.m, nil)</code></span>
<span class="codeline" id="line-3932"><code>	setGNoWB(&amp;gp.m.curg, nil)</code></span>
<span class="codeline" id="line-3933"><code>}</code></span>
<span class="codeline" id="line-3934"><code></code></span>
<span class="codeline" id="line-3935"><code>// checkTimers runs any timers for the P that are ready.</code></span>
<span class="codeline" id="line-3936"><code>// If now is not 0 it is the current time.</code></span>
<span class="codeline" id="line-3937"><code>// It returns the passed time or the current time if now was passed as 0.</code></span>
<span class="codeline" id="line-3938"><code>// and the time when the next timer should run or 0 if there is no next timer,</code></span>
<span class="codeline" id="line-3939"><code>// and reports whether it ran any timers.</code></span>
<span class="codeline" id="line-3940"><code>// If the time when the next timer should run is not 0,</code></span>
<span class="codeline" id="line-3941"><code>// it is always larger than the returned time.</code></span>
<span class="codeline" id="line-3942"><code>// We pass now in and out to avoid extra calls of nanotime.</code></span>
<span class="codeline" id="line-3943"><code>//</code></span>
<span class="codeline" id="line-3944"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-3945"><code>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {</code></span>
<span class="codeline" id="line-3946"><code>	// If it's not yet time for the first timer, or the first adjusted</code></span>
<span class="codeline" id="line-3947"><code>	// timer, then there is nothing to do.</code></span>
<span class="codeline" id="line-3948"><code>	next := pp.timer0When.Load()</code></span>
<span class="codeline" id="line-3949"><code>	nextAdj := pp.timerModifiedEarliest.Load()</code></span>
<span class="codeline" id="line-3950"><code>	if next == 0 || (nextAdj != 0 &amp;&amp; nextAdj &lt; next) {</code></span>
<span class="codeline" id="line-3951"><code>		next = nextAdj</code></span>
<span class="codeline" id="line-3952"><code>	}</code></span>
<span class="codeline" id="line-3953"><code></code></span>
<span class="codeline" id="line-3954"><code>	if next == 0 {</code></span>
<span class="codeline" id="line-3955"><code>		// No timers to run or adjust.</code></span>
<span class="codeline" id="line-3956"><code>		return now, 0, false</code></span>
<span class="codeline" id="line-3957"><code>	}</code></span>
<span class="codeline" id="line-3958"><code></code></span>
<span class="codeline" id="line-3959"><code>	if now == 0 {</code></span>
<span class="codeline" id="line-3960"><code>		now = nanotime()</code></span>
<span class="codeline" id="line-3961"><code>	}</code></span>
<span class="codeline" id="line-3962"><code>	if now &lt; next {</code></span>
<span class="codeline" id="line-3963"><code>		// Next timer is not ready to run, but keep going</code></span>
<span class="codeline" id="line-3964"><code>		// if we would clear deleted timers.</code></span>
<span class="codeline" id="line-3965"><code>		// This corresponds to the condition below where</code></span>
<span class="codeline" id="line-3966"><code>		// we decide whether to call clearDeletedTimers.</code></span>
<span class="codeline" id="line-3967"><code>		if pp != getg().m.p.ptr() || int(pp.deletedTimers.Load()) &lt;= int(pp.numTimers.Load()/4) {</code></span>
<span class="codeline" id="line-3968"><code>			return now, next, false</code></span>
<span class="codeline" id="line-3969"><code>		}</code></span>
<span class="codeline" id="line-3970"><code>	}</code></span>
<span class="codeline" id="line-3971"><code></code></span>
<span class="codeline" id="line-3972"><code>	lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-3973"><code></code></span>
<span class="codeline" id="line-3974"><code>	if len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-3975"><code>		adjusttimers(pp, now)</code></span>
<span class="codeline" id="line-3976"><code>		for len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-3977"><code>			// Note that runtimer may temporarily unlock</code></span>
<span class="codeline" id="line-3978"><code>			// pp.timersLock.</code></span>
<span class="codeline" id="line-3979"><code>			if tw := runtimer(pp, now); tw != 0 {</code></span>
<span class="codeline" id="line-3980"><code>				if tw &gt; 0 {</code></span>
<span class="codeline" id="line-3981"><code>					pollUntil = tw</code></span>
<span class="codeline" id="line-3982"><code>				}</code></span>
<span class="codeline" id="line-3983"><code>				break</code></span>
<span class="codeline" id="line-3984"><code>			}</code></span>
<span class="codeline" id="line-3985"><code>			ran = true</code></span>
<span class="codeline" id="line-3986"><code>		}</code></span>
<span class="codeline" id="line-3987"><code>	}</code></span>
<span class="codeline" id="line-3988"><code></code></span>
<span class="codeline" id="line-3989"><code>	// If this is the local P, and there are a lot of deleted timers,</code></span>
<span class="codeline" id="line-3990"><code>	// clear them out. We only do this for the local P to reduce</code></span>
<span class="codeline" id="line-3991"><code>	// lock contention on timersLock.</code></span>
<span class="codeline" id="line-3992"><code>	if pp == getg().m.p.ptr() &amp;&amp; int(pp.deletedTimers.Load()) &gt; len(pp.timers)/4 {</code></span>
<span class="codeline" id="line-3993"><code>		clearDeletedTimers(pp)</code></span>
<span class="codeline" id="line-3994"><code>	}</code></span>
<span class="codeline" id="line-3995"><code></code></span>
<span class="codeline" id="line-3996"><code>	unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-3997"><code></code></span>
<span class="codeline" id="line-3998"><code>	return now, pollUntil, ran</code></span>
<span class="codeline" id="line-3999"><code>}</code></span>
<span class="codeline" id="line-4000"><code></code></span>
<span class="codeline" id="line-4001"><code>func parkunlock_c(gp *g, lock unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-4002"><code>	unlock((*mutex)(lock))</code></span>
<span class="codeline" id="line-4003"><code>	return true</code></span>
<span class="codeline" id="line-4004"><code>}</code></span>
<span class="codeline" id="line-4005"><code></code></span>
<span class="codeline" id="line-4006"><code>// park continuation on g0.</code></span>
<span class="codeline" id="line-4007"><code>func park_m(gp *g) {</code></span>
<span class="codeline" id="line-4008"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-4009"><code></code></span>
<span class="codeline" id="line-4010"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4011"><code></code></span>
<span class="codeline" id="line-4012"><code>	// N.B. Not using casGToWaiting here because the waitreason is</code></span>
<span class="codeline" id="line-4013"><code>	// set by park_m's caller.</code></span>
<span class="codeline" id="line-4014"><code>	casgstatus(gp, _Grunning, _Gwaiting)</code></span>
<span class="codeline" id="line-4015"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4016"><code>		trace.GoPark(mp.waitTraceBlockReason, mp.waitTraceSkip)</code></span>
<span class="codeline" id="line-4017"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4018"><code>	}</code></span>
<span class="codeline" id="line-4019"><code></code></span>
<span class="codeline" id="line-4020"><code>	dropg()</code></span>
<span class="codeline" id="line-4021"><code></code></span>
<span class="codeline" id="line-4022"><code>	if fn := mp.waitunlockf; fn != nil {</code></span>
<span class="codeline" id="line-4023"><code>		ok := fn(gp, mp.waitlock)</code></span>
<span class="codeline" id="line-4024"><code>		mp.waitunlockf = nil</code></span>
<span class="codeline" id="line-4025"><code>		mp.waitlock = nil</code></span>
<span class="codeline" id="line-4026"><code>		if !ok {</code></span>
<span class="codeline" id="line-4027"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-4028"><code>			casgstatus(gp, _Gwaiting, _Grunnable)</code></span>
<span class="codeline" id="line-4029"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-4030"><code>				trace.GoUnpark(gp, 2)</code></span>
<span class="codeline" id="line-4031"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-4032"><code>			}</code></span>
<span class="codeline" id="line-4033"><code>			execute(gp, true) // Schedule it back, never returns.</code></span>
<span class="codeline" id="line-4034"><code>		}</code></span>
<span class="codeline" id="line-4035"><code>	}</code></span>
<span class="codeline" id="line-4036"><code>	schedule()</code></span>
<span class="codeline" id="line-4037"><code>}</code></span>
<span class="codeline" id="line-4038"><code></code></span>
<span class="codeline" id="line-4039"><code>func goschedImpl(gp *g, preempted bool) {</code></span>
<span class="codeline" id="line-4040"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4041"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-4042"><code>	if status&amp;^_Gscan != _Grunning {</code></span>
<span class="codeline" id="line-4043"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-4044"><code>		throw("bad g status")</code></span>
<span class="codeline" id="line-4045"><code>	}</code></span>
<span class="codeline" id="line-4046"><code>	casgstatus(gp, _Grunning, _Grunnable)</code></span>
<span class="codeline" id="line-4047"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4048"><code>		if preempted {</code></span>
<span class="codeline" id="line-4049"><code>			trace.GoPreempt()</code></span>
<span class="codeline" id="line-4050"><code>		} else {</code></span>
<span class="codeline" id="line-4051"><code>			trace.GoSched()</code></span>
<span class="codeline" id="line-4052"><code>		}</code></span>
<span class="codeline" id="line-4053"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4054"><code>	}</code></span>
<span class="codeline" id="line-4055"><code></code></span>
<span class="codeline" id="line-4056"><code>	dropg()</code></span>
<span class="codeline" id="line-4057"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4058"><code>	globrunqput(gp)</code></span>
<span class="codeline" id="line-4059"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4060"><code></code></span>
<span class="codeline" id="line-4061"><code>	if mainStarted {</code></span>
<span class="codeline" id="line-4062"><code>		wakep()</code></span>
<span class="codeline" id="line-4063"><code>	}</code></span>
<span class="codeline" id="line-4064"><code></code></span>
<span class="codeline" id="line-4065"><code>	schedule()</code></span>
<span class="codeline" id="line-4066"><code>}</code></span>
<span class="codeline" id="line-4067"><code></code></span>
<span class="codeline" id="line-4068"><code>// Gosched continuation on g0.</code></span>
<span class="codeline" id="line-4069"><code>func gosched_m(gp *g) {</code></span>
<span class="codeline" id="line-4070"><code>	goschedImpl(gp, false)</code></span>
<span class="codeline" id="line-4071"><code>}</code></span>
<span class="codeline" id="line-4072"><code></code></span>
<span class="codeline" id="line-4073"><code>// goschedguarded is a forbidden-states-avoided version of gosched_m.</code></span>
<span class="codeline" id="line-4074"><code>func goschedguarded_m(gp *g) {</code></span>
<span class="codeline" id="line-4075"><code>	if !canPreemptM(gp.m) {</code></span>
<span class="codeline" id="line-4076"><code>		gogo(&amp;gp.sched) // never return</code></span>
<span class="codeline" id="line-4077"><code>	}</code></span>
<span class="codeline" id="line-4078"><code>	goschedImpl(gp, false)</code></span>
<span class="codeline" id="line-4079"><code>}</code></span>
<span class="codeline" id="line-4080"><code></code></span>
<span class="codeline" id="line-4081"><code>func gopreempt_m(gp *g) {</code></span>
<span class="codeline" id="line-4082"><code>	goschedImpl(gp, true)</code></span>
<span class="codeline" id="line-4083"><code>}</code></span>
<span class="codeline" id="line-4084"><code></code></span>
<span class="codeline" id="line-4085"><code>// preemptPark parks gp and puts it in _Gpreempted.</code></span>
<span class="codeline" id="line-4086"><code>//</code></span>
<span class="codeline" id="line-4087"><code>//go:systemstack</code></span>
<span class="codeline" id="line-4088"><code>func preemptPark(gp *g) {</code></span>
<span class="codeline" id="line-4089"><code>	status := readgstatus(gp)</code></span>
<span class="codeline" id="line-4090"><code>	if status&amp;^_Gscan != _Grunning {</code></span>
<span class="codeline" id="line-4091"><code>		dumpgstatus(gp)</code></span>
<span class="codeline" id="line-4092"><code>		throw("bad g status")</code></span>
<span class="codeline" id="line-4093"><code>	}</code></span>
<span class="codeline" id="line-4094"><code></code></span>
<span class="codeline" id="line-4095"><code>	if gp.asyncSafePoint {</code></span>
<span class="codeline" id="line-4096"><code>		// Double-check that async preemption does not</code></span>
<span class="codeline" id="line-4097"><code>		// happen in SPWRITE assembly functions.</code></span>
<span class="codeline" id="line-4098"><code>		// isAsyncSafePoint must exclude this case.</code></span>
<span class="codeline" id="line-4099"><code>		f := findfunc(gp.sched.pc)</code></span>
<span class="codeline" id="line-4100"><code>		if !f.valid() {</code></span>
<span class="codeline" id="line-4101"><code>			throw("preempt at unknown pc")</code></span>
<span class="codeline" id="line-4102"><code>		}</code></span>
<span class="codeline" id="line-4103"><code>		if f.flag&amp;abi.FuncFlagSPWrite != 0 {</code></span>
<span class="codeline" id="line-4104"><code>			println("runtime: unexpected SPWRITE function", funcname(f), "in async preempt")</code></span>
<span class="codeline" id="line-4105"><code>			throw("preempt SPWRITE")</code></span>
<span class="codeline" id="line-4106"><code>		}</code></span>
<span class="codeline" id="line-4107"><code>	}</code></span>
<span class="codeline" id="line-4108"><code></code></span>
<span class="codeline" id="line-4109"><code>	// Transition from _Grunning to _Gscan|_Gpreempted. We can't</code></span>
<span class="codeline" id="line-4110"><code>	// be in _Grunning when we dropg because then we'd be running</code></span>
<span class="codeline" id="line-4111"><code>	// without an M, but the moment we're in _Gpreempted,</code></span>
<span class="codeline" id="line-4112"><code>	// something could claim this G before we've fully cleaned it</code></span>
<span class="codeline" id="line-4113"><code>	// up. Hence, we set the scan bit to lock down further</code></span>
<span class="codeline" id="line-4114"><code>	// transitions until we can dropg.</code></span>
<span class="codeline" id="line-4115"><code>	casGToPreemptScan(gp, _Grunning, _Gscan|_Gpreempted)</code></span>
<span class="codeline" id="line-4116"><code>	dropg()</code></span>
<span class="codeline" id="line-4117"><code></code></span>
<span class="codeline" id="line-4118"><code>	// Be careful about how we trace this next event. The ordering</code></span>
<span class="codeline" id="line-4119"><code>	// is subtle.</code></span>
<span class="codeline" id="line-4120"><code>	//</code></span>
<span class="codeline" id="line-4121"><code>	// The moment we CAS into _Gpreempted, suspendG could CAS to</code></span>
<span class="codeline" id="line-4122"><code>	// _Gwaiting, do its work, and ready the goroutine. All of</code></span>
<span class="codeline" id="line-4123"><code>	// this could happen before we even get the chance to emit</code></span>
<span class="codeline" id="line-4124"><code>	// an event. The end result is that the events could appear</code></span>
<span class="codeline" id="line-4125"><code>	// out of order, and the tracer generally assumes the scheduler</code></span>
<span class="codeline" id="line-4126"><code>	// takes care of the ordering between GoPark and GoUnpark.</code></span>
<span class="codeline" id="line-4127"><code>	//</code></span>
<span class="codeline" id="line-4128"><code>	// The answer here is simple: emit the event while we still hold</code></span>
<span class="codeline" id="line-4129"><code>	// the _Gscan bit on the goroutine. We still need to traceAcquire</code></span>
<span class="codeline" id="line-4130"><code>	// and traceRelease across the CAS because the tracer could be</code></span>
<span class="codeline" id="line-4131"><code>	// what's calling suspendG in the first place, and we want the</code></span>
<span class="codeline" id="line-4132"><code>	// CAS and event emission to appear atomic to the tracer.</code></span>
<span class="codeline" id="line-4133"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4134"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4135"><code>		trace.GoPark(traceBlockPreempted, 0)</code></span>
<span class="codeline" id="line-4136"><code>	}</code></span>
<span class="codeline" id="line-4137"><code>	casfrom_Gscanstatus(gp, _Gscan|_Gpreempted, _Gpreempted)</code></span>
<span class="codeline" id="line-4138"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4139"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4140"><code>	}</code></span>
<span class="codeline" id="line-4141"><code>	schedule()</code></span>
<span class="codeline" id="line-4142"><code>}</code></span>
<span class="codeline" id="line-4143"><code></code></span>
<span class="codeline" id="line-4144"><code>// goyield is like Gosched, but it:</code></span>
<span class="codeline" id="line-4145"><code>// - emits a GoPreempt trace event instead of a GoSched trace event</code></span>
<span class="codeline" id="line-4146"><code>// - puts the current G on the runq of the current P instead of the globrunq</code></span>
<span class="codeline" id="line-4147"><code>func goyield() {</code></span>
<span class="codeline" id="line-4148"><code>	checkTimeouts()</code></span>
<span class="codeline" id="line-4149"><code>	mcall(goyield_m)</code></span>
<span class="codeline" id="line-4150"><code>}</code></span>
<span class="codeline" id="line-4151"><code></code></span>
<span class="codeline" id="line-4152"><code>func goyield_m(gp *g) {</code></span>
<span class="codeline" id="line-4153"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4154"><code>	pp := gp.m.p.ptr()</code></span>
<span class="codeline" id="line-4155"><code>	casgstatus(gp, _Grunning, _Grunnable)</code></span>
<span class="codeline" id="line-4156"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4157"><code>		trace.GoPreempt()</code></span>
<span class="codeline" id="line-4158"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4159"><code>	}</code></span>
<span class="codeline" id="line-4160"><code>	dropg()</code></span>
<span class="codeline" id="line-4161"><code>	runqput(pp, gp, false)</code></span>
<span class="codeline" id="line-4162"><code>	schedule()</code></span>
<span class="codeline" id="line-4163"><code>}</code></span>
<span class="codeline" id="line-4164"><code></code></span>
<span class="codeline" id="line-4165"><code>// Finishes execution of the current goroutine.</code></span>
<span class="codeline" id="line-4166"><code>func goexit1() {</code></span>
<span class="codeline" id="line-4167"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-4168"><code>		racegoend()</code></span>
<span class="codeline" id="line-4169"><code>	}</code></span>
<span class="codeline" id="line-4170"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4171"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4172"><code>		trace.GoEnd()</code></span>
<span class="codeline" id="line-4173"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4174"><code>	}</code></span>
<span class="codeline" id="line-4175"><code>	mcall(goexit0)</code></span>
<span class="codeline" id="line-4176"><code>}</code></span>
<span class="codeline" id="line-4177"><code></code></span>
<span class="codeline" id="line-4178"><code>// goexit continuation on g0.</code></span>
<span class="codeline" id="line-4179"><code>func goexit0(gp *g) {</code></span>
<span class="codeline" id="line-4180"><code>	gdestroy(gp)</code></span>
<span class="codeline" id="line-4181"><code>	schedule()</code></span>
<span class="codeline" id="line-4182"><code>}</code></span>
<span class="codeline" id="line-4183"><code></code></span>
<span class="codeline" id="line-4184"><code>func gdestroy(gp *g) {</code></span>
<span class="codeline" id="line-4185"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-4186"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-4187"><code></code></span>
<span class="codeline" id="line-4188"><code>	casgstatus(gp, _Grunning, _Gdead)</code></span>
<span class="codeline" id="line-4189"><code>	gcController.addScannableStack(pp, -int64(gp.stack.hi-gp.stack.lo))</code></span>
<span class="codeline" id="line-4190"><code>	if isSystemGoroutine(gp, false) {</code></span>
<span class="codeline" id="line-4191"><code>		sched.ngsys.Add(-1)</code></span>
<span class="codeline" id="line-4192"><code>	}</code></span>
<span class="codeline" id="line-4193"><code>	gp.m = nil</code></span>
<span class="codeline" id="line-4194"><code>	locked := gp.lockedm != 0</code></span>
<span class="codeline" id="line-4195"><code>	gp.lockedm = 0</code></span>
<span class="codeline" id="line-4196"><code>	mp.lockedg = 0</code></span>
<span class="codeline" id="line-4197"><code>	gp.preemptStop = false</code></span>
<span class="codeline" id="line-4198"><code>	gp.paniconfault = false</code></span>
<span class="codeline" id="line-4199"><code>	gp._defer = nil // should be true already but just in case.</code></span>
<span class="codeline" id="line-4200"><code>	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.</code></span>
<span class="codeline" id="line-4201"><code>	gp.writebuf = nil</code></span>
<span class="codeline" id="line-4202"><code>	gp.waitreason = waitReasonZero</code></span>
<span class="codeline" id="line-4203"><code>	gp.param = nil</code></span>
<span class="codeline" id="line-4204"><code>	gp.labels = nil</code></span>
<span class="codeline" id="line-4205"><code>	gp.timer = nil</code></span>
<span class="codeline" id="line-4206"><code></code></span>
<span class="codeline" id="line-4207"><code>	if gcBlackenEnabled != 0 &amp;&amp; gp.gcAssistBytes &gt; 0 {</code></span>
<span class="codeline" id="line-4208"><code>		// Flush assist credit to the global pool. This gives</code></span>
<span class="codeline" id="line-4209"><code>		// better information to pacing if the application is</code></span>
<span class="codeline" id="line-4210"><code>		// rapidly creating an exiting goroutines.</code></span>
<span class="codeline" id="line-4211"><code>		assistWorkPerByte := gcController.assistWorkPerByte.Load()</code></span>
<span class="codeline" id="line-4212"><code>		scanCredit := int64(assistWorkPerByte * float64(gp.gcAssistBytes))</code></span>
<span class="codeline" id="line-4213"><code>		gcController.bgScanCredit.Add(scanCredit)</code></span>
<span class="codeline" id="line-4214"><code>		gp.gcAssistBytes = 0</code></span>
<span class="codeline" id="line-4215"><code>	}</code></span>
<span class="codeline" id="line-4216"><code></code></span>
<span class="codeline" id="line-4217"><code>	dropg()</code></span>
<span class="codeline" id="line-4218"><code></code></span>
<span class="codeline" id="line-4219"><code>	if GOARCH == "wasm" { // no threads yet on wasm</code></span>
<span class="codeline" id="line-4220"><code>		gfput(pp, gp)</code></span>
<span class="codeline" id="line-4221"><code>		return</code></span>
<span class="codeline" id="line-4222"><code>	}</code></span>
<span class="codeline" id="line-4223"><code></code></span>
<span class="codeline" id="line-4224"><code>	if mp.lockedInt != 0 {</code></span>
<span class="codeline" id="line-4225"><code>		print("invalid m-&gt;lockedInt = ", mp.lockedInt, "\n")</code></span>
<span class="codeline" id="line-4226"><code>		throw("internal lockOSThread error")</code></span>
<span class="codeline" id="line-4227"><code>	}</code></span>
<span class="codeline" id="line-4228"><code>	gfput(pp, gp)</code></span>
<span class="codeline" id="line-4229"><code>	if locked {</code></span>
<span class="codeline" id="line-4230"><code>		// The goroutine may have locked this thread because</code></span>
<span class="codeline" id="line-4231"><code>		// it put it in an unusual kernel state. Kill it</code></span>
<span class="codeline" id="line-4232"><code>		// rather than returning it to the thread pool.</code></span>
<span class="codeline" id="line-4233"><code></code></span>
<span class="codeline" id="line-4234"><code>		// Return to mstart, which will release the P and exit</code></span>
<span class="codeline" id="line-4235"><code>		// the thread.</code></span>
<span class="codeline" id="line-4236"><code>		if GOOS != "plan9" { // See golang.org/issue/22227.</code></span>
<span class="codeline" id="line-4237"><code>			gogo(&amp;mp.g0.sched)</code></span>
<span class="codeline" id="line-4238"><code>		} else {</code></span>
<span class="codeline" id="line-4239"><code>			// Clear lockedExt on plan9 since we may end up re-using</code></span>
<span class="codeline" id="line-4240"><code>			// this thread.</code></span>
<span class="codeline" id="line-4241"><code>			mp.lockedExt = 0</code></span>
<span class="codeline" id="line-4242"><code>		}</code></span>
<span class="codeline" id="line-4243"><code>	}</code></span>
<span class="codeline" id="line-4244"><code>}</code></span>
<span class="codeline" id="line-4245"><code></code></span>
<span class="codeline" id="line-4246"><code>// save updates getg().sched to refer to pc and sp so that a following</code></span>
<span class="codeline" id="line-4247"><code>// gogo will restore pc and sp.</code></span>
<span class="codeline" id="line-4248"><code>//</code></span>
<span class="codeline" id="line-4249"><code>// save must not have write barriers because invoking a write barrier</code></span>
<span class="codeline" id="line-4250"><code>// can clobber getg().sched.</code></span>
<span class="codeline" id="line-4251"><code>//</code></span>
<span class="codeline" id="line-4252"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4253"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4254"><code>func save(pc, sp uintptr) {</code></span>
<span class="codeline" id="line-4255"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4256"><code></code></span>
<span class="codeline" id="line-4257"><code>	if gp == gp.m.g0 || gp == gp.m.gsignal {</code></span>
<span class="codeline" id="line-4258"><code>		// m.g0.sched is special and must describe the context</code></span>
<span class="codeline" id="line-4259"><code>		// for exiting the thread. mstart1 writes to it directly.</code></span>
<span class="codeline" id="line-4260"><code>		// m.gsignal.sched should not be used at all.</code></span>
<span class="codeline" id="line-4261"><code>		// This check makes sure save calls do not accidentally</code></span>
<span class="codeline" id="line-4262"><code>		// run in contexts where they'd write to system g's.</code></span>
<span class="codeline" id="line-4263"><code>		throw("save on system g not allowed")</code></span>
<span class="codeline" id="line-4264"><code>	}</code></span>
<span class="codeline" id="line-4265"><code></code></span>
<span class="codeline" id="line-4266"><code>	gp.sched.pc = pc</code></span>
<span class="codeline" id="line-4267"><code>	gp.sched.sp = sp</code></span>
<span class="codeline" id="line-4268"><code>	gp.sched.lr = 0</code></span>
<span class="codeline" id="line-4269"><code>	gp.sched.ret = 0</code></span>
<span class="codeline" id="line-4270"><code>	// We need to ensure ctxt is zero, but can't have a write</code></span>
<span class="codeline" id="line-4271"><code>	// barrier here. However, it should always already be zero.</code></span>
<span class="codeline" id="line-4272"><code>	// Assert that.</code></span>
<span class="codeline" id="line-4273"><code>	if gp.sched.ctxt != nil {</code></span>
<span class="codeline" id="line-4274"><code>		badctxt()</code></span>
<span class="codeline" id="line-4275"><code>	}</code></span>
<span class="codeline" id="line-4276"><code>}</code></span>
<span class="codeline" id="line-4277"><code></code></span>
<span class="codeline" id="line-4278"><code>// The goroutine g is about to enter a system call.</code></span>
<span class="codeline" id="line-4279"><code>// Record that it's not using the cpu anymore.</code></span>
<span class="codeline" id="line-4280"><code>// This is called only from the go syscall library and cgocall,</code></span>
<span class="codeline" id="line-4281"><code>// not from the low-level system calls used by the runtime.</code></span>
<span class="codeline" id="line-4282"><code>//</code></span>
<span class="codeline" id="line-4283"><code>// Entersyscall cannot split the stack: the save must</code></span>
<span class="codeline" id="line-4284"><code>// make g-&gt;sched refer to the caller's stack segment, because</code></span>
<span class="codeline" id="line-4285"><code>// entersyscall is going to return immediately after.</code></span>
<span class="codeline" id="line-4286"><code>//</code></span>
<span class="codeline" id="line-4287"><code>// Nothing entersyscall calls can split the stack either.</code></span>
<span class="codeline" id="line-4288"><code>// We cannot safely move the stack during an active call to syscall,</code></span>
<span class="codeline" id="line-4289"><code>// because we do not know which of the uintptr arguments are</code></span>
<span class="codeline" id="line-4290"><code>// really pointers (back into the stack).</code></span>
<span class="codeline" id="line-4291"><code>// In practice, this means that we make the fast path run through</code></span>
<span class="codeline" id="line-4292"><code>// entersyscall doing no-split things, and the slow path has to use systemstack</code></span>
<span class="codeline" id="line-4293"><code>// to run bigger things on the system stack.</code></span>
<span class="codeline" id="line-4294"><code>//</code></span>
<span class="codeline" id="line-4295"><code>// reentersyscall is the entry point used by cgo callbacks, where explicitly</code></span>
<span class="codeline" id="line-4296"><code>// saved SP and PC are restored. This is needed when exitsyscall will be called</code></span>
<span class="codeline" id="line-4297"><code>// from a function further up in the call stack than the parent, as g-&gt;syscallsp</code></span>
<span class="codeline" id="line-4298"><code>// must always point to a valid stack frame. entersyscall below is the normal</code></span>
<span class="codeline" id="line-4299"><code>// entry point for syscalls, which obtains the SP and PC from the caller.</code></span>
<span class="codeline" id="line-4300"><code>//</code></span>
<span class="codeline" id="line-4301"><code>// Syscall tracing (old tracer):</code></span>
<span class="codeline" id="line-4302"><code>// At the start of a syscall we emit traceGoSysCall to capture the stack trace.</code></span>
<span class="codeline" id="line-4303"><code>// If the syscall does not block, that is it, we do not emit any other events.</code></span>
<span class="codeline" id="line-4304"><code>// If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock;</code></span>
<span class="codeline" id="line-4305"><code>// when syscall returns we emit traceGoSysExit and when the goroutine starts running</code></span>
<span class="codeline" id="line-4306"><code>// (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart.</code></span>
<span class="codeline" id="line-4307"><code>// To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock,</code></span>
<span class="codeline" id="line-4308"><code>// we remember current value of syscalltick in m (gp.m.syscalltick = gp.m.p.ptr().syscalltick),</code></span>
<span class="codeline" id="line-4309"><code>// whoever emits traceGoSysBlock increments p.syscalltick afterwards;</code></span>
<span class="codeline" id="line-4310"><code>// and we wait for the increment before emitting traceGoSysExit.</code></span>
<span class="codeline" id="line-4311"><code>// Note that the increment is done even if tracing is not enabled,</code></span>
<span class="codeline" id="line-4312"><code>// because tracing can be enabled in the middle of syscall. We don't want the wait to hang.</code></span>
<span class="codeline" id="line-4313"><code>//</code></span>
<span class="codeline" id="line-4314"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4315"><code>func reentersyscall(pc, sp uintptr) {</code></span>
<span class="codeline" id="line-4316"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4317"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4318"><code></code></span>
<span class="codeline" id="line-4319"><code>	// Disable preemption because during this function g is in Gsyscall status,</code></span>
<span class="codeline" id="line-4320"><code>	// but can have inconsistent g-&gt;sched, do not let GC observe it.</code></span>
<span class="codeline" id="line-4321"><code>	gp.m.locks++</code></span>
<span class="codeline" id="line-4322"><code></code></span>
<span class="codeline" id="line-4323"><code>	// Entersyscall must not call any function that might split/grow the stack.</code></span>
<span class="codeline" id="line-4324"><code>	// (See details in comment above.)</code></span>
<span class="codeline" id="line-4325"><code>	// Catch calls that might, by replacing the stack guard with something that</code></span>
<span class="codeline" id="line-4326"><code>	// will trip any stack check and leaving a flag to tell newstack to die.</code></span>
<span class="codeline" id="line-4327"><code>	gp.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-4328"><code>	gp.throwsplit = true</code></span>
<span class="codeline" id="line-4329"><code></code></span>
<span class="codeline" id="line-4330"><code>	// Leave SP around for GC and traceback.</code></span>
<span class="codeline" id="line-4331"><code>	save(pc, sp)</code></span>
<span class="codeline" id="line-4332"><code>	gp.syscallsp = sp</code></span>
<span class="codeline" id="line-4333"><code>	gp.syscallpc = pc</code></span>
<span class="codeline" id="line-4334"><code>	casgstatus(gp, _Grunning, _Gsyscall)</code></span>
<span class="codeline" id="line-4335"><code>	if staticLockRanking {</code></span>
<span class="codeline" id="line-4336"><code>		// When doing static lock ranking casgstatus can call</code></span>
<span class="codeline" id="line-4337"><code>		// systemstack which clobbers g.sched.</code></span>
<span class="codeline" id="line-4338"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-4339"><code>	}</code></span>
<span class="codeline" id="line-4340"><code>	if gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp {</code></span>
<span class="codeline" id="line-4341"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4342"><code>			print("entersyscall inconsistent ", hex(gp.syscallsp), " [", hex(gp.stack.lo), ",", hex(gp.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-4343"><code>			throw("entersyscall")</code></span>
<span class="codeline" id="line-4344"><code>		})</code></span>
<span class="codeline" id="line-4345"><code>	}</code></span>
<span class="codeline" id="line-4346"><code></code></span>
<span class="codeline" id="line-4347"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4348"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4349"><code>			trace.GoSysCall()</code></span>
<span class="codeline" id="line-4350"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4351"><code>		})</code></span>
<span class="codeline" id="line-4352"><code>		// systemstack itself clobbers g.sched.{pc,sp} and we might</code></span>
<span class="codeline" id="line-4353"><code>		// need them later when the G is genuinely blocked in a</code></span>
<span class="codeline" id="line-4354"><code>		// syscall</code></span>
<span class="codeline" id="line-4355"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-4356"><code>	}</code></span>
<span class="codeline" id="line-4357"><code></code></span>
<span class="codeline" id="line-4358"><code>	if sched.sysmonwait.Load() {</code></span>
<span class="codeline" id="line-4359"><code>		systemstack(entersyscall_sysmon)</code></span>
<span class="codeline" id="line-4360"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-4361"><code>	}</code></span>
<span class="codeline" id="line-4362"><code></code></span>
<span class="codeline" id="line-4363"><code>	if gp.m.p.ptr().runSafePointFn != 0 {</code></span>
<span class="codeline" id="line-4364"><code>		// runSafePointFn may stack split if run on this stack</code></span>
<span class="codeline" id="line-4365"><code>		systemstack(runSafePointFn)</code></span>
<span class="codeline" id="line-4366"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-4367"><code>	}</code></span>
<span class="codeline" id="line-4368"><code></code></span>
<span class="codeline" id="line-4369"><code>	gp.m.syscalltick = gp.m.p.ptr().syscalltick</code></span>
<span class="codeline" id="line-4370"><code>	pp := gp.m.p.ptr()</code></span>
<span class="codeline" id="line-4371"><code>	pp.m = 0</code></span>
<span class="codeline" id="line-4372"><code>	gp.m.oldp.set(pp)</code></span>
<span class="codeline" id="line-4373"><code>	gp.m.p = 0</code></span>
<span class="codeline" id="line-4374"><code>	atomic.Store(&amp;pp.status, _Psyscall)</code></span>
<span class="codeline" id="line-4375"><code>	if sched.gcwaiting.Load() {</code></span>
<span class="codeline" id="line-4376"><code>		systemstack(entersyscall_gcwait)</code></span>
<span class="codeline" id="line-4377"><code>		save(pc, sp)</code></span>
<span class="codeline" id="line-4378"><code>	}</code></span>
<span class="codeline" id="line-4379"><code></code></span>
<span class="codeline" id="line-4380"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-4381"><code>}</code></span>
<span class="codeline" id="line-4382"><code></code></span>
<span class="codeline" id="line-4383"><code>// Standard syscall entry used by the go syscall library and normal cgo calls.</code></span>
<span class="codeline" id="line-4384"><code>//</code></span>
<span class="codeline" id="line-4385"><code>// This is exported via linkname to assembly in the syscall package and x/sys.</code></span>
<span class="codeline" id="line-4386"><code>//</code></span>
<span class="codeline" id="line-4387"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4388"><code>//go:linkname entersyscall</code></span>
<span class="codeline" id="line-4389"><code>func entersyscall() {</code></span>
<span class="codeline" id="line-4390"><code>	reentersyscall(getcallerpc(), getcallersp())</code></span>
<span class="codeline" id="line-4391"><code>}</code></span>
<span class="codeline" id="line-4392"><code></code></span>
<span class="codeline" id="line-4393"><code>func entersyscall_sysmon() {</code></span>
<span class="codeline" id="line-4394"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4395"><code>	if sched.sysmonwait.Load() {</code></span>
<span class="codeline" id="line-4396"><code>		sched.sysmonwait.Store(false)</code></span>
<span class="codeline" id="line-4397"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-4398"><code>	}</code></span>
<span class="codeline" id="line-4399"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4400"><code>}</code></span>
<span class="codeline" id="line-4401"><code></code></span>
<span class="codeline" id="line-4402"><code>func entersyscall_gcwait() {</code></span>
<span class="codeline" id="line-4403"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4404"><code>	pp := gp.m.oldp.ptr()</code></span>
<span class="codeline" id="line-4405"><code></code></span>
<span class="codeline" id="line-4406"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4407"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4408"><code>	if sched.stopwait &gt; 0 &amp;&amp; atomic.Cas(&amp;pp.status, _Psyscall, _Pgcstop) {</code></span>
<span class="codeline" id="line-4409"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4410"><code>			if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4411"><code>				// This is a steal in the new tracer. While it's very likely</code></span>
<span class="codeline" id="line-4412"><code>				// that we were the ones to put this P into _Psyscall, between</code></span>
<span class="codeline" id="line-4413"><code>				// then and now it's totally possible it had been stolen and</code></span>
<span class="codeline" id="line-4414"><code>				// then put back into _Psyscall for us to acquire here. In such</code></span>
<span class="codeline" id="line-4415"><code>				// case ProcStop would be incorrect.</code></span>
<span class="codeline" id="line-4416"><code>				//</code></span>
<span class="codeline" id="line-4417"><code>				// TODO(mknyszek): Consider emitting a ProcStop instead when</code></span>
<span class="codeline" id="line-4418"><code>				// gp.m.syscalltick == pp.syscalltick, since then we know we never</code></span>
<span class="codeline" id="line-4419"><code>				// lost the P.</code></span>
<span class="codeline" id="line-4420"><code>				trace.ProcSteal(pp, true)</code></span>
<span class="codeline" id="line-4421"><code>			} else {</code></span>
<span class="codeline" id="line-4422"><code>				trace.GoSysBlock(pp)</code></span>
<span class="codeline" id="line-4423"><code>				trace.ProcStop(pp)</code></span>
<span class="codeline" id="line-4424"><code>			}</code></span>
<span class="codeline" id="line-4425"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4426"><code>		}</code></span>
<span class="codeline" id="line-4427"><code>		pp.syscalltick++</code></span>
<span class="codeline" id="line-4428"><code>		if sched.stopwait--; sched.stopwait == 0 {</code></span>
<span class="codeline" id="line-4429"><code>			notewakeup(&amp;sched.stopnote)</code></span>
<span class="codeline" id="line-4430"><code>		}</code></span>
<span class="codeline" id="line-4431"><code>	} else if trace.ok() {</code></span>
<span class="codeline" id="line-4432"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4433"><code>	}</code></span>
<span class="codeline" id="line-4434"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4435"><code>}</code></span>
<span class="codeline" id="line-4436"><code></code></span>
<span class="codeline" id="line-4437"><code>// The same as entersyscall(), but with a hint that the syscall is blocking.</code></span>
<span class="codeline" id="line-4438"><code>//</code></span>
<span class="codeline" id="line-4439"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4440"><code>func entersyscallblock() {</code></span>
<span class="codeline" id="line-4441"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4442"><code></code></span>
<span class="codeline" id="line-4443"><code>	gp.m.locks++ // see comment in entersyscall</code></span>
<span class="codeline" id="line-4444"><code>	gp.throwsplit = true</code></span>
<span class="codeline" id="line-4445"><code>	gp.stackguard0 = stackPreempt // see comment in entersyscall</code></span>
<span class="codeline" id="line-4446"><code>	gp.m.syscalltick = gp.m.p.ptr().syscalltick</code></span>
<span class="codeline" id="line-4447"><code>	gp.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-4448"><code></code></span>
<span class="codeline" id="line-4449"><code>	// Leave SP around for GC and traceback.</code></span>
<span class="codeline" id="line-4450"><code>	pc := getcallerpc()</code></span>
<span class="codeline" id="line-4451"><code>	sp := getcallersp()</code></span>
<span class="codeline" id="line-4452"><code>	save(pc, sp)</code></span>
<span class="codeline" id="line-4453"><code>	gp.syscallsp = gp.sched.sp</code></span>
<span class="codeline" id="line-4454"><code>	gp.syscallpc = gp.sched.pc</code></span>
<span class="codeline" id="line-4455"><code>	if gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp {</code></span>
<span class="codeline" id="line-4456"><code>		sp1 := sp</code></span>
<span class="codeline" id="line-4457"><code>		sp2 := gp.sched.sp</code></span>
<span class="codeline" id="line-4458"><code>		sp3 := gp.syscallsp</code></span>
<span class="codeline" id="line-4459"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4460"><code>			print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(gp.stack.lo), ",", hex(gp.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-4461"><code>			throw("entersyscallblock")</code></span>
<span class="codeline" id="line-4462"><code>		})</code></span>
<span class="codeline" id="line-4463"><code>	}</code></span>
<span class="codeline" id="line-4464"><code>	casgstatus(gp, _Grunning, _Gsyscall)</code></span>
<span class="codeline" id="line-4465"><code>	if gp.syscallsp &lt; gp.stack.lo || gp.stack.hi &lt; gp.syscallsp {</code></span>
<span class="codeline" id="line-4466"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4467"><code>			print("entersyscallblock inconsistent ", hex(sp), " ", hex(gp.sched.sp), " ", hex(gp.syscallsp), " [", hex(gp.stack.lo), ",", hex(gp.stack.hi), "]\n")</code></span>
<span class="codeline" id="line-4468"><code>			throw("entersyscallblock")</code></span>
<span class="codeline" id="line-4469"><code>		})</code></span>
<span class="codeline" id="line-4470"><code>	}</code></span>
<span class="codeline" id="line-4471"><code></code></span>
<span class="codeline" id="line-4472"><code>	systemstack(entersyscallblock_handoff)</code></span>
<span class="codeline" id="line-4473"><code></code></span>
<span class="codeline" id="line-4474"><code>	// Resave for traceback during blocked call.</code></span>
<span class="codeline" id="line-4475"><code>	save(getcallerpc(), getcallersp())</code></span>
<span class="codeline" id="line-4476"><code></code></span>
<span class="codeline" id="line-4477"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-4478"><code>}</code></span>
<span class="codeline" id="line-4479"><code></code></span>
<span class="codeline" id="line-4480"><code>func entersyscallblock_handoff() {</code></span>
<span class="codeline" id="line-4481"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4482"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4483"><code>		trace.GoSysCall()</code></span>
<span class="codeline" id="line-4484"><code>		trace.GoSysBlock(getg().m.p.ptr())</code></span>
<span class="codeline" id="line-4485"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4486"><code>	}</code></span>
<span class="codeline" id="line-4487"><code>	handoffp(releasep())</code></span>
<span class="codeline" id="line-4488"><code>}</code></span>
<span class="codeline" id="line-4489"><code></code></span>
<span class="codeline" id="line-4490"><code>// The goroutine g exited its system call.</code></span>
<span class="codeline" id="line-4491"><code>// Arrange for it to run on a cpu again.</code></span>
<span class="codeline" id="line-4492"><code>// This is called only from the go syscall library, not</code></span>
<span class="codeline" id="line-4493"><code>// from the low-level system calls used by the runtime.</code></span>
<span class="codeline" id="line-4494"><code>//</code></span>
<span class="codeline" id="line-4495"><code>// Write barriers are not allowed because our P may have been stolen.</code></span>
<span class="codeline" id="line-4496"><code>//</code></span>
<span class="codeline" id="line-4497"><code>// This is exported via linkname to assembly in the syscall package.</code></span>
<span class="codeline" id="line-4498"><code>//</code></span>
<span class="codeline" id="line-4499"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4500"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4501"><code>//go:linkname exitsyscall</code></span>
<span class="codeline" id="line-4502"><code>func exitsyscall() {</code></span>
<span class="codeline" id="line-4503"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4504"><code></code></span>
<span class="codeline" id="line-4505"><code>	gp.m.locks++ // see comment in entersyscall</code></span>
<span class="codeline" id="line-4506"><code>	if getcallersp() &gt; gp.syscallsp {</code></span>
<span class="codeline" id="line-4507"><code>		throw("exitsyscall: syscall frame is no longer valid")</code></span>
<span class="codeline" id="line-4508"><code>	}</code></span>
<span class="codeline" id="line-4509"><code></code></span>
<span class="codeline" id="line-4510"><code>	gp.waitsince = 0</code></span>
<span class="codeline" id="line-4511"><code>	oldp := gp.m.oldp.ptr()</code></span>
<span class="codeline" id="line-4512"><code>	gp.m.oldp = 0</code></span>
<span class="codeline" id="line-4513"><code>	if exitsyscallfast(oldp) {</code></span>
<span class="codeline" id="line-4514"><code>		// When exitsyscallfast returns success, we have a P so can now use</code></span>
<span class="codeline" id="line-4515"><code>		// write barriers</code></span>
<span class="codeline" id="line-4516"><code>		if goroutineProfile.active {</code></span>
<span class="codeline" id="line-4517"><code>			// Make sure that gp has had its stack written out to the goroutine</code></span>
<span class="codeline" id="line-4518"><code>			// profile, exactly as it was when the goroutine profiler first</code></span>
<span class="codeline" id="line-4519"><code>			// stopped the world.</code></span>
<span class="codeline" id="line-4520"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-4521"><code>				tryRecordGoroutineProfileWB(gp)</code></span>
<span class="codeline" id="line-4522"><code>			})</code></span>
<span class="codeline" id="line-4523"><code>		}</code></span>
<span class="codeline" id="line-4524"><code>		trace := traceAcquire()</code></span>
<span class="codeline" id="line-4525"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4526"><code>			lostP := oldp != gp.m.p.ptr() || gp.m.syscalltick != gp.m.p.ptr().syscalltick</code></span>
<span class="codeline" id="line-4527"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-4528"><code>				if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4529"><code>					// Write out syscall exit eagerly in the experiment.</code></span>
<span class="codeline" id="line-4530"><code>					//</code></span>
<span class="codeline" id="line-4531"><code>					// It's important that we write this *after* we know whether we</code></span>
<span class="codeline" id="line-4532"><code>					// lost our P or not (determined by exitsyscallfast).</code></span>
<span class="codeline" id="line-4533"><code>					trace.GoSysExit(lostP)</code></span>
<span class="codeline" id="line-4534"><code>				}</code></span>
<span class="codeline" id="line-4535"><code>				if lostP {</code></span>
<span class="codeline" id="line-4536"><code>					// We lost the P at some point, even though we got it back here.</code></span>
<span class="codeline" id="line-4537"><code>					// Trace that we're starting again, because there was a traceGoSysBlock</code></span>
<span class="codeline" id="line-4538"><code>					// call somewhere in exitsyscallfast (indicating that this goroutine</code></span>
<span class="codeline" id="line-4539"><code>					// had blocked) and we're about to start running again.</code></span>
<span class="codeline" id="line-4540"><code>					trace.GoStart()</code></span>
<span class="codeline" id="line-4541"><code>				}</code></span>
<span class="codeline" id="line-4542"><code>			})</code></span>
<span class="codeline" id="line-4543"><code>		}</code></span>
<span class="codeline" id="line-4544"><code>		// There's a cpu for us, so we can run.</code></span>
<span class="codeline" id="line-4545"><code>		gp.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-4546"><code>		// We need to cas the status and scan before resuming...</code></span>
<span class="codeline" id="line-4547"><code>		casgstatus(gp, _Gsyscall, _Grunning)</code></span>
<span class="codeline" id="line-4548"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4549"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4550"><code>		}</code></span>
<span class="codeline" id="line-4551"><code></code></span>
<span class="codeline" id="line-4552"><code>		// Garbage collector isn't running (since we are),</code></span>
<span class="codeline" id="line-4553"><code>		// so okay to clear syscallsp.</code></span>
<span class="codeline" id="line-4554"><code>		gp.syscallsp = 0</code></span>
<span class="codeline" id="line-4555"><code>		gp.m.locks--</code></span>
<span class="codeline" id="line-4556"><code>		if gp.preempt {</code></span>
<span class="codeline" id="line-4557"><code>			// restore the preemption request in case we've cleared it in newstack</code></span>
<span class="codeline" id="line-4558"><code>			gp.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-4559"><code>		} else {</code></span>
<span class="codeline" id="line-4560"><code>			// otherwise restore the real stackGuard, we've spoiled it in entersyscall/entersyscallblock</code></span>
<span class="codeline" id="line-4561"><code>			gp.stackguard0 = gp.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-4562"><code>		}</code></span>
<span class="codeline" id="line-4563"><code>		gp.throwsplit = false</code></span>
<span class="codeline" id="line-4564"><code></code></span>
<span class="codeline" id="line-4565"><code>		if sched.disable.user &amp;&amp; !schedEnabled(gp) {</code></span>
<span class="codeline" id="line-4566"><code>			// Scheduling of this goroutine is disabled.</code></span>
<span class="codeline" id="line-4567"><code>			Gosched()</code></span>
<span class="codeline" id="line-4568"><code>		}</code></span>
<span class="codeline" id="line-4569"><code></code></span>
<span class="codeline" id="line-4570"><code>		return</code></span>
<span class="codeline" id="line-4571"><code>	}</code></span>
<span class="codeline" id="line-4572"><code></code></span>
<span class="codeline" id="line-4573"><code>	if !goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4574"><code>		// In the old tracer, because we don't have a P we can't</code></span>
<span class="codeline" id="line-4575"><code>		// actually record the true time we exited the syscall.</code></span>
<span class="codeline" id="line-4576"><code>		// Record it.</code></span>
<span class="codeline" id="line-4577"><code>		trace := traceAcquire()</code></span>
<span class="codeline" id="line-4578"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4579"><code>			trace.RecordSyscallExitedTime(gp, oldp)</code></span>
<span class="codeline" id="line-4580"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4581"><code>		}</code></span>
<span class="codeline" id="line-4582"><code>	}</code></span>
<span class="codeline" id="line-4583"><code></code></span>
<span class="codeline" id="line-4584"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-4585"><code></code></span>
<span class="codeline" id="line-4586"><code>	// Call the scheduler.</code></span>
<span class="codeline" id="line-4587"><code>	mcall(exitsyscall0)</code></span>
<span class="codeline" id="line-4588"><code></code></span>
<span class="codeline" id="line-4589"><code>	// Scheduler returned, so we're allowed to run now.</code></span>
<span class="codeline" id="line-4590"><code>	// Delete the syscallsp information that we left for</code></span>
<span class="codeline" id="line-4591"><code>	// the garbage collector during the system call.</code></span>
<span class="codeline" id="line-4592"><code>	// Must wait until now because until gosched returns</code></span>
<span class="codeline" id="line-4593"><code>	// we don't know for sure that the garbage collector</code></span>
<span class="codeline" id="line-4594"><code>	// is not running.</code></span>
<span class="codeline" id="line-4595"><code>	gp.syscallsp = 0</code></span>
<span class="codeline" id="line-4596"><code>	gp.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-4597"><code>	gp.throwsplit = false</code></span>
<span class="codeline" id="line-4598"><code>}</code></span>
<span class="codeline" id="line-4599"><code></code></span>
<span class="codeline" id="line-4600"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4601"><code>func exitsyscallfast(oldp *p) bool {</code></span>
<span class="codeline" id="line-4602"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4603"><code></code></span>
<span class="codeline" id="line-4604"><code>	// Freezetheworld sets stopwait but does not retake P's.</code></span>
<span class="codeline" id="line-4605"><code>	if sched.stopwait == freezeStopWait {</code></span>
<span class="codeline" id="line-4606"><code>		return false</code></span>
<span class="codeline" id="line-4607"><code>	}</code></span>
<span class="codeline" id="line-4608"><code></code></span>
<span class="codeline" id="line-4609"><code>	// Try to re-acquire the last P.</code></span>
<span class="codeline" id="line-4610"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4611"><code>	if oldp != nil &amp;&amp; oldp.status == _Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) {</code></span>
<span class="codeline" id="line-4612"><code>		// There's a cpu for us, so we can run.</code></span>
<span class="codeline" id="line-4613"><code>		wirep(oldp)</code></span>
<span class="codeline" id="line-4614"><code>		exitsyscallfast_reacquired(trace)</code></span>
<span class="codeline" id="line-4615"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4616"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4617"><code>		}</code></span>
<span class="codeline" id="line-4618"><code>		return true</code></span>
<span class="codeline" id="line-4619"><code>	}</code></span>
<span class="codeline" id="line-4620"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4621"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4622"><code>	}</code></span>
<span class="codeline" id="line-4623"><code></code></span>
<span class="codeline" id="line-4624"><code>	// Try to get any other idle P.</code></span>
<span class="codeline" id="line-4625"><code>	if sched.pidle != 0 {</code></span>
<span class="codeline" id="line-4626"><code>		var ok bool</code></span>
<span class="codeline" id="line-4627"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4628"><code>			ok = exitsyscallfast_pidle()</code></span>
<span class="codeline" id="line-4629"><code>			if ok &amp;&amp; !goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4630"><code>				trace := traceAcquire()</code></span>
<span class="codeline" id="line-4631"><code>				if trace.ok() {</code></span>
<span class="codeline" id="line-4632"><code>					if oldp != nil {</code></span>
<span class="codeline" id="line-4633"><code>						// Wait till traceGoSysBlock event is emitted.</code></span>
<span class="codeline" id="line-4634"><code>						// This ensures consistency of the trace (the goroutine is started after it is blocked).</code></span>
<span class="codeline" id="line-4635"><code>						for oldp.syscalltick == gp.m.syscalltick {</code></span>
<span class="codeline" id="line-4636"><code>							osyield()</code></span>
<span class="codeline" id="line-4637"><code>						}</code></span>
<span class="codeline" id="line-4638"><code>					}</code></span>
<span class="codeline" id="line-4639"><code>					// In the experiment, we write this in exitsyscall.</code></span>
<span class="codeline" id="line-4640"><code>					// Don't write it here unless the experiment is off.</code></span>
<span class="codeline" id="line-4641"><code>					trace.GoSysExit(true)</code></span>
<span class="codeline" id="line-4642"><code>					traceRelease(trace)</code></span>
<span class="codeline" id="line-4643"><code>				}</code></span>
<span class="codeline" id="line-4644"><code>			}</code></span>
<span class="codeline" id="line-4645"><code>		})</code></span>
<span class="codeline" id="line-4646"><code>		if ok {</code></span>
<span class="codeline" id="line-4647"><code>			return true</code></span>
<span class="codeline" id="line-4648"><code>		}</code></span>
<span class="codeline" id="line-4649"><code>	}</code></span>
<span class="codeline" id="line-4650"><code>	return false</code></span>
<span class="codeline" id="line-4651"><code>}</code></span>
<span class="codeline" id="line-4652"><code></code></span>
<span class="codeline" id="line-4653"><code>// exitsyscallfast_reacquired is the exitsyscall path on which this G</code></span>
<span class="codeline" id="line-4654"><code>// has successfully reacquired the P it was running on before the</code></span>
<span class="codeline" id="line-4655"><code>// syscall.</code></span>
<span class="codeline" id="line-4656"><code>//</code></span>
<span class="codeline" id="line-4657"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4658"><code>func exitsyscallfast_reacquired(trace traceLocker) {</code></span>
<span class="codeline" id="line-4659"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4660"><code>	if gp.m.syscalltick != gp.m.p.ptr().syscalltick {</code></span>
<span class="codeline" id="line-4661"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4662"><code>			// The p was retaken and then enter into syscall again (since gp.m.syscalltick has changed).</code></span>
<span class="codeline" id="line-4663"><code>			// traceGoSysBlock for this syscall was already emitted,</code></span>
<span class="codeline" id="line-4664"><code>			// but here we effectively retake the p from the new syscall running on the same p.</code></span>
<span class="codeline" id="line-4665"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-4666"><code>				if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4667"><code>					// In the experiment, we're stealing the P. It's treated</code></span>
<span class="codeline" id="line-4668"><code>					// as if it temporarily stopped running. Then, start running.</code></span>
<span class="codeline" id="line-4669"><code>					trace.ProcSteal(gp.m.p.ptr(), true)</code></span>
<span class="codeline" id="line-4670"><code>					trace.ProcStart()</code></span>
<span class="codeline" id="line-4671"><code>				} else {</code></span>
<span class="codeline" id="line-4672"><code>					// Denote blocking of the new syscall.</code></span>
<span class="codeline" id="line-4673"><code>					trace.GoSysBlock(gp.m.p.ptr())</code></span>
<span class="codeline" id="line-4674"><code>					// Denote completion of the current syscall.</code></span>
<span class="codeline" id="line-4675"><code>					trace.GoSysExit(true)</code></span>
<span class="codeline" id="line-4676"><code>				}</code></span>
<span class="codeline" id="line-4677"><code>			})</code></span>
<span class="codeline" id="line-4678"><code>		}</code></span>
<span class="codeline" id="line-4679"><code>		gp.m.p.ptr().syscalltick++</code></span>
<span class="codeline" id="line-4680"><code>	}</code></span>
<span class="codeline" id="line-4681"><code>}</code></span>
<span class="codeline" id="line-4682"><code></code></span>
<span class="codeline" id="line-4683"><code>func exitsyscallfast_pidle() bool {</code></span>
<span class="codeline" id="line-4684"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4685"><code>	pp, _ := pidleget(0)</code></span>
<span class="codeline" id="line-4686"><code>	if pp != nil &amp;&amp; sched.sysmonwait.Load() {</code></span>
<span class="codeline" id="line-4687"><code>		sched.sysmonwait.Store(false)</code></span>
<span class="codeline" id="line-4688"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-4689"><code>	}</code></span>
<span class="codeline" id="line-4690"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4691"><code>	if pp != nil {</code></span>
<span class="codeline" id="line-4692"><code>		acquirep(pp)</code></span>
<span class="codeline" id="line-4693"><code>		return true</code></span>
<span class="codeline" id="line-4694"><code>	}</code></span>
<span class="codeline" id="line-4695"><code>	return false</code></span>
<span class="codeline" id="line-4696"><code>}</code></span>
<span class="codeline" id="line-4697"><code></code></span>
<span class="codeline" id="line-4698"><code>// exitsyscall slow path on g0.</code></span>
<span class="codeline" id="line-4699"><code>// Failed to acquire P, enqueue gp as runnable.</code></span>
<span class="codeline" id="line-4700"><code>//</code></span>
<span class="codeline" id="line-4701"><code>// Called via mcall, so gp is the calling g from this M.</code></span>
<span class="codeline" id="line-4702"><code>//</code></span>
<span class="codeline" id="line-4703"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4704"><code>func exitsyscall0(gp *g) {</code></span>
<span class="codeline" id="line-4705"><code>	var trace traceLocker</code></span>
<span class="codeline" id="line-4706"><code>	if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4707"><code>		traceExitingSyscall()</code></span>
<span class="codeline" id="line-4708"><code>		trace = traceAcquire()</code></span>
<span class="codeline" id="line-4709"><code>	}</code></span>
<span class="codeline" id="line-4710"><code>	casgstatus(gp, _Gsyscall, _Grunnable)</code></span>
<span class="codeline" id="line-4711"><code>	if goexperiment.ExecTracer2 {</code></span>
<span class="codeline" id="line-4712"><code>		traceExitedSyscall()</code></span>
<span class="codeline" id="line-4713"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-4714"><code>			// Write out syscall exit eagerly in the experiment.</code></span>
<span class="codeline" id="line-4715"><code>			//</code></span>
<span class="codeline" id="line-4716"><code>			// It's important that we write this *after* we know whether we</code></span>
<span class="codeline" id="line-4717"><code>			// lost our P or not (determined by exitsyscallfast).</code></span>
<span class="codeline" id="line-4718"><code>			trace.GoSysExit(true)</code></span>
<span class="codeline" id="line-4719"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-4720"><code>		}</code></span>
<span class="codeline" id="line-4721"><code>	}</code></span>
<span class="codeline" id="line-4722"><code>	dropg()</code></span>
<span class="codeline" id="line-4723"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4724"><code>	var pp *p</code></span>
<span class="codeline" id="line-4725"><code>	if schedEnabled(gp) {</code></span>
<span class="codeline" id="line-4726"><code>		pp, _ = pidleget(0)</code></span>
<span class="codeline" id="line-4727"><code>	}</code></span>
<span class="codeline" id="line-4728"><code>	var locked bool</code></span>
<span class="codeline" id="line-4729"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-4730"><code>		globrunqput(gp)</code></span>
<span class="codeline" id="line-4731"><code></code></span>
<span class="codeline" id="line-4732"><code>		// Below, we stoplockedm if gp is locked. globrunqput releases</code></span>
<span class="codeline" id="line-4733"><code>		// ownership of gp, so we must check if gp is locked prior to</code></span>
<span class="codeline" id="line-4734"><code>		// committing the release by unlocking sched.lock, otherwise we</code></span>
<span class="codeline" id="line-4735"><code>		// could race with another M transitioning gp from unlocked to</code></span>
<span class="codeline" id="line-4736"><code>		// locked.</code></span>
<span class="codeline" id="line-4737"><code>		locked = gp.lockedm != 0</code></span>
<span class="codeline" id="line-4738"><code>	} else if sched.sysmonwait.Load() {</code></span>
<span class="codeline" id="line-4739"><code>		sched.sysmonwait.Store(false)</code></span>
<span class="codeline" id="line-4740"><code>		notewakeup(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-4741"><code>	}</code></span>
<span class="codeline" id="line-4742"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-4743"><code>	if pp != nil {</code></span>
<span class="codeline" id="line-4744"><code>		acquirep(pp)</code></span>
<span class="codeline" id="line-4745"><code>		execute(gp, false) // Never returns.</code></span>
<span class="codeline" id="line-4746"><code>	}</code></span>
<span class="codeline" id="line-4747"><code>	if locked {</code></span>
<span class="codeline" id="line-4748"><code>		// Wait until another thread schedules gp and so m again.</code></span>
<span class="codeline" id="line-4749"><code>		//</code></span>
<span class="codeline" id="line-4750"><code>		// N.B. lockedm must be this M, as this g was running on this M</code></span>
<span class="codeline" id="line-4751"><code>		// before entersyscall.</code></span>
<span class="codeline" id="line-4752"><code>		stoplockedm()</code></span>
<span class="codeline" id="line-4753"><code>		execute(gp, false) // Never returns.</code></span>
<span class="codeline" id="line-4754"><code>	}</code></span>
<span class="codeline" id="line-4755"><code>	stopm()</code></span>
<span class="codeline" id="line-4756"><code>	schedule() // Never returns.</code></span>
<span class="codeline" id="line-4757"><code>}</code></span>
<span class="codeline" id="line-4758"><code></code></span>
<span class="codeline" id="line-4759"><code>// Called from syscall package before fork.</code></span>
<span class="codeline" id="line-4760"><code>//</code></span>
<span class="codeline" id="line-4761"><code>//go:linkname syscall_runtime_BeforeFork syscall.runtime_BeforeFork</code></span>
<span class="codeline" id="line-4762"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4763"><code>func syscall_runtime_BeforeFork() {</code></span>
<span class="codeline" id="line-4764"><code>	gp := getg().m.curg</code></span>
<span class="codeline" id="line-4765"><code></code></span>
<span class="codeline" id="line-4766"><code>	// Block signals during a fork, so that the child does not run</code></span>
<span class="codeline" id="line-4767"><code>	// a signal handler before exec if a signal is sent to the process</code></span>
<span class="codeline" id="line-4768"><code>	// group. See issue #18600.</code></span>
<span class="codeline" id="line-4769"><code>	gp.m.locks++</code></span>
<span class="codeline" id="line-4770"><code>	sigsave(&amp;gp.m.sigmask)</code></span>
<span class="codeline" id="line-4771"><code>	sigblock(false)</code></span>
<span class="codeline" id="line-4772"><code></code></span>
<span class="codeline" id="line-4773"><code>	// This function is called before fork in syscall package.</code></span>
<span class="codeline" id="line-4774"><code>	// Code between fork and exec must not allocate memory nor even try to grow stack.</code></span>
<span class="codeline" id="line-4775"><code>	// Here we spoil g.stackguard0 to reliably detect any attempts to grow stack.</code></span>
<span class="codeline" id="line-4776"><code>	// runtime_AfterFork will undo this in parent process, but not in child.</code></span>
<span class="codeline" id="line-4777"><code>	gp.stackguard0 = stackFork</code></span>
<span class="codeline" id="line-4778"><code>}</code></span>
<span class="codeline" id="line-4779"><code></code></span>
<span class="codeline" id="line-4780"><code>// Called from syscall package after fork in parent.</code></span>
<span class="codeline" id="line-4781"><code>//</code></span>
<span class="codeline" id="line-4782"><code>//go:linkname syscall_runtime_AfterFork syscall.runtime_AfterFork</code></span>
<span class="codeline" id="line-4783"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4784"><code>func syscall_runtime_AfterFork() {</code></span>
<span class="codeline" id="line-4785"><code>	gp := getg().m.curg</code></span>
<span class="codeline" id="line-4786"><code></code></span>
<span class="codeline" id="line-4787"><code>	// See the comments in beforefork.</code></span>
<span class="codeline" id="line-4788"><code>	gp.stackguard0 = gp.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-4789"><code></code></span>
<span class="codeline" id="line-4790"><code>	msigrestore(gp.m.sigmask)</code></span>
<span class="codeline" id="line-4791"><code></code></span>
<span class="codeline" id="line-4792"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-4793"><code>}</code></span>
<span class="codeline" id="line-4794"><code></code></span>
<span class="codeline" id="line-4795"><code>// inForkedChild is true while manipulating signals in the child process.</code></span>
<span class="codeline" id="line-4796"><code>// This is used to avoid calling libc functions in case we are using vfork.</code></span>
<span class="codeline" id="line-4797"><code>var inForkedChild bool</code></span>
<span class="codeline" id="line-4798"><code></code></span>
<span class="codeline" id="line-4799"><code>// Called from syscall package after fork in child.</code></span>
<span class="codeline" id="line-4800"><code>// It resets non-sigignored signals to the default handler, and</code></span>
<span class="codeline" id="line-4801"><code>// restores the signal mask in preparation for the exec.</code></span>
<span class="codeline" id="line-4802"><code>//</code></span>
<span class="codeline" id="line-4803"><code>// Because this might be called during a vfork, and therefore may be</code></span>
<span class="codeline" id="line-4804"><code>// temporarily sharing address space with the parent process, this must</code></span>
<span class="codeline" id="line-4805"><code>// not change any global variables or calling into C code that may do so.</code></span>
<span class="codeline" id="line-4806"><code>//</code></span>
<span class="codeline" id="line-4807"><code>//go:linkname syscall_runtime_AfterForkInChild syscall.runtime_AfterForkInChild</code></span>
<span class="codeline" id="line-4808"><code>//go:nosplit</code></span>
<span class="codeline" id="line-4809"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-4810"><code>func syscall_runtime_AfterForkInChild() {</code></span>
<span class="codeline" id="line-4811"><code>	// It's OK to change the global variable inForkedChild here</code></span>
<span class="codeline" id="line-4812"><code>	// because we are going to change it back. There is no race here,</code></span>
<span class="codeline" id="line-4813"><code>	// because if we are sharing address space with the parent process,</code></span>
<span class="codeline" id="line-4814"><code>	// then the parent process can not be running concurrently.</code></span>
<span class="codeline" id="line-4815"><code>	inForkedChild = true</code></span>
<span class="codeline" id="line-4816"><code></code></span>
<span class="codeline" id="line-4817"><code>	clearSignalHandlers()</code></span>
<span class="codeline" id="line-4818"><code></code></span>
<span class="codeline" id="line-4819"><code>	// When we are the child we are the only thread running,</code></span>
<span class="codeline" id="line-4820"><code>	// so we know that nothing else has changed gp.m.sigmask.</code></span>
<span class="codeline" id="line-4821"><code>	msigrestore(getg().m.sigmask)</code></span>
<span class="codeline" id="line-4822"><code></code></span>
<span class="codeline" id="line-4823"><code>	inForkedChild = false</code></span>
<span class="codeline" id="line-4824"><code>}</code></span>
<span class="codeline" id="line-4825"><code></code></span>
<span class="codeline" id="line-4826"><code>// pendingPreemptSignals is the number of preemption signals</code></span>
<span class="codeline" id="line-4827"><code>// that have been sent but not received. This is only used on Darwin.</code></span>
<span class="codeline" id="line-4828"><code>// For #41702.</code></span>
<span class="codeline" id="line-4829"><code>var pendingPreemptSignals atomic.Int32</code></span>
<span class="codeline" id="line-4830"><code></code></span>
<span class="codeline" id="line-4831"><code>// Called from syscall package before Exec.</code></span>
<span class="codeline" id="line-4832"><code>//</code></span>
<span class="codeline" id="line-4833"><code>//go:linkname syscall_runtime_BeforeExec syscall.runtime_BeforeExec</code></span>
<span class="codeline" id="line-4834"><code>func syscall_runtime_BeforeExec() {</code></span>
<span class="codeline" id="line-4835"><code>	// Prevent thread creation during exec.</code></span>
<span class="codeline" id="line-4836"><code>	execLock.lock()</code></span>
<span class="codeline" id="line-4837"><code></code></span>
<span class="codeline" id="line-4838"><code>	// On Darwin, wait for all pending preemption signals to</code></span>
<span class="codeline" id="line-4839"><code>	// be received. See issue #41702.</code></span>
<span class="codeline" id="line-4840"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-4841"><code>		for pendingPreemptSignals.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-4842"><code>			osyield()</code></span>
<span class="codeline" id="line-4843"><code>		}</code></span>
<span class="codeline" id="line-4844"><code>	}</code></span>
<span class="codeline" id="line-4845"><code>}</code></span>
<span class="codeline" id="line-4846"><code></code></span>
<span class="codeline" id="line-4847"><code>// Called from syscall package after Exec.</code></span>
<span class="codeline" id="line-4848"><code>//</code></span>
<span class="codeline" id="line-4849"><code>//go:linkname syscall_runtime_AfterExec syscall.runtime_AfterExec</code></span>
<span class="codeline" id="line-4850"><code>func syscall_runtime_AfterExec() {</code></span>
<span class="codeline" id="line-4851"><code>	execLock.unlock()</code></span>
<span class="codeline" id="line-4852"><code>}</code></span>
<span class="codeline" id="line-4853"><code></code></span>
<span class="codeline" id="line-4854"><code>// Allocate a new g, with a stack big enough for stacksize bytes.</code></span>
<span class="codeline" id="line-4855"><code>func malg(stacksize int32) *g {</code></span>
<span class="codeline" id="line-4856"><code>	newg := new(g)</code></span>
<span class="codeline" id="line-4857"><code>	if stacksize &gt;= 0 {</code></span>
<span class="codeline" id="line-4858"><code>		stacksize = round2(stackSystem + stacksize)</code></span>
<span class="codeline" id="line-4859"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-4860"><code>			newg.stack = stackalloc(uint32(stacksize))</code></span>
<span class="codeline" id="line-4861"><code>		})</code></span>
<span class="codeline" id="line-4862"><code>		newg.stackguard0 = newg.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-4863"><code>		newg.stackguard1 = ^uintptr(0)</code></span>
<span class="codeline" id="line-4864"><code>		// Clear the bottom word of the stack. We record g</code></span>
<span class="codeline" id="line-4865"><code>		// there on gsignal stack during VDSO on ARM and ARM64.</code></span>
<span class="codeline" id="line-4866"><code>		*(*uintptr)(unsafe.Pointer(newg.stack.lo)) = 0</code></span>
<span class="codeline" id="line-4867"><code>	}</code></span>
<span class="codeline" id="line-4868"><code>	return newg</code></span>
<span class="codeline" id="line-4869"><code>}</code></span>
<span class="codeline" id="line-4870"><code></code></span>
<span class="codeline" id="line-4871"><code>// Create a new g running fn.</code></span>
<span class="codeline" id="line-4872"><code>// Put it on the queue of g's waiting to run.</code></span>
<span class="codeline" id="line-4873"><code>// The compiler turns a go statement into a call to this.</code></span>
<span class="codeline" id="line-4874"><code>func newproc(fn *funcval) {</code></span>
<span class="codeline" id="line-4875"><code>	gp := getg()</code></span>
<span class="codeline" id="line-4876"><code>	pc := getcallerpc()</code></span>
<span class="codeline" id="line-4877"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-4878"><code>		newg := newproc1(fn, gp, pc)</code></span>
<span class="codeline" id="line-4879"><code></code></span>
<span class="codeline" id="line-4880"><code>		pp := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-4881"><code>		runqput(pp, newg, true)</code></span>
<span class="codeline" id="line-4882"><code></code></span>
<span class="codeline" id="line-4883"><code>		if mainStarted {</code></span>
<span class="codeline" id="line-4884"><code>			wakep()</code></span>
<span class="codeline" id="line-4885"><code>		}</code></span>
<span class="codeline" id="line-4886"><code>	})</code></span>
<span class="codeline" id="line-4887"><code>}</code></span>
<span class="codeline" id="line-4888"><code></code></span>
<span class="codeline" id="line-4889"><code>// Create a new g in state _Grunnable, starting at fn. callerpc is the</code></span>
<span class="codeline" id="line-4890"><code>// address of the go statement that created this. The caller is responsible</code></span>
<span class="codeline" id="line-4891"><code>// for adding the new g to the scheduler.</code></span>
<span class="codeline" id="line-4892"><code>func newproc1(fn *funcval, callergp *g, callerpc uintptr) *g {</code></span>
<span class="codeline" id="line-4893"><code>	if fn == nil {</code></span>
<span class="codeline" id="line-4894"><code>		fatal("go of nil func value")</code></span>
<span class="codeline" id="line-4895"><code>	}</code></span>
<span class="codeline" id="line-4896"><code></code></span>
<span class="codeline" id="line-4897"><code>	mp := acquirem() // disable preemption because we hold M and P in local vars.</code></span>
<span class="codeline" id="line-4898"><code>	pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-4899"><code>	newg := gfget(pp)</code></span>
<span class="codeline" id="line-4900"><code>	if newg == nil {</code></span>
<span class="codeline" id="line-4901"><code>		newg = malg(stackMin)</code></span>
<span class="codeline" id="line-4902"><code>		casgstatus(newg, _Gidle, _Gdead)</code></span>
<span class="codeline" id="line-4903"><code>		allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.</code></span>
<span class="codeline" id="line-4904"><code>	}</code></span>
<span class="codeline" id="line-4905"><code>	if newg.stack.hi == 0 {</code></span>
<span class="codeline" id="line-4906"><code>		throw("newproc1: newg missing stack")</code></span>
<span class="codeline" id="line-4907"><code>	}</code></span>
<span class="codeline" id="line-4908"><code></code></span>
<span class="codeline" id="line-4909"><code>	if readgstatus(newg) != _Gdead {</code></span>
<span class="codeline" id="line-4910"><code>		throw("newproc1: new g is not Gdead")</code></span>
<span class="codeline" id="line-4911"><code>	}</code></span>
<span class="codeline" id="line-4912"><code></code></span>
<span class="codeline" id="line-4913"><code>	totalSize := uintptr(4*goarch.PtrSize + sys.MinFrameSize) // extra space in case of reads slightly beyond frame</code></span>
<span class="codeline" id="line-4914"><code>	totalSize = alignUp(totalSize, sys.StackAlign)</code></span>
<span class="codeline" id="line-4915"><code>	sp := newg.stack.hi - totalSize</code></span>
<span class="codeline" id="line-4916"><code>	if usesLR {</code></span>
<span class="codeline" id="line-4917"><code>		// caller's LR</code></span>
<span class="codeline" id="line-4918"><code>		*(*uintptr)(unsafe.Pointer(sp)) = 0</code></span>
<span class="codeline" id="line-4919"><code>		prepGoExitFrame(sp)</code></span>
<span class="codeline" id="line-4920"><code>	}</code></span>
<span class="codeline" id="line-4921"><code>	if GOARCH == "arm64" {</code></span>
<span class="codeline" id="line-4922"><code>		// caller's FP</code></span>
<span class="codeline" id="line-4923"><code>		*(*uintptr)(unsafe.Pointer(sp - goarch.PtrSize)) = 0</code></span>
<span class="codeline" id="line-4924"><code>	}</code></span>
<span class="codeline" id="line-4925"><code></code></span>
<span class="codeline" id="line-4926"><code>	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</code></span>
<span class="codeline" id="line-4927"><code>	newg.sched.sp = sp</code></span>
<span class="codeline" id="line-4928"><code>	newg.stktopsp = sp</code></span>
<span class="codeline" id="line-4929"><code>	newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function</code></span>
<span class="codeline" id="line-4930"><code>	newg.sched.g = guintptr(unsafe.Pointer(newg))</code></span>
<span class="codeline" id="line-4931"><code>	gostartcallfn(&amp;newg.sched, fn)</code></span>
<span class="codeline" id="line-4932"><code>	newg.parentGoid = callergp.goid</code></span>
<span class="codeline" id="line-4933"><code>	newg.gopc = callerpc</code></span>
<span class="codeline" id="line-4934"><code>	newg.ancestors = saveAncestors(callergp)</code></span>
<span class="codeline" id="line-4935"><code>	newg.startpc = fn.fn</code></span>
<span class="codeline" id="line-4936"><code>	if isSystemGoroutine(newg, false) {</code></span>
<span class="codeline" id="line-4937"><code>		sched.ngsys.Add(1)</code></span>
<span class="codeline" id="line-4938"><code>	} else {</code></span>
<span class="codeline" id="line-4939"><code>		// Only user goroutines inherit pprof labels.</code></span>
<span class="codeline" id="line-4940"><code>		if mp.curg != nil {</code></span>
<span class="codeline" id="line-4941"><code>			newg.labels = mp.curg.labels</code></span>
<span class="codeline" id="line-4942"><code>		}</code></span>
<span class="codeline" id="line-4943"><code>		if goroutineProfile.active {</code></span>
<span class="codeline" id="line-4944"><code>			// A concurrent goroutine profile is running. It should include</code></span>
<span class="codeline" id="line-4945"><code>			// exactly the set of goroutines that were alive when the goroutine</code></span>
<span class="codeline" id="line-4946"><code>			// profiler first stopped the world. That does not include newg, so</code></span>
<span class="codeline" id="line-4947"><code>			// mark it as not needing a profile before transitioning it from</code></span>
<span class="codeline" id="line-4948"><code>			// _Gdead.</code></span>
<span class="codeline" id="line-4949"><code>			newg.goroutineProfiled.Store(goroutineProfileSatisfied)</code></span>
<span class="codeline" id="line-4950"><code>		}</code></span>
<span class="codeline" id="line-4951"><code>	}</code></span>
<span class="codeline" id="line-4952"><code>	// Track initial transition?</code></span>
<span class="codeline" id="line-4953"><code>	newg.trackingSeq = uint8(cheaprand())</code></span>
<span class="codeline" id="line-4954"><code>	if newg.trackingSeq%gTrackingPeriod == 0 {</code></span>
<span class="codeline" id="line-4955"><code>		newg.tracking = true</code></span>
<span class="codeline" id="line-4956"><code>	}</code></span>
<span class="codeline" id="line-4957"><code>	gcController.addScannableStack(pp, int64(newg.stack.hi-newg.stack.lo))</code></span>
<span class="codeline" id="line-4958"><code></code></span>
<span class="codeline" id="line-4959"><code>	// Get a goid and switch to runnable. Make all this atomic to the tracer.</code></span>
<span class="codeline" id="line-4960"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-4961"><code>	casgstatus(newg, _Gdead, _Grunnable)</code></span>
<span class="codeline" id="line-4962"><code>	if pp.goidcache == pp.goidcacheend {</code></span>
<span class="codeline" id="line-4963"><code>		// Sched.goidgen is the last allocated id,</code></span>
<span class="codeline" id="line-4964"><code>		// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</code></span>
<span class="codeline" id="line-4965"><code>		// At startup sched.goidgen=0, so main goroutine receives goid=1.</code></span>
<span class="codeline" id="line-4966"><code>		pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</code></span>
<span class="codeline" id="line-4967"><code>		pp.goidcache -= _GoidCacheBatch - 1</code></span>
<span class="codeline" id="line-4968"><code>		pp.goidcacheend = pp.goidcache + _GoidCacheBatch</code></span>
<span class="codeline" id="line-4969"><code>	}</code></span>
<span class="codeline" id="line-4970"><code>	newg.goid = pp.goidcache</code></span>
<span class="codeline" id="line-4971"><code>	pp.goidcache++</code></span>
<span class="codeline" id="line-4972"><code>	newg.trace.reset()</code></span>
<span class="codeline" id="line-4973"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-4974"><code>		trace.GoCreate(newg, newg.startpc)</code></span>
<span class="codeline" id="line-4975"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-4976"><code>	}</code></span>
<span class="codeline" id="line-4977"><code></code></span>
<span class="codeline" id="line-4978"><code>	// Set up race context.</code></span>
<span class="codeline" id="line-4979"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-4980"><code>		newg.racectx = racegostart(callerpc)</code></span>
<span class="codeline" id="line-4981"><code>		newg.raceignore = 0</code></span>
<span class="codeline" id="line-4982"><code>		if newg.labels != nil {</code></span>
<span class="codeline" id="line-4983"><code>			// See note in proflabel.go on labelSync's role in synchronizing</code></span>
<span class="codeline" id="line-4984"><code>			// with the reads in the signal handler.</code></span>
<span class="codeline" id="line-4985"><code>			racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync))</code></span>
<span class="codeline" id="line-4986"><code>		}</code></span>
<span class="codeline" id="line-4987"><code>	}</code></span>
<span class="codeline" id="line-4988"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-4989"><code></code></span>
<span class="codeline" id="line-4990"><code>	return newg</code></span>
<span class="codeline" id="line-4991"><code>}</code></span>
<span class="codeline" id="line-4992"><code></code></span>
<span class="codeline" id="line-4993"><code>// saveAncestors copies previous ancestors of the given caller g and</code></span>
<span class="codeline" id="line-4994"><code>// includes info for the current caller into a new set of tracebacks for</code></span>
<span class="codeline" id="line-4995"><code>// a g being created.</code></span>
<span class="codeline" id="line-4996"><code>func saveAncestors(callergp *g) *[]ancestorInfo {</code></span>
<span class="codeline" id="line-4997"><code>	// Copy all prior info, except for the root goroutine (goid 0).</code></span>
<span class="codeline" id="line-4998"><code>	if debug.tracebackancestors &lt;= 0 || callergp.goid == 0 {</code></span>
<span class="codeline" id="line-4999"><code>		return nil</code></span>
<span class="codeline" id="line-5000"><code>	}</code></span>
<span class="codeline" id="line-5001"><code>	var callerAncestors []ancestorInfo</code></span>
<span class="codeline" id="line-5002"><code>	if callergp.ancestors != nil {</code></span>
<span class="codeline" id="line-5003"><code>		callerAncestors = *callergp.ancestors</code></span>
<span class="codeline" id="line-5004"><code>	}</code></span>
<span class="codeline" id="line-5005"><code>	n := int32(len(callerAncestors)) + 1</code></span>
<span class="codeline" id="line-5006"><code>	if n &gt; debug.tracebackancestors {</code></span>
<span class="codeline" id="line-5007"><code>		n = debug.tracebackancestors</code></span>
<span class="codeline" id="line-5008"><code>	}</code></span>
<span class="codeline" id="line-5009"><code>	ancestors := make([]ancestorInfo, n)</code></span>
<span class="codeline" id="line-5010"><code>	copy(ancestors[1:], callerAncestors)</code></span>
<span class="codeline" id="line-5011"><code></code></span>
<span class="codeline" id="line-5012"><code>	var pcs [tracebackInnerFrames]uintptr</code></span>
<span class="codeline" id="line-5013"><code>	npcs := gcallers(callergp, 0, pcs[:])</code></span>
<span class="codeline" id="line-5014"><code>	ipcs := make([]uintptr, npcs)</code></span>
<span class="codeline" id="line-5015"><code>	copy(ipcs, pcs[:])</code></span>
<span class="codeline" id="line-5016"><code>	ancestors[0] = ancestorInfo{</code></span>
<span class="codeline" id="line-5017"><code>		pcs:  ipcs,</code></span>
<span class="codeline" id="line-5018"><code>		goid: callergp.goid,</code></span>
<span class="codeline" id="line-5019"><code>		gopc: callergp.gopc,</code></span>
<span class="codeline" id="line-5020"><code>	}</code></span>
<span class="codeline" id="line-5021"><code></code></span>
<span class="codeline" id="line-5022"><code>	ancestorsp := new([]ancestorInfo)</code></span>
<span class="codeline" id="line-5023"><code>	*ancestorsp = ancestors</code></span>
<span class="codeline" id="line-5024"><code>	return ancestorsp</code></span>
<span class="codeline" id="line-5025"><code>}</code></span>
<span class="codeline" id="line-5026"><code></code></span>
<span class="codeline" id="line-5027"><code>// Put on gfree list.</code></span>
<span class="codeline" id="line-5028"><code>// If local list is too long, transfer a batch to the global list.</code></span>
<span class="codeline" id="line-5029"><code>func gfput(pp *p, gp *g) {</code></span>
<span class="codeline" id="line-5030"><code>	if readgstatus(gp) != _Gdead {</code></span>
<span class="codeline" id="line-5031"><code>		throw("gfput: bad status (not Gdead)")</code></span>
<span class="codeline" id="line-5032"><code>	}</code></span>
<span class="codeline" id="line-5033"><code></code></span>
<span class="codeline" id="line-5034"><code>	stksize := gp.stack.hi - gp.stack.lo</code></span>
<span class="codeline" id="line-5035"><code></code></span>
<span class="codeline" id="line-5036"><code>	if stksize != uintptr(startingStackSize) {</code></span>
<span class="codeline" id="line-5037"><code>		// non-standard stack size - free it.</code></span>
<span class="codeline" id="line-5038"><code>		stackfree(gp.stack)</code></span>
<span class="codeline" id="line-5039"><code>		gp.stack.lo = 0</code></span>
<span class="codeline" id="line-5040"><code>		gp.stack.hi = 0</code></span>
<span class="codeline" id="line-5041"><code>		gp.stackguard0 = 0</code></span>
<span class="codeline" id="line-5042"><code>	}</code></span>
<span class="codeline" id="line-5043"><code></code></span>
<span class="codeline" id="line-5044"><code>	pp.gFree.push(gp)</code></span>
<span class="codeline" id="line-5045"><code>	pp.gFree.n++</code></span>
<span class="codeline" id="line-5046"><code>	if pp.gFree.n &gt;= 64 {</code></span>
<span class="codeline" id="line-5047"><code>		var (</code></span>
<span class="codeline" id="line-5048"><code>			inc      int32</code></span>
<span class="codeline" id="line-5049"><code>			stackQ   gQueue</code></span>
<span class="codeline" id="line-5050"><code>			noStackQ gQueue</code></span>
<span class="codeline" id="line-5051"><code>		)</code></span>
<span class="codeline" id="line-5052"><code>		for pp.gFree.n &gt;= 32 {</code></span>
<span class="codeline" id="line-5053"><code>			gp := pp.gFree.pop()</code></span>
<span class="codeline" id="line-5054"><code>			pp.gFree.n--</code></span>
<span class="codeline" id="line-5055"><code>			if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-5056"><code>				noStackQ.push(gp)</code></span>
<span class="codeline" id="line-5057"><code>			} else {</code></span>
<span class="codeline" id="line-5058"><code>				stackQ.push(gp)</code></span>
<span class="codeline" id="line-5059"><code>			}</code></span>
<span class="codeline" id="line-5060"><code>			inc++</code></span>
<span class="codeline" id="line-5061"><code>		}</code></span>
<span class="codeline" id="line-5062"><code>		lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5063"><code>		sched.gFree.noStack.pushAll(noStackQ)</code></span>
<span class="codeline" id="line-5064"><code>		sched.gFree.stack.pushAll(stackQ)</code></span>
<span class="codeline" id="line-5065"><code>		sched.gFree.n += inc</code></span>
<span class="codeline" id="line-5066"><code>		unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5067"><code>	}</code></span>
<span class="codeline" id="line-5068"><code>}</code></span>
<span class="codeline" id="line-5069"><code></code></span>
<span class="codeline" id="line-5070"><code>// Get from gfree list.</code></span>
<span class="codeline" id="line-5071"><code>// If local list is empty, grab a batch from global list.</code></span>
<span class="codeline" id="line-5072"><code>func gfget(pp *p) *g {</code></span>
<span class="codeline" id="line-5073"><code>retry:</code></span>
<span class="codeline" id="line-5074"><code>	if pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) {</code></span>
<span class="codeline" id="line-5075"><code>		lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5076"><code>		// Move a batch of free Gs to the P.</code></span>
<span class="codeline" id="line-5077"><code>		for pp.gFree.n &lt; 32 {</code></span>
<span class="codeline" id="line-5078"><code>			// Prefer Gs with stacks.</code></span>
<span class="codeline" id="line-5079"><code>			gp := sched.gFree.stack.pop()</code></span>
<span class="codeline" id="line-5080"><code>			if gp == nil {</code></span>
<span class="codeline" id="line-5081"><code>				gp = sched.gFree.noStack.pop()</code></span>
<span class="codeline" id="line-5082"><code>				if gp == nil {</code></span>
<span class="codeline" id="line-5083"><code>					break</code></span>
<span class="codeline" id="line-5084"><code>				}</code></span>
<span class="codeline" id="line-5085"><code>			}</code></span>
<span class="codeline" id="line-5086"><code>			sched.gFree.n--</code></span>
<span class="codeline" id="line-5087"><code>			pp.gFree.push(gp)</code></span>
<span class="codeline" id="line-5088"><code>			pp.gFree.n++</code></span>
<span class="codeline" id="line-5089"><code>		}</code></span>
<span class="codeline" id="line-5090"><code>		unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5091"><code>		goto retry</code></span>
<span class="codeline" id="line-5092"><code>	}</code></span>
<span class="codeline" id="line-5093"><code>	gp := pp.gFree.pop()</code></span>
<span class="codeline" id="line-5094"><code>	if gp == nil {</code></span>
<span class="codeline" id="line-5095"><code>		return nil</code></span>
<span class="codeline" id="line-5096"><code>	}</code></span>
<span class="codeline" id="line-5097"><code>	pp.gFree.n--</code></span>
<span class="codeline" id="line-5098"><code>	if gp.stack.lo != 0 &amp;&amp; gp.stack.hi-gp.stack.lo != uintptr(startingStackSize) {</code></span>
<span class="codeline" id="line-5099"><code>		// Deallocate old stack. We kept it in gfput because it was the</code></span>
<span class="codeline" id="line-5100"><code>		// right size when the goroutine was put on the free list, but</code></span>
<span class="codeline" id="line-5101"><code>		// the right size has changed since then.</code></span>
<span class="codeline" id="line-5102"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-5103"><code>			stackfree(gp.stack)</code></span>
<span class="codeline" id="line-5104"><code>			gp.stack.lo = 0</code></span>
<span class="codeline" id="line-5105"><code>			gp.stack.hi = 0</code></span>
<span class="codeline" id="line-5106"><code>			gp.stackguard0 = 0</code></span>
<span class="codeline" id="line-5107"><code>		})</code></span>
<span class="codeline" id="line-5108"><code>	}</code></span>
<span class="codeline" id="line-5109"><code>	if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-5110"><code>		// Stack was deallocated in gfput or just above. Allocate a new one.</code></span>
<span class="codeline" id="line-5111"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-5112"><code>			gp.stack = stackalloc(startingStackSize)</code></span>
<span class="codeline" id="line-5113"><code>		})</code></span>
<span class="codeline" id="line-5114"><code>		gp.stackguard0 = gp.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-5115"><code>	} else {</code></span>
<span class="codeline" id="line-5116"><code>		if raceenabled {</code></span>
<span class="codeline" id="line-5117"><code>			racemalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)</code></span>
<span class="codeline" id="line-5118"><code>		}</code></span>
<span class="codeline" id="line-5119"><code>		if msanenabled {</code></span>
<span class="codeline" id="line-5120"><code>			msanmalloc(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)</code></span>
<span class="codeline" id="line-5121"><code>		}</code></span>
<span class="codeline" id="line-5122"><code>		if asanenabled {</code></span>
<span class="codeline" id="line-5123"><code>			asanunpoison(unsafe.Pointer(gp.stack.lo), gp.stack.hi-gp.stack.lo)</code></span>
<span class="codeline" id="line-5124"><code>		}</code></span>
<span class="codeline" id="line-5125"><code>	}</code></span>
<span class="codeline" id="line-5126"><code>	return gp</code></span>
<span class="codeline" id="line-5127"><code>}</code></span>
<span class="codeline" id="line-5128"><code></code></span>
<span class="codeline" id="line-5129"><code>// Purge all cached G's from gfree list to the global list.</code></span>
<span class="codeline" id="line-5130"><code>func gfpurge(pp *p) {</code></span>
<span class="codeline" id="line-5131"><code>	var (</code></span>
<span class="codeline" id="line-5132"><code>		inc      int32</code></span>
<span class="codeline" id="line-5133"><code>		stackQ   gQueue</code></span>
<span class="codeline" id="line-5134"><code>		noStackQ gQueue</code></span>
<span class="codeline" id="line-5135"><code>	)</code></span>
<span class="codeline" id="line-5136"><code>	for !pp.gFree.empty() {</code></span>
<span class="codeline" id="line-5137"><code>		gp := pp.gFree.pop()</code></span>
<span class="codeline" id="line-5138"><code>		pp.gFree.n--</code></span>
<span class="codeline" id="line-5139"><code>		if gp.stack.lo == 0 {</code></span>
<span class="codeline" id="line-5140"><code>			noStackQ.push(gp)</code></span>
<span class="codeline" id="line-5141"><code>		} else {</code></span>
<span class="codeline" id="line-5142"><code>			stackQ.push(gp)</code></span>
<span class="codeline" id="line-5143"><code>		}</code></span>
<span class="codeline" id="line-5144"><code>		inc++</code></span>
<span class="codeline" id="line-5145"><code>	}</code></span>
<span class="codeline" id="line-5146"><code>	lock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5147"><code>	sched.gFree.noStack.pushAll(noStackQ)</code></span>
<span class="codeline" id="line-5148"><code>	sched.gFree.stack.pushAll(stackQ)</code></span>
<span class="codeline" id="line-5149"><code>	sched.gFree.n += inc</code></span>
<span class="codeline" id="line-5150"><code>	unlock(&amp;sched.gFree.lock)</code></span>
<span class="codeline" id="line-5151"><code>}</code></span>
<span class="codeline" id="line-5152"><code></code></span>
<span class="codeline" id="line-5153"><code>// Breakpoint executes a breakpoint trap.</code></span>
<span class="codeline" id="line-5154"><code>func Breakpoint() {</code></span>
<span class="codeline" id="line-5155"><code>	breakpoint()</code></span>
<span class="codeline" id="line-5156"><code>}</code></span>
<span class="codeline" id="line-5157"><code></code></span>
<span class="codeline" id="line-5158"><code>// dolockOSThread is called by LockOSThread and lockOSThread below</code></span>
<span class="codeline" id="line-5159"><code>// after they modify m.locked. Do not allow preemption during this call,</code></span>
<span class="codeline" id="line-5160"><code>// or else the m might be different in this function than in the caller.</code></span>
<span class="codeline" id="line-5161"><code>//</code></span>
<span class="codeline" id="line-5162"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5163"><code>func dolockOSThread() {</code></span>
<span class="codeline" id="line-5164"><code>	if GOARCH == "wasm" {</code></span>
<span class="codeline" id="line-5165"><code>		return // no threads on wasm yet</code></span>
<span class="codeline" id="line-5166"><code>	}</code></span>
<span class="codeline" id="line-5167"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5168"><code>	gp.m.lockedg.set(gp)</code></span>
<span class="codeline" id="line-5169"><code>	gp.lockedm.set(gp.m)</code></span>
<span class="codeline" id="line-5170"><code>}</code></span>
<span class="codeline" id="line-5171"><code></code></span>
<span class="codeline" id="line-5172"><code>// LockOSThread wires the calling goroutine to its current operating system thread.</code></span>
<span class="codeline" id="line-5173"><code>// The calling goroutine will always execute in that thread,</code></span>
<span class="codeline" id="line-5174"><code>// and no other goroutine will execute in it,</code></span>
<span class="codeline" id="line-5175"><code>// until the calling goroutine has made as many calls to</code></span>
<span class="codeline" id="line-5176"><code>// [UnlockOSThread] as to LockOSThread.</code></span>
<span class="codeline" id="line-5177"><code>// If the calling goroutine exits without unlocking the thread,</code></span>
<span class="codeline" id="line-5178"><code>// the thread will be terminated.</code></span>
<span class="codeline" id="line-5179"><code>//</code></span>
<span class="codeline" id="line-5180"><code>// All init functions are run on the startup thread. Calling LockOSThread</code></span>
<span class="codeline" id="line-5181"><code>// from an init function will cause the main function to be invoked on</code></span>
<span class="codeline" id="line-5182"><code>// that thread.</code></span>
<span class="codeline" id="line-5183"><code>//</code></span>
<span class="codeline" id="line-5184"><code>// A goroutine should call LockOSThread before calling OS services or</code></span>
<span class="codeline" id="line-5185"><code>// non-Go library functions that depend on per-thread state.</code></span>
<span class="codeline" id="line-5186"><code>//</code></span>
<span class="codeline" id="line-5187"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5188"><code>func LockOSThread() {</code></span>
<span class="codeline" id="line-5189"><code>	if atomic.Load(&amp;newmHandoff.haveTemplateThread) == 0 &amp;&amp; GOOS != "plan9" {</code></span>
<span class="codeline" id="line-5190"><code>		// If we need to start a new thread from the locked</code></span>
<span class="codeline" id="line-5191"><code>		// thread, we need the template thread. Start it now</code></span>
<span class="codeline" id="line-5192"><code>		// while we're in a known-good state.</code></span>
<span class="codeline" id="line-5193"><code>		startTemplateThread()</code></span>
<span class="codeline" id="line-5194"><code>	}</code></span>
<span class="codeline" id="line-5195"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5196"><code>	gp.m.lockedExt++</code></span>
<span class="codeline" id="line-5197"><code>	if gp.m.lockedExt == 0 {</code></span>
<span class="codeline" id="line-5198"><code>		gp.m.lockedExt--</code></span>
<span class="codeline" id="line-5199"><code>		panic("LockOSThread nesting overflow")</code></span>
<span class="codeline" id="line-5200"><code>	}</code></span>
<span class="codeline" id="line-5201"><code>	dolockOSThread()</code></span>
<span class="codeline" id="line-5202"><code>}</code></span>
<span class="codeline" id="line-5203"><code></code></span>
<span class="codeline" id="line-5204"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5205"><code>func lockOSThread() {</code></span>
<span class="codeline" id="line-5206"><code>	getg().m.lockedInt++</code></span>
<span class="codeline" id="line-5207"><code>	dolockOSThread()</code></span>
<span class="codeline" id="line-5208"><code>}</code></span>
<span class="codeline" id="line-5209"><code></code></span>
<span class="codeline" id="line-5210"><code>// dounlockOSThread is called by UnlockOSThread and unlockOSThread below</code></span>
<span class="codeline" id="line-5211"><code>// after they update m-&gt;locked. Do not allow preemption during this call,</code></span>
<span class="codeline" id="line-5212"><code>// or else the m might be in different in this function than in the caller.</code></span>
<span class="codeline" id="line-5213"><code>//</code></span>
<span class="codeline" id="line-5214"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5215"><code>func dounlockOSThread() {</code></span>
<span class="codeline" id="line-5216"><code>	if GOARCH == "wasm" {</code></span>
<span class="codeline" id="line-5217"><code>		return // no threads on wasm yet</code></span>
<span class="codeline" id="line-5218"><code>	}</code></span>
<span class="codeline" id="line-5219"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5220"><code>	if gp.m.lockedInt != 0 || gp.m.lockedExt != 0 {</code></span>
<span class="codeline" id="line-5221"><code>		return</code></span>
<span class="codeline" id="line-5222"><code>	}</code></span>
<span class="codeline" id="line-5223"><code>	gp.m.lockedg = 0</code></span>
<span class="codeline" id="line-5224"><code>	gp.lockedm = 0</code></span>
<span class="codeline" id="line-5225"><code>}</code></span>
<span class="codeline" id="line-5226"><code></code></span>
<span class="codeline" id="line-5227"><code>// UnlockOSThread undoes an earlier call to LockOSThread.</code></span>
<span class="codeline" id="line-5228"><code>// If this drops the number of active LockOSThread calls on the</code></span>
<span class="codeline" id="line-5229"><code>// calling goroutine to zero, it unwires the calling goroutine from</code></span>
<span class="codeline" id="line-5230"><code>// its fixed operating system thread.</code></span>
<span class="codeline" id="line-5231"><code>// If there are no active LockOSThread calls, this is a no-op.</code></span>
<span class="codeline" id="line-5232"><code>//</code></span>
<span class="codeline" id="line-5233"><code>// Before calling UnlockOSThread, the caller must ensure that the OS</code></span>
<span class="codeline" id="line-5234"><code>// thread is suitable for running other goroutines. If the caller made</code></span>
<span class="codeline" id="line-5235"><code>// any permanent changes to the state of the thread that would affect</code></span>
<span class="codeline" id="line-5236"><code>// other goroutines, it should not call this function and thus leave</code></span>
<span class="codeline" id="line-5237"><code>// the goroutine locked to the OS thread until the goroutine (and</code></span>
<span class="codeline" id="line-5238"><code>// hence the thread) exits.</code></span>
<span class="codeline" id="line-5239"><code>//</code></span>
<span class="codeline" id="line-5240"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5241"><code>func UnlockOSThread() {</code></span>
<span class="codeline" id="line-5242"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5243"><code>	if gp.m.lockedExt == 0 {</code></span>
<span class="codeline" id="line-5244"><code>		return</code></span>
<span class="codeline" id="line-5245"><code>	}</code></span>
<span class="codeline" id="line-5246"><code>	gp.m.lockedExt--</code></span>
<span class="codeline" id="line-5247"><code>	dounlockOSThread()</code></span>
<span class="codeline" id="line-5248"><code>}</code></span>
<span class="codeline" id="line-5249"><code></code></span>
<span class="codeline" id="line-5250"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5251"><code>func unlockOSThread() {</code></span>
<span class="codeline" id="line-5252"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5253"><code>	if gp.m.lockedInt == 0 {</code></span>
<span class="codeline" id="line-5254"><code>		systemstack(badunlockosthread)</code></span>
<span class="codeline" id="line-5255"><code>	}</code></span>
<span class="codeline" id="line-5256"><code>	gp.m.lockedInt--</code></span>
<span class="codeline" id="line-5257"><code>	dounlockOSThread()</code></span>
<span class="codeline" id="line-5258"><code>}</code></span>
<span class="codeline" id="line-5259"><code></code></span>
<span class="codeline" id="line-5260"><code>func badunlockosthread() {</code></span>
<span class="codeline" id="line-5261"><code>	throw("runtime: internal error: misuse of lockOSThread/unlockOSThread")</code></span>
<span class="codeline" id="line-5262"><code>}</code></span>
<span class="codeline" id="line-5263"><code></code></span>
<span class="codeline" id="line-5264"><code>func gcount() int32 {</code></span>
<span class="codeline" id="line-5265"><code>	n := int32(atomic.Loaduintptr(&amp;allglen)) - sched.gFree.n - sched.ngsys.Load()</code></span>
<span class="codeline" id="line-5266"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-5267"><code>		n -= pp.gFree.n</code></span>
<span class="codeline" id="line-5268"><code>	}</code></span>
<span class="codeline" id="line-5269"><code></code></span>
<span class="codeline" id="line-5270"><code>	// All these variables can be changed concurrently, so the result can be inconsistent.</code></span>
<span class="codeline" id="line-5271"><code>	// But at least the current goroutine is running.</code></span>
<span class="codeline" id="line-5272"><code>	if n &lt; 1 {</code></span>
<span class="codeline" id="line-5273"><code>		n = 1</code></span>
<span class="codeline" id="line-5274"><code>	}</code></span>
<span class="codeline" id="line-5275"><code>	return n</code></span>
<span class="codeline" id="line-5276"><code>}</code></span>
<span class="codeline" id="line-5277"><code></code></span>
<span class="codeline" id="line-5278"><code>func mcount() int32 {</code></span>
<span class="codeline" id="line-5279"><code>	return int32(sched.mnext - sched.nmfreed)</code></span>
<span class="codeline" id="line-5280"><code>}</code></span>
<span class="codeline" id="line-5281"><code></code></span>
<span class="codeline" id="line-5282"><code>var prof struct {</code></span>
<span class="codeline" id="line-5283"><code>	signalLock atomic.Uint32</code></span>
<span class="codeline" id="line-5284"><code></code></span>
<span class="codeline" id="line-5285"><code>	// Must hold signalLock to write. Reads may be lock-free, but</code></span>
<span class="codeline" id="line-5286"><code>	// signalLock should be taken to synchronize with changes.</code></span>
<span class="codeline" id="line-5287"><code>	hz atomic.Int32</code></span>
<span class="codeline" id="line-5288"><code>}</code></span>
<span class="codeline" id="line-5289"><code></code></span>
<span class="codeline" id="line-5290"><code>func _System()                    { _System() }</code></span>
<span class="codeline" id="line-5291"><code>func _ExternalCode()              { _ExternalCode() }</code></span>
<span class="codeline" id="line-5292"><code>func _LostExternalCode()          { _LostExternalCode() }</code></span>
<span class="codeline" id="line-5293"><code>func _GC()                        { _GC() }</code></span>
<span class="codeline" id="line-5294"><code>func _LostSIGPROFDuringAtomic64() { _LostSIGPROFDuringAtomic64() }</code></span>
<span class="codeline" id="line-5295"><code>func _LostContendedRuntimeLock()  { _LostContendedRuntimeLock() }</code></span>
<span class="codeline" id="line-5296"><code>func _VDSO()                      { _VDSO() }</code></span>
<span class="codeline" id="line-5297"><code></code></span>
<span class="codeline" id="line-5298"><code>// Called if we receive a SIGPROF signal.</code></span>
<span class="codeline" id="line-5299"><code>// Called by the signal handler, may run during STW.</code></span>
<span class="codeline" id="line-5300"><code>//</code></span>
<span class="codeline" id="line-5301"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5302"><code>func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {</code></span>
<span class="codeline" id="line-5303"><code>	if prof.hz.Load() == 0 {</code></span>
<span class="codeline" id="line-5304"><code>		return</code></span>
<span class="codeline" id="line-5305"><code>	}</code></span>
<span class="codeline" id="line-5306"><code></code></span>
<span class="codeline" id="line-5307"><code>	// If mp.profilehz is 0, then profiling is not enabled for this thread.</code></span>
<span class="codeline" id="line-5308"><code>	// We must check this to avoid a deadlock between setcpuprofilerate</code></span>
<span class="codeline" id="line-5309"><code>	// and the call to cpuprof.add, below.</code></span>
<span class="codeline" id="line-5310"><code>	if mp != nil &amp;&amp; mp.profilehz == 0 {</code></span>
<span class="codeline" id="line-5311"><code>		return</code></span>
<span class="codeline" id="line-5312"><code>	}</code></span>
<span class="codeline" id="line-5313"><code></code></span>
<span class="codeline" id="line-5314"><code>	// On mips{,le}/arm, 64bit atomics are emulated with spinlocks, in</code></span>
<span class="codeline" id="line-5315"><code>	// runtime/internal/atomic. If SIGPROF arrives while the program is inside</code></span>
<span class="codeline" id="line-5316"><code>	// the critical section, it creates a deadlock (when writing the sample).</code></span>
<span class="codeline" id="line-5317"><code>	// As a workaround, create a counter of SIGPROFs while in critical section</code></span>
<span class="codeline" id="line-5318"><code>	// to store the count, and pass it to sigprof.add() later when SIGPROF is</code></span>
<span class="codeline" id="line-5319"><code>	// received from somewhere else (with _LostSIGPROFDuringAtomic64 as pc).</code></span>
<span class="codeline" id="line-5320"><code>	if GOARCH == "mips" || GOARCH == "mipsle" || GOARCH == "arm" {</code></span>
<span class="codeline" id="line-5321"><code>		if f := findfunc(pc); f.valid() {</code></span>
<span class="codeline" id="line-5322"><code>			if hasPrefix(funcname(f), "runtime/internal/atomic") {</code></span>
<span class="codeline" id="line-5323"><code>				cpuprof.lostAtomic++</code></span>
<span class="codeline" id="line-5324"><code>				return</code></span>
<span class="codeline" id="line-5325"><code>			}</code></span>
<span class="codeline" id="line-5326"><code>		}</code></span>
<span class="codeline" id="line-5327"><code>		if GOARCH == "arm" &amp;&amp; goarm &lt; 7 &amp;&amp; GOOS == "linux" &amp;&amp; pc&amp;0xffff0000 == 0xffff0000 {</code></span>
<span class="codeline" id="line-5328"><code>			// runtime/internal/atomic functions call into kernel</code></span>
<span class="codeline" id="line-5329"><code>			// helpers on arm &lt; 7. See</code></span>
<span class="codeline" id="line-5330"><code>			// runtime/internal/atomic/sys_linux_arm.s.</code></span>
<span class="codeline" id="line-5331"><code>			cpuprof.lostAtomic++</code></span>
<span class="codeline" id="line-5332"><code>			return</code></span>
<span class="codeline" id="line-5333"><code>		}</code></span>
<span class="codeline" id="line-5334"><code>	}</code></span>
<span class="codeline" id="line-5335"><code></code></span>
<span class="codeline" id="line-5336"><code>	// Profiling runs concurrently with GC, so it must not allocate.</code></span>
<span class="codeline" id="line-5337"><code>	// Set a trap in case the code does allocate.</code></span>
<span class="codeline" id="line-5338"><code>	// Note that on windows, one thread takes profiles of all the</code></span>
<span class="codeline" id="line-5339"><code>	// other threads, so mp is usually not getg().m.</code></span>
<span class="codeline" id="line-5340"><code>	// In fact mp may not even be stopped.</code></span>
<span class="codeline" id="line-5341"><code>	// See golang.org/issue/17165.</code></span>
<span class="codeline" id="line-5342"><code>	getg().m.mallocing++</code></span>
<span class="codeline" id="line-5343"><code></code></span>
<span class="codeline" id="line-5344"><code>	var u unwinder</code></span>
<span class="codeline" id="line-5345"><code>	var stk [maxCPUProfStack]uintptr</code></span>
<span class="codeline" id="line-5346"><code>	n := 0</code></span>
<span class="codeline" id="line-5347"><code>	if mp.ncgo &gt; 0 &amp;&amp; mp.curg != nil &amp;&amp; mp.curg.syscallpc != 0 &amp;&amp; mp.curg.syscallsp != 0 {</code></span>
<span class="codeline" id="line-5348"><code>		cgoOff := 0</code></span>
<span class="codeline" id="line-5349"><code>		// Check cgoCallersUse to make sure that we are not</code></span>
<span class="codeline" id="line-5350"><code>		// interrupting other code that is fiddling with</code></span>
<span class="codeline" id="line-5351"><code>		// cgoCallers.  We are running in a signal handler</code></span>
<span class="codeline" id="line-5352"><code>		// with all signals blocked, so we don't have to worry</code></span>
<span class="codeline" id="line-5353"><code>		// about any other code interrupting us.</code></span>
<span class="codeline" id="line-5354"><code>		if mp.cgoCallersUse.Load() == 0 &amp;&amp; mp.cgoCallers != nil &amp;&amp; mp.cgoCallers[0] != 0 {</code></span>
<span class="codeline" id="line-5355"><code>			for cgoOff &lt; len(mp.cgoCallers) &amp;&amp; mp.cgoCallers[cgoOff] != 0 {</code></span>
<span class="codeline" id="line-5356"><code>				cgoOff++</code></span>
<span class="codeline" id="line-5357"><code>			}</code></span>
<span class="codeline" id="line-5358"><code>			n += copy(stk[:], mp.cgoCallers[:cgoOff])</code></span>
<span class="codeline" id="line-5359"><code>			mp.cgoCallers[0] = 0</code></span>
<span class="codeline" id="line-5360"><code>		}</code></span>
<span class="codeline" id="line-5361"><code></code></span>
<span class="codeline" id="line-5362"><code>		// Collect Go stack that leads to the cgo call.</code></span>
<span class="codeline" id="line-5363"><code>		u.initAt(mp.curg.syscallpc, mp.curg.syscallsp, 0, mp.curg, unwindSilentErrors)</code></span>
<span class="codeline" id="line-5364"><code>	} else if usesLibcall() &amp;&amp; mp.libcallg != 0 &amp;&amp; mp.libcallpc != 0 &amp;&amp; mp.libcallsp != 0 {</code></span>
<span class="codeline" id="line-5365"><code>		// Libcall, i.e. runtime syscall on windows.</code></span>
<span class="codeline" id="line-5366"><code>		// Collect Go stack that leads to the call.</code></span>
<span class="codeline" id="line-5367"><code>		u.initAt(mp.libcallpc, mp.libcallsp, 0, mp.libcallg.ptr(), unwindSilentErrors)</code></span>
<span class="codeline" id="line-5368"><code>	} else if mp != nil &amp;&amp; mp.vdsoSP != 0 {</code></span>
<span class="codeline" id="line-5369"><code>		// VDSO call, e.g. nanotime1 on Linux.</code></span>
<span class="codeline" id="line-5370"><code>		// Collect Go stack that leads to the call.</code></span>
<span class="codeline" id="line-5371"><code>		u.initAt(mp.vdsoPC, mp.vdsoSP, 0, gp, unwindSilentErrors|unwindJumpStack)</code></span>
<span class="codeline" id="line-5372"><code>	} else {</code></span>
<span class="codeline" id="line-5373"><code>		u.initAt(pc, sp, lr, gp, unwindSilentErrors|unwindTrap|unwindJumpStack)</code></span>
<span class="codeline" id="line-5374"><code>	}</code></span>
<span class="codeline" id="line-5375"><code>	n += tracebackPCs(&amp;u, 0, stk[n:])</code></span>
<span class="codeline" id="line-5376"><code></code></span>
<span class="codeline" id="line-5377"><code>	if n &lt;= 0 {</code></span>
<span class="codeline" id="line-5378"><code>		// Normal traceback is impossible or has failed.</code></span>
<span class="codeline" id="line-5379"><code>		// Account it against abstract "System" or "GC".</code></span>
<span class="codeline" id="line-5380"><code>		n = 2</code></span>
<span class="codeline" id="line-5381"><code>		if inVDSOPage(pc) {</code></span>
<span class="codeline" id="line-5382"><code>			pc = abi.FuncPCABIInternal(_VDSO) + sys.PCQuantum</code></span>
<span class="codeline" id="line-5383"><code>		} else if pc &gt; firstmoduledata.etext {</code></span>
<span class="codeline" id="line-5384"><code>			// "ExternalCode" is better than "etext".</code></span>
<span class="codeline" id="line-5385"><code>			pc = abi.FuncPCABIInternal(_ExternalCode) + sys.PCQuantum</code></span>
<span class="codeline" id="line-5386"><code>		}</code></span>
<span class="codeline" id="line-5387"><code>		stk[0] = pc</code></span>
<span class="codeline" id="line-5388"><code>		if mp.preemptoff != "" {</code></span>
<span class="codeline" id="line-5389"><code>			stk[1] = abi.FuncPCABIInternal(_GC) + sys.PCQuantum</code></span>
<span class="codeline" id="line-5390"><code>		} else {</code></span>
<span class="codeline" id="line-5391"><code>			stk[1] = abi.FuncPCABIInternal(_System) + sys.PCQuantum</code></span>
<span class="codeline" id="line-5392"><code>		}</code></span>
<span class="codeline" id="line-5393"><code>	}</code></span>
<span class="codeline" id="line-5394"><code></code></span>
<span class="codeline" id="line-5395"><code>	if prof.hz.Load() != 0 {</code></span>
<span class="codeline" id="line-5396"><code>		// Note: it can happen on Windows that we interrupted a system thread</code></span>
<span class="codeline" id="line-5397"><code>		// with no g, so gp could nil. The other nil checks are done out of</code></span>
<span class="codeline" id="line-5398"><code>		// caution, but not expected to be nil in practice.</code></span>
<span class="codeline" id="line-5399"><code>		var tagPtr *unsafe.Pointer</code></span>
<span class="codeline" id="line-5400"><code>		if gp != nil &amp;&amp; gp.m != nil &amp;&amp; gp.m.curg != nil {</code></span>
<span class="codeline" id="line-5401"><code>			tagPtr = &amp;gp.m.curg.labels</code></span>
<span class="codeline" id="line-5402"><code>		}</code></span>
<span class="codeline" id="line-5403"><code>		cpuprof.add(tagPtr, stk[:n])</code></span>
<span class="codeline" id="line-5404"><code></code></span>
<span class="codeline" id="line-5405"><code>		gprof := gp</code></span>
<span class="codeline" id="line-5406"><code>		var mp *m</code></span>
<span class="codeline" id="line-5407"><code>		var pp *p</code></span>
<span class="codeline" id="line-5408"><code>		if gp != nil &amp;&amp; gp.m != nil {</code></span>
<span class="codeline" id="line-5409"><code>			if gp.m.curg != nil {</code></span>
<span class="codeline" id="line-5410"><code>				gprof = gp.m.curg</code></span>
<span class="codeline" id="line-5411"><code>			}</code></span>
<span class="codeline" id="line-5412"><code>			mp = gp.m</code></span>
<span class="codeline" id="line-5413"><code>			pp = gp.m.p.ptr()</code></span>
<span class="codeline" id="line-5414"><code>		}</code></span>
<span class="codeline" id="line-5415"><code>		traceCPUSample(gprof, mp, pp, stk[:n])</code></span>
<span class="codeline" id="line-5416"><code>	}</code></span>
<span class="codeline" id="line-5417"><code>	getg().m.mallocing--</code></span>
<span class="codeline" id="line-5418"><code>}</code></span>
<span class="codeline" id="line-5419"><code></code></span>
<span class="codeline" id="line-5420"><code>// setcpuprofilerate sets the CPU profiling rate to hz times per second.</code></span>
<span class="codeline" id="line-5421"><code>// If hz &lt;= 0, setcpuprofilerate turns off CPU profiling.</code></span>
<span class="codeline" id="line-5422"><code>func setcpuprofilerate(hz int32) {</code></span>
<span class="codeline" id="line-5423"><code>	// Force sane arguments.</code></span>
<span class="codeline" id="line-5424"><code>	if hz &lt; 0 {</code></span>
<span class="codeline" id="line-5425"><code>		hz = 0</code></span>
<span class="codeline" id="line-5426"><code>	}</code></span>
<span class="codeline" id="line-5427"><code></code></span>
<span class="codeline" id="line-5428"><code>	// Disable preemption, otherwise we can be rescheduled to another thread</code></span>
<span class="codeline" id="line-5429"><code>	// that has profiling enabled.</code></span>
<span class="codeline" id="line-5430"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5431"><code>	gp.m.locks++</code></span>
<span class="codeline" id="line-5432"><code></code></span>
<span class="codeline" id="line-5433"><code>	// Stop profiler on this thread so that it is safe to lock prof.</code></span>
<span class="codeline" id="line-5434"><code>	// if a profiling signal came in while we had prof locked,</code></span>
<span class="codeline" id="line-5435"><code>	// it would deadlock.</code></span>
<span class="codeline" id="line-5436"><code>	setThreadCPUProfiler(0)</code></span>
<span class="codeline" id="line-5437"><code></code></span>
<span class="codeline" id="line-5438"><code>	for !prof.signalLock.CompareAndSwap(0, 1) {</code></span>
<span class="codeline" id="line-5439"><code>		osyield()</code></span>
<span class="codeline" id="line-5440"><code>	}</code></span>
<span class="codeline" id="line-5441"><code>	if prof.hz.Load() != hz {</code></span>
<span class="codeline" id="line-5442"><code>		setProcessCPUProfiler(hz)</code></span>
<span class="codeline" id="line-5443"><code>		prof.hz.Store(hz)</code></span>
<span class="codeline" id="line-5444"><code>	}</code></span>
<span class="codeline" id="line-5445"><code>	prof.signalLock.Store(0)</code></span>
<span class="codeline" id="line-5446"><code></code></span>
<span class="codeline" id="line-5447"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5448"><code>	sched.profilehz = hz</code></span>
<span class="codeline" id="line-5449"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5450"><code></code></span>
<span class="codeline" id="line-5451"><code>	if hz != 0 {</code></span>
<span class="codeline" id="line-5452"><code>		setThreadCPUProfiler(hz)</code></span>
<span class="codeline" id="line-5453"><code>	}</code></span>
<span class="codeline" id="line-5454"><code></code></span>
<span class="codeline" id="line-5455"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-5456"><code>}</code></span>
<span class="codeline" id="line-5457"><code></code></span>
<span class="codeline" id="line-5458"><code>// init initializes pp, which may be a freshly allocated p or a</code></span>
<span class="codeline" id="line-5459"><code>// previously destroyed p, and transitions it to status _Pgcstop.</code></span>
<span class="codeline" id="line-5460"><code>func (pp *p) init(id int32) {</code></span>
<span class="codeline" id="line-5461"><code>	pp.id = id</code></span>
<span class="codeline" id="line-5462"><code>	pp.status = _Pgcstop</code></span>
<span class="codeline" id="line-5463"><code>	pp.sudogcache = pp.sudogbuf[:0]</code></span>
<span class="codeline" id="line-5464"><code>	pp.deferpool = pp.deferpoolbuf[:0]</code></span>
<span class="codeline" id="line-5465"><code>	pp.wbBuf.reset()</code></span>
<span class="codeline" id="line-5466"><code>	if pp.mcache == nil {</code></span>
<span class="codeline" id="line-5467"><code>		if id == 0 {</code></span>
<span class="codeline" id="line-5468"><code>			if mcache0 == nil {</code></span>
<span class="codeline" id="line-5469"><code>				throw("missing mcache?")</code></span>
<span class="codeline" id="line-5470"><code>			}</code></span>
<span class="codeline" id="line-5471"><code>			// Use the bootstrap mcache0. Only one P will get</code></span>
<span class="codeline" id="line-5472"><code>			// mcache0: the one with ID 0.</code></span>
<span class="codeline" id="line-5473"><code>			pp.mcache = mcache0</code></span>
<span class="codeline" id="line-5474"><code>		} else {</code></span>
<span class="codeline" id="line-5475"><code>			pp.mcache = allocmcache()</code></span>
<span class="codeline" id="line-5476"><code>		}</code></span>
<span class="codeline" id="line-5477"><code>	}</code></span>
<span class="codeline" id="line-5478"><code>	if raceenabled &amp;&amp; pp.raceprocctx == 0 {</code></span>
<span class="codeline" id="line-5479"><code>		if id == 0 {</code></span>
<span class="codeline" id="line-5480"><code>			pp.raceprocctx = raceprocctx0</code></span>
<span class="codeline" id="line-5481"><code>			raceprocctx0 = 0 // bootstrap</code></span>
<span class="codeline" id="line-5482"><code>		} else {</code></span>
<span class="codeline" id="line-5483"><code>			pp.raceprocctx = raceproccreate()</code></span>
<span class="codeline" id="line-5484"><code>		}</code></span>
<span class="codeline" id="line-5485"><code>	}</code></span>
<span class="codeline" id="line-5486"><code>	lockInit(&amp;pp.timersLock, lockRankTimers)</code></span>
<span class="codeline" id="line-5487"><code></code></span>
<span class="codeline" id="line-5488"><code>	// This P may get timers when it starts running. Set the mask here</code></span>
<span class="codeline" id="line-5489"><code>	// since the P may not go through pidleget (notably P 0 on startup).</code></span>
<span class="codeline" id="line-5490"><code>	timerpMask.set(id)</code></span>
<span class="codeline" id="line-5491"><code>	// Similarly, we may not go through pidleget before this P starts</code></span>
<span class="codeline" id="line-5492"><code>	// running if it is P 0 on startup.</code></span>
<span class="codeline" id="line-5493"><code>	idlepMask.clear(id)</code></span>
<span class="codeline" id="line-5494"><code>}</code></span>
<span class="codeline" id="line-5495"><code></code></span>
<span class="codeline" id="line-5496"><code>// destroy releases all of the resources associated with pp and</code></span>
<span class="codeline" id="line-5497"><code>// transitions it to status _Pdead.</code></span>
<span class="codeline" id="line-5498"><code>//</code></span>
<span class="codeline" id="line-5499"><code>// sched.lock must be held and the world must be stopped.</code></span>
<span class="codeline" id="line-5500"><code>func (pp *p) destroy() {</code></span>
<span class="codeline" id="line-5501"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5502"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-5503"><code></code></span>
<span class="codeline" id="line-5504"><code>	// Move all runnable goroutines to the global queue</code></span>
<span class="codeline" id="line-5505"><code>	for pp.runqhead != pp.runqtail {</code></span>
<span class="codeline" id="line-5506"><code>		// Pop from tail of local queue</code></span>
<span class="codeline" id="line-5507"><code>		pp.runqtail--</code></span>
<span class="codeline" id="line-5508"><code>		gp := pp.runq[pp.runqtail%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-5509"><code>		// Push onto head of global queue</code></span>
<span class="codeline" id="line-5510"><code>		globrunqputhead(gp)</code></span>
<span class="codeline" id="line-5511"><code>	}</code></span>
<span class="codeline" id="line-5512"><code>	if pp.runnext != 0 {</code></span>
<span class="codeline" id="line-5513"><code>		globrunqputhead(pp.runnext.ptr())</code></span>
<span class="codeline" id="line-5514"><code>		pp.runnext = 0</code></span>
<span class="codeline" id="line-5515"><code>	}</code></span>
<span class="codeline" id="line-5516"><code>	if len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-5517"><code>		plocal := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-5518"><code>		// The world is stopped, but we acquire timersLock to</code></span>
<span class="codeline" id="line-5519"><code>		// protect against sysmon calling timeSleepUntil.</code></span>
<span class="codeline" id="line-5520"><code>		// This is the only case where we hold the timersLock of</code></span>
<span class="codeline" id="line-5521"><code>		// more than one P, so there are no deadlock concerns.</code></span>
<span class="codeline" id="line-5522"><code>		lock(&amp;plocal.timersLock)</code></span>
<span class="codeline" id="line-5523"><code>		lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-5524"><code>		moveTimers(plocal, pp.timers)</code></span>
<span class="codeline" id="line-5525"><code>		pp.timers = nil</code></span>
<span class="codeline" id="line-5526"><code>		pp.numTimers.Store(0)</code></span>
<span class="codeline" id="line-5527"><code>		pp.deletedTimers.Store(0)</code></span>
<span class="codeline" id="line-5528"><code>		pp.timer0When.Store(0)</code></span>
<span class="codeline" id="line-5529"><code>		unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-5530"><code>		unlock(&amp;plocal.timersLock)</code></span>
<span class="codeline" id="line-5531"><code>	}</code></span>
<span class="codeline" id="line-5532"><code>	// Flush p's write barrier buffer.</code></span>
<span class="codeline" id="line-5533"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-5534"><code>		wbBufFlush1(pp)</code></span>
<span class="codeline" id="line-5535"><code>		pp.gcw.dispose()</code></span>
<span class="codeline" id="line-5536"><code>	}</code></span>
<span class="codeline" id="line-5537"><code>	for i := range pp.sudogbuf {</code></span>
<span class="codeline" id="line-5538"><code>		pp.sudogbuf[i] = nil</code></span>
<span class="codeline" id="line-5539"><code>	}</code></span>
<span class="codeline" id="line-5540"><code>	pp.sudogcache = pp.sudogbuf[:0]</code></span>
<span class="codeline" id="line-5541"><code>	pp.pinnerCache = nil</code></span>
<span class="codeline" id="line-5542"><code>	for j := range pp.deferpoolbuf {</code></span>
<span class="codeline" id="line-5543"><code>		pp.deferpoolbuf[j] = nil</code></span>
<span class="codeline" id="line-5544"><code>	}</code></span>
<span class="codeline" id="line-5545"><code>	pp.deferpool = pp.deferpoolbuf[:0]</code></span>
<span class="codeline" id="line-5546"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-5547"><code>		for i := 0; i &lt; pp.mspancache.len; i++ {</code></span>
<span class="codeline" id="line-5548"><code>			// Safe to call since the world is stopped.</code></span>
<span class="codeline" id="line-5549"><code>			mheap_.spanalloc.free(unsafe.Pointer(pp.mspancache.buf[i]))</code></span>
<span class="codeline" id="line-5550"><code>		}</code></span>
<span class="codeline" id="line-5551"><code>		pp.mspancache.len = 0</code></span>
<span class="codeline" id="line-5552"><code>		lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-5553"><code>		pp.pcache.flush(&amp;mheap_.pages)</code></span>
<span class="codeline" id="line-5554"><code>		unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-5555"><code>	})</code></span>
<span class="codeline" id="line-5556"><code>	freemcache(pp.mcache)</code></span>
<span class="codeline" id="line-5557"><code>	pp.mcache = nil</code></span>
<span class="codeline" id="line-5558"><code>	gfpurge(pp)</code></span>
<span class="codeline" id="line-5559"><code>	traceProcFree(pp)</code></span>
<span class="codeline" id="line-5560"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-5561"><code>		if pp.timerRaceCtx != 0 {</code></span>
<span class="codeline" id="line-5562"><code>			// The race detector code uses a callback to fetch</code></span>
<span class="codeline" id="line-5563"><code>			// the proc context, so arrange for that callback</code></span>
<span class="codeline" id="line-5564"><code>			// to see the right thing.</code></span>
<span class="codeline" id="line-5565"><code>			// This hack only works because we are the only</code></span>
<span class="codeline" id="line-5566"><code>			// thread running.</code></span>
<span class="codeline" id="line-5567"><code>			mp := getg().m</code></span>
<span class="codeline" id="line-5568"><code>			phold := mp.p.ptr()</code></span>
<span class="codeline" id="line-5569"><code>			mp.p.set(pp)</code></span>
<span class="codeline" id="line-5570"><code></code></span>
<span class="codeline" id="line-5571"><code>			racectxend(pp.timerRaceCtx)</code></span>
<span class="codeline" id="line-5572"><code>			pp.timerRaceCtx = 0</code></span>
<span class="codeline" id="line-5573"><code></code></span>
<span class="codeline" id="line-5574"><code>			mp.p.set(phold)</code></span>
<span class="codeline" id="line-5575"><code>		}</code></span>
<span class="codeline" id="line-5576"><code>		raceprocdestroy(pp.raceprocctx)</code></span>
<span class="codeline" id="line-5577"><code>		pp.raceprocctx = 0</code></span>
<span class="codeline" id="line-5578"><code>	}</code></span>
<span class="codeline" id="line-5579"><code>	pp.gcAssistTime = 0</code></span>
<span class="codeline" id="line-5580"><code>	pp.status = _Pdead</code></span>
<span class="codeline" id="line-5581"><code>}</code></span>
<span class="codeline" id="line-5582"><code></code></span>
<span class="codeline" id="line-5583"><code>// Change number of processors.</code></span>
<span class="codeline" id="line-5584"><code>//</code></span>
<span class="codeline" id="line-5585"><code>// sched.lock must be held, and the world must be stopped.</code></span>
<span class="codeline" id="line-5586"><code>//</code></span>
<span class="codeline" id="line-5587"><code>// gcworkbufs must not be being modified by either the GC or the write barrier</code></span>
<span class="codeline" id="line-5588"><code>// code, so the GC must not be running if the number of Ps actually changes.</code></span>
<span class="codeline" id="line-5589"><code>//</code></span>
<span class="codeline" id="line-5590"><code>// Returns list of Ps with local work, they need to be scheduled by the caller.</code></span>
<span class="codeline" id="line-5591"><code>func procresize(nprocs int32) *p {</code></span>
<span class="codeline" id="line-5592"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5593"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-5594"><code></code></span>
<span class="codeline" id="line-5595"><code>	old := gomaxprocs</code></span>
<span class="codeline" id="line-5596"><code>	if old &lt; 0 || nprocs &lt;= 0 {</code></span>
<span class="codeline" id="line-5597"><code>		throw("procresize: invalid arg")</code></span>
<span class="codeline" id="line-5598"><code>	}</code></span>
<span class="codeline" id="line-5599"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-5600"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-5601"><code>		trace.Gomaxprocs(nprocs)</code></span>
<span class="codeline" id="line-5602"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-5603"><code>	}</code></span>
<span class="codeline" id="line-5604"><code></code></span>
<span class="codeline" id="line-5605"><code>	// update statistics</code></span>
<span class="codeline" id="line-5606"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-5607"><code>	if sched.procresizetime != 0 {</code></span>
<span class="codeline" id="line-5608"><code>		sched.totaltime += int64(old) * (now - sched.procresizetime)</code></span>
<span class="codeline" id="line-5609"><code>	}</code></span>
<span class="codeline" id="line-5610"><code>	sched.procresizetime = now</code></span>
<span class="codeline" id="line-5611"><code></code></span>
<span class="codeline" id="line-5612"><code>	maskWords := (nprocs + 31) / 32</code></span>
<span class="codeline" id="line-5613"><code></code></span>
<span class="codeline" id="line-5614"><code>	// Grow allp if necessary.</code></span>
<span class="codeline" id="line-5615"><code>	if nprocs &gt; int32(len(allp)) {</code></span>
<span class="codeline" id="line-5616"><code>		// Synchronize with retake, which could be running</code></span>
<span class="codeline" id="line-5617"><code>		// concurrently since it doesn't run on a P.</code></span>
<span class="codeline" id="line-5618"><code>		lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-5619"><code>		if nprocs &lt;= int32(cap(allp)) {</code></span>
<span class="codeline" id="line-5620"><code>			allp = allp[:nprocs]</code></span>
<span class="codeline" id="line-5621"><code>		} else {</code></span>
<span class="codeline" id="line-5622"><code>			nallp := make([]*p, nprocs)</code></span>
<span class="codeline" id="line-5623"><code>			// Copy everything up to allp's cap so we</code></span>
<span class="codeline" id="line-5624"><code>			// never lose old allocated Ps.</code></span>
<span class="codeline" id="line-5625"><code>			copy(nallp, allp[:cap(allp)])</code></span>
<span class="codeline" id="line-5626"><code>			allp = nallp</code></span>
<span class="codeline" id="line-5627"><code>		}</code></span>
<span class="codeline" id="line-5628"><code></code></span>
<span class="codeline" id="line-5629"><code>		if maskWords &lt;= int32(cap(idlepMask)) {</code></span>
<span class="codeline" id="line-5630"><code>			idlepMask = idlepMask[:maskWords]</code></span>
<span class="codeline" id="line-5631"><code>			timerpMask = timerpMask[:maskWords]</code></span>
<span class="codeline" id="line-5632"><code>		} else {</code></span>
<span class="codeline" id="line-5633"><code>			nidlepMask := make([]uint32, maskWords)</code></span>
<span class="codeline" id="line-5634"><code>			// No need to copy beyond len, old Ps are irrelevant.</code></span>
<span class="codeline" id="line-5635"><code>			copy(nidlepMask, idlepMask)</code></span>
<span class="codeline" id="line-5636"><code>			idlepMask = nidlepMask</code></span>
<span class="codeline" id="line-5637"><code></code></span>
<span class="codeline" id="line-5638"><code>			ntimerpMask := make([]uint32, maskWords)</code></span>
<span class="codeline" id="line-5639"><code>			copy(ntimerpMask, timerpMask)</code></span>
<span class="codeline" id="line-5640"><code>			timerpMask = ntimerpMask</code></span>
<span class="codeline" id="line-5641"><code>		}</code></span>
<span class="codeline" id="line-5642"><code>		unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-5643"><code>	}</code></span>
<span class="codeline" id="line-5644"><code></code></span>
<span class="codeline" id="line-5645"><code>	// initialize new P's</code></span>
<span class="codeline" id="line-5646"><code>	for i := old; i &lt; nprocs; i++ {</code></span>
<span class="codeline" id="line-5647"><code>		pp := allp[i]</code></span>
<span class="codeline" id="line-5648"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-5649"><code>			pp = new(p)</code></span>
<span class="codeline" id="line-5650"><code>		}</code></span>
<span class="codeline" id="line-5651"><code>		pp.init(i)</code></span>
<span class="codeline" id="line-5652"><code>		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</code></span>
<span class="codeline" id="line-5653"><code>	}</code></span>
<span class="codeline" id="line-5654"><code></code></span>
<span class="codeline" id="line-5655"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5656"><code>	if gp.m.p != 0 &amp;&amp; gp.m.p.ptr().id &lt; nprocs {</code></span>
<span class="codeline" id="line-5657"><code>		// continue to use the current P</code></span>
<span class="codeline" id="line-5658"><code>		gp.m.p.ptr().status = _Prunning</code></span>
<span class="codeline" id="line-5659"><code>		gp.m.p.ptr().mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-5660"><code>	} else {</code></span>
<span class="codeline" id="line-5661"><code>		// release the current P and acquire allp[0].</code></span>
<span class="codeline" id="line-5662"><code>		//</code></span>
<span class="codeline" id="line-5663"><code>		// We must do this before destroying our current P</code></span>
<span class="codeline" id="line-5664"><code>		// because p.destroy itself has write barriers, so we</code></span>
<span class="codeline" id="line-5665"><code>		// need to do that from a valid P.</code></span>
<span class="codeline" id="line-5666"><code>		if gp.m.p != 0 {</code></span>
<span class="codeline" id="line-5667"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-5668"><code>			if trace.ok() {</code></span>
<span class="codeline" id="line-5669"><code>				// Pretend that we were descheduled</code></span>
<span class="codeline" id="line-5670"><code>				// and then scheduled again to keep</code></span>
<span class="codeline" id="line-5671"><code>				// the trace sane.</code></span>
<span class="codeline" id="line-5672"><code>				trace.GoSched()</code></span>
<span class="codeline" id="line-5673"><code>				trace.ProcStop(gp.m.p.ptr())</code></span>
<span class="codeline" id="line-5674"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-5675"><code>			}</code></span>
<span class="codeline" id="line-5676"><code>			gp.m.p.ptr().m = 0</code></span>
<span class="codeline" id="line-5677"><code>		}</code></span>
<span class="codeline" id="line-5678"><code>		gp.m.p = 0</code></span>
<span class="codeline" id="line-5679"><code>		pp := allp[0]</code></span>
<span class="codeline" id="line-5680"><code>		pp.m = 0</code></span>
<span class="codeline" id="line-5681"><code>		pp.status = _Pidle</code></span>
<span class="codeline" id="line-5682"><code>		acquirep(pp)</code></span>
<span class="codeline" id="line-5683"><code>		trace := traceAcquire()</code></span>
<span class="codeline" id="line-5684"><code>		if trace.ok() {</code></span>
<span class="codeline" id="line-5685"><code>			trace.GoStart()</code></span>
<span class="codeline" id="line-5686"><code>			traceRelease(trace)</code></span>
<span class="codeline" id="line-5687"><code>		}</code></span>
<span class="codeline" id="line-5688"><code>	}</code></span>
<span class="codeline" id="line-5689"><code></code></span>
<span class="codeline" id="line-5690"><code>	// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</code></span>
<span class="codeline" id="line-5691"><code>	mcache0 = nil</code></span>
<span class="codeline" id="line-5692"><code></code></span>
<span class="codeline" id="line-5693"><code>	// release resources from unused P's</code></span>
<span class="codeline" id="line-5694"><code>	for i := nprocs; i &lt; old; i++ {</code></span>
<span class="codeline" id="line-5695"><code>		pp := allp[i]</code></span>
<span class="codeline" id="line-5696"><code>		pp.destroy()</code></span>
<span class="codeline" id="line-5697"><code>		// can't free P itself because it can be referenced by an M in syscall</code></span>
<span class="codeline" id="line-5698"><code>	}</code></span>
<span class="codeline" id="line-5699"><code></code></span>
<span class="codeline" id="line-5700"><code>	// Trim allp.</code></span>
<span class="codeline" id="line-5701"><code>	if int32(len(allp)) != nprocs {</code></span>
<span class="codeline" id="line-5702"><code>		lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-5703"><code>		allp = allp[:nprocs]</code></span>
<span class="codeline" id="line-5704"><code>		idlepMask = idlepMask[:maskWords]</code></span>
<span class="codeline" id="line-5705"><code>		timerpMask = timerpMask[:maskWords]</code></span>
<span class="codeline" id="line-5706"><code>		unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-5707"><code>	}</code></span>
<span class="codeline" id="line-5708"><code></code></span>
<span class="codeline" id="line-5709"><code>	var runnablePs *p</code></span>
<span class="codeline" id="line-5710"><code>	for i := nprocs - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-5711"><code>		pp := allp[i]</code></span>
<span class="codeline" id="line-5712"><code>		if gp.m.p.ptr() == pp {</code></span>
<span class="codeline" id="line-5713"><code>			continue</code></span>
<span class="codeline" id="line-5714"><code>		}</code></span>
<span class="codeline" id="line-5715"><code>		pp.status = _Pidle</code></span>
<span class="codeline" id="line-5716"><code>		if runqempty(pp) {</code></span>
<span class="codeline" id="line-5717"><code>			pidleput(pp, now)</code></span>
<span class="codeline" id="line-5718"><code>		} else {</code></span>
<span class="codeline" id="line-5719"><code>			pp.m.set(mget())</code></span>
<span class="codeline" id="line-5720"><code>			pp.link.set(runnablePs)</code></span>
<span class="codeline" id="line-5721"><code>			runnablePs = pp</code></span>
<span class="codeline" id="line-5722"><code>		}</code></span>
<span class="codeline" id="line-5723"><code>	}</code></span>
<span class="codeline" id="line-5724"><code>	stealOrder.reset(uint32(nprocs))</code></span>
<span class="codeline" id="line-5725"><code>	var int32p *int32 = &amp;gomaxprocs // make compiler check that gomaxprocs is an int32</code></span>
<span class="codeline" id="line-5726"><code>	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))</code></span>
<span class="codeline" id="line-5727"><code>	if old != nprocs {</code></span>
<span class="codeline" id="line-5728"><code>		// Notify the limiter that the amount of procs has changed.</code></span>
<span class="codeline" id="line-5729"><code>		gcCPULimiter.resetCapacity(now, nprocs)</code></span>
<span class="codeline" id="line-5730"><code>	}</code></span>
<span class="codeline" id="line-5731"><code>	return runnablePs</code></span>
<span class="codeline" id="line-5732"><code>}</code></span>
<span class="codeline" id="line-5733"><code></code></span>
<span class="codeline" id="line-5734"><code>// Associate p and the current m.</code></span>
<span class="codeline" id="line-5735"><code>//</code></span>
<span class="codeline" id="line-5736"><code>// This function is allowed to have write barriers even if the caller</code></span>
<span class="codeline" id="line-5737"><code>// isn't because it immediately acquires pp.</code></span>
<span class="codeline" id="line-5738"><code>//</code></span>
<span class="codeline" id="line-5739"><code>//go:yeswritebarrierrec</code></span>
<span class="codeline" id="line-5740"><code>func acquirep(pp *p) {</code></span>
<span class="codeline" id="line-5741"><code>	// Do the part that isn't allowed to have write barriers.</code></span>
<span class="codeline" id="line-5742"><code>	wirep(pp)</code></span>
<span class="codeline" id="line-5743"><code></code></span>
<span class="codeline" id="line-5744"><code>	// Have p; write barriers now allowed.</code></span>
<span class="codeline" id="line-5745"><code></code></span>
<span class="codeline" id="line-5746"><code>	// Perform deferred mcache flush before this P can allocate</code></span>
<span class="codeline" id="line-5747"><code>	// from a potentially stale mcache.</code></span>
<span class="codeline" id="line-5748"><code>	pp.mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-5749"><code></code></span>
<span class="codeline" id="line-5750"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-5751"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-5752"><code>		trace.ProcStart()</code></span>
<span class="codeline" id="line-5753"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-5754"><code>	}</code></span>
<span class="codeline" id="line-5755"><code>}</code></span>
<span class="codeline" id="line-5756"><code></code></span>
<span class="codeline" id="line-5757"><code>// wirep is the first step of acquirep, which actually associates the</code></span>
<span class="codeline" id="line-5758"><code>// current M to pp. This is broken out so we can disallow write</code></span>
<span class="codeline" id="line-5759"><code>// barriers for this part, since we don't yet have a P.</code></span>
<span class="codeline" id="line-5760"><code>//</code></span>
<span class="codeline" id="line-5761"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5762"><code>//go:nosplit</code></span>
<span class="codeline" id="line-5763"><code>func wirep(pp *p) {</code></span>
<span class="codeline" id="line-5764"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5765"><code></code></span>
<span class="codeline" id="line-5766"><code>	if gp.m.p != 0 {</code></span>
<span class="codeline" id="line-5767"><code>		// Call on the systemstack to avoid a nosplit overflow build failure</code></span>
<span class="codeline" id="line-5768"><code>		// on some platforms when built with -N -l. See #64113.</code></span>
<span class="codeline" id="line-5769"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-5770"><code>			throw("wirep: already in go")</code></span>
<span class="codeline" id="line-5771"><code>		})</code></span>
<span class="codeline" id="line-5772"><code>	}</code></span>
<span class="codeline" id="line-5773"><code>	if pp.m != 0 || pp.status != _Pidle {</code></span>
<span class="codeline" id="line-5774"><code>		// Call on the systemstack to avoid a nosplit overflow build failure</code></span>
<span class="codeline" id="line-5775"><code>		// on some platforms when built with -N -l. See #64113.</code></span>
<span class="codeline" id="line-5776"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-5777"><code>			id := int64(0)</code></span>
<span class="codeline" id="line-5778"><code>			if pp.m != 0 {</code></span>
<span class="codeline" id="line-5779"><code>				id = pp.m.ptr().id</code></span>
<span class="codeline" id="line-5780"><code>			}</code></span>
<span class="codeline" id="line-5781"><code>			print("wirep: p-&gt;m=", pp.m, "(", id, ") p-&gt;status=", pp.status, "\n")</code></span>
<span class="codeline" id="line-5782"><code>			throw("wirep: invalid p state")</code></span>
<span class="codeline" id="line-5783"><code>		})</code></span>
<span class="codeline" id="line-5784"><code>	}</code></span>
<span class="codeline" id="line-5785"><code>	gp.m.p.set(pp)</code></span>
<span class="codeline" id="line-5786"><code>	pp.m.set(gp.m)</code></span>
<span class="codeline" id="line-5787"><code>	pp.status = _Prunning</code></span>
<span class="codeline" id="line-5788"><code>}</code></span>
<span class="codeline" id="line-5789"><code></code></span>
<span class="codeline" id="line-5790"><code>// Disassociate p and the current m.</code></span>
<span class="codeline" id="line-5791"><code>func releasep() *p {</code></span>
<span class="codeline" id="line-5792"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-5793"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-5794"><code>		trace.ProcStop(getg().m.p.ptr())</code></span>
<span class="codeline" id="line-5795"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-5796"><code>	}</code></span>
<span class="codeline" id="line-5797"><code>	return releasepNoTrace()</code></span>
<span class="codeline" id="line-5798"><code>}</code></span>
<span class="codeline" id="line-5799"><code></code></span>
<span class="codeline" id="line-5800"><code>// Disassociate p and the current m without tracing an event.</code></span>
<span class="codeline" id="line-5801"><code>func releasepNoTrace() *p {</code></span>
<span class="codeline" id="line-5802"><code>	gp := getg()</code></span>
<span class="codeline" id="line-5803"><code></code></span>
<span class="codeline" id="line-5804"><code>	if gp.m.p == 0 {</code></span>
<span class="codeline" id="line-5805"><code>		throw("releasep: invalid arg")</code></span>
<span class="codeline" id="line-5806"><code>	}</code></span>
<span class="codeline" id="line-5807"><code>	pp := gp.m.p.ptr()</code></span>
<span class="codeline" id="line-5808"><code>	if pp.m.ptr() != gp.m || pp.status != _Prunning {</code></span>
<span class="codeline" id="line-5809"><code>		print("releasep: m=", gp.m, " m-&gt;p=", gp.m.p.ptr(), " p-&gt;m=", hex(pp.m), " p-&gt;status=", pp.status, "\n")</code></span>
<span class="codeline" id="line-5810"><code>		throw("releasep: invalid p state")</code></span>
<span class="codeline" id="line-5811"><code>	}</code></span>
<span class="codeline" id="line-5812"><code>	gp.m.p = 0</code></span>
<span class="codeline" id="line-5813"><code>	pp.m = 0</code></span>
<span class="codeline" id="line-5814"><code>	pp.status = _Pidle</code></span>
<span class="codeline" id="line-5815"><code>	return pp</code></span>
<span class="codeline" id="line-5816"><code>}</code></span>
<span class="codeline" id="line-5817"><code></code></span>
<span class="codeline" id="line-5818"><code>func incidlelocked(v int32) {</code></span>
<span class="codeline" id="line-5819"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5820"><code>	sched.nmidlelocked += v</code></span>
<span class="codeline" id="line-5821"><code>	if v &gt; 0 {</code></span>
<span class="codeline" id="line-5822"><code>		checkdead()</code></span>
<span class="codeline" id="line-5823"><code>	}</code></span>
<span class="codeline" id="line-5824"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5825"><code>}</code></span>
<span class="codeline" id="line-5826"><code></code></span>
<span class="codeline" id="line-5827"><code>// Check for deadlock situation.</code></span>
<span class="codeline" id="line-5828"><code>// The check is based on number of running M's, if 0 -&gt; deadlock.</code></span>
<span class="codeline" id="line-5829"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-5830"><code>func checkdead() {</code></span>
<span class="codeline" id="line-5831"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5832"><code></code></span>
<span class="codeline" id="line-5833"><code>	// For -buildmode=c-shared or -buildmode=c-archive it's OK if</code></span>
<span class="codeline" id="line-5834"><code>	// there are no running goroutines. The calling program is</code></span>
<span class="codeline" id="line-5835"><code>	// assumed to be running.</code></span>
<span class="codeline" id="line-5836"><code>	if islibrary || isarchive {</code></span>
<span class="codeline" id="line-5837"><code>		return</code></span>
<span class="codeline" id="line-5838"><code>	}</code></span>
<span class="codeline" id="line-5839"><code></code></span>
<span class="codeline" id="line-5840"><code>	// If we are dying because of a signal caught on an already idle thread,</code></span>
<span class="codeline" id="line-5841"><code>	// freezetheworld will cause all running threads to block.</code></span>
<span class="codeline" id="line-5842"><code>	// And runtime will essentially enter into deadlock state,</code></span>
<span class="codeline" id="line-5843"><code>	// except that there is a thread that will call exit soon.</code></span>
<span class="codeline" id="line-5844"><code>	if panicking.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-5845"><code>		return</code></span>
<span class="codeline" id="line-5846"><code>	}</code></span>
<span class="codeline" id="line-5847"><code></code></span>
<span class="codeline" id="line-5848"><code>	// If we are not running under cgo, but we have an extra M then account</code></span>
<span class="codeline" id="line-5849"><code>	// for it. (It is possible to have an extra M on Windows without cgo to</code></span>
<span class="codeline" id="line-5850"><code>	// accommodate callbacks created by syscall.NewCallback. See issue #6751</code></span>
<span class="codeline" id="line-5851"><code>	// for details.)</code></span>
<span class="codeline" id="line-5852"><code>	var run0 int32</code></span>
<span class="codeline" id="line-5853"><code>	if !iscgo &amp;&amp; cgoHasExtraM &amp;&amp; extraMLength.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-5854"><code>		run0 = 1</code></span>
<span class="codeline" id="line-5855"><code>	}</code></span>
<span class="codeline" id="line-5856"><code></code></span>
<span class="codeline" id="line-5857"><code>	run := mcount() - sched.nmidle - sched.nmidlelocked - sched.nmsys</code></span>
<span class="codeline" id="line-5858"><code>	if run &gt; run0 {</code></span>
<span class="codeline" id="line-5859"><code>		return</code></span>
<span class="codeline" id="line-5860"><code>	}</code></span>
<span class="codeline" id="line-5861"><code>	if run &lt; 0 {</code></span>
<span class="codeline" id="line-5862"><code>		print("runtime: checkdead: nmidle=", sched.nmidle, " nmidlelocked=", sched.nmidlelocked, " mcount=", mcount(), " nmsys=", sched.nmsys, "\n")</code></span>
<span class="codeline" id="line-5863"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5864"><code>		throw("checkdead: inconsistent counts")</code></span>
<span class="codeline" id="line-5865"><code>	}</code></span>
<span class="codeline" id="line-5866"><code></code></span>
<span class="codeline" id="line-5867"><code>	grunning := 0</code></span>
<span class="codeline" id="line-5868"><code>	forEachG(func(gp *g) {</code></span>
<span class="codeline" id="line-5869"><code>		if isSystemGoroutine(gp, false) {</code></span>
<span class="codeline" id="line-5870"><code>			return</code></span>
<span class="codeline" id="line-5871"><code>		}</code></span>
<span class="codeline" id="line-5872"><code>		s := readgstatus(gp)</code></span>
<span class="codeline" id="line-5873"><code>		switch s &amp;^ _Gscan {</code></span>
<span class="codeline" id="line-5874"><code>		case _Gwaiting,</code></span>
<span class="codeline" id="line-5875"><code>			_Gpreempted:</code></span>
<span class="codeline" id="line-5876"><code>			grunning++</code></span>
<span class="codeline" id="line-5877"><code>		case _Grunnable,</code></span>
<span class="codeline" id="line-5878"><code>			_Grunning,</code></span>
<span class="codeline" id="line-5879"><code>			_Gsyscall:</code></span>
<span class="codeline" id="line-5880"><code>			print("runtime: checkdead: find g ", gp.goid, " in status ", s, "\n")</code></span>
<span class="codeline" id="line-5881"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5882"><code>			throw("checkdead: runnable g")</code></span>
<span class="codeline" id="line-5883"><code>		}</code></span>
<span class="codeline" id="line-5884"><code>	})</code></span>
<span class="codeline" id="line-5885"><code>	if grunning == 0 { // possible if main goroutine calls runtimeGoexit()</code></span>
<span class="codeline" id="line-5886"><code>		unlock(&amp;sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn't hang</code></span>
<span class="codeline" id="line-5887"><code>		fatal("no goroutines (main called runtime.Goexit) - deadlock!")</code></span>
<span class="codeline" id="line-5888"><code>	}</code></span>
<span class="codeline" id="line-5889"><code></code></span>
<span class="codeline" id="line-5890"><code>	// Maybe jump time forward for playground.</code></span>
<span class="codeline" id="line-5891"><code>	if faketime != 0 {</code></span>
<span class="codeline" id="line-5892"><code>		if when := timeSleepUntil(); when &lt; maxWhen {</code></span>
<span class="codeline" id="line-5893"><code>			faketime = when</code></span>
<span class="codeline" id="line-5894"><code></code></span>
<span class="codeline" id="line-5895"><code>			// Start an M to steal the timer.</code></span>
<span class="codeline" id="line-5896"><code>			pp, _ := pidleget(faketime)</code></span>
<span class="codeline" id="line-5897"><code>			if pp == nil {</code></span>
<span class="codeline" id="line-5898"><code>				// There should always be a free P since</code></span>
<span class="codeline" id="line-5899"><code>				// nothing is running.</code></span>
<span class="codeline" id="line-5900"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5901"><code>				throw("checkdead: no p for timer")</code></span>
<span class="codeline" id="line-5902"><code>			}</code></span>
<span class="codeline" id="line-5903"><code>			mp := mget()</code></span>
<span class="codeline" id="line-5904"><code>			if mp == nil {</code></span>
<span class="codeline" id="line-5905"><code>				// There should always be a free M since</code></span>
<span class="codeline" id="line-5906"><code>				// nothing is running.</code></span>
<span class="codeline" id="line-5907"><code>				unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5908"><code>				throw("checkdead: no m for timer")</code></span>
<span class="codeline" id="line-5909"><code>			}</code></span>
<span class="codeline" id="line-5910"><code>			// M must be spinning to steal. We set this to be</code></span>
<span class="codeline" id="line-5911"><code>			// explicit, but since this is the only M it would</code></span>
<span class="codeline" id="line-5912"><code>			// become spinning on its own anyways.</code></span>
<span class="codeline" id="line-5913"><code>			sched.nmspinning.Add(1)</code></span>
<span class="codeline" id="line-5914"><code>			mp.spinning = true</code></span>
<span class="codeline" id="line-5915"><code>			mp.nextp.set(pp)</code></span>
<span class="codeline" id="line-5916"><code>			notewakeup(&amp;mp.park)</code></span>
<span class="codeline" id="line-5917"><code>			return</code></span>
<span class="codeline" id="line-5918"><code>		}</code></span>
<span class="codeline" id="line-5919"><code>	}</code></span>
<span class="codeline" id="line-5920"><code></code></span>
<span class="codeline" id="line-5921"><code>	// There are no goroutines running, so we can look at the P's.</code></span>
<span class="codeline" id="line-5922"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-5923"><code>		if len(pp.timers) &gt; 0 {</code></span>
<span class="codeline" id="line-5924"><code>			return</code></span>
<span class="codeline" id="line-5925"><code>		}</code></span>
<span class="codeline" id="line-5926"><code>	}</code></span>
<span class="codeline" id="line-5927"><code></code></span>
<span class="codeline" id="line-5928"><code>	unlock(&amp;sched.lock) // unlock so that GODEBUG=scheddetail=1 doesn't hang</code></span>
<span class="codeline" id="line-5929"><code>	fatal("all goroutines are asleep - deadlock!")</code></span>
<span class="codeline" id="line-5930"><code>}</code></span>
<span class="codeline" id="line-5931"><code></code></span>
<span class="codeline" id="line-5932"><code>// forcegcperiod is the maximum time in nanoseconds between garbage</code></span>
<span class="codeline" id="line-5933"><code>// collections. If we go this long without a garbage collection, one</code></span>
<span class="codeline" id="line-5934"><code>// is forced to run.</code></span>
<span class="codeline" id="line-5935"><code>//</code></span>
<span class="codeline" id="line-5936"><code>// This is a variable for testing purposes. It normally doesn't change.</code></span>
<span class="codeline" id="line-5937"><code>var forcegcperiod int64 = 2 * 60 * 1e9</code></span>
<span class="codeline" id="line-5938"><code></code></span>
<span class="codeline" id="line-5939"><code>// needSysmonWorkaround is true if the workaround for</code></span>
<span class="codeline" id="line-5940"><code>// golang.org/issue/42515 is needed on NetBSD.</code></span>
<span class="codeline" id="line-5941"><code>var needSysmonWorkaround bool = false</code></span>
<span class="codeline" id="line-5942"><code></code></span>
<span class="codeline" id="line-5943"><code>// Always runs without a P, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-5944"><code>//</code></span>
<span class="codeline" id="line-5945"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-5946"><code>func sysmon() {</code></span>
<span class="codeline" id="line-5947"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5948"><code>	sched.nmsys++</code></span>
<span class="codeline" id="line-5949"><code>	checkdead()</code></span>
<span class="codeline" id="line-5950"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5951"><code></code></span>
<span class="codeline" id="line-5952"><code>	lasttrace := int64(0)</code></span>
<span class="codeline" id="line-5953"><code>	idle := 0 // how many cycles in succession we had not wokeup somebody</code></span>
<span class="codeline" id="line-5954"><code>	delay := uint32(0)</code></span>
<span class="codeline" id="line-5955"><code></code></span>
<span class="codeline" id="line-5956"><code>	for {</code></span>
<span class="codeline" id="line-5957"><code>		if idle == 0 { // start with 20us sleep...</code></span>
<span class="codeline" id="line-5958"><code>			delay = 20</code></span>
<span class="codeline" id="line-5959"><code>		} else if idle &gt; 50 { // start doubling the sleep after 1ms...</code></span>
<span class="codeline" id="line-5960"><code>			delay *= 2</code></span>
<span class="codeline" id="line-5961"><code>		}</code></span>
<span class="codeline" id="line-5962"><code>		if delay &gt; 10*1000 { // up to 10ms</code></span>
<span class="codeline" id="line-5963"><code>			delay = 10 * 1000</code></span>
<span class="codeline" id="line-5964"><code>		}</code></span>
<span class="codeline" id="line-5965"><code>		usleep(delay)</code></span>
<span class="codeline" id="line-5966"><code></code></span>
<span class="codeline" id="line-5967"><code>		// sysmon should not enter deep sleep if schedtrace is enabled so that</code></span>
<span class="codeline" id="line-5968"><code>		// it can print that information at the right time.</code></span>
<span class="codeline" id="line-5969"><code>		//</code></span>
<span class="codeline" id="line-5970"><code>		// It should also not enter deep sleep if there are any active P's so</code></span>
<span class="codeline" id="line-5971"><code>		// that it can retake P's from syscalls, preempt long running G's, and</code></span>
<span class="codeline" id="line-5972"><code>		// poll the network if all P's are busy for long stretches.</code></span>
<span class="codeline" id="line-5973"><code>		//</code></span>
<span class="codeline" id="line-5974"><code>		// It should wakeup from deep sleep if any P's become active either due</code></span>
<span class="codeline" id="line-5975"><code>		// to exiting a syscall or waking up due to a timer expiring so that it</code></span>
<span class="codeline" id="line-5976"><code>		// can resume performing those duties. If it wakes from a syscall it</code></span>
<span class="codeline" id="line-5977"><code>		// resets idle and delay as a bet that since it had retaken a P from a</code></span>
<span class="codeline" id="line-5978"><code>		// syscall before, it may need to do it again shortly after the</code></span>
<span class="codeline" id="line-5979"><code>		// application starts work again. It does not reset idle when waking</code></span>
<span class="codeline" id="line-5980"><code>		// from a timer to avoid adding system load to applications that spend</code></span>
<span class="codeline" id="line-5981"><code>		// most of their time sleeping.</code></span>
<span class="codeline" id="line-5982"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-5983"><code>		if debug.schedtrace &lt;= 0 &amp;&amp; (sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs) {</code></span>
<span class="codeline" id="line-5984"><code>			lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5985"><code>			if sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs {</code></span>
<span class="codeline" id="line-5986"><code>				syscallWake := false</code></span>
<span class="codeline" id="line-5987"><code>				next := timeSleepUntil()</code></span>
<span class="codeline" id="line-5988"><code>				if next &gt; now {</code></span>
<span class="codeline" id="line-5989"><code>					sched.sysmonwait.Store(true)</code></span>
<span class="codeline" id="line-5990"><code>					unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-5991"><code>					// Make wake-up period small enough</code></span>
<span class="codeline" id="line-5992"><code>					// for the sampling to be correct.</code></span>
<span class="codeline" id="line-5993"><code>					sleep := forcegcperiod / 2</code></span>
<span class="codeline" id="line-5994"><code>					if next-now &lt; sleep {</code></span>
<span class="codeline" id="line-5995"><code>						sleep = next - now</code></span>
<span class="codeline" id="line-5996"><code>					}</code></span>
<span class="codeline" id="line-5997"><code>					shouldRelax := sleep &gt;= osRelaxMinNS</code></span>
<span class="codeline" id="line-5998"><code>					if shouldRelax {</code></span>
<span class="codeline" id="line-5999"><code>						osRelax(true)</code></span>
<span class="codeline" id="line-6000"><code>					}</code></span>
<span class="codeline" id="line-6001"><code>					syscallWake = notetsleep(&amp;sched.sysmonnote, sleep)</code></span>
<span class="codeline" id="line-6002"><code>					if shouldRelax {</code></span>
<span class="codeline" id="line-6003"><code>						osRelax(false)</code></span>
<span class="codeline" id="line-6004"><code>					}</code></span>
<span class="codeline" id="line-6005"><code>					lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6006"><code>					sched.sysmonwait.Store(false)</code></span>
<span class="codeline" id="line-6007"><code>					noteclear(&amp;sched.sysmonnote)</code></span>
<span class="codeline" id="line-6008"><code>				}</code></span>
<span class="codeline" id="line-6009"><code>				if syscallWake {</code></span>
<span class="codeline" id="line-6010"><code>					idle = 0</code></span>
<span class="codeline" id="line-6011"><code>					delay = 20</code></span>
<span class="codeline" id="line-6012"><code>				}</code></span>
<span class="codeline" id="line-6013"><code>			}</code></span>
<span class="codeline" id="line-6014"><code>			unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6015"><code>		}</code></span>
<span class="codeline" id="line-6016"><code></code></span>
<span class="codeline" id="line-6017"><code>		lock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-6018"><code>		// Update now in case we blocked on sysmonnote or spent a long time</code></span>
<span class="codeline" id="line-6019"><code>		// blocked on schedlock or sysmonlock above.</code></span>
<span class="codeline" id="line-6020"><code>		now = nanotime()</code></span>
<span class="codeline" id="line-6021"><code></code></span>
<span class="codeline" id="line-6022"><code>		// trigger libc interceptors if needed</code></span>
<span class="codeline" id="line-6023"><code>		if *cgo_yield != nil {</code></span>
<span class="codeline" id="line-6024"><code>			asmcgocall(*cgo_yield, nil)</code></span>
<span class="codeline" id="line-6025"><code>		}</code></span>
<span class="codeline" id="line-6026"><code>		// poll network if not polled for more than 10ms</code></span>
<span class="codeline" id="line-6027"><code>		lastpoll := sched.lastpoll.Load()</code></span>
<span class="codeline" id="line-6028"><code>		if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10*1000*1000 &lt; now {</code></span>
<span class="codeline" id="line-6029"><code>			sched.lastpoll.CompareAndSwap(lastpoll, now)</code></span>
<span class="codeline" id="line-6030"><code>			list, delta := netpoll(0) // non-blocking - returns list of goroutines</code></span>
<span class="codeline" id="line-6031"><code>			if !list.empty() {</code></span>
<span class="codeline" id="line-6032"><code>				// Need to decrement number of idle locked M's</code></span>
<span class="codeline" id="line-6033"><code>				// (pretending that one more is running) before injectglist.</code></span>
<span class="codeline" id="line-6034"><code>				// Otherwise it can lead to the following situation:</code></span>
<span class="codeline" id="line-6035"><code>				// injectglist grabs all P's but before it starts M's to run the P's,</code></span>
<span class="codeline" id="line-6036"><code>				// another M returns from syscall, finishes running its G,</code></span>
<span class="codeline" id="line-6037"><code>				// observes that there is no work to do and no other running M's</code></span>
<span class="codeline" id="line-6038"><code>				// and reports deadlock.</code></span>
<span class="codeline" id="line-6039"><code>				incidlelocked(-1)</code></span>
<span class="codeline" id="line-6040"><code>				injectglist(&amp;list)</code></span>
<span class="codeline" id="line-6041"><code>				incidlelocked(1)</code></span>
<span class="codeline" id="line-6042"><code>				netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-6043"><code>			}</code></span>
<span class="codeline" id="line-6044"><code>		}</code></span>
<span class="codeline" id="line-6045"><code>		if GOOS == "netbsd" &amp;&amp; needSysmonWorkaround {</code></span>
<span class="codeline" id="line-6046"><code>			// netpoll is responsible for waiting for timer</code></span>
<span class="codeline" id="line-6047"><code>			// expiration, so we typically don't have to worry</code></span>
<span class="codeline" id="line-6048"><code>			// about starting an M to service timers. (Note that</code></span>
<span class="codeline" id="line-6049"><code>			// sleep for timeSleepUntil above simply ensures sysmon</code></span>
<span class="codeline" id="line-6050"><code>			// starts running again when that timer expiration may</code></span>
<span class="codeline" id="line-6051"><code>			// cause Go code to run again).</code></span>
<span class="codeline" id="line-6052"><code>			//</code></span>
<span class="codeline" id="line-6053"><code>			// However, netbsd has a kernel bug that sometimes</code></span>
<span class="codeline" id="line-6054"><code>			// misses netpollBreak wake-ups, which can lead to</code></span>
<span class="codeline" id="line-6055"><code>			// unbounded delays servicing timers. If we detect this</code></span>
<span class="codeline" id="line-6056"><code>			// overrun, then startm to get something to handle the</code></span>
<span class="codeline" id="line-6057"><code>			// timer.</code></span>
<span class="codeline" id="line-6058"><code>			//</code></span>
<span class="codeline" id="line-6059"><code>			// See issue 42515 and</code></span>
<span class="codeline" id="line-6060"><code>			// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.</code></span>
<span class="codeline" id="line-6061"><code>			if next := timeSleepUntil(); next &lt; now {</code></span>
<span class="codeline" id="line-6062"><code>				startm(nil, false, false)</code></span>
<span class="codeline" id="line-6063"><code>			}</code></span>
<span class="codeline" id="line-6064"><code>		}</code></span>
<span class="codeline" id="line-6065"><code>		if scavenger.sysmonWake.Load() != 0 {</code></span>
<span class="codeline" id="line-6066"><code>			// Kick the scavenger awake if someone requested it.</code></span>
<span class="codeline" id="line-6067"><code>			scavenger.wake()</code></span>
<span class="codeline" id="line-6068"><code>		}</code></span>
<span class="codeline" id="line-6069"><code>		// retake P's blocked in syscalls</code></span>
<span class="codeline" id="line-6070"><code>		// and preempt long running G's</code></span>
<span class="codeline" id="line-6071"><code>		if retake(now) != 0 {</code></span>
<span class="codeline" id="line-6072"><code>			idle = 0</code></span>
<span class="codeline" id="line-6073"><code>		} else {</code></span>
<span class="codeline" id="line-6074"><code>			idle++</code></span>
<span class="codeline" id="line-6075"><code>		}</code></span>
<span class="codeline" id="line-6076"><code>		// check if we need to force a GC</code></span>
<span class="codeline" id="line-6077"><code>		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;&amp; forcegc.idle.Load() {</code></span>
<span class="codeline" id="line-6078"><code>			lock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-6079"><code>			forcegc.idle.Store(false)</code></span>
<span class="codeline" id="line-6080"><code>			var list gList</code></span>
<span class="codeline" id="line-6081"><code>			list.push(forcegc.g)</code></span>
<span class="codeline" id="line-6082"><code>			injectglist(&amp;list)</code></span>
<span class="codeline" id="line-6083"><code>			unlock(&amp;forcegc.lock)</code></span>
<span class="codeline" id="line-6084"><code>		}</code></span>
<span class="codeline" id="line-6085"><code>		if debug.schedtrace &gt; 0 &amp;&amp; lasttrace+int64(debug.schedtrace)*1000000 &lt;= now {</code></span>
<span class="codeline" id="line-6086"><code>			lasttrace = now</code></span>
<span class="codeline" id="line-6087"><code>			schedtrace(debug.scheddetail &gt; 0)</code></span>
<span class="codeline" id="line-6088"><code>		}</code></span>
<span class="codeline" id="line-6089"><code>		unlock(&amp;sched.sysmonlock)</code></span>
<span class="codeline" id="line-6090"><code>	}</code></span>
<span class="codeline" id="line-6091"><code>}</code></span>
<span class="codeline" id="line-6092"><code></code></span>
<span class="codeline" id="line-6093"><code>type sysmontick struct {</code></span>
<span class="codeline" id="line-6094"><code>	schedtick   uint32</code></span>
<span class="codeline" id="line-6095"><code>	schedwhen   int64</code></span>
<span class="codeline" id="line-6096"><code>	syscalltick uint32</code></span>
<span class="codeline" id="line-6097"><code>	syscallwhen int64</code></span>
<span class="codeline" id="line-6098"><code>}</code></span>
<span class="codeline" id="line-6099"><code></code></span>
<span class="codeline" id="line-6100"><code>// forcePreemptNS is the time slice given to a G before it is</code></span>
<span class="codeline" id="line-6101"><code>// preempted.</code></span>
<span class="codeline" id="line-6102"><code>const forcePreemptNS = 10 * 1000 * 1000 // 10ms</code></span>
<span class="codeline" id="line-6103"><code></code></span>
<span class="codeline" id="line-6104"><code>func retake(now int64) uint32 {</code></span>
<span class="codeline" id="line-6105"><code>	n := 0</code></span>
<span class="codeline" id="line-6106"><code>	// Prevent allp slice changes. This lock will be completely</code></span>
<span class="codeline" id="line-6107"><code>	// uncontended unless we're already stopping the world.</code></span>
<span class="codeline" id="line-6108"><code>	lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-6109"><code>	// We can't use a range loop over allp because we may</code></span>
<span class="codeline" id="line-6110"><code>	// temporarily drop the allpLock. Hence, we need to re-fetch</code></span>
<span class="codeline" id="line-6111"><code>	// allp each time around the loop.</code></span>
<span class="codeline" id="line-6112"><code>	for i := 0; i &lt; len(allp); i++ {</code></span>
<span class="codeline" id="line-6113"><code>		pp := allp[i]</code></span>
<span class="codeline" id="line-6114"><code>		if pp == nil {</code></span>
<span class="codeline" id="line-6115"><code>			// This can happen if procresize has grown</code></span>
<span class="codeline" id="line-6116"><code>			// allp but not yet created new Ps.</code></span>
<span class="codeline" id="line-6117"><code>			continue</code></span>
<span class="codeline" id="line-6118"><code>		}</code></span>
<span class="codeline" id="line-6119"><code>		pd := &amp;pp.sysmontick</code></span>
<span class="codeline" id="line-6120"><code>		s := pp.status</code></span>
<span class="codeline" id="line-6121"><code>		sysretake := false</code></span>
<span class="codeline" id="line-6122"><code>		if s == _Prunning || s == _Psyscall {</code></span>
<span class="codeline" id="line-6123"><code>			// Preempt G if it's running for too long.</code></span>
<span class="codeline" id="line-6124"><code>			t := int64(pp.schedtick)</code></span>
<span class="codeline" id="line-6125"><code>			if int64(pd.schedtick) != t {</code></span>
<span class="codeline" id="line-6126"><code>				pd.schedtick = uint32(t)</code></span>
<span class="codeline" id="line-6127"><code>				pd.schedwhen = now</code></span>
<span class="codeline" id="line-6128"><code>			} else if pd.schedwhen+forcePreemptNS &lt;= now {</code></span>
<span class="codeline" id="line-6129"><code>				preemptone(pp)</code></span>
<span class="codeline" id="line-6130"><code>				// In case of syscall, preemptone() doesn't</code></span>
<span class="codeline" id="line-6131"><code>				// work, because there is no M wired to P.</code></span>
<span class="codeline" id="line-6132"><code>				sysretake = true</code></span>
<span class="codeline" id="line-6133"><code>			}</code></span>
<span class="codeline" id="line-6134"><code>		}</code></span>
<span class="codeline" id="line-6135"><code>		if s == _Psyscall {</code></span>
<span class="codeline" id="line-6136"><code>			// Retake P from syscall if it's there for more than 1 sysmon tick (at least 20us).</code></span>
<span class="codeline" id="line-6137"><code>			t := int64(pp.syscalltick)</code></span>
<span class="codeline" id="line-6138"><code>			if !sysretake &amp;&amp; int64(pd.syscalltick) != t {</code></span>
<span class="codeline" id="line-6139"><code>				pd.syscalltick = uint32(t)</code></span>
<span class="codeline" id="line-6140"><code>				pd.syscallwhen = now</code></span>
<span class="codeline" id="line-6141"><code>				continue</code></span>
<span class="codeline" id="line-6142"><code>			}</code></span>
<span class="codeline" id="line-6143"><code>			// On the one hand we don't want to retake Ps if there is no other work to do,</code></span>
<span class="codeline" id="line-6144"><code>			// but on the other hand we want to retake them eventually</code></span>
<span class="codeline" id="line-6145"><code>			// because they can prevent the sysmon thread from deep sleep.</code></span>
<span class="codeline" id="line-6146"><code>			if runqempty(pp) &amp;&amp; sched.nmspinning.Load()+sched.npidle.Load() &gt; 0 &amp;&amp; pd.syscallwhen+10*1000*1000 &gt; now {</code></span>
<span class="codeline" id="line-6147"><code>				continue</code></span>
<span class="codeline" id="line-6148"><code>			}</code></span>
<span class="codeline" id="line-6149"><code>			// Drop allpLock so we can take sched.lock.</code></span>
<span class="codeline" id="line-6150"><code>			unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-6151"><code>			// Need to decrement number of idle locked M's</code></span>
<span class="codeline" id="line-6152"><code>			// (pretending that one more is running) before the CAS.</code></span>
<span class="codeline" id="line-6153"><code>			// Otherwise the M from which we retake can exit the syscall,</code></span>
<span class="codeline" id="line-6154"><code>			// increment nmidle and report deadlock.</code></span>
<span class="codeline" id="line-6155"><code>			incidlelocked(-1)</code></span>
<span class="codeline" id="line-6156"><code>			trace := traceAcquire()</code></span>
<span class="codeline" id="line-6157"><code>			if atomic.Cas(&amp;pp.status, s, _Pidle) {</code></span>
<span class="codeline" id="line-6158"><code>				if trace.ok() {</code></span>
<span class="codeline" id="line-6159"><code>					trace.GoSysBlock(pp)</code></span>
<span class="codeline" id="line-6160"><code>					trace.ProcSteal(pp, false)</code></span>
<span class="codeline" id="line-6161"><code>					traceRelease(trace)</code></span>
<span class="codeline" id="line-6162"><code>				}</code></span>
<span class="codeline" id="line-6163"><code>				n++</code></span>
<span class="codeline" id="line-6164"><code>				pp.syscalltick++</code></span>
<span class="codeline" id="line-6165"><code>				handoffp(pp)</code></span>
<span class="codeline" id="line-6166"><code>			} else if trace.ok() {</code></span>
<span class="codeline" id="line-6167"><code>				traceRelease(trace)</code></span>
<span class="codeline" id="line-6168"><code>			}</code></span>
<span class="codeline" id="line-6169"><code>			incidlelocked(1)</code></span>
<span class="codeline" id="line-6170"><code>			lock(&amp;allpLock)</code></span>
<span class="codeline" id="line-6171"><code>		}</code></span>
<span class="codeline" id="line-6172"><code>	}</code></span>
<span class="codeline" id="line-6173"><code>	unlock(&amp;allpLock)</code></span>
<span class="codeline" id="line-6174"><code>	return uint32(n)</code></span>
<span class="codeline" id="line-6175"><code>}</code></span>
<span class="codeline" id="line-6176"><code></code></span>
<span class="codeline" id="line-6177"><code>// Tell all goroutines that they have been preempted and they should stop.</code></span>
<span class="codeline" id="line-6178"><code>// This function is purely best-effort. It can fail to inform a goroutine if a</code></span>
<span class="codeline" id="line-6179"><code>// processor just started running it.</code></span>
<span class="codeline" id="line-6180"><code>// No locks need to be held.</code></span>
<span class="codeline" id="line-6181"><code>// Returns true if preemption request was issued to at least one goroutine.</code></span>
<span class="codeline" id="line-6182"><code>func preemptall() bool {</code></span>
<span class="codeline" id="line-6183"><code>	res := false</code></span>
<span class="codeline" id="line-6184"><code>	for _, pp := range allp {</code></span>
<span class="codeline" id="line-6185"><code>		if pp.status != _Prunning {</code></span>
<span class="codeline" id="line-6186"><code>			continue</code></span>
<span class="codeline" id="line-6187"><code>		}</code></span>
<span class="codeline" id="line-6188"><code>		if preemptone(pp) {</code></span>
<span class="codeline" id="line-6189"><code>			res = true</code></span>
<span class="codeline" id="line-6190"><code>		}</code></span>
<span class="codeline" id="line-6191"><code>	}</code></span>
<span class="codeline" id="line-6192"><code>	return res</code></span>
<span class="codeline" id="line-6193"><code>}</code></span>
<span class="codeline" id="line-6194"><code></code></span>
<span class="codeline" id="line-6195"><code>// Tell the goroutine running on processor P to stop.</code></span>
<span class="codeline" id="line-6196"><code>// This function is purely best-effort. It can incorrectly fail to inform the</code></span>
<span class="codeline" id="line-6197"><code>// goroutine. It can inform the wrong goroutine. Even if it informs the</code></span>
<span class="codeline" id="line-6198"><code>// correct goroutine, that goroutine might ignore the request if it is</code></span>
<span class="codeline" id="line-6199"><code>// simultaneously executing newstack.</code></span>
<span class="codeline" id="line-6200"><code>// No lock needs to be held.</code></span>
<span class="codeline" id="line-6201"><code>// Returns true if preemption request was issued.</code></span>
<span class="codeline" id="line-6202"><code>// The actual preemption will happen at some point in the future</code></span>
<span class="codeline" id="line-6203"><code>// and will be indicated by the gp-&gt;status no longer being</code></span>
<span class="codeline" id="line-6204"><code>// Grunning</code></span>
<span class="codeline" id="line-6205"><code>func preemptone(pp *p) bool {</code></span>
<span class="codeline" id="line-6206"><code>	mp := pp.m.ptr()</code></span>
<span class="codeline" id="line-6207"><code>	if mp == nil || mp == getg().m {</code></span>
<span class="codeline" id="line-6208"><code>		return false</code></span>
<span class="codeline" id="line-6209"><code>	}</code></span>
<span class="codeline" id="line-6210"><code>	gp := mp.curg</code></span>
<span class="codeline" id="line-6211"><code>	if gp == nil || gp == mp.g0 {</code></span>
<span class="codeline" id="line-6212"><code>		return false</code></span>
<span class="codeline" id="line-6213"><code>	}</code></span>
<span class="codeline" id="line-6214"><code></code></span>
<span class="codeline" id="line-6215"><code>	gp.preempt = true</code></span>
<span class="codeline" id="line-6216"><code></code></span>
<span class="codeline" id="line-6217"><code>	// Every call in a goroutine checks for stack overflow by</code></span>
<span class="codeline" id="line-6218"><code>	// comparing the current stack pointer to gp-&gt;stackguard0.</code></span>
<span class="codeline" id="line-6219"><code>	// Setting gp-&gt;stackguard0 to StackPreempt folds</code></span>
<span class="codeline" id="line-6220"><code>	// preemption into the normal stack overflow check.</code></span>
<span class="codeline" id="line-6221"><code>	gp.stackguard0 = stackPreempt</code></span>
<span class="codeline" id="line-6222"><code></code></span>
<span class="codeline" id="line-6223"><code>	// Request an async preemption of this P.</code></span>
<span class="codeline" id="line-6224"><code>	if preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-6225"><code>		pp.preempt = true</code></span>
<span class="codeline" id="line-6226"><code>		preemptM(mp)</code></span>
<span class="codeline" id="line-6227"><code>	}</code></span>
<span class="codeline" id="line-6228"><code></code></span>
<span class="codeline" id="line-6229"><code>	return true</code></span>
<span class="codeline" id="line-6230"><code>}</code></span>
<span class="codeline" id="line-6231"><code></code></span>
<span class="codeline" id="line-6232"><code>var starttime int64</code></span>
<span class="codeline" id="line-6233"><code></code></span>
<span class="codeline" id="line-6234"><code>func schedtrace(detailed bool) {</code></span>
<span class="codeline" id="line-6235"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-6236"><code>	if starttime == 0 {</code></span>
<span class="codeline" id="line-6237"><code>		starttime = now</code></span>
<span class="codeline" id="line-6238"><code>	}</code></span>
<span class="codeline" id="line-6239"><code></code></span>
<span class="codeline" id="line-6240"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6241"><code>	print("SCHED ", (now-starttime)/1e6, "ms: gomaxprocs=", gomaxprocs, " idleprocs=", sched.npidle.Load(), " threads=", mcount(), " spinningthreads=", sched.nmspinning.Load(), " needspinning=", sched.needspinning.Load(), " idlethreads=", sched.nmidle, " runqueue=", sched.runqsize)</code></span>
<span class="codeline" id="line-6242"><code>	if detailed {</code></span>
<span class="codeline" id="line-6243"><code>		print(" gcwaiting=", sched.gcwaiting.Load(), " nmidlelocked=", sched.nmidlelocked, " stopwait=", sched.stopwait, " sysmonwait=", sched.sysmonwait.Load(), "\n")</code></span>
<span class="codeline" id="line-6244"><code>	}</code></span>
<span class="codeline" id="line-6245"><code>	// We must be careful while reading data from P's, M's and G's.</code></span>
<span class="codeline" id="line-6246"><code>	// Even if we hold schedlock, most data can be changed concurrently.</code></span>
<span class="codeline" id="line-6247"><code>	// E.g. (p-&gt;m ? p-&gt;m-&gt;id : -1) can crash if p-&gt;m changes from non-nil to nil.</code></span>
<span class="codeline" id="line-6248"><code>	for i, pp := range allp {</code></span>
<span class="codeline" id="line-6249"><code>		mp := pp.m.ptr()</code></span>
<span class="codeline" id="line-6250"><code>		h := atomic.Load(&amp;pp.runqhead)</code></span>
<span class="codeline" id="line-6251"><code>		t := atomic.Load(&amp;pp.runqtail)</code></span>
<span class="codeline" id="line-6252"><code>		if detailed {</code></span>
<span class="codeline" id="line-6253"><code>			print("  P", i, ": status=", pp.status, " schedtick=", pp.schedtick, " syscalltick=", pp.syscalltick, " m=")</code></span>
<span class="codeline" id="line-6254"><code>			if mp != nil {</code></span>
<span class="codeline" id="line-6255"><code>				print(mp.id)</code></span>
<span class="codeline" id="line-6256"><code>			} else {</code></span>
<span class="codeline" id="line-6257"><code>				print("nil")</code></span>
<span class="codeline" id="line-6258"><code>			}</code></span>
<span class="codeline" id="line-6259"><code>			print(" runqsize=", t-h, " gfreecnt=", pp.gFree.n, " timerslen=", len(pp.timers), "\n")</code></span>
<span class="codeline" id="line-6260"><code>		} else {</code></span>
<span class="codeline" id="line-6261"><code>			// In non-detailed mode format lengths of per-P run queues as:</code></span>
<span class="codeline" id="line-6262"><code>			// [len1 len2 len3 len4]</code></span>
<span class="codeline" id="line-6263"><code>			print(" ")</code></span>
<span class="codeline" id="line-6264"><code>			if i == 0 {</code></span>
<span class="codeline" id="line-6265"><code>				print("[")</code></span>
<span class="codeline" id="line-6266"><code>			}</code></span>
<span class="codeline" id="line-6267"><code>			print(t - h)</code></span>
<span class="codeline" id="line-6268"><code>			if i == len(allp)-1 {</code></span>
<span class="codeline" id="line-6269"><code>				print("]\n")</code></span>
<span class="codeline" id="line-6270"><code>			}</code></span>
<span class="codeline" id="line-6271"><code>		}</code></span>
<span class="codeline" id="line-6272"><code>	}</code></span>
<span class="codeline" id="line-6273"><code></code></span>
<span class="codeline" id="line-6274"><code>	if !detailed {</code></span>
<span class="codeline" id="line-6275"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6276"><code>		return</code></span>
<span class="codeline" id="line-6277"><code>	}</code></span>
<span class="codeline" id="line-6278"><code></code></span>
<span class="codeline" id="line-6279"><code>	for mp := allm; mp != nil; mp = mp.alllink {</code></span>
<span class="codeline" id="line-6280"><code>		pp := mp.p.ptr()</code></span>
<span class="codeline" id="line-6281"><code>		print("  M", mp.id, ": p=")</code></span>
<span class="codeline" id="line-6282"><code>		if pp != nil {</code></span>
<span class="codeline" id="line-6283"><code>			print(pp.id)</code></span>
<span class="codeline" id="line-6284"><code>		} else {</code></span>
<span class="codeline" id="line-6285"><code>			print("nil")</code></span>
<span class="codeline" id="line-6286"><code>		}</code></span>
<span class="codeline" id="line-6287"><code>		print(" curg=")</code></span>
<span class="codeline" id="line-6288"><code>		if mp.curg != nil {</code></span>
<span class="codeline" id="line-6289"><code>			print(mp.curg.goid)</code></span>
<span class="codeline" id="line-6290"><code>		} else {</code></span>
<span class="codeline" id="line-6291"><code>			print("nil")</code></span>
<span class="codeline" id="line-6292"><code>		}</code></span>
<span class="codeline" id="line-6293"><code>		print(" mallocing=", mp.mallocing, " throwing=", mp.throwing, " preemptoff=", mp.preemptoff, " locks=", mp.locks, " dying=", mp.dying, " spinning=", mp.spinning, " blocked=", mp.blocked, " lockedg=")</code></span>
<span class="codeline" id="line-6294"><code>		if lockedg := mp.lockedg.ptr(); lockedg != nil {</code></span>
<span class="codeline" id="line-6295"><code>			print(lockedg.goid)</code></span>
<span class="codeline" id="line-6296"><code>		} else {</code></span>
<span class="codeline" id="line-6297"><code>			print("nil")</code></span>
<span class="codeline" id="line-6298"><code>		}</code></span>
<span class="codeline" id="line-6299"><code>		print("\n")</code></span>
<span class="codeline" id="line-6300"><code>	}</code></span>
<span class="codeline" id="line-6301"><code></code></span>
<span class="codeline" id="line-6302"><code>	forEachG(func(gp *g) {</code></span>
<span class="codeline" id="line-6303"><code>		print("  G", gp.goid, ": status=", readgstatus(gp), "(", gp.waitreason.String(), ") m=")</code></span>
<span class="codeline" id="line-6304"><code>		if gp.m != nil {</code></span>
<span class="codeline" id="line-6305"><code>			print(gp.m.id)</code></span>
<span class="codeline" id="line-6306"><code>		} else {</code></span>
<span class="codeline" id="line-6307"><code>			print("nil")</code></span>
<span class="codeline" id="line-6308"><code>		}</code></span>
<span class="codeline" id="line-6309"><code>		print(" lockedm=")</code></span>
<span class="codeline" id="line-6310"><code>		if lockedm := gp.lockedm.ptr(); lockedm != nil {</code></span>
<span class="codeline" id="line-6311"><code>			print(lockedm.id)</code></span>
<span class="codeline" id="line-6312"><code>		} else {</code></span>
<span class="codeline" id="line-6313"><code>			print("nil")</code></span>
<span class="codeline" id="line-6314"><code>		}</code></span>
<span class="codeline" id="line-6315"><code>		print("\n")</code></span>
<span class="codeline" id="line-6316"><code>	})</code></span>
<span class="codeline" id="line-6317"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6318"><code>}</code></span>
<span class="codeline" id="line-6319"><code></code></span>
<span class="codeline" id="line-6320"><code>// schedEnableUser enables or disables the scheduling of user</code></span>
<span class="codeline" id="line-6321"><code>// goroutines.</code></span>
<span class="codeline" id="line-6322"><code>//</code></span>
<span class="codeline" id="line-6323"><code>// This does not stop already running user goroutines, so the caller</code></span>
<span class="codeline" id="line-6324"><code>// should first stop the world when disabling user goroutines.</code></span>
<span class="codeline" id="line-6325"><code>func schedEnableUser(enable bool) {</code></span>
<span class="codeline" id="line-6326"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6327"><code>	if sched.disable.user == !enable {</code></span>
<span class="codeline" id="line-6328"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6329"><code>		return</code></span>
<span class="codeline" id="line-6330"><code>	}</code></span>
<span class="codeline" id="line-6331"><code>	sched.disable.user = !enable</code></span>
<span class="codeline" id="line-6332"><code>	if enable {</code></span>
<span class="codeline" id="line-6333"><code>		n := sched.disable.n</code></span>
<span class="codeline" id="line-6334"><code>		sched.disable.n = 0</code></span>
<span class="codeline" id="line-6335"><code>		globrunqputbatch(&amp;sched.disable.runnable, n)</code></span>
<span class="codeline" id="line-6336"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6337"><code>		for ; n != 0 &amp;&amp; sched.npidle.Load() != 0; n-- {</code></span>
<span class="codeline" id="line-6338"><code>			startm(nil, false, false)</code></span>
<span class="codeline" id="line-6339"><code>		}</code></span>
<span class="codeline" id="line-6340"><code>	} else {</code></span>
<span class="codeline" id="line-6341"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6342"><code>	}</code></span>
<span class="codeline" id="line-6343"><code>}</code></span>
<span class="codeline" id="line-6344"><code></code></span>
<span class="codeline" id="line-6345"><code>// schedEnabled reports whether gp should be scheduled. It returns</code></span>
<span class="codeline" id="line-6346"><code>// false is scheduling of gp is disabled.</code></span>
<span class="codeline" id="line-6347"><code>//</code></span>
<span class="codeline" id="line-6348"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6349"><code>func schedEnabled(gp *g) bool {</code></span>
<span class="codeline" id="line-6350"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6351"><code></code></span>
<span class="codeline" id="line-6352"><code>	if sched.disable.user {</code></span>
<span class="codeline" id="line-6353"><code>		return isSystemGoroutine(gp, true)</code></span>
<span class="codeline" id="line-6354"><code>	}</code></span>
<span class="codeline" id="line-6355"><code>	return true</code></span>
<span class="codeline" id="line-6356"><code>}</code></span>
<span class="codeline" id="line-6357"><code></code></span>
<span class="codeline" id="line-6358"><code>// Put mp on midle list.</code></span>
<span class="codeline" id="line-6359"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6360"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6361"><code>//</code></span>
<span class="codeline" id="line-6362"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6363"><code>func mput(mp *m) {</code></span>
<span class="codeline" id="line-6364"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6365"><code></code></span>
<span class="codeline" id="line-6366"><code>	mp.schedlink = sched.midle</code></span>
<span class="codeline" id="line-6367"><code>	sched.midle.set(mp)</code></span>
<span class="codeline" id="line-6368"><code>	sched.nmidle++</code></span>
<span class="codeline" id="line-6369"><code>	checkdead()</code></span>
<span class="codeline" id="line-6370"><code>}</code></span>
<span class="codeline" id="line-6371"><code></code></span>
<span class="codeline" id="line-6372"><code>// Try to get an m from midle list.</code></span>
<span class="codeline" id="line-6373"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6374"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6375"><code>//</code></span>
<span class="codeline" id="line-6376"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6377"><code>func mget() *m {</code></span>
<span class="codeline" id="line-6378"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6379"><code></code></span>
<span class="codeline" id="line-6380"><code>	mp := sched.midle.ptr()</code></span>
<span class="codeline" id="line-6381"><code>	if mp != nil {</code></span>
<span class="codeline" id="line-6382"><code>		sched.midle = mp.schedlink</code></span>
<span class="codeline" id="line-6383"><code>		sched.nmidle--</code></span>
<span class="codeline" id="line-6384"><code>	}</code></span>
<span class="codeline" id="line-6385"><code>	return mp</code></span>
<span class="codeline" id="line-6386"><code>}</code></span>
<span class="codeline" id="line-6387"><code></code></span>
<span class="codeline" id="line-6388"><code>// Put gp on the global runnable queue.</code></span>
<span class="codeline" id="line-6389"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6390"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6391"><code>//</code></span>
<span class="codeline" id="line-6392"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6393"><code>func globrunqput(gp *g) {</code></span>
<span class="codeline" id="line-6394"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6395"><code></code></span>
<span class="codeline" id="line-6396"><code>	sched.runq.pushBack(gp)</code></span>
<span class="codeline" id="line-6397"><code>	sched.runqsize++</code></span>
<span class="codeline" id="line-6398"><code>}</code></span>
<span class="codeline" id="line-6399"><code></code></span>
<span class="codeline" id="line-6400"><code>// Put gp at the head of the global runnable queue.</code></span>
<span class="codeline" id="line-6401"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6402"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6403"><code>//</code></span>
<span class="codeline" id="line-6404"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6405"><code>func globrunqputhead(gp *g) {</code></span>
<span class="codeline" id="line-6406"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6407"><code></code></span>
<span class="codeline" id="line-6408"><code>	sched.runq.push(gp)</code></span>
<span class="codeline" id="line-6409"><code>	sched.runqsize++</code></span>
<span class="codeline" id="line-6410"><code>}</code></span>
<span class="codeline" id="line-6411"><code></code></span>
<span class="codeline" id="line-6412"><code>// Put a batch of runnable goroutines on the global runnable queue.</code></span>
<span class="codeline" id="line-6413"><code>// This clears *batch.</code></span>
<span class="codeline" id="line-6414"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6415"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6416"><code>//</code></span>
<span class="codeline" id="line-6417"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6418"><code>func globrunqputbatch(batch *gQueue, n int32) {</code></span>
<span class="codeline" id="line-6419"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6420"><code></code></span>
<span class="codeline" id="line-6421"><code>	sched.runq.pushBackAll(*batch)</code></span>
<span class="codeline" id="line-6422"><code>	sched.runqsize += n</code></span>
<span class="codeline" id="line-6423"><code>	*batch = gQueue{}</code></span>
<span class="codeline" id="line-6424"><code>}</code></span>
<span class="codeline" id="line-6425"><code></code></span>
<span class="codeline" id="line-6426"><code>// Try get a batch of G's from the global runnable queue.</code></span>
<span class="codeline" id="line-6427"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6428"><code>func globrunqget(pp *p, max int32) *g {</code></span>
<span class="codeline" id="line-6429"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6430"><code></code></span>
<span class="codeline" id="line-6431"><code>	if sched.runqsize == 0 {</code></span>
<span class="codeline" id="line-6432"><code>		return nil</code></span>
<span class="codeline" id="line-6433"><code>	}</code></span>
<span class="codeline" id="line-6434"><code></code></span>
<span class="codeline" id="line-6435"><code>	n := sched.runqsize/gomaxprocs + 1</code></span>
<span class="codeline" id="line-6436"><code>	if n &gt; sched.runqsize {</code></span>
<span class="codeline" id="line-6437"><code>		n = sched.runqsize</code></span>
<span class="codeline" id="line-6438"><code>	}</code></span>
<span class="codeline" id="line-6439"><code>	if max &gt; 0 &amp;&amp; n &gt; max {</code></span>
<span class="codeline" id="line-6440"><code>		n = max</code></span>
<span class="codeline" id="line-6441"><code>	}</code></span>
<span class="codeline" id="line-6442"><code>	if n &gt; int32(len(pp.runq))/2 {</code></span>
<span class="codeline" id="line-6443"><code>		n = int32(len(pp.runq)) / 2</code></span>
<span class="codeline" id="line-6444"><code>	}</code></span>
<span class="codeline" id="line-6445"><code></code></span>
<span class="codeline" id="line-6446"><code>	sched.runqsize -= n</code></span>
<span class="codeline" id="line-6447"><code></code></span>
<span class="codeline" id="line-6448"><code>	gp := sched.runq.pop()</code></span>
<span class="codeline" id="line-6449"><code>	n--</code></span>
<span class="codeline" id="line-6450"><code>	for ; n &gt; 0; n-- {</code></span>
<span class="codeline" id="line-6451"><code>		gp1 := sched.runq.pop()</code></span>
<span class="codeline" id="line-6452"><code>		runqput(pp, gp1, false)</code></span>
<span class="codeline" id="line-6453"><code>	}</code></span>
<span class="codeline" id="line-6454"><code>	return gp</code></span>
<span class="codeline" id="line-6455"><code>}</code></span>
<span class="codeline" id="line-6456"><code></code></span>
<span class="codeline" id="line-6457"><code>// pMask is an atomic bitstring with one bit per P.</code></span>
<span class="codeline" id="line-6458"><code>type pMask []uint32</code></span>
<span class="codeline" id="line-6459"><code></code></span>
<span class="codeline" id="line-6460"><code>// read returns true if P id's bit is set.</code></span>
<span class="codeline" id="line-6461"><code>func (p pMask) read(id uint32) bool {</code></span>
<span class="codeline" id="line-6462"><code>	word := id / 32</code></span>
<span class="codeline" id="line-6463"><code>	mask := uint32(1) &lt;&lt; (id % 32)</code></span>
<span class="codeline" id="line-6464"><code>	return (atomic.Load(&amp;p[word]) &amp; mask) != 0</code></span>
<span class="codeline" id="line-6465"><code>}</code></span>
<span class="codeline" id="line-6466"><code></code></span>
<span class="codeline" id="line-6467"><code>// set sets P id's bit.</code></span>
<span class="codeline" id="line-6468"><code>func (p pMask) set(id int32) {</code></span>
<span class="codeline" id="line-6469"><code>	word := id / 32</code></span>
<span class="codeline" id="line-6470"><code>	mask := uint32(1) &lt;&lt; (id % 32)</code></span>
<span class="codeline" id="line-6471"><code>	atomic.Or(&amp;p[word], mask)</code></span>
<span class="codeline" id="line-6472"><code>}</code></span>
<span class="codeline" id="line-6473"><code></code></span>
<span class="codeline" id="line-6474"><code>// clear clears P id's bit.</code></span>
<span class="codeline" id="line-6475"><code>func (p pMask) clear(id int32) {</code></span>
<span class="codeline" id="line-6476"><code>	word := id / 32</code></span>
<span class="codeline" id="line-6477"><code>	mask := uint32(1) &lt;&lt; (id % 32)</code></span>
<span class="codeline" id="line-6478"><code>	atomic.And(&amp;p[word], ^mask)</code></span>
<span class="codeline" id="line-6479"><code>}</code></span>
<span class="codeline" id="line-6480"><code></code></span>
<span class="codeline" id="line-6481"><code>// updateTimerPMask clears pp's timer mask if it has no timers on its heap.</code></span>
<span class="codeline" id="line-6482"><code>//</code></span>
<span class="codeline" id="line-6483"><code>// Ideally, the timer mask would be kept immediately consistent on any timer</code></span>
<span class="codeline" id="line-6484"><code>// operations. Unfortunately, updating a shared global data structure in the</code></span>
<span class="codeline" id="line-6485"><code>// timer hot path adds too much overhead in applications frequently switching</code></span>
<span class="codeline" id="line-6486"><code>// between no timers and some timers.</code></span>
<span class="codeline" id="line-6487"><code>//</code></span>
<span class="codeline" id="line-6488"><code>// As a compromise, the timer mask is updated only on pidleget / pidleput. A</code></span>
<span class="codeline" id="line-6489"><code>// running P (returned by pidleget) may add a timer at any time, so its mask</code></span>
<span class="codeline" id="line-6490"><code>// must be set. An idle P (passed to pidleput) cannot add new timers while</code></span>
<span class="codeline" id="line-6491"><code>// idle, so if it has no timers at that time, its mask may be cleared.</code></span>
<span class="codeline" id="line-6492"><code>//</code></span>
<span class="codeline" id="line-6493"><code>// Thus, we get the following effects on timer-stealing in findrunnable:</code></span>
<span class="codeline" id="line-6494"><code>//</code></span>
<span class="codeline" id="line-6495"><code>//   - Idle Ps with no timers when they go idle are never checked in findrunnable</code></span>
<span class="codeline" id="line-6496"><code>//     (for work- or timer-stealing; this is the ideal case).</code></span>
<span class="codeline" id="line-6497"><code>//   - Running Ps must always be checked.</code></span>
<span class="codeline" id="line-6498"><code>//   - Idle Ps whose timers are stolen must continue to be checked until they run</code></span>
<span class="codeline" id="line-6499"><code>//     again, even after timer expiration.</code></span>
<span class="codeline" id="line-6500"><code>//</code></span>
<span class="codeline" id="line-6501"><code>// When the P starts running again, the mask should be set, as a timer may be</code></span>
<span class="codeline" id="line-6502"><code>// added at any time.</code></span>
<span class="codeline" id="line-6503"><code>//</code></span>
<span class="codeline" id="line-6504"><code>// TODO(prattmic): Additional targeted updates may improve the above cases.</code></span>
<span class="codeline" id="line-6505"><code>// e.g., updating the mask when stealing a timer.</code></span>
<span class="codeline" id="line-6506"><code>func updateTimerPMask(pp *p) {</code></span>
<span class="codeline" id="line-6507"><code>	if pp.numTimers.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-6508"><code>		return</code></span>
<span class="codeline" id="line-6509"><code>	}</code></span>
<span class="codeline" id="line-6510"><code></code></span>
<span class="codeline" id="line-6511"><code>	// Looks like there are no timers, however another P may transiently</code></span>
<span class="codeline" id="line-6512"><code>	// decrement numTimers when handling a timerModified timer in</code></span>
<span class="codeline" id="line-6513"><code>	// checkTimers. We must take timersLock to serialize with these changes.</code></span>
<span class="codeline" id="line-6514"><code>	lock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-6515"><code>	if pp.numTimers.Load() == 0 {</code></span>
<span class="codeline" id="line-6516"><code>		timerpMask.clear(pp.id)</code></span>
<span class="codeline" id="line-6517"><code>	}</code></span>
<span class="codeline" id="line-6518"><code>	unlock(&amp;pp.timersLock)</code></span>
<span class="codeline" id="line-6519"><code>}</code></span>
<span class="codeline" id="line-6520"><code></code></span>
<span class="codeline" id="line-6521"><code>// pidleput puts p on the _Pidle list. now must be a relatively recent call</code></span>
<span class="codeline" id="line-6522"><code>// to nanotime or zero. Returns now or the current time if now was zero.</code></span>
<span class="codeline" id="line-6523"><code>//</code></span>
<span class="codeline" id="line-6524"><code>// This releases ownership of p. Once sched.lock is released it is no longer</code></span>
<span class="codeline" id="line-6525"><code>// safe to use p.</code></span>
<span class="codeline" id="line-6526"><code>//</code></span>
<span class="codeline" id="line-6527"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6528"><code>//</code></span>
<span class="codeline" id="line-6529"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6530"><code>//</code></span>
<span class="codeline" id="line-6531"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6532"><code>func pidleput(pp *p, now int64) int64 {</code></span>
<span class="codeline" id="line-6533"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6534"><code></code></span>
<span class="codeline" id="line-6535"><code>	if !runqempty(pp) {</code></span>
<span class="codeline" id="line-6536"><code>		throw("pidleput: P has non-empty run queue")</code></span>
<span class="codeline" id="line-6537"><code>	}</code></span>
<span class="codeline" id="line-6538"><code>	if now == 0 {</code></span>
<span class="codeline" id="line-6539"><code>		now = nanotime()</code></span>
<span class="codeline" id="line-6540"><code>	}</code></span>
<span class="codeline" id="line-6541"><code>	updateTimerPMask(pp) // clear if there are no timers.</code></span>
<span class="codeline" id="line-6542"><code>	idlepMask.set(pp.id)</code></span>
<span class="codeline" id="line-6543"><code>	pp.link = sched.pidle</code></span>
<span class="codeline" id="line-6544"><code>	sched.pidle.set(pp)</code></span>
<span class="codeline" id="line-6545"><code>	sched.npidle.Add(1)</code></span>
<span class="codeline" id="line-6546"><code>	if !pp.limiterEvent.start(limiterEventIdle, now) {</code></span>
<span class="codeline" id="line-6547"><code>		throw("must be able to track idle limiter event")</code></span>
<span class="codeline" id="line-6548"><code>	}</code></span>
<span class="codeline" id="line-6549"><code>	return now</code></span>
<span class="codeline" id="line-6550"><code>}</code></span>
<span class="codeline" id="line-6551"><code></code></span>
<span class="codeline" id="line-6552"><code>// pidleget tries to get a p from the _Pidle list, acquiring ownership.</code></span>
<span class="codeline" id="line-6553"><code>//</code></span>
<span class="codeline" id="line-6554"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6555"><code>//</code></span>
<span class="codeline" id="line-6556"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6557"><code>//</code></span>
<span class="codeline" id="line-6558"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6559"><code>func pidleget(now int64) (*p, int64) {</code></span>
<span class="codeline" id="line-6560"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6561"><code></code></span>
<span class="codeline" id="line-6562"><code>	pp := sched.pidle.ptr()</code></span>
<span class="codeline" id="line-6563"><code>	if pp != nil {</code></span>
<span class="codeline" id="line-6564"><code>		// Timer may get added at any time now.</code></span>
<span class="codeline" id="line-6565"><code>		if now == 0 {</code></span>
<span class="codeline" id="line-6566"><code>			now = nanotime()</code></span>
<span class="codeline" id="line-6567"><code>		}</code></span>
<span class="codeline" id="line-6568"><code>		timerpMask.set(pp.id)</code></span>
<span class="codeline" id="line-6569"><code>		idlepMask.clear(pp.id)</code></span>
<span class="codeline" id="line-6570"><code>		sched.pidle = pp.link</code></span>
<span class="codeline" id="line-6571"><code>		sched.npidle.Add(-1)</code></span>
<span class="codeline" id="line-6572"><code>		pp.limiterEvent.stop(limiterEventIdle, now)</code></span>
<span class="codeline" id="line-6573"><code>	}</code></span>
<span class="codeline" id="line-6574"><code>	return pp, now</code></span>
<span class="codeline" id="line-6575"><code>}</code></span>
<span class="codeline" id="line-6576"><code></code></span>
<span class="codeline" id="line-6577"><code>// pidlegetSpinning tries to get a p from the _Pidle list, acquiring ownership.</code></span>
<span class="codeline" id="line-6578"><code>// This is called by spinning Ms (or callers than need a spinning M) that have</code></span>
<span class="codeline" id="line-6579"><code>// found work. If no P is available, this must synchronized with non-spinning</code></span>
<span class="codeline" id="line-6580"><code>// Ms that may be preparing to drop their P without discovering this work.</code></span>
<span class="codeline" id="line-6581"><code>//</code></span>
<span class="codeline" id="line-6582"><code>// sched.lock must be held.</code></span>
<span class="codeline" id="line-6583"><code>//</code></span>
<span class="codeline" id="line-6584"><code>// May run during STW, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-6585"><code>//</code></span>
<span class="codeline" id="line-6586"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-6587"><code>func pidlegetSpinning(now int64) (*p, int64) {</code></span>
<span class="codeline" id="line-6588"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6589"><code></code></span>
<span class="codeline" id="line-6590"><code>	pp, now := pidleget(now)</code></span>
<span class="codeline" id="line-6591"><code>	if pp == nil {</code></span>
<span class="codeline" id="line-6592"><code>		// See "Delicate dance" comment in findrunnable. We found work</code></span>
<span class="codeline" id="line-6593"><code>		// that we cannot take, we must synchronize with non-spinning</code></span>
<span class="codeline" id="line-6594"><code>		// Ms that may be preparing to drop their P.</code></span>
<span class="codeline" id="line-6595"><code>		sched.needspinning.Store(1)</code></span>
<span class="codeline" id="line-6596"><code>		return nil, now</code></span>
<span class="codeline" id="line-6597"><code>	}</code></span>
<span class="codeline" id="line-6598"><code></code></span>
<span class="codeline" id="line-6599"><code>	return pp, now</code></span>
<span class="codeline" id="line-6600"><code>}</code></span>
<span class="codeline" id="line-6601"><code></code></span>
<span class="codeline" id="line-6602"><code>// runqempty reports whether pp has no Gs on its local run queue.</code></span>
<span class="codeline" id="line-6603"><code>// It never returns true spuriously.</code></span>
<span class="codeline" id="line-6604"><code>func runqempty(pp *p) bool {</code></span>
<span class="codeline" id="line-6605"><code>	// Defend against a race where 1) pp has G1 in runqnext but runqhead == runqtail,</code></span>
<span class="codeline" id="line-6606"><code>	// 2) runqput on pp kicks G1 to the runq, 3) runqget on pp empties runqnext.</code></span>
<span class="codeline" id="line-6607"><code>	// Simply observing that runqhead == runqtail and then observing that runqnext == nil</code></span>
<span class="codeline" id="line-6608"><code>	// does not mean the queue is empty.</code></span>
<span class="codeline" id="line-6609"><code>	for {</code></span>
<span class="codeline" id="line-6610"><code>		head := atomic.Load(&amp;pp.runqhead)</code></span>
<span class="codeline" id="line-6611"><code>		tail := atomic.Load(&amp;pp.runqtail)</code></span>
<span class="codeline" id="line-6612"><code>		runnext := atomic.Loaduintptr((*uintptr)(unsafe.Pointer(&amp;pp.runnext)))</code></span>
<span class="codeline" id="line-6613"><code>		if tail == atomic.Load(&amp;pp.runqtail) {</code></span>
<span class="codeline" id="line-6614"><code>			return head == tail &amp;&amp; runnext == 0</code></span>
<span class="codeline" id="line-6615"><code>		}</code></span>
<span class="codeline" id="line-6616"><code>	}</code></span>
<span class="codeline" id="line-6617"><code>}</code></span>
<span class="codeline" id="line-6618"><code></code></span>
<span class="codeline" id="line-6619"><code>// To shake out latent assumptions about scheduling order,</code></span>
<span class="codeline" id="line-6620"><code>// we introduce some randomness into scheduling decisions</code></span>
<span class="codeline" id="line-6621"><code>// when running with the race detector.</code></span>
<span class="codeline" id="line-6622"><code>// The need for this was made obvious by changing the</code></span>
<span class="codeline" id="line-6623"><code>// (deterministic) scheduling order in Go 1.5 and breaking</code></span>
<span class="codeline" id="line-6624"><code>// many poorly-written tests.</code></span>
<span class="codeline" id="line-6625"><code>// With the randomness here, as long as the tests pass</code></span>
<span class="codeline" id="line-6626"><code>// consistently with -race, they shouldn't have latent scheduling</code></span>
<span class="codeline" id="line-6627"><code>// assumptions.</code></span>
<span class="codeline" id="line-6628"><code>const randomizeScheduler = raceenabled</code></span>
<span class="codeline" id="line-6629"><code></code></span>
<span class="codeline" id="line-6630"><code>// runqput tries to put g on the local runnable queue.</code></span>
<span class="codeline" id="line-6631"><code>// If next is false, runqput adds g to the tail of the runnable queue.</code></span>
<span class="codeline" id="line-6632"><code>// If next is true, runqput puts g in the pp.runnext slot.</code></span>
<span class="codeline" id="line-6633"><code>// If the run queue is full, runnext puts g on the global queue.</code></span>
<span class="codeline" id="line-6634"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-6635"><code>func runqput(pp *p, gp *g, next bool) {</code></span>
<span class="codeline" id="line-6636"><code>	if randomizeScheduler &amp;&amp; next &amp;&amp; randn(2) == 0 {</code></span>
<span class="codeline" id="line-6637"><code>		next = false</code></span>
<span class="codeline" id="line-6638"><code>	}</code></span>
<span class="codeline" id="line-6639"><code></code></span>
<span class="codeline" id="line-6640"><code>	if next {</code></span>
<span class="codeline" id="line-6641"><code>	retryNext:</code></span>
<span class="codeline" id="line-6642"><code>		oldnext := pp.runnext</code></span>
<span class="codeline" id="line-6643"><code>		if !pp.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {</code></span>
<span class="codeline" id="line-6644"><code>			goto retryNext</code></span>
<span class="codeline" id="line-6645"><code>		}</code></span>
<span class="codeline" id="line-6646"><code>		if oldnext == 0 {</code></span>
<span class="codeline" id="line-6647"><code>			return</code></span>
<span class="codeline" id="line-6648"><code>		}</code></span>
<span class="codeline" id="line-6649"><code>		// Kick the old runnext out to the regular run queue.</code></span>
<span class="codeline" id="line-6650"><code>		gp = oldnext.ptr()</code></span>
<span class="codeline" id="line-6651"><code>	}</code></span>
<span class="codeline" id="line-6652"><code></code></span>
<span class="codeline" id="line-6653"><code>retry:</code></span>
<span class="codeline" id="line-6654"><code>	h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with consumers</code></span>
<span class="codeline" id="line-6655"><code>	t := pp.runqtail</code></span>
<span class="codeline" id="line-6656"><code>	if t-h &lt; uint32(len(pp.runq)) {</code></span>
<span class="codeline" id="line-6657"><code>		pp.runq[t%uint32(len(pp.runq))].set(gp)</code></span>
<span class="codeline" id="line-6658"><code>		atomic.StoreRel(&amp;pp.runqtail, t+1) // store-release, makes the item available for consumption</code></span>
<span class="codeline" id="line-6659"><code>		return</code></span>
<span class="codeline" id="line-6660"><code>	}</code></span>
<span class="codeline" id="line-6661"><code>	if runqputslow(pp, gp, h, t) {</code></span>
<span class="codeline" id="line-6662"><code>		return</code></span>
<span class="codeline" id="line-6663"><code>	}</code></span>
<span class="codeline" id="line-6664"><code>	// the queue is not full, now the put above must succeed</code></span>
<span class="codeline" id="line-6665"><code>	goto retry</code></span>
<span class="codeline" id="line-6666"><code>}</code></span>
<span class="codeline" id="line-6667"><code></code></span>
<span class="codeline" id="line-6668"><code>// Put g and a batch of work from local runnable queue on global queue.</code></span>
<span class="codeline" id="line-6669"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-6670"><code>func runqputslow(pp *p, gp *g, h, t uint32) bool {</code></span>
<span class="codeline" id="line-6671"><code>	var batch [len(pp.runq)/2 + 1]*g</code></span>
<span class="codeline" id="line-6672"><code></code></span>
<span class="codeline" id="line-6673"><code>	// First, grab a batch from local queue.</code></span>
<span class="codeline" id="line-6674"><code>	n := t - h</code></span>
<span class="codeline" id="line-6675"><code>	n = n / 2</code></span>
<span class="codeline" id="line-6676"><code>	if n != uint32(len(pp.runq)/2) {</code></span>
<span class="codeline" id="line-6677"><code>		throw("runqputslow: queue is not full")</code></span>
<span class="codeline" id="line-6678"><code>	}</code></span>
<span class="codeline" id="line-6679"><code>	for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-6680"><code>		batch[i] = pp.runq[(h+i)%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-6681"><code>	}</code></span>
<span class="codeline" id="line-6682"><code>	if !atomic.CasRel(&amp;pp.runqhead, h, h+n) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-6683"><code>		return false</code></span>
<span class="codeline" id="line-6684"><code>	}</code></span>
<span class="codeline" id="line-6685"><code>	batch[n] = gp</code></span>
<span class="codeline" id="line-6686"><code></code></span>
<span class="codeline" id="line-6687"><code>	if randomizeScheduler {</code></span>
<span class="codeline" id="line-6688"><code>		for i := uint32(1); i &lt;= n; i++ {</code></span>
<span class="codeline" id="line-6689"><code>			j := cheaprandn(i + 1)</code></span>
<span class="codeline" id="line-6690"><code>			batch[i], batch[j] = batch[j], batch[i]</code></span>
<span class="codeline" id="line-6691"><code>		}</code></span>
<span class="codeline" id="line-6692"><code>	}</code></span>
<span class="codeline" id="line-6693"><code></code></span>
<span class="codeline" id="line-6694"><code>	// Link the goroutines.</code></span>
<span class="codeline" id="line-6695"><code>	for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-6696"><code>		batch[i].schedlink.set(batch[i+1])</code></span>
<span class="codeline" id="line-6697"><code>	}</code></span>
<span class="codeline" id="line-6698"><code>	var q gQueue</code></span>
<span class="codeline" id="line-6699"><code>	q.head.set(batch[0])</code></span>
<span class="codeline" id="line-6700"><code>	q.tail.set(batch[n])</code></span>
<span class="codeline" id="line-6701"><code></code></span>
<span class="codeline" id="line-6702"><code>	// Now put the batch on global queue.</code></span>
<span class="codeline" id="line-6703"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6704"><code>	globrunqputbatch(&amp;q, int32(n+1))</code></span>
<span class="codeline" id="line-6705"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6706"><code>	return true</code></span>
<span class="codeline" id="line-6707"><code>}</code></span>
<span class="codeline" id="line-6708"><code></code></span>
<span class="codeline" id="line-6709"><code>// runqputbatch tries to put all the G's on q on the local runnable queue.</code></span>
<span class="codeline" id="line-6710"><code>// If the queue is full, they are put on the global queue; in that case</code></span>
<span class="codeline" id="line-6711"><code>// this will temporarily acquire the scheduler lock.</code></span>
<span class="codeline" id="line-6712"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-6713"><code>func runqputbatch(pp *p, q *gQueue, qsize int) {</code></span>
<span class="codeline" id="line-6714"><code>	h := atomic.LoadAcq(&amp;pp.runqhead)</code></span>
<span class="codeline" id="line-6715"><code>	t := pp.runqtail</code></span>
<span class="codeline" id="line-6716"><code>	n := uint32(0)</code></span>
<span class="codeline" id="line-6717"><code>	for !q.empty() &amp;&amp; t-h &lt; uint32(len(pp.runq)) {</code></span>
<span class="codeline" id="line-6718"><code>		gp := q.pop()</code></span>
<span class="codeline" id="line-6719"><code>		pp.runq[t%uint32(len(pp.runq))].set(gp)</code></span>
<span class="codeline" id="line-6720"><code>		t++</code></span>
<span class="codeline" id="line-6721"><code>		n++</code></span>
<span class="codeline" id="line-6722"><code>	}</code></span>
<span class="codeline" id="line-6723"><code>	qsize -= int(n)</code></span>
<span class="codeline" id="line-6724"><code></code></span>
<span class="codeline" id="line-6725"><code>	if randomizeScheduler {</code></span>
<span class="codeline" id="line-6726"><code>		off := func(o uint32) uint32 {</code></span>
<span class="codeline" id="line-6727"><code>			return (pp.runqtail + o) % uint32(len(pp.runq))</code></span>
<span class="codeline" id="line-6728"><code>		}</code></span>
<span class="codeline" id="line-6729"><code>		for i := uint32(1); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-6730"><code>			j := cheaprandn(i + 1)</code></span>
<span class="codeline" id="line-6731"><code>			pp.runq[off(i)], pp.runq[off(j)] = pp.runq[off(j)], pp.runq[off(i)]</code></span>
<span class="codeline" id="line-6732"><code>		}</code></span>
<span class="codeline" id="line-6733"><code>	}</code></span>
<span class="codeline" id="line-6734"><code></code></span>
<span class="codeline" id="line-6735"><code>	atomic.StoreRel(&amp;pp.runqtail, t)</code></span>
<span class="codeline" id="line-6736"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-6737"><code>		lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6738"><code>		globrunqputbatch(q, int32(qsize))</code></span>
<span class="codeline" id="line-6739"><code>		unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6740"><code>	}</code></span>
<span class="codeline" id="line-6741"><code>}</code></span>
<span class="codeline" id="line-6742"><code></code></span>
<span class="codeline" id="line-6743"><code>// Get g from local runnable queue.</code></span>
<span class="codeline" id="line-6744"><code>// If inheritTime is true, gp should inherit the remaining time in the</code></span>
<span class="codeline" id="line-6745"><code>// current time slice. Otherwise, it should start a new time slice.</code></span>
<span class="codeline" id="line-6746"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-6747"><code>func runqget(pp *p) (gp *g, inheritTime bool) {</code></span>
<span class="codeline" id="line-6748"><code>	// If there's a runnext, it's the next G to run.</code></span>
<span class="codeline" id="line-6749"><code>	next := pp.runnext</code></span>
<span class="codeline" id="line-6750"><code>	// If the runnext is non-0 and the CAS fails, it could only have been stolen by another P,</code></span>
<span class="codeline" id="line-6751"><code>	// because other Ps can race to set runnext to 0, but only the current P can set it to non-0.</code></span>
<span class="codeline" id="line-6752"><code>	// Hence, there's no need to retry this CAS if it fails.</code></span>
<span class="codeline" id="line-6753"><code>	if next != 0 &amp;&amp; pp.runnext.cas(next, 0) {</code></span>
<span class="codeline" id="line-6754"><code>		return next.ptr(), true</code></span>
<span class="codeline" id="line-6755"><code>	}</code></span>
<span class="codeline" id="line-6756"><code></code></span>
<span class="codeline" id="line-6757"><code>	for {</code></span>
<span class="codeline" id="line-6758"><code>		h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with other consumers</code></span>
<span class="codeline" id="line-6759"><code>		t := pp.runqtail</code></span>
<span class="codeline" id="line-6760"><code>		if t == h {</code></span>
<span class="codeline" id="line-6761"><code>			return nil, false</code></span>
<span class="codeline" id="line-6762"><code>		}</code></span>
<span class="codeline" id="line-6763"><code>		gp := pp.runq[h%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-6764"><code>		if atomic.CasRel(&amp;pp.runqhead, h, h+1) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-6765"><code>			return gp, false</code></span>
<span class="codeline" id="line-6766"><code>		}</code></span>
<span class="codeline" id="line-6767"><code>	}</code></span>
<span class="codeline" id="line-6768"><code>}</code></span>
<span class="codeline" id="line-6769"><code></code></span>
<span class="codeline" id="line-6770"><code>// runqdrain drains the local runnable queue of pp and returns all goroutines in it.</code></span>
<span class="codeline" id="line-6771"><code>// Executed only by the owner P.</code></span>
<span class="codeline" id="line-6772"><code>func runqdrain(pp *p) (drainQ gQueue, n uint32) {</code></span>
<span class="codeline" id="line-6773"><code>	oldNext := pp.runnext</code></span>
<span class="codeline" id="line-6774"><code>	if oldNext != 0 &amp;&amp; pp.runnext.cas(oldNext, 0) {</code></span>
<span class="codeline" id="line-6775"><code>		drainQ.pushBack(oldNext.ptr())</code></span>
<span class="codeline" id="line-6776"><code>		n++</code></span>
<span class="codeline" id="line-6777"><code>	}</code></span>
<span class="codeline" id="line-6778"><code></code></span>
<span class="codeline" id="line-6779"><code>retry:</code></span>
<span class="codeline" id="line-6780"><code>	h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with other consumers</code></span>
<span class="codeline" id="line-6781"><code>	t := pp.runqtail</code></span>
<span class="codeline" id="line-6782"><code>	qn := t - h</code></span>
<span class="codeline" id="line-6783"><code>	if qn == 0 {</code></span>
<span class="codeline" id="line-6784"><code>		return</code></span>
<span class="codeline" id="line-6785"><code>	}</code></span>
<span class="codeline" id="line-6786"><code>	if qn &gt; uint32(len(pp.runq)) { // read inconsistent h and t</code></span>
<span class="codeline" id="line-6787"><code>		goto retry</code></span>
<span class="codeline" id="line-6788"><code>	}</code></span>
<span class="codeline" id="line-6789"><code></code></span>
<span class="codeline" id="line-6790"><code>	if !atomic.CasRel(&amp;pp.runqhead, h, h+qn) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-6791"><code>		goto retry</code></span>
<span class="codeline" id="line-6792"><code>	}</code></span>
<span class="codeline" id="line-6793"><code></code></span>
<span class="codeline" id="line-6794"><code>	// We've inverted the order in which it gets G's from the local P's runnable queue</code></span>
<span class="codeline" id="line-6795"><code>	// and then advances the head pointer because we don't want to mess up the statuses of G's</code></span>
<span class="codeline" id="line-6796"><code>	// while runqdrain() and runqsteal() are running in parallel.</code></span>
<span class="codeline" id="line-6797"><code>	// Thus we should advance the head pointer before draining the local P into a gQueue,</code></span>
<span class="codeline" id="line-6798"><code>	// so that we can update any gp.schedlink only after we take the full ownership of G,</code></span>
<span class="codeline" id="line-6799"><code>	// meanwhile, other P's can't access to all G's in local P's runnable queue and steal them.</code></span>
<span class="codeline" id="line-6800"><code>	// See https://groups.google.com/g/golang-dev/c/0pTKxEKhHSc/m/6Q85QjdVBQAJ for more details.</code></span>
<span class="codeline" id="line-6801"><code>	for i := uint32(0); i &lt; qn; i++ {</code></span>
<span class="codeline" id="line-6802"><code>		gp := pp.runq[(h+i)%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-6803"><code>		drainQ.pushBack(gp)</code></span>
<span class="codeline" id="line-6804"><code>		n++</code></span>
<span class="codeline" id="line-6805"><code>	}</code></span>
<span class="codeline" id="line-6806"><code>	return</code></span>
<span class="codeline" id="line-6807"><code>}</code></span>
<span class="codeline" id="line-6808"><code></code></span>
<span class="codeline" id="line-6809"><code>// Grabs a batch of goroutines from pp's runnable queue into batch.</code></span>
<span class="codeline" id="line-6810"><code>// Batch is a ring buffer starting at batchHead.</code></span>
<span class="codeline" id="line-6811"><code>// Returns number of grabbed goroutines.</code></span>
<span class="codeline" id="line-6812"><code>// Can be executed by any P.</code></span>
<span class="codeline" id="line-6813"><code>func runqgrab(pp *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {</code></span>
<span class="codeline" id="line-6814"><code>	for {</code></span>
<span class="codeline" id="line-6815"><code>		h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with other consumers</code></span>
<span class="codeline" id="line-6816"><code>		t := atomic.LoadAcq(&amp;pp.runqtail) // load-acquire, synchronize with the producer</code></span>
<span class="codeline" id="line-6817"><code>		n := t - h</code></span>
<span class="codeline" id="line-6818"><code>		n = n - n/2</code></span>
<span class="codeline" id="line-6819"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-6820"><code>			if stealRunNextG {</code></span>
<span class="codeline" id="line-6821"><code>				// Try to steal from pp.runnext.</code></span>
<span class="codeline" id="line-6822"><code>				if next := pp.runnext; next != 0 {</code></span>
<span class="codeline" id="line-6823"><code>					if pp.status == _Prunning {</code></span>
<span class="codeline" id="line-6824"><code>						// Sleep to ensure that pp isn't about to run the g</code></span>
<span class="codeline" id="line-6825"><code>						// we are about to steal.</code></span>
<span class="codeline" id="line-6826"><code>						// The important use case here is when the g running</code></span>
<span class="codeline" id="line-6827"><code>						// on pp ready()s another g and then almost</code></span>
<span class="codeline" id="line-6828"><code>						// immediately blocks. Instead of stealing runnext</code></span>
<span class="codeline" id="line-6829"><code>						// in this window, back off to give pp a chance to</code></span>
<span class="codeline" id="line-6830"><code>						// schedule runnext. This will avoid thrashing gs</code></span>
<span class="codeline" id="line-6831"><code>						// between different Ps.</code></span>
<span class="codeline" id="line-6832"><code>						// A sync chan send/recv takes ~50ns as of time of</code></span>
<span class="codeline" id="line-6833"><code>						// writing, so 3us gives ~50x overshoot.</code></span>
<span class="codeline" id="line-6834"><code>						if !osHasLowResTimer {</code></span>
<span class="codeline" id="line-6835"><code>							usleep(3)</code></span>
<span class="codeline" id="line-6836"><code>						} else {</code></span>
<span class="codeline" id="line-6837"><code>							// On some platforms system timer granularity is</code></span>
<span class="codeline" id="line-6838"><code>							// 1-15ms, which is way too much for this</code></span>
<span class="codeline" id="line-6839"><code>							// optimization. So just yield.</code></span>
<span class="codeline" id="line-6840"><code>							osyield()</code></span>
<span class="codeline" id="line-6841"><code>						}</code></span>
<span class="codeline" id="line-6842"><code>					}</code></span>
<span class="codeline" id="line-6843"><code>					if !pp.runnext.cas(next, 0) {</code></span>
<span class="codeline" id="line-6844"><code>						continue</code></span>
<span class="codeline" id="line-6845"><code>					}</code></span>
<span class="codeline" id="line-6846"><code>					batch[batchHead%uint32(len(batch))] = next</code></span>
<span class="codeline" id="line-6847"><code>					return 1</code></span>
<span class="codeline" id="line-6848"><code>				}</code></span>
<span class="codeline" id="line-6849"><code>			}</code></span>
<span class="codeline" id="line-6850"><code>			return 0</code></span>
<span class="codeline" id="line-6851"><code>		}</code></span>
<span class="codeline" id="line-6852"><code>		if n &gt; uint32(len(pp.runq)/2) { // read inconsistent h and t</code></span>
<span class="codeline" id="line-6853"><code>			continue</code></span>
<span class="codeline" id="line-6854"><code>		}</code></span>
<span class="codeline" id="line-6855"><code>		for i := uint32(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-6856"><code>			g := pp.runq[(h+i)%uint32(len(pp.runq))]</code></span>
<span class="codeline" id="line-6857"><code>			batch[(batchHead+i)%uint32(len(batch))] = g</code></span>
<span class="codeline" id="line-6858"><code>		}</code></span>
<span class="codeline" id="line-6859"><code>		if atomic.CasRel(&amp;pp.runqhead, h, h+n) { // cas-release, commits consume</code></span>
<span class="codeline" id="line-6860"><code>			return n</code></span>
<span class="codeline" id="line-6861"><code>		}</code></span>
<span class="codeline" id="line-6862"><code>	}</code></span>
<span class="codeline" id="line-6863"><code>}</code></span>
<span class="codeline" id="line-6864"><code></code></span>
<span class="codeline" id="line-6865"><code>// Steal half of elements from local runnable queue of p2</code></span>
<span class="codeline" id="line-6866"><code>// and put onto local runnable queue of p.</code></span>
<span class="codeline" id="line-6867"><code>// Returns one of the stolen elements (or nil if failed).</code></span>
<span class="codeline" id="line-6868"><code>func runqsteal(pp, p2 *p, stealRunNextG bool) *g {</code></span>
<span class="codeline" id="line-6869"><code>	t := pp.runqtail</code></span>
<span class="codeline" id="line-6870"><code>	n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)</code></span>
<span class="codeline" id="line-6871"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-6872"><code>		return nil</code></span>
<span class="codeline" id="line-6873"><code>	}</code></span>
<span class="codeline" id="line-6874"><code>	n--</code></span>
<span class="codeline" id="line-6875"><code>	gp := pp.runq[(t+n)%uint32(len(pp.runq))].ptr()</code></span>
<span class="codeline" id="line-6876"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-6877"><code>		return gp</code></span>
<span class="codeline" id="line-6878"><code>	}</code></span>
<span class="codeline" id="line-6879"><code>	h := atomic.LoadAcq(&amp;pp.runqhead) // load-acquire, synchronize with consumers</code></span>
<span class="codeline" id="line-6880"><code>	if t-h+n &gt;= uint32(len(pp.runq)) {</code></span>
<span class="codeline" id="line-6881"><code>		throw("runqsteal: runq overflow")</code></span>
<span class="codeline" id="line-6882"><code>	}</code></span>
<span class="codeline" id="line-6883"><code>	atomic.StoreRel(&amp;pp.runqtail, t+n) // store-release, makes the item available for consumption</code></span>
<span class="codeline" id="line-6884"><code>	return gp</code></span>
<span class="codeline" id="line-6885"><code>}</code></span>
<span class="codeline" id="line-6886"><code></code></span>
<span class="codeline" id="line-6887"><code>// A gQueue is a dequeue of Gs linked through g.schedlink. A G can only</code></span>
<span class="codeline" id="line-6888"><code>// be on one gQueue or gList at a time.</code></span>
<span class="codeline" id="line-6889"><code>type gQueue struct {</code></span>
<span class="codeline" id="line-6890"><code>	head guintptr</code></span>
<span class="codeline" id="line-6891"><code>	tail guintptr</code></span>
<span class="codeline" id="line-6892"><code>}</code></span>
<span class="codeline" id="line-6893"><code></code></span>
<span class="codeline" id="line-6894"><code>// empty reports whether q is empty.</code></span>
<span class="codeline" id="line-6895"><code>func (q *gQueue) empty() bool {</code></span>
<span class="codeline" id="line-6896"><code>	return q.head == 0</code></span>
<span class="codeline" id="line-6897"><code>}</code></span>
<span class="codeline" id="line-6898"><code></code></span>
<span class="codeline" id="line-6899"><code>// push adds gp to the head of q.</code></span>
<span class="codeline" id="line-6900"><code>func (q *gQueue) push(gp *g) {</code></span>
<span class="codeline" id="line-6901"><code>	gp.schedlink = q.head</code></span>
<span class="codeline" id="line-6902"><code>	q.head.set(gp)</code></span>
<span class="codeline" id="line-6903"><code>	if q.tail == 0 {</code></span>
<span class="codeline" id="line-6904"><code>		q.tail.set(gp)</code></span>
<span class="codeline" id="line-6905"><code>	}</code></span>
<span class="codeline" id="line-6906"><code>}</code></span>
<span class="codeline" id="line-6907"><code></code></span>
<span class="codeline" id="line-6908"><code>// pushBack adds gp to the tail of q.</code></span>
<span class="codeline" id="line-6909"><code>func (q *gQueue) pushBack(gp *g) {</code></span>
<span class="codeline" id="line-6910"><code>	gp.schedlink = 0</code></span>
<span class="codeline" id="line-6911"><code>	if q.tail != 0 {</code></span>
<span class="codeline" id="line-6912"><code>		q.tail.ptr().schedlink.set(gp)</code></span>
<span class="codeline" id="line-6913"><code>	} else {</code></span>
<span class="codeline" id="line-6914"><code>		q.head.set(gp)</code></span>
<span class="codeline" id="line-6915"><code>	}</code></span>
<span class="codeline" id="line-6916"><code>	q.tail.set(gp)</code></span>
<span class="codeline" id="line-6917"><code>}</code></span>
<span class="codeline" id="line-6918"><code></code></span>
<span class="codeline" id="line-6919"><code>// pushBackAll adds all Gs in q2 to the tail of q. After this q2 must</code></span>
<span class="codeline" id="line-6920"><code>// not be used.</code></span>
<span class="codeline" id="line-6921"><code>func (q *gQueue) pushBackAll(q2 gQueue) {</code></span>
<span class="codeline" id="line-6922"><code>	if q2.tail == 0 {</code></span>
<span class="codeline" id="line-6923"><code>		return</code></span>
<span class="codeline" id="line-6924"><code>	}</code></span>
<span class="codeline" id="line-6925"><code>	q2.tail.ptr().schedlink = 0</code></span>
<span class="codeline" id="line-6926"><code>	if q.tail != 0 {</code></span>
<span class="codeline" id="line-6927"><code>		q.tail.ptr().schedlink = q2.head</code></span>
<span class="codeline" id="line-6928"><code>	} else {</code></span>
<span class="codeline" id="line-6929"><code>		q.head = q2.head</code></span>
<span class="codeline" id="line-6930"><code>	}</code></span>
<span class="codeline" id="line-6931"><code>	q.tail = q2.tail</code></span>
<span class="codeline" id="line-6932"><code>}</code></span>
<span class="codeline" id="line-6933"><code></code></span>
<span class="codeline" id="line-6934"><code>// pop removes and returns the head of queue q. It returns nil if</code></span>
<span class="codeline" id="line-6935"><code>// q is empty.</code></span>
<span class="codeline" id="line-6936"><code>func (q *gQueue) pop() *g {</code></span>
<span class="codeline" id="line-6937"><code>	gp := q.head.ptr()</code></span>
<span class="codeline" id="line-6938"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-6939"><code>		q.head = gp.schedlink</code></span>
<span class="codeline" id="line-6940"><code>		if q.head == 0 {</code></span>
<span class="codeline" id="line-6941"><code>			q.tail = 0</code></span>
<span class="codeline" id="line-6942"><code>		}</code></span>
<span class="codeline" id="line-6943"><code>	}</code></span>
<span class="codeline" id="line-6944"><code>	return gp</code></span>
<span class="codeline" id="line-6945"><code>}</code></span>
<span class="codeline" id="line-6946"><code></code></span>
<span class="codeline" id="line-6947"><code>// popList takes all Gs in q and returns them as a gList.</code></span>
<span class="codeline" id="line-6948"><code>func (q *gQueue) popList() gList {</code></span>
<span class="codeline" id="line-6949"><code>	stack := gList{q.head}</code></span>
<span class="codeline" id="line-6950"><code>	*q = gQueue{}</code></span>
<span class="codeline" id="line-6951"><code>	return stack</code></span>
<span class="codeline" id="line-6952"><code>}</code></span>
<span class="codeline" id="line-6953"><code></code></span>
<span class="codeline" id="line-6954"><code>// A gList is a list of Gs linked through g.schedlink. A G can only be</code></span>
<span class="codeline" id="line-6955"><code>// on one gQueue or gList at a time.</code></span>
<span class="codeline" id="line-6956"><code>type gList struct {</code></span>
<span class="codeline" id="line-6957"><code>	head guintptr</code></span>
<span class="codeline" id="line-6958"><code>}</code></span>
<span class="codeline" id="line-6959"><code></code></span>
<span class="codeline" id="line-6960"><code>// empty reports whether l is empty.</code></span>
<span class="codeline" id="line-6961"><code>func (l *gList) empty() bool {</code></span>
<span class="codeline" id="line-6962"><code>	return l.head == 0</code></span>
<span class="codeline" id="line-6963"><code>}</code></span>
<span class="codeline" id="line-6964"><code></code></span>
<span class="codeline" id="line-6965"><code>// push adds gp to the head of l.</code></span>
<span class="codeline" id="line-6966"><code>func (l *gList) push(gp *g) {</code></span>
<span class="codeline" id="line-6967"><code>	gp.schedlink = l.head</code></span>
<span class="codeline" id="line-6968"><code>	l.head.set(gp)</code></span>
<span class="codeline" id="line-6969"><code>}</code></span>
<span class="codeline" id="line-6970"><code></code></span>
<span class="codeline" id="line-6971"><code>// pushAll prepends all Gs in q to l.</code></span>
<span class="codeline" id="line-6972"><code>func (l *gList) pushAll(q gQueue) {</code></span>
<span class="codeline" id="line-6973"><code>	if !q.empty() {</code></span>
<span class="codeline" id="line-6974"><code>		q.tail.ptr().schedlink = l.head</code></span>
<span class="codeline" id="line-6975"><code>		l.head = q.head</code></span>
<span class="codeline" id="line-6976"><code>	}</code></span>
<span class="codeline" id="line-6977"><code>}</code></span>
<span class="codeline" id="line-6978"><code></code></span>
<span class="codeline" id="line-6979"><code>// pop removes and returns the head of l. If l is empty, it returns nil.</code></span>
<span class="codeline" id="line-6980"><code>func (l *gList) pop() *g {</code></span>
<span class="codeline" id="line-6981"><code>	gp := l.head.ptr()</code></span>
<span class="codeline" id="line-6982"><code>	if gp != nil {</code></span>
<span class="codeline" id="line-6983"><code>		l.head = gp.schedlink</code></span>
<span class="codeline" id="line-6984"><code>	}</code></span>
<span class="codeline" id="line-6985"><code>	return gp</code></span>
<span class="codeline" id="line-6986"><code>}</code></span>
<span class="codeline" id="line-6987"><code></code></span>
<span class="codeline" id="line-6988"><code>//go:linkname setMaxThreads runtime/debug.setMaxThreads</code></span>
<span class="codeline" id="line-6989"><code>func setMaxThreads(in int) (out int) {</code></span>
<span class="codeline" id="line-6990"><code>	lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6991"><code>	out = int(sched.maxmcount)</code></span>
<span class="codeline" id="line-6992"><code>	if in &gt; 0x7fffffff { // MaxInt32</code></span>
<span class="codeline" id="line-6993"><code>		sched.maxmcount = 0x7fffffff</code></span>
<span class="codeline" id="line-6994"><code>	} else {</code></span>
<span class="codeline" id="line-6995"><code>		sched.maxmcount = int32(in)</code></span>
<span class="codeline" id="line-6996"><code>	}</code></span>
<span class="codeline" id="line-6997"><code>	checkmcount()</code></span>
<span class="codeline" id="line-6998"><code>	unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-6999"><code>	return</code></span>
<span class="codeline" id="line-7000"><code>}</code></span>
<span class="codeline" id="line-7001"><code></code></span>
<span class="codeline" id="line-7002"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7003"><code>func procPin() int {</code></span>
<span class="codeline" id="line-7004"><code>	gp := getg()</code></span>
<span class="codeline" id="line-7005"><code>	mp := gp.m</code></span>
<span class="codeline" id="line-7006"><code></code></span>
<span class="codeline" id="line-7007"><code>	mp.locks++</code></span>
<span class="codeline" id="line-7008"><code>	return int(mp.p.ptr().id)</code></span>
<span class="codeline" id="line-7009"><code>}</code></span>
<span class="codeline" id="line-7010"><code></code></span>
<span class="codeline" id="line-7011"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7012"><code>func procUnpin() {</code></span>
<span class="codeline" id="line-7013"><code>	gp := getg()</code></span>
<span class="codeline" id="line-7014"><code>	gp.m.locks--</code></span>
<span class="codeline" id="line-7015"><code>}</code></span>
<span class="codeline" id="line-7016"><code></code></span>
<span class="codeline" id="line-7017"><code>//go:linkname sync_runtime_procPin sync.runtime_procPin</code></span>
<span class="codeline" id="line-7018"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7019"><code>func sync_runtime_procPin() int {</code></span>
<span class="codeline" id="line-7020"><code>	return procPin()</code></span>
<span class="codeline" id="line-7021"><code>}</code></span>
<span class="codeline" id="line-7022"><code></code></span>
<span class="codeline" id="line-7023"><code>//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin</code></span>
<span class="codeline" id="line-7024"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7025"><code>func sync_runtime_procUnpin() {</code></span>
<span class="codeline" id="line-7026"><code>	procUnpin()</code></span>
<span class="codeline" id="line-7027"><code>}</code></span>
<span class="codeline" id="line-7028"><code></code></span>
<span class="codeline" id="line-7029"><code>//go:linkname sync_atomic_runtime_procPin sync/atomic.runtime_procPin</code></span>
<span class="codeline" id="line-7030"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7031"><code>func sync_atomic_runtime_procPin() int {</code></span>
<span class="codeline" id="line-7032"><code>	return procPin()</code></span>
<span class="codeline" id="line-7033"><code>}</code></span>
<span class="codeline" id="line-7034"><code></code></span>
<span class="codeline" id="line-7035"><code>//go:linkname sync_atomic_runtime_procUnpin sync/atomic.runtime_procUnpin</code></span>
<span class="codeline" id="line-7036"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7037"><code>func sync_atomic_runtime_procUnpin() {</code></span>
<span class="codeline" id="line-7038"><code>	procUnpin()</code></span>
<span class="codeline" id="line-7039"><code>}</code></span>
<span class="codeline" id="line-7040"><code></code></span>
<span class="codeline" id="line-7041"><code>// Active spinning for sync.Mutex.</code></span>
<span class="codeline" id="line-7042"><code>//</code></span>
<span class="codeline" id="line-7043"><code>//go:linkname sync_runtime_canSpin sync.runtime_canSpin</code></span>
<span class="codeline" id="line-7044"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7045"><code>func sync_runtime_canSpin(i int) bool {</code></span>
<span class="codeline" id="line-7046"><code>	// sync.Mutex is cooperative, so we are conservative with spinning.</code></span>
<span class="codeline" id="line-7047"><code>	// Spin only few times and only if running on a multicore machine and</code></span>
<span class="codeline" id="line-7048"><code>	// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.</code></span>
<span class="codeline" id="line-7049"><code>	// As opposed to runtime mutex we don't do passive spinning here,</code></span>
<span class="codeline" id="line-7050"><code>	// because there can be work on global runq or on other Ps.</code></span>
<span class="codeline" id="line-7051"><code>	if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= sched.npidle.Load()+sched.nmspinning.Load()+1 {</code></span>
<span class="codeline" id="line-7052"><code>		return false</code></span>
<span class="codeline" id="line-7053"><code>	}</code></span>
<span class="codeline" id="line-7054"><code>	if p := getg().m.p.ptr(); !runqempty(p) {</code></span>
<span class="codeline" id="line-7055"><code>		return false</code></span>
<span class="codeline" id="line-7056"><code>	}</code></span>
<span class="codeline" id="line-7057"><code>	return true</code></span>
<span class="codeline" id="line-7058"><code>}</code></span>
<span class="codeline" id="line-7059"><code></code></span>
<span class="codeline" id="line-7060"><code>//go:linkname sync_runtime_doSpin sync.runtime_doSpin</code></span>
<span class="codeline" id="line-7061"><code>//go:nosplit</code></span>
<span class="codeline" id="line-7062"><code>func sync_runtime_doSpin() {</code></span>
<span class="codeline" id="line-7063"><code>	procyield(active_spin_cnt)</code></span>
<span class="codeline" id="line-7064"><code>}</code></span>
<span class="codeline" id="line-7065"><code></code></span>
<span class="codeline" id="line-7066"><code>var stealOrder randomOrder</code></span>
<span class="codeline" id="line-7067"><code></code></span>
<span class="codeline" id="line-7068"><code>// randomOrder/randomEnum are helper types for randomized work stealing.</code></span>
<span class="codeline" id="line-7069"><code>// They allow to enumerate all Ps in different pseudo-random orders without repetitions.</code></span>
<span class="codeline" id="line-7070"><code>// The algorithm is based on the fact that if we have X such that X and GOMAXPROCS</code></span>
<span class="codeline" id="line-7071"><code>// are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration.</code></span>
<span class="codeline" id="line-7072"><code>type randomOrder struct {</code></span>
<span class="codeline" id="line-7073"><code>	count    uint32</code></span>
<span class="codeline" id="line-7074"><code>	coprimes []uint32</code></span>
<span class="codeline" id="line-7075"><code>}</code></span>
<span class="codeline" id="line-7076"><code></code></span>
<span class="codeline" id="line-7077"><code>type randomEnum struct {</code></span>
<span class="codeline" id="line-7078"><code>	i     uint32</code></span>
<span class="codeline" id="line-7079"><code>	count uint32</code></span>
<span class="codeline" id="line-7080"><code>	pos   uint32</code></span>
<span class="codeline" id="line-7081"><code>	inc   uint32</code></span>
<span class="codeline" id="line-7082"><code>}</code></span>
<span class="codeline" id="line-7083"><code></code></span>
<span class="codeline" id="line-7084"><code>func (ord *randomOrder) reset(count uint32) {</code></span>
<span class="codeline" id="line-7085"><code>	ord.count = count</code></span>
<span class="codeline" id="line-7086"><code>	ord.coprimes = ord.coprimes[:0]</code></span>
<span class="codeline" id="line-7087"><code>	for i := uint32(1); i &lt;= count; i++ {</code></span>
<span class="codeline" id="line-7088"><code>		if gcd(i, count) == 1 {</code></span>
<span class="codeline" id="line-7089"><code>			ord.coprimes = append(ord.coprimes, i)</code></span>
<span class="codeline" id="line-7090"><code>		}</code></span>
<span class="codeline" id="line-7091"><code>	}</code></span>
<span class="codeline" id="line-7092"><code>}</code></span>
<span class="codeline" id="line-7093"><code></code></span>
<span class="codeline" id="line-7094"><code>func (ord *randomOrder) start(i uint32) randomEnum {</code></span>
<span class="codeline" id="line-7095"><code>	return randomEnum{</code></span>
<span class="codeline" id="line-7096"><code>		count: ord.count,</code></span>
<span class="codeline" id="line-7097"><code>		pos:   i % ord.count,</code></span>
<span class="codeline" id="line-7098"><code>		inc:   ord.coprimes[i/ord.count%uint32(len(ord.coprimes))],</code></span>
<span class="codeline" id="line-7099"><code>	}</code></span>
<span class="codeline" id="line-7100"><code>}</code></span>
<span class="codeline" id="line-7101"><code></code></span>
<span class="codeline" id="line-7102"><code>func (enum *randomEnum) done() bool {</code></span>
<span class="codeline" id="line-7103"><code>	return enum.i == enum.count</code></span>
<span class="codeline" id="line-7104"><code>}</code></span>
<span class="codeline" id="line-7105"><code></code></span>
<span class="codeline" id="line-7106"><code>func (enum *randomEnum) next() {</code></span>
<span class="codeline" id="line-7107"><code>	enum.i++</code></span>
<span class="codeline" id="line-7108"><code>	enum.pos = (enum.pos + enum.inc) % enum.count</code></span>
<span class="codeline" id="line-7109"><code>}</code></span>
<span class="codeline" id="line-7110"><code></code></span>
<span class="codeline" id="line-7111"><code>func (enum *randomEnum) position() uint32 {</code></span>
<span class="codeline" id="line-7112"><code>	return enum.pos</code></span>
<span class="codeline" id="line-7113"><code>}</code></span>
<span class="codeline" id="line-7114"><code></code></span>
<span class="codeline" id="line-7115"><code>func gcd(a, b uint32) uint32 {</code></span>
<span class="codeline" id="line-7116"><code>	for b != 0 {</code></span>
<span class="codeline" id="line-7117"><code>		a, b = b, a%b</code></span>
<span class="codeline" id="line-7118"><code>	}</code></span>
<span class="codeline" id="line-7119"><code>	return a</code></span>
<span class="codeline" id="line-7120"><code>}</code></span>
<span class="codeline" id="line-7121"><code></code></span>
<span class="codeline" id="line-7122"><code>// An initTask represents the set of initializations that need to be done for a package.</code></span>
<span class="codeline" id="line-7123"><code>// Keep in sync with ../../test/noinit.go:initTask</code></span>
<span class="codeline" id="line-7124"><code>type initTask struct {</code></span>
<span class="codeline" id="line-7125"><code>	state uint32 // 0 = uninitialized, 1 = in progress, 2 = done</code></span>
<span class="codeline" id="line-7126"><code>	nfns  uint32</code></span>
<span class="codeline" id="line-7127"><code>	// followed by nfns pcs, uintptr sized, one per init function to run</code></span>
<span class="codeline" id="line-7128"><code>}</code></span>
<span class="codeline" id="line-7129"><code></code></span>
<span class="codeline" id="line-7130"><code>// inittrace stores statistics for init functions which are</code></span>
<span class="codeline" id="line-7131"><code>// updated by malloc and newproc when active is true.</code></span>
<span class="codeline" id="line-7132"><code>var inittrace tracestat</code></span>
<span class="codeline" id="line-7133"><code></code></span>
<span class="codeline" id="line-7134"><code>type tracestat struct {</code></span>
<span class="codeline" id="line-7135"><code>	active bool   // init tracing activation status</code></span>
<span class="codeline" id="line-7136"><code>	id     uint64 // init goroutine id</code></span>
<span class="codeline" id="line-7137"><code>	allocs uint64 // heap allocations</code></span>
<span class="codeline" id="line-7138"><code>	bytes  uint64 // heap allocated bytes</code></span>
<span class="codeline" id="line-7139"><code>}</code></span>
<span class="codeline" id="line-7140"><code></code></span>
<span class="codeline" id="line-7141"><code>func doInit(ts []*initTask) {</code></span>
<span class="codeline" id="line-7142"><code>	for _, t := range ts {</code></span>
<span class="codeline" id="line-7143"><code>		doInit1(t)</code></span>
<span class="codeline" id="line-7144"><code>	}</code></span>
<span class="codeline" id="line-7145"><code>}</code></span>
<span class="codeline" id="line-7146"><code></code></span>
<span class="codeline" id="line-7147"><code>func doInit1(t *initTask) {</code></span>
<span class="codeline" id="line-7148"><code>	switch t.state {</code></span>
<span class="codeline" id="line-7149"><code>	case 2: // fully initialized</code></span>
<span class="codeline" id="line-7150"><code>		return</code></span>
<span class="codeline" id="line-7151"><code>	case 1: // initialization in progress</code></span>
<span class="codeline" id="line-7152"><code>		throw("recursive call during initialization - linker skew")</code></span>
<span class="codeline" id="line-7153"><code>	default: // not initialized yet</code></span>
<span class="codeline" id="line-7154"><code>		t.state = 1 // initialization in progress</code></span>
<span class="codeline" id="line-7155"><code></code></span>
<span class="codeline" id="line-7156"><code>		var (</code></span>
<span class="codeline" id="line-7157"><code>			start  int64</code></span>
<span class="codeline" id="line-7158"><code>			before tracestat</code></span>
<span class="codeline" id="line-7159"><code>		)</code></span>
<span class="codeline" id="line-7160"><code></code></span>
<span class="codeline" id="line-7161"><code>		if inittrace.active {</code></span>
<span class="codeline" id="line-7162"><code>			start = nanotime()</code></span>
<span class="codeline" id="line-7163"><code>			// Load stats non-atomically since tracinit is updated only by this init goroutine.</code></span>
<span class="codeline" id="line-7164"><code>			before = inittrace</code></span>
<span class="codeline" id="line-7165"><code>		}</code></span>
<span class="codeline" id="line-7166"><code></code></span>
<span class="codeline" id="line-7167"><code>		if t.nfns == 0 {</code></span>
<span class="codeline" id="line-7168"><code>			// We should have pruned all of these in the linker.</code></span>
<span class="codeline" id="line-7169"><code>			throw("inittask with no functions")</code></span>
<span class="codeline" id="line-7170"><code>		}</code></span>
<span class="codeline" id="line-7171"><code></code></span>
<span class="codeline" id="line-7172"><code>		firstFunc := add(unsafe.Pointer(t), 8)</code></span>
<span class="codeline" id="line-7173"><code>		for i := uint32(0); i &lt; t.nfns; i++ {</code></span>
<span class="codeline" id="line-7174"><code>			p := add(firstFunc, uintptr(i)*goarch.PtrSize)</code></span>
<span class="codeline" id="line-7175"><code>			f := *(*func())(unsafe.Pointer(&amp;p))</code></span>
<span class="codeline" id="line-7176"><code>			f()</code></span>
<span class="codeline" id="line-7177"><code>		}</code></span>
<span class="codeline" id="line-7178"><code></code></span>
<span class="codeline" id="line-7179"><code>		if inittrace.active {</code></span>
<span class="codeline" id="line-7180"><code>			end := nanotime()</code></span>
<span class="codeline" id="line-7181"><code>			// Load stats non-atomically since tracinit is updated only by this init goroutine.</code></span>
<span class="codeline" id="line-7182"><code>			after := inittrace</code></span>
<span class="codeline" id="line-7183"><code></code></span>
<span class="codeline" id="line-7184"><code>			f := *(*func())(unsafe.Pointer(&amp;firstFunc))</code></span>
<span class="codeline" id="line-7185"><code>			pkg := funcpkgpath(findfunc(abi.FuncPCABIInternal(f)))</code></span>
<span class="codeline" id="line-7186"><code></code></span>
<span class="codeline" id="line-7187"><code>			var sbuf [24]byte</code></span>
<span class="codeline" id="line-7188"><code>			print("init ", pkg, " @")</code></span>
<span class="codeline" id="line-7189"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(start-runtimeInitTime))), " ms, ")</code></span>
<span class="codeline" id="line-7190"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(end-start))), " ms clock, ")</code></span>
<span class="codeline" id="line-7191"><code>			print(string(itoa(sbuf[:], after.bytes-before.bytes)), " bytes, ")</code></span>
<span class="codeline" id="line-7192"><code>			print(string(itoa(sbuf[:], after.allocs-before.allocs)), " allocs")</code></span>
<span class="codeline" id="line-7193"><code>			print("\n")</code></span>
<span class="codeline" id="line-7194"><code>		}</code></span>
<span class="codeline" id="line-7195"><code></code></span>
<span class="codeline" id="line-7196"><code>		t.state = 2 // initialization done</code></span>
<span class="codeline" id="line-7197"><code>	}</code></span>
<span class="codeline" id="line-7198"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>