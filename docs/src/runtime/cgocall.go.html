<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: cgocall.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	cgocall.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Cgo call and callback support.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// To call into the C function f from Go, the cgo-generated code calls</code></span>
<span class="codeline" id="line-8"><code>// runtime.cgocall(_cgo_Cfunc_f, frame), where _cgo_Cfunc_f is a</code></span>
<span class="codeline" id="line-9"><code>// gcc-compiled function written by cgo.</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// runtime.cgocall (below) calls entersyscall so as not to block</code></span>
<span class="codeline" id="line-12"><code>// other goroutines or the garbage collector, and then calls</code></span>
<span class="codeline" id="line-13"><code>// runtime.asmcgocall(_cgo_Cfunc_f, frame).</code></span>
<span class="codeline" id="line-14"><code>//</code></span>
<span class="codeline" id="line-15"><code>// runtime.asmcgocall (in asm_$GOARCH.s) switches to the m-&gt;g0 stack</code></span>
<span class="codeline" id="line-16"><code>// (assumed to be an operating system-allocated stack, so safe to run</code></span>
<span class="codeline" id="line-17"><code>// gcc-compiled code on) and calls _cgo_Cfunc_f(frame).</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// _cgo_Cfunc_f invokes the actual C function f with arguments</code></span>
<span class="codeline" id="line-20"><code>// taken from the frame structure, records the results in the frame,</code></span>
<span class="codeline" id="line-21"><code>// and returns to runtime.asmcgocall.</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>// After it regains control, runtime.asmcgocall switches back to the</code></span>
<span class="codeline" id="line-24"><code>// original g (m-&gt;curg)'s stack and returns to runtime.cgocall.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// After it regains control, runtime.cgocall calls exitsyscall, which blocks</code></span>
<span class="codeline" id="line-27"><code>// until this m can run Go code without violating the $GOMAXPROCS limit,</code></span>
<span class="codeline" id="line-28"><code>// and then unlocks g from m.</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// The above description skipped over the possibility of the gcc-compiled</code></span>
<span class="codeline" id="line-31"><code>// function f calling back into Go. If that happens, we continue down</code></span>
<span class="codeline" id="line-32"><code>// the rabbit hole during the execution of f.</code></span>
<span class="codeline" id="line-33"><code>//</code></span>
<span class="codeline" id="line-34"><code>// To make it possible for gcc-compiled C code to call a Go function p.GoF,</code></span>
<span class="codeline" id="line-35"><code>// cgo writes a gcc-compiled function named GoF (not p.GoF, since gcc doesn't</code></span>
<span class="codeline" id="line-36"><code>// know about packages).  The gcc-compiled C function f calls GoF.</code></span>
<span class="codeline" id="line-37"><code>//</code></span>
<span class="codeline" id="line-38"><code>// GoF initializes "frame", a structure containing all of its</code></span>
<span class="codeline" id="line-39"><code>// arguments and slots for p.GoF's results. It calls</code></span>
<span class="codeline" id="line-40"><code>// crosscall2(_cgoexp_GoF, frame, framesize, ctxt) using the gcc ABI.</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// crosscall2 (in cgo/asm_$GOARCH.s) is a four-argument adapter from</code></span>
<span class="codeline" id="line-43"><code>// the gcc function call ABI to the gc function call ABI. At this</code></span>
<span class="codeline" id="line-44"><code>// point we're in the Go runtime, but we're still running on m.g0's</code></span>
<span class="codeline" id="line-45"><code>// stack and outside the $GOMAXPROCS limit. crosscall2 calls</code></span>
<span class="codeline" id="line-46"><code>// runtime.cgocallback(_cgoexp_GoF, frame, ctxt) using the gc ABI.</code></span>
<span class="codeline" id="line-47"><code>// (crosscall2's framesize argument is no longer used, but there's one</code></span>
<span class="codeline" id="line-48"><code>// case where SWIG calls crosscall2 directly and expects to pass this</code></span>
<span class="codeline" id="line-49"><code>// argument. See _cgo_panic.)</code></span>
<span class="codeline" id="line-50"><code>//</code></span>
<span class="codeline" id="line-51"><code>// runtime.cgocallback (in asm_$GOARCH.s) switches from m.g0's stack</code></span>
<span class="codeline" id="line-52"><code>// to the original g (m.curg)'s stack, on which it calls</code></span>
<span class="codeline" id="line-53"><code>// runtime.cgocallbackg(_cgoexp_GoF, frame, ctxt). As part of the</code></span>
<span class="codeline" id="line-54"><code>// stack switch, runtime.cgocallback saves the current SP as</code></span>
<span class="codeline" id="line-55"><code>// m.g0.sched.sp, so that any use of m.g0's stack during the execution</code></span>
<span class="codeline" id="line-56"><code>// of the callback will be done below the existing stack frames.</code></span>
<span class="codeline" id="line-57"><code>// Before overwriting m.g0.sched.sp, it pushes the old value on the</code></span>
<span class="codeline" id="line-58"><code>// m.g0 stack, so that it can be restored later.</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>// runtime.cgocallbackg (below) is now running on a real goroutine</code></span>
<span class="codeline" id="line-61"><code>// stack (not an m.g0 stack).  First it calls runtime.exitsyscall, which will</code></span>
<span class="codeline" id="line-62"><code>// block until the $GOMAXPROCS limit allows running this goroutine.</code></span>
<span class="codeline" id="line-63"><code>// Once exitsyscall has returned, it is safe to do things like call the memory</code></span>
<span class="codeline" id="line-64"><code>// allocator or invoke the Go callback function.  runtime.cgocallbackg</code></span>
<span class="codeline" id="line-65"><code>// first defers a function to unwind m.g0.sched.sp, so that if p.GoF</code></span>
<span class="codeline" id="line-66"><code>// panics, m.g0.sched.sp will be restored to its old value: the m.g0 stack</code></span>
<span class="codeline" id="line-67"><code>// and the m.curg stack will be unwound in lock step.</code></span>
<span class="codeline" id="line-68"><code>// Then it calls _cgoexp_GoF(frame).</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// _cgoexp_GoF, which was generated by cmd/cgo, unpacks the arguments</code></span>
<span class="codeline" id="line-71"><code>// from frame, calls p.GoF, writes the results back to frame, and</code></span>
<span class="codeline" id="line-72"><code>// returns. Now we start unwinding this whole process.</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>// runtime.cgocallbackg pops but does not execute the deferred</code></span>
<span class="codeline" id="line-75"><code>// function to unwind m.g0.sched.sp, calls runtime.entersyscall, and</code></span>
<span class="codeline" id="line-76"><code>// returns to runtime.cgocallback.</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>// After it regains control, runtime.cgocallback switches back to</code></span>
<span class="codeline" id="line-79"><code>// m.g0's stack (the pointer is still in m.g0.sched.sp), restores the old</code></span>
<span class="codeline" id="line-80"><code>// m.g0.sched.sp value from the stack, and returns to crosscall2.</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// crosscall2 restores the callee-save registers for gcc and returns</code></span>
<span class="codeline" id="line-83"><code>// to GoF, which unpacks any result values and returns to f.</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>package runtime</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>import (</code></span>
<span class="codeline" id="line-88"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-89"><code>	"internal/goexperiment"</code></span>
<span class="codeline" id="line-90"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-91"><code>	"unsafe"</code></span>
<span class="codeline" id="line-92"><code>)</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>// Addresses collected in a cgo backtrace when crashing.</code></span>
<span class="codeline" id="line-95"><code>// Length must match arg.Max in x_cgo_callers in runtime/cgo/gcc_traceback.c.</code></span>
<span class="codeline" id="line-96"><code>type cgoCallers [32]uintptr</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>// argset matches runtime/cgo/linux_syscall.c:argset_t</code></span>
<span class="codeline" id="line-99"><code>type argset struct {</code></span>
<span class="codeline" id="line-100"><code>	args   unsafe.Pointer</code></span>
<span class="codeline" id="line-101"><code>	retval uintptr</code></span>
<span class="codeline" id="line-102"><code>}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>// wrapper for syscall package to call cgocall for libc (cgo) calls.</code></span>
<span class="codeline" id="line-105"><code>//</code></span>
<span class="codeline" id="line-106"><code>//go:linkname syscall_cgocaller syscall.cgocaller</code></span>
<span class="codeline" id="line-107"><code>//go:nosplit</code></span>
<span class="codeline" id="line-108"><code>//go:uintptrescapes</code></span>
<span class="codeline" id="line-109"><code>func syscall_cgocaller(fn unsafe.Pointer, args ...uintptr) uintptr {</code></span>
<span class="codeline" id="line-110"><code>	as := argset{args: unsafe.Pointer(&amp;args[0])}</code></span>
<span class="codeline" id="line-111"><code>	cgocall(fn, unsafe.Pointer(&amp;as))</code></span>
<span class="codeline" id="line-112"><code>	return as.retval</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>var ncgocall uint64 // number of cgo calls in total for dead m</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// Call from Go to C.</code></span>
<span class="codeline" id="line-118"><code>//</code></span>
<span class="codeline" id="line-119"><code>// This must be nosplit because it's used for syscalls on some</code></span>
<span class="codeline" id="line-120"><code>// platforms. Syscalls may have untyped arguments on the stack, so</code></span>
<span class="codeline" id="line-121"><code>// it's not safe to grow or scan the stack.</code></span>
<span class="codeline" id="line-122"><code>//</code></span>
<span class="codeline" id="line-123"><code>//go:nosplit</code></span>
<span class="codeline" id="line-124"><code>func cgocall(fn, arg unsafe.Pointer) int32 {</code></span>
<span class="codeline" id="line-125"><code>	if !iscgo &amp;&amp; GOOS != "solaris" &amp;&amp; GOOS != "illumos" &amp;&amp; GOOS != "windows" {</code></span>
<span class="codeline" id="line-126"><code>		throw("cgocall unavailable")</code></span>
<span class="codeline" id="line-127"><code>	}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>	if fn == nil {</code></span>
<span class="codeline" id="line-130"><code>		throw("cgocall nil")</code></span>
<span class="codeline" id="line-131"><code>	}</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-134"><code>		racereleasemerge(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-138"><code>	mp.ncgocall++</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	// Reset traceback.</code></span>
<span class="codeline" id="line-141"><code>	mp.cgoCallers[0] = 0</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>	// Announce we are entering a system call</code></span>
<span class="codeline" id="line-144"><code>	// so that the scheduler knows to create another</code></span>
<span class="codeline" id="line-145"><code>	// M to run goroutines while we are in the</code></span>
<span class="codeline" id="line-146"><code>	// foreign code.</code></span>
<span class="codeline" id="line-147"><code>	//</code></span>
<span class="codeline" id="line-148"><code>	// The call to asmcgocall is guaranteed not to</code></span>
<span class="codeline" id="line-149"><code>	// grow the stack and does not allocate memory,</code></span>
<span class="codeline" id="line-150"><code>	// so it is safe to call while "in a system call", outside</code></span>
<span class="codeline" id="line-151"><code>	// the $GOMAXPROCS accounting.</code></span>
<span class="codeline" id="line-152"><code>	//</code></span>
<span class="codeline" id="line-153"><code>	// fn may call back into Go code, in which case we'll exit the</code></span>
<span class="codeline" id="line-154"><code>	// "system call", run the Go code (which may grow the stack),</code></span>
<span class="codeline" id="line-155"><code>	// and then re-enter the "system call" reusing the PC and SP</code></span>
<span class="codeline" id="line-156"><code>	// saved by entersyscall here.</code></span>
<span class="codeline" id="line-157"><code>	entersyscall()</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>	// Tell asynchronous preemption that we're entering external</code></span>
<span class="codeline" id="line-160"><code>	// code. We do this after entersyscall because this may block</code></span>
<span class="codeline" id="line-161"><code>	// and cause an async preemption to fail, but at this point a</code></span>
<span class="codeline" id="line-162"><code>	// sync preemption will succeed (though this is not a matter</code></span>
<span class="codeline" id="line-163"><code>	// of correctness).</code></span>
<span class="codeline" id="line-164"><code>	osPreemptExtEnter(mp)</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>	mp.incgo = true</code></span>
<span class="codeline" id="line-167"><code>	// We use ncgo as a check during execution tracing for whether there is</code></span>
<span class="codeline" id="line-168"><code>	// any C on the call stack, which there will be after this point. If</code></span>
<span class="codeline" id="line-169"><code>	// there isn't, we can use frame pointer unwinding to collect call</code></span>
<span class="codeline" id="line-170"><code>	// stacks efficiently. This will be the case for the first Go-to-C call</code></span>
<span class="codeline" id="line-171"><code>	// on a stack, so it's preferable to update it here, after we emit a</code></span>
<span class="codeline" id="line-172"><code>	// trace event in entersyscall above.</code></span>
<span class="codeline" id="line-173"><code>	mp.ncgo++</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>	errno := asmcgocall(fn, arg)</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// Update accounting before exitsyscall because exitsyscall may</code></span>
<span class="codeline" id="line-178"><code>	// reschedule us on to a different M.</code></span>
<span class="codeline" id="line-179"><code>	mp.incgo = false</code></span>
<span class="codeline" id="line-180"><code>	mp.ncgo--</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>	osPreemptExtExit(mp)</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	exitsyscall()</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// Note that raceacquire must be called only after exitsyscall has</code></span>
<span class="codeline" id="line-187"><code>	// wired this M to a P.</code></span>
<span class="codeline" id="line-188"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-189"><code>		raceacquire(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-190"><code>	}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	// From the garbage collector's perspective, time can move</code></span>
<span class="codeline" id="line-193"><code>	// backwards in the sequence above. If there's a callback into</code></span>
<span class="codeline" id="line-194"><code>	// Go code, GC will see this function at the call to</code></span>
<span class="codeline" id="line-195"><code>	// asmcgocall. When the Go call later returns to C, the</code></span>
<span class="codeline" id="line-196"><code>	// syscall PC/SP is rolled back and the GC sees this function</code></span>
<span class="codeline" id="line-197"><code>	// back at the call to entersyscall. Normally, fn and arg</code></span>
<span class="codeline" id="line-198"><code>	// would be live at entersyscall and dead at asmcgocall, so if</code></span>
<span class="codeline" id="line-199"><code>	// time moved backwards, GC would see these arguments as dead</code></span>
<span class="codeline" id="line-200"><code>	// and then live. Prevent these undead arguments from crashing</code></span>
<span class="codeline" id="line-201"><code>	// GC by forcing them to stay live across this time warp.</code></span>
<span class="codeline" id="line-202"><code>	KeepAlive(fn)</code></span>
<span class="codeline" id="line-203"><code>	KeepAlive(arg)</code></span>
<span class="codeline" id="line-204"><code>	KeepAlive(mp)</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>	return errno</code></span>
<span class="codeline" id="line-207"><code>}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>// Set or reset the system stack bounds for a callback on sp.</code></span>
<span class="codeline" id="line-210"><code>//</code></span>
<span class="codeline" id="line-211"><code>// Must be nosplit because it is called by needm prior to fully initializing</code></span>
<span class="codeline" id="line-212"><code>// the M.</code></span>
<span class="codeline" id="line-213"><code>//</code></span>
<span class="codeline" id="line-214"><code>//go:nosplit</code></span>
<span class="codeline" id="line-215"><code>func callbackUpdateSystemStack(mp *m, sp uintptr, signal bool) {</code></span>
<span class="codeline" id="line-216"><code>	g0 := mp.g0</code></span>
<span class="codeline" id="line-217"><code>	if sp &gt; g0.stack.lo &amp;&amp; sp &lt;= g0.stack.hi {</code></span>
<span class="codeline" id="line-218"><code>		// Stack already in bounds, nothing to do.</code></span>
<span class="codeline" id="line-219"><code>		return</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>	if mp.ncgo &gt; 0 {</code></span>
<span class="codeline" id="line-223"><code>		// ncgo &gt; 0 indicates that this M was in Go further up the stack</code></span>
<span class="codeline" id="line-224"><code>		// (it called C and is now receiving a callback). It is not</code></span>
<span class="codeline" id="line-225"><code>		// safe for the C call to change the stack out from under us.</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>		// Note that this case isn't possible for signal == true, as</code></span>
<span class="codeline" id="line-228"><code>		// that is always passing a new M from needm.</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>		// Stack is bogus, but reset the bounds anyway so we can print.</code></span>
<span class="codeline" id="line-231"><code>		hi := g0.stack.hi</code></span>
<span class="codeline" id="line-232"><code>		lo := g0.stack.lo</code></span>
<span class="codeline" id="line-233"><code>		g0.stack.hi = sp + 1024</code></span>
<span class="codeline" id="line-234"><code>		g0.stack.lo = sp - 32*1024</code></span>
<span class="codeline" id="line-235"><code>		g0.stackguard0 = g0.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-236"><code>		g0.stackguard1 = g0.stackguard0</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>		print("M ", mp.id, " procid ", mp.procid, " runtime: cgocallback with sp=", hex(sp), " out of bounds [", hex(lo), ", ", hex(hi), "]")</code></span>
<span class="codeline" id="line-239"><code>		print("\n")</code></span>
<span class="codeline" id="line-240"><code>		exit(2)</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>	// This M does not have Go further up the stack. However, it may have</code></span>
<span class="codeline" id="line-244"><code>	// previously called into Go, initializing the stack bounds. Between</code></span>
<span class="codeline" id="line-245"><code>	// that call returning and now the stack may have changed (perhaps the</code></span>
<span class="codeline" id="line-246"><code>	// C thread is running a coroutine library). We need to update the</code></span>
<span class="codeline" id="line-247"><code>	// stack bounds for this case.</code></span>
<span class="codeline" id="line-248"><code>	//</code></span>
<span class="codeline" id="line-249"><code>	// Set the stack bounds to match the current stack. If we don't</code></span>
<span class="codeline" id="line-250"><code>	// actually know how big the stack is, like we don't know how big any</code></span>
<span class="codeline" id="line-251"><code>	// scheduling stack is, but we assume there's at least 32 kB. If we</code></span>
<span class="codeline" id="line-252"><code>	// can get a more accurate stack bound from pthread, use that, provided</code></span>
<span class="codeline" id="line-253"><code>	// it actually contains SP..</code></span>
<span class="codeline" id="line-254"><code>	g0.stack.hi = sp + 1024</code></span>
<span class="codeline" id="line-255"><code>	g0.stack.lo = sp - 32*1024</code></span>
<span class="codeline" id="line-256"><code>	if !signal &amp;&amp; _cgo_getstackbound != nil {</code></span>
<span class="codeline" id="line-257"><code>		// Don't adjust if called from the signal handler.</code></span>
<span class="codeline" id="line-258"><code>		// We are on the signal stack, not the pthread stack.</code></span>
<span class="codeline" id="line-259"><code>		// (We could get the stack bounds from sigaltstack, but</code></span>
<span class="codeline" id="line-260"><code>		// we're getting out of the signal handler very soon</code></span>
<span class="codeline" id="line-261"><code>		// anyway. Not worth it.)</code></span>
<span class="codeline" id="line-262"><code>		var bounds [2]uintptr</code></span>
<span class="codeline" id="line-263"><code>		asmcgocall(_cgo_getstackbound, unsafe.Pointer(&amp;bounds))</code></span>
<span class="codeline" id="line-264"><code>		// getstackbound is an unsupported no-op on Windows.</code></span>
<span class="codeline" id="line-265"><code>		//</code></span>
<span class="codeline" id="line-266"><code>		// Don't use these bounds if they don't contain SP. Perhaps we</code></span>
<span class="codeline" id="line-267"><code>		// were called by something not using the standard thread</code></span>
<span class="codeline" id="line-268"><code>		// stack.</code></span>
<span class="codeline" id="line-269"><code>		if bounds[0] != 0 &amp;&amp; sp &gt; bounds[0] &amp;&amp; sp &lt;= bounds[1] {</code></span>
<span class="codeline" id="line-270"><code>			g0.stack.lo = bounds[0]</code></span>
<span class="codeline" id="line-271"><code>			g0.stack.hi = bounds[1]</code></span>
<span class="codeline" id="line-272"><code>		}</code></span>
<span class="codeline" id="line-273"><code>	}</code></span>
<span class="codeline" id="line-274"><code>	g0.stackguard0 = g0.stack.lo + stackGuard</code></span>
<span class="codeline" id="line-275"><code>	g0.stackguard1 = g0.stackguard0</code></span>
<span class="codeline" id="line-276"><code>}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>// Call from C back to Go. fn must point to an ABIInternal Go entry-point.</code></span>
<span class="codeline" id="line-279"><code>//</code></span>
<span class="codeline" id="line-280"><code>//go:nosplit</code></span>
<span class="codeline" id="line-281"><code>func cgocallbackg(fn, frame unsafe.Pointer, ctxt uintptr) {</code></span>
<span class="codeline" id="line-282"><code>	gp := getg()</code></span>
<span class="codeline" id="line-283"><code>	if gp != gp.m.curg {</code></span>
<span class="codeline" id="line-284"><code>		println("runtime: bad g in cgocallback")</code></span>
<span class="codeline" id="line-285"><code>		exit(2)</code></span>
<span class="codeline" id="line-286"><code>	}</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>	sp := gp.m.g0.sched.sp // system sp saved by cgocallback.</code></span>
<span class="codeline" id="line-289"><code>	callbackUpdateSystemStack(gp.m, sp, false)</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	// The call from C is on gp.m's g0 stack, so we must ensure</code></span>
<span class="codeline" id="line-292"><code>	// that we stay on that M. We have to do this before calling</code></span>
<span class="codeline" id="line-293"><code>	// exitsyscall, since it would otherwise be free to move us to</code></span>
<span class="codeline" id="line-294"><code>	// a different M. The call to unlockOSThread is in this function</code></span>
<span class="codeline" id="line-295"><code>	// after cgocallbackg1, or in the case of panicking, in unwindm.</code></span>
<span class="codeline" id="line-296"><code>	lockOSThread()</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	checkm := gp.m</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>	// Save current syscall parameters, so m.syscall can be</code></span>
<span class="codeline" id="line-301"><code>	// used again if callback decide to make syscall.</code></span>
<span class="codeline" id="line-302"><code>	syscall := gp.m.syscall</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>	// entersyscall saves the caller's SP to allow the GC to trace the Go</code></span>
<span class="codeline" id="line-305"><code>	// stack. However, since we're returning to an earlier stack frame and</code></span>
<span class="codeline" id="line-306"><code>	// need to pair with the entersyscall() call made by cgocall, we must</code></span>
<span class="codeline" id="line-307"><code>	// save syscall* and let reentersyscall restore them.</code></span>
<span class="codeline" id="line-308"><code>	savedsp := unsafe.Pointer(gp.syscallsp)</code></span>
<span class="codeline" id="line-309"><code>	savedpc := gp.syscallpc</code></span>
<span class="codeline" id="line-310"><code>	exitsyscall() // coming out of cgo call</code></span>
<span class="codeline" id="line-311"><code>	gp.m.incgo = false</code></span>
<span class="codeline" id="line-312"><code>	if gp.m.isextra {</code></span>
<span class="codeline" id="line-313"><code>		gp.m.isExtraInC = false</code></span>
<span class="codeline" id="line-314"><code>	}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>	osPreemptExtExit(gp.m)</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>	if gp.nocgocallback {</code></span>
<span class="codeline" id="line-319"><code>		panic("runtime: function marked with #cgo nocallback called back into Go")</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>	cgocallbackg1(fn, frame, ctxt)</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>	// At this point we're about to call unlockOSThread.</code></span>
<span class="codeline" id="line-325"><code>	// The following code must not change to a different m.</code></span>
<span class="codeline" id="line-326"><code>	// This is enforced by checking incgo in the schedule function.</code></span>
<span class="codeline" id="line-327"><code>	gp.m.incgo = true</code></span>
<span class="codeline" id="line-328"><code>	unlockOSThread()</code></span>
<span class="codeline" id="line-329"><code></code></span>
<span class="codeline" id="line-330"><code>	if gp.m.isextra {</code></span>
<span class="codeline" id="line-331"><code>		gp.m.isExtraInC = true</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>	if gp.m != checkm {</code></span>
<span class="codeline" id="line-335"><code>		throw("m changed unexpectedly in cgocallbackg")</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>	osPreemptExtEnter(gp.m)</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>	// going back to cgo call</code></span>
<span class="codeline" id="line-341"><code>	reentersyscall(savedpc, uintptr(savedsp))</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>	gp.m.syscall = syscall</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>func cgocallbackg1(fn, frame unsafe.Pointer, ctxt uintptr) {</code></span>
<span class="codeline" id="line-347"><code>	gp := getg()</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>	if gp.m.needextram || extraMWaiters.Load() &gt; 0 {</code></span>
<span class="codeline" id="line-350"><code>		gp.m.needextram = false</code></span>
<span class="codeline" id="line-351"><code>		systemstack(newextram)</code></span>
<span class="codeline" id="line-352"><code>	}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>	if ctxt != 0 {</code></span>
<span class="codeline" id="line-355"><code>		s := append(gp.cgoCtxt, ctxt)</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>		// Now we need to set gp.cgoCtxt = s, but we could get</code></span>
<span class="codeline" id="line-358"><code>		// a SIGPROF signal while manipulating the slice, and</code></span>
<span class="codeline" id="line-359"><code>		// the SIGPROF handler could pick up gp.cgoCtxt while</code></span>
<span class="codeline" id="line-360"><code>		// tracing up the stack.  We need to ensure that the</code></span>
<span class="codeline" id="line-361"><code>		// handler always sees a valid slice, so set the</code></span>
<span class="codeline" id="line-362"><code>		// values in an order such that it always does.</code></span>
<span class="codeline" id="line-363"><code>		p := (*slice)(unsafe.Pointer(&amp;gp.cgoCtxt))</code></span>
<span class="codeline" id="line-364"><code>		atomicstorep(unsafe.Pointer(&amp;p.array), unsafe.Pointer(&amp;s[0]))</code></span>
<span class="codeline" id="line-365"><code>		p.cap = cap(s)</code></span>
<span class="codeline" id="line-366"><code>		p.len = len(s)</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>		defer func(gp *g) {</code></span>
<span class="codeline" id="line-369"><code>			// Decrease the length of the slice by one, safely.</code></span>
<span class="codeline" id="line-370"><code>			p := (*slice)(unsafe.Pointer(&amp;gp.cgoCtxt))</code></span>
<span class="codeline" id="line-371"><code>			p.len--</code></span>
<span class="codeline" id="line-372"><code>		}(gp)</code></span>
<span class="codeline" id="line-373"><code>	}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>	if gp.m.ncgo == 0 {</code></span>
<span class="codeline" id="line-376"><code>		// The C call to Go came from a thread not currently running</code></span>
<span class="codeline" id="line-377"><code>		// any Go. In the case of -buildmode=c-archive or c-shared,</code></span>
<span class="codeline" id="line-378"><code>		// this call may be coming in before package initialization</code></span>
<span class="codeline" id="line-379"><code>		// is complete. Wait until it is.</code></span>
<span class="codeline" id="line-380"><code>		&lt;-main_init_done</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code></code></span>
<span class="codeline" id="line-383"><code>	// Check whether the profiler needs to be turned on or off; this route to</code></span>
<span class="codeline" id="line-384"><code>	// run Go code does not use runtime.execute, so bypasses the check there.</code></span>
<span class="codeline" id="line-385"><code>	hz := sched.profilehz</code></span>
<span class="codeline" id="line-386"><code>	if gp.m.profilehz != hz {</code></span>
<span class="codeline" id="line-387"><code>		setThreadCPUProfiler(hz)</code></span>
<span class="codeline" id="line-388"><code>	}</code></span>
<span class="codeline" id="line-389"><code></code></span>
<span class="codeline" id="line-390"><code>	// Add entry to defer stack in case of panic.</code></span>
<span class="codeline" id="line-391"><code>	restore := true</code></span>
<span class="codeline" id="line-392"><code>	defer unwindm(&amp;restore)</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-395"><code>		raceacquire(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-396"><code>	}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>	// Invoke callback. This function is generated by cmd/cgo and</code></span>
<span class="codeline" id="line-399"><code>	// will unpack the argument frame and call the Go function.</code></span>
<span class="codeline" id="line-400"><code>	var cb func(frame unsafe.Pointer)</code></span>
<span class="codeline" id="line-401"><code>	cbFV := funcval{uintptr(fn)}</code></span>
<span class="codeline" id="line-402"><code>	*(*unsafe.Pointer)(unsafe.Pointer(&amp;cb)) = noescape(unsafe.Pointer(&amp;cbFV))</code></span>
<span class="codeline" id="line-403"><code>	cb(frame)</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-406"><code>		racereleasemerge(unsafe.Pointer(&amp;racecgosync))</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>	// Do not unwind m-&gt;g0-&gt;sched.sp.</code></span>
<span class="codeline" id="line-410"><code>	// Our caller, cgocallback, will do that.</code></span>
<span class="codeline" id="line-411"><code>	restore = false</code></span>
<span class="codeline" id="line-412"><code>}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>func unwindm(restore *bool) {</code></span>
<span class="codeline" id="line-415"><code>	if *restore {</code></span>
<span class="codeline" id="line-416"><code>		// Restore sp saved by cgocallback during</code></span>
<span class="codeline" id="line-417"><code>		// unwind of g's stack (see comment at top of file).</code></span>
<span class="codeline" id="line-418"><code>		mp := acquirem()</code></span>
<span class="codeline" id="line-419"><code>		sched := &amp;mp.g0.sched</code></span>
<span class="codeline" id="line-420"><code>		sched.sp = *(*uintptr)(unsafe.Pointer(sched.sp + alignUp(sys.MinFrameSize, sys.StackAlign)))</code></span>
<span class="codeline" id="line-421"><code></code></span>
<span class="codeline" id="line-422"><code>		// Do the accounting that cgocall will not have a chance to do</code></span>
<span class="codeline" id="line-423"><code>		// during an unwind.</code></span>
<span class="codeline" id="line-424"><code>		//</code></span>
<span class="codeline" id="line-425"><code>		// In the case where a Go call originates from C, ncgo is 0</code></span>
<span class="codeline" id="line-426"><code>		// and there is no matching cgocall to end.</code></span>
<span class="codeline" id="line-427"><code>		if mp.ncgo &gt; 0 {</code></span>
<span class="codeline" id="line-428"><code>			mp.incgo = false</code></span>
<span class="codeline" id="line-429"><code>			mp.ncgo--</code></span>
<span class="codeline" id="line-430"><code>			osPreemptExtExit(mp)</code></span>
<span class="codeline" id="line-431"><code>		}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>		// Undo the call to lockOSThread in cgocallbackg, only on the</code></span>
<span class="codeline" id="line-434"><code>		// panicking path. In normal return case cgocallbackg will call</code></span>
<span class="codeline" id="line-435"><code>		// unlockOSThread, ensuring no preemption point after the unlock.</code></span>
<span class="codeline" id="line-436"><code>		// Here we don't need to worry about preemption, because we're</code></span>
<span class="codeline" id="line-437"><code>		// panicking out of the callback and unwinding the g0 stack,</code></span>
<span class="codeline" id="line-438"><code>		// instead of reentering cgo (which requires the same thread).</code></span>
<span class="codeline" id="line-439"><code>		unlockOSThread()</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>}</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>// called from assembly.</code></span>
<span class="codeline" id="line-446"><code>func badcgocallback() {</code></span>
<span class="codeline" id="line-447"><code>	throw("misaligned stack in cgocallback")</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>// called from (incomplete) assembly.</code></span>
<span class="codeline" id="line-451"><code>func cgounimpl() {</code></span>
<span class="codeline" id="line-452"><code>	throw("cgo not implemented")</code></span>
<span class="codeline" id="line-453"><code>}</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>var racecgosync uint64 // represents possible synchronization in C code</code></span>
<span class="codeline" id="line-456"><code></code></span>
<span class="codeline" id="line-457"><code>// Pointer checking for cgo code.</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>// We want to detect all cases where a program that does not use</code></span>
<span class="codeline" id="line-460"><code>// unsafe makes a cgo call passing a Go pointer to memory that</code></span>
<span class="codeline" id="line-461"><code>// contains an unpinned Go pointer. Here a Go pointer is defined as a</code></span>
<span class="codeline" id="line-462"><code>// pointer to memory allocated by the Go runtime. Programs that use</code></span>
<span class="codeline" id="line-463"><code>// unsafe can evade this restriction easily, so we don't try to catch</code></span>
<span class="codeline" id="line-464"><code>// them. The cgo program will rewrite all possibly bad pointer</code></span>
<span class="codeline" id="line-465"><code>// arguments to call cgoCheckPointer, where we can catch cases of a Go</code></span>
<span class="codeline" id="line-466"><code>// pointer pointing to an unpinned Go pointer.</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>// Complicating matters, taking the address of a slice or array</code></span>
<span class="codeline" id="line-469"><code>// element permits the C program to access all elements of the slice</code></span>
<span class="codeline" id="line-470"><code>// or array. In that case we will see a pointer to a single element,</code></span>
<span class="codeline" id="line-471"><code>// but we need to check the entire data structure.</code></span>
<span class="codeline" id="line-472"><code></code></span>
<span class="codeline" id="line-473"><code>// The cgoCheckPointer call takes additional arguments indicating that</code></span>
<span class="codeline" id="line-474"><code>// it was called on an address expression. An additional argument of</code></span>
<span class="codeline" id="line-475"><code>// true means that it only needs to check a single element. An</code></span>
<span class="codeline" id="line-476"><code>// additional argument of a slice or array means that it needs to</code></span>
<span class="codeline" id="line-477"><code>// check the entire slice/array, but nothing else. Otherwise, the</code></span>
<span class="codeline" id="line-478"><code>// pointer could be anything, and we check the entire heap object,</code></span>
<span class="codeline" id="line-479"><code>// which is conservative but safe.</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// When and if we implement a moving garbage collector,</code></span>
<span class="codeline" id="line-482"><code>// cgoCheckPointer will pin the pointer for the duration of the cgo</code></span>
<span class="codeline" id="line-483"><code>// call.  (This is necessary but not sufficient; the cgo program will</code></span>
<span class="codeline" id="line-484"><code>// also have to change to pin Go pointers that cannot point to Go</code></span>
<span class="codeline" id="line-485"><code>// pointers.)</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>// cgoCheckPointer checks if the argument contains a Go pointer that</code></span>
<span class="codeline" id="line-488"><code>// points to an unpinned Go pointer, and panics if it does.</code></span>
<span class="codeline" id="line-489"><code>func cgoCheckPointer(ptr any, arg any) {</code></span>
<span class="codeline" id="line-490"><code>	if !goexperiment.CgoCheck2 &amp;&amp; debug.cgocheck == 0 {</code></span>
<span class="codeline" id="line-491"><code>		return</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	ep := efaceOf(&amp;ptr)</code></span>
<span class="codeline" id="line-495"><code>	t := ep._type</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>	top := true</code></span>
<span class="codeline" id="line-498"><code>	if arg != nil &amp;&amp; (t.Kind_&amp;kindMask == kindPtr || t.Kind_&amp;kindMask == kindUnsafePointer) {</code></span>
<span class="codeline" id="line-499"><code>		p := ep.data</code></span>
<span class="codeline" id="line-500"><code>		if t.Kind_&amp;kindDirectIface == 0 {</code></span>
<span class="codeline" id="line-501"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-502"><code>		}</code></span>
<span class="codeline" id="line-503"><code>		if p == nil || !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-504"><code>			return</code></span>
<span class="codeline" id="line-505"><code>		}</code></span>
<span class="codeline" id="line-506"><code>		aep := efaceOf(&amp;arg)</code></span>
<span class="codeline" id="line-507"><code>		switch aep._type.Kind_ &amp; kindMask {</code></span>
<span class="codeline" id="line-508"><code>		case kindBool:</code></span>
<span class="codeline" id="line-509"><code>			if t.Kind_&amp;kindMask == kindUnsafePointer {</code></span>
<span class="codeline" id="line-510"><code>				// We don't know the type of the element.</code></span>
<span class="codeline" id="line-511"><code>				break</code></span>
<span class="codeline" id="line-512"><code>			}</code></span>
<span class="codeline" id="line-513"><code>			pt := (*ptrtype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-514"><code>			cgoCheckArg(pt.Elem, p, true, false, cgoCheckPointerFail)</code></span>
<span class="codeline" id="line-515"><code>			return</code></span>
<span class="codeline" id="line-516"><code>		case kindSlice:</code></span>
<span class="codeline" id="line-517"><code>			// Check the slice rather than the pointer.</code></span>
<span class="codeline" id="line-518"><code>			ep = aep</code></span>
<span class="codeline" id="line-519"><code>			t = ep._type</code></span>
<span class="codeline" id="line-520"><code>		case kindArray:</code></span>
<span class="codeline" id="line-521"><code>			// Check the array rather than the pointer.</code></span>
<span class="codeline" id="line-522"><code>			// Pass top as false since we have a pointer</code></span>
<span class="codeline" id="line-523"><code>			// to the array.</code></span>
<span class="codeline" id="line-524"><code>			ep = aep</code></span>
<span class="codeline" id="line-525"><code>			t = ep._type</code></span>
<span class="codeline" id="line-526"><code>			top = false</code></span>
<span class="codeline" id="line-527"><code>		default:</code></span>
<span class="codeline" id="line-528"><code>			throw("can't happen")</code></span>
<span class="codeline" id="line-529"><code>		}</code></span>
<span class="codeline" id="line-530"><code>	}</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>	cgoCheckArg(t, ep.data, t.Kind_&amp;kindDirectIface == 0, top, cgoCheckPointerFail)</code></span>
<span class="codeline" id="line-533"><code>}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>const cgoCheckPointerFail = "cgo argument has Go pointer to unpinned Go pointer"</code></span>
<span class="codeline" id="line-536"><code>const cgoResultFail = "cgo result is unpinned Go pointer or points to unpinned Go pointer"</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// cgoCheckArg is the real work of cgoCheckPointer. The argument p</code></span>
<span class="codeline" id="line-539"><code>// is either a pointer to the value (of type t), or the value itself,</code></span>
<span class="codeline" id="line-540"><code>// depending on indir. The top parameter is whether we are at the top</code></span>
<span class="codeline" id="line-541"><code>// level, where Go pointers are allowed. Go pointers to pinned objects are</code></span>
<span class="codeline" id="line-542"><code>// allowed as long as they don't reference other unpinned pointers.</code></span>
<span class="codeline" id="line-543"><code>func cgoCheckArg(t *_type, p unsafe.Pointer, indir, top bool, msg string) {</code></span>
<span class="codeline" id="line-544"><code>	if t.PtrBytes == 0 || p == nil {</code></span>
<span class="codeline" id="line-545"><code>		// If the type has no pointers there is nothing to do.</code></span>
<span class="codeline" id="line-546"><code>		return</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>	switch t.Kind_ &amp; kindMask {</code></span>
<span class="codeline" id="line-550"><code>	default:</code></span>
<span class="codeline" id="line-551"><code>		throw("can't happen")</code></span>
<span class="codeline" id="line-552"><code>	case kindArray:</code></span>
<span class="codeline" id="line-553"><code>		at := (*arraytype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-554"><code>		if !indir {</code></span>
<span class="codeline" id="line-555"><code>			if at.Len != 1 {</code></span>
<span class="codeline" id="line-556"><code>				throw("can't happen")</code></span>
<span class="codeline" id="line-557"><code>			}</code></span>
<span class="codeline" id="line-558"><code>			cgoCheckArg(at.Elem, p, at.Elem.Kind_&amp;kindDirectIface == 0, top, msg)</code></span>
<span class="codeline" id="line-559"><code>			return</code></span>
<span class="codeline" id="line-560"><code>		}</code></span>
<span class="codeline" id="line-561"><code>		for i := uintptr(0); i &lt; at.Len; i++ {</code></span>
<span class="codeline" id="line-562"><code>			cgoCheckArg(at.Elem, p, true, top, msg)</code></span>
<span class="codeline" id="line-563"><code>			p = add(p, at.Elem.Size_)</code></span>
<span class="codeline" id="line-564"><code>		}</code></span>
<span class="codeline" id="line-565"><code>	case kindChan, kindMap:</code></span>
<span class="codeline" id="line-566"><code>		// These types contain internal pointers that will</code></span>
<span class="codeline" id="line-567"><code>		// always be allocated in the Go heap. It's never OK</code></span>
<span class="codeline" id="line-568"><code>		// to pass them to C.</code></span>
<span class="codeline" id="line-569"><code>		panic(errorString(msg))</code></span>
<span class="codeline" id="line-570"><code>	case kindFunc:</code></span>
<span class="codeline" id="line-571"><code>		if indir {</code></span>
<span class="codeline" id="line-572"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-573"><code>		}</code></span>
<span class="codeline" id="line-574"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-575"><code>			return</code></span>
<span class="codeline" id="line-576"><code>		}</code></span>
<span class="codeline" id="line-577"><code>		panic(errorString(msg))</code></span>
<span class="codeline" id="line-578"><code>	case kindInterface:</code></span>
<span class="codeline" id="line-579"><code>		it := *(**_type)(p)</code></span>
<span class="codeline" id="line-580"><code>		if it == nil {</code></span>
<span class="codeline" id="line-581"><code>			return</code></span>
<span class="codeline" id="line-582"><code>		}</code></span>
<span class="codeline" id="line-583"><code>		// A type known at compile time is OK since it's</code></span>
<span class="codeline" id="line-584"><code>		// constant. A type not known at compile time will be</code></span>
<span class="codeline" id="line-585"><code>		// in the heap and will not be OK.</code></span>
<span class="codeline" id="line-586"><code>		if inheap(uintptr(unsafe.Pointer(it))) {</code></span>
<span class="codeline" id="line-587"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-588"><code>		}</code></span>
<span class="codeline" id="line-589"><code>		p = *(*unsafe.Pointer)(add(p, goarch.PtrSize))</code></span>
<span class="codeline" id="line-590"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-591"><code>			return</code></span>
<span class="codeline" id="line-592"><code>		}</code></span>
<span class="codeline" id="line-593"><code>		if !top &amp;&amp; !isPinned(p) {</code></span>
<span class="codeline" id="line-594"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-595"><code>		}</code></span>
<span class="codeline" id="line-596"><code>		cgoCheckArg(it, p, it.Kind_&amp;kindDirectIface == 0, false, msg)</code></span>
<span class="codeline" id="line-597"><code>	case kindSlice:</code></span>
<span class="codeline" id="line-598"><code>		st := (*slicetype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-599"><code>		s := (*slice)(p)</code></span>
<span class="codeline" id="line-600"><code>		p = s.array</code></span>
<span class="codeline" id="line-601"><code>		if p == nil || !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-602"><code>			return</code></span>
<span class="codeline" id="line-603"><code>		}</code></span>
<span class="codeline" id="line-604"><code>		if !top &amp;&amp; !isPinned(p) {</code></span>
<span class="codeline" id="line-605"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-606"><code>		}</code></span>
<span class="codeline" id="line-607"><code>		if st.Elem.PtrBytes == 0 {</code></span>
<span class="codeline" id="line-608"><code>			return</code></span>
<span class="codeline" id="line-609"><code>		}</code></span>
<span class="codeline" id="line-610"><code>		for i := 0; i &lt; s.cap; i++ {</code></span>
<span class="codeline" id="line-611"><code>			cgoCheckArg(st.Elem, p, true, false, msg)</code></span>
<span class="codeline" id="line-612"><code>			p = add(p, st.Elem.Size_)</code></span>
<span class="codeline" id="line-613"><code>		}</code></span>
<span class="codeline" id="line-614"><code>	case kindString:</code></span>
<span class="codeline" id="line-615"><code>		ss := (*stringStruct)(p)</code></span>
<span class="codeline" id="line-616"><code>		if !cgoIsGoPointer(ss.str) {</code></span>
<span class="codeline" id="line-617"><code>			return</code></span>
<span class="codeline" id="line-618"><code>		}</code></span>
<span class="codeline" id="line-619"><code>		if !top &amp;&amp; !isPinned(ss.str) {</code></span>
<span class="codeline" id="line-620"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-621"><code>		}</code></span>
<span class="codeline" id="line-622"><code>	case kindStruct:</code></span>
<span class="codeline" id="line-623"><code>		st := (*structtype)(unsafe.Pointer(t))</code></span>
<span class="codeline" id="line-624"><code>		if !indir {</code></span>
<span class="codeline" id="line-625"><code>			if len(st.Fields) != 1 {</code></span>
<span class="codeline" id="line-626"><code>				throw("can't happen")</code></span>
<span class="codeline" id="line-627"><code>			}</code></span>
<span class="codeline" id="line-628"><code>			cgoCheckArg(st.Fields[0].Typ, p, st.Fields[0].Typ.Kind_&amp;kindDirectIface == 0, top, msg)</code></span>
<span class="codeline" id="line-629"><code>			return</code></span>
<span class="codeline" id="line-630"><code>		}</code></span>
<span class="codeline" id="line-631"><code>		for _, f := range st.Fields {</code></span>
<span class="codeline" id="line-632"><code>			if f.Typ.PtrBytes == 0 {</code></span>
<span class="codeline" id="line-633"><code>				continue</code></span>
<span class="codeline" id="line-634"><code>			}</code></span>
<span class="codeline" id="line-635"><code>			cgoCheckArg(f.Typ, add(p, f.Offset), true, top, msg)</code></span>
<span class="codeline" id="line-636"><code>		}</code></span>
<span class="codeline" id="line-637"><code>	case kindPtr, kindUnsafePointer:</code></span>
<span class="codeline" id="line-638"><code>		if indir {</code></span>
<span class="codeline" id="line-639"><code>			p = *(*unsafe.Pointer)(p)</code></span>
<span class="codeline" id="line-640"><code>			if p == nil {</code></span>
<span class="codeline" id="line-641"><code>				return</code></span>
<span class="codeline" id="line-642"><code>			}</code></span>
<span class="codeline" id="line-643"><code>		}</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>		if !cgoIsGoPointer(p) {</code></span>
<span class="codeline" id="line-646"><code>			return</code></span>
<span class="codeline" id="line-647"><code>		}</code></span>
<span class="codeline" id="line-648"><code>		if !top &amp;&amp; !isPinned(p) {</code></span>
<span class="codeline" id="line-649"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-650"><code>		}</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>		cgoCheckUnknownPointer(p, msg)</code></span>
<span class="codeline" id="line-653"><code>	}</code></span>
<span class="codeline" id="line-654"><code>}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>// cgoCheckUnknownPointer is called for an arbitrary pointer into Go</code></span>
<span class="codeline" id="line-657"><code>// memory. It checks whether that Go memory contains any other</code></span>
<span class="codeline" id="line-658"><code>// pointer into unpinned Go memory. If it does, we panic.</code></span>
<span class="codeline" id="line-659"><code>// The return values are unused but useful to see in panic tracebacks.</code></span>
<span class="codeline" id="line-660"><code>func cgoCheckUnknownPointer(p unsafe.Pointer, msg string) (base, i uintptr) {</code></span>
<span class="codeline" id="line-661"><code>	if inheap(uintptr(p)) {</code></span>
<span class="codeline" id="line-662"><code>		b, span, _ := findObject(uintptr(p), 0, 0)</code></span>
<span class="codeline" id="line-663"><code>		base = b</code></span>
<span class="codeline" id="line-664"><code>		if base == 0 {</code></span>
<span class="codeline" id="line-665"><code>			return</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code>		if goexperiment.AllocHeaders {</code></span>
<span class="codeline" id="line-668"><code>			tp := span.typePointersOfUnchecked(base)</code></span>
<span class="codeline" id="line-669"><code>			for {</code></span>
<span class="codeline" id="line-670"><code>				var addr uintptr</code></span>
<span class="codeline" id="line-671"><code>				if tp, addr = tp.next(base + span.elemsize); addr == 0 {</code></span>
<span class="codeline" id="line-672"><code>					break</code></span>
<span class="codeline" id="line-673"><code>				}</code></span>
<span class="codeline" id="line-674"><code>				pp := *(*unsafe.Pointer)(unsafe.Pointer(addr))</code></span>
<span class="codeline" id="line-675"><code>				if cgoIsGoPointer(pp) &amp;&amp; !isPinned(pp) {</code></span>
<span class="codeline" id="line-676"><code>					panic(errorString(msg))</code></span>
<span class="codeline" id="line-677"><code>				}</code></span>
<span class="codeline" id="line-678"><code>			}</code></span>
<span class="codeline" id="line-679"><code>		} else {</code></span>
<span class="codeline" id="line-680"><code>			n := span.elemsize</code></span>
<span class="codeline" id="line-681"><code>			hbits := heapBitsForAddr(base, n)</code></span>
<span class="codeline" id="line-682"><code>			for {</code></span>
<span class="codeline" id="line-683"><code>				var addr uintptr</code></span>
<span class="codeline" id="line-684"><code>				if hbits, addr = hbits.next(); addr == 0 {</code></span>
<span class="codeline" id="line-685"><code>					break</code></span>
<span class="codeline" id="line-686"><code>				}</code></span>
<span class="codeline" id="line-687"><code>				pp := *(*unsafe.Pointer)(unsafe.Pointer(addr))</code></span>
<span class="codeline" id="line-688"><code>				if cgoIsGoPointer(pp) &amp;&amp; !isPinned(pp) {</code></span>
<span class="codeline" id="line-689"><code>					panic(errorString(msg))</code></span>
<span class="codeline" id="line-690"><code>				}</code></span>
<span class="codeline" id="line-691"><code>			}</code></span>
<span class="codeline" id="line-692"><code>		}</code></span>
<span class="codeline" id="line-693"><code>		return</code></span>
<span class="codeline" id="line-694"><code>	}</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>	for _, datap := range activeModules() {</code></span>
<span class="codeline" id="line-697"><code>		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {</code></span>
<span class="codeline" id="line-698"><code>			// We have no way to know the size of the object.</code></span>
<span class="codeline" id="line-699"><code>			// We have to assume that it might contain a pointer.</code></span>
<span class="codeline" id="line-700"><code>			panic(errorString(msg))</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>		// In the text or noptr sections, we know that the</code></span>
<span class="codeline" id="line-703"><code>		// pointer does not point to a Go pointer.</code></span>
<span class="codeline" id="line-704"><code>	}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>	return</code></span>
<span class="codeline" id="line-707"><code>}</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>// cgoIsGoPointer reports whether the pointer is a Go pointer--a</code></span>
<span class="codeline" id="line-710"><code>// pointer to Go memory. We only care about Go memory that might</code></span>
<span class="codeline" id="line-711"><code>// contain pointers.</code></span>
<span class="codeline" id="line-712"><code>//</code></span>
<span class="codeline" id="line-713"><code>//go:nosplit</code></span>
<span class="codeline" id="line-714"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-715"><code>func cgoIsGoPointer(p unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-716"><code>	if p == nil {</code></span>
<span class="codeline" id="line-717"><code>		return false</code></span>
<span class="codeline" id="line-718"><code>	}</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>	if inHeapOrStack(uintptr(p)) {</code></span>
<span class="codeline" id="line-721"><code>		return true</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>	for _, datap := range activeModules() {</code></span>
<span class="codeline" id="line-725"><code>		if cgoInRange(p, datap.data, datap.edata) || cgoInRange(p, datap.bss, datap.ebss) {</code></span>
<span class="codeline" id="line-726"><code>			return true</code></span>
<span class="codeline" id="line-727"><code>		}</code></span>
<span class="codeline" id="line-728"><code>	}</code></span>
<span class="codeline" id="line-729"><code></code></span>
<span class="codeline" id="line-730"><code>	return false</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>// cgoInRange reports whether p is between start and end.</code></span>
<span class="codeline" id="line-734"><code>//</code></span>
<span class="codeline" id="line-735"><code>//go:nosplit</code></span>
<span class="codeline" id="line-736"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-737"><code>func cgoInRange(p unsafe.Pointer, start, end uintptr) bool {</code></span>
<span class="codeline" id="line-738"><code>	return start &lt;= uintptr(p) &amp;&amp; uintptr(p) &lt; end</code></span>
<span class="codeline" id="line-739"><code>}</code></span>
<span class="codeline" id="line-740"><code></code></span>
<span class="codeline" id="line-741"><code>// cgoCheckResult is called to check the result parameter of an</code></span>
<span class="codeline" id="line-742"><code>// exported Go function. It panics if the result is or contains any</code></span>
<span class="codeline" id="line-743"><code>// other pointer into unpinned Go memory.</code></span>
<span class="codeline" id="line-744"><code>func cgoCheckResult(val any) {</code></span>
<span class="codeline" id="line-745"><code>	if !goexperiment.CgoCheck2 &amp;&amp; debug.cgocheck == 0 {</code></span>
<span class="codeline" id="line-746"><code>		return</code></span>
<span class="codeline" id="line-747"><code>	}</code></span>
<span class="codeline" id="line-748"><code></code></span>
<span class="codeline" id="line-749"><code>	ep := efaceOf(&amp;val)</code></span>
<span class="codeline" id="line-750"><code>	t := ep._type</code></span>
<span class="codeline" id="line-751"><code>	cgoCheckArg(t, ep.data, t.Kind_&amp;kindDirectIface == 0, false, cgoResultFail)</code></span>
<span class="codeline" id="line-752"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>