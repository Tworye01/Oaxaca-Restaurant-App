<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: signal_unix.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	signal_unix.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2012 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>//go:build unix</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"internal/abi"</code></span>
<span class="codeline" id="line-11"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-12"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-13"><code>	"unsafe"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// sigTabT is the type of an entry in the global sigtable array.</code></span>
<span class="codeline" id="line-17"><code>// sigtable is inherently system dependent, and appears in OS-specific files,</code></span>
<span class="codeline" id="line-18"><code>// but sigTabT is the same for all Unixy systems.</code></span>
<span class="codeline" id="line-19"><code>// The sigtable array is indexed by a system signal number to get the flags</code></span>
<span class="codeline" id="line-20"><code>// and printable name of each signal.</code></span>
<span class="codeline" id="line-21"><code>type sigTabT struct {</code></span>
<span class="codeline" id="line-22"><code>	flags int32</code></span>
<span class="codeline" id="line-23"><code>	name  string</code></span>
<span class="codeline" id="line-24"><code>}</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>//go:linkname os_sigpipe os.sigpipe</code></span>
<span class="codeline" id="line-27"><code>func os_sigpipe() {</code></span>
<span class="codeline" id="line-28"><code>	systemstack(sigpipe)</code></span>
<span class="codeline" id="line-29"><code>}</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>func signame(sig uint32) string {</code></span>
<span class="codeline" id="line-32"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-33"><code>		return ""</code></span>
<span class="codeline" id="line-34"><code>	}</code></span>
<span class="codeline" id="line-35"><code>	return sigtable[sig].name</code></span>
<span class="codeline" id="line-36"><code>}</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>const (</code></span>
<span class="codeline" id="line-39"><code>	_SIG_DFL uintptr = 0</code></span>
<span class="codeline" id="line-40"><code>	_SIG_IGN uintptr = 1</code></span>
<span class="codeline" id="line-41"><code>)</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>// sigPreempt is the signal used for non-cooperative preemption.</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>// There's no good way to choose this signal, but there are some</code></span>
<span class="codeline" id="line-46"><code>// heuristics:</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// 1. It should be a signal that's passed-through by debuggers by</code></span>
<span class="codeline" id="line-49"><code>// default. On Linux, this is SIGALRM, SIGURG, SIGCHLD, SIGIO,</code></span>
<span class="codeline" id="line-50"><code>// SIGVTALRM, SIGPROF, and SIGWINCH, plus some glibc-internal signals.</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>// 2. It shouldn't be used internally by libc in mixed Go/C binaries</code></span>
<span class="codeline" id="line-53"><code>// because libc may assume it's the only thing that can handle these</code></span>
<span class="codeline" id="line-54"><code>// signals. For example SIGCANCEL or SIGSETXID.</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>// 3. It should be a signal that can happen spuriously without</code></span>
<span class="codeline" id="line-57"><code>// consequences. For example, SIGALRM is a bad choice because the</code></span>
<span class="codeline" id="line-58"><code>// signal handler can't tell if it was caused by the real process</code></span>
<span class="codeline" id="line-59"><code>// alarm or not (arguably this means the signal is broken, but I</code></span>
<span class="codeline" id="line-60"><code>// digress). SIGUSR1 and SIGUSR2 are also bad because those are often</code></span>
<span class="codeline" id="line-61"><code>// used in meaningful ways by applications.</code></span>
<span class="codeline" id="line-62"><code>//</code></span>
<span class="codeline" id="line-63"><code>// 4. We need to deal with platforms without real-time signals (like</code></span>
<span class="codeline" id="line-64"><code>// macOS), so those are out.</code></span>
<span class="codeline" id="line-65"><code>//</code></span>
<span class="codeline" id="line-66"><code>// We use SIGURG because it meets all of these criteria, is extremely</code></span>
<span class="codeline" id="line-67"><code>// unlikely to be used by an application for its "real" meaning (both</code></span>
<span class="codeline" id="line-68"><code>// because out-of-band data is basically unused and because SIGURG</code></span>
<span class="codeline" id="line-69"><code>// doesn't report which socket has the condition, making it pretty</code></span>
<span class="codeline" id="line-70"><code>// useless), and even if it is, the application has to be ready for</code></span>
<span class="codeline" id="line-71"><code>// spurious SIGURG. SIGIO wouldn't be a bad choice either, but is more</code></span>
<span class="codeline" id="line-72"><code>// likely to be used for real.</code></span>
<span class="codeline" id="line-73"><code>const sigPreempt = _SIGURG</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>// Stores the signal handlers registered before Go installed its own.</code></span>
<span class="codeline" id="line-76"><code>// These signal handlers will be invoked in cases where Go doesn't want to</code></span>
<span class="codeline" id="line-77"><code>// handle a particular signal (e.g., signal occurred on a non-Go thread).</code></span>
<span class="codeline" id="line-78"><code>// See sigfwdgo for more information on when the signals are forwarded.</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>// This is read by the signal handler; accesses should use</code></span>
<span class="codeline" id="line-81"><code>// atomic.Loaduintptr and atomic.Storeuintptr.</code></span>
<span class="codeline" id="line-82"><code>var fwdSig [_NSIG]uintptr</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>// handlingSig is indexed by signal number and is non-zero if we are</code></span>
<span class="codeline" id="line-85"><code>// currently handling the signal. Or, to put it another way, whether</code></span>
<span class="codeline" id="line-86"><code>// the signal handler is currently set to the Go signal handler or not.</code></span>
<span class="codeline" id="line-87"><code>// This is uint32 rather than bool so that we can use atomic instructions.</code></span>
<span class="codeline" id="line-88"><code>var handlingSig [_NSIG]uint32</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>// channels for synchronizing signal mask updates with the signal mask</code></span>
<span class="codeline" id="line-91"><code>// thread</code></span>
<span class="codeline" id="line-92"><code>var (</code></span>
<span class="codeline" id="line-93"><code>	disableSigChan  chan uint32</code></span>
<span class="codeline" id="line-94"><code>	enableSigChan   chan uint32</code></span>
<span class="codeline" id="line-95"><code>	maskUpdatedChan chan struct{}</code></span>
<span class="codeline" id="line-96"><code>)</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>func init() {</code></span>
<span class="codeline" id="line-99"><code>	// _NSIG is the number of signals on this operating system.</code></span>
<span class="codeline" id="line-100"><code>	// sigtable should describe what to do for all the possible signals.</code></span>
<span class="codeline" id="line-101"><code>	if len(sigtable) != _NSIG {</code></span>
<span class="codeline" id="line-102"><code>		print("runtime: len(sigtable)=", len(sigtable), " _NSIG=", _NSIG, "\n")</code></span>
<span class="codeline" id="line-103"><code>		throw("bad sigtable len")</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code>}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>var signalsOK bool</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// Initialize signals.</code></span>
<span class="codeline" id="line-110"><code>// Called by libpreinit so runtime may not be initialized.</code></span>
<span class="codeline" id="line-111"><code>//</code></span>
<span class="codeline" id="line-112"><code>//go:nosplit</code></span>
<span class="codeline" id="line-113"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-114"><code>func initsig(preinit bool) {</code></span>
<span class="codeline" id="line-115"><code>	if !preinit {</code></span>
<span class="codeline" id="line-116"><code>		// It's now OK for signal handlers to run.</code></span>
<span class="codeline" id="line-117"><code>		signalsOK = true</code></span>
<span class="codeline" id="line-118"><code>	}</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>	// For c-archive/c-shared this is called by libpreinit with</code></span>
<span class="codeline" id="line-121"><code>	// preinit == true.</code></span>
<span class="codeline" id="line-122"><code>	if (isarchive || islibrary) &amp;&amp; !preinit {</code></span>
<span class="codeline" id="line-123"><code>		return</code></span>
<span class="codeline" id="line-124"><code>	}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>	for i := uint32(0); i &lt; _NSIG; i++ {</code></span>
<span class="codeline" id="line-127"><code>		t := &amp;sigtable[i]</code></span>
<span class="codeline" id="line-128"><code>		if t.flags == 0 || t.flags&amp;_SigDefault != 0 {</code></span>
<span class="codeline" id="line-129"><code>			continue</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>		// We don't need to use atomic operations here because</code></span>
<span class="codeline" id="line-133"><code>		// there shouldn't be any other goroutines running yet.</code></span>
<span class="codeline" id="line-134"><code>		fwdSig[i] = getsig(i)</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>		if !sigInstallGoHandler(i) {</code></span>
<span class="codeline" id="line-137"><code>			// Even if we are not installing a signal handler,</code></span>
<span class="codeline" id="line-138"><code>			// set SA_ONSTACK if necessary.</code></span>
<span class="codeline" id="line-139"><code>			if fwdSig[i] != _SIG_DFL &amp;&amp; fwdSig[i] != _SIG_IGN {</code></span>
<span class="codeline" id="line-140"><code>				setsigstack(i)</code></span>
<span class="codeline" id="line-141"><code>			} else if fwdSig[i] == _SIG_IGN {</code></span>
<span class="codeline" id="line-142"><code>				sigInitIgnored(i)</code></span>
<span class="codeline" id="line-143"><code>			}</code></span>
<span class="codeline" id="line-144"><code>			continue</code></span>
<span class="codeline" id="line-145"><code>		}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>		handlingSig[i] = 1</code></span>
<span class="codeline" id="line-148"><code>		setsig(i, abi.FuncPCABIInternal(sighandler))</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code>}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>//go:nosplit</code></span>
<span class="codeline" id="line-153"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-154"><code>func sigInstallGoHandler(sig uint32) bool {</code></span>
<span class="codeline" id="line-155"><code>	// For some signals, we respect an inherited SIG_IGN handler</code></span>
<span class="codeline" id="line-156"><code>	// rather than insist on installing our own default handler.</code></span>
<span class="codeline" id="line-157"><code>	// Even these signals can be fetched using the os/signal package.</code></span>
<span class="codeline" id="line-158"><code>	switch sig {</code></span>
<span class="codeline" id="line-159"><code>	case _SIGHUP, _SIGINT:</code></span>
<span class="codeline" id="line-160"><code>		if atomic.Loaduintptr(&amp;fwdSig[sig]) == _SIG_IGN {</code></span>
<span class="codeline" id="line-161"><code>			return false</code></span>
<span class="codeline" id="line-162"><code>		}</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>	if (GOOS == "linux" || GOOS == "android") &amp;&amp; !iscgo &amp;&amp; sig == sigPerThreadSyscall {</code></span>
<span class="codeline" id="line-166"><code>		// sigPerThreadSyscall is the same signal used by glibc for</code></span>
<span class="codeline" id="line-167"><code>		// per-thread syscalls on Linux. We use it for the same purpose</code></span>
<span class="codeline" id="line-168"><code>		// in non-cgo binaries.</code></span>
<span class="codeline" id="line-169"><code>		return true</code></span>
<span class="codeline" id="line-170"><code>	}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-173"><code>	if t.flags&amp;_SigSetStack != 0 {</code></span>
<span class="codeline" id="line-174"><code>		return false</code></span>
<span class="codeline" id="line-175"><code>	}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// When built using c-archive or c-shared, only install signal</code></span>
<span class="codeline" id="line-178"><code>	// handlers for synchronous signals and SIGPIPE and sigPreempt.</code></span>
<span class="codeline" id="line-179"><code>	if (isarchive || islibrary) &amp;&amp; t.flags&amp;_SigPanic == 0 &amp;&amp; sig != _SIGPIPE &amp;&amp; sig != sigPreempt {</code></span>
<span class="codeline" id="line-180"><code>		return false</code></span>
<span class="codeline" id="line-181"><code>	}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>	return true</code></span>
<span class="codeline" id="line-184"><code>}</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>// sigenable enables the Go signal handler to catch the signal sig.</code></span>
<span class="codeline" id="line-187"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-188"><code>// via os/signal.enableSignal and signal_enable.</code></span>
<span class="codeline" id="line-189"><code>func sigenable(sig uint32) {</code></span>
<span class="codeline" id="line-190"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-191"><code>		return</code></span>
<span class="codeline" id="line-192"><code>	}</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-195"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-196"><code>		return</code></span>
<span class="codeline" id="line-197"><code>	}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-200"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-201"><code>		ensureSigM()</code></span>
<span class="codeline" id="line-202"><code>		enableSigChan &lt;- sig</code></span>
<span class="codeline" id="line-203"><code>		&lt;-maskUpdatedChan</code></span>
<span class="codeline" id="line-204"><code>		if atomic.Cas(&amp;handlingSig[sig], 0, 1) {</code></span>
<span class="codeline" id="line-205"><code>			atomic.Storeuintptr(&amp;fwdSig[sig], getsig(sig))</code></span>
<span class="codeline" id="line-206"><code>			setsig(sig, abi.FuncPCABIInternal(sighandler))</code></span>
<span class="codeline" id="line-207"><code>		}</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>// sigdisable disables the Go signal handler for the signal sig.</code></span>
<span class="codeline" id="line-212"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-213"><code>// via os/signal.disableSignal and signal_disable.</code></span>
<span class="codeline" id="line-214"><code>func sigdisable(sig uint32) {</code></span>
<span class="codeline" id="line-215"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-216"><code>		return</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-220"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-221"><code>		return</code></span>
<span class="codeline" id="line-222"><code>	}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-225"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-226"><code>		ensureSigM()</code></span>
<span class="codeline" id="line-227"><code>		disableSigChan &lt;- sig</code></span>
<span class="codeline" id="line-228"><code>		&lt;-maskUpdatedChan</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>		// If initsig does not install a signal handler for a</code></span>
<span class="codeline" id="line-231"><code>		// signal, then to go back to the state before Notify</code></span>
<span class="codeline" id="line-232"><code>		// we should remove the one we installed.</code></span>
<span class="codeline" id="line-233"><code>		if !sigInstallGoHandler(sig) {</code></span>
<span class="codeline" id="line-234"><code>			atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-235"><code>			setsig(sig, atomic.Loaduintptr(&amp;fwdSig[sig]))</code></span>
<span class="codeline" id="line-236"><code>		}</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// sigignore ignores the signal sig.</code></span>
<span class="codeline" id="line-241"><code>// It is only called while holding the os/signal.handlers lock,</code></span>
<span class="codeline" id="line-242"><code>// via os/signal.ignoreSignal and signal_ignore.</code></span>
<span class="codeline" id="line-243"><code>func sigignore(sig uint32) {</code></span>
<span class="codeline" id="line-244"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-245"><code>		return</code></span>
<span class="codeline" id="line-246"><code>	}</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>	// SIGPROF is handled specially for profiling.</code></span>
<span class="codeline" id="line-249"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-250"><code>		return</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>	t := &amp;sigtable[sig]</code></span>
<span class="codeline" id="line-254"><code>	if t.flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-255"><code>		atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-256"><code>		setsig(sig, _SIG_IGN)</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// clearSignalHandlers clears all signal handlers that are not ignored</code></span>
<span class="codeline" id="line-261"><code>// back to the default. This is called by the child after a fork, so that</code></span>
<span class="codeline" id="line-262"><code>// we can enable the signal mask for the exec without worrying about</code></span>
<span class="codeline" id="line-263"><code>// running a signal handler in the child.</code></span>
<span class="codeline" id="line-264"><code>//</code></span>
<span class="codeline" id="line-265"><code>//go:nosplit</code></span>
<span class="codeline" id="line-266"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-267"><code>func clearSignalHandlers() {</code></span>
<span class="codeline" id="line-268"><code>	for i := uint32(0); i &lt; _NSIG; i++ {</code></span>
<span class="codeline" id="line-269"><code>		if atomic.Load(&amp;handlingSig[i]) != 0 {</code></span>
<span class="codeline" id="line-270"><code>			setsig(i, _SIG_DFL)</code></span>
<span class="codeline" id="line-271"><code>		}</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code>}</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>// setProcessCPUProfilerTimer is called when the profiling timer changes.</code></span>
<span class="codeline" id="line-276"><code>// It is called with prof.signalLock held. hz is the new timer, and is 0 if</code></span>
<span class="codeline" id="line-277"><code>// profiling is being disabled. Enable or disable the signal as</code></span>
<span class="codeline" id="line-278"><code>// required for -buildmode=c-archive.</code></span>
<span class="codeline" id="line-279"><code>func setProcessCPUProfilerTimer(hz int32) {</code></span>
<span class="codeline" id="line-280"><code>	if hz != 0 {</code></span>
<span class="codeline" id="line-281"><code>		// Enable the Go signal handler if not enabled.</code></span>
<span class="codeline" id="line-282"><code>		if atomic.Cas(&amp;handlingSig[_SIGPROF], 0, 1) {</code></span>
<span class="codeline" id="line-283"><code>			h := getsig(_SIGPROF)</code></span>
<span class="codeline" id="line-284"><code>			// If no signal handler was installed before, then we record</code></span>
<span class="codeline" id="line-285"><code>			// _SIG_IGN here. When we turn off profiling (below) we'll start</code></span>
<span class="codeline" id="line-286"><code>			// ignoring SIGPROF signals. We do this, rather than change</code></span>
<span class="codeline" id="line-287"><code>			// to SIG_DFL, because there may be a pending SIGPROF</code></span>
<span class="codeline" id="line-288"><code>			// signal that has not yet been delivered to some other thread.</code></span>
<span class="codeline" id="line-289"><code>			// If we change to SIG_DFL when turning off profiling, the</code></span>
<span class="codeline" id="line-290"><code>			// program will crash when that SIGPROF is delivered. We assume</code></span>
<span class="codeline" id="line-291"><code>			// that programs that use profiling don't want to crash on a</code></span>
<span class="codeline" id="line-292"><code>			// stray SIGPROF. See issue 19320.</code></span>
<span class="codeline" id="line-293"><code>			// We do the change here instead of when turning off profiling,</code></span>
<span class="codeline" id="line-294"><code>			// because there we may race with a signal handler running</code></span>
<span class="codeline" id="line-295"><code>			// concurrently, in particular, sigfwdgo may observe _SIG_DFL and</code></span>
<span class="codeline" id="line-296"><code>			// die. See issue 43828.</code></span>
<span class="codeline" id="line-297"><code>			if h == _SIG_DFL {</code></span>
<span class="codeline" id="line-298"><code>				h = _SIG_IGN</code></span>
<span class="codeline" id="line-299"><code>			}</code></span>
<span class="codeline" id="line-300"><code>			atomic.Storeuintptr(&amp;fwdSig[_SIGPROF], h)</code></span>
<span class="codeline" id="line-301"><code>			setsig(_SIGPROF, abi.FuncPCABIInternal(sighandler))</code></span>
<span class="codeline" id="line-302"><code>		}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>		var it itimerval</code></span>
<span class="codeline" id="line-305"><code>		it.it_interval.tv_sec = 0</code></span>
<span class="codeline" id="line-306"><code>		it.it_interval.set_usec(1000000 / hz)</code></span>
<span class="codeline" id="line-307"><code>		it.it_value = it.it_interval</code></span>
<span class="codeline" id="line-308"><code>		setitimer(_ITIMER_PROF, &amp;it, nil)</code></span>
<span class="codeline" id="line-309"><code>	} else {</code></span>
<span class="codeline" id="line-310"><code>		setitimer(_ITIMER_PROF, &amp;itimerval{}, nil)</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>		// If the Go signal handler should be disabled by default,</code></span>
<span class="codeline" id="line-313"><code>		// switch back to the signal handler that was installed</code></span>
<span class="codeline" id="line-314"><code>		// when we enabled profiling. We don't try to handle the case</code></span>
<span class="codeline" id="line-315"><code>		// of a program that changes the SIGPROF handler while Go</code></span>
<span class="codeline" id="line-316"><code>		// profiling is enabled.</code></span>
<span class="codeline" id="line-317"><code>		if !sigInstallGoHandler(_SIGPROF) {</code></span>
<span class="codeline" id="line-318"><code>			if atomic.Cas(&amp;handlingSig[_SIGPROF], 1, 0) {</code></span>
<span class="codeline" id="line-319"><code>				h := atomic.Loaduintptr(&amp;fwdSig[_SIGPROF])</code></span>
<span class="codeline" id="line-320"><code>				setsig(_SIGPROF, h)</code></span>
<span class="codeline" id="line-321"><code>			}</code></span>
<span class="codeline" id="line-322"><code>		}</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code>}</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>// setThreadCPUProfilerHz makes any thread-specific changes required to</code></span>
<span class="codeline" id="line-327"><code>// implement profiling at a rate of hz.</code></span>
<span class="codeline" id="line-328"><code>// No changes required on Unix systems when using setitimer.</code></span>
<span class="codeline" id="line-329"><code>func setThreadCPUProfilerHz(hz int32) {</code></span>
<span class="codeline" id="line-330"><code>	getg().m.profilehz = hz</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>func sigpipe() {</code></span>
<span class="codeline" id="line-334"><code>	if signal_ignored(_SIGPIPE) || sigsend(_SIGPIPE) {</code></span>
<span class="codeline" id="line-335"><code>		return</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code>	dieFromSignal(_SIGPIPE)</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// doSigPreempt handles a preemption signal on gp.</code></span>
<span class="codeline" id="line-341"><code>func doSigPreempt(gp *g, ctxt *sigctxt) {</code></span>
<span class="codeline" id="line-342"><code>	// Check if this G wants to be preempted and is safe to</code></span>
<span class="codeline" id="line-343"><code>	// preempt.</code></span>
<span class="codeline" id="line-344"><code>	if wantAsyncPreempt(gp) {</code></span>
<span class="codeline" id="line-345"><code>		if ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok {</code></span>
<span class="codeline" id="line-346"><code>			// Adjust the PC and inject a call to asyncPreempt.</code></span>
<span class="codeline" id="line-347"><code>			ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)</code></span>
<span class="codeline" id="line-348"><code>		}</code></span>
<span class="codeline" id="line-349"><code>	}</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>	// Acknowledge the preemption.</code></span>
<span class="codeline" id="line-352"><code>	gp.m.preemptGen.Add(1)</code></span>
<span class="codeline" id="line-353"><code>	gp.m.signalPending.Store(0)</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-356"><code>		pendingPreemptSignals.Add(-1)</code></span>
<span class="codeline" id="line-357"><code>	}</code></span>
<span class="codeline" id="line-358"><code>}</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>const preemptMSupported = true</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>// preemptM sends a preemption request to mp. This request may be</code></span>
<span class="codeline" id="line-363"><code>// handled asynchronously and may be coalesced with other requests to</code></span>
<span class="codeline" id="line-364"><code>// the M. When the request is received, if the running G or P are</code></span>
<span class="codeline" id="line-365"><code>// marked for preemption and the goroutine is at an asynchronous</code></span>
<span class="codeline" id="line-366"><code>// safe-point, it will preempt the goroutine. It always atomically</code></span>
<span class="codeline" id="line-367"><code>// increments mp.preemptGen after handling a preemption request.</code></span>
<span class="codeline" id="line-368"><code>func preemptM(mp *m) {</code></span>
<span class="codeline" id="line-369"><code>	// On Darwin, don't try to preempt threads during exec.</code></span>
<span class="codeline" id="line-370"><code>	// Issue #41702.</code></span>
<span class="codeline" id="line-371"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-372"><code>		execLock.rlock()</code></span>
<span class="codeline" id="line-373"><code>	}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>	if mp.signalPending.CompareAndSwap(0, 1) {</code></span>
<span class="codeline" id="line-376"><code>		if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-377"><code>			pendingPreemptSignals.Add(1)</code></span>
<span class="codeline" id="line-378"><code>		}</code></span>
<span class="codeline" id="line-379"><code></code></span>
<span class="codeline" id="line-380"><code>		// If multiple threads are preempting the same M, it may send many</code></span>
<span class="codeline" id="line-381"><code>		// signals to the same M such that it hardly make progress, causing</code></span>
<span class="codeline" id="line-382"><code>		// live-lock problem. Apparently this could happen on darwin. See</code></span>
<span class="codeline" id="line-383"><code>		// issue #37741.</code></span>
<span class="codeline" id="line-384"><code>		// Only send a signal if there isn't already one pending.</code></span>
<span class="codeline" id="line-385"><code>		signalM(mp, sigPreempt)</code></span>
<span class="codeline" id="line-386"><code>	}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>	if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-389"><code>		execLock.runlock()</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>// sigFetchG fetches the value of G safely when running in a signal handler.</code></span>
<span class="codeline" id="line-394"><code>// On some architectures, the g value may be clobbered when running in a VDSO.</code></span>
<span class="codeline" id="line-395"><code>// See issue #32912.</code></span>
<span class="codeline" id="line-396"><code>//</code></span>
<span class="codeline" id="line-397"><code>//go:nosplit</code></span>
<span class="codeline" id="line-398"><code>func sigFetchG(c *sigctxt) *g {</code></span>
<span class="codeline" id="line-399"><code>	switch GOARCH {</code></span>
<span class="codeline" id="line-400"><code>	case "arm", "arm64", "loong64", "ppc64", "ppc64le", "riscv64", "s390x":</code></span>
<span class="codeline" id="line-401"><code>		if !iscgo &amp;&amp; inVDSOPage(c.sigpc()) {</code></span>
<span class="codeline" id="line-402"><code>			// When using cgo, we save the g on TLS and load it from there</code></span>
<span class="codeline" id="line-403"><code>			// in sigtramp. Just use that.</code></span>
<span class="codeline" id="line-404"><code>			// Otherwise, before making a VDSO call we save the g to the</code></span>
<span class="codeline" id="line-405"><code>			// bottom of the signal stack. Fetch from there.</code></span>
<span class="codeline" id="line-406"><code>			// TODO: in efence mode, stack is sysAlloc'd, so this wouldn't</code></span>
<span class="codeline" id="line-407"><code>			// work.</code></span>
<span class="codeline" id="line-408"><code>			sp := getcallersp()</code></span>
<span class="codeline" id="line-409"><code>			s := spanOf(sp)</code></span>
<span class="codeline" id="line-410"><code>			if s != nil &amp;&amp; s.state.get() == mSpanManual &amp;&amp; s.base() &lt; sp &amp;&amp; sp &lt; s.limit {</code></span>
<span class="codeline" id="line-411"><code>				gp := *(**g)(unsafe.Pointer(s.base()))</code></span>
<span class="codeline" id="line-412"><code>				return gp</code></span>
<span class="codeline" id="line-413"><code>			}</code></span>
<span class="codeline" id="line-414"><code>			return nil</code></span>
<span class="codeline" id="line-415"><code>		}</code></span>
<span class="codeline" id="line-416"><code>	}</code></span>
<span class="codeline" id="line-417"><code>	return getg()</code></span>
<span class="codeline" id="line-418"><code>}</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>// sigtrampgo is called from the signal handler function, sigtramp,</code></span>
<span class="codeline" id="line-421"><code>// written in assembly code.</code></span>
<span class="codeline" id="line-422"><code>// This is called by the signal handler, and the world may be stopped.</code></span>
<span class="codeline" id="line-423"><code>//</code></span>
<span class="codeline" id="line-424"><code>// It must be nosplit because getg() is still the G that was running</code></span>
<span class="codeline" id="line-425"><code>// (if any) when the signal was delivered, but it's (usually) called</code></span>
<span class="codeline" id="line-426"><code>// on the gsignal stack. Until this switches the G to gsignal, the</code></span>
<span class="codeline" id="line-427"><code>// stack bounds check won't work.</code></span>
<span class="codeline" id="line-428"><code>//</code></span>
<span class="codeline" id="line-429"><code>//go:nosplit</code></span>
<span class="codeline" id="line-430"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-431"><code>func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer) {</code></span>
<span class="codeline" id="line-432"><code>	if sigfwdgo(sig, info, ctx) {</code></span>
<span class="codeline" id="line-433"><code>		return</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	c := &amp;sigctxt{info, ctx}</code></span>
<span class="codeline" id="line-436"><code>	gp := sigFetchG(c)</code></span>
<span class="codeline" id="line-437"><code>	setg(gp)</code></span>
<span class="codeline" id="line-438"><code>	if gp == nil || (gp.m != nil &amp;&amp; gp.m.isExtraInC) {</code></span>
<span class="codeline" id="line-439"><code>		if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-440"><code>			// Some platforms (Linux) have per-thread timers, which we use in</code></span>
<span class="codeline" id="line-441"><code>			// combination with the process-wide timer. Avoid double-counting.</code></span>
<span class="codeline" id="line-442"><code>			if validSIGPROF(nil, c) {</code></span>
<span class="codeline" id="line-443"><code>				sigprofNonGoPC(c.sigpc())</code></span>
<span class="codeline" id="line-444"><code>			}</code></span>
<span class="codeline" id="line-445"><code>			return</code></span>
<span class="codeline" id="line-446"><code>		}</code></span>
<span class="codeline" id="line-447"><code>		if sig == sigPreempt &amp;&amp; preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-448"><code>			// This is probably a signal from preemptM sent</code></span>
<span class="codeline" id="line-449"><code>			// while executing Go code but received while</code></span>
<span class="codeline" id="line-450"><code>			// executing non-Go code.</code></span>
<span class="codeline" id="line-451"><code>			// We got past sigfwdgo, so we know that there is</code></span>
<span class="codeline" id="line-452"><code>			// no non-Go signal handler for sigPreempt.</code></span>
<span class="codeline" id="line-453"><code>			// The default behavior for sigPreempt is to ignore</code></span>
<span class="codeline" id="line-454"><code>			// the signal, so badsignal will be a no-op anyway.</code></span>
<span class="codeline" id="line-455"><code>			if GOOS == "darwin" || GOOS == "ios" {</code></span>
<span class="codeline" id="line-456"><code>				pendingPreemptSignals.Add(-1)</code></span>
<span class="codeline" id="line-457"><code>			}</code></span>
<span class="codeline" id="line-458"><code>			return</code></span>
<span class="codeline" id="line-459"><code>		}</code></span>
<span class="codeline" id="line-460"><code>		c.fixsigcode(sig)</code></span>
<span class="codeline" id="line-461"><code>		// Set g to nil here and badsignal will use g0 by needm.</code></span>
<span class="codeline" id="line-462"><code>		// TODO: reuse the current m here by using the gsignal and adjustSignalStack,</code></span>
<span class="codeline" id="line-463"><code>		// since the current g maybe a normal goroutine and actually running on the signal stack,</code></span>
<span class="codeline" id="line-464"><code>		// it may hit stack split that is not expected here.</code></span>
<span class="codeline" id="line-465"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-466"><code>			setg(nil)</code></span>
<span class="codeline" id="line-467"><code>		}</code></span>
<span class="codeline" id="line-468"><code>		badsignal(uintptr(sig), c)</code></span>
<span class="codeline" id="line-469"><code>		// Restore g</code></span>
<span class="codeline" id="line-470"><code>		if gp != nil {</code></span>
<span class="codeline" id="line-471"><code>			setg(gp)</code></span>
<span class="codeline" id="line-472"><code>		}</code></span>
<span class="codeline" id="line-473"><code>		return</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>	setg(gp.m.gsignal)</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>	// If some non-Go code called sigaltstack, adjust.</code></span>
<span class="codeline" id="line-479"><code>	var gsignalStack gsignalStack</code></span>
<span class="codeline" id="line-480"><code>	setStack := adjustSignalStack(sig, gp.m, &amp;gsignalStack)</code></span>
<span class="codeline" id="line-481"><code>	if setStack {</code></span>
<span class="codeline" id="line-482"><code>		gp.m.gsignal.stktopsp = getcallersp()</code></span>
<span class="codeline" id="line-483"><code>	}</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>	if gp.stackguard0 == stackFork {</code></span>
<span class="codeline" id="line-486"><code>		signalDuringFork(sig)</code></span>
<span class="codeline" id="line-487"><code>	}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>	c.fixsigcode(sig)</code></span>
<span class="codeline" id="line-490"><code>	sighandler(sig, info, ctx, gp)</code></span>
<span class="codeline" id="line-491"><code>	setg(gp)</code></span>
<span class="codeline" id="line-492"><code>	if setStack {</code></span>
<span class="codeline" id="line-493"><code>		restoreGsignalStack(&amp;gsignalStack)</code></span>
<span class="codeline" id="line-494"><code>	}</code></span>
<span class="codeline" id="line-495"><code>}</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>// If the signal handler receives a SIGPROF signal on a non-Go thread,</code></span>
<span class="codeline" id="line-498"><code>// it tries to collect a traceback into sigprofCallers.</code></span>
<span class="codeline" id="line-499"><code>// sigprofCallersUse is set to non-zero while sigprofCallers holds a traceback.</code></span>
<span class="codeline" id="line-500"><code>var sigprofCallers cgoCallers</code></span>
<span class="codeline" id="line-501"><code>var sigprofCallersUse uint32</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// sigprofNonGo is called if we receive a SIGPROF signal on a non-Go thread,</code></span>
<span class="codeline" id="line-504"><code>// and the signal handler collected a stack trace in sigprofCallers.</code></span>
<span class="codeline" id="line-505"><code>// When this is called, sigprofCallersUse will be non-zero.</code></span>
<span class="codeline" id="line-506"><code>// g is nil, and what we can do is very limited.</code></span>
<span class="codeline" id="line-507"><code>//</code></span>
<span class="codeline" id="line-508"><code>// It is called from the signal handling functions written in assembly code that</code></span>
<span class="codeline" id="line-509"><code>// are active for cgo programs, cgoSigtramp and sigprofNonGoWrapper, which have</code></span>
<span class="codeline" id="line-510"><code>// not verified that the SIGPROF delivery corresponds to the best available</code></span>
<span class="codeline" id="line-511"><code>// profiling source for this thread.</code></span>
<span class="codeline" id="line-512"><code>//</code></span>
<span class="codeline" id="line-513"><code>//go:nosplit</code></span>
<span class="codeline" id="line-514"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-515"><code>func sigprofNonGo(sig uint32, info *siginfo, ctx unsafe.Pointer) {</code></span>
<span class="codeline" id="line-516"><code>	if prof.hz.Load() != 0 {</code></span>
<span class="codeline" id="line-517"><code>		c := &amp;sigctxt{info, ctx}</code></span>
<span class="codeline" id="line-518"><code>		// Some platforms (Linux) have per-thread timers, which we use in</code></span>
<span class="codeline" id="line-519"><code>		// combination with the process-wide timer. Avoid double-counting.</code></span>
<span class="codeline" id="line-520"><code>		if validSIGPROF(nil, c) {</code></span>
<span class="codeline" id="line-521"><code>			n := 0</code></span>
<span class="codeline" id="line-522"><code>			for n &lt; len(sigprofCallers) &amp;&amp; sigprofCallers[n] != 0 {</code></span>
<span class="codeline" id="line-523"><code>				n++</code></span>
<span class="codeline" id="line-524"><code>			}</code></span>
<span class="codeline" id="line-525"><code>			cpuprof.addNonGo(sigprofCallers[:n])</code></span>
<span class="codeline" id="line-526"><code>		}</code></span>
<span class="codeline" id="line-527"><code>	}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	atomic.Store(&amp;sigprofCallersUse, 0)</code></span>
<span class="codeline" id="line-530"><code>}</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>// sigprofNonGoPC is called when a profiling signal arrived on a</code></span>
<span class="codeline" id="line-533"><code>// non-Go thread and we have a single PC value, not a stack trace.</code></span>
<span class="codeline" id="line-534"><code>// g is nil, and what we can do is very limited.</code></span>
<span class="codeline" id="line-535"><code>//</code></span>
<span class="codeline" id="line-536"><code>//go:nosplit</code></span>
<span class="codeline" id="line-537"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-538"><code>func sigprofNonGoPC(pc uintptr) {</code></span>
<span class="codeline" id="line-539"><code>	if prof.hz.Load() != 0 {</code></span>
<span class="codeline" id="line-540"><code>		stk := []uintptr{</code></span>
<span class="codeline" id="line-541"><code>			pc,</code></span>
<span class="codeline" id="line-542"><code>			abi.FuncPCABIInternal(_ExternalCode) + sys.PCQuantum,</code></span>
<span class="codeline" id="line-543"><code>		}</code></span>
<span class="codeline" id="line-544"><code>		cpuprof.addNonGo(stk)</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code>}</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>// adjustSignalStack adjusts the current stack guard based on the</code></span>
<span class="codeline" id="line-549"><code>// stack pointer that is actually in use while handling a signal.</code></span>
<span class="codeline" id="line-550"><code>// We do this in case some non-Go code called sigaltstack.</code></span>
<span class="codeline" id="line-551"><code>// This reports whether the stack was adjusted, and if so stores the old</code></span>
<span class="codeline" id="line-552"><code>// signal stack in *gsigstack.</code></span>
<span class="codeline" id="line-553"><code>//</code></span>
<span class="codeline" id="line-554"><code>//go:nosplit</code></span>
<span class="codeline" id="line-555"><code>func adjustSignalStack(sig uint32, mp *m, gsigStack *gsignalStack) bool {</code></span>
<span class="codeline" id="line-556"><code>	sp := uintptr(unsafe.Pointer(&amp;sig))</code></span>
<span class="codeline" id="line-557"><code>	if sp &gt;= mp.gsignal.stack.lo &amp;&amp; sp &lt; mp.gsignal.stack.hi {</code></span>
<span class="codeline" id="line-558"><code>		return false</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code></code></span>
<span class="codeline" id="line-561"><code>	var st stackt</code></span>
<span class="codeline" id="line-562"><code>	sigaltstack(nil, &amp;st)</code></span>
<span class="codeline" id="line-563"><code>	stsp := uintptr(unsafe.Pointer(st.ss_sp))</code></span>
<span class="codeline" id="line-564"><code>	if st.ss_flags&amp;_SS_DISABLE == 0 &amp;&amp; sp &gt;= stsp &amp;&amp; sp &lt; stsp+st.ss_size {</code></span>
<span class="codeline" id="line-565"><code>		setGsignalStack(&amp;st, gsigStack)</code></span>
<span class="codeline" id="line-566"><code>		return true</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	if sp &gt;= mp.g0.stack.lo &amp;&amp; sp &lt; mp.g0.stack.hi {</code></span>
<span class="codeline" id="line-570"><code>		// The signal was delivered on the g0 stack.</code></span>
<span class="codeline" id="line-571"><code>		// This can happen when linked with C code</code></span>
<span class="codeline" id="line-572"><code>		// using the thread sanitizer, which collects</code></span>
<span class="codeline" id="line-573"><code>		// signals then delivers them itself by calling</code></span>
<span class="codeline" id="line-574"><code>		// the signal handler directly when C code,</code></span>
<span class="codeline" id="line-575"><code>		// including C code called via cgo, calls a</code></span>
<span class="codeline" id="line-576"><code>		// TSAN-intercepted function such as malloc.</code></span>
<span class="codeline" id="line-577"><code>		//</code></span>
<span class="codeline" id="line-578"><code>		// We check this condition last as g0.stack.lo</code></span>
<span class="codeline" id="line-579"><code>		// may be not very accurate (see mstart).</code></span>
<span class="codeline" id="line-580"><code>		st := stackt{ss_size: mp.g0.stack.hi - mp.g0.stack.lo}</code></span>
<span class="codeline" id="line-581"><code>		setSignalstackSP(&amp;st, mp.g0.stack.lo)</code></span>
<span class="codeline" id="line-582"><code>		setGsignalStack(&amp;st, gsigStack)</code></span>
<span class="codeline" id="line-583"><code>		return true</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>	// sp is not within gsignal stack, g0 stack, or sigaltstack. Bad.</code></span>
<span class="codeline" id="line-587"><code>	setg(nil)</code></span>
<span class="codeline" id="line-588"><code>	needm(true)</code></span>
<span class="codeline" id="line-589"><code>	if st.ss_flags&amp;_SS_DISABLE != 0 {</code></span>
<span class="codeline" id="line-590"><code>		noSignalStack(sig)</code></span>
<span class="codeline" id="line-591"><code>	} else {</code></span>
<span class="codeline" id="line-592"><code>		sigNotOnStack(sig, sp, mp)</code></span>
<span class="codeline" id="line-593"><code>	}</code></span>
<span class="codeline" id="line-594"><code>	dropm()</code></span>
<span class="codeline" id="line-595"><code>	return false</code></span>
<span class="codeline" id="line-596"><code>}</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>// crashing is the number of m's we have waited for when implementing</code></span>
<span class="codeline" id="line-599"><code>// GOTRACEBACK=crash when a signal is received.</code></span>
<span class="codeline" id="line-600"><code>var crashing atomic.Int32</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>// testSigtrap and testSigusr1 are used by the runtime tests. If</code></span>
<span class="codeline" id="line-603"><code>// non-nil, it is called on SIGTRAP/SIGUSR1. If it returns true, the</code></span>
<span class="codeline" id="line-604"><code>// normal behavior on this signal is suppressed.</code></span>
<span class="codeline" id="line-605"><code>var testSigtrap func(info *siginfo, ctxt *sigctxt, gp *g) bool</code></span>
<span class="codeline" id="line-606"><code>var testSigusr1 func(gp *g) bool</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>// sighandler is invoked when a signal occurs. The global g will be</code></span>
<span class="codeline" id="line-609"><code>// set to a gsignal goroutine and we will be running on the alternate</code></span>
<span class="codeline" id="line-610"><code>// signal stack. The parameter gp will be the value of the global g</code></span>
<span class="codeline" id="line-611"><code>// when the signal occurred. The sig, info, and ctxt parameters are</code></span>
<span class="codeline" id="line-612"><code>// from the system signal handler: they are the parameters passed when</code></span>
<span class="codeline" id="line-613"><code>// the SA is passed to the sigaction system call.</code></span>
<span class="codeline" id="line-614"><code>//</code></span>
<span class="codeline" id="line-615"><code>// The garbage collector may have stopped the world, so write barriers</code></span>
<span class="codeline" id="line-616"><code>// are not allowed.</code></span>
<span class="codeline" id="line-617"><code>//</code></span>
<span class="codeline" id="line-618"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-619"><code>func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {</code></span>
<span class="codeline" id="line-620"><code>	// The g executing the signal handler. This is almost always</code></span>
<span class="codeline" id="line-621"><code>	// mp.gsignal. See delayedSignal for an exception.</code></span>
<span class="codeline" id="line-622"><code>	gsignal := getg()</code></span>
<span class="codeline" id="line-623"><code>	mp := gsignal.m</code></span>
<span class="codeline" id="line-624"><code>	c := &amp;sigctxt{info, ctxt}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>	// Cgo TSAN (not the Go race detector) intercepts signals and calls the</code></span>
<span class="codeline" id="line-627"><code>	// signal handler at a later time. When the signal handler is called, the</code></span>
<span class="codeline" id="line-628"><code>	// memory may have changed, but the signal context remains old. The</code></span>
<span class="codeline" id="line-629"><code>	// unmatched signal context and memory makes it unsafe to unwind or inspect</code></span>
<span class="codeline" id="line-630"><code>	// the stack. So we ignore delayed non-fatal signals that will cause a stack</code></span>
<span class="codeline" id="line-631"><code>	// inspection (profiling signal and preemption signal).</code></span>
<span class="codeline" id="line-632"><code>	// cgo_yield is only non-nil for TSAN, and is specifically used to trigger</code></span>
<span class="codeline" id="line-633"><code>	// signal delivery. We use that as an indicator of delayed signals.</code></span>
<span class="codeline" id="line-634"><code>	// For delayed signals, the handler is called on the g0 stack (see</code></span>
<span class="codeline" id="line-635"><code>	// adjustSignalStack).</code></span>
<span class="codeline" id="line-636"><code>	delayedSignal := *cgo_yield != nil &amp;&amp; mp != nil &amp;&amp; gsignal.stack == mp.g0.stack</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-639"><code>		// Some platforms (Linux) have per-thread timers, which we use in</code></span>
<span class="codeline" id="line-640"><code>		// combination with the process-wide timer. Avoid double-counting.</code></span>
<span class="codeline" id="line-641"><code>		if !delayedSignal &amp;&amp; validSIGPROF(mp, c) {</code></span>
<span class="codeline" id="line-642"><code>			sigprof(c.sigpc(), c.sigsp(), c.siglr(), gp, mp)</code></span>
<span class="codeline" id="line-643"><code>		}</code></span>
<span class="codeline" id="line-644"><code>		return</code></span>
<span class="codeline" id="line-645"><code>	}</code></span>
<span class="codeline" id="line-646"><code></code></span>
<span class="codeline" id="line-647"><code>	if sig == _SIGTRAP &amp;&amp; testSigtrap != nil &amp;&amp; testSigtrap(info, (*sigctxt)(noescape(unsafe.Pointer(c))), gp) {</code></span>
<span class="codeline" id="line-648"><code>		return</code></span>
<span class="codeline" id="line-649"><code>	}</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>	if sig == _SIGUSR1 &amp;&amp; testSigusr1 != nil &amp;&amp; testSigusr1(gp) {</code></span>
<span class="codeline" id="line-652"><code>		return</code></span>
<span class="codeline" id="line-653"><code>	}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>	if (GOOS == "linux" || GOOS == "android") &amp;&amp; sig == sigPerThreadSyscall {</code></span>
<span class="codeline" id="line-656"><code>		// sigPerThreadSyscall is the same signal used by glibc for</code></span>
<span class="codeline" id="line-657"><code>		// per-thread syscalls on Linux. We use it for the same purpose</code></span>
<span class="codeline" id="line-658"><code>		// in non-cgo binaries. Since this signal is not _SigNotify,</code></span>
<span class="codeline" id="line-659"><code>		// there is nothing more to do once we run the syscall.</code></span>
<span class="codeline" id="line-660"><code>		runPerThreadSyscall()</code></span>
<span class="codeline" id="line-661"><code>		return</code></span>
<span class="codeline" id="line-662"><code>	}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>	if sig == sigPreempt &amp;&amp; debug.asyncpreemptoff == 0 &amp;&amp; !delayedSignal {</code></span>
<span class="codeline" id="line-665"><code>		// Might be a preemption signal.</code></span>
<span class="codeline" id="line-666"><code>		doSigPreempt(gp, c)</code></span>
<span class="codeline" id="line-667"><code>		// Even if this was definitely a preemption signal, it</code></span>
<span class="codeline" id="line-668"><code>		// may have been coalesced with another signal, so we</code></span>
<span class="codeline" id="line-669"><code>		// still let it through to the application.</code></span>
<span class="codeline" id="line-670"><code>	}</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>	flags := int32(_SigThrow)</code></span>
<span class="codeline" id="line-673"><code>	if sig &lt; uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-674"><code>		flags = sigtable[sig].flags</code></span>
<span class="codeline" id="line-675"><code>	}</code></span>
<span class="codeline" id="line-676"><code>	if !c.sigFromUser() &amp;&amp; flags&amp;_SigPanic != 0 &amp;&amp; (gp.throwsplit || gp != mp.curg) {</code></span>
<span class="codeline" id="line-677"><code>		// We can't safely sigpanic because it may grow the</code></span>
<span class="codeline" id="line-678"><code>		// stack. Abort in the signal handler instead.</code></span>
<span class="codeline" id="line-679"><code>		//</code></span>
<span class="codeline" id="line-680"><code>		// Also don't inject a sigpanic if we are not on a</code></span>
<span class="codeline" id="line-681"><code>		// user G stack. Either we're in the runtime, or we're</code></span>
<span class="codeline" id="line-682"><code>		// running C code. Either way we cannot recover.</code></span>
<span class="codeline" id="line-683"><code>		flags = _SigThrow</code></span>
<span class="codeline" id="line-684"><code>	}</code></span>
<span class="codeline" id="line-685"><code>	if isAbortPC(c.sigpc()) {</code></span>
<span class="codeline" id="line-686"><code>		// On many architectures, the abort function just</code></span>
<span class="codeline" id="line-687"><code>		// causes a memory fault. Don't turn that into a panic.</code></span>
<span class="codeline" id="line-688"><code>		flags = _SigThrow</code></span>
<span class="codeline" id="line-689"><code>	}</code></span>
<span class="codeline" id="line-690"><code>	if !c.sigFromUser() &amp;&amp; flags&amp;_SigPanic != 0 {</code></span>
<span class="codeline" id="line-691"><code>		// The signal is going to cause a panic.</code></span>
<span class="codeline" id="line-692"><code>		// Arrange the stack so that it looks like the point</code></span>
<span class="codeline" id="line-693"><code>		// where the signal occurred made a call to the</code></span>
<span class="codeline" id="line-694"><code>		// function sigpanic. Then set the PC to sigpanic.</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>		// Have to pass arguments out of band since</code></span>
<span class="codeline" id="line-697"><code>		// augmenting the stack frame would break</code></span>
<span class="codeline" id="line-698"><code>		// the unwinding code.</code></span>
<span class="codeline" id="line-699"><code>		gp.sig = sig</code></span>
<span class="codeline" id="line-700"><code>		gp.sigcode0 = uintptr(c.sigcode())</code></span>
<span class="codeline" id="line-701"><code>		gp.sigcode1 = c.fault()</code></span>
<span class="codeline" id="line-702"><code>		gp.sigpc = c.sigpc()</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>		c.preparePanic(sig, gp)</code></span>
<span class="codeline" id="line-705"><code>		return</code></span>
<span class="codeline" id="line-706"><code>	}</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>	if c.sigFromUser() || flags&amp;_SigNotify != 0 {</code></span>
<span class="codeline" id="line-709"><code>		if sigsend(sig) {</code></span>
<span class="codeline" id="line-710"><code>			return</code></span>
<span class="codeline" id="line-711"><code>		}</code></span>
<span class="codeline" id="line-712"><code>	}</code></span>
<span class="codeline" id="line-713"><code></code></span>
<span class="codeline" id="line-714"><code>	if c.sigFromUser() &amp;&amp; signal_ignored(sig) {</code></span>
<span class="codeline" id="line-715"><code>		return</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>	if flags&amp;_SigKill != 0 {</code></span>
<span class="codeline" id="line-719"><code>		dieFromSignal(sig)</code></span>
<span class="codeline" id="line-720"><code>	}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>	// _SigThrow means that we should exit now.</code></span>
<span class="codeline" id="line-723"><code>	// If we get here with _SigPanic, it means that the signal</code></span>
<span class="codeline" id="line-724"><code>	// was sent to us by a program (c.sigFromUser() is true);</code></span>
<span class="codeline" id="line-725"><code>	// in that case, if we didn't handle it in sigsend, we exit now.</code></span>
<span class="codeline" id="line-726"><code>	if flags&amp;(_SigThrow|_SigPanic) == 0 {</code></span>
<span class="codeline" id="line-727"><code>		return</code></span>
<span class="codeline" id="line-728"><code>	}</code></span>
<span class="codeline" id="line-729"><code></code></span>
<span class="codeline" id="line-730"><code>	mp.throwing = throwTypeRuntime</code></span>
<span class="codeline" id="line-731"><code>	mp.caughtsig.set(gp)</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>	if crashing.Load() == 0 {</code></span>
<span class="codeline" id="line-734"><code>		startpanic_m()</code></span>
<span class="codeline" id="line-735"><code>	}</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>	gp = fatalsignal(sig, c, gp, mp)</code></span>
<span class="codeline" id="line-738"><code></code></span>
<span class="codeline" id="line-739"><code>	level, _, docrash := gotraceback()</code></span>
<span class="codeline" id="line-740"><code>	if level &gt; 0 {</code></span>
<span class="codeline" id="line-741"><code>		goroutineheader(gp)</code></span>
<span class="codeline" id="line-742"><code>		tracebacktrap(c.sigpc(), c.sigsp(), c.siglr(), gp)</code></span>
<span class="codeline" id="line-743"><code>		if crashing.Load() &gt; 0 &amp;&amp; gp != mp.curg &amp;&amp; mp.curg != nil &amp;&amp; readgstatus(mp.curg)&amp;^_Gscan == _Grunning {</code></span>
<span class="codeline" id="line-744"><code>			// tracebackothers on original m skipped this one; trace it now.</code></span>
<span class="codeline" id="line-745"><code>			goroutineheader(mp.curg)</code></span>
<span class="codeline" id="line-746"><code>			traceback(^uintptr(0), ^uintptr(0), 0, mp.curg)</code></span>
<span class="codeline" id="line-747"><code>		} else if crashing.Load() == 0 {</code></span>
<span class="codeline" id="line-748"><code>			tracebackothers(gp)</code></span>
<span class="codeline" id="line-749"><code>			print("\n")</code></span>
<span class="codeline" id="line-750"><code>		}</code></span>
<span class="codeline" id="line-751"><code>		dumpregs(c)</code></span>
<span class="codeline" id="line-752"><code>	}</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>	if docrash {</code></span>
<span class="codeline" id="line-755"><code>		isCrashThread := false</code></span>
<span class="codeline" id="line-756"><code>		if crashing.CompareAndSwap(0, 1) {</code></span>
<span class="codeline" id="line-757"><code>			isCrashThread = true</code></span>
<span class="codeline" id="line-758"><code>		} else {</code></span>
<span class="codeline" id="line-759"><code>			crashing.Add(1)</code></span>
<span class="codeline" id="line-760"><code>		}</code></span>
<span class="codeline" id="line-761"><code>		if crashing.Load() &lt; mcount()-int32(extraMLength.Load()) {</code></span>
<span class="codeline" id="line-762"><code>			// There are other m's that need to dump their stacks.</code></span>
<span class="codeline" id="line-763"><code>			// Relay SIGQUIT to the next m by sending it to the current process.</code></span>
<span class="codeline" id="line-764"><code>			// All m's that have already received SIGQUIT have signal masks blocking</code></span>
<span class="codeline" id="line-765"><code>			// receipt of any signals, so the SIGQUIT will go to an m that hasn't seen it yet.</code></span>
<span class="codeline" id="line-766"><code>			// The first m will wait until all ms received the SIGQUIT, then crash/exit.</code></span>
<span class="codeline" id="line-767"><code>			// Just in case the relaying gets botched, each m involved in</code></span>
<span class="codeline" id="line-768"><code>			// the relay sleeps for 5 seconds and then does the crash/exit itself.</code></span>
<span class="codeline" id="line-769"><code>			// The faulting m is crashing first so it is the faulting thread in the core dump (see issue #63277):</code></span>
<span class="codeline" id="line-770"><code>			// in expected operation, the first m will wait until the last m has received the SIGQUIT,</code></span>
<span class="codeline" id="line-771"><code>			// and then run crash/exit and the process is gone.</code></span>
<span class="codeline" id="line-772"><code>			// However, if it spends more than 5 seconds to send SIGQUIT to all ms,</code></span>
<span class="codeline" id="line-773"><code>			// any of ms may crash/exit the process after waiting for 5 seconds.</code></span>
<span class="codeline" id="line-774"><code>			print("\n-----\n\n")</code></span>
<span class="codeline" id="line-775"><code>			raiseproc(_SIGQUIT)</code></span>
<span class="codeline" id="line-776"><code>		}</code></span>
<span class="codeline" id="line-777"><code>		if isCrashThread {</code></span>
<span class="codeline" id="line-778"><code>			i := 0</code></span>
<span class="codeline" id="line-779"><code>			for (crashing.Load() &lt; mcount()-int32(extraMLength.Load())) &amp;&amp; i &lt; 10 {</code></span>
<span class="codeline" id="line-780"><code>				i++</code></span>
<span class="codeline" id="line-781"><code>				usleep(500 * 1000)</code></span>
<span class="codeline" id="line-782"><code>			}</code></span>
<span class="codeline" id="line-783"><code>		} else {</code></span>
<span class="codeline" id="line-784"><code>			usleep(5 * 1000 * 1000)</code></span>
<span class="codeline" id="line-785"><code>		}</code></span>
<span class="codeline" id="line-786"><code>		printDebugLog()</code></span>
<span class="codeline" id="line-787"><code>		crash()</code></span>
<span class="codeline" id="line-788"><code>	}</code></span>
<span class="codeline" id="line-789"><code></code></span>
<span class="codeline" id="line-790"><code>	printDebugLog()</code></span>
<span class="codeline" id="line-791"><code></code></span>
<span class="codeline" id="line-792"><code>	exit(2)</code></span>
<span class="codeline" id="line-793"><code>}</code></span>
<span class="codeline" id="line-794"><code></code></span>
<span class="codeline" id="line-795"><code>func fatalsignal(sig uint32, c *sigctxt, gp *g, mp *m) *g {</code></span>
<span class="codeline" id="line-796"><code>	if sig &lt; uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-797"><code>		print(sigtable[sig].name, "\n")</code></span>
<span class="codeline" id="line-798"><code>	} else {</code></span>
<span class="codeline" id="line-799"><code>		print("Signal ", sig, "\n")</code></span>
<span class="codeline" id="line-800"><code>	}</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>	if isSecureMode() {</code></span>
<span class="codeline" id="line-803"><code>		exit(2)</code></span>
<span class="codeline" id="line-804"><code>	}</code></span>
<span class="codeline" id="line-805"><code></code></span>
<span class="codeline" id="line-806"><code>	print("PC=", hex(c.sigpc()), " m=", mp.id, " sigcode=", c.sigcode())</code></span>
<span class="codeline" id="line-807"><code>	if sig == _SIGSEGV || sig == _SIGBUS {</code></span>
<span class="codeline" id="line-808"><code>		print(" addr=", hex(c.fault()))</code></span>
<span class="codeline" id="line-809"><code>	}</code></span>
<span class="codeline" id="line-810"><code>	print("\n")</code></span>
<span class="codeline" id="line-811"><code>	if mp.incgo &amp;&amp; gp == mp.g0 &amp;&amp; mp.curg != nil {</code></span>
<span class="codeline" id="line-812"><code>		print("signal arrived during cgo execution\n")</code></span>
<span class="codeline" id="line-813"><code>		// Switch to curg so that we get a traceback of the Go code</code></span>
<span class="codeline" id="line-814"><code>		// leading up to the cgocall, which switched from curg to g0.</code></span>
<span class="codeline" id="line-815"><code>		gp = mp.curg</code></span>
<span class="codeline" id="line-816"><code>	}</code></span>
<span class="codeline" id="line-817"><code>	if sig == _SIGILL || sig == _SIGFPE {</code></span>
<span class="codeline" id="line-818"><code>		// It would be nice to know how long the instruction is.</code></span>
<span class="codeline" id="line-819"><code>		// Unfortunately, that's complicated to do in general (mostly for x86</code></span>
<span class="codeline" id="line-820"><code>		// and s930x, but other archs have non-standard instruction lengths also).</code></span>
<span class="codeline" id="line-821"><code>		// Opt to print 16 bytes, which covers most instructions.</code></span>
<span class="codeline" id="line-822"><code>		const maxN = 16</code></span>
<span class="codeline" id="line-823"><code>		n := uintptr(maxN)</code></span>
<span class="codeline" id="line-824"><code>		// We have to be careful, though. If we're near the end of</code></span>
<span class="codeline" id="line-825"><code>		// a page and the following page isn't mapped, we could</code></span>
<span class="codeline" id="line-826"><code>		// segfault. So make sure we don't straddle a page (even though</code></span>
<span class="codeline" id="line-827"><code>		// that could lead to printing an incomplete instruction).</code></span>
<span class="codeline" id="line-828"><code>		// We're assuming here we can read at least the page containing the PC.</code></span>
<span class="codeline" id="line-829"><code>		// I suppose it is possible that the page is mapped executable but not readable?</code></span>
<span class="codeline" id="line-830"><code>		pc := c.sigpc()</code></span>
<span class="codeline" id="line-831"><code>		if n &gt; physPageSize-pc%physPageSize {</code></span>
<span class="codeline" id="line-832"><code>			n = physPageSize - pc%physPageSize</code></span>
<span class="codeline" id="line-833"><code>		}</code></span>
<span class="codeline" id="line-834"><code>		print("instruction bytes:")</code></span>
<span class="codeline" id="line-835"><code>		b := (*[maxN]byte)(unsafe.Pointer(pc))</code></span>
<span class="codeline" id="line-836"><code>		for i := uintptr(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-837"><code>			print(" ", hex(b[i]))</code></span>
<span class="codeline" id="line-838"><code>		}</code></span>
<span class="codeline" id="line-839"><code>		println()</code></span>
<span class="codeline" id="line-840"><code>	}</code></span>
<span class="codeline" id="line-841"><code>	print("\n")</code></span>
<span class="codeline" id="line-842"><code>	return gp</code></span>
<span class="codeline" id="line-843"><code>}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>// sigpanic turns a synchronous signal into a run-time panic.</code></span>
<span class="codeline" id="line-846"><code>// If the signal handler sees a synchronous panic, it arranges the</code></span>
<span class="codeline" id="line-847"><code>// stack to look like the function where the signal occurred called</code></span>
<span class="codeline" id="line-848"><code>// sigpanic, sets the signal's PC value to sigpanic, and returns from</code></span>
<span class="codeline" id="line-849"><code>// the signal handler. The effect is that the program will act as</code></span>
<span class="codeline" id="line-850"><code>// though the function that got the signal simply called sigpanic</code></span>
<span class="codeline" id="line-851"><code>// instead.</code></span>
<span class="codeline" id="line-852"><code>//</code></span>
<span class="codeline" id="line-853"><code>// This must NOT be nosplit because the linker doesn't know where</code></span>
<span class="codeline" id="line-854"><code>// sigpanic calls can be injected.</code></span>
<span class="codeline" id="line-855"><code>//</code></span>
<span class="codeline" id="line-856"><code>// The signal handler must not inject a call to sigpanic if</code></span>
<span class="codeline" id="line-857"><code>// getg().throwsplit, since sigpanic may need to grow the stack.</code></span>
<span class="codeline" id="line-858"><code>//</code></span>
<span class="codeline" id="line-859"><code>// This is exported via linkname to assembly in runtime/cgo.</code></span>
<span class="codeline" id="line-860"><code>//</code></span>
<span class="codeline" id="line-861"><code>//go:linkname sigpanic</code></span>
<span class="codeline" id="line-862"><code>func sigpanic() {</code></span>
<span class="codeline" id="line-863"><code>	gp := getg()</code></span>
<span class="codeline" id="line-864"><code>	if !canpanic() {</code></span>
<span class="codeline" id="line-865"><code>		throw("unexpected signal during runtime execution")</code></span>
<span class="codeline" id="line-866"><code>	}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>	switch gp.sig {</code></span>
<span class="codeline" id="line-869"><code>	case _SIGBUS:</code></span>
<span class="codeline" id="line-870"><code>		if gp.sigcode0 == _BUS_ADRERR &amp;&amp; gp.sigcode1 &lt; 0x1000 {</code></span>
<span class="codeline" id="line-871"><code>			panicmem()</code></span>
<span class="codeline" id="line-872"><code>		}</code></span>
<span class="codeline" id="line-873"><code>		// Support runtime/debug.SetPanicOnFault.</code></span>
<span class="codeline" id="line-874"><code>		if gp.paniconfault {</code></span>
<span class="codeline" id="line-875"><code>			panicmemAddr(gp.sigcode1)</code></span>
<span class="codeline" id="line-876"><code>		}</code></span>
<span class="codeline" id="line-877"><code>		print("unexpected fault address ", hex(gp.sigcode1), "\n")</code></span>
<span class="codeline" id="line-878"><code>		throw("fault")</code></span>
<span class="codeline" id="line-879"><code>	case _SIGSEGV:</code></span>
<span class="codeline" id="line-880"><code>		if (gp.sigcode0 == 0 || gp.sigcode0 == _SEGV_MAPERR || gp.sigcode0 == _SEGV_ACCERR) &amp;&amp; gp.sigcode1 &lt; 0x1000 {</code></span>
<span class="codeline" id="line-881"><code>			panicmem()</code></span>
<span class="codeline" id="line-882"><code>		}</code></span>
<span class="codeline" id="line-883"><code>		// Support runtime/debug.SetPanicOnFault.</code></span>
<span class="codeline" id="line-884"><code>		if gp.paniconfault {</code></span>
<span class="codeline" id="line-885"><code>			panicmemAddr(gp.sigcode1)</code></span>
<span class="codeline" id="line-886"><code>		}</code></span>
<span class="codeline" id="line-887"><code>		if inUserArenaChunk(gp.sigcode1) {</code></span>
<span class="codeline" id="line-888"><code>			// We could check that the arena chunk is explicitly set to fault,</code></span>
<span class="codeline" id="line-889"><code>			// but the fact that we faulted on accessing it is enough to prove</code></span>
<span class="codeline" id="line-890"><code>			// that it is.</code></span>
<span class="codeline" id="line-891"><code>			print("accessed data from freed user arena ", hex(gp.sigcode1), "\n")</code></span>
<span class="codeline" id="line-892"><code>		} else {</code></span>
<span class="codeline" id="line-893"><code>			print("unexpected fault address ", hex(gp.sigcode1), "\n")</code></span>
<span class="codeline" id="line-894"><code>		}</code></span>
<span class="codeline" id="line-895"><code>		throw("fault")</code></span>
<span class="codeline" id="line-896"><code>	case _SIGFPE:</code></span>
<span class="codeline" id="line-897"><code>		switch gp.sigcode0 {</code></span>
<span class="codeline" id="line-898"><code>		case _FPE_INTDIV:</code></span>
<span class="codeline" id="line-899"><code>			panicdivide()</code></span>
<span class="codeline" id="line-900"><code>		case _FPE_INTOVF:</code></span>
<span class="codeline" id="line-901"><code>			panicoverflow()</code></span>
<span class="codeline" id="line-902"><code>		}</code></span>
<span class="codeline" id="line-903"><code>		panicfloat()</code></span>
<span class="codeline" id="line-904"><code>	}</code></span>
<span class="codeline" id="line-905"><code></code></span>
<span class="codeline" id="line-906"><code>	if gp.sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-907"><code>		// can't happen: we looked up gp.sig in sigtable to decide to call sigpanic</code></span>
<span class="codeline" id="line-908"><code>		throw("unexpected signal value")</code></span>
<span class="codeline" id="line-909"><code>	}</code></span>
<span class="codeline" id="line-910"><code>	panic(errorString(sigtable[gp.sig].name))</code></span>
<span class="codeline" id="line-911"><code>}</code></span>
<span class="codeline" id="line-912"><code></code></span>
<span class="codeline" id="line-913"><code>// dieFromSignal kills the program with a signal.</code></span>
<span class="codeline" id="line-914"><code>// This provides the expected exit status for the shell.</code></span>
<span class="codeline" id="line-915"><code>// This is only called with fatal signals expected to kill the process.</code></span>
<span class="codeline" id="line-916"><code>//</code></span>
<span class="codeline" id="line-917"><code>//go:nosplit</code></span>
<span class="codeline" id="line-918"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-919"><code>func dieFromSignal(sig uint32) {</code></span>
<span class="codeline" id="line-920"><code>	unblocksig(sig)</code></span>
<span class="codeline" id="line-921"><code>	// Mark the signal as unhandled to ensure it is forwarded.</code></span>
<span class="codeline" id="line-922"><code>	atomic.Store(&amp;handlingSig[sig], 0)</code></span>
<span class="codeline" id="line-923"><code>	raise(sig)</code></span>
<span class="codeline" id="line-924"><code></code></span>
<span class="codeline" id="line-925"><code>	// That should have killed us. On some systems, though, raise</code></span>
<span class="codeline" id="line-926"><code>	// sends the signal to the whole process rather than to just</code></span>
<span class="codeline" id="line-927"><code>	// the current thread, which means that the signal may not yet</code></span>
<span class="codeline" id="line-928"><code>	// have been delivered. Give other threads a chance to run and</code></span>
<span class="codeline" id="line-929"><code>	// pick up the signal.</code></span>
<span class="codeline" id="line-930"><code>	osyield()</code></span>
<span class="codeline" id="line-931"><code>	osyield()</code></span>
<span class="codeline" id="line-932"><code>	osyield()</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>	// If that didn't work, try _SIG_DFL.</code></span>
<span class="codeline" id="line-935"><code>	setsig(sig, _SIG_DFL)</code></span>
<span class="codeline" id="line-936"><code>	raise(sig)</code></span>
<span class="codeline" id="line-937"><code></code></span>
<span class="codeline" id="line-938"><code>	osyield()</code></span>
<span class="codeline" id="line-939"><code>	osyield()</code></span>
<span class="codeline" id="line-940"><code>	osyield()</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>	// If we are still somehow running, just exit with the wrong status.</code></span>
<span class="codeline" id="line-943"><code>	exit(2)</code></span>
<span class="codeline" id="line-944"><code>}</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>// raisebadsignal is called when a signal is received on a non-Go</code></span>
<span class="codeline" id="line-947"><code>// thread, and the Go program does not want to handle it (that is, the</code></span>
<span class="codeline" id="line-948"><code>// program has not called os/signal.Notify for the signal).</code></span>
<span class="codeline" id="line-949"><code>func raisebadsignal(sig uint32, c *sigctxt) {</code></span>
<span class="codeline" id="line-950"><code>	if sig == _SIGPROF {</code></span>
<span class="codeline" id="line-951"><code>		// Ignore profiling signals that arrive on non-Go threads.</code></span>
<span class="codeline" id="line-952"><code>		return</code></span>
<span class="codeline" id="line-953"><code>	}</code></span>
<span class="codeline" id="line-954"><code></code></span>
<span class="codeline" id="line-955"><code>	var handler uintptr</code></span>
<span class="codeline" id="line-956"><code>	if sig &gt;= _NSIG {</code></span>
<span class="codeline" id="line-957"><code>		handler = _SIG_DFL</code></span>
<span class="codeline" id="line-958"><code>	} else {</code></span>
<span class="codeline" id="line-959"><code>		handler = atomic.Loaduintptr(&amp;fwdSig[sig])</code></span>
<span class="codeline" id="line-960"><code>	}</code></span>
<span class="codeline" id="line-961"><code></code></span>
<span class="codeline" id="line-962"><code>	// Reset the signal handler and raise the signal.</code></span>
<span class="codeline" id="line-963"><code>	// We are currently running inside a signal handler, so the</code></span>
<span class="codeline" id="line-964"><code>	// signal is blocked. We need to unblock it before raising the</code></span>
<span class="codeline" id="line-965"><code>	// signal, or the signal we raise will be ignored until we return</code></span>
<span class="codeline" id="line-966"><code>	// from the signal handler. We know that the signal was unblocked</code></span>
<span class="codeline" id="line-967"><code>	// before entering the handler, or else we would not have received</code></span>
<span class="codeline" id="line-968"><code>	// it. That means that we don't have to worry about blocking it</code></span>
<span class="codeline" id="line-969"><code>	// again.</code></span>
<span class="codeline" id="line-970"><code>	unblocksig(sig)</code></span>
<span class="codeline" id="line-971"><code>	setsig(sig, handler)</code></span>
<span class="codeline" id="line-972"><code></code></span>
<span class="codeline" id="line-973"><code>	// If we're linked into a non-Go program we want to try to</code></span>
<span class="codeline" id="line-974"><code>	// avoid modifying the original context in which the signal</code></span>
<span class="codeline" id="line-975"><code>	// was raised. If the handler is the default, we know it</code></span>
<span class="codeline" id="line-976"><code>	// is non-recoverable, so we don't have to worry about</code></span>
<span class="codeline" id="line-977"><code>	// re-installing sighandler. At this point we can just</code></span>
<span class="codeline" id="line-978"><code>	// return and the signal will be re-raised and caught by</code></span>
<span class="codeline" id="line-979"><code>	// the default handler with the correct context.</code></span>
<span class="codeline" id="line-980"><code>	//</code></span>
<span class="codeline" id="line-981"><code>	// On FreeBSD, the libthr sigaction code prevents</code></span>
<span class="codeline" id="line-982"><code>	// this from working so we fall through to raise.</code></span>
<span class="codeline" id="line-983"><code>	if GOOS != "freebsd" &amp;&amp; (isarchive || islibrary) &amp;&amp; handler == _SIG_DFL &amp;&amp; !c.sigFromUser() {</code></span>
<span class="codeline" id="line-984"><code>		return</code></span>
<span class="codeline" id="line-985"><code>	}</code></span>
<span class="codeline" id="line-986"><code></code></span>
<span class="codeline" id="line-987"><code>	raise(sig)</code></span>
<span class="codeline" id="line-988"><code></code></span>
<span class="codeline" id="line-989"><code>	// Give the signal a chance to be delivered.</code></span>
<span class="codeline" id="line-990"><code>	// In almost all real cases the program is about to crash,</code></span>
<span class="codeline" id="line-991"><code>	// so sleeping here is not a waste of time.</code></span>
<span class="codeline" id="line-992"><code>	usleep(1000)</code></span>
<span class="codeline" id="line-993"><code></code></span>
<span class="codeline" id="line-994"><code>	// If the signal didn't cause the program to exit, restore the</code></span>
<span class="codeline" id="line-995"><code>	// Go signal handler and carry on.</code></span>
<span class="codeline" id="line-996"><code>	//</code></span>
<span class="codeline" id="line-997"><code>	// We may receive another instance of the signal before we</code></span>
<span class="codeline" id="line-998"><code>	// restore the Go handler, but that is not so bad: we know</code></span>
<span class="codeline" id="line-999"><code>	// that the Go program has been ignoring the signal.</code></span>
<span class="codeline" id="line-1000"><code>	setsig(sig, abi.FuncPCABIInternal(sighandler))</code></span>
<span class="codeline" id="line-1001"><code>}</code></span>
<span class="codeline" id="line-1002"><code></code></span>
<span class="codeline" id="line-1003"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1004"><code>func crash() {</code></span>
<span class="codeline" id="line-1005"><code>	dieFromSignal(_SIGABRT)</code></span>
<span class="codeline" id="line-1006"><code>}</code></span>
<span class="codeline" id="line-1007"><code></code></span>
<span class="codeline" id="line-1008"><code>// ensureSigM starts one global, sleeping thread to make sure at least one thread</code></span>
<span class="codeline" id="line-1009"><code>// is available to catch signals enabled for os/signal.</code></span>
<span class="codeline" id="line-1010"><code>func ensureSigM() {</code></span>
<span class="codeline" id="line-1011"><code>	if maskUpdatedChan != nil {</code></span>
<span class="codeline" id="line-1012"><code>		return</code></span>
<span class="codeline" id="line-1013"><code>	}</code></span>
<span class="codeline" id="line-1014"><code>	maskUpdatedChan = make(chan struct{})</code></span>
<span class="codeline" id="line-1015"><code>	disableSigChan = make(chan uint32)</code></span>
<span class="codeline" id="line-1016"><code>	enableSigChan = make(chan uint32)</code></span>
<span class="codeline" id="line-1017"><code>	go func() {</code></span>
<span class="codeline" id="line-1018"><code>		// Signal masks are per-thread, so make sure this goroutine stays on one</code></span>
<span class="codeline" id="line-1019"><code>		// thread.</code></span>
<span class="codeline" id="line-1020"><code>		LockOSThread()</code></span>
<span class="codeline" id="line-1021"><code>		defer UnlockOSThread()</code></span>
<span class="codeline" id="line-1022"><code>		// The sigBlocked mask contains the signals not active for os/signal,</code></span>
<span class="codeline" id="line-1023"><code>		// initially all signals except the essential. When signal.Notify()/Stop is called,</code></span>
<span class="codeline" id="line-1024"><code>		// sigenable/sigdisable in turn notify this thread to update its signal</code></span>
<span class="codeline" id="line-1025"><code>		// mask accordingly.</code></span>
<span class="codeline" id="line-1026"><code>		sigBlocked := sigset_all</code></span>
<span class="codeline" id="line-1027"><code>		for i := range sigtable {</code></span>
<span class="codeline" id="line-1028"><code>			if !blockableSig(uint32(i)) {</code></span>
<span class="codeline" id="line-1029"><code>				sigdelset(&amp;sigBlocked, i)</code></span>
<span class="codeline" id="line-1030"><code>			}</code></span>
<span class="codeline" id="line-1031"><code>		}</code></span>
<span class="codeline" id="line-1032"><code>		sigprocmask(_SIG_SETMASK, &amp;sigBlocked, nil)</code></span>
<span class="codeline" id="line-1033"><code>		for {</code></span>
<span class="codeline" id="line-1034"><code>			select {</code></span>
<span class="codeline" id="line-1035"><code>			case sig := &lt;-enableSigChan:</code></span>
<span class="codeline" id="line-1036"><code>				if sig &gt; 0 {</code></span>
<span class="codeline" id="line-1037"><code>					sigdelset(&amp;sigBlocked, int(sig))</code></span>
<span class="codeline" id="line-1038"><code>				}</code></span>
<span class="codeline" id="line-1039"><code>			case sig := &lt;-disableSigChan:</code></span>
<span class="codeline" id="line-1040"><code>				if sig &gt; 0 &amp;&amp; blockableSig(sig) {</code></span>
<span class="codeline" id="line-1041"><code>					sigaddset(&amp;sigBlocked, int(sig))</code></span>
<span class="codeline" id="line-1042"><code>				}</code></span>
<span class="codeline" id="line-1043"><code>			}</code></span>
<span class="codeline" id="line-1044"><code>			sigprocmask(_SIG_SETMASK, &amp;sigBlocked, nil)</code></span>
<span class="codeline" id="line-1045"><code>			maskUpdatedChan &lt;- struct{}{}</code></span>
<span class="codeline" id="line-1046"><code>		}</code></span>
<span class="codeline" id="line-1047"><code>	}()</code></span>
<span class="codeline" id="line-1048"><code>}</code></span>
<span class="codeline" id="line-1049"><code></code></span>
<span class="codeline" id="line-1050"><code>// This is called when we receive a signal when there is no signal stack.</code></span>
<span class="codeline" id="line-1051"><code>// This can only happen if non-Go code calls sigaltstack to disable the</code></span>
<span class="codeline" id="line-1052"><code>// signal stack.</code></span>
<span class="codeline" id="line-1053"><code>func noSignalStack(sig uint32) {</code></span>
<span class="codeline" id="line-1054"><code>	println("signal", sig, "received on thread with no signal stack")</code></span>
<span class="codeline" id="line-1055"><code>	throw("non-Go code disabled sigaltstack")</code></span>
<span class="codeline" id="line-1056"><code>}</code></span>
<span class="codeline" id="line-1057"><code></code></span>
<span class="codeline" id="line-1058"><code>// This is called if we receive a signal when there is a signal stack</code></span>
<span class="codeline" id="line-1059"><code>// but we are not on it. This can only happen if non-Go code called</code></span>
<span class="codeline" id="line-1060"><code>// sigaction without setting the SS_ONSTACK flag.</code></span>
<span class="codeline" id="line-1061"><code>func sigNotOnStack(sig uint32, sp uintptr, mp *m) {</code></span>
<span class="codeline" id="line-1062"><code>	println("signal", sig, "received but handler not on signal stack")</code></span>
<span class="codeline" id="line-1063"><code>	print("mp.gsignal stack [", hex(mp.gsignal.stack.lo), " ", hex(mp.gsignal.stack.hi), "], ")</code></span>
<span class="codeline" id="line-1064"><code>	print("mp.g0 stack [", hex(mp.g0.stack.lo), " ", hex(mp.g0.stack.hi), "], sp=", hex(sp), "\n")</code></span>
<span class="codeline" id="line-1065"><code>	throw("non-Go code set up signal handler without SA_ONSTACK flag")</code></span>
<span class="codeline" id="line-1066"><code>}</code></span>
<span class="codeline" id="line-1067"><code></code></span>
<span class="codeline" id="line-1068"><code>// signalDuringFork is called if we receive a signal while doing a fork.</code></span>
<span class="codeline" id="line-1069"><code>// We do not want signals at that time, as a signal sent to the process</code></span>
<span class="codeline" id="line-1070"><code>// group may be delivered to the child process, causing confusion.</code></span>
<span class="codeline" id="line-1071"><code>// This should never be called, because we block signals across the fork;</code></span>
<span class="codeline" id="line-1072"><code>// this function is just a safety check. See issue 18600 for background.</code></span>
<span class="codeline" id="line-1073"><code>func signalDuringFork(sig uint32) {</code></span>
<span class="codeline" id="line-1074"><code>	println("signal", sig, "received during fork")</code></span>
<span class="codeline" id="line-1075"><code>	throw("signal received during fork")</code></span>
<span class="codeline" id="line-1076"><code>}</code></span>
<span class="codeline" id="line-1077"><code></code></span>
<span class="codeline" id="line-1078"><code>// This runs on a foreign stack, without an m or a g. No stack split.</code></span>
<span class="codeline" id="line-1079"><code>//</code></span>
<span class="codeline" id="line-1080"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1081"><code>//go:norace</code></span>
<span class="codeline" id="line-1082"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1083"><code>func badsignal(sig uintptr, c *sigctxt) {</code></span>
<span class="codeline" id="line-1084"><code>	if !iscgo &amp;&amp; !cgoHasExtraM {</code></span>
<span class="codeline" id="line-1085"><code>		// There is no extra M. needm will not be able to grab</code></span>
<span class="codeline" id="line-1086"><code>		// an M. Instead of hanging, just crash.</code></span>
<span class="codeline" id="line-1087"><code>		// Cannot call split-stack function as there is no G.</code></span>
<span class="codeline" id="line-1088"><code>		writeErrStr("fatal: bad g in signal handler\n")</code></span>
<span class="codeline" id="line-1089"><code>		exit(2)</code></span>
<span class="codeline" id="line-1090"><code>		*(*uintptr)(unsafe.Pointer(uintptr(123))) = 2</code></span>
<span class="codeline" id="line-1091"><code>	}</code></span>
<span class="codeline" id="line-1092"><code>	needm(true)</code></span>
<span class="codeline" id="line-1093"><code>	if !sigsend(uint32(sig)) {</code></span>
<span class="codeline" id="line-1094"><code>		// A foreign thread received the signal sig, and the</code></span>
<span class="codeline" id="line-1095"><code>		// Go code does not want to handle it.</code></span>
<span class="codeline" id="line-1096"><code>		raisebadsignal(uint32(sig), c)</code></span>
<span class="codeline" id="line-1097"><code>	}</code></span>
<span class="codeline" id="line-1098"><code>	dropm()</code></span>
<span class="codeline" id="line-1099"><code>}</code></span>
<span class="codeline" id="line-1100"><code></code></span>
<span class="codeline" id="line-1101"><code>//go:noescape</code></span>
<span class="codeline" id="line-1102"><code>func sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)</code></span>
<span class="codeline" id="line-1103"><code></code></span>
<span class="codeline" id="line-1104"><code>// Determines if the signal should be handled by Go and if not, forwards the</code></span>
<span class="codeline" id="line-1105"><code>// signal to the handler that was installed before Go's. Returns whether the</code></span>
<span class="codeline" id="line-1106"><code>// signal was forwarded.</code></span>
<span class="codeline" id="line-1107"><code>// This is called by the signal handler, and the world may be stopped.</code></span>
<span class="codeline" id="line-1108"><code>//</code></span>
<span class="codeline" id="line-1109"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1110"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1111"><code>func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-1112"><code>	if sig &gt;= uint32(len(sigtable)) {</code></span>
<span class="codeline" id="line-1113"><code>		return false</code></span>
<span class="codeline" id="line-1114"><code>	}</code></span>
<span class="codeline" id="line-1115"><code>	fwdFn := atomic.Loaduintptr(&amp;fwdSig[sig])</code></span>
<span class="codeline" id="line-1116"><code>	flags := sigtable[sig].flags</code></span>
<span class="codeline" id="line-1117"><code></code></span>
<span class="codeline" id="line-1118"><code>	// If we aren't handling the signal, forward it.</code></span>
<span class="codeline" id="line-1119"><code>	if atomic.Load(&amp;handlingSig[sig]) == 0 || !signalsOK {</code></span>
<span class="codeline" id="line-1120"><code>		// If the signal is ignored, doing nothing is the same as forwarding.</code></span>
<span class="codeline" id="line-1121"><code>		if fwdFn == _SIG_IGN || (fwdFn == _SIG_DFL &amp;&amp; flags&amp;_SigIgn != 0) {</code></span>
<span class="codeline" id="line-1122"><code>			return true</code></span>
<span class="codeline" id="line-1123"><code>		}</code></span>
<span class="codeline" id="line-1124"><code>		// We are not handling the signal and there is no other handler to forward to.</code></span>
<span class="codeline" id="line-1125"><code>		// Crash with the default behavior.</code></span>
<span class="codeline" id="line-1126"><code>		if fwdFn == _SIG_DFL {</code></span>
<span class="codeline" id="line-1127"><code>			setsig(sig, _SIG_DFL)</code></span>
<span class="codeline" id="line-1128"><code>			dieFromSignal(sig)</code></span>
<span class="codeline" id="line-1129"><code>			return false</code></span>
<span class="codeline" id="line-1130"><code>		}</code></span>
<span class="codeline" id="line-1131"><code></code></span>
<span class="codeline" id="line-1132"><code>		sigfwd(fwdFn, sig, info, ctx)</code></span>
<span class="codeline" id="line-1133"><code>		return true</code></span>
<span class="codeline" id="line-1134"><code>	}</code></span>
<span class="codeline" id="line-1135"><code></code></span>
<span class="codeline" id="line-1136"><code>	// This function and its caller sigtrampgo assumes SIGPIPE is delivered on the</code></span>
<span class="codeline" id="line-1137"><code>	// originating thread. This property does not hold on macOS (golang.org/issue/33384),</code></span>
<span class="codeline" id="line-1138"><code>	// so we have no choice but to ignore SIGPIPE.</code></span>
<span class="codeline" id="line-1139"><code>	if (GOOS == "darwin" || GOOS == "ios") &amp;&amp; sig == _SIGPIPE {</code></span>
<span class="codeline" id="line-1140"><code>		return true</code></span>
<span class="codeline" id="line-1141"><code>	}</code></span>
<span class="codeline" id="line-1142"><code></code></span>
<span class="codeline" id="line-1143"><code>	// If there is no handler to forward to, no need to forward.</code></span>
<span class="codeline" id="line-1144"><code>	if fwdFn == _SIG_DFL {</code></span>
<span class="codeline" id="line-1145"><code>		return false</code></span>
<span class="codeline" id="line-1146"><code>	}</code></span>
<span class="codeline" id="line-1147"><code></code></span>
<span class="codeline" id="line-1148"><code>	c := &amp;sigctxt{info, ctx}</code></span>
<span class="codeline" id="line-1149"><code>	// Only forward synchronous signals and SIGPIPE.</code></span>
<span class="codeline" id="line-1150"><code>	// Unfortunately, user generated SIGPIPEs will also be forwarded, because si_code</code></span>
<span class="codeline" id="line-1151"><code>	// is set to _SI_USER even for a SIGPIPE raised from a write to a closed socket</code></span>
<span class="codeline" id="line-1152"><code>	// or pipe.</code></span>
<span class="codeline" id="line-1153"><code>	if (c.sigFromUser() || flags&amp;_SigPanic == 0) &amp;&amp; sig != _SIGPIPE {</code></span>
<span class="codeline" id="line-1154"><code>		return false</code></span>
<span class="codeline" id="line-1155"><code>	}</code></span>
<span class="codeline" id="line-1156"><code>	// Determine if the signal occurred inside Go code. We test that:</code></span>
<span class="codeline" id="line-1157"><code>	//   (1) we weren't in VDSO page,</code></span>
<span class="codeline" id="line-1158"><code>	//   (2) we were in a goroutine (i.e., m.curg != nil), and</code></span>
<span class="codeline" id="line-1159"><code>	//   (3) we weren't in CGO.</code></span>
<span class="codeline" id="line-1160"><code>	//   (4) we weren't in dropped extra m.</code></span>
<span class="codeline" id="line-1161"><code>	gp := sigFetchG(c)</code></span>
<span class="codeline" id="line-1162"><code>	if gp != nil &amp;&amp; gp.m != nil &amp;&amp; gp.m.curg != nil &amp;&amp; !gp.m.isExtraInC &amp;&amp; !gp.m.incgo {</code></span>
<span class="codeline" id="line-1163"><code>		return false</code></span>
<span class="codeline" id="line-1164"><code>	}</code></span>
<span class="codeline" id="line-1165"><code></code></span>
<span class="codeline" id="line-1166"><code>	// Signal not handled by Go, forward it.</code></span>
<span class="codeline" id="line-1167"><code>	if fwdFn != _SIG_IGN {</code></span>
<span class="codeline" id="line-1168"><code>		sigfwd(fwdFn, sig, info, ctx)</code></span>
<span class="codeline" id="line-1169"><code>	}</code></span>
<span class="codeline" id="line-1170"><code></code></span>
<span class="codeline" id="line-1171"><code>	return true</code></span>
<span class="codeline" id="line-1172"><code>}</code></span>
<span class="codeline" id="line-1173"><code></code></span>
<span class="codeline" id="line-1174"><code>// sigsave saves the current thread's signal mask into *p.</code></span>
<span class="codeline" id="line-1175"><code>// This is used to preserve the non-Go signal mask when a non-Go</code></span>
<span class="codeline" id="line-1176"><code>// thread calls a Go function.</code></span>
<span class="codeline" id="line-1177"><code>// This is nosplit and nowritebarrierrec because it is called by needm</code></span>
<span class="codeline" id="line-1178"><code>// which may be called on a non-Go thread with no g available.</code></span>
<span class="codeline" id="line-1179"><code>//</code></span>
<span class="codeline" id="line-1180"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1181"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1182"><code>func sigsave(p *sigset) {</code></span>
<span class="codeline" id="line-1183"><code>	sigprocmask(_SIG_SETMASK, nil, p)</code></span>
<span class="codeline" id="line-1184"><code>}</code></span>
<span class="codeline" id="line-1185"><code></code></span>
<span class="codeline" id="line-1186"><code>// msigrestore sets the current thread's signal mask to sigmask.</code></span>
<span class="codeline" id="line-1187"><code>// This is used to restore the non-Go signal mask when a non-Go thread</code></span>
<span class="codeline" id="line-1188"><code>// calls a Go function.</code></span>
<span class="codeline" id="line-1189"><code>// This is nosplit and nowritebarrierrec because it is called by dropm</code></span>
<span class="codeline" id="line-1190"><code>// after g has been cleared.</code></span>
<span class="codeline" id="line-1191"><code>//</code></span>
<span class="codeline" id="line-1192"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1193"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1194"><code>func msigrestore(sigmask sigset) {</code></span>
<span class="codeline" id="line-1195"><code>	sigprocmask(_SIG_SETMASK, &amp;sigmask, nil)</code></span>
<span class="codeline" id="line-1196"><code>}</code></span>
<span class="codeline" id="line-1197"><code></code></span>
<span class="codeline" id="line-1198"><code>// sigsetAllExiting is used by sigblock(true) when a thread is</code></span>
<span class="codeline" id="line-1199"><code>// exiting.</code></span>
<span class="codeline" id="line-1200"><code>var sigsetAllExiting = func() sigset {</code></span>
<span class="codeline" id="line-1201"><code>	res := sigset_all</code></span>
<span class="codeline" id="line-1202"><code></code></span>
<span class="codeline" id="line-1203"><code>	// Apply GOOS-specific overrides here, rather than in osinit,</code></span>
<span class="codeline" id="line-1204"><code>	// because osinit may be called before sigsetAllExiting is</code></span>
<span class="codeline" id="line-1205"><code>	// initialized (#51913).</code></span>
<span class="codeline" id="line-1206"><code>	if GOOS == "linux" &amp;&amp; iscgo {</code></span>
<span class="codeline" id="line-1207"><code>		// #42494 glibc and musl reserve some signals for</code></span>
<span class="codeline" id="line-1208"><code>		// internal use and require they not be blocked by</code></span>
<span class="codeline" id="line-1209"><code>		// the rest of a normal C runtime. When the go runtime</code></span>
<span class="codeline" id="line-1210"><code>		// blocks...unblocks signals, temporarily, the blocked</code></span>
<span class="codeline" id="line-1211"><code>		// interval of time is generally very short. As such,</code></span>
<span class="codeline" id="line-1212"><code>		// these expectations of *libc code are mostly met by</code></span>
<span class="codeline" id="line-1213"><code>		// the combined go+cgo system of threads. However,</code></span>
<span class="codeline" id="line-1214"><code>		// when go causes a thread to exit, via a return from</code></span>
<span class="codeline" id="line-1215"><code>		// mstart(), the combined runtime can deadlock if</code></span>
<span class="codeline" id="line-1216"><code>		// these signals are blocked. Thus, don't block these</code></span>
<span class="codeline" id="line-1217"><code>		// signals when exiting threads.</code></span>
<span class="codeline" id="line-1218"><code>		// - glibc: SIGCANCEL (32), SIGSETXID (33)</code></span>
<span class="codeline" id="line-1219"><code>		// - musl: SIGTIMER (32), SIGCANCEL (33), SIGSYNCCALL (34)</code></span>
<span class="codeline" id="line-1220"><code>		sigdelset(&amp;res, 32)</code></span>
<span class="codeline" id="line-1221"><code>		sigdelset(&amp;res, 33)</code></span>
<span class="codeline" id="line-1222"><code>		sigdelset(&amp;res, 34)</code></span>
<span class="codeline" id="line-1223"><code>	}</code></span>
<span class="codeline" id="line-1224"><code></code></span>
<span class="codeline" id="line-1225"><code>	return res</code></span>
<span class="codeline" id="line-1226"><code>}()</code></span>
<span class="codeline" id="line-1227"><code></code></span>
<span class="codeline" id="line-1228"><code>// sigblock blocks signals in the current thread's signal mask.</code></span>
<span class="codeline" id="line-1229"><code>// This is used to block signals while setting up and tearing down g</code></span>
<span class="codeline" id="line-1230"><code>// when a non-Go thread calls a Go function. When a thread is exiting</code></span>
<span class="codeline" id="line-1231"><code>// we use the sigsetAllExiting value, otherwise the OS specific</code></span>
<span class="codeline" id="line-1232"><code>// definition of sigset_all is used.</code></span>
<span class="codeline" id="line-1233"><code>// This is nosplit and nowritebarrierrec because it is called by needm</code></span>
<span class="codeline" id="line-1234"><code>// which may be called on a non-Go thread with no g available.</code></span>
<span class="codeline" id="line-1235"><code>//</code></span>
<span class="codeline" id="line-1236"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1237"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1238"><code>func sigblock(exiting bool) {</code></span>
<span class="codeline" id="line-1239"><code>	if exiting {</code></span>
<span class="codeline" id="line-1240"><code>		sigprocmask(_SIG_SETMASK, &amp;sigsetAllExiting, nil)</code></span>
<span class="codeline" id="line-1241"><code>		return</code></span>
<span class="codeline" id="line-1242"><code>	}</code></span>
<span class="codeline" id="line-1243"><code>	sigprocmask(_SIG_SETMASK, &amp;sigset_all, nil)</code></span>
<span class="codeline" id="line-1244"><code>}</code></span>
<span class="codeline" id="line-1245"><code></code></span>
<span class="codeline" id="line-1246"><code>// unblocksig removes sig from the current thread's signal mask.</code></span>
<span class="codeline" id="line-1247"><code>// This is nosplit and nowritebarrierrec because it is called from</code></span>
<span class="codeline" id="line-1248"><code>// dieFromSignal, which can be called by sigfwdgo while running in the</code></span>
<span class="codeline" id="line-1249"><code>// signal handler, on the signal stack, with no g available.</code></span>
<span class="codeline" id="line-1250"><code>//</code></span>
<span class="codeline" id="line-1251"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1252"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1253"><code>func unblocksig(sig uint32) {</code></span>
<span class="codeline" id="line-1254"><code>	var set sigset</code></span>
<span class="codeline" id="line-1255"><code>	sigaddset(&amp;set, int(sig))</code></span>
<span class="codeline" id="line-1256"><code>	sigprocmask(_SIG_UNBLOCK, &amp;set, nil)</code></span>
<span class="codeline" id="line-1257"><code>}</code></span>
<span class="codeline" id="line-1258"><code></code></span>
<span class="codeline" id="line-1259"><code>// minitSignals is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1260"><code>// thread's alternate signal stack and signal mask.</code></span>
<span class="codeline" id="line-1261"><code>func minitSignals() {</code></span>
<span class="codeline" id="line-1262"><code>	minitSignalStack()</code></span>
<span class="codeline" id="line-1263"><code>	minitSignalMask()</code></span>
<span class="codeline" id="line-1264"><code>}</code></span>
<span class="codeline" id="line-1265"><code></code></span>
<span class="codeline" id="line-1266"><code>// minitSignalStack is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1267"><code>// alternate signal stack. If the alternate signal stack is not set</code></span>
<span class="codeline" id="line-1268"><code>// for the thread (the normal case) then set the alternate signal</code></span>
<span class="codeline" id="line-1269"><code>// stack to the gsignal stack. If the alternate signal stack is set</code></span>
<span class="codeline" id="line-1270"><code>// for the thread (the case when a non-Go thread sets the alternate</code></span>
<span class="codeline" id="line-1271"><code>// signal stack and then calls a Go function) then set the gsignal</code></span>
<span class="codeline" id="line-1272"><code>// stack to the alternate signal stack. We also set the alternate</code></span>
<span class="codeline" id="line-1273"><code>// signal stack to the gsignal stack if cgo is not used (regardless</code></span>
<span class="codeline" id="line-1274"><code>// of whether it is already set). Record which choice was made in</code></span>
<span class="codeline" id="line-1275"><code>// newSigstack, so that it can be undone in unminit.</code></span>
<span class="codeline" id="line-1276"><code>func minitSignalStack() {</code></span>
<span class="codeline" id="line-1277"><code>	mp := getg().m</code></span>
<span class="codeline" id="line-1278"><code>	var st stackt</code></span>
<span class="codeline" id="line-1279"><code>	sigaltstack(nil, &amp;st)</code></span>
<span class="codeline" id="line-1280"><code>	if st.ss_flags&amp;_SS_DISABLE != 0 || !iscgo {</code></span>
<span class="codeline" id="line-1281"><code>		signalstack(&amp;mp.gsignal.stack)</code></span>
<span class="codeline" id="line-1282"><code>		mp.newSigstack = true</code></span>
<span class="codeline" id="line-1283"><code>	} else {</code></span>
<span class="codeline" id="line-1284"><code>		setGsignalStack(&amp;st, &amp;mp.goSigStack)</code></span>
<span class="codeline" id="line-1285"><code>		mp.newSigstack = false</code></span>
<span class="codeline" id="line-1286"><code>	}</code></span>
<span class="codeline" id="line-1287"><code>}</code></span>
<span class="codeline" id="line-1288"><code></code></span>
<span class="codeline" id="line-1289"><code>// minitSignalMask is called when initializing a new m to set the</code></span>
<span class="codeline" id="line-1290"><code>// thread's signal mask. When this is called all signals have been</code></span>
<span class="codeline" id="line-1291"><code>// blocked for the thread.  This starts with m.sigmask, which was set</code></span>
<span class="codeline" id="line-1292"><code>// either from initSigmask for a newly created thread or by calling</code></span>
<span class="codeline" id="line-1293"><code>// sigsave if this is a non-Go thread calling a Go function. It</code></span>
<span class="codeline" id="line-1294"><code>// removes all essential signals from the mask, thus causing those</code></span>
<span class="codeline" id="line-1295"><code>// signals to not be blocked. Then it sets the thread's signal mask.</code></span>
<span class="codeline" id="line-1296"><code>// After this is called the thread can receive signals.</code></span>
<span class="codeline" id="line-1297"><code>func minitSignalMask() {</code></span>
<span class="codeline" id="line-1298"><code>	nmask := getg().m.sigmask</code></span>
<span class="codeline" id="line-1299"><code>	for i := range sigtable {</code></span>
<span class="codeline" id="line-1300"><code>		if !blockableSig(uint32(i)) {</code></span>
<span class="codeline" id="line-1301"><code>			sigdelset(&amp;nmask, i)</code></span>
<span class="codeline" id="line-1302"><code>		}</code></span>
<span class="codeline" id="line-1303"><code>	}</code></span>
<span class="codeline" id="line-1304"><code>	sigprocmask(_SIG_SETMASK, &amp;nmask, nil)</code></span>
<span class="codeline" id="line-1305"><code>}</code></span>
<span class="codeline" id="line-1306"><code></code></span>
<span class="codeline" id="line-1307"><code>// unminitSignals is called from dropm, via unminit, to undo the</code></span>
<span class="codeline" id="line-1308"><code>// effect of calling minit on a non-Go thread.</code></span>
<span class="codeline" id="line-1309"><code>//</code></span>
<span class="codeline" id="line-1310"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1311"><code>func unminitSignals() {</code></span>
<span class="codeline" id="line-1312"><code>	if getg().m.newSigstack {</code></span>
<span class="codeline" id="line-1313"><code>		st := stackt{ss_flags: _SS_DISABLE}</code></span>
<span class="codeline" id="line-1314"><code>		sigaltstack(&amp;st, nil)</code></span>
<span class="codeline" id="line-1315"><code>	} else {</code></span>
<span class="codeline" id="line-1316"><code>		// We got the signal stack from someone else. Restore</code></span>
<span class="codeline" id="line-1317"><code>		// the Go-allocated stack in case this M gets reused</code></span>
<span class="codeline" id="line-1318"><code>		// for another thread (e.g., it's an extram). Also, on</code></span>
<span class="codeline" id="line-1319"><code>		// Android, libc allocates a signal stack for all</code></span>
<span class="codeline" id="line-1320"><code>		// threads, so it's important to restore the Go stack</code></span>
<span class="codeline" id="line-1321"><code>		// even on Go-created threads so we can free it.</code></span>
<span class="codeline" id="line-1322"><code>		restoreGsignalStack(&amp;getg().m.goSigStack)</code></span>
<span class="codeline" id="line-1323"><code>	}</code></span>
<span class="codeline" id="line-1324"><code>}</code></span>
<span class="codeline" id="line-1325"><code></code></span>
<span class="codeline" id="line-1326"><code>// blockableSig reports whether sig may be blocked by the signal mask.</code></span>
<span class="codeline" id="line-1327"><code>// We never want to block the signals marked _SigUnblock;</code></span>
<span class="codeline" id="line-1328"><code>// these are the synchronous signals that turn into a Go panic.</code></span>
<span class="codeline" id="line-1329"><code>// We never want to block the preemption signal if it is being used.</code></span>
<span class="codeline" id="line-1330"><code>// In a Go program--not a c-archive/c-shared--we never want to block</code></span>
<span class="codeline" id="line-1331"><code>// the signals marked _SigKill or _SigThrow, as otherwise it's possible</code></span>
<span class="codeline" id="line-1332"><code>// for all running threads to block them and delay their delivery until</code></span>
<span class="codeline" id="line-1333"><code>// we start a new thread. When linked into a C program we let the C code</code></span>
<span class="codeline" id="line-1334"><code>// decide on the disposition of those signals.</code></span>
<span class="codeline" id="line-1335"><code>func blockableSig(sig uint32) bool {</code></span>
<span class="codeline" id="line-1336"><code>	flags := sigtable[sig].flags</code></span>
<span class="codeline" id="line-1337"><code>	if flags&amp;_SigUnblock != 0 {</code></span>
<span class="codeline" id="line-1338"><code>		return false</code></span>
<span class="codeline" id="line-1339"><code>	}</code></span>
<span class="codeline" id="line-1340"><code>	if sig == sigPreempt &amp;&amp; preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {</code></span>
<span class="codeline" id="line-1341"><code>		return false</code></span>
<span class="codeline" id="line-1342"><code>	}</code></span>
<span class="codeline" id="line-1343"><code>	if isarchive || islibrary {</code></span>
<span class="codeline" id="line-1344"><code>		return true</code></span>
<span class="codeline" id="line-1345"><code>	}</code></span>
<span class="codeline" id="line-1346"><code>	return flags&amp;(_SigKill|_SigThrow) == 0</code></span>
<span class="codeline" id="line-1347"><code>}</code></span>
<span class="codeline" id="line-1348"><code></code></span>
<span class="codeline" id="line-1349"><code>// gsignalStack saves the fields of the gsignal stack changed by</code></span>
<span class="codeline" id="line-1350"><code>// setGsignalStack.</code></span>
<span class="codeline" id="line-1351"><code>type gsignalStack struct {</code></span>
<span class="codeline" id="line-1352"><code>	stack       stack</code></span>
<span class="codeline" id="line-1353"><code>	stackguard0 uintptr</code></span>
<span class="codeline" id="line-1354"><code>	stackguard1 uintptr</code></span>
<span class="codeline" id="line-1355"><code>	stktopsp    uintptr</code></span>
<span class="codeline" id="line-1356"><code>}</code></span>
<span class="codeline" id="line-1357"><code></code></span>
<span class="codeline" id="line-1358"><code>// setGsignalStack sets the gsignal stack of the current m to an</code></span>
<span class="codeline" id="line-1359"><code>// alternate signal stack returned from the sigaltstack system call.</code></span>
<span class="codeline" id="line-1360"><code>// It saves the old values in *old for use by restoreGsignalStack.</code></span>
<span class="codeline" id="line-1361"><code>// This is used when handling a signal if non-Go code has set the</code></span>
<span class="codeline" id="line-1362"><code>// alternate signal stack.</code></span>
<span class="codeline" id="line-1363"><code>//</code></span>
<span class="codeline" id="line-1364"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1365"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1366"><code>func setGsignalStack(st *stackt, old *gsignalStack) {</code></span>
<span class="codeline" id="line-1367"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1368"><code>	if old != nil {</code></span>
<span class="codeline" id="line-1369"><code>		old.stack = gp.m.gsignal.stack</code></span>
<span class="codeline" id="line-1370"><code>		old.stackguard0 = gp.m.gsignal.stackguard0</code></span>
<span class="codeline" id="line-1371"><code>		old.stackguard1 = gp.m.gsignal.stackguard1</code></span>
<span class="codeline" id="line-1372"><code>		old.stktopsp = gp.m.gsignal.stktopsp</code></span>
<span class="codeline" id="line-1373"><code>	}</code></span>
<span class="codeline" id="line-1374"><code>	stsp := uintptr(unsafe.Pointer(st.ss_sp))</code></span>
<span class="codeline" id="line-1375"><code>	gp.m.gsignal.stack.lo = stsp</code></span>
<span class="codeline" id="line-1376"><code>	gp.m.gsignal.stack.hi = stsp + st.ss_size</code></span>
<span class="codeline" id="line-1377"><code>	gp.m.gsignal.stackguard0 = stsp + stackGuard</code></span>
<span class="codeline" id="line-1378"><code>	gp.m.gsignal.stackguard1 = stsp + stackGuard</code></span>
<span class="codeline" id="line-1379"><code>}</code></span>
<span class="codeline" id="line-1380"><code></code></span>
<span class="codeline" id="line-1381"><code>// restoreGsignalStack restores the gsignal stack to the value it had</code></span>
<span class="codeline" id="line-1382"><code>// before entering the signal handler.</code></span>
<span class="codeline" id="line-1383"><code>//</code></span>
<span class="codeline" id="line-1384"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1385"><code>//go:nowritebarrierrec</code></span>
<span class="codeline" id="line-1386"><code>func restoreGsignalStack(st *gsignalStack) {</code></span>
<span class="codeline" id="line-1387"><code>	gp := getg().m.gsignal</code></span>
<span class="codeline" id="line-1388"><code>	gp.stack = st.stack</code></span>
<span class="codeline" id="line-1389"><code>	gp.stackguard0 = st.stackguard0</code></span>
<span class="codeline" id="line-1390"><code>	gp.stackguard1 = st.stackguard1</code></span>
<span class="codeline" id="line-1391"><code>	gp.stktopsp = st.stktopsp</code></span>
<span class="codeline" id="line-1392"><code>}</code></span>
<span class="codeline" id="line-1393"><code></code></span>
<span class="codeline" id="line-1394"><code>// signalstack sets the current thread's alternate signal stack to s.</code></span>
<span class="codeline" id="line-1395"><code>//</code></span>
<span class="codeline" id="line-1396"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1397"><code>func signalstack(s *stack) {</code></span>
<span class="codeline" id="line-1398"><code>	st := stackt{ss_size: s.hi - s.lo}</code></span>
<span class="codeline" id="line-1399"><code>	setSignalstackSP(&amp;st, s.lo)</code></span>
<span class="codeline" id="line-1400"><code>	sigaltstack(&amp;st, nil)</code></span>
<span class="codeline" id="line-1401"><code>}</code></span>
<span class="codeline" id="line-1402"><code></code></span>
<span class="codeline" id="line-1403"><code>// setsigsegv is used on darwin/arm64 to fake a segmentation fault.</code></span>
<span class="codeline" id="line-1404"><code>//</code></span>
<span class="codeline" id="line-1405"><code>// This is exported via linkname to assembly in runtime/cgo.</code></span>
<span class="codeline" id="line-1406"><code>//</code></span>
<span class="codeline" id="line-1407"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1408"><code>//go:linkname setsigsegv</code></span>
<span class="codeline" id="line-1409"><code>func setsigsegv(pc uintptr) {</code></span>
<span class="codeline" id="line-1410"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1411"><code>	gp.sig = _SIGSEGV</code></span>
<span class="codeline" id="line-1412"><code>	gp.sigpc = pc</code></span>
<span class="codeline" id="line-1413"><code>	gp.sigcode0 = _SEGV_MAPERR</code></span>
<span class="codeline" id="line-1414"><code>	gp.sigcode1 = 0 // TODO: emulate si_addr</code></span>
<span class="codeline" id="line-1415"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>