<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mgc.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mgc.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Garbage collector (GC).</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple</code></span>
<span class="codeline" id="line-8"><code>// GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is</code></span>
<span class="codeline" id="line-9"><code>// non-generational and non-compacting. Allocation is done using size segregated per P allocation</code></span>
<span class="codeline" id="line-10"><code>// areas to minimize fragmentation while eliminating locks in the common case.</code></span>
<span class="codeline" id="line-11"><code>//</code></span>
<span class="codeline" id="line-12"><code>// The algorithm decomposes into several steps.</code></span>
<span class="codeline" id="line-13"><code>// This is a high level description of the algorithm being used. For an overview of GC a good</code></span>
<span class="codeline" id="line-14"><code>// place to start is Richard Jones' gchandbook.org.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// The algorithm's intellectual heritage includes Dijkstra's on-the-fly algorithm, see</code></span>
<span class="codeline" id="line-17"><code>// Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978.</code></span>
<span class="codeline" id="line-18"><code>// On-the-fly garbage collection: an exercise in cooperation. Commun. ACM 21, 11 (November 1978),</code></span>
<span class="codeline" id="line-19"><code>// 966-975.</code></span>
<span class="codeline" id="line-20"><code>// For journal quality proofs that these steps are complete, correct, and terminate see</code></span>
<span class="codeline" id="line-21"><code>// Hudson, R., and Moss, J.E.B. Copying Garbage Collection without stopping the world.</code></span>
<span class="codeline" id="line-22"><code>// Concurrency and Computation: Practice and Experience 15(3-5), 2003.</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>// 1. GC performs sweep termination.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>//    a. Stop the world. This causes all Ps to reach a GC safe-point.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>//    b. Sweep any unswept spans. There will only be unswept spans if</code></span>
<span class="codeline" id="line-29"><code>//    this GC cycle was forced before the expected time.</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// 2. GC performs the mark phase.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>//    a. Prepare for the mark phase by setting gcphase to _GCmark</code></span>
<span class="codeline" id="line-34"><code>//    (from _GCoff), enabling the write barrier, enabling mutator</code></span>
<span class="codeline" id="line-35"><code>//    assists, and enqueueing root mark jobs. No objects may be</code></span>
<span class="codeline" id="line-36"><code>//    scanned until all Ps have enabled the write barrier, which is</code></span>
<span class="codeline" id="line-37"><code>//    accomplished using STW.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>//    b. Start the world. From this point, GC work is done by mark</code></span>
<span class="codeline" id="line-40"><code>//    workers started by the scheduler and by assists performed as</code></span>
<span class="codeline" id="line-41"><code>//    part of allocation. The write barrier shades both the</code></span>
<span class="codeline" id="line-42"><code>//    overwritten pointer and the new pointer value for any pointer</code></span>
<span class="codeline" id="line-43"><code>//    writes (see mbarrier.go for details). Newly allocated objects</code></span>
<span class="codeline" id="line-44"><code>//    are immediately marked black.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>//    c. GC performs root marking jobs. This includes scanning all</code></span>
<span class="codeline" id="line-47"><code>//    stacks, shading all globals, and shading any heap pointers in</code></span>
<span class="codeline" id="line-48"><code>//    off-heap runtime data structures. Scanning a stack stops a</code></span>
<span class="codeline" id="line-49"><code>//    goroutine, shades any pointers found on its stack, and then</code></span>
<span class="codeline" id="line-50"><code>//    resumes the goroutine.</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>//    d. GC drains the work queue of grey objects, scanning each grey</code></span>
<span class="codeline" id="line-53"><code>//    object to black and shading all pointers found in the object</code></span>
<span class="codeline" id="line-54"><code>//    (which in turn may add those pointers to the work queue).</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>//    e. Because GC work is spread across local caches, GC uses a</code></span>
<span class="codeline" id="line-57"><code>//    distributed termination algorithm to detect when there are no</code></span>
<span class="codeline" id="line-58"><code>//    more root marking jobs or grey objects (see gcMarkDone). At this</code></span>
<span class="codeline" id="line-59"><code>//    point, GC transitions to mark termination.</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// 3. GC performs mark termination.</code></span>
<span class="codeline" id="line-62"><code>//</code></span>
<span class="codeline" id="line-63"><code>//    a. Stop the world.</code></span>
<span class="codeline" id="line-64"><code>//</code></span>
<span class="codeline" id="line-65"><code>//    b. Set gcphase to _GCmarktermination, and disable workers and</code></span>
<span class="codeline" id="line-66"><code>//    assists.</code></span>
<span class="codeline" id="line-67"><code>//</code></span>
<span class="codeline" id="line-68"><code>//    c. Perform housekeeping like flushing mcaches.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// 4. GC performs the sweep phase.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>//    a. Prepare for the sweep phase by setting gcphase to _GCoff,</code></span>
<span class="codeline" id="line-73"><code>//    setting up sweep state and disabling the write barrier.</code></span>
<span class="codeline" id="line-74"><code>//</code></span>
<span class="codeline" id="line-75"><code>//    b. Start the world. From this point on, newly allocated objects</code></span>
<span class="codeline" id="line-76"><code>//    are white, and allocating sweeps spans before use if necessary.</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>//    c. GC does concurrent sweeping in the background and in response</code></span>
<span class="codeline" id="line-79"><code>//    to allocation. See description below.</code></span>
<span class="codeline" id="line-80"><code>//</code></span>
<span class="codeline" id="line-81"><code>// 5. When sufficient allocation has taken place, replay the sequence</code></span>
<span class="codeline" id="line-82"><code>// starting with 1 above. See discussion of GC rate below.</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>// Concurrent sweep.</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// The sweep phase proceeds concurrently with normal program execution.</code></span>
<span class="codeline" id="line-87"><code>// The heap is swept span-by-span both lazily (when a goroutine needs another span)</code></span>
<span class="codeline" id="line-88"><code>// and concurrently in a background goroutine (this helps programs that are not CPU bound).</code></span>
<span class="codeline" id="line-89"><code>// At the end of STW mark termination all spans are marked as "needs sweeping".</code></span>
<span class="codeline" id="line-90"><code>//</code></span>
<span class="codeline" id="line-91"><code>// The background sweeper goroutine simply sweeps spans one-by-one.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// To avoid requesting more OS memory while there are unswept spans, when a</code></span>
<span class="codeline" id="line-94"><code>// goroutine needs another span, it first attempts to reclaim that much memory</code></span>
<span class="codeline" id="line-95"><code>// by sweeping. When a goroutine needs to allocate a new small-object span, it</code></span>
<span class="codeline" id="line-96"><code>// sweeps small-object spans for the same object size until it frees at least</code></span>
<span class="codeline" id="line-97"><code>// one object. When a goroutine needs to allocate large-object span from heap,</code></span>
<span class="codeline" id="line-98"><code>// it sweeps spans until it frees at least that many pages into heap. There is</code></span>
<span class="codeline" id="line-99"><code>// one case where this may not suffice: if a goroutine sweeps and frees two</code></span>
<span class="codeline" id="line-100"><code>// nonadjacent one-page spans to the heap, it will allocate a new two-page</code></span>
<span class="codeline" id="line-101"><code>// span, but there can still be other one-page unswept spans which could be</code></span>
<span class="codeline" id="line-102"><code>// combined into a two-page span.</code></span>
<span class="codeline" id="line-103"><code>//</code></span>
<span class="codeline" id="line-104"><code>// It's critical to ensure that no operations proceed on unswept spans (that would corrupt</code></span>
<span class="codeline" id="line-105"><code>// mark bits in GC bitmap). During GC all mcaches are flushed into the central cache,</code></span>
<span class="codeline" id="line-106"><code>// so they are empty. When a goroutine grabs a new span into mcache, it sweeps it.</code></span>
<span class="codeline" id="line-107"><code>// When a goroutine explicitly frees an object or sets a finalizer, it ensures that</code></span>
<span class="codeline" id="line-108"><code>// the span is swept (either by sweeping it, or by waiting for the concurrent sweep to finish).</code></span>
<span class="codeline" id="line-109"><code>// The finalizer goroutine is kicked off only when all spans are swept.</code></span>
<span class="codeline" id="line-110"><code>// When the next GC starts, it sweeps all not-yet-swept spans (if any).</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>// GC rate.</code></span>
<span class="codeline" id="line-113"><code>// Next GC is after we've allocated an extra amount of memory proportional to</code></span>
<span class="codeline" id="line-114"><code>// the amount already in use. The proportion is controlled by GOGC environment variable</code></span>
<span class="codeline" id="line-115"><code>// (100 by default). If GOGC=100 and we're using 4M, we'll GC again when we get to 8M</code></span>
<span class="codeline" id="line-116"><code>// (this mark is computed by the gcController.heapGoal method). This keeps the GC cost in</code></span>
<span class="codeline" id="line-117"><code>// linear proportion to the allocation cost. Adjusting GOGC just changes the linear constant</code></span>
<span class="codeline" id="line-118"><code>// (and also the amount of extra memory used).</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>// Oblets</code></span>
<span class="codeline" id="line-121"><code>//</code></span>
<span class="codeline" id="line-122"><code>// In order to prevent long pauses while scanning large objects and to</code></span>
<span class="codeline" id="line-123"><code>// improve parallelism, the garbage collector breaks up scan jobs for</code></span>
<span class="codeline" id="line-124"><code>// objects larger than maxObletBytes into "oblets" of at most</code></span>
<span class="codeline" id="line-125"><code>// maxObletBytes. When scanning encounters the beginning of a large</code></span>
<span class="codeline" id="line-126"><code>// object, it scans only the first oblet and enqueues the remaining</code></span>
<span class="codeline" id="line-127"><code>// oblets as new scan jobs.</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>package runtime</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>import (</code></span>
<span class="codeline" id="line-132"><code>	"internal/cpu"</code></span>
<span class="codeline" id="line-133"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-134"><code>	"unsafe"</code></span>
<span class="codeline" id="line-135"><code>)</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>const (</code></span>
<span class="codeline" id="line-138"><code>	_DebugGC      = 0</code></span>
<span class="codeline" id="line-139"><code>	_FinBlockSize = 4 * 1024</code></span>
<span class="codeline" id="line-140"><code></code></span>
<span class="codeline" id="line-141"><code>	// concurrentSweep is a debug flag. Disabling this flag</code></span>
<span class="codeline" id="line-142"><code>	// ensures all spans are swept while the world is stopped.</code></span>
<span class="codeline" id="line-143"><code>	concurrentSweep = true</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>	// debugScanConservative enables debug logging for stack</code></span>
<span class="codeline" id="line-146"><code>	// frames that are scanned conservatively.</code></span>
<span class="codeline" id="line-147"><code>	debugScanConservative = false</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>	// sweepMinHeapDistance is a lower bound on the heap distance</code></span>
<span class="codeline" id="line-150"><code>	// (in bytes) reserved for concurrent sweeping between GC</code></span>
<span class="codeline" id="line-151"><code>	// cycles.</code></span>
<span class="codeline" id="line-152"><code>	sweepMinHeapDistance = 1024 * 1024</code></span>
<span class="codeline" id="line-153"><code>)</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>// heapObjectsCanMove always returns false in the current garbage collector.</code></span>
<span class="codeline" id="line-156"><code>// It exists for go4.org/unsafe/assume-no-moving-gc, which is an</code></span>
<span class="codeline" id="line-157"><code>// unfortunate idea that had an even more unfortunate implementation.</code></span>
<span class="codeline" id="line-158"><code>// Every time a new Go release happened, the package stopped building,</code></span>
<span class="codeline" id="line-159"><code>// and the authors had to add a new file with a new //go:build line, and</code></span>
<span class="codeline" id="line-160"><code>// then the entire ecosystem of packages with that as a dependency had to</code></span>
<span class="codeline" id="line-161"><code>// explicitly update to the new version. Many packages depend on</code></span>
<span class="codeline" id="line-162"><code>// assume-no-moving-gc transitively, through paths like</code></span>
<span class="codeline" id="line-163"><code>// inet.af/netaddr -&gt; go4.org/intern -&gt; assume-no-moving-gc.</code></span>
<span class="codeline" id="line-164"><code>// This was causing a significant amount of friction around each new</code></span>
<span class="codeline" id="line-165"><code>// release, so we added this bool for the package to //go:linkname</code></span>
<span class="codeline" id="line-166"><code>// instead. The bool is still unfortunate, but it's not as bad as</code></span>
<span class="codeline" id="line-167"><code>// breaking the ecosystem on every new release.</code></span>
<span class="codeline" id="line-168"><code>//</code></span>
<span class="codeline" id="line-169"><code>// If the Go garbage collector ever does move heap objects, we can set</code></span>
<span class="codeline" id="line-170"><code>// this to true to break all the programs using assume-no-moving-gc.</code></span>
<span class="codeline" id="line-171"><code>//</code></span>
<span class="codeline" id="line-172"><code>//go:linkname heapObjectsCanMove</code></span>
<span class="codeline" id="line-173"><code>func heapObjectsCanMove() bool {</code></span>
<span class="codeline" id="line-174"><code>	return false</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>func gcinit() {</code></span>
<span class="codeline" id="line-178"><code>	if unsafe.Sizeof(workbuf{}) != _WorkbufSize {</code></span>
<span class="codeline" id="line-179"><code>		throw("size of Workbuf is suboptimal")</code></span>
<span class="codeline" id="line-180"><code>	}</code></span>
<span class="codeline" id="line-181"><code>	// No sweep on the first cycle.</code></span>
<span class="codeline" id="line-182"><code>	sweep.active.state.Store(sweepDrainedMask)</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	// Initialize GC pacer state.</code></span>
<span class="codeline" id="line-185"><code>	// Use the environment variable GOGC for the initial gcPercent value.</code></span>
<span class="codeline" id="line-186"><code>	// Use the environment variable GOMEMLIMIT for the initial memoryLimit value.</code></span>
<span class="codeline" id="line-187"><code>	gcController.init(readGOGC(), readGOMEMLIMIT())</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>	work.startSema = 1</code></span>
<span class="codeline" id="line-190"><code>	work.markDoneSema = 1</code></span>
<span class="codeline" id="line-191"><code>	lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)</code></span>
<span class="codeline" id="line-192"><code>	lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)</code></span>
<span class="codeline" id="line-193"><code>	lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// gcenable is called after the bulk of the runtime initialization,</code></span>
<span class="codeline" id="line-197"><code>// just before we're about to start letting user code run.</code></span>
<span class="codeline" id="line-198"><code>// It kicks off the background sweeper goroutine, the background</code></span>
<span class="codeline" id="line-199"><code>// scavenger goroutine, and enables GC.</code></span>
<span class="codeline" id="line-200"><code>func gcenable() {</code></span>
<span class="codeline" id="line-201"><code>	// Kick off sweeping and scavenging.</code></span>
<span class="codeline" id="line-202"><code>	c := make(chan int, 2)</code></span>
<span class="codeline" id="line-203"><code>	go bgsweep(c)</code></span>
<span class="codeline" id="line-204"><code>	go bgscavenge(c)</code></span>
<span class="codeline" id="line-205"><code>	&lt;-c</code></span>
<span class="codeline" id="line-206"><code>	&lt;-c</code></span>
<span class="codeline" id="line-207"><code>	memstats.enablegc = true // now that runtime is initialized, GC is okay</code></span>
<span class="codeline" id="line-208"><code>}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>// Garbage collector phase.</code></span>
<span class="codeline" id="line-211"><code>// Indicates to write barrier and synchronization task to perform.</code></span>
<span class="codeline" id="line-212"><code>var gcphase uint32</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// The compiler knows about this variable.</code></span>
<span class="codeline" id="line-215"><code>// If you change it, you must change builtin/runtime.go, too.</code></span>
<span class="codeline" id="line-216"><code>// If you change the first four bytes, you must also change the write</code></span>
<span class="codeline" id="line-217"><code>// barrier insertion code.</code></span>
<span class="codeline" id="line-218"><code>var writeBarrier struct {</code></span>
<span class="codeline" id="line-219"><code>	enabled bool    // compiler emits a check of this before calling write barrier</code></span>
<span class="codeline" id="line-220"><code>	pad     [3]byte // compiler uses 32-bit load for "enabled" field</code></span>
<span class="codeline" id="line-221"><code>	alignme uint64  // guarantee alignment so that compiler can use a 32 or 64-bit load</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// gcBlackenEnabled is 1 if mutator assists and background mark</code></span>
<span class="codeline" id="line-225"><code>// workers are allowed to blacken objects. This must only be set when</code></span>
<span class="codeline" id="line-226"><code>// gcphase == _GCmark.</code></span>
<span class="codeline" id="line-227"><code>var gcBlackenEnabled uint32</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>const (</code></span>
<span class="codeline" id="line-230"><code>	_GCoff             = iota // GC not running; sweeping in background, write barrier disabled</code></span>
<span class="codeline" id="line-231"><code>	_GCmark                   // GC marking roots and workbufs: allocate black, write barrier ENABLED</code></span>
<span class="codeline" id="line-232"><code>	_GCmarktermination        // GC mark termination: allocate black, P's help GC, write barrier ENABLED</code></span>
<span class="codeline" id="line-233"><code>)</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>//go:nosplit</code></span>
<span class="codeline" id="line-236"><code>func setGCPhase(x uint32) {</code></span>
<span class="codeline" id="line-237"><code>	atomic.Store(&amp;gcphase, x)</code></span>
<span class="codeline" id="line-238"><code>	writeBarrier.enabled = gcphase == _GCmark || gcphase == _GCmarktermination</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>// gcMarkWorkerMode represents the mode that a concurrent mark worker</code></span>
<span class="codeline" id="line-242"><code>// should operate in.</code></span>
<span class="codeline" id="line-243"><code>//</code></span>
<span class="codeline" id="line-244"><code>// Concurrent marking happens through four different mechanisms. One</code></span>
<span class="codeline" id="line-245"><code>// is mutator assists, which happen in response to allocations and are</code></span>
<span class="codeline" id="line-246"><code>// not scheduled. The other three are variations in the per-P mark</code></span>
<span class="codeline" id="line-247"><code>// workers and are distinguished by gcMarkWorkerMode.</code></span>
<span class="codeline" id="line-248"><code>type gcMarkWorkerMode int</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>const (</code></span>
<span class="codeline" id="line-251"><code>	// gcMarkWorkerNotWorker indicates that the next scheduled G is not</code></span>
<span class="codeline" id="line-252"><code>	// starting work and the mode should be ignored.</code></span>
<span class="codeline" id="line-253"><code>	gcMarkWorkerNotWorker gcMarkWorkerMode = iota</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>	// gcMarkWorkerDedicatedMode indicates that the P of a mark</code></span>
<span class="codeline" id="line-256"><code>	// worker is dedicated to running that mark worker. The mark</code></span>
<span class="codeline" id="line-257"><code>	// worker should run without preemption.</code></span>
<span class="codeline" id="line-258"><code>	gcMarkWorkerDedicatedMode</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>	// gcMarkWorkerFractionalMode indicates that a P is currently</code></span>
<span class="codeline" id="line-261"><code>	// running the "fractional" mark worker. The fractional worker</code></span>
<span class="codeline" id="line-262"><code>	// is necessary when GOMAXPROCS*gcBackgroundUtilization is not</code></span>
<span class="codeline" id="line-263"><code>	// an integer and using only dedicated workers would result in</code></span>
<span class="codeline" id="line-264"><code>	// utilization too far from the target of gcBackgroundUtilization.</code></span>
<span class="codeline" id="line-265"><code>	// The fractional worker should run until it is preempted and</code></span>
<span class="codeline" id="line-266"><code>	// will be scheduled to pick up the fractional part of</code></span>
<span class="codeline" id="line-267"><code>	// GOMAXPROCS*gcBackgroundUtilization.</code></span>
<span class="codeline" id="line-268"><code>	gcMarkWorkerFractionalMode</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>	// gcMarkWorkerIdleMode indicates that a P is running the mark</code></span>
<span class="codeline" id="line-271"><code>	// worker because it has nothing else to do. The idle worker</code></span>
<span class="codeline" id="line-272"><code>	// should run until it is preempted and account its time</code></span>
<span class="codeline" id="line-273"><code>	// against gcController.idleMarkTime.</code></span>
<span class="codeline" id="line-274"><code>	gcMarkWorkerIdleMode</code></span>
<span class="codeline" id="line-275"><code>)</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// gcMarkWorkerModeStrings are the strings labels of gcMarkWorkerModes</code></span>
<span class="codeline" id="line-278"><code>// to use in execution traces.</code></span>
<span class="codeline" id="line-279"><code>var gcMarkWorkerModeStrings = [...]string{</code></span>
<span class="codeline" id="line-280"><code>	"Not worker",</code></span>
<span class="codeline" id="line-281"><code>	"GC (dedicated)",</code></span>
<span class="codeline" id="line-282"><code>	"GC (fractional)",</code></span>
<span class="codeline" id="line-283"><code>	"GC (idle)",</code></span>
<span class="codeline" id="line-284"><code>}</code></span>
<span class="codeline" id="line-285"><code></code></span>
<span class="codeline" id="line-286"><code>// pollFractionalWorkerExit reports whether a fractional mark worker</code></span>
<span class="codeline" id="line-287"><code>// should self-preempt. It assumes it is called from the fractional</code></span>
<span class="codeline" id="line-288"><code>// worker.</code></span>
<span class="codeline" id="line-289"><code>func pollFractionalWorkerExit() bool {</code></span>
<span class="codeline" id="line-290"><code>	// This should be kept in sync with the fractional worker</code></span>
<span class="codeline" id="line-291"><code>	// scheduler logic in findRunnableGCWorker.</code></span>
<span class="codeline" id="line-292"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-293"><code>	delta := now - gcController.markStartTime</code></span>
<span class="codeline" id="line-294"><code>	if delta &lt;= 0 {</code></span>
<span class="codeline" id="line-295"><code>		return true</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	p := getg().m.p.ptr()</code></span>
<span class="codeline" id="line-298"><code>	selfTime := p.gcFractionalMarkTime + (now - p.gcMarkWorkerStartTime)</code></span>
<span class="codeline" id="line-299"><code>	// Add some slack to the utilization goal so that the</code></span>
<span class="codeline" id="line-300"><code>	// fractional worker isn't behind again the instant it exits.</code></span>
<span class="codeline" id="line-301"><code>	return float64(selfTime)/float64(delta) &gt; 1.2*gcController.fractionalUtilizationGoal</code></span>
<span class="codeline" id="line-302"><code>}</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>var work workType</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>type workType struct {</code></span>
<span class="codeline" id="line-307"><code>	full  lfstack          // lock-free list of full blocks workbuf</code></span>
<span class="codeline" id="line-308"><code>	_     cpu.CacheLinePad // prevents false-sharing between full and empty</code></span>
<span class="codeline" id="line-309"><code>	empty lfstack          // lock-free list of empty blocks workbuf</code></span>
<span class="codeline" id="line-310"><code>	_     cpu.CacheLinePad // prevents false-sharing between empty and nproc/nwait</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>	wbufSpans struct {</code></span>
<span class="codeline" id="line-313"><code>		lock mutex</code></span>
<span class="codeline" id="line-314"><code>		// free is a list of spans dedicated to workbufs, but</code></span>
<span class="codeline" id="line-315"><code>		// that don't currently contain any workbufs.</code></span>
<span class="codeline" id="line-316"><code>		free mSpanList</code></span>
<span class="codeline" id="line-317"><code>		// busy is a list of all spans containing workbufs on</code></span>
<span class="codeline" id="line-318"><code>		// one of the workbuf lists.</code></span>
<span class="codeline" id="line-319"><code>		busy mSpanList</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>	// Restore 64-bit alignment on 32-bit.</code></span>
<span class="codeline" id="line-323"><code>	_ uint32</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	// bytesMarked is the number of bytes marked this cycle. This</code></span>
<span class="codeline" id="line-326"><code>	// includes bytes blackened in scanned objects, noscan objects</code></span>
<span class="codeline" id="line-327"><code>	// that go straight to black, and permagrey objects scanned by</code></span>
<span class="codeline" id="line-328"><code>	// markroot during the concurrent scan phase. This is updated</code></span>
<span class="codeline" id="line-329"><code>	// atomically during the cycle. Updates may be batched</code></span>
<span class="codeline" id="line-330"><code>	// arbitrarily, since the value is only read at the end of the</code></span>
<span class="codeline" id="line-331"><code>	// cycle.</code></span>
<span class="codeline" id="line-332"><code>	//</code></span>
<span class="codeline" id="line-333"><code>	// Because of benign races during marking, this number may not</code></span>
<span class="codeline" id="line-334"><code>	// be the exact number of marked bytes, but it should be very</code></span>
<span class="codeline" id="line-335"><code>	// close.</code></span>
<span class="codeline" id="line-336"><code>	//</code></span>
<span class="codeline" id="line-337"><code>	// Put this field here because it needs 64-bit atomic access</code></span>
<span class="codeline" id="line-338"><code>	// (and thus 8-byte alignment even on 32-bit architectures).</code></span>
<span class="codeline" id="line-339"><code>	bytesMarked uint64</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>	markrootNext uint32 // next markroot job</code></span>
<span class="codeline" id="line-342"><code>	markrootJobs uint32 // number of markroot jobs</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>	nproc  uint32</code></span>
<span class="codeline" id="line-345"><code>	tstart int64</code></span>
<span class="codeline" id="line-346"><code>	nwait  uint32</code></span>
<span class="codeline" id="line-347"><code></code></span>
<span class="codeline" id="line-348"><code>	// Number of roots of various root types. Set by gcMarkRootPrepare.</code></span>
<span class="codeline" id="line-349"><code>	//</code></span>
<span class="codeline" id="line-350"><code>	// nStackRoots == len(stackRoots), but we have nStackRoots for</code></span>
<span class="codeline" id="line-351"><code>	// consistency.</code></span>
<span class="codeline" id="line-352"><code>	nDataRoots, nBSSRoots, nSpanRoots, nStackRoots int</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>	// Base indexes of each root type. Set by gcMarkRootPrepare.</code></span>
<span class="codeline" id="line-355"><code>	baseData, baseBSS, baseSpans, baseStacks, baseEnd uint32</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	// stackRoots is a snapshot of all of the Gs that existed</code></span>
<span class="codeline" id="line-358"><code>	// before the beginning of concurrent marking. The backing</code></span>
<span class="codeline" id="line-359"><code>	// store of this must not be modified because it might be</code></span>
<span class="codeline" id="line-360"><code>	// shared with allgs.</code></span>
<span class="codeline" id="line-361"><code>	stackRoots []*g</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>	// Each type of GC state transition is protected by a lock.</code></span>
<span class="codeline" id="line-364"><code>	// Since multiple threads can simultaneously detect the state</code></span>
<span class="codeline" id="line-365"><code>	// transition condition, any thread that detects a transition</code></span>
<span class="codeline" id="line-366"><code>	// condition must acquire the appropriate transition lock,</code></span>
<span class="codeline" id="line-367"><code>	// re-check the transition condition and return if it no</code></span>
<span class="codeline" id="line-368"><code>	// longer holds or perform the transition if it does.</code></span>
<span class="codeline" id="line-369"><code>	// Likewise, any transition must invalidate the transition</code></span>
<span class="codeline" id="line-370"><code>	// condition before releasing the lock. This ensures that each</code></span>
<span class="codeline" id="line-371"><code>	// transition is performed by exactly one thread and threads</code></span>
<span class="codeline" id="line-372"><code>	// that need the transition to happen block until it has</code></span>
<span class="codeline" id="line-373"><code>	// happened.</code></span>
<span class="codeline" id="line-374"><code>	//</code></span>
<span class="codeline" id="line-375"><code>	// startSema protects the transition from "off" to mark or</code></span>
<span class="codeline" id="line-376"><code>	// mark termination.</code></span>
<span class="codeline" id="line-377"><code>	startSema uint32</code></span>
<span class="codeline" id="line-378"><code>	// markDoneSema protects transitions from mark to mark termination.</code></span>
<span class="codeline" id="line-379"><code>	markDoneSema uint32</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>	bgMarkReady note   // signal background mark worker has started</code></span>
<span class="codeline" id="line-382"><code>	bgMarkDone  uint32 // cas to 1 when at a background mark completion point</code></span>
<span class="codeline" id="line-383"><code>	// Background mark completion signaling</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	// mode is the concurrency mode of the current GC cycle.</code></span>
<span class="codeline" id="line-386"><code>	mode gcMode</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>	// userForced indicates the current GC cycle was forced by an</code></span>
<span class="codeline" id="line-389"><code>	// explicit user call.</code></span>
<span class="codeline" id="line-390"><code>	userForced bool</code></span>
<span class="codeline" id="line-391"><code></code></span>
<span class="codeline" id="line-392"><code>	// initialHeapLive is the value of gcController.heapLive at the</code></span>
<span class="codeline" id="line-393"><code>	// beginning of this GC cycle.</code></span>
<span class="codeline" id="line-394"><code>	initialHeapLive uint64</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	// assistQueue is a queue of assists that are blocked because</code></span>
<span class="codeline" id="line-397"><code>	// there was neither enough credit to steal or enough work to</code></span>
<span class="codeline" id="line-398"><code>	// do.</code></span>
<span class="codeline" id="line-399"><code>	assistQueue struct {</code></span>
<span class="codeline" id="line-400"><code>		lock mutex</code></span>
<span class="codeline" id="line-401"><code>		q    gQueue</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>	// sweepWaiters is a list of blocked goroutines to wake when</code></span>
<span class="codeline" id="line-405"><code>	// we transition from mark termination to sweep.</code></span>
<span class="codeline" id="line-406"><code>	sweepWaiters struct {</code></span>
<span class="codeline" id="line-407"><code>		lock mutex</code></span>
<span class="codeline" id="line-408"><code>		list gList</code></span>
<span class="codeline" id="line-409"><code>	}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>	// cycles is the number of completed GC cycles, where a GC</code></span>
<span class="codeline" id="line-412"><code>	// cycle is sweep termination, mark, mark termination, and</code></span>
<span class="codeline" id="line-413"><code>	// sweep. This differs from memstats.numgc, which is</code></span>
<span class="codeline" id="line-414"><code>	// incremented at mark termination.</code></span>
<span class="codeline" id="line-415"><code>	cycles atomic.Uint32</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	// Timing/utilization stats for this cycle.</code></span>
<span class="codeline" id="line-418"><code>	stwprocs, maxprocs                 int32</code></span>
<span class="codeline" id="line-419"><code>	tSweepTerm, tMark, tMarkTerm, tEnd int64 // nanotime() of phase start</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	pauseNS int64 // total STW time this cycle</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>	// debug.gctrace heap sizes for this cycle.</code></span>
<span class="codeline" id="line-424"><code>	heap0, heap1, heap2 uint64</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>	// Cumulative estimated CPU usage.</code></span>
<span class="codeline" id="line-427"><code>	cpuStats</code></span>
<span class="codeline" id="line-428"><code>}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>// GC runs a garbage collection and blocks the caller until the</code></span>
<span class="codeline" id="line-431"><code>// garbage collection is complete. It may also block the entire</code></span>
<span class="codeline" id="line-432"><code>// program.</code></span>
<span class="codeline" id="line-433"><code>func GC() {</code></span>
<span class="codeline" id="line-434"><code>	// We consider a cycle to be: sweep termination, mark, mark</code></span>
<span class="codeline" id="line-435"><code>	// termination, and sweep. This function shouldn't return</code></span>
<span class="codeline" id="line-436"><code>	// until a full cycle has been completed, from beginning to</code></span>
<span class="codeline" id="line-437"><code>	// end. Hence, we always want to finish up the current cycle</code></span>
<span class="codeline" id="line-438"><code>	// and start a new one. That means:</code></span>
<span class="codeline" id="line-439"><code>	//</code></span>
<span class="codeline" id="line-440"><code>	// 1. In sweep termination, mark, or mark termination of cycle</code></span>
<span class="codeline" id="line-441"><code>	// N, wait until mark termination N completes and transitions</code></span>
<span class="codeline" id="line-442"><code>	// to sweep N.</code></span>
<span class="codeline" id="line-443"><code>	//</code></span>
<span class="codeline" id="line-444"><code>	// 2. In sweep N, help with sweep N.</code></span>
<span class="codeline" id="line-445"><code>	//</code></span>
<span class="codeline" id="line-446"><code>	// At this point we can begin a full cycle N+1.</code></span>
<span class="codeline" id="line-447"><code>	//</code></span>
<span class="codeline" id="line-448"><code>	// 3. Trigger cycle N+1 by starting sweep termination N+1.</code></span>
<span class="codeline" id="line-449"><code>	//</code></span>
<span class="codeline" id="line-450"><code>	// 4. Wait for mark termination N+1 to complete.</code></span>
<span class="codeline" id="line-451"><code>	//</code></span>
<span class="codeline" id="line-452"><code>	// 5. Help with sweep N+1 until it's done.</code></span>
<span class="codeline" id="line-453"><code>	//</code></span>
<span class="codeline" id="line-454"><code>	// This all has to be written to deal with the fact that the</code></span>
<span class="codeline" id="line-455"><code>	// GC may move ahead on its own. For example, when we block</code></span>
<span class="codeline" id="line-456"><code>	// until mark termination N, we may wake up in cycle N+2.</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>	// Wait until the current sweep termination, mark, and mark</code></span>
<span class="codeline" id="line-459"><code>	// termination complete.</code></span>
<span class="codeline" id="line-460"><code>	n := work.cycles.Load()</code></span>
<span class="codeline" id="line-461"><code>	gcWaitOnMark(n)</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>	// We're now in sweep N or later. Trigger GC cycle N+1, which</code></span>
<span class="codeline" id="line-464"><code>	// will first finish sweep N if necessary and then enter sweep</code></span>
<span class="codeline" id="line-465"><code>	// termination N+1.</code></span>
<span class="codeline" id="line-466"><code>	gcStart(gcTrigger{kind: gcTriggerCycle, n: n + 1})</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>	// Wait for mark termination N+1 to complete.</code></span>
<span class="codeline" id="line-469"><code>	gcWaitOnMark(n + 1)</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	// Finish sweep N+1 before returning. We do this both to</code></span>
<span class="codeline" id="line-472"><code>	// complete the cycle and because runtime.GC() is often used</code></span>
<span class="codeline" id="line-473"><code>	// as part of tests and benchmarks to get the system into a</code></span>
<span class="codeline" id="line-474"><code>	// relatively stable and isolated state.</code></span>
<span class="codeline" id="line-475"><code>	for work.cycles.Load() == n+1 &amp;&amp; sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-476"><code>		Gosched()</code></span>
<span class="codeline" id="line-477"><code>	}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>	// Callers may assume that the heap profile reflects the</code></span>
<span class="codeline" id="line-480"><code>	// just-completed cycle when this returns (historically this</code></span>
<span class="codeline" id="line-481"><code>	// happened because this was a STW GC), but right now the</code></span>
<span class="codeline" id="line-482"><code>	// profile still reflects mark termination N, not N+1.</code></span>
<span class="codeline" id="line-483"><code>	//</code></span>
<span class="codeline" id="line-484"><code>	// As soon as all of the sweep frees from cycle N+1 are done,</code></span>
<span class="codeline" id="line-485"><code>	// we can go ahead and publish the heap profile.</code></span>
<span class="codeline" id="line-486"><code>	//</code></span>
<span class="codeline" id="line-487"><code>	// First, wait for sweeping to finish. (We know there are no</code></span>
<span class="codeline" id="line-488"><code>	// more spans on the sweep queue, but we may be concurrently</code></span>
<span class="codeline" id="line-489"><code>	// sweeping spans, so we have to wait.)</code></span>
<span class="codeline" id="line-490"><code>	for work.cycles.Load() == n+1 &amp;&amp; !isSweepDone() {</code></span>
<span class="codeline" id="line-491"><code>		Gosched()</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	// Now we're really done with sweeping, so we can publish the</code></span>
<span class="codeline" id="line-495"><code>	// stable heap profile. Only do this if we haven't already hit</code></span>
<span class="codeline" id="line-496"><code>	// another mark termination.</code></span>
<span class="codeline" id="line-497"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-498"><code>	cycle := work.cycles.Load()</code></span>
<span class="codeline" id="line-499"><code>	if cycle == n+1 || (gcphase == _GCmark &amp;&amp; cycle == n+2) {</code></span>
<span class="codeline" id="line-500"><code>		mProf_PostSweep()</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>// gcWaitOnMark blocks until GC finishes the Nth mark phase. If GC has</code></span>
<span class="codeline" id="line-506"><code>// already completed this mark phase, it returns immediately.</code></span>
<span class="codeline" id="line-507"><code>func gcWaitOnMark(n uint32) {</code></span>
<span class="codeline" id="line-508"><code>	for {</code></span>
<span class="codeline" id="line-509"><code>		// Disable phase transitions.</code></span>
<span class="codeline" id="line-510"><code>		lock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-511"><code>		nMarks := work.cycles.Load()</code></span>
<span class="codeline" id="line-512"><code>		if gcphase != _GCmark {</code></span>
<span class="codeline" id="line-513"><code>			// We've already completed this cycle's mark.</code></span>
<span class="codeline" id="line-514"><code>			nMarks++</code></span>
<span class="codeline" id="line-515"><code>		}</code></span>
<span class="codeline" id="line-516"><code>		if nMarks &gt; n {</code></span>
<span class="codeline" id="line-517"><code>			// We're done.</code></span>
<span class="codeline" id="line-518"><code>			unlock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-519"><code>			return</code></span>
<span class="codeline" id="line-520"><code>		}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>		// Wait until sweep termination, mark, and mark</code></span>
<span class="codeline" id="line-523"><code>		// termination of cycle N complete.</code></span>
<span class="codeline" id="line-524"><code>		work.sweepWaiters.list.push(getg())</code></span>
<span class="codeline" id="line-525"><code>		goparkunlock(&amp;work.sweepWaiters.lock, waitReasonWaitForGCCycle, traceBlockUntilGCEnds, 1)</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code>}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>// gcMode indicates how concurrent a GC cycle should be.</code></span>
<span class="codeline" id="line-530"><code>type gcMode int</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>const (</code></span>
<span class="codeline" id="line-533"><code>	gcBackgroundMode gcMode = iota // concurrent GC and sweep</code></span>
<span class="codeline" id="line-534"><code>	gcForceMode                    // stop-the-world GC now, concurrent sweep</code></span>
<span class="codeline" id="line-535"><code>	gcForceBlockMode               // stop-the-world GC now and STW sweep (forced by user)</code></span>
<span class="codeline" id="line-536"><code>)</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// A gcTrigger is a predicate for starting a GC cycle. Specifically,</code></span>
<span class="codeline" id="line-539"><code>// it is an exit condition for the _GCoff phase.</code></span>
<span class="codeline" id="line-540"><code>type gcTrigger struct {</code></span>
<span class="codeline" id="line-541"><code>	kind gcTriggerKind</code></span>
<span class="codeline" id="line-542"><code>	now  int64  // gcTriggerTime: current time</code></span>
<span class="codeline" id="line-543"><code>	n    uint32 // gcTriggerCycle: cycle number to start</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>type gcTriggerKind int</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>const (</code></span>
<span class="codeline" id="line-549"><code>	// gcTriggerHeap indicates that a cycle should be started when</code></span>
<span class="codeline" id="line-550"><code>	// the heap size reaches the trigger heap size computed by the</code></span>
<span class="codeline" id="line-551"><code>	// controller.</code></span>
<span class="codeline" id="line-552"><code>	gcTriggerHeap gcTriggerKind = iota</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>	// gcTriggerTime indicates that a cycle should be started when</code></span>
<span class="codeline" id="line-555"><code>	// it's been more than forcegcperiod nanoseconds since the</code></span>
<span class="codeline" id="line-556"><code>	// previous GC cycle.</code></span>
<span class="codeline" id="line-557"><code>	gcTriggerTime</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>	// gcTriggerCycle indicates that a cycle should be started if</code></span>
<span class="codeline" id="line-560"><code>	// we have not yet started cycle number gcTrigger.n (relative</code></span>
<span class="codeline" id="line-561"><code>	// to work.cycles).</code></span>
<span class="codeline" id="line-562"><code>	gcTriggerCycle</code></span>
<span class="codeline" id="line-563"><code>)</code></span>
<span class="codeline" id="line-564"><code></code></span>
<span class="codeline" id="line-565"><code>// test reports whether the trigger condition is satisfied, meaning</code></span>
<span class="codeline" id="line-566"><code>// that the exit condition for the _GCoff phase has been met. The exit</code></span>
<span class="codeline" id="line-567"><code>// condition should be tested when allocating.</code></span>
<span class="codeline" id="line-568"><code>func (t gcTrigger) test() bool {</code></span>
<span class="codeline" id="line-569"><code>	if !memstats.enablegc || panicking.Load() != 0 || gcphase != _GCoff {</code></span>
<span class="codeline" id="line-570"><code>		return false</code></span>
<span class="codeline" id="line-571"><code>	}</code></span>
<span class="codeline" id="line-572"><code>	switch t.kind {</code></span>
<span class="codeline" id="line-573"><code>	case gcTriggerHeap:</code></span>
<span class="codeline" id="line-574"><code>		trigger, _ := gcController.trigger()</code></span>
<span class="codeline" id="line-575"><code>		return gcController.heapLive.Load() &gt;= trigger</code></span>
<span class="codeline" id="line-576"><code>	case gcTriggerTime:</code></span>
<span class="codeline" id="line-577"><code>		if gcController.gcPercent.Load() &lt; 0 {</code></span>
<span class="codeline" id="line-578"><code>			return false</code></span>
<span class="codeline" id="line-579"><code>		}</code></span>
<span class="codeline" id="line-580"><code>		lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</code></span>
<span class="codeline" id="line-581"><code>		return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</code></span>
<span class="codeline" id="line-582"><code>	case gcTriggerCycle:</code></span>
<span class="codeline" id="line-583"><code>		// t.n &gt; work.cycles, but accounting for wraparound.</code></span>
<span class="codeline" id="line-584"><code>		return int32(t.n-work.cycles.Load()) &gt; 0</code></span>
<span class="codeline" id="line-585"><code>	}</code></span>
<span class="codeline" id="line-586"><code>	return true</code></span>
<span class="codeline" id="line-587"><code>}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>// gcStart starts the GC. It transitions from _GCoff to _GCmark (if</code></span>
<span class="codeline" id="line-590"><code>// debug.gcstoptheworld == 0) or performs all of GC (if</code></span>
<span class="codeline" id="line-591"><code>// debug.gcstoptheworld != 0).</code></span>
<span class="codeline" id="line-592"><code>//</code></span>
<span class="codeline" id="line-593"><code>// This may return without performing this transition in some cases,</code></span>
<span class="codeline" id="line-594"><code>// such as when called on a system stack or with locks held.</code></span>
<span class="codeline" id="line-595"><code>func gcStart(trigger gcTrigger) {</code></span>
<span class="codeline" id="line-596"><code>	// Since this is called from malloc and malloc is called in</code></span>
<span class="codeline" id="line-597"><code>	// the guts of a number of libraries that might be holding</code></span>
<span class="codeline" id="line-598"><code>	// locks, don't attempt to start GC in non-preemptible or</code></span>
<span class="codeline" id="line-599"><code>	// potentially unstable situations.</code></span>
<span class="codeline" id="line-600"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-601"><code>	if gp := getg(); gp == mp.g0 || mp.locks &gt; 1 || mp.preemptoff != "" {</code></span>
<span class="codeline" id="line-602"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-603"><code>		return</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-606"><code>	mp = nil</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>	// Pick up the remaining unswept/not being swept spans concurrently</code></span>
<span class="codeline" id="line-609"><code>	//</code></span>
<span class="codeline" id="line-610"><code>	// This shouldn't happen if we're being invoked in background</code></span>
<span class="codeline" id="line-611"><code>	// mode since proportional sweep should have just finished</code></span>
<span class="codeline" id="line-612"><code>	// sweeping everything, but rounding errors, etc, may leave a</code></span>
<span class="codeline" id="line-613"><code>	// few spans unswept. In forced mode, this is necessary since</code></span>
<span class="codeline" id="line-614"><code>	// GC can be forced at any point in the sweeping cycle.</code></span>
<span class="codeline" id="line-615"><code>	//</code></span>
<span class="codeline" id="line-616"><code>	// We check the transition condition continuously here in case</code></span>
<span class="codeline" id="line-617"><code>	// this G gets delayed in to the next GC cycle.</code></span>
<span class="codeline" id="line-618"><code>	for trigger.test() &amp;&amp; sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>	// Perform GC initialization and the sweep termination</code></span>
<span class="codeline" id="line-622"><code>	// transition.</code></span>
<span class="codeline" id="line-623"><code>	semacquire(&amp;work.startSema)</code></span>
<span class="codeline" id="line-624"><code>	// Re-check transition condition under transition lock.</code></span>
<span class="codeline" id="line-625"><code>	if !trigger.test() {</code></span>
<span class="codeline" id="line-626"><code>		semrelease(&amp;work.startSema)</code></span>
<span class="codeline" id="line-627"><code>		return</code></span>
<span class="codeline" id="line-628"><code>	}</code></span>
<span class="codeline" id="line-629"><code></code></span>
<span class="codeline" id="line-630"><code>	// In gcstoptheworld debug mode, upgrade the mode accordingly.</code></span>
<span class="codeline" id="line-631"><code>	// We do this after re-checking the transition condition so</code></span>
<span class="codeline" id="line-632"><code>	// that multiple goroutines that detect the heap trigger don't</code></span>
<span class="codeline" id="line-633"><code>	// start multiple STW GCs.</code></span>
<span class="codeline" id="line-634"><code>	mode := gcBackgroundMode</code></span>
<span class="codeline" id="line-635"><code>	if debug.gcstoptheworld == 1 {</code></span>
<span class="codeline" id="line-636"><code>		mode = gcForceMode</code></span>
<span class="codeline" id="line-637"><code>	} else if debug.gcstoptheworld == 2 {</code></span>
<span class="codeline" id="line-638"><code>		mode = gcForceBlockMode</code></span>
<span class="codeline" id="line-639"><code>	}</code></span>
<span class="codeline" id="line-640"><code></code></span>
<span class="codeline" id="line-641"><code>	// Ok, we're doing it! Stop everybody else</code></span>
<span class="codeline" id="line-642"><code>	semacquire(&amp;gcsema)</code></span>
<span class="codeline" id="line-643"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>	// For stats, check if this GC was forced by the user.</code></span>
<span class="codeline" id="line-646"><code>	// Update it under gcsema to avoid gctrace getting wrong values.</code></span>
<span class="codeline" id="line-647"><code>	work.userForced = trigger.kind == gcTriggerCycle</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-650"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-651"><code>		trace.GCStart()</code></span>
<span class="codeline" id="line-652"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-653"><code>	}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>	// Check that all Ps have finished deferred mcache flushes.</code></span>
<span class="codeline" id="line-656"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-657"><code>		if fg := p.mcache.flushGen.Load(); fg != mheap_.sweepgen {</code></span>
<span class="codeline" id="line-658"><code>			println("runtime: p", p.id, "flushGen", fg, "!= sweepgen", mheap_.sweepgen)</code></span>
<span class="codeline" id="line-659"><code>			throw("p mcache not flushed")</code></span>
<span class="codeline" id="line-660"><code>		}</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>	gcBgMarkStartWorkers()</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>	systemstack(gcResetMarkState)</code></span>
<span class="codeline" id="line-666"><code></code></span>
<span class="codeline" id="line-667"><code>	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</code></span>
<span class="codeline" id="line-668"><code>	if work.stwprocs &gt; ncpu {</code></span>
<span class="codeline" id="line-669"><code>		// This is used to compute CPU time of the STW phases,</code></span>
<span class="codeline" id="line-670"><code>		// so it can't be more than ncpu, even if GOMAXPROCS is.</code></span>
<span class="codeline" id="line-671"><code>		work.stwprocs = ncpu</code></span>
<span class="codeline" id="line-672"><code>	}</code></span>
<span class="codeline" id="line-673"><code>	work.heap0 = gcController.heapLive.Load()</code></span>
<span class="codeline" id="line-674"><code>	work.pauseNS = 0</code></span>
<span class="codeline" id="line-675"><code>	work.mode = mode</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-678"><code>	work.tSweepTerm = now</code></span>
<span class="codeline" id="line-679"><code>	var stw worldStop</code></span>
<span class="codeline" id="line-680"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-681"><code>		stw = stopTheWorldWithSema(stwGCSweepTerm)</code></span>
<span class="codeline" id="line-682"><code>	})</code></span>
<span class="codeline" id="line-683"><code>	// Finish sweep before we start concurrent scan.</code></span>
<span class="codeline" id="line-684"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-685"><code>		finishsweep_m()</code></span>
<span class="codeline" id="line-686"><code>	})</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>	// clearpools before we start the GC. If we wait the memory will not be</code></span>
<span class="codeline" id="line-689"><code>	// reclaimed until the next GC cycle.</code></span>
<span class="codeline" id="line-690"><code>	clearpools()</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>	work.cycles.Add(1)</code></span>
<span class="codeline" id="line-693"><code></code></span>
<span class="codeline" id="line-694"><code>	// Assists and workers can start the moment we start</code></span>
<span class="codeline" id="line-695"><code>	// the world.</code></span>
<span class="codeline" id="line-696"><code>	gcController.startCycle(now, int(gomaxprocs), trigger)</code></span>
<span class="codeline" id="line-697"><code></code></span>
<span class="codeline" id="line-698"><code>	// Notify the CPU limiter that assists may begin.</code></span>
<span class="codeline" id="line-699"><code>	gcCPULimiter.startGCTransition(true, now)</code></span>
<span class="codeline" id="line-700"><code></code></span>
<span class="codeline" id="line-701"><code>	// In STW mode, disable scheduling of user Gs. This may also</code></span>
<span class="codeline" id="line-702"><code>	// disable scheduling of this goroutine, so it may block as</code></span>
<span class="codeline" id="line-703"><code>	// soon as we start the world again.</code></span>
<span class="codeline" id="line-704"><code>	if mode != gcBackgroundMode {</code></span>
<span class="codeline" id="line-705"><code>		schedEnableUser(false)</code></span>
<span class="codeline" id="line-706"><code>	}</code></span>
<span class="codeline" id="line-707"><code></code></span>
<span class="codeline" id="line-708"><code>	// Enter concurrent mark phase and enable</code></span>
<span class="codeline" id="line-709"><code>	// write barriers.</code></span>
<span class="codeline" id="line-710"><code>	//</code></span>
<span class="codeline" id="line-711"><code>	// Because the world is stopped, all Ps will</code></span>
<span class="codeline" id="line-712"><code>	// observe that write barriers are enabled by</code></span>
<span class="codeline" id="line-713"><code>	// the time we start the world and begin</code></span>
<span class="codeline" id="line-714"><code>	// scanning.</code></span>
<span class="codeline" id="line-715"><code>	//</code></span>
<span class="codeline" id="line-716"><code>	// Write barriers must be enabled before assists are</code></span>
<span class="codeline" id="line-717"><code>	// enabled because they must be enabled before</code></span>
<span class="codeline" id="line-718"><code>	// any non-leaf heap objects are marked. Since</code></span>
<span class="codeline" id="line-719"><code>	// allocations are blocked until assists can</code></span>
<span class="codeline" id="line-720"><code>	// happen, we want to enable assists as early as</code></span>
<span class="codeline" id="line-721"><code>	// possible.</code></span>
<span class="codeline" id="line-722"><code>	setGCPhase(_GCmark)</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>	gcBgMarkPrepare() // Must happen before assists are enabled.</code></span>
<span class="codeline" id="line-725"><code>	gcMarkRootPrepare()</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>	// Mark all active tinyalloc blocks. Since we're</code></span>
<span class="codeline" id="line-728"><code>	// allocating from these, they need to be black like</code></span>
<span class="codeline" id="line-729"><code>	// other allocations. The alternative is to blacken</code></span>
<span class="codeline" id="line-730"><code>	// the tiny block on every allocation from it, which</code></span>
<span class="codeline" id="line-731"><code>	// would slow down the tiny allocator.</code></span>
<span class="codeline" id="line-732"><code>	gcMarkTinyAllocs()</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>	// At this point all Ps have enabled the write</code></span>
<span class="codeline" id="line-735"><code>	// barrier, thus maintaining the no white to</code></span>
<span class="codeline" id="line-736"><code>	// black invariant. Enable mutator assists to</code></span>
<span class="codeline" id="line-737"><code>	// put back-pressure on fast allocating</code></span>
<span class="codeline" id="line-738"><code>	// mutators.</code></span>
<span class="codeline" id="line-739"><code>	atomic.Store(&amp;gcBlackenEnabled, 1)</code></span>
<span class="codeline" id="line-740"><code></code></span>
<span class="codeline" id="line-741"><code>	// In STW mode, we could block the instant systemstack</code></span>
<span class="codeline" id="line-742"><code>	// returns, so make sure we're not preemptible.</code></span>
<span class="codeline" id="line-743"><code>	mp = acquirem()</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>	// Concurrent mark.</code></span>
<span class="codeline" id="line-746"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-747"><code>		now = startTheWorldWithSema(0, stw)</code></span>
<span class="codeline" id="line-748"><code>		work.pauseNS += now - stw.start</code></span>
<span class="codeline" id="line-749"><code>		work.tMark = now</code></span>
<span class="codeline" id="line-750"><code></code></span>
<span class="codeline" id="line-751"><code>		sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)</code></span>
<span class="codeline" id="line-752"><code>		work.cpuStats.gcPauseTime += sweepTermCpu</code></span>
<span class="codeline" id="line-753"><code>		work.cpuStats.gcTotalTime += sweepTermCpu</code></span>
<span class="codeline" id="line-754"><code></code></span>
<span class="codeline" id="line-755"><code>		// Release the CPU limiter.</code></span>
<span class="codeline" id="line-756"><code>		gcCPULimiter.finishGCTransition(now)</code></span>
<span class="codeline" id="line-757"><code>	})</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>	// Release the world sema before Gosched() in STW mode</code></span>
<span class="codeline" id="line-760"><code>	// because we will need to reacquire it later but before</code></span>
<span class="codeline" id="line-761"><code>	// this goroutine becomes runnable again, and we could</code></span>
<span class="codeline" id="line-762"><code>	// self-deadlock otherwise.</code></span>
<span class="codeline" id="line-763"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-764"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>	// Make sure we block instead of returning to user code</code></span>
<span class="codeline" id="line-767"><code>	// in STW mode.</code></span>
<span class="codeline" id="line-768"><code>	if mode != gcBackgroundMode {</code></span>
<span class="codeline" id="line-769"><code>		Gosched()</code></span>
<span class="codeline" id="line-770"><code>	}</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>	semrelease(&amp;work.startSema)</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>// gcMarkDoneFlushed counts the number of P's with flushed work.</code></span>
<span class="codeline" id="line-776"><code>//</code></span>
<span class="codeline" id="line-777"><code>// Ideally this would be a captured local in gcMarkDone, but forEachP</code></span>
<span class="codeline" id="line-778"><code>// escapes its callback closure, so it can't capture anything.</code></span>
<span class="codeline" id="line-779"><code>//</code></span>
<span class="codeline" id="line-780"><code>// This is protected by markDoneSema.</code></span>
<span class="codeline" id="line-781"><code>var gcMarkDoneFlushed uint32</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>// gcMarkDone transitions the GC from mark to mark termination if all</code></span>
<span class="codeline" id="line-784"><code>// reachable objects have been marked (that is, there are no grey</code></span>
<span class="codeline" id="line-785"><code>// objects and can be no more in the future). Otherwise, it flushes</code></span>
<span class="codeline" id="line-786"><code>// all local work to the global queues where it can be discovered by</code></span>
<span class="codeline" id="line-787"><code>// other workers.</code></span>
<span class="codeline" id="line-788"><code>//</code></span>
<span class="codeline" id="line-789"><code>// This should be called when all local mark work has been drained and</code></span>
<span class="codeline" id="line-790"><code>// there are no remaining workers. Specifically, when</code></span>
<span class="codeline" id="line-791"><code>//</code></span>
<span class="codeline" id="line-792"><code>//	work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(p)</code></span>
<span class="codeline" id="line-793"><code>//</code></span>
<span class="codeline" id="line-794"><code>// The calling context must be preemptible.</code></span>
<span class="codeline" id="line-795"><code>//</code></span>
<span class="codeline" id="line-796"><code>// Flushing local work is important because idle Ps may have local</code></span>
<span class="codeline" id="line-797"><code>// work queued. This is the only way to make that work visible and</code></span>
<span class="codeline" id="line-798"><code>// drive GC to completion.</code></span>
<span class="codeline" id="line-799"><code>//</code></span>
<span class="codeline" id="line-800"><code>// It is explicitly okay to have write barriers in this function. If</code></span>
<span class="codeline" id="line-801"><code>// it does transition to mark termination, then all reachable objects</code></span>
<span class="codeline" id="line-802"><code>// have been marked, so the write barrier cannot shade any more</code></span>
<span class="codeline" id="line-803"><code>// objects.</code></span>
<span class="codeline" id="line-804"><code>func gcMarkDone() {</code></span>
<span class="codeline" id="line-805"><code>	// Ensure only one thread is running the ragged barrier at a</code></span>
<span class="codeline" id="line-806"><code>	// time.</code></span>
<span class="codeline" id="line-807"><code>	semacquire(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-808"><code></code></span>
<span class="codeline" id="line-809"><code>top:</code></span>
<span class="codeline" id="line-810"><code>	// Re-check transition condition under transition lock.</code></span>
<span class="codeline" id="line-811"><code>	//</code></span>
<span class="codeline" id="line-812"><code>	// It's critical that this checks the global work queues are</code></span>
<span class="codeline" id="line-813"><code>	// empty before performing the ragged barrier. Otherwise,</code></span>
<span class="codeline" id="line-814"><code>	// there could be global work that a P could take after the P</code></span>
<span class="codeline" id="line-815"><code>	// has passed the ragged barrier.</code></span>
<span class="codeline" id="line-816"><code>	if !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) {</code></span>
<span class="codeline" id="line-817"><code>		semrelease(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-818"><code>		return</code></span>
<span class="codeline" id="line-819"><code>	}</code></span>
<span class="codeline" id="line-820"><code></code></span>
<span class="codeline" id="line-821"><code>	// forEachP needs worldsema to execute, and we'll need it to</code></span>
<span class="codeline" id="line-822"><code>	// stop the world later, so acquire worldsema now.</code></span>
<span class="codeline" id="line-823"><code>	semacquire(&amp;worldsema)</code></span>
<span class="codeline" id="line-824"><code></code></span>
<span class="codeline" id="line-825"><code>	// Flush all local buffers and collect flushedWork flags.</code></span>
<span class="codeline" id="line-826"><code>	gcMarkDoneFlushed = 0</code></span>
<span class="codeline" id="line-827"><code>	forEachP(waitReasonGCMarkTermination, func(pp *p) {</code></span>
<span class="codeline" id="line-828"><code>		// Flush the write barrier buffer, since this may add</code></span>
<span class="codeline" id="line-829"><code>		// work to the gcWork.</code></span>
<span class="codeline" id="line-830"><code>		wbBufFlush1(pp)</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>		// Flush the gcWork, since this may create global work</code></span>
<span class="codeline" id="line-833"><code>		// and set the flushedWork flag.</code></span>
<span class="codeline" id="line-834"><code>		//</code></span>
<span class="codeline" id="line-835"><code>		// TODO(austin): Break up these workbufs to</code></span>
<span class="codeline" id="line-836"><code>		// better distribute work.</code></span>
<span class="codeline" id="line-837"><code>		pp.gcw.dispose()</code></span>
<span class="codeline" id="line-838"><code>		// Collect the flushedWork flag.</code></span>
<span class="codeline" id="line-839"><code>		if pp.gcw.flushedWork {</code></span>
<span class="codeline" id="line-840"><code>			atomic.Xadd(&amp;gcMarkDoneFlushed, 1)</code></span>
<span class="codeline" id="line-841"><code>			pp.gcw.flushedWork = false</code></span>
<span class="codeline" id="line-842"><code>		}</code></span>
<span class="codeline" id="line-843"><code>	})</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>	if gcMarkDoneFlushed != 0 {</code></span>
<span class="codeline" id="line-846"><code>		// More grey objects were discovered since the</code></span>
<span class="codeline" id="line-847"><code>		// previous termination check, so there may be more</code></span>
<span class="codeline" id="line-848"><code>		// work to do. Keep going. It's possible the</code></span>
<span class="codeline" id="line-849"><code>		// transition condition became true again during the</code></span>
<span class="codeline" id="line-850"><code>		// ragged barrier, so re-check it.</code></span>
<span class="codeline" id="line-851"><code>		semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-852"><code>		goto top</code></span>
<span class="codeline" id="line-853"><code>	}</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>	// There was no global work, no local work, and no Ps</code></span>
<span class="codeline" id="line-856"><code>	// communicated work since we took markDoneSema. Therefore</code></span>
<span class="codeline" id="line-857"><code>	// there are no grey objects and no more objects can be</code></span>
<span class="codeline" id="line-858"><code>	// shaded. Transition to mark termination.</code></span>
<span class="codeline" id="line-859"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-860"><code>	work.tMarkTerm = now</code></span>
<span class="codeline" id="line-861"><code>	getg().m.preemptoff = "gcing"</code></span>
<span class="codeline" id="line-862"><code>	var stw worldStop</code></span>
<span class="codeline" id="line-863"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-864"><code>		stw = stopTheWorldWithSema(stwGCMarkTerm)</code></span>
<span class="codeline" id="line-865"><code>	})</code></span>
<span class="codeline" id="line-866"><code>	// The gcphase is _GCmark, it will transition to _GCmarktermination</code></span>
<span class="codeline" id="line-867"><code>	// below. The important thing is that the wb remains active until</code></span>
<span class="codeline" id="line-868"><code>	// all marking is complete. This includes writes made by the GC.</code></span>
<span class="codeline" id="line-869"><code></code></span>
<span class="codeline" id="line-870"><code>	// There is sometimes work left over when we enter mark termination due</code></span>
<span class="codeline" id="line-871"><code>	// to write barriers performed after the completion barrier above.</code></span>
<span class="codeline" id="line-872"><code>	// Detect this and resume concurrent mark. This is obviously</code></span>
<span class="codeline" id="line-873"><code>	// unfortunate.</code></span>
<span class="codeline" id="line-874"><code>	//</code></span>
<span class="codeline" id="line-875"><code>	// See issue #27993 for details.</code></span>
<span class="codeline" id="line-876"><code>	//</code></span>
<span class="codeline" id="line-877"><code>	// Switch to the system stack to call wbBufFlush1, though in this case</code></span>
<span class="codeline" id="line-878"><code>	// it doesn't matter because we're non-preemptible anyway.</code></span>
<span class="codeline" id="line-879"><code>	restart := false</code></span>
<span class="codeline" id="line-880"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-881"><code>		for _, p := range allp {</code></span>
<span class="codeline" id="line-882"><code>			wbBufFlush1(p)</code></span>
<span class="codeline" id="line-883"><code>			if !p.gcw.empty() {</code></span>
<span class="codeline" id="line-884"><code>				restart = true</code></span>
<span class="codeline" id="line-885"><code>				break</code></span>
<span class="codeline" id="line-886"><code>			}</code></span>
<span class="codeline" id="line-887"><code>		}</code></span>
<span class="codeline" id="line-888"><code>	})</code></span>
<span class="codeline" id="line-889"><code>	if restart {</code></span>
<span class="codeline" id="line-890"><code>		getg().m.preemptoff = ""</code></span>
<span class="codeline" id="line-891"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-892"><code>			now := startTheWorldWithSema(0, stw)</code></span>
<span class="codeline" id="line-893"><code>			work.pauseNS += now - stw.start</code></span>
<span class="codeline" id="line-894"><code>		})</code></span>
<span class="codeline" id="line-895"><code>		semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-896"><code>		goto top</code></span>
<span class="codeline" id="line-897"><code>	}</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>	gcComputeStartingStackSize()</code></span>
<span class="codeline" id="line-900"><code></code></span>
<span class="codeline" id="line-901"><code>	// Disable assists and background workers. We must do</code></span>
<span class="codeline" id="line-902"><code>	// this before waking blocked assists.</code></span>
<span class="codeline" id="line-903"><code>	atomic.Store(&amp;gcBlackenEnabled, 0)</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>	// Notify the CPU limiter that GC assists will now cease.</code></span>
<span class="codeline" id="line-906"><code>	gcCPULimiter.startGCTransition(false, now)</code></span>
<span class="codeline" id="line-907"><code></code></span>
<span class="codeline" id="line-908"><code>	// Wake all blocked assists. These will run when we</code></span>
<span class="codeline" id="line-909"><code>	// start the world again.</code></span>
<span class="codeline" id="line-910"><code>	gcWakeAllAssists()</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>	// Likewise, release the transition lock. Blocked</code></span>
<span class="codeline" id="line-913"><code>	// workers and assists will run when we start the</code></span>
<span class="codeline" id="line-914"><code>	// world again.</code></span>
<span class="codeline" id="line-915"><code>	semrelease(&amp;work.markDoneSema)</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>	// In STW mode, re-enable user goroutines. These will be</code></span>
<span class="codeline" id="line-918"><code>	// queued to run after we start the world.</code></span>
<span class="codeline" id="line-919"><code>	schedEnableUser(true)</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>	// endCycle depends on all gcWork cache stats being flushed.</code></span>
<span class="codeline" id="line-922"><code>	// The termination algorithm above ensured that up to</code></span>
<span class="codeline" id="line-923"><code>	// allocations since the ragged barrier.</code></span>
<span class="codeline" id="line-924"><code>	gcController.endCycle(now, int(gomaxprocs), work.userForced)</code></span>
<span class="codeline" id="line-925"><code></code></span>
<span class="codeline" id="line-926"><code>	// Perform mark termination. This will restart the world.</code></span>
<span class="codeline" id="line-927"><code>	gcMarkTermination(stw)</code></span>
<span class="codeline" id="line-928"><code>}</code></span>
<span class="codeline" id="line-929"><code></code></span>
<span class="codeline" id="line-930"><code>// World must be stopped and mark assists and background workers must be</code></span>
<span class="codeline" id="line-931"><code>// disabled.</code></span>
<span class="codeline" id="line-932"><code>func gcMarkTermination(stw worldStop) {</code></span>
<span class="codeline" id="line-933"><code>	// Start marktermination (write barrier remains enabled for now).</code></span>
<span class="codeline" id="line-934"><code>	setGCPhase(_GCmarktermination)</code></span>
<span class="codeline" id="line-935"><code></code></span>
<span class="codeline" id="line-936"><code>	work.heap1 = gcController.heapLive.Load()</code></span>
<span class="codeline" id="line-937"><code>	startTime := nanotime()</code></span>
<span class="codeline" id="line-938"><code></code></span>
<span class="codeline" id="line-939"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-940"><code>	mp.preemptoff = "gcing"</code></span>
<span class="codeline" id="line-941"><code>	mp.traceback = 2</code></span>
<span class="codeline" id="line-942"><code>	curgp := mp.curg</code></span>
<span class="codeline" id="line-943"><code>	// N.B. The execution tracer is not aware of this status</code></span>
<span class="codeline" id="line-944"><code>	// transition and handles it specially based on the</code></span>
<span class="codeline" id="line-945"><code>	// wait reason.</code></span>
<span class="codeline" id="line-946"><code>	casGToWaiting(curgp, _Grunning, waitReasonGarbageCollection)</code></span>
<span class="codeline" id="line-947"><code></code></span>
<span class="codeline" id="line-948"><code>	// Run gc on the g0 stack. We do this so that the g stack</code></span>
<span class="codeline" id="line-949"><code>	// we're currently running on will no longer change. Cuts</code></span>
<span class="codeline" id="line-950"><code>	// the root set down a bit (g0 stacks are not scanned, and</code></span>
<span class="codeline" id="line-951"><code>	// we don't need to scan gc's internal state).  We also</code></span>
<span class="codeline" id="line-952"><code>	// need to switch to g0 so we can shrink the stack.</code></span>
<span class="codeline" id="line-953"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-954"><code>		gcMark(startTime)</code></span>
<span class="codeline" id="line-955"><code>		// Must return immediately.</code></span>
<span class="codeline" id="line-956"><code>		// The outer function's stack may have moved</code></span>
<span class="codeline" id="line-957"><code>		// during gcMark (it shrinks stacks, including the</code></span>
<span class="codeline" id="line-958"><code>		// outer function's stack), so we must not refer</code></span>
<span class="codeline" id="line-959"><code>		// to any of its variables. Return back to the</code></span>
<span class="codeline" id="line-960"><code>		// non-system stack to pick up the new addresses</code></span>
<span class="codeline" id="line-961"><code>		// before continuing.</code></span>
<span class="codeline" id="line-962"><code>	})</code></span>
<span class="codeline" id="line-963"><code></code></span>
<span class="codeline" id="line-964"><code>	var stwSwept bool</code></span>
<span class="codeline" id="line-965"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-966"><code>		work.heap2 = work.bytesMarked</code></span>
<span class="codeline" id="line-967"><code>		if debug.gccheckmark &gt; 0 {</code></span>
<span class="codeline" id="line-968"><code>			// Run a full non-parallel, stop-the-world</code></span>
<span class="codeline" id="line-969"><code>			// mark using checkmark bits, to check that we</code></span>
<span class="codeline" id="line-970"><code>			// didn't forget to mark anything during the</code></span>
<span class="codeline" id="line-971"><code>			// concurrent mark process.</code></span>
<span class="codeline" id="line-972"><code>			startCheckmarks()</code></span>
<span class="codeline" id="line-973"><code>			gcResetMarkState()</code></span>
<span class="codeline" id="line-974"><code>			gcw := &amp;getg().m.p.ptr().gcw</code></span>
<span class="codeline" id="line-975"><code>			gcDrain(gcw, 0)</code></span>
<span class="codeline" id="line-976"><code>			wbBufFlush1(getg().m.p.ptr())</code></span>
<span class="codeline" id="line-977"><code>			gcw.dispose()</code></span>
<span class="codeline" id="line-978"><code>			endCheckmarks()</code></span>
<span class="codeline" id="line-979"><code>		}</code></span>
<span class="codeline" id="line-980"><code></code></span>
<span class="codeline" id="line-981"><code>		// marking is complete so we can turn the write barrier off</code></span>
<span class="codeline" id="line-982"><code>		setGCPhase(_GCoff)</code></span>
<span class="codeline" id="line-983"><code>		stwSwept = gcSweep(work.mode)</code></span>
<span class="codeline" id="line-984"><code>	})</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>	mp.traceback = 0</code></span>
<span class="codeline" id="line-987"><code>	casgstatus(curgp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-988"><code></code></span>
<span class="codeline" id="line-989"><code>	trace := traceAcquire()</code></span>
<span class="codeline" id="line-990"><code>	if trace.ok() {</code></span>
<span class="codeline" id="line-991"><code>		trace.GCDone()</code></span>
<span class="codeline" id="line-992"><code>		traceRelease(trace)</code></span>
<span class="codeline" id="line-993"><code>	}</code></span>
<span class="codeline" id="line-994"><code></code></span>
<span class="codeline" id="line-995"><code>	// all done</code></span>
<span class="codeline" id="line-996"><code>	mp.preemptoff = ""</code></span>
<span class="codeline" id="line-997"><code></code></span>
<span class="codeline" id="line-998"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-999"><code>		throw("gc done but gcphase != _GCoff")</code></span>
<span class="codeline" id="line-1000"><code>	}</code></span>
<span class="codeline" id="line-1001"><code></code></span>
<span class="codeline" id="line-1002"><code>	// Record heapInUse for scavenger.</code></span>
<span class="codeline" id="line-1003"><code>	memstats.lastHeapInUse = gcController.heapInUse.load()</code></span>
<span class="codeline" id="line-1004"><code></code></span>
<span class="codeline" id="line-1005"><code>	// Update GC trigger and pacing, as well as downstream consumers</code></span>
<span class="codeline" id="line-1006"><code>	// of this pacing information, for the next cycle.</code></span>
<span class="codeline" id="line-1007"><code>	systemstack(gcControllerCommit)</code></span>
<span class="codeline" id="line-1008"><code></code></span>
<span class="codeline" id="line-1009"><code>	// Update timing memstats</code></span>
<span class="codeline" id="line-1010"><code>	now := nanotime()</code></span>
<span class="codeline" id="line-1011"><code>	sec, nsec, _ := time_now()</code></span>
<span class="codeline" id="line-1012"><code>	unixNow := sec*1e9 + int64(nsec)</code></span>
<span class="codeline" id="line-1013"><code>	work.pauseNS += now - stw.start</code></span>
<span class="codeline" id="line-1014"><code>	work.tEnd = now</code></span>
<span class="codeline" id="line-1015"><code>	atomic.Store64(&amp;memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user</code></span>
<span class="codeline" id="line-1016"><code>	atomic.Store64(&amp;memstats.last_gc_nanotime, uint64(now)) // monotonic time for us</code></span>
<span class="codeline" id="line-1017"><code>	memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)</code></span>
<span class="codeline" id="line-1018"><code>	memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)</code></span>
<span class="codeline" id="line-1019"><code>	memstats.pause_total_ns += uint64(work.pauseNS)</code></span>
<span class="codeline" id="line-1020"><code></code></span>
<span class="codeline" id="line-1021"><code>	markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)</code></span>
<span class="codeline" id="line-1022"><code>	work.cpuStats.gcPauseTime += markTermCpu</code></span>
<span class="codeline" id="line-1023"><code>	work.cpuStats.gcTotalTime += markTermCpu</code></span>
<span class="codeline" id="line-1024"><code></code></span>
<span class="codeline" id="line-1025"><code>	// Accumulate CPU stats.</code></span>
<span class="codeline" id="line-1026"><code>	//</code></span>
<span class="codeline" id="line-1027"><code>	// Pass gcMarkPhase=true so we can get all the latest GC CPU stats in there too.</code></span>
<span class="codeline" id="line-1028"><code>	work.cpuStats.accumulate(now, true)</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>	// Compute overall GC CPU utilization.</code></span>
<span class="codeline" id="line-1031"><code>	// Omit idle marking time from the overall utilization here since it's "free".</code></span>
<span class="codeline" id="line-1032"><code>	memstats.gc_cpu_fraction = float64(work.cpuStats.gcTotalTime-work.cpuStats.gcIdleTime) / float64(work.cpuStats.totalTime)</code></span>
<span class="codeline" id="line-1033"><code></code></span>
<span class="codeline" id="line-1034"><code>	// Reset assist time and background time stats.</code></span>
<span class="codeline" id="line-1035"><code>	//</code></span>
<span class="codeline" id="line-1036"><code>	// Do this now, instead of at the start of the next GC cycle, because</code></span>
<span class="codeline" id="line-1037"><code>	// these two may keep accumulating even if the GC is not active.</code></span>
<span class="codeline" id="line-1038"><code>	scavenge.assistTime.Store(0)</code></span>
<span class="codeline" id="line-1039"><code>	scavenge.backgroundTime.Store(0)</code></span>
<span class="codeline" id="line-1040"><code></code></span>
<span class="codeline" id="line-1041"><code>	// Reset idle time stat.</code></span>
<span class="codeline" id="line-1042"><code>	sched.idleTime.Store(0)</code></span>
<span class="codeline" id="line-1043"><code></code></span>
<span class="codeline" id="line-1044"><code>	if work.userForced {</code></span>
<span class="codeline" id="line-1045"><code>		memstats.numforcedgc++</code></span>
<span class="codeline" id="line-1046"><code>	}</code></span>
<span class="codeline" id="line-1047"><code></code></span>
<span class="codeline" id="line-1048"><code>	// Bump GC cycle count and wake goroutines waiting on sweep.</code></span>
<span class="codeline" id="line-1049"><code>	lock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1050"><code>	memstats.numgc++</code></span>
<span class="codeline" id="line-1051"><code>	injectglist(&amp;work.sweepWaiters.list)</code></span>
<span class="codeline" id="line-1052"><code>	unlock(&amp;work.sweepWaiters.lock)</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>	// Increment the scavenge generation now.</code></span>
<span class="codeline" id="line-1055"><code>	//</code></span>
<span class="codeline" id="line-1056"><code>	// This moment represents peak heap in use because we're</code></span>
<span class="codeline" id="line-1057"><code>	// about to start sweeping.</code></span>
<span class="codeline" id="line-1058"><code>	mheap_.pages.scav.index.nextGen()</code></span>
<span class="codeline" id="line-1059"><code></code></span>
<span class="codeline" id="line-1060"><code>	// Release the CPU limiter.</code></span>
<span class="codeline" id="line-1061"><code>	gcCPULimiter.finishGCTransition(now)</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>	// Finish the current heap profiling cycle and start a new</code></span>
<span class="codeline" id="line-1064"><code>	// heap profiling cycle. We do this before starting the world</code></span>
<span class="codeline" id="line-1065"><code>	// so events don't leak into the wrong cycle.</code></span>
<span class="codeline" id="line-1066"><code>	mProf_NextCycle()</code></span>
<span class="codeline" id="line-1067"><code></code></span>
<span class="codeline" id="line-1068"><code>	// There may be stale spans in mcaches that need to be swept.</code></span>
<span class="codeline" id="line-1069"><code>	// Those aren't tracked in any sweep lists, so we need to</code></span>
<span class="codeline" id="line-1070"><code>	// count them against sweep completion until we ensure all</code></span>
<span class="codeline" id="line-1071"><code>	// those spans have been forced out.</code></span>
<span class="codeline" id="line-1072"><code>	//</code></span>
<span class="codeline" id="line-1073"><code>	// If gcSweep fully swept the heap (for example if the sweep</code></span>
<span class="codeline" id="line-1074"><code>	// is not concurrent due to a GODEBUG setting), then we expect</code></span>
<span class="codeline" id="line-1075"><code>	// the sweepLocker to be invalid, since sweeping is done.</code></span>
<span class="codeline" id="line-1076"><code>	//</code></span>
<span class="codeline" id="line-1077"><code>	// N.B. Below we might duplicate some work from gcSweep; this is</code></span>
<span class="codeline" id="line-1078"><code>	// fine as all that work is idempotent within a GC cycle, and</code></span>
<span class="codeline" id="line-1079"><code>	// we're still holding worldsema so a new cycle can't start.</code></span>
<span class="codeline" id="line-1080"><code>	sl := sweep.active.begin()</code></span>
<span class="codeline" id="line-1081"><code>	if !stwSwept &amp;&amp; !sl.valid {</code></span>
<span class="codeline" id="line-1082"><code>		throw("failed to set sweep barrier")</code></span>
<span class="codeline" id="line-1083"><code>	} else if stwSwept &amp;&amp; sl.valid {</code></span>
<span class="codeline" id="line-1084"><code>		throw("non-concurrent sweep failed to drain all sweep queues")</code></span>
<span class="codeline" id="line-1085"><code>	}</code></span>
<span class="codeline" id="line-1086"><code></code></span>
<span class="codeline" id="line-1087"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-1088"><code>		// The memstats updated above must be updated with the world</code></span>
<span class="codeline" id="line-1089"><code>		// stopped to ensure consistency of some values, such as</code></span>
<span class="codeline" id="line-1090"><code>		// sched.idleTime and sched.totaltime. memstats also include</code></span>
<span class="codeline" id="line-1091"><code>		// the pause time (work,pauseNS), forcing computation of the</code></span>
<span class="codeline" id="line-1092"><code>		// total pause time before the pause actually ends.</code></span>
<span class="codeline" id="line-1093"><code>		//</code></span>
<span class="codeline" id="line-1094"><code>		// Here we reuse the same now for start the world so that the</code></span>
<span class="codeline" id="line-1095"><code>		// time added to /sched/pauses/total/gc:seconds will be</code></span>
<span class="codeline" id="line-1096"><code>		// consistent with the value in memstats.</code></span>
<span class="codeline" id="line-1097"><code>		startTheWorldWithSema(now, stw)</code></span>
<span class="codeline" id="line-1098"><code>	})</code></span>
<span class="codeline" id="line-1099"><code></code></span>
<span class="codeline" id="line-1100"><code>	// Flush the heap profile so we can start a new cycle next GC.</code></span>
<span class="codeline" id="line-1101"><code>	// This is relatively expensive, so we don't do it with the</code></span>
<span class="codeline" id="line-1102"><code>	// world stopped.</code></span>
<span class="codeline" id="line-1103"><code>	mProf_Flush()</code></span>
<span class="codeline" id="line-1104"><code></code></span>
<span class="codeline" id="line-1105"><code>	// Prepare workbufs for freeing by the sweeper. We do this</code></span>
<span class="codeline" id="line-1106"><code>	// asynchronously because it can take non-trivial time.</code></span>
<span class="codeline" id="line-1107"><code>	prepareFreeWorkbufs()</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>	// Free stack spans. This must be done between GC cycles.</code></span>
<span class="codeline" id="line-1110"><code>	systemstack(freeStackSpans)</code></span>
<span class="codeline" id="line-1111"><code></code></span>
<span class="codeline" id="line-1112"><code>	// Ensure all mcaches are flushed. Each P will flush its own</code></span>
<span class="codeline" id="line-1113"><code>	// mcache before allocating, but idle Ps may not. Since this</code></span>
<span class="codeline" id="line-1114"><code>	// is necessary to sweep all spans, we need to ensure all</code></span>
<span class="codeline" id="line-1115"><code>	// mcaches are flushed before we start the next GC cycle.</code></span>
<span class="codeline" id="line-1116"><code>	//</code></span>
<span class="codeline" id="line-1117"><code>	// While we're here, flush the page cache for idle Ps to avoid</code></span>
<span class="codeline" id="line-1118"><code>	// having pages get stuck on them. These pages are hidden from</code></span>
<span class="codeline" id="line-1119"><code>	// the scavenger, so in small idle heaps a significant amount</code></span>
<span class="codeline" id="line-1120"><code>	// of additional memory might be held onto.</code></span>
<span class="codeline" id="line-1121"><code>	//</code></span>
<span class="codeline" id="line-1122"><code>	// Also, flush the pinner cache, to avoid leaking that memory</code></span>
<span class="codeline" id="line-1123"><code>	// indefinitely.</code></span>
<span class="codeline" id="line-1124"><code>	forEachP(waitReasonFlushProcCaches, func(pp *p) {</code></span>
<span class="codeline" id="line-1125"><code>		pp.mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-1126"><code>		if pp.status == _Pidle {</code></span>
<span class="codeline" id="line-1127"><code>			systemstack(func() {</code></span>
<span class="codeline" id="line-1128"><code>				lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1129"><code>				pp.pcache.flush(&amp;mheap_.pages)</code></span>
<span class="codeline" id="line-1130"><code>				unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1131"><code>			})</code></span>
<span class="codeline" id="line-1132"><code>		}</code></span>
<span class="codeline" id="line-1133"><code>		pp.pinnerCache = nil</code></span>
<span class="codeline" id="line-1134"><code>	})</code></span>
<span class="codeline" id="line-1135"><code>	if sl.valid {</code></span>
<span class="codeline" id="line-1136"><code>		// Now that we've swept stale spans in mcaches, they don't</code></span>
<span class="codeline" id="line-1137"><code>		// count against unswept spans.</code></span>
<span class="codeline" id="line-1138"><code>		//</code></span>
<span class="codeline" id="line-1139"><code>		// Note: this sweepLocker may not be valid if sweeping had</code></span>
<span class="codeline" id="line-1140"><code>		// already completed during the STW. See the corresponding</code></span>
<span class="codeline" id="line-1141"><code>		// begin() call that produced sl.</code></span>
<span class="codeline" id="line-1142"><code>		sweep.active.end(sl)</code></span>
<span class="codeline" id="line-1143"><code>	}</code></span>
<span class="codeline" id="line-1144"><code></code></span>
<span class="codeline" id="line-1145"><code>	// Print gctrace before dropping worldsema. As soon as we drop</code></span>
<span class="codeline" id="line-1146"><code>	// worldsema another cycle could start and smash the stats</code></span>
<span class="codeline" id="line-1147"><code>	// we're trying to print.</code></span>
<span class="codeline" id="line-1148"><code>	if debug.gctrace &gt; 0 {</code></span>
<span class="codeline" id="line-1149"><code>		util := int(memstats.gc_cpu_fraction * 100)</code></span>
<span class="codeline" id="line-1150"><code></code></span>
<span class="codeline" id="line-1151"><code>		var sbuf [24]byte</code></span>
<span class="codeline" id="line-1152"><code>		printlock()</code></span>
<span class="codeline" id="line-1153"><code>		print("gc ", memstats.numgc,</code></span>
<span class="codeline" id="line-1154"><code>			" @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",</code></span>
<span class="codeline" id="line-1155"><code>			util, "%: ")</code></span>
<span class="codeline" id="line-1156"><code>		prev := work.tSweepTerm</code></span>
<span class="codeline" id="line-1157"><code>		for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {</code></span>
<span class="codeline" id="line-1158"><code>			if i != 0 {</code></span>
<span class="codeline" id="line-1159"><code>				print("+")</code></span>
<span class="codeline" id="line-1160"><code>			}</code></span>
<span class="codeline" id="line-1161"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))</code></span>
<span class="codeline" id="line-1162"><code>			prev = ns</code></span>
<span class="codeline" id="line-1163"><code>		}</code></span>
<span class="codeline" id="line-1164"><code>		print(" ms clock, ")</code></span>
<span class="codeline" id="line-1165"><code>		for i, ns := range []int64{</code></span>
<span class="codeline" id="line-1166"><code>			int64(work.stwprocs) * (work.tMark - work.tSweepTerm),</code></span>
<span class="codeline" id="line-1167"><code>			gcController.assistTime.Load(),</code></span>
<span class="codeline" id="line-1168"><code>			gcController.dedicatedMarkTime.Load() + gcController.fractionalMarkTime.Load(),</code></span>
<span class="codeline" id="line-1169"><code>			gcController.idleMarkTime.Load(),</code></span>
<span class="codeline" id="line-1170"><code>			markTermCpu,</code></span>
<span class="codeline" id="line-1171"><code>		} {</code></span>
<span class="codeline" id="line-1172"><code>			if i == 2 || i == 3 {</code></span>
<span class="codeline" id="line-1173"><code>				// Separate mark time components with /.</code></span>
<span class="codeline" id="line-1174"><code>				print("/")</code></span>
<span class="codeline" id="line-1175"><code>			} else if i != 0 {</code></span>
<span class="codeline" id="line-1176"><code>				print("+")</code></span>
<span class="codeline" id="line-1177"><code>			}</code></span>
<span class="codeline" id="line-1178"><code>			print(string(fmtNSAsMS(sbuf[:], uint64(ns))))</code></span>
<span class="codeline" id="line-1179"><code>		}</code></span>
<span class="codeline" id="line-1180"><code>		print(" ms cpu, ",</code></span>
<span class="codeline" id="line-1181"><code>			work.heap0&gt;&gt;20, "-&gt;", work.heap1&gt;&gt;20, "-&gt;", work.heap2&gt;&gt;20, " MB, ",</code></span>
<span class="codeline" id="line-1182"><code>			gcController.lastHeapGoal&gt;&gt;20, " MB goal, ",</code></span>
<span class="codeline" id="line-1183"><code>			gcController.lastStackScan.Load()&gt;&gt;20, " MB stacks, ",</code></span>
<span class="codeline" id="line-1184"><code>			gcController.globalsScan.Load()&gt;&gt;20, " MB globals, ",</code></span>
<span class="codeline" id="line-1185"><code>			work.maxprocs, " P")</code></span>
<span class="codeline" id="line-1186"><code>		if work.userForced {</code></span>
<span class="codeline" id="line-1187"><code>			print(" (forced)")</code></span>
<span class="codeline" id="line-1188"><code>		}</code></span>
<span class="codeline" id="line-1189"><code>		print("\n")</code></span>
<span class="codeline" id="line-1190"><code>		printunlock()</code></span>
<span class="codeline" id="line-1191"><code>	}</code></span>
<span class="codeline" id="line-1192"><code></code></span>
<span class="codeline" id="line-1193"><code>	// Set any arena chunks that were deferred to fault.</code></span>
<span class="codeline" id="line-1194"><code>	lock(&amp;userArenaState.lock)</code></span>
<span class="codeline" id="line-1195"><code>	faultList := userArenaState.fault</code></span>
<span class="codeline" id="line-1196"><code>	userArenaState.fault = nil</code></span>
<span class="codeline" id="line-1197"><code>	unlock(&amp;userArenaState.lock)</code></span>
<span class="codeline" id="line-1198"><code>	for _, lc := range faultList {</code></span>
<span class="codeline" id="line-1199"><code>		lc.mspan.setUserArenaChunkToFault()</code></span>
<span class="codeline" id="line-1200"><code>	}</code></span>
<span class="codeline" id="line-1201"><code></code></span>
<span class="codeline" id="line-1202"><code>	// Enable huge pages on some metadata if we cross a heap threshold.</code></span>
<span class="codeline" id="line-1203"><code>	if gcController.heapGoal() &gt; minHeapForMetadataHugePages {</code></span>
<span class="codeline" id="line-1204"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-1205"><code>			mheap_.enableMetadataHugePages()</code></span>
<span class="codeline" id="line-1206"><code>		})</code></span>
<span class="codeline" id="line-1207"><code>	}</code></span>
<span class="codeline" id="line-1208"><code></code></span>
<span class="codeline" id="line-1209"><code>	semrelease(&amp;worldsema)</code></span>
<span class="codeline" id="line-1210"><code>	semrelease(&amp;gcsema)</code></span>
<span class="codeline" id="line-1211"><code>	// Careful: another GC cycle may start now.</code></span>
<span class="codeline" id="line-1212"><code></code></span>
<span class="codeline" id="line-1213"><code>	releasem(mp)</code></span>
<span class="codeline" id="line-1214"><code>	mp = nil</code></span>
<span class="codeline" id="line-1215"><code></code></span>
<span class="codeline" id="line-1216"><code>	// now that gc is done, kick off finalizer thread if needed</code></span>
<span class="codeline" id="line-1217"><code>	if !concurrentSweep {</code></span>
<span class="codeline" id="line-1218"><code>		// give the queued finalizers, if any, a chance to run</code></span>
<span class="codeline" id="line-1219"><code>		Gosched()</code></span>
<span class="codeline" id="line-1220"><code>	}</code></span>
<span class="codeline" id="line-1221"><code>}</code></span>
<span class="codeline" id="line-1222"><code></code></span>
<span class="codeline" id="line-1223"><code>// gcBgMarkStartWorkers prepares background mark worker goroutines. These</code></span>
<span class="codeline" id="line-1224"><code>// goroutines will not run until the mark phase, but they must be started while</code></span>
<span class="codeline" id="line-1225"><code>// the work is not stopped and from a regular G stack. The caller must hold</code></span>
<span class="codeline" id="line-1226"><code>// worldsema.</code></span>
<span class="codeline" id="line-1227"><code>func gcBgMarkStartWorkers() {</code></span>
<span class="codeline" id="line-1228"><code>	// Background marking is performed by per-P G's. Ensure that each P has</code></span>
<span class="codeline" id="line-1229"><code>	// a background GC G.</code></span>
<span class="codeline" id="line-1230"><code>	//</code></span>
<span class="codeline" id="line-1231"><code>	// Worker Gs don't exit if gomaxprocs is reduced. If it is raised</code></span>
<span class="codeline" id="line-1232"><code>	// again, we can reuse the old workers; no need to create new workers.</code></span>
<span class="codeline" id="line-1233"><code>	for gcBgMarkWorkerCount &lt; gomaxprocs {</code></span>
<span class="codeline" id="line-1234"><code>		go gcBgMarkWorker()</code></span>
<span class="codeline" id="line-1235"><code></code></span>
<span class="codeline" id="line-1236"><code>		notetsleepg(&amp;work.bgMarkReady, -1)</code></span>
<span class="codeline" id="line-1237"><code>		noteclear(&amp;work.bgMarkReady)</code></span>
<span class="codeline" id="line-1238"><code>		// The worker is now guaranteed to be added to the pool before</code></span>
<span class="codeline" id="line-1239"><code>		// its P's next findRunnableGCWorker.</code></span>
<span class="codeline" id="line-1240"><code></code></span>
<span class="codeline" id="line-1241"><code>		gcBgMarkWorkerCount++</code></span>
<span class="codeline" id="line-1242"><code>	}</code></span>
<span class="codeline" id="line-1243"><code>}</code></span>
<span class="codeline" id="line-1244"><code></code></span>
<span class="codeline" id="line-1245"><code>// gcBgMarkPrepare sets up state for background marking.</code></span>
<span class="codeline" id="line-1246"><code>// Mutator assists must not yet be enabled.</code></span>
<span class="codeline" id="line-1247"><code>func gcBgMarkPrepare() {</code></span>
<span class="codeline" id="line-1248"><code>	// Background marking will stop when the work queues are empty</code></span>
<span class="codeline" id="line-1249"><code>	// and there are no more workers (note that, since this is</code></span>
<span class="codeline" id="line-1250"><code>	// concurrent, this may be a transient state, but mark</code></span>
<span class="codeline" id="line-1251"><code>	// termination will clean it up). Between background workers</code></span>
<span class="codeline" id="line-1252"><code>	// and assists, we don't really know how many workers there</code></span>
<span class="codeline" id="line-1253"><code>	// will be, so we pretend to have an arbitrarily large number</code></span>
<span class="codeline" id="line-1254"><code>	// of workers, almost all of which are "waiting". While a</code></span>
<span class="codeline" id="line-1255"><code>	// worker is working it decrements nwait. If nproc == nwait,</code></span>
<span class="codeline" id="line-1256"><code>	// there are no workers.</code></span>
<span class="codeline" id="line-1257"><code>	work.nproc = ^uint32(0)</code></span>
<span class="codeline" id="line-1258"><code>	work.nwait = ^uint32(0)</code></span>
<span class="codeline" id="line-1259"><code>}</code></span>
<span class="codeline" id="line-1260"><code></code></span>
<span class="codeline" id="line-1261"><code>// gcBgMarkWorkerNode is an entry in the gcBgMarkWorkerPool. It points to a single</code></span>
<span class="codeline" id="line-1262"><code>// gcBgMarkWorker goroutine.</code></span>
<span class="codeline" id="line-1263"><code>type gcBgMarkWorkerNode struct {</code></span>
<span class="codeline" id="line-1264"><code>	// Unused workers are managed in a lock-free stack. This field must be first.</code></span>
<span class="codeline" id="line-1265"><code>	node lfnode</code></span>
<span class="codeline" id="line-1266"><code></code></span>
<span class="codeline" id="line-1267"><code>	// The g of this worker.</code></span>
<span class="codeline" id="line-1268"><code>	gp guintptr</code></span>
<span class="codeline" id="line-1269"><code></code></span>
<span class="codeline" id="line-1270"><code>	// Release this m on park. This is used to communicate with the unlock</code></span>
<span class="codeline" id="line-1271"><code>	// function, which cannot access the G's stack. It is unused outside of</code></span>
<span class="codeline" id="line-1272"><code>	// gcBgMarkWorker().</code></span>
<span class="codeline" id="line-1273"><code>	m muintptr</code></span>
<span class="codeline" id="line-1274"><code>}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>func gcBgMarkWorker() {</code></span>
<span class="codeline" id="line-1277"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1278"><code></code></span>
<span class="codeline" id="line-1279"><code>	// We pass node to a gopark unlock function, so it can't be on</code></span>
<span class="codeline" id="line-1280"><code>	// the stack (see gopark). Prevent deadlock from recursively</code></span>
<span class="codeline" id="line-1281"><code>	// starting GC by disabling preemption.</code></span>
<span class="codeline" id="line-1282"><code>	gp.m.preemptoff = "GC worker init"</code></span>
<span class="codeline" id="line-1283"><code>	node := new(gcBgMarkWorkerNode)</code></span>
<span class="codeline" id="line-1284"><code>	gp.m.preemptoff = ""</code></span>
<span class="codeline" id="line-1285"><code></code></span>
<span class="codeline" id="line-1286"><code>	node.gp.set(gp)</code></span>
<span class="codeline" id="line-1287"><code></code></span>
<span class="codeline" id="line-1288"><code>	node.m.set(acquirem())</code></span>
<span class="codeline" id="line-1289"><code>	notewakeup(&amp;work.bgMarkReady)</code></span>
<span class="codeline" id="line-1290"><code>	// After this point, the background mark worker is generally scheduled</code></span>
<span class="codeline" id="line-1291"><code>	// cooperatively by gcController.findRunnableGCWorker. While performing</code></span>
<span class="codeline" id="line-1292"><code>	// work on the P, preemption is disabled because we are working on</code></span>
<span class="codeline" id="line-1293"><code>	// P-local work buffers. When the preempt flag is set, this puts itself</code></span>
<span class="codeline" id="line-1294"><code>	// into _Gwaiting to be woken up by gcController.findRunnableGCWorker</code></span>
<span class="codeline" id="line-1295"><code>	// at the appropriate time.</code></span>
<span class="codeline" id="line-1296"><code>	//</code></span>
<span class="codeline" id="line-1297"><code>	// When preemption is enabled (e.g., while in gcMarkDone), this worker</code></span>
<span class="codeline" id="line-1298"><code>	// may be preempted and schedule as a _Grunnable G from a runq. That is</code></span>
<span class="codeline" id="line-1299"><code>	// fine; it will eventually gopark again for further scheduling via</code></span>
<span class="codeline" id="line-1300"><code>	// findRunnableGCWorker.</code></span>
<span class="codeline" id="line-1301"><code>	//</code></span>
<span class="codeline" id="line-1302"><code>	// Since we disable preemption before notifying bgMarkReady, we</code></span>
<span class="codeline" id="line-1303"><code>	// guarantee that this G will be in the worker pool for the next</code></span>
<span class="codeline" id="line-1304"><code>	// findRunnableGCWorker. This isn't strictly necessary, but it reduces</code></span>
<span class="codeline" id="line-1305"><code>	// latency between _GCmark starting and the workers starting.</code></span>
<span class="codeline" id="line-1306"><code></code></span>
<span class="codeline" id="line-1307"><code>	for {</code></span>
<span class="codeline" id="line-1308"><code>		// Go to sleep until woken by</code></span>
<span class="codeline" id="line-1309"><code>		// gcController.findRunnableGCWorker.</code></span>
<span class="codeline" id="line-1310"><code>		gopark(func(g *g, nodep unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-1311"><code>			node := (*gcBgMarkWorkerNode)(nodep)</code></span>
<span class="codeline" id="line-1312"><code></code></span>
<span class="codeline" id="line-1313"><code>			if mp := node.m.ptr(); mp != nil {</code></span>
<span class="codeline" id="line-1314"><code>				// The worker G is no longer running; release</code></span>
<span class="codeline" id="line-1315"><code>				// the M.</code></span>
<span class="codeline" id="line-1316"><code>				//</code></span>
<span class="codeline" id="line-1317"><code>				// N.B. it is _safe_ to release the M as soon</code></span>
<span class="codeline" id="line-1318"><code>				// as we are no longer performing P-local mark</code></span>
<span class="codeline" id="line-1319"><code>				// work.</code></span>
<span class="codeline" id="line-1320"><code>				//</code></span>
<span class="codeline" id="line-1321"><code>				// However, since we cooperatively stop work</code></span>
<span class="codeline" id="line-1322"><code>				// when gp.preempt is set, if we releasem in</code></span>
<span class="codeline" id="line-1323"><code>				// the loop then the following call to gopark</code></span>
<span class="codeline" id="line-1324"><code>				// would immediately preempt the G. This is</code></span>
<span class="codeline" id="line-1325"><code>				// also safe, but inefficient: the G must</code></span>
<span class="codeline" id="line-1326"><code>				// schedule again only to enter gopark and park</code></span>
<span class="codeline" id="line-1327"><code>				// again. Thus, we defer the release until</code></span>
<span class="codeline" id="line-1328"><code>				// after parking the G.</code></span>
<span class="codeline" id="line-1329"><code>				releasem(mp)</code></span>
<span class="codeline" id="line-1330"><code>			}</code></span>
<span class="codeline" id="line-1331"><code></code></span>
<span class="codeline" id="line-1332"><code>			// Release this G to the pool.</code></span>
<span class="codeline" id="line-1333"><code>			gcBgMarkWorkerPool.push(&amp;node.node)</code></span>
<span class="codeline" id="line-1334"><code>			// Note that at this point, the G may immediately be</code></span>
<span class="codeline" id="line-1335"><code>			// rescheduled and may be running.</code></span>
<span class="codeline" id="line-1336"><code>			return true</code></span>
<span class="codeline" id="line-1337"><code>		}, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceBlockSystemGoroutine, 0)</code></span>
<span class="codeline" id="line-1338"><code></code></span>
<span class="codeline" id="line-1339"><code>		// Preemption must not occur here, or another G might see</code></span>
<span class="codeline" id="line-1340"><code>		// p.gcMarkWorkerMode.</code></span>
<span class="codeline" id="line-1341"><code></code></span>
<span class="codeline" id="line-1342"><code>		// Disable preemption so we can use the gcw. If the</code></span>
<span class="codeline" id="line-1343"><code>		// scheduler wants to preempt us, we'll stop draining,</code></span>
<span class="codeline" id="line-1344"><code>		// dispose the gcw, and then preempt.</code></span>
<span class="codeline" id="line-1345"><code>		node.m.set(acquirem())</code></span>
<span class="codeline" id="line-1346"><code>		pp := gp.m.p.ptr() // P can't change with preemption disabled.</code></span>
<span class="codeline" id="line-1347"><code></code></span>
<span class="codeline" id="line-1348"><code>		if gcBlackenEnabled == 0 {</code></span>
<span class="codeline" id="line-1349"><code>			println("worker mode", pp.gcMarkWorkerMode)</code></span>
<span class="codeline" id="line-1350"><code>			throw("gcBgMarkWorker: blackening not enabled")</code></span>
<span class="codeline" id="line-1351"><code>		}</code></span>
<span class="codeline" id="line-1352"><code></code></span>
<span class="codeline" id="line-1353"><code>		if pp.gcMarkWorkerMode == gcMarkWorkerNotWorker {</code></span>
<span class="codeline" id="line-1354"><code>			throw("gcBgMarkWorker: mode not set")</code></span>
<span class="codeline" id="line-1355"><code>		}</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>		startTime := nanotime()</code></span>
<span class="codeline" id="line-1358"><code>		pp.gcMarkWorkerStartTime = startTime</code></span>
<span class="codeline" id="line-1359"><code>		var trackLimiterEvent bool</code></span>
<span class="codeline" id="line-1360"><code>		if pp.gcMarkWorkerMode == gcMarkWorkerIdleMode {</code></span>
<span class="codeline" id="line-1361"><code>			trackLimiterEvent = pp.limiterEvent.start(limiterEventIdleMarkWork, startTime)</code></span>
<span class="codeline" id="line-1362"><code>		}</code></span>
<span class="codeline" id="line-1363"><code></code></span>
<span class="codeline" id="line-1364"><code>		decnwait := atomic.Xadd(&amp;work.nwait, -1)</code></span>
<span class="codeline" id="line-1365"><code>		if decnwait == work.nproc {</code></span>
<span class="codeline" id="line-1366"><code>			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)</code></span>
<span class="codeline" id="line-1367"><code>			throw("work.nwait was &gt; work.nproc")</code></span>
<span class="codeline" id="line-1368"><code>		}</code></span>
<span class="codeline" id="line-1369"><code></code></span>
<span class="codeline" id="line-1370"><code>		systemstack(func() {</code></span>
<span class="codeline" id="line-1371"><code>			// Mark our goroutine preemptible so its stack</code></span>
<span class="codeline" id="line-1372"><code>			// can be scanned. This lets two mark workers</code></span>
<span class="codeline" id="line-1373"><code>			// scan each other (otherwise, they would</code></span>
<span class="codeline" id="line-1374"><code>			// deadlock). We must not modify anything on</code></span>
<span class="codeline" id="line-1375"><code>			// the G stack. However, stack shrinking is</code></span>
<span class="codeline" id="line-1376"><code>			// disabled for mark workers, so it is safe to</code></span>
<span class="codeline" id="line-1377"><code>			// read from the G stack.</code></span>
<span class="codeline" id="line-1378"><code>			//</code></span>
<span class="codeline" id="line-1379"><code>			// N.B. The execution tracer is not aware of this status</code></span>
<span class="codeline" id="line-1380"><code>			// transition and handles it specially based on the</code></span>
<span class="codeline" id="line-1381"><code>			// wait reason.</code></span>
<span class="codeline" id="line-1382"><code>			casGToWaiting(gp, _Grunning, waitReasonGCWorkerActive)</code></span>
<span class="codeline" id="line-1383"><code>			switch pp.gcMarkWorkerMode {</code></span>
<span class="codeline" id="line-1384"><code>			default:</code></span>
<span class="codeline" id="line-1385"><code>				throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")</code></span>
<span class="codeline" id="line-1386"><code>			case gcMarkWorkerDedicatedMode:</code></span>
<span class="codeline" id="line-1387"><code>				gcDrainMarkWorkerDedicated(&amp;pp.gcw, true)</code></span>
<span class="codeline" id="line-1388"><code>				if gp.preempt {</code></span>
<span class="codeline" id="line-1389"><code>					// We were preempted. This is</code></span>
<span class="codeline" id="line-1390"><code>					// a useful signal to kick</code></span>
<span class="codeline" id="line-1391"><code>					// everything out of the run</code></span>
<span class="codeline" id="line-1392"><code>					// queue so it can run</code></span>
<span class="codeline" id="line-1393"><code>					// somewhere else.</code></span>
<span class="codeline" id="line-1394"><code>					if drainQ, n := runqdrain(pp); n &gt; 0 {</code></span>
<span class="codeline" id="line-1395"><code>						lock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1396"><code>						globrunqputbatch(&amp;drainQ, int32(n))</code></span>
<span class="codeline" id="line-1397"><code>						unlock(&amp;sched.lock)</code></span>
<span class="codeline" id="line-1398"><code>					}</code></span>
<span class="codeline" id="line-1399"><code>				}</code></span>
<span class="codeline" id="line-1400"><code>				// Go back to draining, this time</code></span>
<span class="codeline" id="line-1401"><code>				// without preemption.</code></span>
<span class="codeline" id="line-1402"><code>				gcDrainMarkWorkerDedicated(&amp;pp.gcw, false)</code></span>
<span class="codeline" id="line-1403"><code>			case gcMarkWorkerFractionalMode:</code></span>
<span class="codeline" id="line-1404"><code>				gcDrainMarkWorkerFractional(&amp;pp.gcw)</code></span>
<span class="codeline" id="line-1405"><code>			case gcMarkWorkerIdleMode:</code></span>
<span class="codeline" id="line-1406"><code>				gcDrainMarkWorkerIdle(&amp;pp.gcw)</code></span>
<span class="codeline" id="line-1407"><code>			}</code></span>
<span class="codeline" id="line-1408"><code>			casgstatus(gp, _Gwaiting, _Grunning)</code></span>
<span class="codeline" id="line-1409"><code>		})</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>		// Account for time and mark us as stopped.</code></span>
<span class="codeline" id="line-1412"><code>		now := nanotime()</code></span>
<span class="codeline" id="line-1413"><code>		duration := now - startTime</code></span>
<span class="codeline" id="line-1414"><code>		gcController.markWorkerStop(pp.gcMarkWorkerMode, duration)</code></span>
<span class="codeline" id="line-1415"><code>		if trackLimiterEvent {</code></span>
<span class="codeline" id="line-1416"><code>			pp.limiterEvent.stop(limiterEventIdleMarkWork, now)</code></span>
<span class="codeline" id="line-1417"><code>		}</code></span>
<span class="codeline" id="line-1418"><code>		if pp.gcMarkWorkerMode == gcMarkWorkerFractionalMode {</code></span>
<span class="codeline" id="line-1419"><code>			atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration)</code></span>
<span class="codeline" id="line-1420"><code>		}</code></span>
<span class="codeline" id="line-1421"><code></code></span>
<span class="codeline" id="line-1422"><code>		// Was this the last worker and did we run out</code></span>
<span class="codeline" id="line-1423"><code>		// of work?</code></span>
<span class="codeline" id="line-1424"><code>		incnwait := atomic.Xadd(&amp;work.nwait, +1)</code></span>
<span class="codeline" id="line-1425"><code>		if incnwait &gt; work.nproc {</code></span>
<span class="codeline" id="line-1426"><code>			println("runtime: p.gcMarkWorkerMode=", pp.gcMarkWorkerMode,</code></span>
<span class="codeline" id="line-1427"><code>				"work.nwait=", incnwait, "work.nproc=", work.nproc)</code></span>
<span class="codeline" id="line-1428"><code>			throw("work.nwait &gt; work.nproc")</code></span>
<span class="codeline" id="line-1429"><code>		}</code></span>
<span class="codeline" id="line-1430"><code></code></span>
<span class="codeline" id="line-1431"><code>		// We'll releasem after this point and thus this P may run</code></span>
<span class="codeline" id="line-1432"><code>		// something else. We must clear the worker mode to avoid</code></span>
<span class="codeline" id="line-1433"><code>		// attributing the mode to a different (non-worker) G in</code></span>
<span class="codeline" id="line-1434"><code>		// traceGoStart.</code></span>
<span class="codeline" id="line-1435"><code>		pp.gcMarkWorkerMode = gcMarkWorkerNotWorker</code></span>
<span class="codeline" id="line-1436"><code></code></span>
<span class="codeline" id="line-1437"><code>		// If this worker reached a background mark completion</code></span>
<span class="codeline" id="line-1438"><code>		// point, signal the main GC goroutine.</code></span>
<span class="codeline" id="line-1439"><code>		if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) {</code></span>
<span class="codeline" id="line-1440"><code>			// We don't need the P-local buffers here, allow</code></span>
<span class="codeline" id="line-1441"><code>			// preemption because we may schedule like a regular</code></span>
<span class="codeline" id="line-1442"><code>			// goroutine in gcMarkDone (block on locks, etc).</code></span>
<span class="codeline" id="line-1443"><code>			releasem(node.m.ptr())</code></span>
<span class="codeline" id="line-1444"><code>			node.m.set(nil)</code></span>
<span class="codeline" id="line-1445"><code></code></span>
<span class="codeline" id="line-1446"><code>			gcMarkDone()</code></span>
<span class="codeline" id="line-1447"><code>		}</code></span>
<span class="codeline" id="line-1448"><code>	}</code></span>
<span class="codeline" id="line-1449"><code>}</code></span>
<span class="codeline" id="line-1450"><code></code></span>
<span class="codeline" id="line-1451"><code>// gcMarkWorkAvailable reports whether executing a mark worker</code></span>
<span class="codeline" id="line-1452"><code>// on p is potentially useful. p may be nil, in which case it only</code></span>
<span class="codeline" id="line-1453"><code>// checks the global sources of work.</code></span>
<span class="codeline" id="line-1454"><code>func gcMarkWorkAvailable(p *p) bool {</code></span>
<span class="codeline" id="line-1455"><code>	if p != nil &amp;&amp; !p.gcw.empty() {</code></span>
<span class="codeline" id="line-1456"><code>		return true</code></span>
<span class="codeline" id="line-1457"><code>	}</code></span>
<span class="codeline" id="line-1458"><code>	if !work.full.empty() {</code></span>
<span class="codeline" id="line-1459"><code>		return true // global work available</code></span>
<span class="codeline" id="line-1460"><code>	}</code></span>
<span class="codeline" id="line-1461"><code>	if work.markrootNext &lt; work.markrootJobs {</code></span>
<span class="codeline" id="line-1462"><code>		return true // root scan work available</code></span>
<span class="codeline" id="line-1463"><code>	}</code></span>
<span class="codeline" id="line-1464"><code>	return false</code></span>
<span class="codeline" id="line-1465"><code>}</code></span>
<span class="codeline" id="line-1466"><code></code></span>
<span class="codeline" id="line-1467"><code>// gcMark runs the mark (or, for concurrent GC, mark termination)</code></span>
<span class="codeline" id="line-1468"><code>// All gcWork caches must be empty.</code></span>
<span class="codeline" id="line-1469"><code>// STW is in effect at this point.</code></span>
<span class="codeline" id="line-1470"><code>func gcMark(startTime int64) {</code></span>
<span class="codeline" id="line-1471"><code>	if debug.allocfreetrace &gt; 0 {</code></span>
<span class="codeline" id="line-1472"><code>		tracegc()</code></span>
<span class="codeline" id="line-1473"><code>	}</code></span>
<span class="codeline" id="line-1474"><code></code></span>
<span class="codeline" id="line-1475"><code>	if gcphase != _GCmarktermination {</code></span>
<span class="codeline" id="line-1476"><code>		throw("in gcMark expecting to see gcphase as _GCmarktermination")</code></span>
<span class="codeline" id="line-1477"><code>	}</code></span>
<span class="codeline" id="line-1478"><code>	work.tstart = startTime</code></span>
<span class="codeline" id="line-1479"><code></code></span>
<span class="codeline" id="line-1480"><code>	// Check that there's no marking work remaining.</code></span>
<span class="codeline" id="line-1481"><code>	if work.full != 0 || work.markrootNext &lt; work.markrootJobs {</code></span>
<span class="codeline" id="line-1482"><code>		print("runtime: full=", hex(work.full), " next=", work.markrootNext, " jobs=", work.markrootJobs, " nDataRoots=", work.nDataRoots, " nBSSRoots=", work.nBSSRoots, " nSpanRoots=", work.nSpanRoots, " nStackRoots=", work.nStackRoots, "\n")</code></span>
<span class="codeline" id="line-1483"><code>		panic("non-empty mark queue after concurrent mark")</code></span>
<span class="codeline" id="line-1484"><code>	}</code></span>
<span class="codeline" id="line-1485"><code></code></span>
<span class="codeline" id="line-1486"><code>	if debug.gccheckmark &gt; 0 {</code></span>
<span class="codeline" id="line-1487"><code>		// This is expensive when there's a large number of</code></span>
<span class="codeline" id="line-1488"><code>		// Gs, so only do it if checkmark is also enabled.</code></span>
<span class="codeline" id="line-1489"><code>		gcMarkRootCheck()</code></span>
<span class="codeline" id="line-1490"><code>	}</code></span>
<span class="codeline" id="line-1491"><code></code></span>
<span class="codeline" id="line-1492"><code>	// Drop allg snapshot. allgs may have grown, in which case</code></span>
<span class="codeline" id="line-1493"><code>	// this is the only reference to the old backing store and</code></span>
<span class="codeline" id="line-1494"><code>	// there's no need to keep it around.</code></span>
<span class="codeline" id="line-1495"><code>	work.stackRoots = nil</code></span>
<span class="codeline" id="line-1496"><code></code></span>
<span class="codeline" id="line-1497"><code>	// Clear out buffers and double-check that all gcWork caches</code></span>
<span class="codeline" id="line-1498"><code>	// are empty. This should be ensured by gcMarkDone before we</code></span>
<span class="codeline" id="line-1499"><code>	// enter mark termination.</code></span>
<span class="codeline" id="line-1500"><code>	//</code></span>
<span class="codeline" id="line-1501"><code>	// TODO: We could clear out buffers just before mark if this</code></span>
<span class="codeline" id="line-1502"><code>	// has a non-negligible impact on STW time.</code></span>
<span class="codeline" id="line-1503"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1504"><code>		// The write barrier may have buffered pointers since</code></span>
<span class="codeline" id="line-1505"><code>		// the gcMarkDone barrier. However, since the barrier</code></span>
<span class="codeline" id="line-1506"><code>		// ensured all reachable objects were marked, all of</code></span>
<span class="codeline" id="line-1507"><code>		// these must be pointers to black objects. Hence we</code></span>
<span class="codeline" id="line-1508"><code>		// can just discard the write barrier buffer.</code></span>
<span class="codeline" id="line-1509"><code>		if debug.gccheckmark &gt; 0 {</code></span>
<span class="codeline" id="line-1510"><code>			// For debugging, flush the buffer and make</code></span>
<span class="codeline" id="line-1511"><code>			// sure it really was all marked.</code></span>
<span class="codeline" id="line-1512"><code>			wbBufFlush1(p)</code></span>
<span class="codeline" id="line-1513"><code>		} else {</code></span>
<span class="codeline" id="line-1514"><code>			p.wbBuf.reset()</code></span>
<span class="codeline" id="line-1515"><code>		}</code></span>
<span class="codeline" id="line-1516"><code></code></span>
<span class="codeline" id="line-1517"><code>		gcw := &amp;p.gcw</code></span>
<span class="codeline" id="line-1518"><code>		if !gcw.empty() {</code></span>
<span class="codeline" id="line-1519"><code>			printlock()</code></span>
<span class="codeline" id="line-1520"><code>			print("runtime: P ", p.id, " flushedWork ", gcw.flushedWork)</code></span>
<span class="codeline" id="line-1521"><code>			if gcw.wbuf1 == nil {</code></span>
<span class="codeline" id="line-1522"><code>				print(" wbuf1=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-1523"><code>			} else {</code></span>
<span class="codeline" id="line-1524"><code>				print(" wbuf1.n=", gcw.wbuf1.nobj)</code></span>
<span class="codeline" id="line-1525"><code>			}</code></span>
<span class="codeline" id="line-1526"><code>			if gcw.wbuf2 == nil {</code></span>
<span class="codeline" id="line-1527"><code>				print(" wbuf2=&lt;nil&gt;")</code></span>
<span class="codeline" id="line-1528"><code>			} else {</code></span>
<span class="codeline" id="line-1529"><code>				print(" wbuf2.n=", gcw.wbuf2.nobj)</code></span>
<span class="codeline" id="line-1530"><code>			}</code></span>
<span class="codeline" id="line-1531"><code>			print("\n")</code></span>
<span class="codeline" id="line-1532"><code>			throw("P has cached GC work at end of mark termination")</code></span>
<span class="codeline" id="line-1533"><code>		}</code></span>
<span class="codeline" id="line-1534"><code>		// There may still be cached empty buffers, which we</code></span>
<span class="codeline" id="line-1535"><code>		// need to flush since we're going to free them. Also,</code></span>
<span class="codeline" id="line-1536"><code>		// there may be non-zero stats because we allocated</code></span>
<span class="codeline" id="line-1537"><code>		// black after the gcMarkDone barrier.</code></span>
<span class="codeline" id="line-1538"><code>		gcw.dispose()</code></span>
<span class="codeline" id="line-1539"><code>	}</code></span>
<span class="codeline" id="line-1540"><code></code></span>
<span class="codeline" id="line-1541"><code>	// Flush scanAlloc from each mcache since we're about to modify</code></span>
<span class="codeline" id="line-1542"><code>	// heapScan directly. If we were to flush this later, then scanAlloc</code></span>
<span class="codeline" id="line-1543"><code>	// might have incorrect information.</code></span>
<span class="codeline" id="line-1544"><code>	//</code></span>
<span class="codeline" id="line-1545"><code>	// Note that it's not important to retain this information; we know</code></span>
<span class="codeline" id="line-1546"><code>	// exactly what heapScan is at this point via scanWork.</code></span>
<span class="codeline" id="line-1547"><code>	for _, p := range allp {</code></span>
<span class="codeline" id="line-1548"><code>		c := p.mcache</code></span>
<span class="codeline" id="line-1549"><code>		if c == nil {</code></span>
<span class="codeline" id="line-1550"><code>			continue</code></span>
<span class="codeline" id="line-1551"><code>		}</code></span>
<span class="codeline" id="line-1552"><code>		c.scanAlloc = 0</code></span>
<span class="codeline" id="line-1553"><code>	}</code></span>
<span class="codeline" id="line-1554"><code></code></span>
<span class="codeline" id="line-1555"><code>	// Reset controller state.</code></span>
<span class="codeline" id="line-1556"><code>	gcController.resetLive(work.bytesMarked)</code></span>
<span class="codeline" id="line-1557"><code>}</code></span>
<span class="codeline" id="line-1558"><code></code></span>
<span class="codeline" id="line-1559"><code>// gcSweep must be called on the system stack because it acquires the heap</code></span>
<span class="codeline" id="line-1560"><code>// lock. See mheap for details.</code></span>
<span class="codeline" id="line-1561"><code>//</code></span>
<span class="codeline" id="line-1562"><code>// Returns true if the heap was fully swept by this function.</code></span>
<span class="codeline" id="line-1563"><code>//</code></span>
<span class="codeline" id="line-1564"><code>// The world must be stopped.</code></span>
<span class="codeline" id="line-1565"><code>//</code></span>
<span class="codeline" id="line-1566"><code>//go:systemstack</code></span>
<span class="codeline" id="line-1567"><code>func gcSweep(mode gcMode) bool {</code></span>
<span class="codeline" id="line-1568"><code>	assertWorldStopped()</code></span>
<span class="codeline" id="line-1569"><code></code></span>
<span class="codeline" id="line-1570"><code>	if gcphase != _GCoff {</code></span>
<span class="codeline" id="line-1571"><code>		throw("gcSweep being done but phase is not GCoff")</code></span>
<span class="codeline" id="line-1572"><code>	}</code></span>
<span class="codeline" id="line-1573"><code></code></span>
<span class="codeline" id="line-1574"><code>	lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1575"><code>	mheap_.sweepgen += 2</code></span>
<span class="codeline" id="line-1576"><code>	sweep.active.reset()</code></span>
<span class="codeline" id="line-1577"><code>	mheap_.pagesSwept.Store(0)</code></span>
<span class="codeline" id="line-1578"><code>	mheap_.sweepArenas = mheap_.allArenas</code></span>
<span class="codeline" id="line-1579"><code>	mheap_.reclaimIndex.Store(0)</code></span>
<span class="codeline" id="line-1580"><code>	mheap_.reclaimCredit.Store(0)</code></span>
<span class="codeline" id="line-1581"><code>	unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1582"><code></code></span>
<span class="codeline" id="line-1583"><code>	sweep.centralIndex.clear()</code></span>
<span class="codeline" id="line-1584"><code></code></span>
<span class="codeline" id="line-1585"><code>	if !concurrentSweep || mode == gcForceBlockMode {</code></span>
<span class="codeline" id="line-1586"><code>		// Special case synchronous sweep.</code></span>
<span class="codeline" id="line-1587"><code>		// Record that no proportional sweeping has to happen.</code></span>
<span class="codeline" id="line-1588"><code>		lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1589"><code>		mheap_.sweepPagesPerByte = 0</code></span>
<span class="codeline" id="line-1590"><code>		unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1591"><code>		// Flush all mcaches.</code></span>
<span class="codeline" id="line-1592"><code>		for _, pp := range allp {</code></span>
<span class="codeline" id="line-1593"><code>			pp.mcache.prepareForSweep()</code></span>
<span class="codeline" id="line-1594"><code>		}</code></span>
<span class="codeline" id="line-1595"><code>		// Sweep all spans eagerly.</code></span>
<span class="codeline" id="line-1596"><code>		for sweepone() != ^uintptr(0) {</code></span>
<span class="codeline" id="line-1597"><code>		}</code></span>
<span class="codeline" id="line-1598"><code>		// Free workbufs eagerly.</code></span>
<span class="codeline" id="line-1599"><code>		prepareFreeWorkbufs()</code></span>
<span class="codeline" id="line-1600"><code>		for freeSomeWbufs(false) {</code></span>
<span class="codeline" id="line-1601"><code>		}</code></span>
<span class="codeline" id="line-1602"><code>		// All "free" events for this mark/sweep cycle have</code></span>
<span class="codeline" id="line-1603"><code>		// now happened, so we can make this profile cycle</code></span>
<span class="codeline" id="line-1604"><code>		// available immediately.</code></span>
<span class="codeline" id="line-1605"><code>		mProf_NextCycle()</code></span>
<span class="codeline" id="line-1606"><code>		mProf_Flush()</code></span>
<span class="codeline" id="line-1607"><code>		return true</code></span>
<span class="codeline" id="line-1608"><code>	}</code></span>
<span class="codeline" id="line-1609"><code></code></span>
<span class="codeline" id="line-1610"><code>	// Background sweep.</code></span>
<span class="codeline" id="line-1611"><code>	lock(&amp;sweep.lock)</code></span>
<span class="codeline" id="line-1612"><code>	if sweep.parked {</code></span>
<span class="codeline" id="line-1613"><code>		sweep.parked = false</code></span>
<span class="codeline" id="line-1614"><code>		ready(sweep.g, 0, true)</code></span>
<span class="codeline" id="line-1615"><code>	}</code></span>
<span class="codeline" id="line-1616"><code>	unlock(&amp;sweep.lock)</code></span>
<span class="codeline" id="line-1617"><code>	return false</code></span>
<span class="codeline" id="line-1618"><code>}</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>// gcResetMarkState resets global state prior to marking (concurrent</code></span>
<span class="codeline" id="line-1621"><code>// or STW) and resets the stack scan state of all Gs.</code></span>
<span class="codeline" id="line-1622"><code>//</code></span>
<span class="codeline" id="line-1623"><code>// This is safe to do without the world stopped because any Gs created</code></span>
<span class="codeline" id="line-1624"><code>// during or after this will start out in the reset state.</code></span>
<span class="codeline" id="line-1625"><code>//</code></span>
<span class="codeline" id="line-1626"><code>// gcResetMarkState must be called on the system stack because it acquires</code></span>
<span class="codeline" id="line-1627"><code>// the heap lock. See mheap for details.</code></span>
<span class="codeline" id="line-1628"><code>//</code></span>
<span class="codeline" id="line-1629"><code>//go:systemstack</code></span>
<span class="codeline" id="line-1630"><code>func gcResetMarkState() {</code></span>
<span class="codeline" id="line-1631"><code>	// This may be called during a concurrent phase, so lock to make sure</code></span>
<span class="codeline" id="line-1632"><code>	// allgs doesn't change.</code></span>
<span class="codeline" id="line-1633"><code>	forEachG(func(gp *g) {</code></span>
<span class="codeline" id="line-1634"><code>		gp.gcscandone = false // set to true in gcphasework</code></span>
<span class="codeline" id="line-1635"><code>		gp.gcAssistBytes = 0</code></span>
<span class="codeline" id="line-1636"><code>	})</code></span>
<span class="codeline" id="line-1637"><code></code></span>
<span class="codeline" id="line-1638"><code>	// Clear page marks. This is just 1MB per 64GB of heap, so the</code></span>
<span class="codeline" id="line-1639"><code>	// time here is pretty trivial.</code></span>
<span class="codeline" id="line-1640"><code>	lock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1641"><code>	arenas := mheap_.allArenas</code></span>
<span class="codeline" id="line-1642"><code>	unlock(&amp;mheap_.lock)</code></span>
<span class="codeline" id="line-1643"><code>	for _, ai := range arenas {</code></span>
<span class="codeline" id="line-1644"><code>		ha := mheap_.arenas[ai.l1()][ai.l2()]</code></span>
<span class="codeline" id="line-1645"><code>		for i := range ha.pageMarks {</code></span>
<span class="codeline" id="line-1646"><code>			ha.pageMarks[i] = 0</code></span>
<span class="codeline" id="line-1647"><code>		}</code></span>
<span class="codeline" id="line-1648"><code>	}</code></span>
<span class="codeline" id="line-1649"><code></code></span>
<span class="codeline" id="line-1650"><code>	work.bytesMarked = 0</code></span>
<span class="codeline" id="line-1651"><code>	work.initialHeapLive = gcController.heapLive.Load()</code></span>
<span class="codeline" id="line-1652"><code>}</code></span>
<span class="codeline" id="line-1653"><code></code></span>
<span class="codeline" id="line-1654"><code>// Hooks for other packages</code></span>
<span class="codeline" id="line-1655"><code></code></span>
<span class="codeline" id="line-1656"><code>var poolcleanup func()</code></span>
<span class="codeline" id="line-1657"><code>var boringCaches []unsafe.Pointer // for crypto/internal/boring</code></span>
<span class="codeline" id="line-1658"><code></code></span>
<span class="codeline" id="line-1659"><code>//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup</code></span>
<span class="codeline" id="line-1660"><code>func sync_runtime_registerPoolCleanup(f func()) {</code></span>
<span class="codeline" id="line-1661"><code>	poolcleanup = f</code></span>
<span class="codeline" id="line-1662"><code>}</code></span>
<span class="codeline" id="line-1663"><code></code></span>
<span class="codeline" id="line-1664"><code>//go:linkname boring_registerCache crypto/internal/boring/bcache.registerCache</code></span>
<span class="codeline" id="line-1665"><code>func boring_registerCache(p unsafe.Pointer) {</code></span>
<span class="codeline" id="line-1666"><code>	boringCaches = append(boringCaches, p)</code></span>
<span class="codeline" id="line-1667"><code>}</code></span>
<span class="codeline" id="line-1668"><code></code></span>
<span class="codeline" id="line-1669"><code>func clearpools() {</code></span>
<span class="codeline" id="line-1670"><code>	// clear sync.Pools</code></span>
<span class="codeline" id="line-1671"><code>	if poolcleanup != nil {</code></span>
<span class="codeline" id="line-1672"><code>		poolcleanup()</code></span>
<span class="codeline" id="line-1673"><code>	}</code></span>
<span class="codeline" id="line-1674"><code></code></span>
<span class="codeline" id="line-1675"><code>	// clear boringcrypto caches</code></span>
<span class="codeline" id="line-1676"><code>	for _, p := range boringCaches {</code></span>
<span class="codeline" id="line-1677"><code>		atomicstorep(p, nil)</code></span>
<span class="codeline" id="line-1678"><code>	}</code></span>
<span class="codeline" id="line-1679"><code></code></span>
<span class="codeline" id="line-1680"><code>	// Clear central sudog cache.</code></span>
<span class="codeline" id="line-1681"><code>	// Leave per-P caches alone, they have strictly bounded size.</code></span>
<span class="codeline" id="line-1682"><code>	// Disconnect cached list before dropping it on the floor,</code></span>
<span class="codeline" id="line-1683"><code>	// so that a dangling ref to one entry does not pin all of them.</code></span>
<span class="codeline" id="line-1684"><code>	lock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-1685"><code>	var sg, sgnext *sudog</code></span>
<span class="codeline" id="line-1686"><code>	for sg = sched.sudogcache; sg != nil; sg = sgnext {</code></span>
<span class="codeline" id="line-1687"><code>		sgnext = sg.next</code></span>
<span class="codeline" id="line-1688"><code>		sg.next = nil</code></span>
<span class="codeline" id="line-1689"><code>	}</code></span>
<span class="codeline" id="line-1690"><code>	sched.sudogcache = nil</code></span>
<span class="codeline" id="line-1691"><code>	unlock(&amp;sched.sudoglock)</code></span>
<span class="codeline" id="line-1692"><code></code></span>
<span class="codeline" id="line-1693"><code>	// Clear central defer pool.</code></span>
<span class="codeline" id="line-1694"><code>	// Leave per-P pools alone, they have strictly bounded size.</code></span>
<span class="codeline" id="line-1695"><code>	lock(&amp;sched.deferlock)</code></span>
<span class="codeline" id="line-1696"><code>	// disconnect cached list before dropping it on the floor,</code></span>
<span class="codeline" id="line-1697"><code>	// so that a dangling ref to one entry does not pin all of them.</code></span>
<span class="codeline" id="line-1698"><code>	var d, dlink *_defer</code></span>
<span class="codeline" id="line-1699"><code>	for d = sched.deferpool; d != nil; d = dlink {</code></span>
<span class="codeline" id="line-1700"><code>		dlink = d.link</code></span>
<span class="codeline" id="line-1701"><code>		d.link = nil</code></span>
<span class="codeline" id="line-1702"><code>	}</code></span>
<span class="codeline" id="line-1703"><code>	sched.deferpool = nil</code></span>
<span class="codeline" id="line-1704"><code>	unlock(&amp;sched.deferlock)</code></span>
<span class="codeline" id="line-1705"><code>}</code></span>
<span class="codeline" id="line-1706"><code></code></span>
<span class="codeline" id="line-1707"><code>// Timing</code></span>
<span class="codeline" id="line-1708"><code></code></span>
<span class="codeline" id="line-1709"><code>// itoaDiv formats val/(10**dec) into buf.</code></span>
<span class="codeline" id="line-1710"><code>func itoaDiv(buf []byte, val uint64, dec int) []byte {</code></span>
<span class="codeline" id="line-1711"><code>	i := len(buf) - 1</code></span>
<span class="codeline" id="line-1712"><code>	idec := i - dec</code></span>
<span class="codeline" id="line-1713"><code>	for val &gt;= 10 || i &gt;= idec {</code></span>
<span class="codeline" id="line-1714"><code>		buf[i] = byte(val%10 + '0')</code></span>
<span class="codeline" id="line-1715"><code>		i--</code></span>
<span class="codeline" id="line-1716"><code>		if i == idec {</code></span>
<span class="codeline" id="line-1717"><code>			buf[i] = '.'</code></span>
<span class="codeline" id="line-1718"><code>			i--</code></span>
<span class="codeline" id="line-1719"><code>		}</code></span>
<span class="codeline" id="line-1720"><code>		val /= 10</code></span>
<span class="codeline" id="line-1721"><code>	}</code></span>
<span class="codeline" id="line-1722"><code>	buf[i] = byte(val + '0')</code></span>
<span class="codeline" id="line-1723"><code>	return buf[i:]</code></span>
<span class="codeline" id="line-1724"><code>}</code></span>
<span class="codeline" id="line-1725"><code></code></span>
<span class="codeline" id="line-1726"><code>// fmtNSAsMS nicely formats ns nanoseconds as milliseconds.</code></span>
<span class="codeline" id="line-1727"><code>func fmtNSAsMS(buf []byte, ns uint64) []byte {</code></span>
<span class="codeline" id="line-1728"><code>	if ns &gt;= 10e6 {</code></span>
<span class="codeline" id="line-1729"><code>		// Format as whole milliseconds.</code></span>
<span class="codeline" id="line-1730"><code>		return itoaDiv(buf, ns/1e6, 0)</code></span>
<span class="codeline" id="line-1731"><code>	}</code></span>
<span class="codeline" id="line-1732"><code>	// Format two digits of precision, with at most three decimal places.</code></span>
<span class="codeline" id="line-1733"><code>	x := ns / 1e3</code></span>
<span class="codeline" id="line-1734"><code>	if x == 0 {</code></span>
<span class="codeline" id="line-1735"><code>		buf[0] = '0'</code></span>
<span class="codeline" id="line-1736"><code>		return buf[:1]</code></span>
<span class="codeline" id="line-1737"><code>	}</code></span>
<span class="codeline" id="line-1738"><code>	dec := 3</code></span>
<span class="codeline" id="line-1739"><code>	for x &gt;= 100 {</code></span>
<span class="codeline" id="line-1740"><code>		x /= 10</code></span>
<span class="codeline" id="line-1741"><code>		dec--</code></span>
<span class="codeline" id="line-1742"><code>	}</code></span>
<span class="codeline" id="line-1743"><code>	return itoaDiv(buf, x, dec)</code></span>
<span class="codeline" id="line-1744"><code>}</code></span>
<span class="codeline" id="line-1745"><code></code></span>
<span class="codeline" id="line-1746"><code>// Helpers for testing GC.</code></span>
<span class="codeline" id="line-1747"><code></code></span>
<span class="codeline" id="line-1748"><code>// gcTestMoveStackOnNextCall causes the stack to be moved on a call</code></span>
<span class="codeline" id="line-1749"><code>// immediately following the call to this. It may not work correctly</code></span>
<span class="codeline" id="line-1750"><code>// if any other work appears after this call (such as returning).</code></span>
<span class="codeline" id="line-1751"><code>// Typically the following call should be marked go:noinline so it</code></span>
<span class="codeline" id="line-1752"><code>// performs a stack check.</code></span>
<span class="codeline" id="line-1753"><code>//</code></span>
<span class="codeline" id="line-1754"><code>// In rare cases this may not cause the stack to move, specifically if</code></span>
<span class="codeline" id="line-1755"><code>// there's a preemption between this call and the next.</code></span>
<span class="codeline" id="line-1756"><code>func gcTestMoveStackOnNextCall() {</code></span>
<span class="codeline" id="line-1757"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1758"><code>	gp.stackguard0 = stackForceMove</code></span>
<span class="codeline" id="line-1759"><code>}</code></span>
<span class="codeline" id="line-1760"><code></code></span>
<span class="codeline" id="line-1761"><code>// gcTestIsReachable performs a GC and returns a bit set where bit i</code></span>
<span class="codeline" id="line-1762"><code>// is set if ptrs[i] is reachable.</code></span>
<span class="codeline" id="line-1763"><code>func gcTestIsReachable(ptrs ...unsafe.Pointer) (mask uint64) {</code></span>
<span class="codeline" id="line-1764"><code>	// This takes the pointers as unsafe.Pointers in order to keep</code></span>
<span class="codeline" id="line-1765"><code>	// them live long enough for us to attach specials. After</code></span>
<span class="codeline" id="line-1766"><code>	// that, we drop our references to them.</code></span>
<span class="codeline" id="line-1767"><code></code></span>
<span class="codeline" id="line-1768"><code>	if len(ptrs) &gt; 64 {</code></span>
<span class="codeline" id="line-1769"><code>		panic("too many pointers for uint64 mask")</code></span>
<span class="codeline" id="line-1770"><code>	}</code></span>
<span class="codeline" id="line-1771"><code></code></span>
<span class="codeline" id="line-1772"><code>	// Block GC while we attach specials and drop our references</code></span>
<span class="codeline" id="line-1773"><code>	// to ptrs. Otherwise, if a GC is in progress, it could mark</code></span>
<span class="codeline" id="line-1774"><code>	// them reachable via this function before we have a chance to</code></span>
<span class="codeline" id="line-1775"><code>	// drop them.</code></span>
<span class="codeline" id="line-1776"><code>	semacquire(&amp;gcsema)</code></span>
<span class="codeline" id="line-1777"><code></code></span>
<span class="codeline" id="line-1778"><code>	// Create reachability specials for ptrs.</code></span>
<span class="codeline" id="line-1779"><code>	specials := make([]*specialReachable, len(ptrs))</code></span>
<span class="codeline" id="line-1780"><code>	for i, p := range ptrs {</code></span>
<span class="codeline" id="line-1781"><code>		lock(&amp;mheap_.speciallock)</code></span>
<span class="codeline" id="line-1782"><code>		s := (*specialReachable)(mheap_.specialReachableAlloc.alloc())</code></span>
<span class="codeline" id="line-1783"><code>		unlock(&amp;mheap_.speciallock)</code></span>
<span class="codeline" id="line-1784"><code>		s.special.kind = _KindSpecialReachable</code></span>
<span class="codeline" id="line-1785"><code>		if !addspecial(p, &amp;s.special) {</code></span>
<span class="codeline" id="line-1786"><code>			throw("already have a reachable special (duplicate pointer?)")</code></span>
<span class="codeline" id="line-1787"><code>		}</code></span>
<span class="codeline" id="line-1788"><code>		specials[i] = s</code></span>
<span class="codeline" id="line-1789"><code>		// Make sure we don't retain ptrs.</code></span>
<span class="codeline" id="line-1790"><code>		ptrs[i] = nil</code></span>
<span class="codeline" id="line-1791"><code>	}</code></span>
<span class="codeline" id="line-1792"><code></code></span>
<span class="codeline" id="line-1793"><code>	semrelease(&amp;gcsema)</code></span>
<span class="codeline" id="line-1794"><code></code></span>
<span class="codeline" id="line-1795"><code>	// Force a full GC and sweep.</code></span>
<span class="codeline" id="line-1796"><code>	GC()</code></span>
<span class="codeline" id="line-1797"><code></code></span>
<span class="codeline" id="line-1798"><code>	// Process specials.</code></span>
<span class="codeline" id="line-1799"><code>	for i, s := range specials {</code></span>
<span class="codeline" id="line-1800"><code>		if !s.done {</code></span>
<span class="codeline" id="line-1801"><code>			printlock()</code></span>
<span class="codeline" id="line-1802"><code>			println("runtime: object", i, "was not swept")</code></span>
<span class="codeline" id="line-1803"><code>			throw("IsReachable failed")</code></span>
<span class="codeline" id="line-1804"><code>		}</code></span>
<span class="codeline" id="line-1805"><code>		if s.reachable {</code></span>
<span class="codeline" id="line-1806"><code>			mask |= 1 &lt;&lt; i</code></span>
<span class="codeline" id="line-1807"><code>		}</code></span>
<span class="codeline" id="line-1808"><code>		lock(&amp;mheap_.speciallock)</code></span>
<span class="codeline" id="line-1809"><code>		mheap_.specialReachableAlloc.free(unsafe.Pointer(s))</code></span>
<span class="codeline" id="line-1810"><code>		unlock(&amp;mheap_.speciallock)</code></span>
<span class="codeline" id="line-1811"><code>	}</code></span>
<span class="codeline" id="line-1812"><code></code></span>
<span class="codeline" id="line-1813"><code>	return mask</code></span>
<span class="codeline" id="line-1814"><code>}</code></span>
<span class="codeline" id="line-1815"><code></code></span>
<span class="codeline" id="line-1816"><code>// gcTestPointerClass returns the category of what p points to, one of:</code></span>
<span class="codeline" id="line-1817"><code>// "heap", "stack", "data", "bss", "other". This is useful for checking</code></span>
<span class="codeline" id="line-1818"><code>// that a test is doing what it's intended to do.</code></span>
<span class="codeline" id="line-1819"><code>//</code></span>
<span class="codeline" id="line-1820"><code>// This is nosplit simply to avoid extra pointer shuffling that may</code></span>
<span class="codeline" id="line-1821"><code>// complicate a test.</code></span>
<span class="codeline" id="line-1822"><code>//</code></span>
<span class="codeline" id="line-1823"><code>//go:nosplit</code></span>
<span class="codeline" id="line-1824"><code>func gcTestPointerClass(p unsafe.Pointer) string {</code></span>
<span class="codeline" id="line-1825"><code>	p2 := uintptr(noescape(p))</code></span>
<span class="codeline" id="line-1826"><code>	gp := getg()</code></span>
<span class="codeline" id="line-1827"><code>	if gp.stack.lo &lt;= p2 &amp;&amp; p2 &lt; gp.stack.hi {</code></span>
<span class="codeline" id="line-1828"><code>		return "stack"</code></span>
<span class="codeline" id="line-1829"><code>	}</code></span>
<span class="codeline" id="line-1830"><code>	if base, _, _ := findObject(p2, 0, 0); base != 0 {</code></span>
<span class="codeline" id="line-1831"><code>		return "heap"</code></span>
<span class="codeline" id="line-1832"><code>	}</code></span>
<span class="codeline" id="line-1833"><code>	for _, datap := range activeModules() {</code></span>
<span class="codeline" id="line-1834"><code>		if datap.data &lt;= p2 &amp;&amp; p2 &lt; datap.edata || datap.noptrdata &lt;= p2 &amp;&amp; p2 &lt; datap.enoptrdata {</code></span>
<span class="codeline" id="line-1835"><code>			return "data"</code></span>
<span class="codeline" id="line-1836"><code>		}</code></span>
<span class="codeline" id="line-1837"><code>		if datap.bss &lt;= p2 &amp;&amp; p2 &lt; datap.ebss || datap.noptrbss &lt;= p2 &amp;&amp; p2 &lt;= datap.enoptrbss {</code></span>
<span class="codeline" id="line-1838"><code>			return "bss"</code></span>
<span class="codeline" id="line-1839"><code>		}</code></span>
<span class="codeline" id="line-1840"><code>	}</code></span>
<span class="codeline" id="line-1841"><code>	KeepAlive(p)</code></span>
<span class="codeline" id="line-1842"><code>	return "other"</code></span>
<span class="codeline" id="line-1843"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>