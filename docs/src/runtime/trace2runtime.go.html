<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: trace2runtime.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	trace2runtime.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2023 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>//go:build goexperiment.exectracer2</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// Runtime -&gt; tracer API.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>package runtime</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>import (</code></span>
<span class="codeline" id="line-12"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-13"><code>	_ "unsafe" // for go:linkname</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// gTraceState is per-G state for the tracer.</code></span>
<span class="codeline" id="line-17"><code>type gTraceState struct {</code></span>
<span class="codeline" id="line-18"><code>	traceSchedResourceState</code></span>
<span class="codeline" id="line-19"><code>}</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>// reset resets the gTraceState for a new goroutine.</code></span>
<span class="codeline" id="line-22"><code>func (s *gTraceState) reset() {</code></span>
<span class="codeline" id="line-23"><code>	s.seq = [2]uint64{}</code></span>
<span class="codeline" id="line-24"><code>	// N.B. s.statusTraced is managed and cleared separately.</code></span>
<span class="codeline" id="line-25"><code>}</code></span>
<span class="codeline" id="line-26"><code></code></span>
<span class="codeline" id="line-27"><code>// mTraceState is per-M state for the tracer.</code></span>
<span class="codeline" id="line-28"><code>type mTraceState struct {</code></span>
<span class="codeline" id="line-29"><code>	seqlock atomic.Uintptr // seqlock indicating that this M is writing to a trace buffer.</code></span>
<span class="codeline" id="line-30"><code>	buf     [2]*traceBuf   // Per-M traceBuf for writing. Indexed by trace.gen%2.</code></span>
<span class="codeline" id="line-31"><code>	link    *m             // Snapshot of alllink or freelink.</code></span>
<span class="codeline" id="line-32"><code>}</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// pTraceState is per-P state for the tracer.</code></span>
<span class="codeline" id="line-35"><code>type pTraceState struct {</code></span>
<span class="codeline" id="line-36"><code>	traceSchedResourceState</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>	// mSyscallID is the ID of the M this was bound to before entering a syscall.</code></span>
<span class="codeline" id="line-39"><code>	mSyscallID int64</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>	// maySweep indicates the sweep events should be traced.</code></span>
<span class="codeline" id="line-42"><code>	// This is used to defer the sweep start event until a span</code></span>
<span class="codeline" id="line-43"><code>	// has actually been swept.</code></span>
<span class="codeline" id="line-44"><code>	maySweep bool</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>	// inSweep indicates that at least one sweep event has been traced.</code></span>
<span class="codeline" id="line-47"><code>	inSweep bool</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>	// swept and reclaimed track the number of bytes swept and reclaimed</code></span>
<span class="codeline" id="line-50"><code>	// by sweeping in the current sweep loop (while maySweep was true).</code></span>
<span class="codeline" id="line-51"><code>	swept, reclaimed uintptr</code></span>
<span class="codeline" id="line-52"><code>}</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>// traceLockInit initializes global trace locks.</code></span>
<span class="codeline" id="line-55"><code>func traceLockInit() {</code></span>
<span class="codeline" id="line-56"><code>	// Sharing a lock rank here is fine because they should never be accessed</code></span>
<span class="codeline" id="line-57"><code>	// together. If they are, we want to find out immediately.</code></span>
<span class="codeline" id="line-58"><code>	lockInit(&amp;trace.stringTab[0].lock, lockRankTraceStrings)</code></span>
<span class="codeline" id="line-59"><code>	lockInit(&amp;trace.stringTab[0].tab.lock, lockRankTraceStrings)</code></span>
<span class="codeline" id="line-60"><code>	lockInit(&amp;trace.stringTab[1].lock, lockRankTraceStrings)</code></span>
<span class="codeline" id="line-61"><code>	lockInit(&amp;trace.stringTab[1].tab.lock, lockRankTraceStrings)</code></span>
<span class="codeline" id="line-62"><code>	lockInit(&amp;trace.stackTab[0].tab.lock, lockRankTraceStackTab)</code></span>
<span class="codeline" id="line-63"><code>	lockInit(&amp;trace.stackTab[1].tab.lock, lockRankTraceStackTab)</code></span>
<span class="codeline" id="line-64"><code>	lockInit(&amp;trace.lock, lockRankTrace)</code></span>
<span class="codeline" id="line-65"><code>}</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>// lockRankMayTraceFlush records the lock ranking effects of a</code></span>
<span class="codeline" id="line-68"><code>// potential call to traceFlush.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// nosplit because traceAcquire is nosplit.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>//go:nosplit</code></span>
<span class="codeline" id="line-73"><code>func lockRankMayTraceFlush() {</code></span>
<span class="codeline" id="line-74"><code>	lockWithRankMayAcquire(&amp;trace.lock, getLockRank(&amp;trace.lock))</code></span>
<span class="codeline" id="line-75"><code>}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>// traceBlockReason is an enumeration of reasons a goroutine might block.</code></span>
<span class="codeline" id="line-78"><code>// This is the interface the rest of the runtime uses to tell the</code></span>
<span class="codeline" id="line-79"><code>// tracer why a goroutine blocked. The tracer then propagates this information</code></span>
<span class="codeline" id="line-80"><code>// into the trace however it sees fit.</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// Note that traceBlockReasons should not be compared, since reasons that are</code></span>
<span class="codeline" id="line-83"><code>// distinct by name may *not* be distinct by value.</code></span>
<span class="codeline" id="line-84"><code>type traceBlockReason uint8</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>const (</code></span>
<span class="codeline" id="line-87"><code>	traceBlockGeneric traceBlockReason = iota</code></span>
<span class="codeline" id="line-88"><code>	traceBlockForever</code></span>
<span class="codeline" id="line-89"><code>	traceBlockNet</code></span>
<span class="codeline" id="line-90"><code>	traceBlockSelect</code></span>
<span class="codeline" id="line-91"><code>	traceBlockCondWait</code></span>
<span class="codeline" id="line-92"><code>	traceBlockSync</code></span>
<span class="codeline" id="line-93"><code>	traceBlockChanSend</code></span>
<span class="codeline" id="line-94"><code>	traceBlockChanRecv</code></span>
<span class="codeline" id="line-95"><code>	traceBlockGCMarkAssist</code></span>
<span class="codeline" id="line-96"><code>	traceBlockGCSweep</code></span>
<span class="codeline" id="line-97"><code>	traceBlockSystemGoroutine</code></span>
<span class="codeline" id="line-98"><code>	traceBlockPreempted</code></span>
<span class="codeline" id="line-99"><code>	traceBlockDebugCall</code></span>
<span class="codeline" id="line-100"><code>	traceBlockUntilGCEnds</code></span>
<span class="codeline" id="line-101"><code>	traceBlockSleep</code></span>
<span class="codeline" id="line-102"><code>)</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>var traceBlockReasonStrings = [...]string{</code></span>
<span class="codeline" id="line-105"><code>	traceBlockGeneric:         "unspecified",</code></span>
<span class="codeline" id="line-106"><code>	traceBlockForever:         "forever",</code></span>
<span class="codeline" id="line-107"><code>	traceBlockNet:             "network",</code></span>
<span class="codeline" id="line-108"><code>	traceBlockSelect:          "select",</code></span>
<span class="codeline" id="line-109"><code>	traceBlockCondWait:        "sync.(*Cond).Wait",</code></span>
<span class="codeline" id="line-110"><code>	traceBlockSync:            "sync",</code></span>
<span class="codeline" id="line-111"><code>	traceBlockChanSend:        "chan send",</code></span>
<span class="codeline" id="line-112"><code>	traceBlockChanRecv:        "chan receive",</code></span>
<span class="codeline" id="line-113"><code>	traceBlockGCMarkAssist:    "GC mark assist wait for work",</code></span>
<span class="codeline" id="line-114"><code>	traceBlockGCSweep:         "GC background sweeper wait",</code></span>
<span class="codeline" id="line-115"><code>	traceBlockSystemGoroutine: "system goroutine wait",</code></span>
<span class="codeline" id="line-116"><code>	traceBlockPreempted:       "preempted",</code></span>
<span class="codeline" id="line-117"><code>	traceBlockDebugCall:       "wait for debug call",</code></span>
<span class="codeline" id="line-118"><code>	traceBlockUntilGCEnds:     "wait until GC ends",</code></span>
<span class="codeline" id="line-119"><code>	traceBlockSleep:           "sleep",</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// traceGoStopReason is an enumeration of reasons a goroutine might yield.</code></span>
<span class="codeline" id="line-123"><code>//</code></span>
<span class="codeline" id="line-124"><code>// Note that traceGoStopReasons should not be compared, since reasons that are</code></span>
<span class="codeline" id="line-125"><code>// distinct by name may *not* be distinct by value.</code></span>
<span class="codeline" id="line-126"><code>type traceGoStopReason uint8</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>const (</code></span>
<span class="codeline" id="line-129"><code>	traceGoStopGeneric traceGoStopReason = iota</code></span>
<span class="codeline" id="line-130"><code>	traceGoStopGoSched</code></span>
<span class="codeline" id="line-131"><code>	traceGoStopPreempted</code></span>
<span class="codeline" id="line-132"><code>)</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>var traceGoStopReasonStrings = [...]string{</code></span>
<span class="codeline" id="line-135"><code>	traceGoStopGeneric:   "unspecified",</code></span>
<span class="codeline" id="line-136"><code>	traceGoStopGoSched:   "runtime.Gosched",</code></span>
<span class="codeline" id="line-137"><code>	traceGoStopPreempted: "preempted",</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>// traceEnabled returns true if the trace is currently enabled.</code></span>
<span class="codeline" id="line-141"><code>//</code></span>
<span class="codeline" id="line-142"><code>//go:nosplit</code></span>
<span class="codeline" id="line-143"><code>func traceEnabled() bool {</code></span>
<span class="codeline" id="line-144"><code>	return trace.gen.Load() != 0</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// traceShuttingDown returns true if the trace is currently shutting down.</code></span>
<span class="codeline" id="line-148"><code>func traceShuttingDown() bool {</code></span>
<span class="codeline" id="line-149"><code>	return trace.shutdown.Load()</code></span>
<span class="codeline" id="line-150"><code>}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>// traceLocker represents an M writing trace events. While a traceLocker value</code></span>
<span class="codeline" id="line-153"><code>// is valid, the tracer observes all operations on the G/M/P or trace events being</code></span>
<span class="codeline" id="line-154"><code>// written as happening atomically.</code></span>
<span class="codeline" id="line-155"><code>type traceLocker struct {</code></span>
<span class="codeline" id="line-156"><code>	mp  *m</code></span>
<span class="codeline" id="line-157"><code>	gen uintptr</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>// debugTraceReentrancy checks if the trace is reentrant.</code></span>
<span class="codeline" id="line-161"><code>//</code></span>
<span class="codeline" id="line-162"><code>// This is optional because throwing in a function makes it instantly</code></span>
<span class="codeline" id="line-163"><code>// not inlineable, and we want traceAcquire to be inlineable for</code></span>
<span class="codeline" id="line-164"><code>// low overhead when the trace is disabled.</code></span>
<span class="codeline" id="line-165"><code>const debugTraceReentrancy = false</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// traceAcquire prepares this M for writing one or more trace events.</code></span>
<span class="codeline" id="line-168"><code>//</code></span>
<span class="codeline" id="line-169"><code>// nosplit because it's called on the syscall path when stack movement is forbidden.</code></span>
<span class="codeline" id="line-170"><code>//</code></span>
<span class="codeline" id="line-171"><code>//go:nosplit</code></span>
<span class="codeline" id="line-172"><code>func traceAcquire() traceLocker {</code></span>
<span class="codeline" id="line-173"><code>	if !traceEnabled() {</code></span>
<span class="codeline" id="line-174"><code>		return traceLocker{}</code></span>
<span class="codeline" id="line-175"><code>	}</code></span>
<span class="codeline" id="line-176"><code>	return traceAcquireEnabled()</code></span>
<span class="codeline" id="line-177"><code>}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>// traceAcquireEnabled is the traceEnabled path for traceAcquire. It's explicitly</code></span>
<span class="codeline" id="line-180"><code>// broken out to make traceAcquire inlineable to keep the overhead of the tracer</code></span>
<span class="codeline" id="line-181"><code>// when it's disabled low.</code></span>
<span class="codeline" id="line-182"><code>//</code></span>
<span class="codeline" id="line-183"><code>// nosplit because it's called by traceAcquire, which is nosplit.</code></span>
<span class="codeline" id="line-184"><code>//</code></span>
<span class="codeline" id="line-185"><code>//go:nosplit</code></span>
<span class="codeline" id="line-186"><code>func traceAcquireEnabled() traceLocker {</code></span>
<span class="codeline" id="line-187"><code>	// Any time we acquire a traceLocker, we may flush a trace buffer. But</code></span>
<span class="codeline" id="line-188"><code>	// buffer flushes are rare. Record the lock edge even if it doesn't happen</code></span>
<span class="codeline" id="line-189"><code>	// this time.</code></span>
<span class="codeline" id="line-190"><code>	lockRankMayTraceFlush()</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>	// Prevent preemption.</code></span>
<span class="codeline" id="line-193"><code>	mp := acquirem()</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	// Acquire the trace seqlock. This prevents traceAdvance from moving forward</code></span>
<span class="codeline" id="line-196"><code>	// until all Ms are observed to be outside of their seqlock critical section.</code></span>
<span class="codeline" id="line-197"><code>	//</code></span>
<span class="codeline" id="line-198"><code>	// Note: The seqlock is mutated here and also in traceCPUSample. If you update</code></span>
<span class="codeline" id="line-199"><code>	// usage of the seqlock here, make sure to also look at what traceCPUSample is</code></span>
<span class="codeline" id="line-200"><code>	// doing.</code></span>
<span class="codeline" id="line-201"><code>	seq := mp.trace.seqlock.Add(1)</code></span>
<span class="codeline" id="line-202"><code>	if debugTraceReentrancy &amp;&amp; seq%2 != 1 {</code></span>
<span class="codeline" id="line-203"><code>		throw("bad use of trace.seqlock or tracer is reentrant")</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>	// N.B. This load of gen appears redundant with the one in traceEnabled.</code></span>
<span class="codeline" id="line-207"><code>	// However, it's very important that the gen we use for writing to the trace</code></span>
<span class="codeline" id="line-208"><code>	// is acquired under a traceLocker so traceAdvance can make sure no stale</code></span>
<span class="codeline" id="line-209"><code>	// gen values are being used.</code></span>
<span class="codeline" id="line-210"><code>	//</code></span>
<span class="codeline" id="line-211"><code>	// Because we're doing this load again, it also means that the trace</code></span>
<span class="codeline" id="line-212"><code>	// might end up being disabled when we load it. In that case we need to undo</code></span>
<span class="codeline" id="line-213"><code>	// what we did and bail.</code></span>
<span class="codeline" id="line-214"><code>	gen := trace.gen.Load()</code></span>
<span class="codeline" id="line-215"><code>	if gen == 0 {</code></span>
<span class="codeline" id="line-216"><code>		mp.trace.seqlock.Add(1)</code></span>
<span class="codeline" id="line-217"><code>		releasem(mp)</code></span>
<span class="codeline" id="line-218"><code>		return traceLocker{}</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code>	return traceLocker{mp, gen}</code></span>
<span class="codeline" id="line-221"><code>}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>// ok returns true if the traceLocker is valid (i.e. tracing is enabled).</code></span>
<span class="codeline" id="line-224"><code>//</code></span>
<span class="codeline" id="line-225"><code>// nosplit because it's called on the syscall path when stack movement is forbidden.</code></span>
<span class="codeline" id="line-226"><code>//</code></span>
<span class="codeline" id="line-227"><code>//go:nosplit</code></span>
<span class="codeline" id="line-228"><code>func (tl traceLocker) ok() bool {</code></span>
<span class="codeline" id="line-229"><code>	return tl.gen != 0</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>// traceRelease indicates that this M is done writing trace events.</code></span>
<span class="codeline" id="line-233"><code>//</code></span>
<span class="codeline" id="line-234"><code>// nosplit because it's called on the syscall path when stack movement is forbidden.</code></span>
<span class="codeline" id="line-235"><code>//</code></span>
<span class="codeline" id="line-236"><code>//go:nosplit</code></span>
<span class="codeline" id="line-237"><code>func traceRelease(tl traceLocker) {</code></span>
<span class="codeline" id="line-238"><code>	seq := tl.mp.trace.seqlock.Add(1)</code></span>
<span class="codeline" id="line-239"><code>	if debugTraceReentrancy &amp;&amp; seq%2 != 0 {</code></span>
<span class="codeline" id="line-240"><code>		print("runtime: seq=", seq, "\n")</code></span>
<span class="codeline" id="line-241"><code>		throw("bad use of trace.seqlock")</code></span>
<span class="codeline" id="line-242"><code>	}</code></span>
<span class="codeline" id="line-243"><code>	releasem(tl.mp)</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>// traceExitingSyscall marks a goroutine as exiting the syscall slow path.</code></span>
<span class="codeline" id="line-247"><code>//</code></span>
<span class="codeline" id="line-248"><code>// Must be paired with a traceExitedSyscall call.</code></span>
<span class="codeline" id="line-249"><code>func traceExitingSyscall() {</code></span>
<span class="codeline" id="line-250"><code>	trace.exitingSyscall.Add(1)</code></span>
<span class="codeline" id="line-251"><code>}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>// traceExitedSyscall marks a goroutine as having exited the syscall slow path.</code></span>
<span class="codeline" id="line-254"><code>func traceExitedSyscall() {</code></span>
<span class="codeline" id="line-255"><code>	trace.exitingSyscall.Add(-1)</code></span>
<span class="codeline" id="line-256"><code>}</code></span>
<span class="codeline" id="line-257"><code></code></span>
<span class="codeline" id="line-258"><code>// Gomaxprocs emits a ProcsChange event.</code></span>
<span class="codeline" id="line-259"><code>func (tl traceLocker) Gomaxprocs(procs int32) {</code></span>
<span class="codeline" id="line-260"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvProcsChange, traceArg(procs), tl.stack(1))</code></span>
<span class="codeline" id="line-261"><code>}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>// ProcStart traces a ProcStart event.</code></span>
<span class="codeline" id="line-264"><code>//</code></span>
<span class="codeline" id="line-265"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-266"><code>func (tl traceLocker) ProcStart() {</code></span>
<span class="codeline" id="line-267"><code>	pp := tl.mp.p.ptr()</code></span>
<span class="codeline" id="line-268"><code>	// Procs are typically started within the scheduler when there is no user goroutine. If there is a user goroutine,</code></span>
<span class="codeline" id="line-269"><code>	// it must be in _Gsyscall because the only time a goroutine is allowed to have its Proc moved around from under it</code></span>
<span class="codeline" id="line-270"><code>	// is during a syscall.</code></span>
<span class="codeline" id="line-271"><code>	tl.eventWriter(traceGoSyscall, traceProcIdle).commit(traceEvProcStart, traceArg(pp.id), pp.trace.nextSeq(tl.gen))</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// ProcStop traces a ProcStop event.</code></span>
<span class="codeline" id="line-275"><code>func (tl traceLocker) ProcStop(pp *p) {</code></span>
<span class="codeline" id="line-276"><code>	// The only time a goroutine is allowed to have its Proc moved around</code></span>
<span class="codeline" id="line-277"><code>	// from under it is during a syscall.</code></span>
<span class="codeline" id="line-278"><code>	tl.eventWriter(traceGoSyscall, traceProcRunning).commit(traceEvProcStop)</code></span>
<span class="codeline" id="line-279"><code>}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>// GCActive traces a GCActive event.</code></span>
<span class="codeline" id="line-282"><code>//</code></span>
<span class="codeline" id="line-283"><code>// Must be emitted by an actively running goroutine on an active P. This restriction can be changed</code></span>
<span class="codeline" id="line-284"><code>// easily and only depends on where it's currently called.</code></span>
<span class="codeline" id="line-285"><code>func (tl traceLocker) GCActive() {</code></span>
<span class="codeline" id="line-286"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCActive, traceArg(trace.seqGC))</code></span>
<span class="codeline" id="line-287"><code>	// N.B. Only one GC can be running at a time, so this is naturally</code></span>
<span class="codeline" id="line-288"><code>	// serialized by the caller.</code></span>
<span class="codeline" id="line-289"><code>	trace.seqGC++</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>// GCStart traces a GCBegin event.</code></span>
<span class="codeline" id="line-293"><code>//</code></span>
<span class="codeline" id="line-294"><code>// Must be emitted by an actively running goroutine on an active P. This restriction can be changed</code></span>
<span class="codeline" id="line-295"><code>// easily and only depends on where it's currently called.</code></span>
<span class="codeline" id="line-296"><code>func (tl traceLocker) GCStart() {</code></span>
<span class="codeline" id="line-297"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCBegin, traceArg(trace.seqGC), tl.stack(3))</code></span>
<span class="codeline" id="line-298"><code>	// N.B. Only one GC can be running at a time, so this is naturally</code></span>
<span class="codeline" id="line-299"><code>	// serialized by the caller.</code></span>
<span class="codeline" id="line-300"><code>	trace.seqGC++</code></span>
<span class="codeline" id="line-301"><code>}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>// GCDone traces a GCEnd event.</code></span>
<span class="codeline" id="line-304"><code>//</code></span>
<span class="codeline" id="line-305"><code>// Must be emitted by an actively running goroutine on an active P. This restriction can be changed</code></span>
<span class="codeline" id="line-306"><code>// easily and only depends on where it's currently called.</code></span>
<span class="codeline" id="line-307"><code>func (tl traceLocker) GCDone() {</code></span>
<span class="codeline" id="line-308"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCEnd, traceArg(trace.seqGC))</code></span>
<span class="codeline" id="line-309"><code>	// N.B. Only one GC can be running at a time, so this is naturally</code></span>
<span class="codeline" id="line-310"><code>	// serialized by the caller.</code></span>
<span class="codeline" id="line-311"><code>	trace.seqGC++</code></span>
<span class="codeline" id="line-312"><code>}</code></span>
<span class="codeline" id="line-313"><code></code></span>
<span class="codeline" id="line-314"><code>// STWStart traces a STWBegin event.</code></span>
<span class="codeline" id="line-315"><code>func (tl traceLocker) STWStart(reason stwReason) {</code></span>
<span class="codeline" id="line-316"><code>	// Although the current P may be in _Pgcstop here, we model the P as running during the STW. This deviates from the</code></span>
<span class="codeline" id="line-317"><code>	// runtime's state tracking, but it's more accurate and doesn't result in any loss of information.</code></span>
<span class="codeline" id="line-318"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvSTWBegin, tl.string(reason.String()), tl.stack(2))</code></span>
<span class="codeline" id="line-319"><code>}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>// STWDone traces a STWEnd event.</code></span>
<span class="codeline" id="line-322"><code>func (tl traceLocker) STWDone() {</code></span>
<span class="codeline" id="line-323"><code>	// Although the current P may be in _Pgcstop here, we model the P as running during the STW. This deviates from the</code></span>
<span class="codeline" id="line-324"><code>	// runtime's state tracking, but it's more accurate and doesn't result in any loss of information.</code></span>
<span class="codeline" id="line-325"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvSTWEnd)</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// GCSweepStart prepares to trace a sweep loop. This does not</code></span>
<span class="codeline" id="line-329"><code>// emit any events until traceGCSweepSpan is called.</code></span>
<span class="codeline" id="line-330"><code>//</code></span>
<span class="codeline" id="line-331"><code>// GCSweepStart must be paired with traceGCSweepDone and there</code></span>
<span class="codeline" id="line-332"><code>// must be no preemption points between these two calls.</code></span>
<span class="codeline" id="line-333"><code>//</code></span>
<span class="codeline" id="line-334"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-335"><code>func (tl traceLocker) GCSweepStart() {</code></span>
<span class="codeline" id="line-336"><code>	// Delay the actual GCSweepBegin event until the first span</code></span>
<span class="codeline" id="line-337"><code>	// sweep. If we don't sweep anything, don't emit any events.</code></span>
<span class="codeline" id="line-338"><code>	pp := tl.mp.p.ptr()</code></span>
<span class="codeline" id="line-339"><code>	if pp.trace.maySweep {</code></span>
<span class="codeline" id="line-340"><code>		throw("double traceGCSweepStart")</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code>	pp.trace.maySweep, pp.trace.swept, pp.trace.reclaimed = true, 0, 0</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>// GCSweepSpan traces the sweep of a single span. If this is</code></span>
<span class="codeline" id="line-346"><code>// the first span swept since traceGCSweepStart was called, this</code></span>
<span class="codeline" id="line-347"><code>// will emit a GCSweepBegin event.</code></span>
<span class="codeline" id="line-348"><code>//</code></span>
<span class="codeline" id="line-349"><code>// This may be called outside a traceGCSweepStart/traceGCSweepDone</code></span>
<span class="codeline" id="line-350"><code>// pair; however, it will not emit any trace events in this case.</code></span>
<span class="codeline" id="line-351"><code>//</code></span>
<span class="codeline" id="line-352"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-353"><code>func (tl traceLocker) GCSweepSpan(bytesSwept uintptr) {</code></span>
<span class="codeline" id="line-354"><code>	pp := tl.mp.p.ptr()</code></span>
<span class="codeline" id="line-355"><code>	if pp.trace.maySweep {</code></span>
<span class="codeline" id="line-356"><code>		if pp.trace.swept == 0 {</code></span>
<span class="codeline" id="line-357"><code>			tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCSweepBegin, tl.stack(1))</code></span>
<span class="codeline" id="line-358"><code>			pp.trace.inSweep = true</code></span>
<span class="codeline" id="line-359"><code>		}</code></span>
<span class="codeline" id="line-360"><code>		pp.trace.swept += bytesSwept</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>// GCSweepDone finishes tracing a sweep loop. If any memory was</code></span>
<span class="codeline" id="line-365"><code>// swept (i.e. traceGCSweepSpan emitted an event) then this will emit</code></span>
<span class="codeline" id="line-366"><code>// a GCSweepEnd event.</code></span>
<span class="codeline" id="line-367"><code>//</code></span>
<span class="codeline" id="line-368"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-369"><code>func (tl traceLocker) GCSweepDone() {</code></span>
<span class="codeline" id="line-370"><code>	pp := tl.mp.p.ptr()</code></span>
<span class="codeline" id="line-371"><code>	if !pp.trace.maySweep {</code></span>
<span class="codeline" id="line-372"><code>		throw("missing traceGCSweepStart")</code></span>
<span class="codeline" id="line-373"><code>	}</code></span>
<span class="codeline" id="line-374"><code>	if pp.trace.inSweep {</code></span>
<span class="codeline" id="line-375"><code>		tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCSweepEnd, traceArg(pp.trace.swept), traceArg(pp.trace.reclaimed))</code></span>
<span class="codeline" id="line-376"><code>		pp.trace.inSweep = false</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	pp.trace.maySweep = false</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>// GCMarkAssistStart emits a MarkAssistBegin event.</code></span>
<span class="codeline" id="line-382"><code>func (tl traceLocker) GCMarkAssistStart() {</code></span>
<span class="codeline" id="line-383"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCMarkAssistBegin, tl.stack(1))</code></span>
<span class="codeline" id="line-384"><code>}</code></span>
<span class="codeline" id="line-385"><code></code></span>
<span class="codeline" id="line-386"><code>// GCMarkAssistDone emits a MarkAssistEnd event.</code></span>
<span class="codeline" id="line-387"><code>func (tl traceLocker) GCMarkAssistDone() {</code></span>
<span class="codeline" id="line-388"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGCMarkAssistEnd)</code></span>
<span class="codeline" id="line-389"><code>}</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>// GoCreate emits a GoCreate event.</code></span>
<span class="codeline" id="line-392"><code>func (tl traceLocker) GoCreate(newg *g, pc uintptr) {</code></span>
<span class="codeline" id="line-393"><code>	newg.trace.setStatusTraced(tl.gen)</code></span>
<span class="codeline" id="line-394"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGoCreate, traceArg(newg.goid), tl.startPC(pc), tl.stack(2))</code></span>
<span class="codeline" id="line-395"><code>}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>// GoStart emits a GoStart event.</code></span>
<span class="codeline" id="line-398"><code>//</code></span>
<span class="codeline" id="line-399"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-400"><code>func (tl traceLocker) GoStart() {</code></span>
<span class="codeline" id="line-401"><code>	gp := getg().m.curg</code></span>
<span class="codeline" id="line-402"><code>	pp := gp.m.p</code></span>
<span class="codeline" id="line-403"><code>	w := tl.eventWriter(traceGoRunnable, traceProcRunning)</code></span>
<span class="codeline" id="line-404"><code>	w = w.write(traceEvGoStart, traceArg(gp.goid), gp.trace.nextSeq(tl.gen))</code></span>
<span class="codeline" id="line-405"><code>	if pp.ptr().gcMarkWorkerMode != gcMarkWorkerNotWorker {</code></span>
<span class="codeline" id="line-406"><code>		w = w.write(traceEvGoLabel, trace.markWorkerLabels[tl.gen%2][pp.ptr().gcMarkWorkerMode])</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code>	w.end()</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>// GoEnd emits a GoDestroy event.</code></span>
<span class="codeline" id="line-412"><code>//</code></span>
<span class="codeline" id="line-413"><code>// TODO(mknyszek): Rename this to GoDestroy.</code></span>
<span class="codeline" id="line-414"><code>func (tl traceLocker) GoEnd() {</code></span>
<span class="codeline" id="line-415"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGoDestroy)</code></span>
<span class="codeline" id="line-416"><code>}</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>// GoSched emits a GoStop event with a GoSched reason.</code></span>
<span class="codeline" id="line-419"><code>func (tl traceLocker) GoSched() {</code></span>
<span class="codeline" id="line-420"><code>	tl.GoStop(traceGoStopGoSched)</code></span>
<span class="codeline" id="line-421"><code>}</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>// GoPreempt emits a GoStop event with a GoPreempted reason.</code></span>
<span class="codeline" id="line-424"><code>func (tl traceLocker) GoPreempt() {</code></span>
<span class="codeline" id="line-425"><code>	tl.GoStop(traceGoStopPreempted)</code></span>
<span class="codeline" id="line-426"><code>}</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>// GoStop emits a GoStop event with the provided reason.</code></span>
<span class="codeline" id="line-429"><code>func (tl traceLocker) GoStop(reason traceGoStopReason) {</code></span>
<span class="codeline" id="line-430"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGoStop, traceArg(trace.goStopReasons[tl.gen%2][reason]), tl.stack(1))</code></span>
<span class="codeline" id="line-431"><code>}</code></span>
<span class="codeline" id="line-432"><code></code></span>
<span class="codeline" id="line-433"><code>// GoPark emits a GoBlock event with the provided reason.</code></span>
<span class="codeline" id="line-434"><code>//</code></span>
<span class="codeline" id="line-435"><code>// TODO(mknyszek): Replace traceBlockReason with waitReason. It's silly</code></span>
<span class="codeline" id="line-436"><code>// that we have both, and waitReason is way more descriptive.</code></span>
<span class="codeline" id="line-437"><code>func (tl traceLocker) GoPark(reason traceBlockReason, skip int) {</code></span>
<span class="codeline" id="line-438"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGoBlock, traceArg(trace.goBlockReasons[tl.gen%2][reason]), tl.stack(skip))</code></span>
<span class="codeline" id="line-439"><code>}</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>// GoUnpark emits a GoUnblock event.</code></span>
<span class="codeline" id="line-442"><code>func (tl traceLocker) GoUnpark(gp *g, skip int) {</code></span>
<span class="codeline" id="line-443"><code>	// Emit a GoWaiting status if necessary for the unblocked goroutine.</code></span>
<span class="codeline" id="line-444"><code>	w := tl.eventWriter(traceGoRunning, traceProcRunning)</code></span>
<span class="codeline" id="line-445"><code>	if !gp.trace.statusWasTraced(tl.gen) &amp;&amp; gp.trace.acquireStatus(tl.gen) {</code></span>
<span class="codeline" id="line-446"><code>		// Careful: don't use the event writer. We never want status or in-progress events</code></span>
<span class="codeline" id="line-447"><code>		// to trigger more in-progress events.</code></span>
<span class="codeline" id="line-448"><code>		w.w = w.w.writeGoStatus(gp.goid, -1, traceGoWaiting, gp.inMarkAssist)</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code>	w.commit(traceEvGoUnblock, traceArg(gp.goid), gp.trace.nextSeq(tl.gen), tl.stack(skip))</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>// GoSysCall emits a GoSyscallBegin event.</code></span>
<span class="codeline" id="line-454"><code>//</code></span>
<span class="codeline" id="line-455"><code>// Must be called with a valid P.</code></span>
<span class="codeline" id="line-456"><code>func (tl traceLocker) GoSysCall() {</code></span>
<span class="codeline" id="line-457"><code>	var skip int</code></span>
<span class="codeline" id="line-458"><code>	switch {</code></span>
<span class="codeline" id="line-459"><code>	case tracefpunwindoff():</code></span>
<span class="codeline" id="line-460"><code>		// Unwind by skipping 1 frame relative to gp.syscallsp which is captured 3</code></span>
<span class="codeline" id="line-461"><code>		// results by hard coding the number of frames in between our caller and the</code></span>
<span class="codeline" id="line-462"><code>		// actual syscall, see cases below.</code></span>
<span class="codeline" id="line-463"><code>		// TODO(felixge): Implement gp.syscallbp to avoid this workaround?</code></span>
<span class="codeline" id="line-464"><code>		skip = 1</code></span>
<span class="codeline" id="line-465"><code>	case GOOS == "solaris" || GOOS == "illumos":</code></span>
<span class="codeline" id="line-466"><code>		// These platforms don't use a libc_read_trampoline.</code></span>
<span class="codeline" id="line-467"><code>		skip = 3</code></span>
<span class="codeline" id="line-468"><code>	default:</code></span>
<span class="codeline" id="line-469"><code>		// Skip the extra trampoline frame used on most systems.</code></span>
<span class="codeline" id="line-470"><code>		skip = 4</code></span>
<span class="codeline" id="line-471"><code>	}</code></span>
<span class="codeline" id="line-472"><code>	// Scribble down the M that the P is currently attached to.</code></span>
<span class="codeline" id="line-473"><code>	pp := tl.mp.p.ptr()</code></span>
<span class="codeline" id="line-474"><code>	pp.trace.mSyscallID = int64(tl.mp.procid)</code></span>
<span class="codeline" id="line-475"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvGoSyscallBegin, pp.trace.nextSeq(tl.gen), tl.stack(skip))</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>// GoSysExit emits a GoSyscallEnd event, possibly along with a GoSyscallBlocked event</code></span>
<span class="codeline" id="line-479"><code>// if lostP is true.</code></span>
<span class="codeline" id="line-480"><code>//</code></span>
<span class="codeline" id="line-481"><code>// lostP must be true in all cases that a goroutine loses its P during a syscall.</code></span>
<span class="codeline" id="line-482"><code>// This means it's not sufficient to check if it has no P. In particular, it needs to be</code></span>
<span class="codeline" id="line-483"><code>// true in the following cases:</code></span>
<span class="codeline" id="line-484"><code>// - The goroutine lost its P, it ran some other code, and then got it back. It's now running with that P.</code></span>
<span class="codeline" id="line-485"><code>// - The goroutine lost its P and was unable to reacquire it, and is now running without a P.</code></span>
<span class="codeline" id="line-486"><code>// - The goroutine lost its P and acquired a different one, and is now running with that P.</code></span>
<span class="codeline" id="line-487"><code>func (tl traceLocker) GoSysExit(lostP bool) {</code></span>
<span class="codeline" id="line-488"><code>	ev := traceEvGoSyscallEnd</code></span>
<span class="codeline" id="line-489"><code>	procStatus := traceProcSyscall // Procs implicitly enter traceProcSyscall on GoSyscallBegin.</code></span>
<span class="codeline" id="line-490"><code>	if lostP {</code></span>
<span class="codeline" id="line-491"><code>		ev = traceEvGoSyscallEndBlocked</code></span>
<span class="codeline" id="line-492"><code>		procStatus = traceProcRunning // If a G has a P when emitting this event, it reacquired a P and is indeed running.</code></span>
<span class="codeline" id="line-493"><code>	} else {</code></span>
<span class="codeline" id="line-494"><code>		tl.mp.p.ptr().trace.mSyscallID = -1</code></span>
<span class="codeline" id="line-495"><code>	}</code></span>
<span class="codeline" id="line-496"><code>	tl.eventWriter(traceGoSyscall, procStatus).commit(ev)</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>// ProcSteal indicates that our current M stole a P from another M.</code></span>
<span class="codeline" id="line-500"><code>//</code></span>
<span class="codeline" id="line-501"><code>// inSyscall indicates that we're stealing the P from a syscall context.</code></span>
<span class="codeline" id="line-502"><code>//</code></span>
<span class="codeline" id="line-503"><code>// The caller must have ownership of pp.</code></span>
<span class="codeline" id="line-504"><code>func (tl traceLocker) ProcSteal(pp *p, inSyscall bool) {</code></span>
<span class="codeline" id="line-505"><code>	// Grab the M ID we stole from.</code></span>
<span class="codeline" id="line-506"><code>	mStolenFrom := pp.trace.mSyscallID</code></span>
<span class="codeline" id="line-507"><code>	pp.trace.mSyscallID = -1</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	// The status of the proc and goroutine, if we need to emit one here, is not evident from the</code></span>
<span class="codeline" id="line-510"><code>	// context of just emitting this event alone. There are two cases. Either we're trying to steal</code></span>
<span class="codeline" id="line-511"><code>	// the P just to get its attention (e.g. STW or sysmon retake) or we're trying to steal a P for</code></span>
<span class="codeline" id="line-512"><code>	// ourselves specifically to keep running. The two contexts look different, but can be summarized</code></span>
<span class="codeline" id="line-513"><code>	// fairly succinctly. In the former, we're a regular running goroutine and proc, if we have either.</code></span>
<span class="codeline" id="line-514"><code>	// In the latter, we're a goroutine in a syscall.</code></span>
<span class="codeline" id="line-515"><code>	goStatus := traceGoRunning</code></span>
<span class="codeline" id="line-516"><code>	procStatus := traceProcRunning</code></span>
<span class="codeline" id="line-517"><code>	if inSyscall {</code></span>
<span class="codeline" id="line-518"><code>		goStatus = traceGoSyscall</code></span>
<span class="codeline" id="line-519"><code>		procStatus = traceProcSyscallAbandoned</code></span>
<span class="codeline" id="line-520"><code>	}</code></span>
<span class="codeline" id="line-521"><code>	w := tl.eventWriter(goStatus, procStatus)</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	// Emit the status of the P we're stealing. We may have *just* done this when creating the event</code></span>
<span class="codeline" id="line-524"><code>	// writer but it's not guaranteed, even if inSyscall is true. Although it might seem like from a</code></span>
<span class="codeline" id="line-525"><code>	// syscall context we're always stealing a P for ourselves, we may have not wired it up yet (so</code></span>
<span class="codeline" id="line-526"><code>	// it wouldn't be visible to eventWriter) or we may not even intend to wire it up to ourselves</code></span>
<span class="codeline" id="line-527"><code>	// at all (e.g. entersyscall_gcwait).</code></span>
<span class="codeline" id="line-528"><code>	if !pp.trace.statusWasTraced(tl.gen) &amp;&amp; pp.trace.acquireStatus(tl.gen) {</code></span>
<span class="codeline" id="line-529"><code>		// Careful: don't use the event writer. We never want status or in-progress events</code></span>
<span class="codeline" id="line-530"><code>		// to trigger more in-progress events.</code></span>
<span class="codeline" id="line-531"><code>		w.w = w.w.writeProcStatus(uint64(pp.id), traceProcSyscallAbandoned, pp.trace.inSweep)</code></span>
<span class="codeline" id="line-532"><code>	}</code></span>
<span class="codeline" id="line-533"><code>	w.commit(traceEvProcSteal, traceArg(pp.id), pp.trace.nextSeq(tl.gen), traceArg(mStolenFrom))</code></span>
<span class="codeline" id="line-534"><code>}</code></span>
<span class="codeline" id="line-535"><code></code></span>
<span class="codeline" id="line-536"><code>// GoSysBlock is a no-op in the new tracer.</code></span>
<span class="codeline" id="line-537"><code>func (tl traceLocker) GoSysBlock(pp *p) {</code></span>
<span class="codeline" id="line-538"><code>}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>// HeapAlloc emits a HeapAlloc event.</code></span>
<span class="codeline" id="line-541"><code>func (tl traceLocker) HeapAlloc(live uint64) {</code></span>
<span class="codeline" id="line-542"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvHeapAlloc, traceArg(live))</code></span>
<span class="codeline" id="line-543"><code>}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>// HeapGoal reads the current heap goal and emits a HeapGoal event.</code></span>
<span class="codeline" id="line-546"><code>func (tl traceLocker) HeapGoal() {</code></span>
<span class="codeline" id="line-547"><code>	heapGoal := gcController.heapGoal()</code></span>
<span class="codeline" id="line-548"><code>	if heapGoal == ^uint64(0) {</code></span>
<span class="codeline" id="line-549"><code>		// Heap-based triggering is disabled.</code></span>
<span class="codeline" id="line-550"><code>		heapGoal = 0</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvHeapGoal, traceArg(heapGoal))</code></span>
<span class="codeline" id="line-553"><code>}</code></span>
<span class="codeline" id="line-554"><code></code></span>
<span class="codeline" id="line-555"><code>// OneNewExtraM is a no-op in the new tracer. This is worth keeping around though because</code></span>
<span class="codeline" id="line-556"><code>// it's a good place to insert a thread-level event about the new extra M.</code></span>
<span class="codeline" id="line-557"><code>func (tl traceLocker) OneNewExtraM(_ *g) {</code></span>
<span class="codeline" id="line-558"><code>}</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>// GoCreateSyscall indicates that a goroutine has transitioned from dead to GoSyscall.</code></span>
<span class="codeline" id="line-561"><code>//</code></span>
<span class="codeline" id="line-562"><code>// Unlike GoCreate, the caller must be running on gp.</code></span>
<span class="codeline" id="line-563"><code>//</code></span>
<span class="codeline" id="line-564"><code>// This occurs when C code calls into Go. On pthread platforms it occurs only when</code></span>
<span class="codeline" id="line-565"><code>// a C thread calls into Go code for the first time.</code></span>
<span class="codeline" id="line-566"><code>func (tl traceLocker) GoCreateSyscall(gp *g) {</code></span>
<span class="codeline" id="line-567"><code>	// N.B. We should never trace a status for this goroutine (which we're currently running on),</code></span>
<span class="codeline" id="line-568"><code>	// since we want this to appear like goroutine creation.</code></span>
<span class="codeline" id="line-569"><code>	gp.trace.setStatusTraced(tl.gen)</code></span>
<span class="codeline" id="line-570"><code>	tl.eventWriter(traceGoBad, traceProcBad).commit(traceEvGoCreateSyscall, traceArg(gp.goid))</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// GoDestroySyscall indicates that a goroutine has transitioned from GoSyscall to dead.</code></span>
<span class="codeline" id="line-574"><code>//</code></span>
<span class="codeline" id="line-575"><code>// Must not have a P.</code></span>
<span class="codeline" id="line-576"><code>//</code></span>
<span class="codeline" id="line-577"><code>// This occurs when Go code returns back to C. On pthread platforms it occurs only when</code></span>
<span class="codeline" id="line-578"><code>// the C thread is destroyed.</code></span>
<span class="codeline" id="line-579"><code>func (tl traceLocker) GoDestroySyscall() {</code></span>
<span class="codeline" id="line-580"><code>	// N.B. If we trace a status here, we must never have a P, and we must be on a goroutine</code></span>
<span class="codeline" id="line-581"><code>	// that is in the syscall state.</code></span>
<span class="codeline" id="line-582"><code>	tl.eventWriter(traceGoSyscall, traceProcBad).commit(traceEvGoDestroySyscall)</code></span>
<span class="codeline" id="line-583"><code>}</code></span>
<span class="codeline" id="line-584"><code></code></span>
<span class="codeline" id="line-585"><code>// To access runtime functions from runtime/trace.</code></span>
<span class="codeline" id="line-586"><code>// See runtime/trace/annotation.go</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>// trace_userTaskCreate emits a UserTaskCreate event.</code></span>
<span class="codeline" id="line-589"><code>//</code></span>
<span class="codeline" id="line-590"><code>//go:linkname trace_userTaskCreate runtime/trace.userTaskCreate</code></span>
<span class="codeline" id="line-591"><code>func trace_userTaskCreate(id, parentID uint64, taskType string) {</code></span>
<span class="codeline" id="line-592"><code>	tl := traceAcquire()</code></span>
<span class="codeline" id="line-593"><code>	if !tl.ok() {</code></span>
<span class="codeline" id="line-594"><code>		// Need to do this check because the caller won't have it.</code></span>
<span class="codeline" id="line-595"><code>		return</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvUserTaskBegin, traceArg(id), traceArg(parentID), tl.string(taskType), tl.stack(3))</code></span>
<span class="codeline" id="line-598"><code>	traceRelease(tl)</code></span>
<span class="codeline" id="line-599"><code>}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>// trace_userTaskEnd emits a UserTaskEnd event.</code></span>
<span class="codeline" id="line-602"><code>//</code></span>
<span class="codeline" id="line-603"><code>//go:linkname trace_userTaskEnd runtime/trace.userTaskEnd</code></span>
<span class="codeline" id="line-604"><code>func trace_userTaskEnd(id uint64) {</code></span>
<span class="codeline" id="line-605"><code>	tl := traceAcquire()</code></span>
<span class="codeline" id="line-606"><code>	if !tl.ok() {</code></span>
<span class="codeline" id="line-607"><code>		// Need to do this check because the caller won't have it.</code></span>
<span class="codeline" id="line-608"><code>		return</code></span>
<span class="codeline" id="line-609"><code>	}</code></span>
<span class="codeline" id="line-610"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvUserTaskEnd, traceArg(id), tl.stack(2))</code></span>
<span class="codeline" id="line-611"><code>	traceRelease(tl)</code></span>
<span class="codeline" id="line-612"><code>}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>// trace_userTaskEnd emits a UserRegionBegin or UserRegionEnd event,</code></span>
<span class="codeline" id="line-615"><code>// depending on mode (0 == Begin, 1 == End).</code></span>
<span class="codeline" id="line-616"><code>//</code></span>
<span class="codeline" id="line-617"><code>// TODO(mknyszek): Just make this two functions.</code></span>
<span class="codeline" id="line-618"><code>//</code></span>
<span class="codeline" id="line-619"><code>//go:linkname trace_userRegion runtime/trace.userRegion</code></span>
<span class="codeline" id="line-620"><code>func trace_userRegion(id, mode uint64, name string) {</code></span>
<span class="codeline" id="line-621"><code>	tl := traceAcquire()</code></span>
<span class="codeline" id="line-622"><code>	if !tl.ok() {</code></span>
<span class="codeline" id="line-623"><code>		// Need to do this check because the caller won't have it.</code></span>
<span class="codeline" id="line-624"><code>		return</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code>	var ev traceEv</code></span>
<span class="codeline" id="line-627"><code>	switch mode {</code></span>
<span class="codeline" id="line-628"><code>	case 0:</code></span>
<span class="codeline" id="line-629"><code>		ev = traceEvUserRegionBegin</code></span>
<span class="codeline" id="line-630"><code>	case 1:</code></span>
<span class="codeline" id="line-631"><code>		ev = traceEvUserRegionEnd</code></span>
<span class="codeline" id="line-632"><code>	default:</code></span>
<span class="codeline" id="line-633"><code>		return</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(ev, traceArg(id), tl.string(name), tl.stack(3))</code></span>
<span class="codeline" id="line-636"><code>	traceRelease(tl)</code></span>
<span class="codeline" id="line-637"><code>}</code></span>
<span class="codeline" id="line-638"><code></code></span>
<span class="codeline" id="line-639"><code>// trace_userTaskEnd emits a UserRegionBegin or UserRegionEnd event.</code></span>
<span class="codeline" id="line-640"><code>//</code></span>
<span class="codeline" id="line-641"><code>//go:linkname trace_userLog runtime/trace.userLog</code></span>
<span class="codeline" id="line-642"><code>func trace_userLog(id uint64, category, message string) {</code></span>
<span class="codeline" id="line-643"><code>	tl := traceAcquire()</code></span>
<span class="codeline" id="line-644"><code>	if !tl.ok() {</code></span>
<span class="codeline" id="line-645"><code>		// Need to do this check because the caller won't have it.</code></span>
<span class="codeline" id="line-646"><code>		return</code></span>
<span class="codeline" id="line-647"><code>	}</code></span>
<span class="codeline" id="line-648"><code>	tl.eventWriter(traceGoRunning, traceProcRunning).commit(traceEvUserLog, traceArg(id), tl.string(category), tl.uniqueString(message), tl.stack(3))</code></span>
<span class="codeline" id="line-649"><code>	traceRelease(tl)</code></span>
<span class="codeline" id="line-650"><code>}</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>// traceProcFree is called when a P is destroyed.</code></span>
<span class="codeline" id="line-653"><code>//</code></span>
<span class="codeline" id="line-654"><code>// This must run on the system stack to match the old tracer.</code></span>
<span class="codeline" id="line-655"><code>//</code></span>
<span class="codeline" id="line-656"><code>//go:systemstack</code></span>
<span class="codeline" id="line-657"><code>func traceProcFree(_ *p) {</code></span>
<span class="codeline" id="line-658"><code>}</code></span>
<span class="codeline" id="line-659"><code></code></span>
<span class="codeline" id="line-660"><code>// traceThreadDestroy is called when a thread is removed from</code></span>
<span class="codeline" id="line-661"><code>// sched.freem.</code></span>
<span class="codeline" id="line-662"><code>//</code></span>
<span class="codeline" id="line-663"><code>// mp must not be able to emit trace events anymore.</code></span>
<span class="codeline" id="line-664"><code>//</code></span>
<span class="codeline" id="line-665"><code>// sched.lock must be held to synchronize with traceAdvance.</code></span>
<span class="codeline" id="line-666"><code>func traceThreadDestroy(mp *m) {</code></span>
<span class="codeline" id="line-667"><code>	assertLockHeld(&amp;sched.lock)</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>	// Flush all outstanding buffers to maintain the invariant</code></span>
<span class="codeline" id="line-670"><code>	// that an M only has active buffers while on sched.freem</code></span>
<span class="codeline" id="line-671"><code>	// or allm.</code></span>
<span class="codeline" id="line-672"><code>	//</code></span>
<span class="codeline" id="line-673"><code>	// Perform a traceAcquire/traceRelease on behalf of mp to</code></span>
<span class="codeline" id="line-674"><code>	// synchronize with the tracer trying to flush our buffer</code></span>
<span class="codeline" id="line-675"><code>	// as well.</code></span>
<span class="codeline" id="line-676"><code>	seq := mp.trace.seqlock.Add(1)</code></span>
<span class="codeline" id="line-677"><code>	if debugTraceReentrancy &amp;&amp; seq%2 != 1 {</code></span>
<span class="codeline" id="line-678"><code>		throw("bad use of trace.seqlock or tracer is reentrant")</code></span>
<span class="codeline" id="line-679"><code>	}</code></span>
<span class="codeline" id="line-680"><code>	systemstack(func() {</code></span>
<span class="codeline" id="line-681"><code>		lock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-682"><code>		for i := range mp.trace.buf {</code></span>
<span class="codeline" id="line-683"><code>			if mp.trace.buf[i] != nil {</code></span>
<span class="codeline" id="line-684"><code>				// N.B. traceBufFlush accepts a generation, but it</code></span>
<span class="codeline" id="line-685"><code>				// really just cares about gen%2.</code></span>
<span class="codeline" id="line-686"><code>				traceBufFlush(mp.trace.buf[i], uintptr(i))</code></span>
<span class="codeline" id="line-687"><code>				mp.trace.buf[i] = nil</code></span>
<span class="codeline" id="line-688"><code>			}</code></span>
<span class="codeline" id="line-689"><code>		}</code></span>
<span class="codeline" id="line-690"><code>		unlock(&amp;trace.lock)</code></span>
<span class="codeline" id="line-691"><code>	})</code></span>
<span class="codeline" id="line-692"><code>	seq1 := mp.trace.seqlock.Add(1)</code></span>
<span class="codeline" id="line-693"><code>	if seq1 != seq+1 {</code></span>
<span class="codeline" id="line-694"><code>		print("runtime: seq1=", seq1, "\n")</code></span>
<span class="codeline" id="line-695"><code>		throw("bad use of trace.seqlock")</code></span>
<span class="codeline" id="line-696"><code>	}</code></span>
<span class="codeline" id="line-697"><code>}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// Not used in the new tracer; solely for compatibility with the old tracer.</code></span>
<span class="codeline" id="line-700"><code>// nosplit because it's called from exitsyscall without a P.</code></span>
<span class="codeline" id="line-701"><code>//</code></span>
<span class="codeline" id="line-702"><code>//go:nosplit</code></span>
<span class="codeline" id="line-703"><code>func (_ traceLocker) RecordSyscallExitedTime(_ *g, _ *p) {</code></span>
<span class="codeline" id="line-704"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>