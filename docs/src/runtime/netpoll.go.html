<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: netpoll.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	netpoll.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>//go:build unix || (js &amp;&amp; wasm) || wasip1 || windows</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package runtime</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-11"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-12"><code>	"unsafe"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>// Integrated network poller (platform-independent part).</code></span>
<span class="codeline" id="line-16"><code>// A particular implementation (epoll/kqueue/port/AIX/Windows)</code></span>
<span class="codeline" id="line-17"><code>// must define the following functions:</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>// func netpollinit()</code></span>
<span class="codeline" id="line-20"><code>//     Initialize the poller. Only called once.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// func netpollopen(fd uintptr, pd *pollDesc) int32</code></span>
<span class="codeline" id="line-23"><code>//     Arm edge-triggered notifications for fd. The pd argument is to pass</code></span>
<span class="codeline" id="line-24"><code>//     back to netpollready when fd is ready. Return an errno value.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// func netpollclose(fd uintptr) int32</code></span>
<span class="codeline" id="line-27"><code>//     Disable notifications for fd. Return an errno value.</code></span>
<span class="codeline" id="line-28"><code>//</code></span>
<span class="codeline" id="line-29"><code>// func netpoll(delta int64) (gList, int32)</code></span>
<span class="codeline" id="line-30"><code>//     Poll the network. If delta &lt; 0, block indefinitely. If delta == 0,</code></span>
<span class="codeline" id="line-31"><code>//     poll without blocking. If delta &gt; 0, block for up to delta nanoseconds.</code></span>
<span class="codeline" id="line-32"><code>//     Return a list of goroutines built by calling netpollready,</code></span>
<span class="codeline" id="line-33"><code>//     and a delta to add to netpollWaiters when all goroutines are ready.</code></span>
<span class="codeline" id="line-34"><code>//     This will never return an empty list with a non-zero delta.</code></span>
<span class="codeline" id="line-35"><code>//</code></span>
<span class="codeline" id="line-36"><code>// func netpollBreak()</code></span>
<span class="codeline" id="line-37"><code>//     Wake up the network poller, assumed to be blocked in netpoll.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// func netpollIsPollDescriptor(fd uintptr) bool</code></span>
<span class="codeline" id="line-40"><code>//     Reports whether fd is a file descriptor used by the poller.</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>// Error codes returned by runtime_pollReset and runtime_pollWait.</code></span>
<span class="codeline" id="line-43"><code>// These must match the values in internal/poll/fd_poll_runtime.go.</code></span>
<span class="codeline" id="line-44"><code>const (</code></span>
<span class="codeline" id="line-45"><code>	pollNoError        = 0 // no error</code></span>
<span class="codeline" id="line-46"><code>	pollErrClosing     = 1 // descriptor is closed</code></span>
<span class="codeline" id="line-47"><code>	pollErrTimeout     = 2 // I/O timeout</code></span>
<span class="codeline" id="line-48"><code>	pollErrNotPollable = 3 // general error polling descriptor</code></span>
<span class="codeline" id="line-49"><code>)</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// pollDesc contains 2 binary semaphores, rg and wg, to park reader and writer</code></span>
<span class="codeline" id="line-52"><code>// goroutines respectively. The semaphore can be in the following states:</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>//	pdReady - io readiness notification is pending;</code></span>
<span class="codeline" id="line-55"><code>//	          a goroutine consumes the notification by changing the state to pdNil.</code></span>
<span class="codeline" id="line-56"><code>//	pdWait - a goroutine prepares to park on the semaphore, but not yet parked;</code></span>
<span class="codeline" id="line-57"><code>//	         the goroutine commits to park by changing the state to G pointer,</code></span>
<span class="codeline" id="line-58"><code>//	         or, alternatively, concurrent io notification changes the state to pdReady,</code></span>
<span class="codeline" id="line-59"><code>//	         or, alternatively, concurrent timeout/close changes the state to pdNil.</code></span>
<span class="codeline" id="line-60"><code>//	G pointer - the goroutine is blocked on the semaphore;</code></span>
<span class="codeline" id="line-61"><code>//	            io notification or timeout/close changes the state to pdReady or pdNil respectively</code></span>
<span class="codeline" id="line-62"><code>//	            and unparks the goroutine.</code></span>
<span class="codeline" id="line-63"><code>//	pdNil - none of the above.</code></span>
<span class="codeline" id="line-64"><code>const (</code></span>
<span class="codeline" id="line-65"><code>	pdNil   uintptr = 0</code></span>
<span class="codeline" id="line-66"><code>	pdReady uintptr = 1</code></span>
<span class="codeline" id="line-67"><code>	pdWait  uintptr = 2</code></span>
<span class="codeline" id="line-68"><code>)</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>const pollBlockSize = 4 * 1024</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>// Network poller descriptor.</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>// No heap pointers.</code></span>
<span class="codeline" id="line-75"><code>type pollDesc struct {</code></span>
<span class="codeline" id="line-76"><code>	_     sys.NotInHeap</code></span>
<span class="codeline" id="line-77"><code>	link  *pollDesc      // in pollcache, protected by pollcache.lock</code></span>
<span class="codeline" id="line-78"><code>	fd    uintptr        // constant for pollDesc usage lifetime</code></span>
<span class="codeline" id="line-79"><code>	fdseq atomic.Uintptr // protects against stale pollDesc</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>	// atomicInfo holds bits from closing, rd, and wd,</code></span>
<span class="codeline" id="line-82"><code>	// which are only ever written while holding the lock,</code></span>
<span class="codeline" id="line-83"><code>	// summarized for use by netpollcheckerr,</code></span>
<span class="codeline" id="line-84"><code>	// which cannot acquire the lock.</code></span>
<span class="codeline" id="line-85"><code>	// After writing these fields under lock in a way that</code></span>
<span class="codeline" id="line-86"><code>	// might change the summary, code must call publishInfo</code></span>
<span class="codeline" id="line-87"><code>	// before releasing the lock.</code></span>
<span class="codeline" id="line-88"><code>	// Code that changes fields and then calls netpollunblock</code></span>
<span class="codeline" id="line-89"><code>	// (while still holding the lock) must call publishInfo</code></span>
<span class="codeline" id="line-90"><code>	// before calling netpollunblock, because publishInfo is what</code></span>
<span class="codeline" id="line-91"><code>	// stops netpollblock from blocking anew</code></span>
<span class="codeline" id="line-92"><code>	// (by changing the result of netpollcheckerr).</code></span>
<span class="codeline" id="line-93"><code>	// atomicInfo also holds the eventErr bit,</code></span>
<span class="codeline" id="line-94"><code>	// recording whether a poll event on the fd got an error;</code></span>
<span class="codeline" id="line-95"><code>	// atomicInfo is the only source of truth for that bit.</code></span>
<span class="codeline" id="line-96"><code>	atomicInfo atomic.Uint32 // atomic pollInfo</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>	// rg, wg are accessed atomically and hold g pointers.</code></span>
<span class="codeline" id="line-99"><code>	// (Using atomic.Uintptr here is similar to using guintptr elsewhere.)</code></span>
<span class="codeline" id="line-100"><code>	rg atomic.Uintptr // pdReady, pdWait, G waiting for read or pdNil</code></span>
<span class="codeline" id="line-101"><code>	wg atomic.Uintptr // pdReady, pdWait, G waiting for write or pdNil</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>	lock    mutex // protects the following fields</code></span>
<span class="codeline" id="line-104"><code>	closing bool</code></span>
<span class="codeline" id="line-105"><code>	user    uint32    // user settable cookie</code></span>
<span class="codeline" id="line-106"><code>	rseq    uintptr   // protects from stale read timers</code></span>
<span class="codeline" id="line-107"><code>	rt      timer     // read deadline timer (set if rt.f != nil)</code></span>
<span class="codeline" id="line-108"><code>	rd      int64     // read deadline (a nanotime in the future, -1 when expired)</code></span>
<span class="codeline" id="line-109"><code>	wseq    uintptr   // protects from stale write timers</code></span>
<span class="codeline" id="line-110"><code>	wt      timer     // write deadline timer</code></span>
<span class="codeline" id="line-111"><code>	wd      int64     // write deadline (a nanotime in the future, -1 when expired)</code></span>
<span class="codeline" id="line-112"><code>	self    *pollDesc // storage for indirect interface. See (*pollDesc).makeArg.</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// pollInfo is the bits needed by netpollcheckerr, stored atomically,</code></span>
<span class="codeline" id="line-116"><code>// mostly duplicating state that is manipulated under lock in pollDesc.</code></span>
<span class="codeline" id="line-117"><code>// The one exception is the pollEventErr bit, which is maintained only</code></span>
<span class="codeline" id="line-118"><code>// in the pollInfo.</code></span>
<span class="codeline" id="line-119"><code>type pollInfo uint32</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>const (</code></span>
<span class="codeline" id="line-122"><code>	pollClosing = 1 &lt;&lt; iota</code></span>
<span class="codeline" id="line-123"><code>	pollEventErr</code></span>
<span class="codeline" id="line-124"><code>	pollExpiredReadDeadline</code></span>
<span class="codeline" id="line-125"><code>	pollExpiredWriteDeadline</code></span>
<span class="codeline" id="line-126"><code>	pollFDSeq // 20 bit field, low 20 bits of fdseq field</code></span>
<span class="codeline" id="line-127"><code>)</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>const (</code></span>
<span class="codeline" id="line-130"><code>	pollFDSeqBits = 20                   // number of bits in pollFDSeq</code></span>
<span class="codeline" id="line-131"><code>	pollFDSeqMask = 1&lt;&lt;pollFDSeqBits - 1 // mask for pollFDSeq</code></span>
<span class="codeline" id="line-132"><code>)</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>func (i pollInfo) closing() bool              { return i&amp;pollClosing != 0 }</code></span>
<span class="codeline" id="line-135"><code>func (i pollInfo) eventErr() bool             { return i&amp;pollEventErr != 0 }</code></span>
<span class="codeline" id="line-136"><code>func (i pollInfo) expiredReadDeadline() bool  { return i&amp;pollExpiredReadDeadline != 0 }</code></span>
<span class="codeline" id="line-137"><code>func (i pollInfo) expiredWriteDeadline() bool { return i&amp;pollExpiredWriteDeadline != 0 }</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// info returns the pollInfo corresponding to pd.</code></span>
<span class="codeline" id="line-140"><code>func (pd *pollDesc) info() pollInfo {</code></span>
<span class="codeline" id="line-141"><code>	return pollInfo(pd.atomicInfo.Load())</code></span>
<span class="codeline" id="line-142"><code>}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>// publishInfo updates pd.atomicInfo (returned by pd.info)</code></span>
<span class="codeline" id="line-145"><code>// using the other values in pd.</code></span>
<span class="codeline" id="line-146"><code>// It must be called while holding pd.lock,</code></span>
<span class="codeline" id="line-147"><code>// and it must be called after changing anything</code></span>
<span class="codeline" id="line-148"><code>// that might affect the info bits.</code></span>
<span class="codeline" id="line-149"><code>// In practice this means after changing closing</code></span>
<span class="codeline" id="line-150"><code>// or changing rd or wd from &lt; 0 to &gt;= 0.</code></span>
<span class="codeline" id="line-151"><code>func (pd *pollDesc) publishInfo() {</code></span>
<span class="codeline" id="line-152"><code>	var info uint32</code></span>
<span class="codeline" id="line-153"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-154"><code>		info |= pollClosing</code></span>
<span class="codeline" id="line-155"><code>	}</code></span>
<span class="codeline" id="line-156"><code>	if pd.rd &lt; 0 {</code></span>
<span class="codeline" id="line-157"><code>		info |= pollExpiredReadDeadline</code></span>
<span class="codeline" id="line-158"><code>	}</code></span>
<span class="codeline" id="line-159"><code>	if pd.wd &lt; 0 {</code></span>
<span class="codeline" id="line-160"><code>		info |= pollExpiredWriteDeadline</code></span>
<span class="codeline" id="line-161"><code>	}</code></span>
<span class="codeline" id="line-162"><code>	info |= uint32(pd.fdseq.Load()&amp;pollFDSeqMask) &lt;&lt; pollFDSeq</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	// Set all of x except the pollEventErr bit.</code></span>
<span class="codeline" id="line-165"><code>	x := pd.atomicInfo.Load()</code></span>
<span class="codeline" id="line-166"><code>	for !pd.atomicInfo.CompareAndSwap(x, (x&amp;pollEventErr)|info) {</code></span>
<span class="codeline" id="line-167"><code>		x = pd.atomicInfo.Load()</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code>}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>// setEventErr sets the result of pd.info().eventErr() to b.</code></span>
<span class="codeline" id="line-172"><code>// We only change the error bit if seq == 0 or if seq matches pollFDSeq</code></span>
<span class="codeline" id="line-173"><code>// (issue #59545).</code></span>
<span class="codeline" id="line-174"><code>func (pd *pollDesc) setEventErr(b bool, seq uintptr) {</code></span>
<span class="codeline" id="line-175"><code>	mSeq := uint32(seq &amp; pollFDSeqMask)</code></span>
<span class="codeline" id="line-176"><code>	x := pd.atomicInfo.Load()</code></span>
<span class="codeline" id="line-177"><code>	xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</code></span>
<span class="codeline" id="line-178"><code>	if seq != 0 &amp;&amp; xSeq != mSeq {</code></span>
<span class="codeline" id="line-179"><code>		return</code></span>
<span class="codeline" id="line-180"><code>	}</code></span>
<span class="codeline" id="line-181"><code>	for (x&amp;pollEventErr != 0) != b &amp;&amp; !pd.atomicInfo.CompareAndSwap(x, x^pollEventErr) {</code></span>
<span class="codeline" id="line-182"><code>		x = pd.atomicInfo.Load()</code></span>
<span class="codeline" id="line-183"><code>		xSeq := (x &gt;&gt; pollFDSeq) &amp; pollFDSeqMask</code></span>
<span class="codeline" id="line-184"><code>		if seq != 0 &amp;&amp; xSeq != mSeq {</code></span>
<span class="codeline" id="line-185"><code>			return</code></span>
<span class="codeline" id="line-186"><code>		}</code></span>
<span class="codeline" id="line-187"><code>	}</code></span>
<span class="codeline" id="line-188"><code>}</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>type pollCache struct {</code></span>
<span class="codeline" id="line-191"><code>	lock  mutex</code></span>
<span class="codeline" id="line-192"><code>	first *pollDesc</code></span>
<span class="codeline" id="line-193"><code>	// PollDesc objects must be type-stable,</code></span>
<span class="codeline" id="line-194"><code>	// because we can get ready notification from epoll/kqueue</code></span>
<span class="codeline" id="line-195"><code>	// after the descriptor is closed/reused.</code></span>
<span class="codeline" id="line-196"><code>	// Stale notifications are detected using seq variable,</code></span>
<span class="codeline" id="line-197"><code>	// seq is incremented when deadlines are changed or descriptor is reused.</code></span>
<span class="codeline" id="line-198"><code>}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>var (</code></span>
<span class="codeline" id="line-201"><code>	netpollInitLock mutex</code></span>
<span class="codeline" id="line-202"><code>	netpollInited   atomic.Uint32</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	pollcache      pollCache</code></span>
<span class="codeline" id="line-205"><code>	netpollWaiters atomic.Uint32</code></span>
<span class="codeline" id="line-206"><code>)</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>//go:linkname poll_runtime_pollServerInit internal/poll.runtime_pollServerInit</code></span>
<span class="codeline" id="line-209"><code>func poll_runtime_pollServerInit() {</code></span>
<span class="codeline" id="line-210"><code>	netpollGenericInit()</code></span>
<span class="codeline" id="line-211"><code>}</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>func netpollGenericInit() {</code></span>
<span class="codeline" id="line-214"><code>	if netpollInited.Load() == 0 {</code></span>
<span class="codeline" id="line-215"><code>		lockInit(&amp;netpollInitLock, lockRankNetpollInit)</code></span>
<span class="codeline" id="line-216"><code>		lock(&amp;netpollInitLock)</code></span>
<span class="codeline" id="line-217"><code>		if netpollInited.Load() == 0 {</code></span>
<span class="codeline" id="line-218"><code>			netpollinit()</code></span>
<span class="codeline" id="line-219"><code>			netpollInited.Store(1)</code></span>
<span class="codeline" id="line-220"><code>		}</code></span>
<span class="codeline" id="line-221"><code>		unlock(&amp;netpollInitLock)</code></span>
<span class="codeline" id="line-222"><code>	}</code></span>
<span class="codeline" id="line-223"><code>}</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>func netpollinited() bool {</code></span>
<span class="codeline" id="line-226"><code>	return netpollInited.Load() != 0</code></span>
<span class="codeline" id="line-227"><code>}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>//go:linkname poll_runtime_isPollServerDescriptor internal/poll.runtime_isPollServerDescriptor</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>// poll_runtime_isPollServerDescriptor reports whether fd is a</code></span>
<span class="codeline" id="line-232"><code>// descriptor being used by netpoll.</code></span>
<span class="codeline" id="line-233"><code>func poll_runtime_isPollServerDescriptor(fd uintptr) bool {</code></span>
<span class="codeline" id="line-234"><code>	return netpollIsPollDescriptor(fd)</code></span>
<span class="codeline" id="line-235"><code>}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen</code></span>
<span class="codeline" id="line-238"><code>func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {</code></span>
<span class="codeline" id="line-239"><code>	pd := pollcache.alloc()</code></span>
<span class="codeline" id="line-240"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-241"><code>	wg := pd.wg.Load()</code></span>
<span class="codeline" id="line-242"><code>	if wg != pdNil &amp;&amp; wg != pdReady {</code></span>
<span class="codeline" id="line-243"><code>		throw("runtime: blocked write on free polldesc")</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	rg := pd.rg.Load()</code></span>
<span class="codeline" id="line-246"><code>	if rg != pdNil &amp;&amp; rg != pdReady {</code></span>
<span class="codeline" id="line-247"><code>		throw("runtime: blocked read on free polldesc")</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code>	pd.fd = fd</code></span>
<span class="codeline" id="line-250"><code>	if pd.fdseq.Load() == 0 {</code></span>
<span class="codeline" id="line-251"><code>		// The value 0 is special in setEventErr, so don't use it.</code></span>
<span class="codeline" id="line-252"><code>		pd.fdseq.Store(1)</code></span>
<span class="codeline" id="line-253"><code>	}</code></span>
<span class="codeline" id="line-254"><code>	pd.closing = false</code></span>
<span class="codeline" id="line-255"><code>	pd.setEventErr(false, 0)</code></span>
<span class="codeline" id="line-256"><code>	pd.rseq++</code></span>
<span class="codeline" id="line-257"><code>	pd.rg.Store(pdNil)</code></span>
<span class="codeline" id="line-258"><code>	pd.rd = 0</code></span>
<span class="codeline" id="line-259"><code>	pd.wseq++</code></span>
<span class="codeline" id="line-260"><code>	pd.wg.Store(pdNil)</code></span>
<span class="codeline" id="line-261"><code>	pd.wd = 0</code></span>
<span class="codeline" id="line-262"><code>	pd.self = pd</code></span>
<span class="codeline" id="line-263"><code>	pd.publishInfo()</code></span>
<span class="codeline" id="line-264"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>	errno := netpollopen(fd, pd)</code></span>
<span class="codeline" id="line-267"><code>	if errno != 0 {</code></span>
<span class="codeline" id="line-268"><code>		pollcache.free(pd)</code></span>
<span class="codeline" id="line-269"><code>		return nil, int(errno)</code></span>
<span class="codeline" id="line-270"><code>	}</code></span>
<span class="codeline" id="line-271"><code>	return pd, 0</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>//go:linkname poll_runtime_pollClose internal/poll.runtime_pollClose</code></span>
<span class="codeline" id="line-275"><code>func poll_runtime_pollClose(pd *pollDesc) {</code></span>
<span class="codeline" id="line-276"><code>	if !pd.closing {</code></span>
<span class="codeline" id="line-277"><code>		throw("runtime: close polldesc w/o unblock")</code></span>
<span class="codeline" id="line-278"><code>	}</code></span>
<span class="codeline" id="line-279"><code>	wg := pd.wg.Load()</code></span>
<span class="codeline" id="line-280"><code>	if wg != pdNil &amp;&amp; wg != pdReady {</code></span>
<span class="codeline" id="line-281"><code>		throw("runtime: blocked write on closing polldesc")</code></span>
<span class="codeline" id="line-282"><code>	}</code></span>
<span class="codeline" id="line-283"><code>	rg := pd.rg.Load()</code></span>
<span class="codeline" id="line-284"><code>	if rg != pdNil &amp;&amp; rg != pdReady {</code></span>
<span class="codeline" id="line-285"><code>		throw("runtime: blocked read on closing polldesc")</code></span>
<span class="codeline" id="line-286"><code>	}</code></span>
<span class="codeline" id="line-287"><code>	netpollclose(pd.fd)</code></span>
<span class="codeline" id="line-288"><code>	pollcache.free(pd)</code></span>
<span class="codeline" id="line-289"><code>}</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>func (c *pollCache) free(pd *pollDesc) {</code></span>
<span class="codeline" id="line-292"><code>	// pd can't be shared here, but lock anyhow because</code></span>
<span class="codeline" id="line-293"><code>	// that's what publishInfo documents.</code></span>
<span class="codeline" id="line-294"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>	// Increment the fdseq field, so that any currently</code></span>
<span class="codeline" id="line-297"><code>	// running netpoll calls will not mark pd as ready.</code></span>
<span class="codeline" id="line-298"><code>	fdseq := pd.fdseq.Load()</code></span>
<span class="codeline" id="line-299"><code>	fdseq = (fdseq + 1) &amp; (1&lt;&lt;taggedPointerBits - 1)</code></span>
<span class="codeline" id="line-300"><code>	pd.fdseq.Store(fdseq)</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>	pd.publishInfo()</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>	lock(&amp;c.lock)</code></span>
<span class="codeline" id="line-307"><code>	pd.link = c.first</code></span>
<span class="codeline" id="line-308"><code>	c.first = pd</code></span>
<span class="codeline" id="line-309"><code>	unlock(&amp;c.lock)</code></span>
<span class="codeline" id="line-310"><code>}</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// poll_runtime_pollReset, which is internal/poll.runtime_pollReset,</code></span>
<span class="codeline" id="line-313"><code>// prepares a descriptor for polling in mode, which is 'r' or 'w'.</code></span>
<span class="codeline" id="line-314"><code>// This returns an error code; the codes are defined above.</code></span>
<span class="codeline" id="line-315"><code>//</code></span>
<span class="codeline" id="line-316"><code>//go:linkname poll_runtime_pollReset internal/poll.runtime_pollReset</code></span>
<span class="codeline" id="line-317"><code>func poll_runtime_pollReset(pd *pollDesc, mode int) int {</code></span>
<span class="codeline" id="line-318"><code>	errcode := netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-319"><code>	if errcode != pollNoError {</code></span>
<span class="codeline" id="line-320"><code>		return errcode</code></span>
<span class="codeline" id="line-321"><code>	}</code></span>
<span class="codeline" id="line-322"><code>	if mode == 'r' {</code></span>
<span class="codeline" id="line-323"><code>		pd.rg.Store(pdNil)</code></span>
<span class="codeline" id="line-324"><code>	} else if mode == 'w' {</code></span>
<span class="codeline" id="line-325"><code>		pd.wg.Store(pdNil)</code></span>
<span class="codeline" id="line-326"><code>	}</code></span>
<span class="codeline" id="line-327"><code>	return pollNoError</code></span>
<span class="codeline" id="line-328"><code>}</code></span>
<span class="codeline" id="line-329"><code></code></span>
<span class="codeline" id="line-330"><code>// poll_runtime_pollWait, which is internal/poll.runtime_pollWait,</code></span>
<span class="codeline" id="line-331"><code>// waits for a descriptor to be ready for reading or writing,</code></span>
<span class="codeline" id="line-332"><code>// according to mode, which is 'r' or 'w'.</code></span>
<span class="codeline" id="line-333"><code>// This returns an error code; the codes are defined above.</code></span>
<span class="codeline" id="line-334"><code>//</code></span>
<span class="codeline" id="line-335"><code>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</code></span>
<span class="codeline" id="line-336"><code>func poll_runtime_pollWait(pd *pollDesc, mode int) int {</code></span>
<span class="codeline" id="line-337"><code>	errcode := netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-338"><code>	if errcode != pollNoError {</code></span>
<span class="codeline" id="line-339"><code>		return errcode</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code>	// As for now only Solaris, illumos, AIX and wasip1 use level-triggered IO.</code></span>
<span class="codeline" id="line-342"><code>	if GOOS == "solaris" || GOOS == "illumos" || GOOS == "aix" || GOOS == "wasip1" {</code></span>
<span class="codeline" id="line-343"><code>		netpollarm(pd, mode)</code></span>
<span class="codeline" id="line-344"><code>	}</code></span>
<span class="codeline" id="line-345"><code>	for !netpollblock(pd, int32(mode), false) {</code></span>
<span class="codeline" id="line-346"><code>		errcode = netpollcheckerr(pd, int32(mode))</code></span>
<span class="codeline" id="line-347"><code>		if errcode != pollNoError {</code></span>
<span class="codeline" id="line-348"><code>			return errcode</code></span>
<span class="codeline" id="line-349"><code>		}</code></span>
<span class="codeline" id="line-350"><code>		// Can happen if timeout has fired and unblocked us,</code></span>
<span class="codeline" id="line-351"><code>		// but before we had a chance to run, timeout has been reset.</code></span>
<span class="codeline" id="line-352"><code>		// Pretend it has not happened and retry.</code></span>
<span class="codeline" id="line-353"><code>	}</code></span>
<span class="codeline" id="line-354"><code>	return pollNoError</code></span>
<span class="codeline" id="line-355"><code>}</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>//go:linkname poll_runtime_pollWaitCanceled internal/poll.runtime_pollWaitCanceled</code></span>
<span class="codeline" id="line-358"><code>func poll_runtime_pollWaitCanceled(pd *pollDesc, mode int) {</code></span>
<span class="codeline" id="line-359"><code>	// This function is used only on windows after a failed attempt to cancel</code></span>
<span class="codeline" id="line-360"><code>	// a pending async IO operation. Wait for ioready, ignore closing or timeouts.</code></span>
<span class="codeline" id="line-361"><code>	for !netpollblock(pd, int32(mode), true) {</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</code></span>
<span class="codeline" id="line-366"><code>func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {</code></span>
<span class="codeline" id="line-367"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-368"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-369"><code>		unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-370"><code>		return</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code>	rd0, wd0 := pd.rd, pd.wd</code></span>
<span class="codeline" id="line-373"><code>	combo0 := rd0 &gt; 0 &amp;&amp; rd0 == wd0</code></span>
<span class="codeline" id="line-374"><code>	if d &gt; 0 {</code></span>
<span class="codeline" id="line-375"><code>		d += nanotime()</code></span>
<span class="codeline" id="line-376"><code>		if d &lt;= 0 {</code></span>
<span class="codeline" id="line-377"><code>			// If the user has a deadline in the future, but the delay calculation</code></span>
<span class="codeline" id="line-378"><code>			// overflows, then set the deadline to the maximum possible value.</code></span>
<span class="codeline" id="line-379"><code>			d = 1&lt;&lt;63 - 1</code></span>
<span class="codeline" id="line-380"><code>		}</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code>	if mode == 'r' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-383"><code>		pd.rd = d</code></span>
<span class="codeline" id="line-384"><code>	}</code></span>
<span class="codeline" id="line-385"><code>	if mode == 'w' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-386"><code>		pd.wd = d</code></span>
<span class="codeline" id="line-387"><code>	}</code></span>
<span class="codeline" id="line-388"><code>	pd.publishInfo()</code></span>
<span class="codeline" id="line-389"><code>	combo := pd.rd &gt; 0 &amp;&amp; pd.rd == pd.wd</code></span>
<span class="codeline" id="line-390"><code>	rtf := netpollReadDeadline</code></span>
<span class="codeline" id="line-391"><code>	if combo {</code></span>
<span class="codeline" id="line-392"><code>		rtf = netpollDeadline</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	if pd.rt.f == nil {</code></span>
<span class="codeline" id="line-395"><code>		if pd.rd &gt; 0 {</code></span>
<span class="codeline" id="line-396"><code>			pd.rt.f = rtf</code></span>
<span class="codeline" id="line-397"><code>			// Copy current seq into the timer arg.</code></span>
<span class="codeline" id="line-398"><code>			// Timer func will check the seq against current descriptor seq,</code></span>
<span class="codeline" id="line-399"><code>			// if they differ the descriptor was reused or timers were reset.</code></span>
<span class="codeline" id="line-400"><code>			pd.rt.arg = pd.makeArg()</code></span>
<span class="codeline" id="line-401"><code>			pd.rt.seq = pd.rseq</code></span>
<span class="codeline" id="line-402"><code>			resettimer(&amp;pd.rt, pd.rd)</code></span>
<span class="codeline" id="line-403"><code>		}</code></span>
<span class="codeline" id="line-404"><code>	} else if pd.rd != rd0 || combo != combo0 {</code></span>
<span class="codeline" id="line-405"><code>		pd.rseq++ // invalidate current timers</code></span>
<span class="codeline" id="line-406"><code>		if pd.rd &gt; 0 {</code></span>
<span class="codeline" id="line-407"><code>			modtimer(&amp;pd.rt, pd.rd, 0, rtf, pd.makeArg(), pd.rseq)</code></span>
<span class="codeline" id="line-408"><code>		} else {</code></span>
<span class="codeline" id="line-409"><code>			deltimer(&amp;pd.rt)</code></span>
<span class="codeline" id="line-410"><code>			pd.rt.f = nil</code></span>
<span class="codeline" id="line-411"><code>		}</code></span>
<span class="codeline" id="line-412"><code>	}</code></span>
<span class="codeline" id="line-413"><code>	if pd.wt.f == nil {</code></span>
<span class="codeline" id="line-414"><code>		if pd.wd &gt; 0 &amp;&amp; !combo {</code></span>
<span class="codeline" id="line-415"><code>			pd.wt.f = netpollWriteDeadline</code></span>
<span class="codeline" id="line-416"><code>			pd.wt.arg = pd.makeArg()</code></span>
<span class="codeline" id="line-417"><code>			pd.wt.seq = pd.wseq</code></span>
<span class="codeline" id="line-418"><code>			resettimer(&amp;pd.wt, pd.wd)</code></span>
<span class="codeline" id="line-419"><code>		}</code></span>
<span class="codeline" id="line-420"><code>	} else if pd.wd != wd0 || combo != combo0 {</code></span>
<span class="codeline" id="line-421"><code>		pd.wseq++ // invalidate current timers</code></span>
<span class="codeline" id="line-422"><code>		if pd.wd &gt; 0 &amp;&amp; !combo {</code></span>
<span class="codeline" id="line-423"><code>			modtimer(&amp;pd.wt, pd.wd, 0, netpollWriteDeadline, pd.makeArg(), pd.wseq)</code></span>
<span class="codeline" id="line-424"><code>		} else {</code></span>
<span class="codeline" id="line-425"><code>			deltimer(&amp;pd.wt)</code></span>
<span class="codeline" id="line-426"><code>			pd.wt.f = nil</code></span>
<span class="codeline" id="line-427"><code>		}</code></span>
<span class="codeline" id="line-428"><code>	}</code></span>
<span class="codeline" id="line-429"><code>	// If we set the new deadline in the past, unblock currently pending IO if any.</code></span>
<span class="codeline" id="line-430"><code>	// Note that pd.publishInfo has already been called, above, immediately after modifying rd and wd.</code></span>
<span class="codeline" id="line-431"><code>	delta := int32(0)</code></span>
<span class="codeline" id="line-432"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-433"><code>	if pd.rd &lt; 0 {</code></span>
<span class="codeline" id="line-434"><code>		rg = netpollunblock(pd, 'r', false, &amp;delta)</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code>	if pd.wd &lt; 0 {</code></span>
<span class="codeline" id="line-437"><code>		wg = netpollunblock(pd, 'w', false, &amp;delta)</code></span>
<span class="codeline" id="line-438"><code>	}</code></span>
<span class="codeline" id="line-439"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-440"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-441"><code>		netpollgoready(rg, 3)</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-444"><code>		netpollgoready(wg, 3)</code></span>
<span class="codeline" id="line-445"><code>	}</code></span>
<span class="codeline" id="line-446"><code>	netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>//go:linkname poll_runtime_pollUnblock internal/poll.runtime_pollUnblock</code></span>
<span class="codeline" id="line-450"><code>func poll_runtime_pollUnblock(pd *pollDesc) {</code></span>
<span class="codeline" id="line-451"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-452"><code>	if pd.closing {</code></span>
<span class="codeline" id="line-453"><code>		throw("runtime: unblock on closing polldesc")</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	pd.closing = true</code></span>
<span class="codeline" id="line-456"><code>	pd.rseq++</code></span>
<span class="codeline" id="line-457"><code>	pd.wseq++</code></span>
<span class="codeline" id="line-458"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-459"><code>	pd.publishInfo()</code></span>
<span class="codeline" id="line-460"><code>	delta := int32(0)</code></span>
<span class="codeline" id="line-461"><code>	rg = netpollunblock(pd, 'r', false, &amp;delta)</code></span>
<span class="codeline" id="line-462"><code>	wg = netpollunblock(pd, 'w', false, &amp;delta)</code></span>
<span class="codeline" id="line-463"><code>	if pd.rt.f != nil {</code></span>
<span class="codeline" id="line-464"><code>		deltimer(&amp;pd.rt)</code></span>
<span class="codeline" id="line-465"><code>		pd.rt.f = nil</code></span>
<span class="codeline" id="line-466"><code>	}</code></span>
<span class="codeline" id="line-467"><code>	if pd.wt.f != nil {</code></span>
<span class="codeline" id="line-468"><code>		deltimer(&amp;pd.wt)</code></span>
<span class="codeline" id="line-469"><code>		pd.wt.f = nil</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-472"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-473"><code>		netpollgoready(rg, 3)</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-476"><code>		netpollgoready(wg, 3)</code></span>
<span class="codeline" id="line-477"><code>	}</code></span>
<span class="codeline" id="line-478"><code>	netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// netpollready is called by the platform-specific netpoll function.</code></span>
<span class="codeline" id="line-482"><code>// It declares that the fd associated with pd is ready for I/O.</code></span>
<span class="codeline" id="line-483"><code>// The toRun argument is used to build a list of goroutines to return</code></span>
<span class="codeline" id="line-484"><code>// from netpoll. The mode argument is 'r', 'w', or 'r'+'w' to indicate</code></span>
<span class="codeline" id="line-485"><code>// whether the fd is ready for reading or writing or both.</code></span>
<span class="codeline" id="line-486"><code>//</code></span>
<span class="codeline" id="line-487"><code>// This returns a delta to apply to netpollWaiters.</code></span>
<span class="codeline" id="line-488"><code>//</code></span>
<span class="codeline" id="line-489"><code>// This may run while the world is stopped, so write barriers are not allowed.</code></span>
<span class="codeline" id="line-490"><code>//</code></span>
<span class="codeline" id="line-491"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-492"><code>func netpollready(toRun *gList, pd *pollDesc, mode int32) int32 {</code></span>
<span class="codeline" id="line-493"><code>	delta := int32(0)</code></span>
<span class="codeline" id="line-494"><code>	var rg, wg *g</code></span>
<span class="codeline" id="line-495"><code>	if mode == 'r' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-496"><code>		rg = netpollunblock(pd, 'r', true, &amp;delta)</code></span>
<span class="codeline" id="line-497"><code>	}</code></span>
<span class="codeline" id="line-498"><code>	if mode == 'w' || mode == 'r'+'w' {</code></span>
<span class="codeline" id="line-499"><code>		wg = netpollunblock(pd, 'w', true, &amp;delta)</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-502"><code>		toRun.push(rg)</code></span>
<span class="codeline" id="line-503"><code>	}</code></span>
<span class="codeline" id="line-504"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-505"><code>		toRun.push(wg)</code></span>
<span class="codeline" id="line-506"><code>	}</code></span>
<span class="codeline" id="line-507"><code>	return delta</code></span>
<span class="codeline" id="line-508"><code>}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>func netpollcheckerr(pd *pollDesc, mode int32) int {</code></span>
<span class="codeline" id="line-511"><code>	info := pd.info()</code></span>
<span class="codeline" id="line-512"><code>	if info.closing() {</code></span>
<span class="codeline" id="line-513"><code>		return pollErrClosing</code></span>
<span class="codeline" id="line-514"><code>	}</code></span>
<span class="codeline" id="line-515"><code>	if (mode == 'r' &amp;&amp; info.expiredReadDeadline()) || (mode == 'w' &amp;&amp; info.expiredWriteDeadline()) {</code></span>
<span class="codeline" id="line-516"><code>		return pollErrTimeout</code></span>
<span class="codeline" id="line-517"><code>	}</code></span>
<span class="codeline" id="line-518"><code>	// Report an event scanning error only on a read event.</code></span>
<span class="codeline" id="line-519"><code>	// An error on a write event will be captured in a subsequent</code></span>
<span class="codeline" id="line-520"><code>	// write call that is able to report a more specific error.</code></span>
<span class="codeline" id="line-521"><code>	if mode == 'r' &amp;&amp; info.eventErr() {</code></span>
<span class="codeline" id="line-522"><code>		return pollErrNotPollable</code></span>
<span class="codeline" id="line-523"><code>	}</code></span>
<span class="codeline" id="line-524"><code>	return pollNoError</code></span>
<span class="codeline" id="line-525"><code>}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>func netpollblockcommit(gp *g, gpp unsafe.Pointer) bool {</code></span>
<span class="codeline" id="line-528"><code>	r := atomic.Casuintptr((*uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))</code></span>
<span class="codeline" id="line-529"><code>	if r {</code></span>
<span class="codeline" id="line-530"><code>		// Bump the count of goroutines waiting for the poller.</code></span>
<span class="codeline" id="line-531"><code>		// The scheduler uses this to decide whether to block</code></span>
<span class="codeline" id="line-532"><code>		// waiting for the poller if there is nothing else to do.</code></span>
<span class="codeline" id="line-533"><code>		netpollAdjustWaiters(1)</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>	return r</code></span>
<span class="codeline" id="line-536"><code>}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>func netpollgoready(gp *g, traceskip int) {</code></span>
<span class="codeline" id="line-539"><code>	goready(gp, traceskip+1)</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>// returns true if IO is ready, or false if timed out or closed</code></span>
<span class="codeline" id="line-543"><code>// waitio - wait only for completed IO, ignore errors</code></span>
<span class="codeline" id="line-544"><code>// Concurrent calls to netpollblock in the same mode are forbidden, as pollDesc</code></span>
<span class="codeline" id="line-545"><code>// can hold only a single waiting goroutine for each mode.</code></span>
<span class="codeline" id="line-546"><code>func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {</code></span>
<span class="codeline" id="line-547"><code>	gpp := &amp;pd.rg</code></span>
<span class="codeline" id="line-548"><code>	if mode == 'w' {</code></span>
<span class="codeline" id="line-549"><code>		gpp = &amp;pd.wg</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code></code></span>
<span class="codeline" id="line-552"><code>	// set the gpp semaphore to pdWait</code></span>
<span class="codeline" id="line-553"><code>	for {</code></span>
<span class="codeline" id="line-554"><code>		// Consume notification if already ready.</code></span>
<span class="codeline" id="line-555"><code>		if gpp.CompareAndSwap(pdReady, pdNil) {</code></span>
<span class="codeline" id="line-556"><code>			return true</code></span>
<span class="codeline" id="line-557"><code>		}</code></span>
<span class="codeline" id="line-558"><code>		if gpp.CompareAndSwap(pdNil, pdWait) {</code></span>
<span class="codeline" id="line-559"><code>			break</code></span>
<span class="codeline" id="line-560"><code>		}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>		// Double check that this isn't corrupt; otherwise we'd loop</code></span>
<span class="codeline" id="line-563"><code>		// forever.</code></span>
<span class="codeline" id="line-564"><code>		if v := gpp.Load(); v != pdReady &amp;&amp; v != pdNil {</code></span>
<span class="codeline" id="line-565"><code>			throw("runtime: double wait")</code></span>
<span class="codeline" id="line-566"><code>		}</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	// need to recheck error states after setting gpp to pdWait</code></span>
<span class="codeline" id="line-570"><code>	// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</code></span>
<span class="codeline" id="line-571"><code>	// do the opposite: store to closing/rd/wd, publishInfo, load of rg/wg</code></span>
<span class="codeline" id="line-572"><code>	if waitio || netpollcheckerr(pd, mode) == pollNoError {</code></span>
<span class="codeline" id="line-573"><code>		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, 5)</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	// be careful to not lose concurrent pdReady notification</code></span>
<span class="codeline" id="line-576"><code>	old := gpp.Swap(pdNil)</code></span>
<span class="codeline" id="line-577"><code>	if old &gt; pdWait {</code></span>
<span class="codeline" id="line-578"><code>		throw("runtime: corrupted polldesc")</code></span>
<span class="codeline" id="line-579"><code>	}</code></span>
<span class="codeline" id="line-580"><code>	return old == pdReady</code></span>
<span class="codeline" id="line-581"><code>}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>// netpollunblock moves either pd.rg (if mode == 'r') or</code></span>
<span class="codeline" id="line-584"><code>// pd.wg (if mode == 'w') into the pdReady state.</code></span>
<span class="codeline" id="line-585"><code>// This returns any goroutine blocked on pd.{rg,wg}.</code></span>
<span class="codeline" id="line-586"><code>// It adds any adjustment to netpollWaiters to *delta;</code></span>
<span class="codeline" id="line-587"><code>// this adjustment should be applied after the goroutine has</code></span>
<span class="codeline" id="line-588"><code>// been marked ready.</code></span>
<span class="codeline" id="line-589"><code>func netpollunblock(pd *pollDesc, mode int32, ioready bool, delta *int32) *g {</code></span>
<span class="codeline" id="line-590"><code>	gpp := &amp;pd.rg</code></span>
<span class="codeline" id="line-591"><code>	if mode == 'w' {</code></span>
<span class="codeline" id="line-592"><code>		gpp = &amp;pd.wg</code></span>
<span class="codeline" id="line-593"><code>	}</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>	for {</code></span>
<span class="codeline" id="line-596"><code>		old := gpp.Load()</code></span>
<span class="codeline" id="line-597"><code>		if old == pdReady {</code></span>
<span class="codeline" id="line-598"><code>			return nil</code></span>
<span class="codeline" id="line-599"><code>		}</code></span>
<span class="codeline" id="line-600"><code>		if old == pdNil &amp;&amp; !ioready {</code></span>
<span class="codeline" id="line-601"><code>			// Only set pdReady for ioready. runtime_pollWait</code></span>
<span class="codeline" id="line-602"><code>			// will check for timeout/cancel before waiting.</code></span>
<span class="codeline" id="line-603"><code>			return nil</code></span>
<span class="codeline" id="line-604"><code>		}</code></span>
<span class="codeline" id="line-605"><code>		new := pdNil</code></span>
<span class="codeline" id="line-606"><code>		if ioready {</code></span>
<span class="codeline" id="line-607"><code>			new = pdReady</code></span>
<span class="codeline" id="line-608"><code>		}</code></span>
<span class="codeline" id="line-609"><code>		if gpp.CompareAndSwap(old, new) {</code></span>
<span class="codeline" id="line-610"><code>			if old == pdWait {</code></span>
<span class="codeline" id="line-611"><code>				old = pdNil</code></span>
<span class="codeline" id="line-612"><code>			} else if old != pdNil {</code></span>
<span class="codeline" id="line-613"><code>				*delta -= 1</code></span>
<span class="codeline" id="line-614"><code>			}</code></span>
<span class="codeline" id="line-615"><code>			return (*g)(unsafe.Pointer(old))</code></span>
<span class="codeline" id="line-616"><code>		}</code></span>
<span class="codeline" id="line-617"><code>	}</code></span>
<span class="codeline" id="line-618"><code>}</code></span>
<span class="codeline" id="line-619"><code></code></span>
<span class="codeline" id="line-620"><code>func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool) {</code></span>
<span class="codeline" id="line-621"><code>	lock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-622"><code>	// Seq arg is seq when the timer was set.</code></span>
<span class="codeline" id="line-623"><code>	// If it's stale, ignore the timer event.</code></span>
<span class="codeline" id="line-624"><code>	currentSeq := pd.rseq</code></span>
<span class="codeline" id="line-625"><code>	if !read {</code></span>
<span class="codeline" id="line-626"><code>		currentSeq = pd.wseq</code></span>
<span class="codeline" id="line-627"><code>	}</code></span>
<span class="codeline" id="line-628"><code>	if seq != currentSeq {</code></span>
<span class="codeline" id="line-629"><code>		// The descriptor was reused or timers were reset.</code></span>
<span class="codeline" id="line-630"><code>		unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-631"><code>		return</code></span>
<span class="codeline" id="line-632"><code>	}</code></span>
<span class="codeline" id="line-633"><code>	delta := int32(0)</code></span>
<span class="codeline" id="line-634"><code>	var rg *g</code></span>
<span class="codeline" id="line-635"><code>	if read {</code></span>
<span class="codeline" id="line-636"><code>		if pd.rd &lt;= 0 || pd.rt.f == nil {</code></span>
<span class="codeline" id="line-637"><code>			throw("runtime: inconsistent read deadline")</code></span>
<span class="codeline" id="line-638"><code>		}</code></span>
<span class="codeline" id="line-639"><code>		pd.rd = -1</code></span>
<span class="codeline" id="line-640"><code>		pd.publishInfo()</code></span>
<span class="codeline" id="line-641"><code>		rg = netpollunblock(pd, 'r', false, &amp;delta)</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code>	var wg *g</code></span>
<span class="codeline" id="line-644"><code>	if write {</code></span>
<span class="codeline" id="line-645"><code>		if pd.wd &lt;= 0 || pd.wt.f == nil &amp;&amp; !read {</code></span>
<span class="codeline" id="line-646"><code>			throw("runtime: inconsistent write deadline")</code></span>
<span class="codeline" id="line-647"><code>		}</code></span>
<span class="codeline" id="line-648"><code>		pd.wd = -1</code></span>
<span class="codeline" id="line-649"><code>		pd.publishInfo()</code></span>
<span class="codeline" id="line-650"><code>		wg = netpollunblock(pd, 'w', false, &amp;delta)</code></span>
<span class="codeline" id="line-651"><code>	}</code></span>
<span class="codeline" id="line-652"><code>	unlock(&amp;pd.lock)</code></span>
<span class="codeline" id="line-653"><code>	if rg != nil {</code></span>
<span class="codeline" id="line-654"><code>		netpollgoready(rg, 0)</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code>	if wg != nil {</code></span>
<span class="codeline" id="line-657"><code>		netpollgoready(wg, 0)</code></span>
<span class="codeline" id="line-658"><code>	}</code></span>
<span class="codeline" id="line-659"><code>	netpollAdjustWaiters(delta)</code></span>
<span class="codeline" id="line-660"><code>}</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>func netpollDeadline(arg any, seq uintptr) {</code></span>
<span class="codeline" id="line-663"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, true, true)</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>func netpollReadDeadline(arg any, seq uintptr) {</code></span>
<span class="codeline" id="line-667"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, true, false)</code></span>
<span class="codeline" id="line-668"><code>}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>func netpollWriteDeadline(arg any, seq uintptr) {</code></span>
<span class="codeline" id="line-671"><code>	netpolldeadlineimpl(arg.(*pollDesc), seq, false, true)</code></span>
<span class="codeline" id="line-672"><code>}</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>// netpollAnyWaiters reports whether any goroutines are waiting for I/O.</code></span>
<span class="codeline" id="line-675"><code>func netpollAnyWaiters() bool {</code></span>
<span class="codeline" id="line-676"><code>	return netpollWaiters.Load() &gt; 0</code></span>
<span class="codeline" id="line-677"><code>}</code></span>
<span class="codeline" id="line-678"><code></code></span>
<span class="codeline" id="line-679"><code>// netpollAdjustWaiters adds delta to netpollWaiters.</code></span>
<span class="codeline" id="line-680"><code>func netpollAdjustWaiters(delta int32) {</code></span>
<span class="codeline" id="line-681"><code>	if delta != 0 {</code></span>
<span class="codeline" id="line-682"><code>		netpollWaiters.Add(delta)</code></span>
<span class="codeline" id="line-683"><code>	}</code></span>
<span class="codeline" id="line-684"><code>}</code></span>
<span class="codeline" id="line-685"><code></code></span>
<span class="codeline" id="line-686"><code>func (c *pollCache) alloc() *pollDesc {</code></span>
<span class="codeline" id="line-687"><code>	lock(&amp;c.lock)</code></span>
<span class="codeline" id="line-688"><code>	if c.first == nil {</code></span>
<span class="codeline" id="line-689"><code>		const pdSize = unsafe.Sizeof(pollDesc{})</code></span>
<span class="codeline" id="line-690"><code>		n := pollBlockSize / pdSize</code></span>
<span class="codeline" id="line-691"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-692"><code>			n = 1</code></span>
<span class="codeline" id="line-693"><code>		}</code></span>
<span class="codeline" id="line-694"><code>		// Must be in non-GC memory because can be referenced</code></span>
<span class="codeline" id="line-695"><code>		// only from epoll/kqueue internals.</code></span>
<span class="codeline" id="line-696"><code>		mem := persistentalloc(n*pdSize, 0, &amp;memstats.other_sys)</code></span>
<span class="codeline" id="line-697"><code>		for i := uintptr(0); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-698"><code>			pd := (*pollDesc)(add(mem, i*pdSize))</code></span>
<span class="codeline" id="line-699"><code>			pd.link = c.first</code></span>
<span class="codeline" id="line-700"><code>			c.first = pd</code></span>
<span class="codeline" id="line-701"><code>		}</code></span>
<span class="codeline" id="line-702"><code>	}</code></span>
<span class="codeline" id="line-703"><code>	pd := c.first</code></span>
<span class="codeline" id="line-704"><code>	c.first = pd.link</code></span>
<span class="codeline" id="line-705"><code>	lockInit(&amp;pd.lock, lockRankPollDesc)</code></span>
<span class="codeline" id="line-706"><code>	unlock(&amp;c.lock)</code></span>
<span class="codeline" id="line-707"><code>	return pd</code></span>
<span class="codeline" id="line-708"><code>}</code></span>
<span class="codeline" id="line-709"><code></code></span>
<span class="codeline" id="line-710"><code>// makeArg converts pd to an interface{}.</code></span>
<span class="codeline" id="line-711"><code>// makeArg does not do any allocation. Normally, such</code></span>
<span class="codeline" id="line-712"><code>// a conversion requires an allocation because pointers to</code></span>
<span class="codeline" id="line-713"><code>// types which embed runtime/internal/sys.NotInHeap (which pollDesc is)</code></span>
<span class="codeline" id="line-714"><code>// must be stored in interfaces indirectly. See issue 42076.</code></span>
<span class="codeline" id="line-715"><code>func (pd *pollDesc) makeArg() (i any) {</code></span>
<span class="codeline" id="line-716"><code>	x := (*eface)(unsafe.Pointer(&amp;i))</code></span>
<span class="codeline" id="line-717"><code>	x._type = pdType</code></span>
<span class="codeline" id="line-718"><code>	x.data = unsafe.Pointer(&amp;pd.self)</code></span>
<span class="codeline" id="line-719"><code>	return</code></span>
<span class="codeline" id="line-720"><code>}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>var (</code></span>
<span class="codeline" id="line-723"><code>	pdEface any    = (*pollDesc)(nil)</code></span>
<span class="codeline" id="line-724"><code>	pdType  *_type = efaceOf(&amp;pdEface)._type</code></span>
<span class="codeline" id="line-725"><code>)</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>