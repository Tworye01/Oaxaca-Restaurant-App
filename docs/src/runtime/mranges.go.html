<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mranges.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mranges.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2019 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Address range data structure.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// This file contains an implementation of a data structure which</code></span>
<span class="codeline" id="line-8"><code>// manages ordered address ranges.</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>package runtime</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>import (</code></span>
<span class="codeline" id="line-13"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-14"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-15"><code>	"unsafe"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// addrRange represents a region of address space.</code></span>
<span class="codeline" id="line-19"><code>//</code></span>
<span class="codeline" id="line-20"><code>// An addrRange must never span a gap in the address space.</code></span>
<span class="codeline" id="line-21"><code>type addrRange struct {</code></span>
<span class="codeline" id="line-22"><code>	// base and limit together represent the region of address space</code></span>
<span class="codeline" id="line-23"><code>	// [base, limit). That is, base is inclusive, limit is exclusive.</code></span>
<span class="codeline" id="line-24"><code>	// These are address over an offset view of the address space on</code></span>
<span class="codeline" id="line-25"><code>	// platforms with a segmented address space, that is, on platforms</code></span>
<span class="codeline" id="line-26"><code>	// where arenaBaseOffset != 0.</code></span>
<span class="codeline" id="line-27"><code>	base, limit offAddr</code></span>
<span class="codeline" id="line-28"><code>}</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>// makeAddrRange creates a new address range from two virtual addresses.</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>// Throws if the base and limit are not in the same memory segment.</code></span>
<span class="codeline" id="line-33"><code>func makeAddrRange(base, limit uintptr) addrRange {</code></span>
<span class="codeline" id="line-34"><code>	r := addrRange{offAddr{base}, offAddr{limit}}</code></span>
<span class="codeline" id="line-35"><code>	if (base-arenaBaseOffset &gt;= base) != (limit-arenaBaseOffset &gt;= limit) {</code></span>
<span class="codeline" id="line-36"><code>		throw("addr range base and limit are not in the same memory segment")</code></span>
<span class="codeline" id="line-37"><code>	}</code></span>
<span class="codeline" id="line-38"><code>	return r</code></span>
<span class="codeline" id="line-39"><code>}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>// size returns the size of the range represented in bytes.</code></span>
<span class="codeline" id="line-42"><code>func (a addrRange) size() uintptr {</code></span>
<span class="codeline" id="line-43"><code>	if !a.base.lessThan(a.limit) {</code></span>
<span class="codeline" id="line-44"><code>		return 0</code></span>
<span class="codeline" id="line-45"><code>	}</code></span>
<span class="codeline" id="line-46"><code>	// Subtraction is safe because limit and base must be in the same</code></span>
<span class="codeline" id="line-47"><code>	// segment of the address space.</code></span>
<span class="codeline" id="line-48"><code>	return a.limit.diff(a.base)</code></span>
<span class="codeline" id="line-49"><code>}</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// contains returns whether or not the range contains a given address.</code></span>
<span class="codeline" id="line-52"><code>func (a addrRange) contains(addr uintptr) bool {</code></span>
<span class="codeline" id="line-53"><code>	return a.base.lessEqual(offAddr{addr}) &amp;&amp; (offAddr{addr}).lessThan(a.limit)</code></span>
<span class="codeline" id="line-54"><code>}</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>// subtract takes the addrRange toPrune and cuts out any overlap with</code></span>
<span class="codeline" id="line-57"><code>// from, then returns the new range. subtract assumes that a and b</code></span>
<span class="codeline" id="line-58"><code>// either don't overlap at all, only overlap on one side, or are equal.</code></span>
<span class="codeline" id="line-59"><code>// If b is strictly contained in a, thus forcing a split, it will throw.</code></span>
<span class="codeline" id="line-60"><code>func (a addrRange) subtract(b addrRange) addrRange {</code></span>
<span class="codeline" id="line-61"><code>	if b.base.lessEqual(a.base) &amp;&amp; a.limit.lessEqual(b.limit) {</code></span>
<span class="codeline" id="line-62"><code>		return addrRange{}</code></span>
<span class="codeline" id="line-63"><code>	} else if a.base.lessThan(b.base) &amp;&amp; b.limit.lessThan(a.limit) {</code></span>
<span class="codeline" id="line-64"><code>		throw("bad prune")</code></span>
<span class="codeline" id="line-65"><code>	} else if b.limit.lessThan(a.limit) &amp;&amp; a.base.lessThan(b.limit) {</code></span>
<span class="codeline" id="line-66"><code>		a.base = b.limit</code></span>
<span class="codeline" id="line-67"><code>	} else if a.base.lessThan(b.base) &amp;&amp; b.base.lessThan(a.limit) {</code></span>
<span class="codeline" id="line-68"><code>		a.limit = b.base</code></span>
<span class="codeline" id="line-69"><code>	}</code></span>
<span class="codeline" id="line-70"><code>	return a</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// takeFromFront takes len bytes from the front of the address range, aligning</code></span>
<span class="codeline" id="line-74"><code>// the base to align first. On success, returns the aligned start of the region</code></span>
<span class="codeline" id="line-75"><code>// taken and true.</code></span>
<span class="codeline" id="line-76"><code>func (a *addrRange) takeFromFront(len uintptr, align uint8) (uintptr, bool) {</code></span>
<span class="codeline" id="line-77"><code>	base := alignUp(a.base.addr(), uintptr(align)) + len</code></span>
<span class="codeline" id="line-78"><code>	if base &gt; a.limit.addr() {</code></span>
<span class="codeline" id="line-79"><code>		return 0, false</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code>	a.base = offAddr{base}</code></span>
<span class="codeline" id="line-82"><code>	return base - len, true</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>// takeFromBack takes len bytes from the end of the address range, aligning</code></span>
<span class="codeline" id="line-86"><code>// the limit to align after subtracting len. On success, returns the aligned</code></span>
<span class="codeline" id="line-87"><code>// start of the region taken and true.</code></span>
<span class="codeline" id="line-88"><code>func (a *addrRange) takeFromBack(len uintptr, align uint8) (uintptr, bool) {</code></span>
<span class="codeline" id="line-89"><code>	limit := alignDown(a.limit.addr()-len, uintptr(align))</code></span>
<span class="codeline" id="line-90"><code>	if a.base.addr() &gt; limit {</code></span>
<span class="codeline" id="line-91"><code>		return 0, false</code></span>
<span class="codeline" id="line-92"><code>	}</code></span>
<span class="codeline" id="line-93"><code>	a.limit = offAddr{limit}</code></span>
<span class="codeline" id="line-94"><code>	return limit, true</code></span>
<span class="codeline" id="line-95"><code>}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>// removeGreaterEqual removes all addresses in a greater than or equal</code></span>
<span class="codeline" id="line-98"><code>// to addr and returns the new range.</code></span>
<span class="codeline" id="line-99"><code>func (a addrRange) removeGreaterEqual(addr uintptr) addrRange {</code></span>
<span class="codeline" id="line-100"><code>	if (offAddr{addr}).lessEqual(a.base) {</code></span>
<span class="codeline" id="line-101"><code>		return addrRange{}</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code>	if a.limit.lessEqual(offAddr{addr}) {</code></span>
<span class="codeline" id="line-104"><code>		return a</code></span>
<span class="codeline" id="line-105"><code>	}</code></span>
<span class="codeline" id="line-106"><code>	return makeAddrRange(a.base.addr(), addr)</code></span>
<span class="codeline" id="line-107"><code>}</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>var (</code></span>
<span class="codeline" id="line-110"><code>	// minOffAddr is the minimum address in the offset space, and</code></span>
<span class="codeline" id="line-111"><code>	// it corresponds to the virtual address arenaBaseOffset.</code></span>
<span class="codeline" id="line-112"><code>	minOffAddr = offAddr{arenaBaseOffset}</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>	// maxOffAddr is the maximum address in the offset address</code></span>
<span class="codeline" id="line-115"><code>	// space. It corresponds to the highest virtual address representable</code></span>
<span class="codeline" id="line-116"><code>	// by the page alloc chunk and heap arena maps.</code></span>
<span class="codeline" id="line-117"><code>	maxOffAddr = offAddr{(((1 &lt;&lt; heapAddrBits) - 1) + arenaBaseOffset) &amp; uintptrMask}</code></span>
<span class="codeline" id="line-118"><code>)</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>// offAddr represents an address in a contiguous view</code></span>
<span class="codeline" id="line-121"><code>// of the address space on systems where the address space is</code></span>
<span class="codeline" id="line-122"><code>// segmented. On other systems, it's just a normal address.</code></span>
<span class="codeline" id="line-123"><code>type offAddr struct {</code></span>
<span class="codeline" id="line-124"><code>	// a is just the virtual address, but should never be used</code></span>
<span class="codeline" id="line-125"><code>	// directly. Call addr() to get this value instead.</code></span>
<span class="codeline" id="line-126"><code>	a uintptr</code></span>
<span class="codeline" id="line-127"><code>}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// add adds a uintptr offset to the offAddr.</code></span>
<span class="codeline" id="line-130"><code>func (l offAddr) add(bytes uintptr) offAddr {</code></span>
<span class="codeline" id="line-131"><code>	return offAddr{a: l.a + bytes}</code></span>
<span class="codeline" id="line-132"><code>}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>// sub subtracts a uintptr offset from the offAddr.</code></span>
<span class="codeline" id="line-135"><code>func (l offAddr) sub(bytes uintptr) offAddr {</code></span>
<span class="codeline" id="line-136"><code>	return offAddr{a: l.a - bytes}</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// diff returns the amount of bytes in between the</code></span>
<span class="codeline" id="line-140"><code>// two offAddrs.</code></span>
<span class="codeline" id="line-141"><code>func (l1 offAddr) diff(l2 offAddr) uintptr {</code></span>
<span class="codeline" id="line-142"><code>	return l1.a - l2.a</code></span>
<span class="codeline" id="line-143"><code>}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// lessThan returns true if l1 is less than l2 in the offset</code></span>
<span class="codeline" id="line-146"><code>// address space.</code></span>
<span class="codeline" id="line-147"><code>func (l1 offAddr) lessThan(l2 offAddr) bool {</code></span>
<span class="codeline" id="line-148"><code>	return (l1.a - arenaBaseOffset) &lt; (l2.a - arenaBaseOffset)</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// lessEqual returns true if l1 is less than or equal to l2 in</code></span>
<span class="codeline" id="line-152"><code>// the offset address space.</code></span>
<span class="codeline" id="line-153"><code>func (l1 offAddr) lessEqual(l2 offAddr) bool {</code></span>
<span class="codeline" id="line-154"><code>	return (l1.a - arenaBaseOffset) &lt;= (l2.a - arenaBaseOffset)</code></span>
<span class="codeline" id="line-155"><code>}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>// equal returns true if the two offAddr values are equal.</code></span>
<span class="codeline" id="line-158"><code>func (l1 offAddr) equal(l2 offAddr) bool {</code></span>
<span class="codeline" id="line-159"><code>	// No need to compare in the offset space, it</code></span>
<span class="codeline" id="line-160"><code>	// means the same thing.</code></span>
<span class="codeline" id="line-161"><code>	return l1 == l2</code></span>
<span class="codeline" id="line-162"><code>}</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>// addr returns the virtual address for this offset address.</code></span>
<span class="codeline" id="line-165"><code>func (l offAddr) addr() uintptr {</code></span>
<span class="codeline" id="line-166"><code>	return l.a</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>// atomicOffAddr is like offAddr, but operations on it are atomic.</code></span>
<span class="codeline" id="line-170"><code>// It also contains operations to be able to store marked addresses</code></span>
<span class="codeline" id="line-171"><code>// to ensure that they're not overridden until they've been seen.</code></span>
<span class="codeline" id="line-172"><code>type atomicOffAddr struct {</code></span>
<span class="codeline" id="line-173"><code>	// a contains the offset address, unlike offAddr.</code></span>
<span class="codeline" id="line-174"><code>	a atomic.Int64</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// Clear attempts to store minOffAddr in atomicOffAddr. It may fail</code></span>
<span class="codeline" id="line-178"><code>// if a marked value is placed in the box in the meanwhile.</code></span>
<span class="codeline" id="line-179"><code>func (b *atomicOffAddr) Clear() {</code></span>
<span class="codeline" id="line-180"><code>	for {</code></span>
<span class="codeline" id="line-181"><code>		old := b.a.Load()</code></span>
<span class="codeline" id="line-182"><code>		if old &lt; 0 {</code></span>
<span class="codeline" id="line-183"><code>			return</code></span>
<span class="codeline" id="line-184"><code>		}</code></span>
<span class="codeline" id="line-185"><code>		if b.a.CompareAndSwap(old, int64(minOffAddr.addr()-arenaBaseOffset)) {</code></span>
<span class="codeline" id="line-186"><code>			return</code></span>
<span class="codeline" id="line-187"><code>		}</code></span>
<span class="codeline" id="line-188"><code>	}</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>// StoreMin stores addr if it's less than the current value in the</code></span>
<span class="codeline" id="line-192"><code>// offset address space if the current value is not marked.</code></span>
<span class="codeline" id="line-193"><code>func (b *atomicOffAddr) StoreMin(addr uintptr) {</code></span>
<span class="codeline" id="line-194"><code>	new := int64(addr - arenaBaseOffset)</code></span>
<span class="codeline" id="line-195"><code>	for {</code></span>
<span class="codeline" id="line-196"><code>		old := b.a.Load()</code></span>
<span class="codeline" id="line-197"><code>		if old &lt; new {</code></span>
<span class="codeline" id="line-198"><code>			return</code></span>
<span class="codeline" id="line-199"><code>		}</code></span>
<span class="codeline" id="line-200"><code>		if b.a.CompareAndSwap(old, new) {</code></span>
<span class="codeline" id="line-201"><code>			return</code></span>
<span class="codeline" id="line-202"><code>		}</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>}</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>// StoreUnmark attempts to unmark the value in atomicOffAddr and</code></span>
<span class="codeline" id="line-207"><code>// replace it with newAddr. markedAddr must be a marked address</code></span>
<span class="codeline" id="line-208"><code>// returned by Load. This function will not store newAddr if the</code></span>
<span class="codeline" id="line-209"><code>// box no longer contains markedAddr.</code></span>
<span class="codeline" id="line-210"><code>func (b *atomicOffAddr) StoreUnmark(markedAddr, newAddr uintptr) {</code></span>
<span class="codeline" id="line-211"><code>	b.a.CompareAndSwap(-int64(markedAddr-arenaBaseOffset), int64(newAddr-arenaBaseOffset))</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// StoreMarked stores addr but first converted to the offset address</code></span>
<span class="codeline" id="line-215"><code>// space and then negated.</code></span>
<span class="codeline" id="line-216"><code>func (b *atomicOffAddr) StoreMarked(addr uintptr) {</code></span>
<span class="codeline" id="line-217"><code>	b.a.Store(-int64(addr - arenaBaseOffset))</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// Load returns the address in the box as a virtual address. It also</code></span>
<span class="codeline" id="line-221"><code>// returns if the value was marked or not.</code></span>
<span class="codeline" id="line-222"><code>func (b *atomicOffAddr) Load() (uintptr, bool) {</code></span>
<span class="codeline" id="line-223"><code>	v := b.a.Load()</code></span>
<span class="codeline" id="line-224"><code>	wasMarked := false</code></span>
<span class="codeline" id="line-225"><code>	if v &lt; 0 {</code></span>
<span class="codeline" id="line-226"><code>		wasMarked = true</code></span>
<span class="codeline" id="line-227"><code>		v = -v</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	return uintptr(v) + arenaBaseOffset, wasMarked</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>// addrRanges is a data structure holding a collection of ranges of</code></span>
<span class="codeline" id="line-233"><code>// address space.</code></span>
<span class="codeline" id="line-234"><code>//</code></span>
<span class="codeline" id="line-235"><code>// The ranges are coalesced eagerly to reduce the</code></span>
<span class="codeline" id="line-236"><code>// number ranges it holds.</code></span>
<span class="codeline" id="line-237"><code>//</code></span>
<span class="codeline" id="line-238"><code>// The slice backing store for this field is persistentalloc'd</code></span>
<span class="codeline" id="line-239"><code>// and thus there is no way to free it.</code></span>
<span class="codeline" id="line-240"><code>//</code></span>
<span class="codeline" id="line-241"><code>// addrRanges is not thread-safe.</code></span>
<span class="codeline" id="line-242"><code>type addrRanges struct {</code></span>
<span class="codeline" id="line-243"><code>	// ranges is a slice of ranges sorted by base.</code></span>
<span class="codeline" id="line-244"><code>	ranges []addrRange</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	// totalBytes is the total amount of address space in bytes counted by</code></span>
<span class="codeline" id="line-247"><code>	// this addrRanges.</code></span>
<span class="codeline" id="line-248"><code>	totalBytes uintptr</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	// sysStat is the stat to track allocations by this type</code></span>
<span class="codeline" id="line-251"><code>	sysStat *sysMemStat</code></span>
<span class="codeline" id="line-252"><code>}</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>func (a *addrRanges) init(sysStat *sysMemStat) {</code></span>
<span class="codeline" id="line-255"><code>	ranges := (*notInHeapSlice)(unsafe.Pointer(&amp;a.ranges))</code></span>
<span class="codeline" id="line-256"><code>	ranges.len = 0</code></span>
<span class="codeline" id="line-257"><code>	ranges.cap = 16</code></span>
<span class="codeline" id="line-258"><code>	ranges.array = (*notInHeap)(persistentalloc(unsafe.Sizeof(addrRange{})*uintptr(ranges.cap), goarch.PtrSize, sysStat))</code></span>
<span class="codeline" id="line-259"><code>	a.sysStat = sysStat</code></span>
<span class="codeline" id="line-260"><code>	a.totalBytes = 0</code></span>
<span class="codeline" id="line-261"><code>}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>// findSucc returns the first index in a such that addr is</code></span>
<span class="codeline" id="line-264"><code>// less than the base of the addrRange at that index.</code></span>
<span class="codeline" id="line-265"><code>func (a *addrRanges) findSucc(addr uintptr) int {</code></span>
<span class="codeline" id="line-266"><code>	base := offAddr{addr}</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>	// Narrow down the search space via a binary search</code></span>
<span class="codeline" id="line-269"><code>	// for large addrRanges until we have at most iterMax</code></span>
<span class="codeline" id="line-270"><code>	// candidates left.</code></span>
<span class="codeline" id="line-271"><code>	const iterMax = 8</code></span>
<span class="codeline" id="line-272"><code>	bot, top := 0, len(a.ranges)</code></span>
<span class="codeline" id="line-273"><code>	for top-bot &gt; iterMax {</code></span>
<span class="codeline" id="line-274"><code>		i := int(uint(bot+top) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-275"><code>		if a.ranges[i].contains(base.addr()) {</code></span>
<span class="codeline" id="line-276"><code>			// a.ranges[i] contains base, so</code></span>
<span class="codeline" id="line-277"><code>			// its successor is the next index.</code></span>
<span class="codeline" id="line-278"><code>			return i + 1</code></span>
<span class="codeline" id="line-279"><code>		}</code></span>
<span class="codeline" id="line-280"><code>		if base.lessThan(a.ranges[i].base) {</code></span>
<span class="codeline" id="line-281"><code>			// In this case i might actually be</code></span>
<span class="codeline" id="line-282"><code>			// the successor, but we can't be sure</code></span>
<span class="codeline" id="line-283"><code>			// until we check the ones before it.</code></span>
<span class="codeline" id="line-284"><code>			top = i</code></span>
<span class="codeline" id="line-285"><code>		} else {</code></span>
<span class="codeline" id="line-286"><code>			// In this case we know base is</code></span>
<span class="codeline" id="line-287"><code>			// greater than or equal to a.ranges[i].limit-1,</code></span>
<span class="codeline" id="line-288"><code>			// so i is definitely not the successor.</code></span>
<span class="codeline" id="line-289"><code>			// We already checked i, so pick the next</code></span>
<span class="codeline" id="line-290"><code>			// one.</code></span>
<span class="codeline" id="line-291"><code>			bot = i + 1</code></span>
<span class="codeline" id="line-292"><code>		}</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	// There are top-bot candidates left, so</code></span>
<span class="codeline" id="line-295"><code>	// iterate over them and find the first that</code></span>
<span class="codeline" id="line-296"><code>	// base is strictly less than.</code></span>
<span class="codeline" id="line-297"><code>	for i := bot; i &lt; top; i++ {</code></span>
<span class="codeline" id="line-298"><code>		if base.lessThan(a.ranges[i].base) {</code></span>
<span class="codeline" id="line-299"><code>			return i</code></span>
<span class="codeline" id="line-300"><code>		}</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code>	return top</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>// findAddrGreaterEqual returns the smallest address represented by a</code></span>
<span class="codeline" id="line-306"><code>// that is &gt;= addr. Thus, if the address is represented by a,</code></span>
<span class="codeline" id="line-307"><code>// then it returns addr. The second return value indicates whether</code></span>
<span class="codeline" id="line-308"><code>// such an address exists for addr in a. That is, if addr is larger than</code></span>
<span class="codeline" id="line-309"><code>// any address known to a, the second return value will be false.</code></span>
<span class="codeline" id="line-310"><code>func (a *addrRanges) findAddrGreaterEqual(addr uintptr) (uintptr, bool) {</code></span>
<span class="codeline" id="line-311"><code>	i := a.findSucc(addr)</code></span>
<span class="codeline" id="line-312"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-313"><code>		return a.ranges[0].base.addr(), true</code></span>
<span class="codeline" id="line-314"><code>	}</code></span>
<span class="codeline" id="line-315"><code>	if a.ranges[i-1].contains(addr) {</code></span>
<span class="codeline" id="line-316"><code>		return addr, true</code></span>
<span class="codeline" id="line-317"><code>	}</code></span>
<span class="codeline" id="line-318"><code>	if i &lt; len(a.ranges) {</code></span>
<span class="codeline" id="line-319"><code>		return a.ranges[i].base.addr(), true</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code>	return 0, false</code></span>
<span class="codeline" id="line-322"><code>}</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>// contains returns true if a covers the address addr.</code></span>
<span class="codeline" id="line-325"><code>func (a *addrRanges) contains(addr uintptr) bool {</code></span>
<span class="codeline" id="line-326"><code>	i := a.findSucc(addr)</code></span>
<span class="codeline" id="line-327"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-328"><code>		return false</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	return a.ranges[i-1].contains(addr)</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>// add inserts a new address range to a.</code></span>
<span class="codeline" id="line-334"><code>//</code></span>
<span class="codeline" id="line-335"><code>// r must not overlap with any address range in a and r.size() must be &gt; 0.</code></span>
<span class="codeline" id="line-336"><code>func (a *addrRanges) add(r addrRange) {</code></span>
<span class="codeline" id="line-337"><code>	// The copies in this function are potentially expensive, but this data</code></span>
<span class="codeline" id="line-338"><code>	// structure is meant to represent the Go heap. At worst, copying this</code></span>
<span class="codeline" id="line-339"><code>	// would take ~160µs assuming a conservative copying rate of 25 GiB/s (the</code></span>
<span class="codeline" id="line-340"><code>	// copy will almost never trigger a page fault) for a 1 TiB heap with 4 MiB</code></span>
<span class="codeline" id="line-341"><code>	// arenas which is completely discontiguous. ~160µs is still a lot, but in</code></span>
<span class="codeline" id="line-342"><code>	// practice most platforms have 64 MiB arenas (which cuts this by a factor</code></span>
<span class="codeline" id="line-343"><code>	// of 16) and Go heaps are usually mostly contiguous, so the chance that</code></span>
<span class="codeline" id="line-344"><code>	// an addrRanges even grows to that size is extremely low.</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>	// An empty range has no effect on the set of addresses represented</code></span>
<span class="codeline" id="line-347"><code>	// by a, but passing a zero-sized range is almost always a bug.</code></span>
<span class="codeline" id="line-348"><code>	if r.size() == 0 {</code></span>
<span class="codeline" id="line-349"><code>		print("runtime: range = {", hex(r.base.addr()), ", ", hex(r.limit.addr()), "}\n")</code></span>
<span class="codeline" id="line-350"><code>		throw("attempted to add zero-sized address range")</code></span>
<span class="codeline" id="line-351"><code>	}</code></span>
<span class="codeline" id="line-352"><code>	// Because we assume r is not currently represented in a,</code></span>
<span class="codeline" id="line-353"><code>	// findSucc gives us our insertion index.</code></span>
<span class="codeline" id="line-354"><code>	i := a.findSucc(r.base.addr())</code></span>
<span class="codeline" id="line-355"><code>	coalescesDown := i &gt; 0 &amp;&amp; a.ranges[i-1].limit.equal(r.base)</code></span>
<span class="codeline" id="line-356"><code>	coalescesUp := i &lt; len(a.ranges) &amp;&amp; r.limit.equal(a.ranges[i].base)</code></span>
<span class="codeline" id="line-357"><code>	if coalescesUp &amp;&amp; coalescesDown {</code></span>
<span class="codeline" id="line-358"><code>		// We have neighbors and they both border us.</code></span>
<span class="codeline" id="line-359"><code>		// Merge a.ranges[i-1], r, and a.ranges[i] together into a.ranges[i-1].</code></span>
<span class="codeline" id="line-360"><code>		a.ranges[i-1].limit = a.ranges[i].limit</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>		// Delete a.ranges[i].</code></span>
<span class="codeline" id="line-363"><code>		copy(a.ranges[i:], a.ranges[i+1:])</code></span>
<span class="codeline" id="line-364"><code>		a.ranges = a.ranges[:len(a.ranges)-1]</code></span>
<span class="codeline" id="line-365"><code>	} else if coalescesDown {</code></span>
<span class="codeline" id="line-366"><code>		// We have a neighbor at a lower address only and it borders us.</code></span>
<span class="codeline" id="line-367"><code>		// Merge the new space into a.ranges[i-1].</code></span>
<span class="codeline" id="line-368"><code>		a.ranges[i-1].limit = r.limit</code></span>
<span class="codeline" id="line-369"><code>	} else if coalescesUp {</code></span>
<span class="codeline" id="line-370"><code>		// We have a neighbor at a higher address only and it borders us.</code></span>
<span class="codeline" id="line-371"><code>		// Merge the new space into a.ranges[i].</code></span>
<span class="codeline" id="line-372"><code>		a.ranges[i].base = r.base</code></span>
<span class="codeline" id="line-373"><code>	} else {</code></span>
<span class="codeline" id="line-374"><code>		// We may or may not have neighbors which don't border us.</code></span>
<span class="codeline" id="line-375"><code>		// Add the new range.</code></span>
<span class="codeline" id="line-376"><code>		if len(a.ranges)+1 &gt; cap(a.ranges) {</code></span>
<span class="codeline" id="line-377"><code>			// Grow the array. Note that this leaks the old array, but since</code></span>
<span class="codeline" id="line-378"><code>			// we're doubling we have at most 2x waste. For a 1 TiB heap and</code></span>
<span class="codeline" id="line-379"><code>			// 4 MiB arenas which are all discontiguous (both very conservative</code></span>
<span class="codeline" id="line-380"><code>			// assumptions), this would waste at most 4 MiB of memory.</code></span>
<span class="codeline" id="line-381"><code>			oldRanges := a.ranges</code></span>
<span class="codeline" id="line-382"><code>			ranges := (*notInHeapSlice)(unsafe.Pointer(&amp;a.ranges))</code></span>
<span class="codeline" id="line-383"><code>			ranges.len = len(oldRanges) + 1</code></span>
<span class="codeline" id="line-384"><code>			ranges.cap = cap(oldRanges) * 2</code></span>
<span class="codeline" id="line-385"><code>			ranges.array = (*notInHeap)(persistentalloc(unsafe.Sizeof(addrRange{})*uintptr(ranges.cap), goarch.PtrSize, a.sysStat))</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>			// Copy in the old array, but make space for the new range.</code></span>
<span class="codeline" id="line-388"><code>			copy(a.ranges[:i], oldRanges[:i])</code></span>
<span class="codeline" id="line-389"><code>			copy(a.ranges[i+1:], oldRanges[i:])</code></span>
<span class="codeline" id="line-390"><code>		} else {</code></span>
<span class="codeline" id="line-391"><code>			a.ranges = a.ranges[:len(a.ranges)+1]</code></span>
<span class="codeline" id="line-392"><code>			copy(a.ranges[i+1:], a.ranges[i:])</code></span>
<span class="codeline" id="line-393"><code>		}</code></span>
<span class="codeline" id="line-394"><code>		a.ranges[i] = r</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code>	a.totalBytes += r.size()</code></span>
<span class="codeline" id="line-397"><code>}</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>// removeLast removes and returns the highest-addressed contiguous range</code></span>
<span class="codeline" id="line-400"><code>// of a, or the last nBytes of that range, whichever is smaller. If a is</code></span>
<span class="codeline" id="line-401"><code>// empty, it returns an empty range.</code></span>
<span class="codeline" id="line-402"><code>func (a *addrRanges) removeLast(nBytes uintptr) addrRange {</code></span>
<span class="codeline" id="line-403"><code>	if len(a.ranges) == 0 {</code></span>
<span class="codeline" id="line-404"><code>		return addrRange{}</code></span>
<span class="codeline" id="line-405"><code>	}</code></span>
<span class="codeline" id="line-406"><code>	r := a.ranges[len(a.ranges)-1]</code></span>
<span class="codeline" id="line-407"><code>	size := r.size()</code></span>
<span class="codeline" id="line-408"><code>	if size &gt; nBytes {</code></span>
<span class="codeline" id="line-409"><code>		newEnd := r.limit.sub(nBytes)</code></span>
<span class="codeline" id="line-410"><code>		a.ranges[len(a.ranges)-1].limit = newEnd</code></span>
<span class="codeline" id="line-411"><code>		a.totalBytes -= nBytes</code></span>
<span class="codeline" id="line-412"><code>		return addrRange{newEnd, r.limit}</code></span>
<span class="codeline" id="line-413"><code>	}</code></span>
<span class="codeline" id="line-414"><code>	a.ranges = a.ranges[:len(a.ranges)-1]</code></span>
<span class="codeline" id="line-415"><code>	a.totalBytes -= size</code></span>
<span class="codeline" id="line-416"><code>	return r</code></span>
<span class="codeline" id="line-417"><code>}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>// removeGreaterEqual removes the ranges of a which are above addr, and additionally</code></span>
<span class="codeline" id="line-420"><code>// splits any range containing addr.</code></span>
<span class="codeline" id="line-421"><code>func (a *addrRanges) removeGreaterEqual(addr uintptr) {</code></span>
<span class="codeline" id="line-422"><code>	pivot := a.findSucc(addr)</code></span>
<span class="codeline" id="line-423"><code>	if pivot == 0 {</code></span>
<span class="codeline" id="line-424"><code>		// addr is before all ranges in a.</code></span>
<span class="codeline" id="line-425"><code>		a.totalBytes = 0</code></span>
<span class="codeline" id="line-426"><code>		a.ranges = a.ranges[:0]</code></span>
<span class="codeline" id="line-427"><code>		return</code></span>
<span class="codeline" id="line-428"><code>	}</code></span>
<span class="codeline" id="line-429"><code>	removed := uintptr(0)</code></span>
<span class="codeline" id="line-430"><code>	for _, r := range a.ranges[pivot:] {</code></span>
<span class="codeline" id="line-431"><code>		removed += r.size()</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code>	if r := a.ranges[pivot-1]; r.contains(addr) {</code></span>
<span class="codeline" id="line-434"><code>		removed += r.size()</code></span>
<span class="codeline" id="line-435"><code>		r = r.removeGreaterEqual(addr)</code></span>
<span class="codeline" id="line-436"><code>		if r.size() == 0 {</code></span>
<span class="codeline" id="line-437"><code>			pivot--</code></span>
<span class="codeline" id="line-438"><code>		} else {</code></span>
<span class="codeline" id="line-439"><code>			removed -= r.size()</code></span>
<span class="codeline" id="line-440"><code>			a.ranges[pivot-1] = r</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>	a.ranges = a.ranges[:pivot]</code></span>
<span class="codeline" id="line-444"><code>	a.totalBytes -= removed</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>// cloneInto makes a deep clone of a's state into b, re-using</code></span>
<span class="codeline" id="line-448"><code>// b's ranges if able.</code></span>
<span class="codeline" id="line-449"><code>func (a *addrRanges) cloneInto(b *addrRanges) {</code></span>
<span class="codeline" id="line-450"><code>	if len(a.ranges) &gt; cap(b.ranges) {</code></span>
<span class="codeline" id="line-451"><code>		// Grow the array.</code></span>
<span class="codeline" id="line-452"><code>		ranges := (*notInHeapSlice)(unsafe.Pointer(&amp;b.ranges))</code></span>
<span class="codeline" id="line-453"><code>		ranges.len = 0</code></span>
<span class="codeline" id="line-454"><code>		ranges.cap = cap(a.ranges)</code></span>
<span class="codeline" id="line-455"><code>		ranges.array = (*notInHeap)(persistentalloc(unsafe.Sizeof(addrRange{})*uintptr(ranges.cap), goarch.PtrSize, b.sysStat))</code></span>
<span class="codeline" id="line-456"><code>	}</code></span>
<span class="codeline" id="line-457"><code>	b.ranges = b.ranges[:len(a.ranges)]</code></span>
<span class="codeline" id="line-458"><code>	b.totalBytes = a.totalBytes</code></span>
<span class="codeline" id="line-459"><code>	copy(b.ranges, a.ranges)</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>