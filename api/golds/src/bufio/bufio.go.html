<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: bufio.go in package bufio</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	bufio.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/bufio.html">bufio</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer</code></span>
<span class="codeline" id="line-6"><code>// object, creating another object (Reader or Writer) that also implements</code></span>
<span class="codeline" id="line-7"><code>// the interface but provides buffering and some help for textual I/O.</code></span></div><span class="codeline" id="line-8"><code>package bufio</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"bytes"</code></span>
<span class="codeline" id="line-12"><code>	"errors"</code></span>
<span class="codeline" id="line-13"><code>	"io"</code></span>
<span class="codeline" id="line-14"><code>	"strings"</code></span>
<span class="codeline" id="line-15"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>const (</code></span>
<span class="codeline" id="line-19"><code>	defaultBufSize = 4096</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>var (</code></span>
<span class="codeline" id="line-23"><code>	ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")</code></span>
<span class="codeline" id="line-24"><code>	ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")</code></span>
<span class="codeline" id="line-25"><code>	ErrBufferFull        = errors.New("bufio: buffer full")</code></span>
<span class="codeline" id="line-26"><code>	ErrNegativeCount     = errors.New("bufio: negative count")</code></span>
<span class="codeline" id="line-27"><code>)</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>// Buffered input.</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// Reader implements buffering for an io.Reader object.</code></span>
<span class="codeline" id="line-32"><code>type Reader struct {</code></span>
<span class="codeline" id="line-33"><code>	buf          []byte</code></span>
<span class="codeline" id="line-34"><code>	rd           io.Reader // reader provided by the client</code></span>
<span class="codeline" id="line-35"><code>	r, w         int       // buf read and write positions</code></span>
<span class="codeline" id="line-36"><code>	err          error</code></span>
<span class="codeline" id="line-37"><code>	lastByte     int // last byte read for UnreadByte; -1 means invalid</code></span>
<span class="codeline" id="line-38"><code>	lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid</code></span>
<span class="codeline" id="line-39"><code>}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>const minReadBufferSize = 16</code></span>
<span class="codeline" id="line-42"><code>const maxConsecutiveEmptyReads = 100</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>// NewReaderSize returns a new [Reader] whose buffer has at least the specified</code></span>
<span class="codeline" id="line-45"><code>// size. If the argument io.Reader is already a [Reader] with large enough</code></span>
<span class="codeline" id="line-46"><code>// size, it returns the underlying [Reader].</code></span>
<span class="codeline" id="line-47"><code>func NewReaderSize(rd io.Reader, size int) *Reader {</code></span>
<span class="codeline" id="line-48"><code>	// Is it already a Reader?</code></span>
<span class="codeline" id="line-49"><code>	b, ok := rd.(*Reader)</code></span>
<span class="codeline" id="line-50"><code>	if ok &amp;&amp; len(b.buf) &gt;= size {</code></span>
<span class="codeline" id="line-51"><code>		return b</code></span>
<span class="codeline" id="line-52"><code>	}</code></span>
<span class="codeline" id="line-53"><code>	r := new(Reader)</code></span>
<span class="codeline" id="line-54"><code>	r.reset(make([]byte, max(size, minReadBufferSize)), rd)</code></span>
<span class="codeline" id="line-55"><code>	return r</code></span>
<span class="codeline" id="line-56"><code>}</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>// NewReader returns a new [Reader] whose buffer has the default size.</code></span>
<span class="codeline" id="line-59"><code>func NewReader(rd io.Reader) *Reader {</code></span>
<span class="codeline" id="line-60"><code>	return NewReaderSize(rd, defaultBufSize)</code></span>
<span class="codeline" id="line-61"><code>}</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>// Size returns the size of the underlying buffer in bytes.</code></span>
<span class="codeline" id="line-64"><code>func (b *Reader) Size() int { return len(b.buf) }</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// Reset discards any buffered data, resets all state, and switches</code></span>
<span class="codeline" id="line-67"><code>// the buffered reader to read from r.</code></span>
<span class="codeline" id="line-68"><code>// Calling Reset on the zero value of [Reader] initializes the internal buffer</code></span>
<span class="codeline" id="line-69"><code>// to the default size.</code></span>
<span class="codeline" id="line-70"><code>// Calling b.Reset(b) (that is, resetting a [Reader] to itself) does nothing.</code></span>
<span class="codeline" id="line-71"><code>func (b *Reader) Reset(r io.Reader) {</code></span>
<span class="codeline" id="line-72"><code>	// If a Reader r is passed to NewReader, NewReader will return r.</code></span>
<span class="codeline" id="line-73"><code>	// Different layers of code may do that, and then later pass r</code></span>
<span class="codeline" id="line-74"><code>	// to Reset. Avoid infinite recursion in that case.</code></span>
<span class="codeline" id="line-75"><code>	if b == r {</code></span>
<span class="codeline" id="line-76"><code>		return</code></span>
<span class="codeline" id="line-77"><code>	}</code></span>
<span class="codeline" id="line-78"><code>	if b.buf == nil {</code></span>
<span class="codeline" id="line-79"><code>		b.buf = make([]byte, defaultBufSize)</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code>	b.reset(b.buf, r)</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>func (b *Reader) reset(buf []byte, r io.Reader) {</code></span>
<span class="codeline" id="line-85"><code>	*b = Reader{</code></span>
<span class="codeline" id="line-86"><code>		buf:          buf,</code></span>
<span class="codeline" id="line-87"><code>		rd:           r,</code></span>
<span class="codeline" id="line-88"><code>		lastByte:     -1,</code></span>
<span class="codeline" id="line-89"><code>		lastRuneSize: -1,</code></span>
<span class="codeline" id="line-90"><code>	}</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>var errNegativeRead = errors.New("bufio: reader returned negative count from Read")</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>// fill reads a new chunk into the buffer.</code></span>
<span class="codeline" id="line-96"><code>func (b *Reader) fill() {</code></span>
<span class="codeline" id="line-97"><code>	// Slide existing data to beginning.</code></span>
<span class="codeline" id="line-98"><code>	if b.r &gt; 0 {</code></span>
<span class="codeline" id="line-99"><code>		copy(b.buf, b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-100"><code>		b.w -= b.r</code></span>
<span class="codeline" id="line-101"><code>		b.r = 0</code></span>
<span class="codeline" id="line-102"><code>	}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>	if b.w &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-105"><code>		panic("bufio: tried to fill full buffer")</code></span>
<span class="codeline" id="line-106"><code>	}</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>	// Read new data: try a limited number of times.</code></span>
<span class="codeline" id="line-109"><code>	for i := maxConsecutiveEmptyReads; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-110"><code>		n, err := b.rd.Read(b.buf[b.w:])</code></span>
<span class="codeline" id="line-111"><code>		if n &lt; 0 {</code></span>
<span class="codeline" id="line-112"><code>			panic(errNegativeRead)</code></span>
<span class="codeline" id="line-113"><code>		}</code></span>
<span class="codeline" id="line-114"><code>		b.w += n</code></span>
<span class="codeline" id="line-115"><code>		if err != nil {</code></span>
<span class="codeline" id="line-116"><code>			b.err = err</code></span>
<span class="codeline" id="line-117"><code>			return</code></span>
<span class="codeline" id="line-118"><code>		}</code></span>
<span class="codeline" id="line-119"><code>		if n &gt; 0 {</code></span>
<span class="codeline" id="line-120"><code>			return</code></span>
<span class="codeline" id="line-121"><code>		}</code></span>
<span class="codeline" id="line-122"><code>	}</code></span>
<span class="codeline" id="line-123"><code>	b.err = io.ErrNoProgress</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>func (b *Reader) readErr() error {</code></span>
<span class="codeline" id="line-127"><code>	err := b.err</code></span>
<span class="codeline" id="line-128"><code>	b.err = nil</code></span>
<span class="codeline" id="line-129"><code>	return err</code></span>
<span class="codeline" id="line-130"><code>}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>// Peek returns the next n bytes without advancing the reader. The bytes stop</code></span>
<span class="codeline" id="line-133"><code>// being valid at the next read call. If Peek returns fewer than n bytes, it</code></span>
<span class="codeline" id="line-134"><code>// also returns an error explaining why the read is short. The error is</code></span>
<span class="codeline" id="line-135"><code>// [ErrBufferFull] if n is larger than b's buffer size.</code></span>
<span class="codeline" id="line-136"><code>//</code></span>
<span class="codeline" id="line-137"><code>// Calling Peek prevents a [Reader.UnreadByte] or [Reader.UnreadRune] call from succeeding</code></span>
<span class="codeline" id="line-138"><code>// until the next read operation.</code></span>
<span class="codeline" id="line-139"><code>func (b *Reader) Peek(n int) ([]byte, error) {</code></span>
<span class="codeline" id="line-140"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-141"><code>		return nil, ErrNegativeCount</code></span>
<span class="codeline" id="line-142"><code>	}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-145"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	for b.w-b.r &lt; n &amp;&amp; b.w-b.r &lt; len(b.buf) &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-148"><code>		b.fill() // b.w-b.r &lt; len(b.buf) =&gt; buffer is not full</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>	if n &gt; len(b.buf) {</code></span>
<span class="codeline" id="line-152"><code>		return b.buf[b.r:b.w], ErrBufferFull</code></span>
<span class="codeline" id="line-153"><code>	}</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// 0 &lt;= n &lt;= len(b.buf)</code></span>
<span class="codeline" id="line-156"><code>	var err error</code></span>
<span class="codeline" id="line-157"><code>	if avail := b.w - b.r; avail &lt; n {</code></span>
<span class="codeline" id="line-158"><code>		// not enough data in buffer</code></span>
<span class="codeline" id="line-159"><code>		n = avail</code></span>
<span class="codeline" id="line-160"><code>		err = b.readErr()</code></span>
<span class="codeline" id="line-161"><code>		if err == nil {</code></span>
<span class="codeline" id="line-162"><code>			err = ErrBufferFull</code></span>
<span class="codeline" id="line-163"><code>		}</code></span>
<span class="codeline" id="line-164"><code>	}</code></span>
<span class="codeline" id="line-165"><code>	return b.buf[b.r : b.r+n], err</code></span>
<span class="codeline" id="line-166"><code>}</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>// Discard skips the next n bytes, returning the number of bytes discarded.</code></span>
<span class="codeline" id="line-169"><code>//</code></span>
<span class="codeline" id="line-170"><code>// If Discard skips fewer than n bytes, it also returns an error.</code></span>
<span class="codeline" id="line-171"><code>// If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without</code></span>
<span class="codeline" id="line-172"><code>// reading from the underlying io.Reader.</code></span>
<span class="codeline" id="line-173"><code>func (b *Reader) Discard(n int) (discarded int, err error) {</code></span>
<span class="codeline" id="line-174"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-175"><code>		return 0, ErrNegativeCount</code></span>
<span class="codeline" id="line-176"><code>	}</code></span>
<span class="codeline" id="line-177"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-178"><code>		return</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-182"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	remain := n</code></span>
<span class="codeline" id="line-185"><code>	for {</code></span>
<span class="codeline" id="line-186"><code>		skip := b.Buffered()</code></span>
<span class="codeline" id="line-187"><code>		if skip == 0 {</code></span>
<span class="codeline" id="line-188"><code>			b.fill()</code></span>
<span class="codeline" id="line-189"><code>			skip = b.Buffered()</code></span>
<span class="codeline" id="line-190"><code>		}</code></span>
<span class="codeline" id="line-191"><code>		if skip &gt; remain {</code></span>
<span class="codeline" id="line-192"><code>			skip = remain</code></span>
<span class="codeline" id="line-193"><code>		}</code></span>
<span class="codeline" id="line-194"><code>		b.r += skip</code></span>
<span class="codeline" id="line-195"><code>		remain -= skip</code></span>
<span class="codeline" id="line-196"><code>		if remain == 0 {</code></span>
<span class="codeline" id="line-197"><code>			return n, nil</code></span>
<span class="codeline" id="line-198"><code>		}</code></span>
<span class="codeline" id="line-199"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-200"><code>			return n - remain, b.readErr()</code></span>
<span class="codeline" id="line-201"><code>		}</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>// Read reads data into p.</code></span>
<span class="codeline" id="line-206"><code>// It returns the number of bytes read into p.</code></span>
<span class="codeline" id="line-207"><code>// The bytes are taken from at most one Read on the underlying [Reader],</code></span>
<span class="codeline" id="line-208"><code>// hence n may be less than len(p).</code></span>
<span class="codeline" id="line-209"><code>// To read exactly len(p) bytes, use io.ReadFull(b, p).</code></span>
<span class="codeline" id="line-210"><code>// If the underlying [Reader] can return a non-zero count with io.EOF,</code></span>
<span class="codeline" id="line-211"><code>// then this Read method can do so as well; see the [io.Reader] docs.</code></span>
<span class="codeline" id="line-212"><code>func (b *Reader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-213"><code>	n = len(p)</code></span>
<span class="codeline" id="line-214"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-215"><code>		if b.Buffered() &gt; 0 {</code></span>
<span class="codeline" id="line-216"><code>			return 0, nil</code></span>
<span class="codeline" id="line-217"><code>		}</code></span>
<span class="codeline" id="line-218"><code>		return 0, b.readErr()</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code>	if b.r == b.w {</code></span>
<span class="codeline" id="line-221"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-222"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-223"><code>		}</code></span>
<span class="codeline" id="line-224"><code>		if len(p) &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-225"><code>			// Large read, empty buffer.</code></span>
<span class="codeline" id="line-226"><code>			// Read directly into p to avoid copy.</code></span>
<span class="codeline" id="line-227"><code>			n, b.err = b.rd.Read(p)</code></span>
<span class="codeline" id="line-228"><code>			if n &lt; 0 {</code></span>
<span class="codeline" id="line-229"><code>				panic(errNegativeRead)</code></span>
<span class="codeline" id="line-230"><code>			}</code></span>
<span class="codeline" id="line-231"><code>			if n &gt; 0 {</code></span>
<span class="codeline" id="line-232"><code>				b.lastByte = int(p[n-1])</code></span>
<span class="codeline" id="line-233"><code>				b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-234"><code>			}</code></span>
<span class="codeline" id="line-235"><code>			return n, b.readErr()</code></span>
<span class="codeline" id="line-236"><code>		}</code></span>
<span class="codeline" id="line-237"><code>		// One read.</code></span>
<span class="codeline" id="line-238"><code>		// Do not use b.fill, which will loop.</code></span>
<span class="codeline" id="line-239"><code>		b.r = 0</code></span>
<span class="codeline" id="line-240"><code>		b.w = 0</code></span>
<span class="codeline" id="line-241"><code>		n, b.err = b.rd.Read(b.buf)</code></span>
<span class="codeline" id="line-242"><code>		if n &lt; 0 {</code></span>
<span class="codeline" id="line-243"><code>			panic(errNegativeRead)</code></span>
<span class="codeline" id="line-244"><code>		}</code></span>
<span class="codeline" id="line-245"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-246"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-247"><code>		}</code></span>
<span class="codeline" id="line-248"><code>		b.w += n</code></span>
<span class="codeline" id="line-249"><code>	}</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>	// copy as much as we can</code></span>
<span class="codeline" id="line-252"><code>	// Note: if the slice panics here, it is probably because</code></span>
<span class="codeline" id="line-253"><code>	// the underlying reader returned a bad count. See issue 49795.</code></span>
<span class="codeline" id="line-254"><code>	n = copy(p, b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-255"><code>	b.r += n</code></span>
<span class="codeline" id="line-256"><code>	b.lastByte = int(b.buf[b.r-1])</code></span>
<span class="codeline" id="line-257"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-258"><code>	return n, nil</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// ReadByte reads and returns a single byte.</code></span>
<span class="codeline" id="line-262"><code>// If no byte is available, returns an error.</code></span>
<span class="codeline" id="line-263"><code>func (b *Reader) ReadByte() (byte, error) {</code></span>
<span class="codeline" id="line-264"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-265"><code>	for b.r == b.w {</code></span>
<span class="codeline" id="line-266"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-267"><code>			return 0, b.readErr()</code></span>
<span class="codeline" id="line-268"><code>		}</code></span>
<span class="codeline" id="line-269"><code>		b.fill() // buffer is empty</code></span>
<span class="codeline" id="line-270"><code>	}</code></span>
<span class="codeline" id="line-271"><code>	c := b.buf[b.r]</code></span>
<span class="codeline" id="line-272"><code>	b.r++</code></span>
<span class="codeline" id="line-273"><code>	b.lastByte = int(c)</code></span>
<span class="codeline" id="line-274"><code>	return c, nil</code></span>
<span class="codeline" id="line-275"><code>}</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// UnreadByte unreads the last byte. Only the most recently read byte can be unread.</code></span>
<span class="codeline" id="line-278"><code>//</code></span>
<span class="codeline" id="line-279"><code>// UnreadByte returns an error if the most recent method called on the</code></span>
<span class="codeline" id="line-280"><code>// [Reader] was not a read operation. Notably, [Reader.Peek], [Reader.Discard], and [Reader.WriteTo] are not</code></span>
<span class="codeline" id="line-281"><code>// considered read operations.</code></span>
<span class="codeline" id="line-282"><code>func (b *Reader) UnreadByte() error {</code></span>
<span class="codeline" id="line-283"><code>	if b.lastByte &lt; 0 || b.r == 0 &amp;&amp; b.w &gt; 0 {</code></span>
<span class="codeline" id="line-284"><code>		return ErrInvalidUnreadByte</code></span>
<span class="codeline" id="line-285"><code>	}</code></span>
<span class="codeline" id="line-286"><code>	// b.r &gt; 0 || b.w == 0</code></span>
<span class="codeline" id="line-287"><code>	if b.r &gt; 0 {</code></span>
<span class="codeline" id="line-288"><code>		b.r--</code></span>
<span class="codeline" id="line-289"><code>	} else {</code></span>
<span class="codeline" id="line-290"><code>		// b.r == 0 &amp;&amp; b.w == 0</code></span>
<span class="codeline" id="line-291"><code>		b.w = 1</code></span>
<span class="codeline" id="line-292"><code>	}</code></span>
<span class="codeline" id="line-293"><code>	b.buf[b.r] = byte(b.lastByte)</code></span>
<span class="codeline" id="line-294"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-295"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-296"><code>	return nil</code></span>
<span class="codeline" id="line-297"><code>}</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>// ReadRune reads a single UTF-8 encoded Unicode character and returns the</code></span>
<span class="codeline" id="line-300"><code>// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte</code></span>
<span class="codeline" id="line-301"><code>// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.</code></span>
<span class="codeline" id="line-302"><code>func (b *Reader) ReadRune() (r rune, size int, err error) {</code></span>
<span class="codeline" id="line-303"><code>	for b.r+utf8.UTFMax &gt; b.w &amp;&amp; !utf8.FullRune(b.buf[b.r:b.w]) &amp;&amp; b.err == nil &amp;&amp; b.w-b.r &lt; len(b.buf) {</code></span>
<span class="codeline" id="line-304"><code>		b.fill() // b.w-b.r &lt; len(buf) =&gt; buffer is not full</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-307"><code>	if b.r == b.w {</code></span>
<span class="codeline" id="line-308"><code>		return 0, 0, b.readErr()</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	r, size = rune(b.buf[b.r]), 1</code></span>
<span class="codeline" id="line-311"><code>	if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-312"><code>		r, size = utf8.DecodeRune(b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-313"><code>	}</code></span>
<span class="codeline" id="line-314"><code>	b.r += size</code></span>
<span class="codeline" id="line-315"><code>	b.lastByte = int(b.buf[b.r-1])</code></span>
<span class="codeline" id="line-316"><code>	b.lastRuneSize = size</code></span>
<span class="codeline" id="line-317"><code>	return r, size, nil</code></span>
<span class="codeline" id="line-318"><code>}</code></span>
<span class="codeline" id="line-319"><code></code></span>
<span class="codeline" id="line-320"><code>// UnreadRune unreads the last rune. If the most recent method called on</code></span>
<span class="codeline" id="line-321"><code>// the [Reader] was not a [Reader.ReadRune], [Reader.UnreadRune] returns an error. (In this</code></span>
<span class="codeline" id="line-322"><code>// regard it is stricter than [Reader.UnreadByte], which will unread the last byte</code></span>
<span class="codeline" id="line-323"><code>// from any read operation.)</code></span>
<span class="codeline" id="line-324"><code>func (b *Reader) UnreadRune() error {</code></span>
<span class="codeline" id="line-325"><code>	if b.lastRuneSize &lt; 0 || b.r &lt; b.lastRuneSize {</code></span>
<span class="codeline" id="line-326"><code>		return ErrInvalidUnreadRune</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code>	b.r -= b.lastRuneSize</code></span>
<span class="codeline" id="line-329"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-330"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-331"><code>	return nil</code></span>
<span class="codeline" id="line-332"><code>}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>// Buffered returns the number of bytes that can be read from the current buffer.</code></span>
<span class="codeline" id="line-335"><code>func (b *Reader) Buffered() int { return b.w - b.r }</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>// ReadSlice reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-338"><code>// returning a slice pointing at the bytes in the buffer.</code></span>
<span class="codeline" id="line-339"><code>// The bytes stop being valid at the next read.</code></span>
<span class="codeline" id="line-340"><code>// If ReadSlice encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-341"><code>// it returns all the data in the buffer and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-342"><code>// ReadSlice fails with error [ErrBufferFull] if the buffer fills without a delim.</code></span>
<span class="codeline" id="line-343"><code>// Because the data returned from ReadSlice will be overwritten</code></span>
<span class="codeline" id="line-344"><code>// by the next I/O operation, most clients should use</code></span>
<span class="codeline" id="line-345"><code>// [Reader.ReadBytes] or ReadString instead.</code></span>
<span class="codeline" id="line-346"><code>// ReadSlice returns err != nil if and only if line does not end in delim.</code></span>
<span class="codeline" id="line-347"><code>func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {</code></span>
<span class="codeline" id="line-348"><code>	s := 0 // search start index</code></span>
<span class="codeline" id="line-349"><code>	for {</code></span>
<span class="codeline" id="line-350"><code>		// Search buffer.</code></span>
<span class="codeline" id="line-351"><code>		if i := bytes.IndexByte(b.buf[b.r+s:b.w], delim); i &gt;= 0 {</code></span>
<span class="codeline" id="line-352"><code>			i += s</code></span>
<span class="codeline" id="line-353"><code>			line = b.buf[b.r : b.r+i+1]</code></span>
<span class="codeline" id="line-354"><code>			b.r += i + 1</code></span>
<span class="codeline" id="line-355"><code>			break</code></span>
<span class="codeline" id="line-356"><code>		}</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>		// Pending error?</code></span>
<span class="codeline" id="line-359"><code>		if b.err != nil {</code></span>
<span class="codeline" id="line-360"><code>			line = b.buf[b.r:b.w]</code></span>
<span class="codeline" id="line-361"><code>			b.r = b.w</code></span>
<span class="codeline" id="line-362"><code>			err = b.readErr()</code></span>
<span class="codeline" id="line-363"><code>			break</code></span>
<span class="codeline" id="line-364"><code>		}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>		// Buffer full?</code></span>
<span class="codeline" id="line-367"><code>		if b.Buffered() &gt;= len(b.buf) {</code></span>
<span class="codeline" id="line-368"><code>			b.r = b.w</code></span>
<span class="codeline" id="line-369"><code>			line = b.buf</code></span>
<span class="codeline" id="line-370"><code>			err = ErrBufferFull</code></span>
<span class="codeline" id="line-371"><code>			break</code></span>
<span class="codeline" id="line-372"><code>		}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>		s = b.w - b.r // do not rescan area we scanned before</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>		b.fill() // buffer is not full</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>	// Handle last byte, if any.</code></span>
<span class="codeline" id="line-380"><code>	if i := len(line) - 1; i &gt;= 0 {</code></span>
<span class="codeline" id="line-381"><code>		b.lastByte = int(line[i])</code></span>
<span class="codeline" id="line-382"><code>		b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-383"><code>	}</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	return</code></span>
<span class="codeline" id="line-386"><code>}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>// ReadLine is a low-level line-reading primitive. Most callers should use</code></span>
<span class="codeline" id="line-389"><code>// [Reader.ReadBytes]('\n') or [Reader.ReadString]('\n') instead or use a [Scanner].</code></span>
<span class="codeline" id="line-390"><code>//</code></span>
<span class="codeline" id="line-391"><code>// ReadLine tries to return a single line, not including the end-of-line bytes.</code></span>
<span class="codeline" id="line-392"><code>// If the line was too long for the buffer then isPrefix is set and the</code></span>
<span class="codeline" id="line-393"><code>// beginning of the line is returned. The rest of the line will be returned</code></span>
<span class="codeline" id="line-394"><code>// from future calls. isPrefix will be false when returning the last fragment</code></span>
<span class="codeline" id="line-395"><code>// of the line. The returned buffer is only valid until the next call to</code></span>
<span class="codeline" id="line-396"><code>// ReadLine. ReadLine either returns a non-nil line or it returns an error,</code></span>
<span class="codeline" id="line-397"><code>// never both.</code></span>
<span class="codeline" id="line-398"><code>//</code></span>
<span class="codeline" id="line-399"><code>// The text returned from ReadLine does not include the line end ("\r\n" or "\n").</code></span>
<span class="codeline" id="line-400"><code>// No indication or error is given if the input ends without a final line end.</code></span>
<span class="codeline" id="line-401"><code>// Calling [Reader.UnreadByte] after ReadLine will always unread the last byte read</code></span>
<span class="codeline" id="line-402"><code>// (possibly a character belonging to the line end) even if that byte is not</code></span>
<span class="codeline" id="line-403"><code>// part of the line returned by ReadLine.</code></span>
<span class="codeline" id="line-404"><code>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {</code></span>
<span class="codeline" id="line-405"><code>	line, err = b.ReadSlice('\n')</code></span>
<span class="codeline" id="line-406"><code>	if err == ErrBufferFull {</code></span>
<span class="codeline" id="line-407"><code>		// Handle the case where "\r\n" straddles the buffer.</code></span>
<span class="codeline" id="line-408"><code>		if len(line) &gt; 0 &amp;&amp; line[len(line)-1] == '\r' {</code></span>
<span class="codeline" id="line-409"><code>			// Put the '\r' back on buf and drop it from line.</code></span>
<span class="codeline" id="line-410"><code>			// Let the next call to ReadLine check for "\r\n".</code></span>
<span class="codeline" id="line-411"><code>			if b.r == 0 {</code></span>
<span class="codeline" id="line-412"><code>				// should be unreachable</code></span>
<span class="codeline" id="line-413"><code>				panic("bufio: tried to rewind past start of buffer")</code></span>
<span class="codeline" id="line-414"><code>			}</code></span>
<span class="codeline" id="line-415"><code>			b.r--</code></span>
<span class="codeline" id="line-416"><code>			line = line[:len(line)-1]</code></span>
<span class="codeline" id="line-417"><code>		}</code></span>
<span class="codeline" id="line-418"><code>		return line, true, nil</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	if len(line) == 0 {</code></span>
<span class="codeline" id="line-422"><code>		if err != nil {</code></span>
<span class="codeline" id="line-423"><code>			line = nil</code></span>
<span class="codeline" id="line-424"><code>		}</code></span>
<span class="codeline" id="line-425"><code>		return</code></span>
<span class="codeline" id="line-426"><code>	}</code></span>
<span class="codeline" id="line-427"><code>	err = nil</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>	if line[len(line)-1] == '\n' {</code></span>
<span class="codeline" id="line-430"><code>		drop := 1</code></span>
<span class="codeline" id="line-431"><code>		if len(line) &gt; 1 &amp;&amp; line[len(line)-2] == '\r' {</code></span>
<span class="codeline" id="line-432"><code>			drop = 2</code></span>
<span class="codeline" id="line-433"><code>		}</code></span>
<span class="codeline" id="line-434"><code>		line = line[:len(line)-drop]</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code>	return</code></span>
<span class="codeline" id="line-437"><code>}</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>// collectFragments reads until the first occurrence of delim in the input. It</code></span>
<span class="codeline" id="line-440"><code>// returns (slice of full buffers, remaining bytes before delim, total number</code></span>
<span class="codeline" id="line-441"><code>// of bytes in the combined first two elements, error).</code></span>
<span class="codeline" id="line-442"><code>// The complete result is equal to</code></span>
<span class="codeline" id="line-443"><code>// `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a</code></span>
<span class="codeline" id="line-444"><code>// length of `totalLen`. The result is structured in this way to allow callers</code></span>
<span class="codeline" id="line-445"><code>// to minimize allocations and copies.</code></span>
<span class="codeline" id="line-446"><code>func (b *Reader) collectFragments(delim byte) (fullBuffers [][]byte, finalFragment []byte, totalLen int, err error) {</code></span>
<span class="codeline" id="line-447"><code>	var frag []byte</code></span>
<span class="codeline" id="line-448"><code>	// Use ReadSlice to look for delim, accumulating full buffers.</code></span>
<span class="codeline" id="line-449"><code>	for {</code></span>
<span class="codeline" id="line-450"><code>		var e error</code></span>
<span class="codeline" id="line-451"><code>		frag, e = b.ReadSlice(delim)</code></span>
<span class="codeline" id="line-452"><code>		if e == nil { // got final fragment</code></span>
<span class="codeline" id="line-453"><code>			break</code></span>
<span class="codeline" id="line-454"><code>		}</code></span>
<span class="codeline" id="line-455"><code>		if e != ErrBufferFull { // unexpected error</code></span>
<span class="codeline" id="line-456"><code>			err = e</code></span>
<span class="codeline" id="line-457"><code>			break</code></span>
<span class="codeline" id="line-458"><code>		}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>		// Make a copy of the buffer.</code></span>
<span class="codeline" id="line-461"><code>		buf := bytes.Clone(frag)</code></span>
<span class="codeline" id="line-462"><code>		fullBuffers = append(fullBuffers, buf)</code></span>
<span class="codeline" id="line-463"><code>		totalLen += len(buf)</code></span>
<span class="codeline" id="line-464"><code>	}</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>	totalLen += len(frag)</code></span>
<span class="codeline" id="line-467"><code>	return fullBuffers, frag, totalLen, err</code></span>
<span class="codeline" id="line-468"><code>}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>// ReadBytes reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-471"><code>// returning a slice containing the data up to and including the delimiter.</code></span>
<span class="codeline" id="line-472"><code>// If ReadBytes encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-473"><code>// it returns the data read before the error and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-474"><code>// ReadBytes returns err != nil if and only if the returned data does not end in</code></span>
<span class="codeline" id="line-475"><code>// delim.</code></span>
<span class="codeline" id="line-476"><code>// For simple uses, a Scanner may be more convenient.</code></span>
<span class="codeline" id="line-477"><code>func (b *Reader) ReadBytes(delim byte) ([]byte, error) {</code></span>
<span class="codeline" id="line-478"><code>	full, frag, n, err := b.collectFragments(delim)</code></span>
<span class="codeline" id="line-479"><code>	// Allocate new buffer to hold the full pieces and the fragment.</code></span>
<span class="codeline" id="line-480"><code>	buf := make([]byte, n)</code></span>
<span class="codeline" id="line-481"><code>	n = 0</code></span>
<span class="codeline" id="line-482"><code>	// Copy full pieces and fragment in.</code></span>
<span class="codeline" id="line-483"><code>	for i := range full {</code></span>
<span class="codeline" id="line-484"><code>		n += copy(buf[n:], full[i])</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code>	copy(buf[n:], frag)</code></span>
<span class="codeline" id="line-487"><code>	return buf, err</code></span>
<span class="codeline" id="line-488"><code>}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>// ReadString reads until the first occurrence of delim in the input,</code></span>
<span class="codeline" id="line-491"><code>// returning a string containing the data up to and including the delimiter.</code></span>
<span class="codeline" id="line-492"><code>// If ReadString encounters an error before finding a delimiter,</code></span>
<span class="codeline" id="line-493"><code>// it returns the data read before the error and the error itself (often io.EOF).</code></span>
<span class="codeline" id="line-494"><code>// ReadString returns err != nil if and only if the returned data does not end in</code></span>
<span class="codeline" id="line-495"><code>// delim.</code></span>
<span class="codeline" id="line-496"><code>// For simple uses, a Scanner may be more convenient.</code></span>
<span class="codeline" id="line-497"><code>func (b *Reader) ReadString(delim byte) (string, error) {</code></span>
<span class="codeline" id="line-498"><code>	full, frag, n, err := b.collectFragments(delim)</code></span>
<span class="codeline" id="line-499"><code>	// Allocate new buffer to hold the full pieces and the fragment.</code></span>
<span class="codeline" id="line-500"><code>	var buf strings.Builder</code></span>
<span class="codeline" id="line-501"><code>	buf.Grow(n)</code></span>
<span class="codeline" id="line-502"><code>	// Copy full pieces and fragment in.</code></span>
<span class="codeline" id="line-503"><code>	for _, fb := range full {</code></span>
<span class="codeline" id="line-504"><code>		buf.Write(fb)</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>	buf.Write(frag)</code></span>
<span class="codeline" id="line-507"><code>	return buf.String(), err</code></span>
<span class="codeline" id="line-508"><code>}</code></span>
<span class="codeline" id="line-509"><code></code></span>
<span class="codeline" id="line-510"><code>// WriteTo implements io.WriterTo.</code></span>
<span class="codeline" id="line-511"><code>// This may make multiple calls to the [Reader.Read] method of the underlying [Reader].</code></span>
<span class="codeline" id="line-512"><code>// If the underlying reader supports the [Reader.WriteTo] method,</code></span>
<span class="codeline" id="line-513"><code>// this calls the underlying [Reader.WriteTo] without buffering.</code></span>
<span class="codeline" id="line-514"><code>func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {</code></span>
<span class="codeline" id="line-515"><code>	b.lastByte = -1</code></span>
<span class="codeline" id="line-516"><code>	b.lastRuneSize = -1</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>	n, err = b.writeBuf(w)</code></span>
<span class="codeline" id="line-519"><code>	if err != nil {</code></span>
<span class="codeline" id="line-520"><code>		return</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	if r, ok := b.rd.(io.WriterTo); ok {</code></span>
<span class="codeline" id="line-524"><code>		m, err := r.WriteTo(w)</code></span>
<span class="codeline" id="line-525"><code>		n += m</code></span>
<span class="codeline" id="line-526"><code>		return n, err</code></span>
<span class="codeline" id="line-527"><code>	}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	if w, ok := w.(io.ReaderFrom); ok {</code></span>
<span class="codeline" id="line-530"><code>		m, err := w.ReadFrom(b.rd)</code></span>
<span class="codeline" id="line-531"><code>		n += m</code></span>
<span class="codeline" id="line-532"><code>		return n, err</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>	if b.w-b.r &lt; len(b.buf) {</code></span>
<span class="codeline" id="line-536"><code>		b.fill() // buffer not full</code></span>
<span class="codeline" id="line-537"><code>	}</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>	for b.r &lt; b.w {</code></span>
<span class="codeline" id="line-540"><code>		// b.r &lt; b.w =&gt; buffer is not empty</code></span>
<span class="codeline" id="line-541"><code>		m, err := b.writeBuf(w)</code></span>
<span class="codeline" id="line-542"><code>		n += m</code></span>
<span class="codeline" id="line-543"><code>		if err != nil {</code></span>
<span class="codeline" id="line-544"><code>			return n, err</code></span>
<span class="codeline" id="line-545"><code>		}</code></span>
<span class="codeline" id="line-546"><code>		b.fill() // buffer is empty</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>	if b.err == io.EOF {</code></span>
<span class="codeline" id="line-550"><code>		b.err = nil</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>	return n, b.readErr()</code></span>
<span class="codeline" id="line-554"><code>}</code></span>
<span class="codeline" id="line-555"><code></code></span>
<span class="codeline" id="line-556"><code>var errNegativeWrite = errors.New("bufio: writer returned negative count from Write")</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>// writeBuf writes the [Reader]'s buffer to the writer.</code></span>
<span class="codeline" id="line-559"><code>func (b *Reader) writeBuf(w io.Writer) (int64, error) {</code></span>
<span class="codeline" id="line-560"><code>	n, err := w.Write(b.buf[b.r:b.w])</code></span>
<span class="codeline" id="line-561"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-562"><code>		panic(errNegativeWrite)</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code>	b.r += n</code></span>
<span class="codeline" id="line-565"><code>	return int64(n), err</code></span>
<span class="codeline" id="line-566"><code>}</code></span>
<span class="codeline" id="line-567"><code></code></span>
<span class="codeline" id="line-568"><code>// buffered output</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>// Writer implements buffering for an [io.Writer] object.</code></span>
<span class="codeline" id="line-571"><code>// If an error occurs writing to a [Writer], no more data will be</code></span>
<span class="codeline" id="line-572"><code>// accepted and all subsequent writes, and [Writer.Flush], will return the error.</code></span>
<span class="codeline" id="line-573"><code>// After all data has been written, the client should call the</code></span>
<span class="codeline" id="line-574"><code>// [Writer.Flush] method to guarantee all data has been forwarded to</code></span>
<span class="codeline" id="line-575"><code>// the underlying [io.Writer].</code></span>
<span class="codeline" id="line-576"><code>type Writer struct {</code></span>
<span class="codeline" id="line-577"><code>	err error</code></span>
<span class="codeline" id="line-578"><code>	buf []byte</code></span>
<span class="codeline" id="line-579"><code>	n   int</code></span>
<span class="codeline" id="line-580"><code>	wr  io.Writer</code></span>
<span class="codeline" id="line-581"><code>}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>// NewWriterSize returns a new [Writer] whose buffer has at least the specified</code></span>
<span class="codeline" id="line-584"><code>// size. If the argument io.Writer is already a [Writer] with large enough</code></span>
<span class="codeline" id="line-585"><code>// size, it returns the underlying [Writer].</code></span>
<span class="codeline" id="line-586"><code>func NewWriterSize(w io.Writer, size int) *Writer {</code></span>
<span class="codeline" id="line-587"><code>	// Is it already a Writer?</code></span>
<span class="codeline" id="line-588"><code>	b, ok := w.(*Writer)</code></span>
<span class="codeline" id="line-589"><code>	if ok &amp;&amp; len(b.buf) &gt;= size {</code></span>
<span class="codeline" id="line-590"><code>		return b</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>	if size &lt;= 0 {</code></span>
<span class="codeline" id="line-593"><code>		size = defaultBufSize</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code>	return &amp;Writer{</code></span>
<span class="codeline" id="line-596"><code>		buf: make([]byte, size),</code></span>
<span class="codeline" id="line-597"><code>		wr:  w,</code></span>
<span class="codeline" id="line-598"><code>	}</code></span>
<span class="codeline" id="line-599"><code>}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>// NewWriter returns a new [Writer] whose buffer has the default size.</code></span>
<span class="codeline" id="line-602"><code>// If the argument io.Writer is already a [Writer] with large enough buffer size,</code></span>
<span class="codeline" id="line-603"><code>// it returns the underlying [Writer].</code></span>
<span class="codeline" id="line-604"><code>func NewWriter(w io.Writer) *Writer {</code></span>
<span class="codeline" id="line-605"><code>	return NewWriterSize(w, defaultBufSize)</code></span>
<span class="codeline" id="line-606"><code>}</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>// Size returns the size of the underlying buffer in bytes.</code></span>
<span class="codeline" id="line-609"><code>func (b *Writer) Size() int { return len(b.buf) }</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>// Reset discards any unflushed buffered data, clears any error, and</code></span>
<span class="codeline" id="line-612"><code>// resets b to write its output to w.</code></span>
<span class="codeline" id="line-613"><code>// Calling Reset on the zero value of [Writer] initializes the internal buffer</code></span>
<span class="codeline" id="line-614"><code>// to the default size.</code></span>
<span class="codeline" id="line-615"><code>// Calling w.Reset(w) (that is, resetting a [Writer] to itself) does nothing.</code></span>
<span class="codeline" id="line-616"><code>func (b *Writer) Reset(w io.Writer) {</code></span>
<span class="codeline" id="line-617"><code>	// If a Writer w is passed to NewWriter, NewWriter will return w.</code></span>
<span class="codeline" id="line-618"><code>	// Different layers of code may do that, and then later pass w</code></span>
<span class="codeline" id="line-619"><code>	// to Reset. Avoid infinite recursion in that case.</code></span>
<span class="codeline" id="line-620"><code>	if b == w {</code></span>
<span class="codeline" id="line-621"><code>		return</code></span>
<span class="codeline" id="line-622"><code>	}</code></span>
<span class="codeline" id="line-623"><code>	if b.buf == nil {</code></span>
<span class="codeline" id="line-624"><code>		b.buf = make([]byte, defaultBufSize)</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code>	b.err = nil</code></span>
<span class="codeline" id="line-627"><code>	b.n = 0</code></span>
<span class="codeline" id="line-628"><code>	b.wr = w</code></span>
<span class="codeline" id="line-629"><code>}</code></span>
<span class="codeline" id="line-630"><code></code></span>
<span class="codeline" id="line-631"><code>// Flush writes any buffered data to the underlying [io.Writer].</code></span>
<span class="codeline" id="line-632"><code>func (b *Writer) Flush() error {</code></span>
<span class="codeline" id="line-633"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-634"><code>		return b.err</code></span>
<span class="codeline" id="line-635"><code>	}</code></span>
<span class="codeline" id="line-636"><code>	if b.n == 0 {</code></span>
<span class="codeline" id="line-637"><code>		return nil</code></span>
<span class="codeline" id="line-638"><code>	}</code></span>
<span class="codeline" id="line-639"><code>	n, err := b.wr.Write(b.buf[0:b.n])</code></span>
<span class="codeline" id="line-640"><code>	if n &lt; b.n &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-641"><code>		err = io.ErrShortWrite</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code>	if err != nil {</code></span>
<span class="codeline" id="line-644"><code>		if n &gt; 0 &amp;&amp; n &lt; b.n {</code></span>
<span class="codeline" id="line-645"><code>			copy(b.buf[0:b.n-n], b.buf[n:b.n])</code></span>
<span class="codeline" id="line-646"><code>		}</code></span>
<span class="codeline" id="line-647"><code>		b.n -= n</code></span>
<span class="codeline" id="line-648"><code>		b.err = err</code></span>
<span class="codeline" id="line-649"><code>		return err</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code>	b.n = 0</code></span>
<span class="codeline" id="line-652"><code>	return nil</code></span>
<span class="codeline" id="line-653"><code>}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>// Available returns how many bytes are unused in the buffer.</code></span>
<span class="codeline" id="line-656"><code>func (b *Writer) Available() int { return len(b.buf) - b.n }</code></span>
<span class="codeline" id="line-657"><code></code></span>
<span class="codeline" id="line-658"><code>// AvailableBuffer returns an empty buffer with b.Available() capacity.</code></span>
<span class="codeline" id="line-659"><code>// This buffer is intended to be appended to and</code></span>
<span class="codeline" id="line-660"><code>// passed to an immediately succeeding [Writer.Write] call.</code></span>
<span class="codeline" id="line-661"><code>// The buffer is only valid until the next write operation on b.</code></span>
<span class="codeline" id="line-662"><code>func (b *Writer) AvailableBuffer() []byte {</code></span>
<span class="codeline" id="line-663"><code>	return b.buf[b.n:][:0]</code></span>
<span class="codeline" id="line-664"><code>}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>// Buffered returns the number of bytes that have been written into the current buffer.</code></span>
<span class="codeline" id="line-667"><code>func (b *Writer) Buffered() int { return b.n }</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>// Write writes the contents of p into the buffer.</code></span>
<span class="codeline" id="line-670"><code>// It returns the number of bytes written.</code></span>
<span class="codeline" id="line-671"><code>// If nn &lt; len(p), it also returns an error explaining</code></span>
<span class="codeline" id="line-672"><code>// why the write is short.</code></span>
<span class="codeline" id="line-673"><code>func (b *Writer) Write(p []byte) (nn int, err error) {</code></span>
<span class="codeline" id="line-674"><code>	for len(p) &gt; b.Available() &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-675"><code>		var n int</code></span>
<span class="codeline" id="line-676"><code>		if b.Buffered() == 0 {</code></span>
<span class="codeline" id="line-677"><code>			// Large write, empty buffer.</code></span>
<span class="codeline" id="line-678"><code>			// Write directly from p to avoid copy.</code></span>
<span class="codeline" id="line-679"><code>			n, b.err = b.wr.Write(p)</code></span>
<span class="codeline" id="line-680"><code>		} else {</code></span>
<span class="codeline" id="line-681"><code>			n = copy(b.buf[b.n:], p)</code></span>
<span class="codeline" id="line-682"><code>			b.n += n</code></span>
<span class="codeline" id="line-683"><code>			b.Flush()</code></span>
<span class="codeline" id="line-684"><code>		}</code></span>
<span class="codeline" id="line-685"><code>		nn += n</code></span>
<span class="codeline" id="line-686"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-687"><code>	}</code></span>
<span class="codeline" id="line-688"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-689"><code>		return nn, b.err</code></span>
<span class="codeline" id="line-690"><code>	}</code></span>
<span class="codeline" id="line-691"><code>	n := copy(b.buf[b.n:], p)</code></span>
<span class="codeline" id="line-692"><code>	b.n += n</code></span>
<span class="codeline" id="line-693"><code>	nn += n</code></span>
<span class="codeline" id="line-694"><code>	return nn, nil</code></span>
<span class="codeline" id="line-695"><code>}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>// WriteByte writes a single byte.</code></span>
<span class="codeline" id="line-698"><code>func (b *Writer) WriteByte(c byte) error {</code></span>
<span class="codeline" id="line-699"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-700"><code>		return b.err</code></span>
<span class="codeline" id="line-701"><code>	}</code></span>
<span class="codeline" id="line-702"><code>	if b.Available() &lt;= 0 &amp;&amp; b.Flush() != nil {</code></span>
<span class="codeline" id="line-703"><code>		return b.err</code></span>
<span class="codeline" id="line-704"><code>	}</code></span>
<span class="codeline" id="line-705"><code>	b.buf[b.n] = c</code></span>
<span class="codeline" id="line-706"><code>	b.n++</code></span>
<span class="codeline" id="line-707"><code>	return nil</code></span>
<span class="codeline" id="line-708"><code>}</code></span>
<span class="codeline" id="line-709"><code></code></span>
<span class="codeline" id="line-710"><code>// WriteRune writes a single Unicode code point, returning</code></span>
<span class="codeline" id="line-711"><code>// the number of bytes written and any error.</code></span>
<span class="codeline" id="line-712"><code>func (b *Writer) WriteRune(r rune) (size int, err error) {</code></span>
<span class="codeline" id="line-713"><code>	// Compare as uint32 to correctly handle negative runes.</code></span>
<span class="codeline" id="line-714"><code>	if uint32(r) &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-715"><code>		err = b.WriteByte(byte(r))</code></span>
<span class="codeline" id="line-716"><code>		if err != nil {</code></span>
<span class="codeline" id="line-717"><code>			return 0, err</code></span>
<span class="codeline" id="line-718"><code>		}</code></span>
<span class="codeline" id="line-719"><code>		return 1, nil</code></span>
<span class="codeline" id="line-720"><code>	}</code></span>
<span class="codeline" id="line-721"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-722"><code>		return 0, b.err</code></span>
<span class="codeline" id="line-723"><code>	}</code></span>
<span class="codeline" id="line-724"><code>	n := b.Available()</code></span>
<span class="codeline" id="line-725"><code>	if n &lt; utf8.UTFMax {</code></span>
<span class="codeline" id="line-726"><code>		if b.Flush(); b.err != nil {</code></span>
<span class="codeline" id="line-727"><code>			return 0, b.err</code></span>
<span class="codeline" id="line-728"><code>		}</code></span>
<span class="codeline" id="line-729"><code>		n = b.Available()</code></span>
<span class="codeline" id="line-730"><code>		if n &lt; utf8.UTFMax {</code></span>
<span class="codeline" id="line-731"><code>			// Can only happen if buffer is silly small.</code></span>
<span class="codeline" id="line-732"><code>			return b.WriteString(string(r))</code></span>
<span class="codeline" id="line-733"><code>		}</code></span>
<span class="codeline" id="line-734"><code>	}</code></span>
<span class="codeline" id="line-735"><code>	size = utf8.EncodeRune(b.buf[b.n:], r)</code></span>
<span class="codeline" id="line-736"><code>	b.n += size</code></span>
<span class="codeline" id="line-737"><code>	return size, nil</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>// WriteString writes a string.</code></span>
<span class="codeline" id="line-741"><code>// It returns the number of bytes written.</code></span>
<span class="codeline" id="line-742"><code>// If the count is less than len(s), it also returns an error explaining</code></span>
<span class="codeline" id="line-743"><code>// why the write is short.</code></span>
<span class="codeline" id="line-744"><code>func (b *Writer) WriteString(s string) (int, error) {</code></span>
<span class="codeline" id="line-745"><code>	var sw io.StringWriter</code></span>
<span class="codeline" id="line-746"><code>	tryStringWriter := true</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>	nn := 0</code></span>
<span class="codeline" id="line-749"><code>	for len(s) &gt; b.Available() &amp;&amp; b.err == nil {</code></span>
<span class="codeline" id="line-750"><code>		var n int</code></span>
<span class="codeline" id="line-751"><code>		if b.Buffered() == 0 &amp;&amp; sw == nil &amp;&amp; tryStringWriter {</code></span>
<span class="codeline" id="line-752"><code>			// Check at most once whether b.wr is a StringWriter.</code></span>
<span class="codeline" id="line-753"><code>			sw, tryStringWriter = b.wr.(io.StringWriter)</code></span>
<span class="codeline" id="line-754"><code>		}</code></span>
<span class="codeline" id="line-755"><code>		if b.Buffered() == 0 &amp;&amp; tryStringWriter {</code></span>
<span class="codeline" id="line-756"><code>			// Large write, empty buffer, and the underlying writer supports</code></span>
<span class="codeline" id="line-757"><code>			// WriteString: forward the write to the underlying StringWriter.</code></span>
<span class="codeline" id="line-758"><code>			// This avoids an extra copy.</code></span>
<span class="codeline" id="line-759"><code>			n, b.err = sw.WriteString(s)</code></span>
<span class="codeline" id="line-760"><code>		} else {</code></span>
<span class="codeline" id="line-761"><code>			n = copy(b.buf[b.n:], s)</code></span>
<span class="codeline" id="line-762"><code>			b.n += n</code></span>
<span class="codeline" id="line-763"><code>			b.Flush()</code></span>
<span class="codeline" id="line-764"><code>		}</code></span>
<span class="codeline" id="line-765"><code>		nn += n</code></span>
<span class="codeline" id="line-766"><code>		s = s[n:]</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-769"><code>		return nn, b.err</code></span>
<span class="codeline" id="line-770"><code>	}</code></span>
<span class="codeline" id="line-771"><code>	n := copy(b.buf[b.n:], s)</code></span>
<span class="codeline" id="line-772"><code>	b.n += n</code></span>
<span class="codeline" id="line-773"><code>	nn += n</code></span>
<span class="codeline" id="line-774"><code>	return nn, nil</code></span>
<span class="codeline" id="line-775"><code>}</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>// ReadFrom implements [io.ReaderFrom]. If the underlying writer</code></span>
<span class="codeline" id="line-778"><code>// supports the ReadFrom method, this calls the underlying ReadFrom.</code></span>
<span class="codeline" id="line-779"><code>// If there is buffered data and an underlying ReadFrom, this fills</code></span>
<span class="codeline" id="line-780"><code>// the buffer and writes it before calling ReadFrom.</code></span>
<span class="codeline" id="line-781"><code>func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {</code></span>
<span class="codeline" id="line-782"><code>	if b.err != nil {</code></span>
<span class="codeline" id="line-783"><code>		return 0, b.err</code></span>
<span class="codeline" id="line-784"><code>	}</code></span>
<span class="codeline" id="line-785"><code>	readerFrom, readerFromOK := b.wr.(io.ReaderFrom)</code></span>
<span class="codeline" id="line-786"><code>	var m int</code></span>
<span class="codeline" id="line-787"><code>	for {</code></span>
<span class="codeline" id="line-788"><code>		if b.Available() == 0 {</code></span>
<span class="codeline" id="line-789"><code>			if err1 := b.Flush(); err1 != nil {</code></span>
<span class="codeline" id="line-790"><code>				return n, err1</code></span>
<span class="codeline" id="line-791"><code>			}</code></span>
<span class="codeline" id="line-792"><code>		}</code></span>
<span class="codeline" id="line-793"><code>		if readerFromOK &amp;&amp; b.Buffered() == 0 {</code></span>
<span class="codeline" id="line-794"><code>			nn, err := readerFrom.ReadFrom(r)</code></span>
<span class="codeline" id="line-795"><code>			b.err = err</code></span>
<span class="codeline" id="line-796"><code>			n += nn</code></span>
<span class="codeline" id="line-797"><code>			return n, err</code></span>
<span class="codeline" id="line-798"><code>		}</code></span>
<span class="codeline" id="line-799"><code>		nr := 0</code></span>
<span class="codeline" id="line-800"><code>		for nr &lt; maxConsecutiveEmptyReads {</code></span>
<span class="codeline" id="line-801"><code>			m, err = r.Read(b.buf[b.n:])</code></span>
<span class="codeline" id="line-802"><code>			if m != 0 || err != nil {</code></span>
<span class="codeline" id="line-803"><code>				break</code></span>
<span class="codeline" id="line-804"><code>			}</code></span>
<span class="codeline" id="line-805"><code>			nr++</code></span>
<span class="codeline" id="line-806"><code>		}</code></span>
<span class="codeline" id="line-807"><code>		if nr == maxConsecutiveEmptyReads {</code></span>
<span class="codeline" id="line-808"><code>			return n, io.ErrNoProgress</code></span>
<span class="codeline" id="line-809"><code>		}</code></span>
<span class="codeline" id="line-810"><code>		b.n += m</code></span>
<span class="codeline" id="line-811"><code>		n += int64(m)</code></span>
<span class="codeline" id="line-812"><code>		if err != nil {</code></span>
<span class="codeline" id="line-813"><code>			break</code></span>
<span class="codeline" id="line-814"><code>		}</code></span>
<span class="codeline" id="line-815"><code>	}</code></span>
<span class="codeline" id="line-816"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-817"><code>		// If we filled the buffer exactly, flush preemptively.</code></span>
<span class="codeline" id="line-818"><code>		if b.Available() == 0 {</code></span>
<span class="codeline" id="line-819"><code>			err = b.Flush()</code></span>
<span class="codeline" id="line-820"><code>		} else {</code></span>
<span class="codeline" id="line-821"><code>			err = nil</code></span>
<span class="codeline" id="line-822"><code>		}</code></span>
<span class="codeline" id="line-823"><code>	}</code></span>
<span class="codeline" id="line-824"><code>	return n, err</code></span>
<span class="codeline" id="line-825"><code>}</code></span>
<span class="codeline" id="line-826"><code></code></span>
<span class="codeline" id="line-827"><code>// buffered input and output</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>// ReadWriter stores pointers to a [Reader] and a [Writer].</code></span>
<span class="codeline" id="line-830"><code>// It implements [io.ReadWriter].</code></span>
<span class="codeline" id="line-831"><code>type ReadWriter struct {</code></span>
<span class="codeline" id="line-832"><code>	*Reader</code></span>
<span class="codeline" id="line-833"><code>	*Writer</code></span>
<span class="codeline" id="line-834"><code>}</code></span>
<span class="codeline" id="line-835"><code></code></span>
<span class="codeline" id="line-836"><code>// NewReadWriter allocates a new [ReadWriter] that dispatches to r and w.</code></span>
<span class="codeline" id="line-837"><code>func NewReadWriter(r *Reader, w *Writer) *ReadWriter {</code></span>
<span class="codeline" id="line-838"><code>	return &amp;ReadWriter{r, w}</code></span>
<span class="codeline" id="line-839"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>