<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: path.go in package path/filepath</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	path.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/path/filepath.html">path/filepath</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package filepath implements utility routines for manipulating filename paths</code></span>
<span class="codeline" id="line-6"><code>// in a way compatible with the target operating system-defined file paths.</code></span>
<span class="codeline" id="line-7"><code>//</code></span>
<span class="codeline" id="line-8"><code>// The filepath package uses either forward slashes or backslashes,</code></span>
<span class="codeline" id="line-9"><code>// depending on the operating system. To process paths such as URLs</code></span>
<span class="codeline" id="line-10"><code>// that always use forward slashes regardless of the operating</code></span>
<span class="codeline" id="line-11"><code>// system, see the [path] package.</code></span></div><span class="codeline" id="line-12"><code>package filepath</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>import (</code></span>
<span class="codeline" id="line-15"><code>	"errors"</code></span>
<span class="codeline" id="line-16"><code>	"io/fs"</code></span>
<span class="codeline" id="line-17"><code>	"os"</code></span>
<span class="codeline" id="line-18"><code>	"slices"</code></span>
<span class="codeline" id="line-19"><code>	"sort"</code></span>
<span class="codeline" id="line-20"><code>	"strings"</code></span>
<span class="codeline" id="line-21"><code>)</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>// A lazybuf is a lazily constructed path buffer.</code></span>
<span class="codeline" id="line-24"><code>// It supports append, reading previously appended bytes,</code></span>
<span class="codeline" id="line-25"><code>// and retrieving the final string. It does not allocate a buffer</code></span>
<span class="codeline" id="line-26"><code>// to hold the output until that output diverges from s.</code></span>
<span class="codeline" id="line-27"><code>type lazybuf struct {</code></span>
<span class="codeline" id="line-28"><code>	path       string</code></span>
<span class="codeline" id="line-29"><code>	buf        []byte</code></span>
<span class="codeline" id="line-30"><code>	w          int</code></span>
<span class="codeline" id="line-31"><code>	volAndPath string</code></span>
<span class="codeline" id="line-32"><code>	volLen     int</code></span>
<span class="codeline" id="line-33"><code>}</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>func (b *lazybuf) index(i int) byte {</code></span>
<span class="codeline" id="line-36"><code>	if b.buf != nil {</code></span>
<span class="codeline" id="line-37"><code>		return b.buf[i]</code></span>
<span class="codeline" id="line-38"><code>	}</code></span>
<span class="codeline" id="line-39"><code>	return b.path[i]</code></span>
<span class="codeline" id="line-40"><code>}</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>func (b *lazybuf) append(c byte) {</code></span>
<span class="codeline" id="line-43"><code>	if b.buf == nil {</code></span>
<span class="codeline" id="line-44"><code>		if b.w &lt; len(b.path) &amp;&amp; b.path[b.w] == c {</code></span>
<span class="codeline" id="line-45"><code>			b.w++</code></span>
<span class="codeline" id="line-46"><code>			return</code></span>
<span class="codeline" id="line-47"><code>		}</code></span>
<span class="codeline" id="line-48"><code>		b.buf = make([]byte, len(b.path))</code></span>
<span class="codeline" id="line-49"><code>		copy(b.buf, b.path[:b.w])</code></span>
<span class="codeline" id="line-50"><code>	}</code></span>
<span class="codeline" id="line-51"><code>	b.buf[b.w] = c</code></span>
<span class="codeline" id="line-52"><code>	b.w++</code></span>
<span class="codeline" id="line-53"><code>}</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>func (b *lazybuf) prepend(prefix ...byte) {</code></span>
<span class="codeline" id="line-56"><code>	b.buf = slices.Insert(b.buf, 0, prefix...)</code></span>
<span class="codeline" id="line-57"><code>	b.w += len(prefix)</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>func (b *lazybuf) string() string {</code></span>
<span class="codeline" id="line-61"><code>	if b.buf == nil {</code></span>
<span class="codeline" id="line-62"><code>		return b.volAndPath[:b.volLen+b.w]</code></span>
<span class="codeline" id="line-63"><code>	}</code></span>
<span class="codeline" id="line-64"><code>	return b.volAndPath[:b.volLen] + string(b.buf[:b.w])</code></span>
<span class="codeline" id="line-65"><code>}</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>const (</code></span>
<span class="codeline" id="line-68"><code>	Separator     = os.PathSeparator</code></span>
<span class="codeline" id="line-69"><code>	ListSeparator = os.PathListSeparator</code></span>
<span class="codeline" id="line-70"><code>)</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>// Clean returns the shortest path name equivalent to path</code></span>
<span class="codeline" id="line-73"><code>// by purely lexical processing. It applies the following rules</code></span>
<span class="codeline" id="line-74"><code>// iteratively until no further processing can be done:</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>//  1. Replace multiple [Separator] elements with a single one.</code></span>
<span class="codeline" id="line-77"><code>//  2. Eliminate each . path name element (the current directory).</code></span>
<span class="codeline" id="line-78"><code>//  3. Eliminate each inner .. path name element (the parent directory)</code></span>
<span class="codeline" id="line-79"><code>//     along with the non-.. element that precedes it.</code></span>
<span class="codeline" id="line-80"><code>//  4. Eliminate .. elements that begin a rooted path:</code></span>
<span class="codeline" id="line-81"><code>//     that is, replace "/.." by "/" at the beginning of a path,</code></span>
<span class="codeline" id="line-82"><code>//     assuming Separator is '/'.</code></span>
<span class="codeline" id="line-83"><code>//</code></span>
<span class="codeline" id="line-84"><code>// The returned path ends in a slash only if it represents a root directory,</code></span>
<span class="codeline" id="line-85"><code>// such as "/" on Unix or `C:\` on Windows.</code></span>
<span class="codeline" id="line-86"><code>//</code></span>
<span class="codeline" id="line-87"><code>// Finally, any occurrences of slash are replaced by Separator.</code></span>
<span class="codeline" id="line-88"><code>//</code></span>
<span class="codeline" id="line-89"><code>// If the result of this process is an empty string, Clean</code></span>
<span class="codeline" id="line-90"><code>// returns the string ".".</code></span>
<span class="codeline" id="line-91"><code>//</code></span>
<span class="codeline" id="line-92"><code>// On Windows, Clean does not modify the volume name other than to replace</code></span>
<span class="codeline" id="line-93"><code>// occurrences of "/" with `\`.</code></span>
<span class="codeline" id="line-94"><code>// For example, Clean("//host/share/../x") returns `\\host\share\x`.</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// See also Rob Pike, “Lexical File Names in Plan 9 or</code></span>
<span class="codeline" id="line-97"><code>// Getting Dot-Dot Right,”</code></span>
<span class="codeline" id="line-98"><code>// https://9p.io/sys/doc/lexnames.html</code></span>
<span class="codeline" id="line-99"><code>func Clean(path string) string {</code></span>
<span class="codeline" id="line-100"><code>	originalPath := path</code></span>
<span class="codeline" id="line-101"><code>	volLen := volumeNameLen(path)</code></span>
<span class="codeline" id="line-102"><code>	path = path[volLen:]</code></span>
<span class="codeline" id="line-103"><code>	if path == "" {</code></span>
<span class="codeline" id="line-104"><code>		if volLen &gt; 1 &amp;&amp; os.IsPathSeparator(originalPath[0]) &amp;&amp; os.IsPathSeparator(originalPath[1]) {</code></span>
<span class="codeline" id="line-105"><code>			// should be UNC</code></span>
<span class="codeline" id="line-106"><code>			return FromSlash(originalPath)</code></span>
<span class="codeline" id="line-107"><code>		}</code></span>
<span class="codeline" id="line-108"><code>		return originalPath + "."</code></span>
<span class="codeline" id="line-109"><code>	}</code></span>
<span class="codeline" id="line-110"><code>	rooted := os.IsPathSeparator(path[0])</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	// Invariants:</code></span>
<span class="codeline" id="line-113"><code>	//	reading from path; r is index of next byte to process.</code></span>
<span class="codeline" id="line-114"><code>	//	writing to buf; w is index of next byte to write.</code></span>
<span class="codeline" id="line-115"><code>	//	dotdot is index in buf where .. must stop, either because</code></span>
<span class="codeline" id="line-116"><code>	//		it is the leading slash or it is a leading ../../.. prefix.</code></span>
<span class="codeline" id="line-117"><code>	n := len(path)</code></span>
<span class="codeline" id="line-118"><code>	out := lazybuf{path: path, volAndPath: originalPath, volLen: volLen}</code></span>
<span class="codeline" id="line-119"><code>	r, dotdot := 0, 0</code></span>
<span class="codeline" id="line-120"><code>	if rooted {</code></span>
<span class="codeline" id="line-121"><code>		out.append(Separator)</code></span>
<span class="codeline" id="line-122"><code>		r, dotdot = 1, 1</code></span>
<span class="codeline" id="line-123"><code>	}</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>	for r &lt; n {</code></span>
<span class="codeline" id="line-126"><code>		switch {</code></span>
<span class="codeline" id="line-127"><code>		case os.IsPathSeparator(path[r]):</code></span>
<span class="codeline" id="line-128"><code>			// empty path element</code></span>
<span class="codeline" id="line-129"><code>			r++</code></span>
<span class="codeline" id="line-130"><code>		case path[r] == '.' &amp;&amp; (r+1 == n || os.IsPathSeparator(path[r+1])):</code></span>
<span class="codeline" id="line-131"><code>			// . element</code></span>
<span class="codeline" id="line-132"><code>			r++</code></span>
<span class="codeline" id="line-133"><code>		case path[r] == '.' &amp;&amp; path[r+1] == '.' &amp;&amp; (r+2 == n || os.IsPathSeparator(path[r+2])):</code></span>
<span class="codeline" id="line-134"><code>			// .. element: remove to last separator</code></span>
<span class="codeline" id="line-135"><code>			r += 2</code></span>
<span class="codeline" id="line-136"><code>			switch {</code></span>
<span class="codeline" id="line-137"><code>			case out.w &gt; dotdot:</code></span>
<span class="codeline" id="line-138"><code>				// can backtrack</code></span>
<span class="codeline" id="line-139"><code>				out.w--</code></span>
<span class="codeline" id="line-140"><code>				for out.w &gt; dotdot &amp;&amp; !os.IsPathSeparator(out.index(out.w)) {</code></span>
<span class="codeline" id="line-141"><code>					out.w--</code></span>
<span class="codeline" id="line-142"><code>				}</code></span>
<span class="codeline" id="line-143"><code>			case !rooted:</code></span>
<span class="codeline" id="line-144"><code>				// cannot backtrack, but not rooted, so append .. element.</code></span>
<span class="codeline" id="line-145"><code>				if out.w &gt; 0 {</code></span>
<span class="codeline" id="line-146"><code>					out.append(Separator)</code></span>
<span class="codeline" id="line-147"><code>				}</code></span>
<span class="codeline" id="line-148"><code>				out.append('.')</code></span>
<span class="codeline" id="line-149"><code>				out.append('.')</code></span>
<span class="codeline" id="line-150"><code>				dotdot = out.w</code></span>
<span class="codeline" id="line-151"><code>			}</code></span>
<span class="codeline" id="line-152"><code>		default:</code></span>
<span class="codeline" id="line-153"><code>			// real path element.</code></span>
<span class="codeline" id="line-154"><code>			// add slash if needed</code></span>
<span class="codeline" id="line-155"><code>			if rooted &amp;&amp; out.w != 1 || !rooted &amp;&amp; out.w != 0 {</code></span>
<span class="codeline" id="line-156"><code>				out.append(Separator)</code></span>
<span class="codeline" id="line-157"><code>			}</code></span>
<span class="codeline" id="line-158"><code>			// copy element</code></span>
<span class="codeline" id="line-159"><code>			for ; r &lt; n &amp;&amp; !os.IsPathSeparator(path[r]); r++ {</code></span>
<span class="codeline" id="line-160"><code>				out.append(path[r])</code></span>
<span class="codeline" id="line-161"><code>			}</code></span>
<span class="codeline" id="line-162"><code>		}</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>	// Turn empty string into "."</code></span>
<span class="codeline" id="line-166"><code>	if out.w == 0 {</code></span>
<span class="codeline" id="line-167"><code>		out.append('.')</code></span>
<span class="codeline" id="line-168"><code>	}</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>	postClean(&amp;out) // avoid creating absolute paths on Windows</code></span>
<span class="codeline" id="line-171"><code>	return FromSlash(out.string())</code></span>
<span class="codeline" id="line-172"><code>}</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>// IsLocal reports whether path, using lexical analysis only, has all of these properties:</code></span>
<span class="codeline" id="line-175"><code>//</code></span>
<span class="codeline" id="line-176"><code>//   - is within the subtree rooted at the directory in which path is evaluated</code></span>
<span class="codeline" id="line-177"><code>//   - is not an absolute path</code></span>
<span class="codeline" id="line-178"><code>//   - is not empty</code></span>
<span class="codeline" id="line-179"><code>//   - on Windows, is not a reserved name such as "NUL"</code></span>
<span class="codeline" id="line-180"><code>//</code></span>
<span class="codeline" id="line-181"><code>// If IsLocal(path) returns true, then</code></span>
<span class="codeline" id="line-182"><code>// Join(base, path) will always produce a path contained within base and</code></span>
<span class="codeline" id="line-183"><code>// Clean(path) will always produce an unrooted path with no ".." path elements.</code></span>
<span class="codeline" id="line-184"><code>//</code></span>
<span class="codeline" id="line-185"><code>// IsLocal is a purely lexical operation.</code></span>
<span class="codeline" id="line-186"><code>// In particular, it does not account for the effect of any symbolic links</code></span>
<span class="codeline" id="line-187"><code>// that may exist in the filesystem.</code></span>
<span class="codeline" id="line-188"><code>func IsLocal(path string) bool {</code></span>
<span class="codeline" id="line-189"><code>	return isLocal(path)</code></span>
<span class="codeline" id="line-190"><code>}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>func unixIsLocal(path string) bool {</code></span>
<span class="codeline" id="line-193"><code>	if IsAbs(path) || path == "" {</code></span>
<span class="codeline" id="line-194"><code>		return false</code></span>
<span class="codeline" id="line-195"><code>	}</code></span>
<span class="codeline" id="line-196"><code>	hasDots := false</code></span>
<span class="codeline" id="line-197"><code>	for p := path; p != ""; {</code></span>
<span class="codeline" id="line-198"><code>		var part string</code></span>
<span class="codeline" id="line-199"><code>		part, p, _ = strings.Cut(p, "/")</code></span>
<span class="codeline" id="line-200"><code>		if part == "." || part == ".." {</code></span>
<span class="codeline" id="line-201"><code>			hasDots = true</code></span>
<span class="codeline" id="line-202"><code>			break</code></span>
<span class="codeline" id="line-203"><code>		}</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	if hasDots {</code></span>
<span class="codeline" id="line-206"><code>		path = Clean(path)</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code>	if path == ".." || strings.HasPrefix(path, "../") {</code></span>
<span class="codeline" id="line-209"><code>		return false</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>	return true</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// ToSlash returns the result of replacing each separator character</code></span>
<span class="codeline" id="line-215"><code>// in path with a slash ('/') character. Multiple separators are</code></span>
<span class="codeline" id="line-216"><code>// replaced by multiple slashes.</code></span>
<span class="codeline" id="line-217"><code>func ToSlash(path string) string {</code></span>
<span class="codeline" id="line-218"><code>	if Separator == '/' {</code></span>
<span class="codeline" id="line-219"><code>		return path</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code>	return strings.ReplaceAll(path, string(Separator), "/")</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// FromSlash returns the result of replacing each slash ('/') character</code></span>
<span class="codeline" id="line-225"><code>// in path with a separator character. Multiple slashes are replaced</code></span>
<span class="codeline" id="line-226"><code>// by multiple separators.</code></span>
<span class="codeline" id="line-227"><code>func FromSlash(path string) string {</code></span>
<span class="codeline" id="line-228"><code>	if Separator == '/' {</code></span>
<span class="codeline" id="line-229"><code>		return path</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	return strings.ReplaceAll(path, "/", string(Separator))</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// SplitList splits a list of paths joined by the OS-specific [ListSeparator],</code></span>
<span class="codeline" id="line-235"><code>// usually found in PATH or GOPATH environment variables.</code></span>
<span class="codeline" id="line-236"><code>// Unlike strings.Split, SplitList returns an empty slice when passed an empty</code></span>
<span class="codeline" id="line-237"><code>// string.</code></span>
<span class="codeline" id="line-238"><code>func SplitList(path string) []string {</code></span>
<span class="codeline" id="line-239"><code>	return splitList(path)</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>// Split splits path immediately following the final [Separator],</code></span>
<span class="codeline" id="line-243"><code>// separating it into a directory and file name component.</code></span>
<span class="codeline" id="line-244"><code>// If there is no Separator in path, Split returns an empty dir</code></span>
<span class="codeline" id="line-245"><code>// and file set to path.</code></span>
<span class="codeline" id="line-246"><code>// The returned values have the property that path = dir+file.</code></span>
<span class="codeline" id="line-247"><code>func Split(path string) (dir, file string) {</code></span>
<span class="codeline" id="line-248"><code>	vol := VolumeName(path)</code></span>
<span class="codeline" id="line-249"><code>	i := len(path) - 1</code></span>
<span class="codeline" id="line-250"><code>	for i &gt;= len(vol) &amp;&amp; !os.IsPathSeparator(path[i]) {</code></span>
<span class="codeline" id="line-251"><code>		i--</code></span>
<span class="codeline" id="line-252"><code>	}</code></span>
<span class="codeline" id="line-253"><code>	return path[:i+1], path[i+1:]</code></span>
<span class="codeline" id="line-254"><code>}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// Join joins any number of path elements into a single path,</code></span>
<span class="codeline" id="line-257"><code>// separating them with an OS specific [Separator]. Empty elements</code></span>
<span class="codeline" id="line-258"><code>// are ignored. The result is Cleaned. However, if the argument</code></span>
<span class="codeline" id="line-259"><code>// list is empty or all its elements are empty, Join returns</code></span>
<span class="codeline" id="line-260"><code>// an empty string.</code></span>
<span class="codeline" id="line-261"><code>// On Windows, the result will only be a UNC path if the first</code></span>
<span class="codeline" id="line-262"><code>// non-empty element is a UNC path.</code></span>
<span class="codeline" id="line-263"><code>func Join(elem ...string) string {</code></span>
<span class="codeline" id="line-264"><code>	return join(elem)</code></span>
<span class="codeline" id="line-265"><code>}</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>// Ext returns the file name extension used by path.</code></span>
<span class="codeline" id="line-268"><code>// The extension is the suffix beginning at the final dot</code></span>
<span class="codeline" id="line-269"><code>// in the final element of path; it is empty if there is</code></span>
<span class="codeline" id="line-270"><code>// no dot.</code></span>
<span class="codeline" id="line-271"><code>func Ext(path string) string {</code></span>
<span class="codeline" id="line-272"><code>	for i := len(path) - 1; i &gt;= 0 &amp;&amp; !os.IsPathSeparator(path[i]); i-- {</code></span>
<span class="codeline" id="line-273"><code>		if path[i] == '.' {</code></span>
<span class="codeline" id="line-274"><code>			return path[i:]</code></span>
<span class="codeline" id="line-275"><code>		}</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code>	return ""</code></span>
<span class="codeline" id="line-278"><code>}</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>// EvalSymlinks returns the path name after the evaluation of any symbolic</code></span>
<span class="codeline" id="line-281"><code>// links.</code></span>
<span class="codeline" id="line-282"><code>// If path is relative the result will be relative to the current directory,</code></span>
<span class="codeline" id="line-283"><code>// unless one of the components is an absolute symbolic link.</code></span>
<span class="codeline" id="line-284"><code>// EvalSymlinks calls [Clean] on the result.</code></span>
<span class="codeline" id="line-285"><code>func EvalSymlinks(path string) (string, error) {</code></span>
<span class="codeline" id="line-286"><code>	return evalSymlinks(path)</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>// Abs returns an absolute representation of path.</code></span>
<span class="codeline" id="line-290"><code>// If the path is not absolute it will be joined with the current</code></span>
<span class="codeline" id="line-291"><code>// working directory to turn it into an absolute path. The absolute</code></span>
<span class="codeline" id="line-292"><code>// path name for a given file is not guaranteed to be unique.</code></span>
<span class="codeline" id="line-293"><code>// Abs calls [Clean] on the result.</code></span>
<span class="codeline" id="line-294"><code>func Abs(path string) (string, error) {</code></span>
<span class="codeline" id="line-295"><code>	return abs(path)</code></span>
<span class="codeline" id="line-296"><code>}</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>func unixAbs(path string) (string, error) {</code></span>
<span class="codeline" id="line-299"><code>	if IsAbs(path) {</code></span>
<span class="codeline" id="line-300"><code>		return Clean(path), nil</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code>	wd, err := os.Getwd()</code></span>
<span class="codeline" id="line-303"><code>	if err != nil {</code></span>
<span class="codeline" id="line-304"><code>		return "", err</code></span>
<span class="codeline" id="line-305"><code>	}</code></span>
<span class="codeline" id="line-306"><code>	return Join(wd, path), nil</code></span>
<span class="codeline" id="line-307"><code>}</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>// Rel returns a relative path that is lexically equivalent to targpath when</code></span>
<span class="codeline" id="line-310"><code>// joined to basepath with an intervening separator. That is,</code></span>
<span class="codeline" id="line-311"><code>// [Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself.</code></span>
<span class="codeline" id="line-312"><code>// On success, the returned path will always be relative to basepath,</code></span>
<span class="codeline" id="line-313"><code>// even if basepath and targpath share no elements.</code></span>
<span class="codeline" id="line-314"><code>// An error is returned if targpath can't be made relative to basepath or if</code></span>
<span class="codeline" id="line-315"><code>// knowing the current working directory would be necessary to compute it.</code></span>
<span class="codeline" id="line-316"><code>// Rel calls [Clean] on the result.</code></span>
<span class="codeline" id="line-317"><code>func Rel(basepath, targpath string) (string, error) {</code></span>
<span class="codeline" id="line-318"><code>	baseVol := VolumeName(basepath)</code></span>
<span class="codeline" id="line-319"><code>	targVol := VolumeName(targpath)</code></span>
<span class="codeline" id="line-320"><code>	base := Clean(basepath)</code></span>
<span class="codeline" id="line-321"><code>	targ := Clean(targpath)</code></span>
<span class="codeline" id="line-322"><code>	if sameWord(targ, base) {</code></span>
<span class="codeline" id="line-323"><code>		return ".", nil</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code>	base = base[len(baseVol):]</code></span>
<span class="codeline" id="line-326"><code>	targ = targ[len(targVol):]</code></span>
<span class="codeline" id="line-327"><code>	if base == "." {</code></span>
<span class="codeline" id="line-328"><code>		base = ""</code></span>
<span class="codeline" id="line-329"><code>	} else if base == "" &amp;&amp; volumeNameLen(baseVol) &gt; 2 /* isUNC */ {</code></span>
<span class="codeline" id="line-330"><code>		// Treat any targetpath matching `\\host\share` basepath as absolute path.</code></span>
<span class="codeline" id="line-331"><code>		base = string(Separator)</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>	// Can't use IsAbs - `\a` and `a` are both relative in Windows.</code></span>
<span class="codeline" id="line-335"><code>	baseSlashed := len(base) &gt; 0 &amp;&amp; base[0] == Separator</code></span>
<span class="codeline" id="line-336"><code>	targSlashed := len(targ) &gt; 0 &amp;&amp; targ[0] == Separator</code></span>
<span class="codeline" id="line-337"><code>	if baseSlashed != targSlashed || !sameWord(baseVol, targVol) {</code></span>
<span class="codeline" id="line-338"><code>		return "", errors.New("Rel: can't make " + targpath + " relative to " + basepath)</code></span>
<span class="codeline" id="line-339"><code>	}</code></span>
<span class="codeline" id="line-340"><code>	// Position base[b0:bi] and targ[t0:ti] at the first differing elements.</code></span>
<span class="codeline" id="line-341"><code>	bl := len(base)</code></span>
<span class="codeline" id="line-342"><code>	tl := len(targ)</code></span>
<span class="codeline" id="line-343"><code>	var b0, bi, t0, ti int</code></span>
<span class="codeline" id="line-344"><code>	for {</code></span>
<span class="codeline" id="line-345"><code>		for bi &lt; bl &amp;&amp; base[bi] != Separator {</code></span>
<span class="codeline" id="line-346"><code>			bi++</code></span>
<span class="codeline" id="line-347"><code>		}</code></span>
<span class="codeline" id="line-348"><code>		for ti &lt; tl &amp;&amp; targ[ti] != Separator {</code></span>
<span class="codeline" id="line-349"><code>			ti++</code></span>
<span class="codeline" id="line-350"><code>		}</code></span>
<span class="codeline" id="line-351"><code>		if !sameWord(targ[t0:ti], base[b0:bi]) {</code></span>
<span class="codeline" id="line-352"><code>			break</code></span>
<span class="codeline" id="line-353"><code>		}</code></span>
<span class="codeline" id="line-354"><code>		if bi &lt; bl {</code></span>
<span class="codeline" id="line-355"><code>			bi++</code></span>
<span class="codeline" id="line-356"><code>		}</code></span>
<span class="codeline" id="line-357"><code>		if ti &lt; tl {</code></span>
<span class="codeline" id="line-358"><code>			ti++</code></span>
<span class="codeline" id="line-359"><code>		}</code></span>
<span class="codeline" id="line-360"><code>		b0 = bi</code></span>
<span class="codeline" id="line-361"><code>		t0 = ti</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>	if base[b0:bi] == ".." {</code></span>
<span class="codeline" id="line-364"><code>		return "", errors.New("Rel: can't make " + targpath + " relative to " + basepath)</code></span>
<span class="codeline" id="line-365"><code>	}</code></span>
<span class="codeline" id="line-366"><code>	if b0 != bl {</code></span>
<span class="codeline" id="line-367"><code>		// Base elements left. Must go up before going down.</code></span>
<span class="codeline" id="line-368"><code>		seps := strings.Count(base[b0:bl], string(Separator))</code></span>
<span class="codeline" id="line-369"><code>		size := 2 + seps*3</code></span>
<span class="codeline" id="line-370"><code>		if tl != t0 {</code></span>
<span class="codeline" id="line-371"><code>			size += 1 + tl - t0</code></span>
<span class="codeline" id="line-372"><code>		}</code></span>
<span class="codeline" id="line-373"><code>		buf := make([]byte, size)</code></span>
<span class="codeline" id="line-374"><code>		n := copy(buf, "..")</code></span>
<span class="codeline" id="line-375"><code>		for i := 0; i &lt; seps; i++ {</code></span>
<span class="codeline" id="line-376"><code>			buf[n] = Separator</code></span>
<span class="codeline" id="line-377"><code>			copy(buf[n+1:], "..")</code></span>
<span class="codeline" id="line-378"><code>			n += 3</code></span>
<span class="codeline" id="line-379"><code>		}</code></span>
<span class="codeline" id="line-380"><code>		if t0 != tl {</code></span>
<span class="codeline" id="line-381"><code>			buf[n] = Separator</code></span>
<span class="codeline" id="line-382"><code>			copy(buf[n+1:], targ[t0:])</code></span>
<span class="codeline" id="line-383"><code>		}</code></span>
<span class="codeline" id="line-384"><code>		return string(buf), nil</code></span>
<span class="codeline" id="line-385"><code>	}</code></span>
<span class="codeline" id="line-386"><code>	return targ[t0:], nil</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>// SkipDir is used as a return value from [WalkFunc] to indicate that</code></span>
<span class="codeline" id="line-390"><code>// the directory named in the call is to be skipped. It is not returned</code></span>
<span class="codeline" id="line-391"><code>// as an error by any function.</code></span>
<span class="codeline" id="line-392"><code>var SkipDir error = fs.SkipDir</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>// SkipAll is used as a return value from [WalkFunc] to indicate that</code></span>
<span class="codeline" id="line-395"><code>// all remaining files and directories are to be skipped. It is not returned</code></span>
<span class="codeline" id="line-396"><code>// as an error by any function.</code></span>
<span class="codeline" id="line-397"><code>var SkipAll error = fs.SkipAll</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>// WalkFunc is the type of the function called by [Walk] to visit each</code></span>
<span class="codeline" id="line-400"><code>// file or directory.</code></span>
<span class="codeline" id="line-401"><code>//</code></span>
<span class="codeline" id="line-402"><code>// The path argument contains the argument to Walk as a prefix.</code></span>
<span class="codeline" id="line-403"><code>// That is, if Walk is called with root argument "dir" and finds a file</code></span>
<span class="codeline" id="line-404"><code>// named "a" in that directory, the walk function will be called with</code></span>
<span class="codeline" id="line-405"><code>// argument "dir/a".</code></span>
<span class="codeline" id="line-406"><code>//</code></span>
<span class="codeline" id="line-407"><code>// The directory and file are joined with Join, which may clean the</code></span>
<span class="codeline" id="line-408"><code>// directory name: if Walk is called with the root argument "x/../dir"</code></span>
<span class="codeline" id="line-409"><code>// and finds a file named "a" in that directory, the walk function will</code></span>
<span class="codeline" id="line-410"><code>// be called with argument "dir/a", not "x/../dir/a".</code></span>
<span class="codeline" id="line-411"><code>//</code></span>
<span class="codeline" id="line-412"><code>// The info argument is the fs.FileInfo for the named path.</code></span>
<span class="codeline" id="line-413"><code>//</code></span>
<span class="codeline" id="line-414"><code>// The error result returned by the function controls how Walk continues.</code></span>
<span class="codeline" id="line-415"><code>// If the function returns the special value [SkipDir], Walk skips the</code></span>
<span class="codeline" id="line-416"><code>// current directory (path if info.IsDir() is true, otherwise path's</code></span>
<span class="codeline" id="line-417"><code>// parent directory). If the function returns the special value [SkipAll],</code></span>
<span class="codeline" id="line-418"><code>// Walk skips all remaining files and directories. Otherwise, if the function</code></span>
<span class="codeline" id="line-419"><code>// returns a non-nil error, Walk stops entirely and returns that error.</code></span>
<span class="codeline" id="line-420"><code>//</code></span>
<span class="codeline" id="line-421"><code>// The err argument reports an error related to path, signaling that Walk</code></span>
<span class="codeline" id="line-422"><code>// will not walk into that directory. The function can decide how to</code></span>
<span class="codeline" id="line-423"><code>// handle that error; as described earlier, returning the error will</code></span>
<span class="codeline" id="line-424"><code>// cause Walk to stop walking the entire tree.</code></span>
<span class="codeline" id="line-425"><code>//</code></span>
<span class="codeline" id="line-426"><code>// Walk calls the function with a non-nil err argument in two cases.</code></span>
<span class="codeline" id="line-427"><code>//</code></span>
<span class="codeline" id="line-428"><code>// First, if an [os.Lstat] on the root directory or any directory or file</code></span>
<span class="codeline" id="line-429"><code>// in the tree fails, Walk calls the function with path set to that</code></span>
<span class="codeline" id="line-430"><code>// directory or file's path, info set to nil, and err set to the error</code></span>
<span class="codeline" id="line-431"><code>// from os.Lstat.</code></span>
<span class="codeline" id="line-432"><code>//</code></span>
<span class="codeline" id="line-433"><code>// Second, if a directory's Readdirnames method fails, Walk calls the</code></span>
<span class="codeline" id="line-434"><code>// function with path set to the directory's path, info, set to an</code></span>
<span class="codeline" id="line-435"><code>// [fs.FileInfo] describing the directory, and err set to the error from</code></span>
<span class="codeline" id="line-436"><code>// Readdirnames.</code></span>
<span class="codeline" id="line-437"><code>type WalkFunc func(path string, info fs.FileInfo, err error) error</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>var lstat = os.Lstat // for testing</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>// walkDir recursively descends path, calling walkDirFn.</code></span>
<span class="codeline" id="line-442"><code>func walkDir(path string, d fs.DirEntry, walkDirFn fs.WalkDirFunc) error {</code></span>
<span class="codeline" id="line-443"><code>	if err := walkDirFn(path, d, nil); err != nil || !d.IsDir() {</code></span>
<span class="codeline" id="line-444"><code>		if err == SkipDir &amp;&amp; d.IsDir() {</code></span>
<span class="codeline" id="line-445"><code>			// Successfully skipped directory.</code></span>
<span class="codeline" id="line-446"><code>			err = nil</code></span>
<span class="codeline" id="line-447"><code>		}</code></span>
<span class="codeline" id="line-448"><code>		return err</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>	dirs, err := os.ReadDir(path)</code></span>
<span class="codeline" id="line-452"><code>	if err != nil {</code></span>
<span class="codeline" id="line-453"><code>		// Second call, to report ReadDir error.</code></span>
<span class="codeline" id="line-454"><code>		err = walkDirFn(path, d, err)</code></span>
<span class="codeline" id="line-455"><code>		if err != nil {</code></span>
<span class="codeline" id="line-456"><code>			if err == SkipDir &amp;&amp; d.IsDir() {</code></span>
<span class="codeline" id="line-457"><code>				err = nil</code></span>
<span class="codeline" id="line-458"><code>			}</code></span>
<span class="codeline" id="line-459"><code>			return err</code></span>
<span class="codeline" id="line-460"><code>		}</code></span>
<span class="codeline" id="line-461"><code>	}</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>	for _, d1 := range dirs {</code></span>
<span class="codeline" id="line-464"><code>		path1 := Join(path, d1.Name())</code></span>
<span class="codeline" id="line-465"><code>		if err := walkDir(path1, d1, walkDirFn); err != nil {</code></span>
<span class="codeline" id="line-466"><code>			if err == SkipDir {</code></span>
<span class="codeline" id="line-467"><code>				break</code></span>
<span class="codeline" id="line-468"><code>			}</code></span>
<span class="codeline" id="line-469"><code>			return err</code></span>
<span class="codeline" id="line-470"><code>		}</code></span>
<span class="codeline" id="line-471"><code>	}</code></span>
<span class="codeline" id="line-472"><code>	return nil</code></span>
<span class="codeline" id="line-473"><code>}</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>// walk recursively descends path, calling walkFn.</code></span>
<span class="codeline" id="line-476"><code>func walk(path string, info fs.FileInfo, walkFn WalkFunc) error {</code></span>
<span class="codeline" id="line-477"><code>	if !info.IsDir() {</code></span>
<span class="codeline" id="line-478"><code>		return walkFn(path, info, nil)</code></span>
<span class="codeline" id="line-479"><code>	}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>	names, err := readDirNames(path)</code></span>
<span class="codeline" id="line-482"><code>	err1 := walkFn(path, info, err)</code></span>
<span class="codeline" id="line-483"><code>	// If err != nil, walk can't walk into this directory.</code></span>
<span class="codeline" id="line-484"><code>	// err1 != nil means walkFn want walk to skip this directory or stop walking.</code></span>
<span class="codeline" id="line-485"><code>	// Therefore, if one of err and err1 isn't nil, walk will return.</code></span>
<span class="codeline" id="line-486"><code>	if err != nil || err1 != nil {</code></span>
<span class="codeline" id="line-487"><code>		// The caller's behavior is controlled by the return value, which is decided</code></span>
<span class="codeline" id="line-488"><code>		// by walkFn. walkFn may ignore err and return nil.</code></span>
<span class="codeline" id="line-489"><code>		// If walkFn returns SkipDir or SkipAll, it will be handled by the caller.</code></span>
<span class="codeline" id="line-490"><code>		// So walk should return whatever walkFn returns.</code></span>
<span class="codeline" id="line-491"><code>		return err1</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	for _, name := range names {</code></span>
<span class="codeline" id="line-495"><code>		filename := Join(path, name)</code></span>
<span class="codeline" id="line-496"><code>		fileInfo, err := lstat(filename)</code></span>
<span class="codeline" id="line-497"><code>		if err != nil {</code></span>
<span class="codeline" id="line-498"><code>			if err := walkFn(filename, fileInfo, err); err != nil &amp;&amp; err != SkipDir {</code></span>
<span class="codeline" id="line-499"><code>				return err</code></span>
<span class="codeline" id="line-500"><code>			}</code></span>
<span class="codeline" id="line-501"><code>		} else {</code></span>
<span class="codeline" id="line-502"><code>			err = walk(filename, fileInfo, walkFn)</code></span>
<span class="codeline" id="line-503"><code>			if err != nil {</code></span>
<span class="codeline" id="line-504"><code>				if !fileInfo.IsDir() || err != SkipDir {</code></span>
<span class="codeline" id="line-505"><code>					return err</code></span>
<span class="codeline" id="line-506"><code>				}</code></span>
<span class="codeline" id="line-507"><code>			}</code></span>
<span class="codeline" id="line-508"><code>		}</code></span>
<span class="codeline" id="line-509"><code>	}</code></span>
<span class="codeline" id="line-510"><code>	return nil</code></span>
<span class="codeline" id="line-511"><code>}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>// WalkDir walks the file tree rooted at root, calling fn for each file or</code></span>
<span class="codeline" id="line-514"><code>// directory in the tree, including root.</code></span>
<span class="codeline" id="line-515"><code>//</code></span>
<span class="codeline" id="line-516"><code>// All errors that arise visiting files and directories are filtered by fn:</code></span>
<span class="codeline" id="line-517"><code>// see the [fs.WalkDirFunc] documentation for details.</code></span>
<span class="codeline" id="line-518"><code>//</code></span>
<span class="codeline" id="line-519"><code>// The files are walked in lexical order, which makes the output deterministic</code></span>
<span class="codeline" id="line-520"><code>// but requires WalkDir to read an entire directory into memory before proceeding</code></span>
<span class="codeline" id="line-521"><code>// to walk that directory.</code></span>
<span class="codeline" id="line-522"><code>//</code></span>
<span class="codeline" id="line-523"><code>// WalkDir does not follow symbolic links.</code></span>
<span class="codeline" id="line-524"><code>//</code></span>
<span class="codeline" id="line-525"><code>// WalkDir calls fn with paths that use the separator character appropriate</code></span>
<span class="codeline" id="line-526"><code>// for the operating system. This is unlike [io/fs.WalkDir], which always</code></span>
<span class="codeline" id="line-527"><code>// uses slash separated paths.</code></span>
<span class="codeline" id="line-528"><code>func WalkDir(root string, fn fs.WalkDirFunc) error {</code></span>
<span class="codeline" id="line-529"><code>	info, err := os.Lstat(root)</code></span>
<span class="codeline" id="line-530"><code>	if err != nil {</code></span>
<span class="codeline" id="line-531"><code>		err = fn(root, nil, err)</code></span>
<span class="codeline" id="line-532"><code>	} else {</code></span>
<span class="codeline" id="line-533"><code>		err = walkDir(root, fs.FileInfoToDirEntry(info), fn)</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>	if err == SkipDir || err == SkipAll {</code></span>
<span class="codeline" id="line-536"><code>		return nil</code></span>
<span class="codeline" id="line-537"><code>	}</code></span>
<span class="codeline" id="line-538"><code>	return err</code></span>
<span class="codeline" id="line-539"><code>}</code></span>
<span class="codeline" id="line-540"><code></code></span>
<span class="codeline" id="line-541"><code>// Walk walks the file tree rooted at root, calling fn for each file or</code></span>
<span class="codeline" id="line-542"><code>// directory in the tree, including root.</code></span>
<span class="codeline" id="line-543"><code>//</code></span>
<span class="codeline" id="line-544"><code>// All errors that arise visiting files and directories are filtered by fn:</code></span>
<span class="codeline" id="line-545"><code>// see the [WalkFunc] documentation for details.</code></span>
<span class="codeline" id="line-546"><code>//</code></span>
<span class="codeline" id="line-547"><code>// The files are walked in lexical order, which makes the output deterministic</code></span>
<span class="codeline" id="line-548"><code>// but requires Walk to read an entire directory into memory before proceeding</code></span>
<span class="codeline" id="line-549"><code>// to walk that directory.</code></span>
<span class="codeline" id="line-550"><code>//</code></span>
<span class="codeline" id="line-551"><code>// Walk does not follow symbolic links.</code></span>
<span class="codeline" id="line-552"><code>//</code></span>
<span class="codeline" id="line-553"><code>// Walk is less efficient than [WalkDir], introduced in Go 1.16,</code></span>
<span class="codeline" id="line-554"><code>// which avoids calling os.Lstat on every visited file or directory.</code></span>
<span class="codeline" id="line-555"><code>func Walk(root string, fn WalkFunc) error {</code></span>
<span class="codeline" id="line-556"><code>	info, err := os.Lstat(root)</code></span>
<span class="codeline" id="line-557"><code>	if err != nil {</code></span>
<span class="codeline" id="line-558"><code>		err = fn(root, nil, err)</code></span>
<span class="codeline" id="line-559"><code>	} else {</code></span>
<span class="codeline" id="line-560"><code>		err = walk(root, info, fn)</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code>	if err == SkipDir || err == SkipAll {</code></span>
<span class="codeline" id="line-563"><code>		return nil</code></span>
<span class="codeline" id="line-564"><code>	}</code></span>
<span class="codeline" id="line-565"><code>	return err</code></span>
<span class="codeline" id="line-566"><code>}</code></span>
<span class="codeline" id="line-567"><code></code></span>
<span class="codeline" id="line-568"><code>// readDirNames reads the directory named by dirname and returns</code></span>
<span class="codeline" id="line-569"><code>// a sorted list of directory entry names.</code></span>
<span class="codeline" id="line-570"><code>func readDirNames(dirname string) ([]string, error) {</code></span>
<span class="codeline" id="line-571"><code>	f, err := os.Open(dirname)</code></span>
<span class="codeline" id="line-572"><code>	if err != nil {</code></span>
<span class="codeline" id="line-573"><code>		return nil, err</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	names, err := f.Readdirnames(-1)</code></span>
<span class="codeline" id="line-576"><code>	f.Close()</code></span>
<span class="codeline" id="line-577"><code>	if err != nil {</code></span>
<span class="codeline" id="line-578"><code>		return nil, err</code></span>
<span class="codeline" id="line-579"><code>	}</code></span>
<span class="codeline" id="line-580"><code>	sort.Strings(names)</code></span>
<span class="codeline" id="line-581"><code>	return names, nil</code></span>
<span class="codeline" id="line-582"><code>}</code></span>
<span class="codeline" id="line-583"><code></code></span>
<span class="codeline" id="line-584"><code>// Base returns the last element of path.</code></span>
<span class="codeline" id="line-585"><code>// Trailing path separators are removed before extracting the last element.</code></span>
<span class="codeline" id="line-586"><code>// If the path is empty, Base returns ".".</code></span>
<span class="codeline" id="line-587"><code>// If the path consists entirely of separators, Base returns a single separator.</code></span>
<span class="codeline" id="line-588"><code>func Base(path string) string {</code></span>
<span class="codeline" id="line-589"><code>	if path == "" {</code></span>
<span class="codeline" id="line-590"><code>		return "."</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>	// Strip trailing slashes.</code></span>
<span class="codeline" id="line-593"><code>	for len(path) &gt; 0 &amp;&amp; os.IsPathSeparator(path[len(path)-1]) {</code></span>
<span class="codeline" id="line-594"><code>		path = path[0 : len(path)-1]</code></span>
<span class="codeline" id="line-595"><code>	}</code></span>
<span class="codeline" id="line-596"><code>	// Throw away volume name</code></span>
<span class="codeline" id="line-597"><code>	path = path[len(VolumeName(path)):]</code></span>
<span class="codeline" id="line-598"><code>	// Find the last element</code></span>
<span class="codeline" id="line-599"><code>	i := len(path) - 1</code></span>
<span class="codeline" id="line-600"><code>	for i &gt;= 0 &amp;&amp; !os.IsPathSeparator(path[i]) {</code></span>
<span class="codeline" id="line-601"><code>		i--</code></span>
<span class="codeline" id="line-602"><code>	}</code></span>
<span class="codeline" id="line-603"><code>	if i &gt;= 0 {</code></span>
<span class="codeline" id="line-604"><code>		path = path[i+1:]</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code>	// If empty now, it had only slashes.</code></span>
<span class="codeline" id="line-607"><code>	if path == "" {</code></span>
<span class="codeline" id="line-608"><code>		return string(Separator)</code></span>
<span class="codeline" id="line-609"><code>	}</code></span>
<span class="codeline" id="line-610"><code>	return path</code></span>
<span class="codeline" id="line-611"><code>}</code></span>
<span class="codeline" id="line-612"><code></code></span>
<span class="codeline" id="line-613"><code>// Dir returns all but the last element of path, typically the path's directory.</code></span>
<span class="codeline" id="line-614"><code>// After dropping the final element, Dir calls [Clean] on the path and trailing</code></span>
<span class="codeline" id="line-615"><code>// slashes are removed.</code></span>
<span class="codeline" id="line-616"><code>// If the path is empty, Dir returns ".".</code></span>
<span class="codeline" id="line-617"><code>// If the path consists entirely of separators, Dir returns a single separator.</code></span>
<span class="codeline" id="line-618"><code>// The returned path does not end in a separator unless it is the root directory.</code></span>
<span class="codeline" id="line-619"><code>func Dir(path string) string {</code></span>
<span class="codeline" id="line-620"><code>	vol := VolumeName(path)</code></span>
<span class="codeline" id="line-621"><code>	i := len(path) - 1</code></span>
<span class="codeline" id="line-622"><code>	for i &gt;= len(vol) &amp;&amp; !os.IsPathSeparator(path[i]) {</code></span>
<span class="codeline" id="line-623"><code>		i--</code></span>
<span class="codeline" id="line-624"><code>	}</code></span>
<span class="codeline" id="line-625"><code>	dir := Clean(path[len(vol) : i+1])</code></span>
<span class="codeline" id="line-626"><code>	if dir == "." &amp;&amp; len(vol) &gt; 2 {</code></span>
<span class="codeline" id="line-627"><code>		// must be UNC</code></span>
<span class="codeline" id="line-628"><code>		return vol</code></span>
<span class="codeline" id="line-629"><code>	}</code></span>
<span class="codeline" id="line-630"><code>	return vol + dir</code></span>
<span class="codeline" id="line-631"><code>}</code></span>
<span class="codeline" id="line-632"><code></code></span>
<span class="codeline" id="line-633"><code>// VolumeName returns leading volume name.</code></span>
<span class="codeline" id="line-634"><code>// Given "C:\foo\bar" it returns "C:" on Windows.</code></span>
<span class="codeline" id="line-635"><code>// Given "\\host\share\foo" it returns "\\host\share".</code></span>
<span class="codeline" id="line-636"><code>// On other platforms it returns "".</code></span>
<span class="codeline" id="line-637"><code>func VolumeName(path string) string {</code></span>
<span class="codeline" id="line-638"><code>	return FromSlash(path[:volumeNameLen(path)])</code></span>
<span class="codeline" id="line-639"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>