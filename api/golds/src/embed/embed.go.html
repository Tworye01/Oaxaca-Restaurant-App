<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: embed.go in package embed</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	embed.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/embed.html">embed</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2020 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package embed provides access to files embedded in the running Go program.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// Go source files that import "embed" can use the //go:embed directive</code></span>
<span class="codeline" id="line-8"><code>// to initialize a variable of type string, []byte, or [FS] with the contents of</code></span>
<span class="codeline" id="line-9"><code>// files read from the package directory or subdirectories at compile time.</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// For example, here are three ways to embed a file named hello.txt</code></span>
<span class="codeline" id="line-12"><code>// and then print its contents at run time.</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// Embedding one file into a string:</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>//	import _ "embed"</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>//	//go:embed hello.txt</code></span>
<span class="codeline" id="line-19"><code>//	var s string</code></span>
<span class="codeline" id="line-20"><code>//	print(s)</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// Embedding one file into a slice of bytes:</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>//	import _ "embed"</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>//	//go:embed hello.txt</code></span>
<span class="codeline" id="line-27"><code>//	var b []byte</code></span>
<span class="codeline" id="line-28"><code>//	print(string(b))</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// Embedded one or more files into a file system:</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>//	import "embed"</code></span>
<span class="codeline" id="line-33"><code>//</code></span>
<span class="codeline" id="line-34"><code>//	//go:embed hello.txt</code></span>
<span class="codeline" id="line-35"><code>//	var f embed.FS</code></span>
<span class="codeline" id="line-36"><code>//	data, _ := f.ReadFile("hello.txt")</code></span>
<span class="codeline" id="line-37"><code>//	print(string(data))</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// # Directives</code></span>
<span class="codeline" id="line-40"><code>//</code></span>
<span class="codeline" id="line-41"><code>// A //go:embed directive above a variable declaration specifies which files to embed,</code></span>
<span class="codeline" id="line-42"><code>// using one or more path.Match patterns.</code></span>
<span class="codeline" id="line-43"><code>//</code></span>
<span class="codeline" id="line-44"><code>// The directive must immediately precede a line containing the declaration of a single variable.</code></span>
<span class="codeline" id="line-45"><code>// Only blank lines and ‘//’ line comments are permitted between the directive and the declaration.</code></span>
<span class="codeline" id="line-46"><code>//</code></span>
<span class="codeline" id="line-47"><code>// The type of the variable must be a string type, or a slice of a byte type,</code></span>
<span class="codeline" id="line-48"><code>// or [FS] (or an alias of [FS]).</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>// For example:</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>//	package server</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>//	import "embed"</code></span>
<span class="codeline" id="line-55"><code>//</code></span>
<span class="codeline" id="line-56"><code>//	// content holds our static web server content.</code></span>
<span class="codeline" id="line-57"><code>//	//go:embed image/* template/*</code></span>
<span class="codeline" id="line-58"><code>//	//go:embed html/index.html</code></span>
<span class="codeline" id="line-59"><code>//	var content embed.FS</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// The Go build system will recognize the directives and arrange for the declared variable</code></span>
<span class="codeline" id="line-62"><code>// (in the example above, content) to be populated with the matching files from the file system.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// The //go:embed directive accepts multiple space-separated patterns for</code></span>
<span class="codeline" id="line-65"><code>// brevity, but it can also be repeated, to avoid very long lines when there are</code></span>
<span class="codeline" id="line-66"><code>// many patterns. The patterns are interpreted relative to the package directory</code></span>
<span class="codeline" id="line-67"><code>// containing the source file. The path separator is a forward slash, even on</code></span>
<span class="codeline" id="line-68"><code>// Windows systems. Patterns may not contain ‘.’ or ‘..’ or empty path elements,</code></span>
<span class="codeline" id="line-69"><code>// nor may they begin or end with a slash. To match everything in the current</code></span>
<span class="codeline" id="line-70"><code>// directory, use ‘*’ instead of ‘.’. To allow for naming files with spaces in</code></span>
<span class="codeline" id="line-71"><code>// their names, patterns can be written as Go double-quoted or back-quoted</code></span>
<span class="codeline" id="line-72"><code>// string literals.</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>// If a pattern names a directory, all files in the subtree rooted at that directory are</code></span>
<span class="codeline" id="line-75"><code>// embedded (recursively), except that files with names beginning with ‘.’ or ‘_’</code></span>
<span class="codeline" id="line-76"><code>// are excluded. So the variable in the above example is almost equivalent to:</code></span>
<span class="codeline" id="line-77"><code>//</code></span>
<span class="codeline" id="line-78"><code>//	// content is our static web server content.</code></span>
<span class="codeline" id="line-79"><code>//	//go:embed image template html/index.html</code></span>
<span class="codeline" id="line-80"><code>//	var content embed.FS</code></span>
<span class="codeline" id="line-81"><code>//</code></span>
<span class="codeline" id="line-82"><code>// The difference is that ‘image/*’ embeds ‘image/.tempfile’ while ‘image’ does not.</code></span>
<span class="codeline" id="line-83"><code>// Neither embeds ‘image/dir/.tempfile’.</code></span>
<span class="codeline" id="line-84"><code>//</code></span>
<span class="codeline" id="line-85"><code>// If a pattern begins with the prefix ‘all:’, then the rule for walking directories is changed</code></span>
<span class="codeline" id="line-86"><code>// to include those files beginning with ‘.’ or ‘_’. For example, ‘all:image’ embeds</code></span>
<span class="codeline" id="line-87"><code>// both ‘image/.tempfile’ and ‘image/dir/.tempfile’.</code></span>
<span class="codeline" id="line-88"><code>//</code></span>
<span class="codeline" id="line-89"><code>// The //go:embed directive can be used with both exported and unexported variables,</code></span>
<span class="codeline" id="line-90"><code>// depending on whether the package wants to make the data available to other packages.</code></span>
<span class="codeline" id="line-91"><code>// It can only be used with variables at package scope, not with local variables.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// Patterns must not match files outside the package's module, such as ‘.git/*’ or symbolic links.</code></span>
<span class="codeline" id="line-94"><code>// Patterns must not match files whose names include the special punctuation characters  " * &lt; &gt; ? ` ' | / \ and :.</code></span>
<span class="codeline" id="line-95"><code>// Matches for empty directories are ignored. After that, each pattern in a //go:embed line</code></span>
<span class="codeline" id="line-96"><code>// must match at least one file or non-empty directory.</code></span>
<span class="codeline" id="line-97"><code>//</code></span>
<span class="codeline" id="line-98"><code>// If any patterns are invalid or have invalid matches, the build will fail.</code></span>
<span class="codeline" id="line-99"><code>//</code></span>
<span class="codeline" id="line-100"><code>// # Strings and Bytes</code></span>
<span class="codeline" id="line-101"><code>//</code></span>
<span class="codeline" id="line-102"><code>// The //go:embed line for a variable of type string or []byte can have only a single pattern,</code></span>
<span class="codeline" id="line-103"><code>// and that pattern can match only a single file. The string or []byte is initialized with</code></span>
<span class="codeline" id="line-104"><code>// the contents of that file.</code></span>
<span class="codeline" id="line-105"><code>//</code></span>
<span class="codeline" id="line-106"><code>// The //go:embed directive requires importing "embed", even when using a string or []byte.</code></span>
<span class="codeline" id="line-107"><code>// In source files that don't refer to [embed.FS], use a blank import (import _ "embed").</code></span>
<span class="codeline" id="line-108"><code>//</code></span>
<span class="codeline" id="line-109"><code>// # File Systems</code></span>
<span class="codeline" id="line-110"><code>//</code></span>
<span class="codeline" id="line-111"><code>// For embedding a single file, a variable of type string or []byte is often best.</code></span>
<span class="codeline" id="line-112"><code>// The [FS] type enables embedding a tree of files, such as a directory of static</code></span>
<span class="codeline" id="line-113"><code>// web server content, as in the example above.</code></span>
<span class="codeline" id="line-114"><code>//</code></span>
<span class="codeline" id="line-115"><code>// FS implements the [io/fs] package's [FS] interface, so it can be used with any package that</code></span>
<span class="codeline" id="line-116"><code>// understands file systems, including [net/http], [text/template], and [html/template].</code></span>
<span class="codeline" id="line-117"><code>//</code></span>
<span class="codeline" id="line-118"><code>// For example, given the content variable in the example above, we can write:</code></span>
<span class="codeline" id="line-119"><code>//</code></span>
<span class="codeline" id="line-120"><code>//	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.FS(content))))</code></span>
<span class="codeline" id="line-121"><code>//</code></span>
<span class="codeline" id="line-122"><code>//	template.ParseFS(content, "*.tmpl")</code></span>
<span class="codeline" id="line-123"><code>//</code></span>
<span class="codeline" id="line-124"><code>// # Tools</code></span>
<span class="codeline" id="line-125"><code>//</code></span>
<span class="codeline" id="line-126"><code>// To support tools that analyze Go packages, the patterns found in //go:embed lines</code></span>
<span class="codeline" id="line-127"><code>// are available in “go list” output. See the EmbedPatterns, TestEmbedPatterns,</code></span>
<span class="codeline" id="line-128"><code>// and XTestEmbedPatterns fields in the “go help list” output.</code></span></div><span class="codeline" id="line-129"><code>package embed</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>import (</code></span>
<span class="codeline" id="line-132"><code>	"errors"</code></span>
<span class="codeline" id="line-133"><code>	"io"</code></span>
<span class="codeline" id="line-134"><code>	"io/fs"</code></span>
<span class="codeline" id="line-135"><code>	"time"</code></span>
<span class="codeline" id="line-136"><code>)</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>// An FS is a read-only collection of files, usually initialized with a //go:embed directive.</code></span>
<span class="codeline" id="line-139"><code>// When declared without a //go:embed directive, an FS is an empty file system.</code></span>
<span class="codeline" id="line-140"><code>//</code></span>
<span class="codeline" id="line-141"><code>// An FS is a read-only value, so it is safe to use from multiple goroutines</code></span>
<span class="codeline" id="line-142"><code>// simultaneously and also safe to assign values of type FS to each other.</code></span>
<span class="codeline" id="line-143"><code>//</code></span>
<span class="codeline" id="line-144"><code>// FS implements fs.FS, so it can be used with any package that understands</code></span>
<span class="codeline" id="line-145"><code>// file system interfaces, including net/http, text/template, and html/template.</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// See the package documentation for more details about initializing an FS.</code></span>
<span class="codeline" id="line-148"><code>type FS struct {</code></span>
<span class="codeline" id="line-149"><code>	// The compiler knows the layout of this struct.</code></span>
<span class="codeline" id="line-150"><code>	// See cmd/compile/internal/staticdata's WriteEmbed.</code></span>
<span class="codeline" id="line-151"><code>	//</code></span>
<span class="codeline" id="line-152"><code>	// The files list is sorted by name but not by simple string comparison.</code></span>
<span class="codeline" id="line-153"><code>	// Instead, each file's name takes the form "dir/elem" or "dir/elem/".</code></span>
<span class="codeline" id="line-154"><code>	// The optional trailing slash indicates that the file is itself a directory.</code></span>
<span class="codeline" id="line-155"><code>	// The files list is sorted first by dir (if dir is missing, it is taken to be ".")</code></span>
<span class="codeline" id="line-156"><code>	// and then by base, so this list of files:</code></span>
<span class="codeline" id="line-157"><code>	//</code></span>
<span class="codeline" id="line-158"><code>	//	p</code></span>
<span class="codeline" id="line-159"><code>	//	q/</code></span>
<span class="codeline" id="line-160"><code>	//	q/r</code></span>
<span class="codeline" id="line-161"><code>	//	q/s/</code></span>
<span class="codeline" id="line-162"><code>	//	q/s/t</code></span>
<span class="codeline" id="line-163"><code>	//	q/s/u</code></span>
<span class="codeline" id="line-164"><code>	//	q/v</code></span>
<span class="codeline" id="line-165"><code>	//	w</code></span>
<span class="codeline" id="line-166"><code>	//</code></span>
<span class="codeline" id="line-167"><code>	// is actually sorted as:</code></span>
<span class="codeline" id="line-168"><code>	//</code></span>
<span class="codeline" id="line-169"><code>	//	p       # dir=.    elem=p</code></span>
<span class="codeline" id="line-170"><code>	//	q/      # dir=.    elem=q</code></span>
<span class="codeline" id="line-171"><code>	//	w/      # dir=.    elem=w</code></span>
<span class="codeline" id="line-172"><code>	//	q/r     # dir=q    elem=r</code></span>
<span class="codeline" id="line-173"><code>	//	q/s/    # dir=q    elem=s</code></span>
<span class="codeline" id="line-174"><code>	//	q/v     # dir=q    elem=v</code></span>
<span class="codeline" id="line-175"><code>	//	q/s/t   # dir=q/s  elem=t</code></span>
<span class="codeline" id="line-176"><code>	//	q/s/u   # dir=q/s  elem=u</code></span>
<span class="codeline" id="line-177"><code>	//</code></span>
<span class="codeline" id="line-178"><code>	// This order brings directory contents together in contiguous sections</code></span>
<span class="codeline" id="line-179"><code>	// of the list, allowing a directory read to use binary search to find</code></span>
<span class="codeline" id="line-180"><code>	// the relevant sequence of entries.</code></span>
<span class="codeline" id="line-181"><code>	files *[]file</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>// split splits the name into dir and elem as described in the</code></span>
<span class="codeline" id="line-185"><code>// comment in the FS struct above. isDir reports whether the</code></span>
<span class="codeline" id="line-186"><code>// final trailing slash was present, indicating that name is a directory.</code></span>
<span class="codeline" id="line-187"><code>func split(name string) (dir, elem string, isDir bool) {</code></span>
<span class="codeline" id="line-188"><code>	if name[len(name)-1] == '/' {</code></span>
<span class="codeline" id="line-189"><code>		isDir = true</code></span>
<span class="codeline" id="line-190"><code>		name = name[:len(name)-1]</code></span>
<span class="codeline" id="line-191"><code>	}</code></span>
<span class="codeline" id="line-192"><code>	i := len(name) - 1</code></span>
<span class="codeline" id="line-193"><code>	for i &gt;= 0 &amp;&amp; name[i] != '/' {</code></span>
<span class="codeline" id="line-194"><code>		i--</code></span>
<span class="codeline" id="line-195"><code>	}</code></span>
<span class="codeline" id="line-196"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-197"><code>		return ".", name, isDir</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code>	return name[:i], name[i+1:], isDir</code></span>
<span class="codeline" id="line-200"><code>}</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>// trimSlash trims a trailing slash from name, if present,</code></span>
<span class="codeline" id="line-203"><code>// returning the possibly shortened name.</code></span>
<span class="codeline" id="line-204"><code>func trimSlash(name string) string {</code></span>
<span class="codeline" id="line-205"><code>	if len(name) &gt; 0 &amp;&amp; name[len(name)-1] == '/' {</code></span>
<span class="codeline" id="line-206"><code>		return name[:len(name)-1]</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code>	return name</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>var (</code></span>
<span class="codeline" id="line-212"><code>	_ fs.ReadDirFS  = FS{}</code></span>
<span class="codeline" id="line-213"><code>	_ fs.ReadFileFS = FS{}</code></span>
<span class="codeline" id="line-214"><code>)</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>// A file is a single file in the FS.</code></span>
<span class="codeline" id="line-217"><code>// It implements fs.FileInfo and fs.DirEntry.</code></span>
<span class="codeline" id="line-218"><code>type file struct {</code></span>
<span class="codeline" id="line-219"><code>	// The compiler knows the layout of this struct.</code></span>
<span class="codeline" id="line-220"><code>	// See cmd/compile/internal/staticdata's WriteEmbed.</code></span>
<span class="codeline" id="line-221"><code>	name string</code></span>
<span class="codeline" id="line-222"><code>	data string</code></span>
<span class="codeline" id="line-223"><code>	hash [16]byte // truncated SHA256 hash</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>var (</code></span>
<span class="codeline" id="line-227"><code>	_ fs.FileInfo = (*file)(nil)</code></span>
<span class="codeline" id="line-228"><code>	_ fs.DirEntry = (*file)(nil)</code></span>
<span class="codeline" id="line-229"><code>)</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>func (f *file) Name() string               { _, elem, _ := split(f.name); return elem }</code></span>
<span class="codeline" id="line-232"><code>func (f *file) Size() int64                { return int64(len(f.data)) }</code></span>
<span class="codeline" id="line-233"><code>func (f *file) ModTime() time.Time         { return time.Time{} }</code></span>
<span class="codeline" id="line-234"><code>func (f *file) IsDir() bool                { _, _, isDir := split(f.name); return isDir }</code></span>
<span class="codeline" id="line-235"><code>func (f *file) Sys() any                   { return nil }</code></span>
<span class="codeline" id="line-236"><code>func (f *file) Type() fs.FileMode          { return f.Mode().Type() }</code></span>
<span class="codeline" id="line-237"><code>func (f *file) Info() (fs.FileInfo, error) { return f, nil }</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>func (f *file) Mode() fs.FileMode {</code></span>
<span class="codeline" id="line-240"><code>	if f.IsDir() {</code></span>
<span class="codeline" id="line-241"><code>		return fs.ModeDir | 0555</code></span>
<span class="codeline" id="line-242"><code>	}</code></span>
<span class="codeline" id="line-243"><code>	return 0444</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>func (f *file) String() string {</code></span>
<span class="codeline" id="line-247"><code>	return fs.FormatFileInfo(f)</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// dotFile is a file for the root directory,</code></span>
<span class="codeline" id="line-251"><code>// which is omitted from the files list in a FS.</code></span>
<span class="codeline" id="line-252"><code>var dotFile = &amp;file{name: "./"}</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>// lookup returns the named file, or nil if it is not present.</code></span>
<span class="codeline" id="line-255"><code>func (f FS) lookup(name string) *file {</code></span>
<span class="codeline" id="line-256"><code>	if !fs.ValidPath(name) {</code></span>
<span class="codeline" id="line-257"><code>		// The compiler should never emit a file with an invalid name,</code></span>
<span class="codeline" id="line-258"><code>		// so this check is not strictly necessary (if name is invalid,</code></span>
<span class="codeline" id="line-259"><code>		// we shouldn't find a match below), but it's a good backstop anyway.</code></span>
<span class="codeline" id="line-260"><code>		return nil</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>	if name == "." {</code></span>
<span class="codeline" id="line-263"><code>		return dotFile</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>	if f.files == nil {</code></span>
<span class="codeline" id="line-266"><code>		return nil</code></span>
<span class="codeline" id="line-267"><code>	}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>	// Binary search to find where name would be in the list,</code></span>
<span class="codeline" id="line-270"><code>	// and then check if name is at that position.</code></span>
<span class="codeline" id="line-271"><code>	dir, elem, _ := split(name)</code></span>
<span class="codeline" id="line-272"><code>	files := *f.files</code></span>
<span class="codeline" id="line-273"><code>	i := sortSearch(len(files), func(i int) bool {</code></span>
<span class="codeline" id="line-274"><code>		idir, ielem, _ := split(files[i].name)</code></span>
<span class="codeline" id="line-275"><code>		return idir &gt; dir || idir == dir &amp;&amp; ielem &gt;= elem</code></span>
<span class="codeline" id="line-276"><code>	})</code></span>
<span class="codeline" id="line-277"><code>	if i &lt; len(files) &amp;&amp; trimSlash(files[i].name) == name {</code></span>
<span class="codeline" id="line-278"><code>		return &amp;files[i]</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code>	return nil</code></span>
<span class="codeline" id="line-281"><code>}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>// readDir returns the list of files corresponding to the directory dir.</code></span>
<span class="codeline" id="line-284"><code>func (f FS) readDir(dir string) []file {</code></span>
<span class="codeline" id="line-285"><code>	if f.files == nil {</code></span>
<span class="codeline" id="line-286"><code>		return nil</code></span>
<span class="codeline" id="line-287"><code>	}</code></span>
<span class="codeline" id="line-288"><code>	// Binary search to find where dir starts and ends in the list</code></span>
<span class="codeline" id="line-289"><code>	// and then return that slice of the list.</code></span>
<span class="codeline" id="line-290"><code>	files := *f.files</code></span>
<span class="codeline" id="line-291"><code>	i := sortSearch(len(files), func(i int) bool {</code></span>
<span class="codeline" id="line-292"><code>		idir, _, _ := split(files[i].name)</code></span>
<span class="codeline" id="line-293"><code>		return idir &gt;= dir</code></span>
<span class="codeline" id="line-294"><code>	})</code></span>
<span class="codeline" id="line-295"><code>	j := sortSearch(len(files), func(j int) bool {</code></span>
<span class="codeline" id="line-296"><code>		jdir, _, _ := split(files[j].name)</code></span>
<span class="codeline" id="line-297"><code>		return jdir &gt; dir</code></span>
<span class="codeline" id="line-298"><code>	})</code></span>
<span class="codeline" id="line-299"><code>	return files[i:j]</code></span>
<span class="codeline" id="line-300"><code>}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>// Open opens the named file for reading and returns it as an [fs.File].</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>// The returned file implements [io.Seeker] and [io.ReaderAt] when the file is not a directory.</code></span>
<span class="codeline" id="line-305"><code>func (f FS) Open(name string) (fs.File, error) {</code></span>
<span class="codeline" id="line-306"><code>	file := f.lookup(name)</code></span>
<span class="codeline" id="line-307"><code>	if file == nil {</code></span>
<span class="codeline" id="line-308"><code>		return nil, &amp;fs.PathError{Op: "open", Path: name, Err: fs.ErrNotExist}</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	if file.IsDir() {</code></span>
<span class="codeline" id="line-311"><code>		return &amp;openDir{file, f.readDir(name), 0}, nil</code></span>
<span class="codeline" id="line-312"><code>	}</code></span>
<span class="codeline" id="line-313"><code>	return &amp;openFile{file, 0}, nil</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>// ReadDir reads and returns the entire named directory.</code></span>
<span class="codeline" id="line-317"><code>func (f FS) ReadDir(name string) ([]fs.DirEntry, error) {</code></span>
<span class="codeline" id="line-318"><code>	file, err := f.Open(name)</code></span>
<span class="codeline" id="line-319"><code>	if err != nil {</code></span>
<span class="codeline" id="line-320"><code>		return nil, err</code></span>
<span class="codeline" id="line-321"><code>	}</code></span>
<span class="codeline" id="line-322"><code>	dir, ok := file.(*openDir)</code></span>
<span class="codeline" id="line-323"><code>	if !ok {</code></span>
<span class="codeline" id="line-324"><code>		return nil, &amp;fs.PathError{Op: "read", Path: name, Err: errors.New("not a directory")}</code></span>
<span class="codeline" id="line-325"><code>	}</code></span>
<span class="codeline" id="line-326"><code>	list := make([]fs.DirEntry, len(dir.files))</code></span>
<span class="codeline" id="line-327"><code>	for i := range list {</code></span>
<span class="codeline" id="line-328"><code>		list[i] = &amp;dir.files[i]</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	return list, nil</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>// ReadFile reads and returns the content of the named file.</code></span>
<span class="codeline" id="line-334"><code>func (f FS) ReadFile(name string) ([]byte, error) {</code></span>
<span class="codeline" id="line-335"><code>	file, err := f.Open(name)</code></span>
<span class="codeline" id="line-336"><code>	if err != nil {</code></span>
<span class="codeline" id="line-337"><code>		return nil, err</code></span>
<span class="codeline" id="line-338"><code>	}</code></span>
<span class="codeline" id="line-339"><code>	ofile, ok := file.(*openFile)</code></span>
<span class="codeline" id="line-340"><code>	if !ok {</code></span>
<span class="codeline" id="line-341"><code>		return nil, &amp;fs.PathError{Op: "read", Path: name, Err: errors.New("is a directory")}</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code>	return []byte(ofile.f.data), nil</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>// An openFile is a regular file open for reading.</code></span>
<span class="codeline" id="line-347"><code>type openFile struct {</code></span>
<span class="codeline" id="line-348"><code>	f      *file // the file itself</code></span>
<span class="codeline" id="line-349"><code>	offset int64 // current read offset</code></span>
<span class="codeline" id="line-350"><code>}</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>var (</code></span>
<span class="codeline" id="line-353"><code>	_ io.Seeker   = (*openFile)(nil)</code></span>
<span class="codeline" id="line-354"><code>	_ io.ReaderAt = (*openFile)(nil)</code></span>
<span class="codeline" id="line-355"><code>)</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>func (f *openFile) Close() error               { return nil }</code></span>
<span class="codeline" id="line-358"><code>func (f *openFile) Stat() (fs.FileInfo, error) { return f.f, nil }</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>func (f *openFile) Read(b []byte) (int, error) {</code></span>
<span class="codeline" id="line-361"><code>	if f.offset &gt;= int64(len(f.f.data)) {</code></span>
<span class="codeline" id="line-362"><code>		return 0, io.EOF</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>	if f.offset &lt; 0 {</code></span>
<span class="codeline" id="line-365"><code>		return 0, &amp;fs.PathError{Op: "read", Path: f.f.name, Err: fs.ErrInvalid}</code></span>
<span class="codeline" id="line-366"><code>	}</code></span>
<span class="codeline" id="line-367"><code>	n := copy(b, f.f.data[f.offset:])</code></span>
<span class="codeline" id="line-368"><code>	f.offset += int64(n)</code></span>
<span class="codeline" id="line-369"><code>	return n, nil</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>func (f *openFile) Seek(offset int64, whence int) (int64, error) {</code></span>
<span class="codeline" id="line-373"><code>	switch whence {</code></span>
<span class="codeline" id="line-374"><code>	case 0:</code></span>
<span class="codeline" id="line-375"><code>		// offset += 0</code></span>
<span class="codeline" id="line-376"><code>	case 1:</code></span>
<span class="codeline" id="line-377"><code>		offset += f.offset</code></span>
<span class="codeline" id="line-378"><code>	case 2:</code></span>
<span class="codeline" id="line-379"><code>		offset += int64(len(f.f.data))</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	if offset &lt; 0 || offset &gt; int64(len(f.f.data)) {</code></span>
<span class="codeline" id="line-382"><code>		return 0, &amp;fs.PathError{Op: "seek", Path: f.f.name, Err: fs.ErrInvalid}</code></span>
<span class="codeline" id="line-383"><code>	}</code></span>
<span class="codeline" id="line-384"><code>	f.offset = offset</code></span>
<span class="codeline" id="line-385"><code>	return offset, nil</code></span>
<span class="codeline" id="line-386"><code>}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>func (f *openFile) ReadAt(b []byte, offset int64) (int, error) {</code></span>
<span class="codeline" id="line-389"><code>	if offset &lt; 0 || offset &gt; int64(len(f.f.data)) {</code></span>
<span class="codeline" id="line-390"><code>		return 0, &amp;fs.PathError{Op: "read", Path: f.f.name, Err: fs.ErrInvalid}</code></span>
<span class="codeline" id="line-391"><code>	}</code></span>
<span class="codeline" id="line-392"><code>	n := copy(b, f.f.data[offset:])</code></span>
<span class="codeline" id="line-393"><code>	if n &lt; len(b) {</code></span>
<span class="codeline" id="line-394"><code>		return n, io.EOF</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code>	return n, nil</code></span>
<span class="codeline" id="line-397"><code>}</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>// An openDir is a directory open for reading.</code></span>
<span class="codeline" id="line-400"><code>type openDir struct {</code></span>
<span class="codeline" id="line-401"><code>	f      *file  // the directory file itself</code></span>
<span class="codeline" id="line-402"><code>	files  []file // the directory contents</code></span>
<span class="codeline" id="line-403"><code>	offset int    // the read offset, an index into the files slice</code></span>
<span class="codeline" id="line-404"><code>}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>func (d *openDir) Close() error               { return nil }</code></span>
<span class="codeline" id="line-407"><code>func (d *openDir) Stat() (fs.FileInfo, error) { return d.f, nil }</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>func (d *openDir) Read([]byte) (int, error) {</code></span>
<span class="codeline" id="line-410"><code>	return 0, &amp;fs.PathError{Op: "read", Path: d.f.name, Err: errors.New("is a directory")}</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>func (d *openDir) ReadDir(count int) ([]fs.DirEntry, error) {</code></span>
<span class="codeline" id="line-414"><code>	n := len(d.files) - d.offset</code></span>
<span class="codeline" id="line-415"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-416"><code>		if count &lt;= 0 {</code></span>
<span class="codeline" id="line-417"><code>			return nil, nil</code></span>
<span class="codeline" id="line-418"><code>		}</code></span>
<span class="codeline" id="line-419"><code>		return nil, io.EOF</code></span>
<span class="codeline" id="line-420"><code>	}</code></span>
<span class="codeline" id="line-421"><code>	if count &gt; 0 &amp;&amp; n &gt; count {</code></span>
<span class="codeline" id="line-422"><code>		n = count</code></span>
<span class="codeline" id="line-423"><code>	}</code></span>
<span class="codeline" id="line-424"><code>	list := make([]fs.DirEntry, n)</code></span>
<span class="codeline" id="line-425"><code>	for i := range list {</code></span>
<span class="codeline" id="line-426"><code>		list[i] = &amp;d.files[d.offset+i]</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	d.offset += n</code></span>
<span class="codeline" id="line-429"><code>	return list, nil</code></span>
<span class="codeline" id="line-430"><code>}</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>// sortSearch is like sort.Search, avoiding an import.</code></span>
<span class="codeline" id="line-433"><code>func sortSearch(n int, f func(int) bool) int {</code></span>
<span class="codeline" id="line-434"><code>	// Define f(-1) == false and f(n) == true.</code></span>
<span class="codeline" id="line-435"><code>	// Invariant: f(i-1) == false, f(j) == true.</code></span>
<span class="codeline" id="line-436"><code>	i, j := 0, n</code></span>
<span class="codeline" id="line-437"><code>	for i &lt; j {</code></span>
<span class="codeline" id="line-438"><code>		h := int(uint(i+j) &gt;&gt; 1) // avoid overflow when computing h</code></span>
<span class="codeline" id="line-439"><code>		// i ≤ h &lt; j</code></span>
<span class="codeline" id="line-440"><code>		if !f(h) {</code></span>
<span class="codeline" id="line-441"><code>			i = h + 1 // preserves f(i-1) == false</code></span>
<span class="codeline" id="line-442"><code>		} else {</code></span>
<span class="codeline" id="line-443"><code>			j = h // preserves f(j) == true</code></span>
<span class="codeline" id="line-444"><code>		}</code></span>
<span class="codeline" id="line-445"><code>	}</code></span>
<span class="codeline" id="line-446"><code>	// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</code></span>
<span class="codeline" id="line-447"><code>	return i</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>