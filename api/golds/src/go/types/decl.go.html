<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: decl.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	decl.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package types</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"go/ast"</code></span>
<span class="codeline" id="line-10"><code>	"go/constant"</code></span>
<span class="codeline" id="line-11"><code>	"go/token"</code></span>
<span class="codeline" id="line-12"><code>	. "internal/types/errors"</code></span>
<span class="codeline" id="line-13"><code>)</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>func (check *Checker) reportAltDecl(obj Object) {</code></span>
<span class="codeline" id="line-16"><code>	if pos := obj.Pos(); pos.IsValid() {</code></span>
<span class="codeline" id="line-17"><code>		// We use "other" rather than "previous" here because</code></span>
<span class="codeline" id="line-18"><code>		// the first declaration seen may not be textually</code></span>
<span class="codeline" id="line-19"><code>		// earlier in the source.</code></span>
<span class="codeline" id="line-20"><code>		check.errorf(obj, DuplicateDecl, "\tother declaration of %s", obj.Name()) // secondary error, \t indented</code></span>
<span class="codeline" id="line-21"><code>	}</code></span>
<span class="codeline" id="line-22"><code>}</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>func (check *Checker) declare(scope *Scope, id *ast.Ident, obj Object, pos token.Pos) {</code></span>
<span class="codeline" id="line-25"><code>	// spec: "The blank identifier, represented by the underscore</code></span>
<span class="codeline" id="line-26"><code>	// character _, may be used in a declaration like any other</code></span>
<span class="codeline" id="line-27"><code>	// identifier but the declaration does not introduce a new</code></span>
<span class="codeline" id="line-28"><code>	// binding."</code></span>
<span class="codeline" id="line-29"><code>	if obj.Name() != "_" {</code></span>
<span class="codeline" id="line-30"><code>		if alt := scope.Insert(obj); alt != nil {</code></span>
<span class="codeline" id="line-31"><code>			check.errorf(obj, DuplicateDecl, "%s redeclared in this block", obj.Name())</code></span>
<span class="codeline" id="line-32"><code>			check.reportAltDecl(alt)</code></span>
<span class="codeline" id="line-33"><code>			return</code></span>
<span class="codeline" id="line-34"><code>		}</code></span>
<span class="codeline" id="line-35"><code>		obj.setScopePos(pos)</code></span>
<span class="codeline" id="line-36"><code>	}</code></span>
<span class="codeline" id="line-37"><code>	if id != nil {</code></span>
<span class="codeline" id="line-38"><code>		check.recordDef(id, obj)</code></span>
<span class="codeline" id="line-39"><code>	}</code></span>
<span class="codeline" id="line-40"><code>}</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>// pathString returns a string of the form a-&gt;b-&gt; ... -&gt;g for a path [a, b, ... g].</code></span>
<span class="codeline" id="line-43"><code>func pathString(path []Object) string {</code></span>
<span class="codeline" id="line-44"><code>	var s string</code></span>
<span class="codeline" id="line-45"><code>	for i, p := range path {</code></span>
<span class="codeline" id="line-46"><code>		if i &gt; 0 {</code></span>
<span class="codeline" id="line-47"><code>			s += "-&gt;"</code></span>
<span class="codeline" id="line-48"><code>		}</code></span>
<span class="codeline" id="line-49"><code>		s += p.Name()</code></span>
<span class="codeline" id="line-50"><code>	}</code></span>
<span class="codeline" id="line-51"><code>	return s</code></span>
<span class="codeline" id="line-52"><code>}</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>// objDecl type-checks the declaration of obj in its respective (file) environment.</code></span>
<span class="codeline" id="line-55"><code>// For the meaning of def, see Checker.definedType, in typexpr.go.</code></span>
<span class="codeline" id="line-56"><code>func (check *Checker) objDecl(obj Object, def *TypeName) {</code></span>
<span class="codeline" id="line-57"><code>	if check.conf._Trace &amp;&amp; obj.Type() == nil {</code></span>
<span class="codeline" id="line-58"><code>		if check.indent == 0 {</code></span>
<span class="codeline" id="line-59"><code>			fmt.Println() // empty line between top-level objects for readability</code></span>
<span class="codeline" id="line-60"><code>		}</code></span>
<span class="codeline" id="line-61"><code>		check.trace(obj.Pos(), "-- checking %s (%s, objPath = %s)", obj, obj.color(), pathString(check.objPath))</code></span>
<span class="codeline" id="line-62"><code>		check.indent++</code></span>
<span class="codeline" id="line-63"><code>		defer func() {</code></span>
<span class="codeline" id="line-64"><code>			check.indent--</code></span>
<span class="codeline" id="line-65"><code>			check.trace(obj.Pos(), "=&gt; %s (%s)", obj, obj.color())</code></span>
<span class="codeline" id="line-66"><code>		}()</code></span>
<span class="codeline" id="line-67"><code>	}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>	// Checking the declaration of obj means inferring its type</code></span>
<span class="codeline" id="line-70"><code>	// (and possibly its value, for constants).</code></span>
<span class="codeline" id="line-71"><code>	// An object's type (and thus the object) may be in one of</code></span>
<span class="codeline" id="line-72"><code>	// three states which are expressed by colors:</code></span>
<span class="codeline" id="line-73"><code>	//</code></span>
<span class="codeline" id="line-74"><code>	// - an object whose type is not yet known is painted white (initial color)</code></span>
<span class="codeline" id="line-75"><code>	// - an object whose type is in the process of being inferred is painted grey</code></span>
<span class="codeline" id="line-76"><code>	// - an object whose type is fully inferred is painted black</code></span>
<span class="codeline" id="line-77"><code>	//</code></span>
<span class="codeline" id="line-78"><code>	// During type inference, an object's color changes from white to grey</code></span>
<span class="codeline" id="line-79"><code>	// to black (pre-declared objects are painted black from the start).</code></span>
<span class="codeline" id="line-80"><code>	// A black object (i.e., its type) can only depend on (refer to) other black</code></span>
<span class="codeline" id="line-81"><code>	// ones. White and grey objects may depend on white and black objects.</code></span>
<span class="codeline" id="line-82"><code>	// A dependency on a grey object indicates a cycle which may or may not be</code></span>
<span class="codeline" id="line-83"><code>	// valid.</code></span>
<span class="codeline" id="line-84"><code>	//</code></span>
<span class="codeline" id="line-85"><code>	// When objects turn grey, they are pushed on the object path (a stack);</code></span>
<span class="codeline" id="line-86"><code>	// they are popped again when they turn black. Thus, if a grey object (a</code></span>
<span class="codeline" id="line-87"><code>	// cycle) is encountered, it is on the object path, and all the objects</code></span>
<span class="codeline" id="line-88"><code>	// it depends on are the remaining objects on that path. Color encoding</code></span>
<span class="codeline" id="line-89"><code>	// is such that the color value of a grey object indicates the index of</code></span>
<span class="codeline" id="line-90"><code>	// that object in the object path.</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>	// During type-checking, white objects may be assigned a type without</code></span>
<span class="codeline" id="line-93"><code>	// traversing through objDecl; e.g., when initializing constants and</code></span>
<span class="codeline" id="line-94"><code>	// variables. Update the colors of those objects here (rather than</code></span>
<span class="codeline" id="line-95"><code>	// everywhere where we set the type) to satisfy the color invariants.</code></span>
<span class="codeline" id="line-96"><code>	if obj.color() == white &amp;&amp; obj.Type() != nil {</code></span>
<span class="codeline" id="line-97"><code>		obj.setColor(black)</code></span>
<span class="codeline" id="line-98"><code>		return</code></span>
<span class="codeline" id="line-99"><code>	}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>	switch obj.color() {</code></span>
<span class="codeline" id="line-102"><code>	case white:</code></span>
<span class="codeline" id="line-103"><code>		assert(obj.Type() == nil)</code></span>
<span class="codeline" id="line-104"><code>		// All color values other than white and black are considered grey.</code></span>
<span class="codeline" id="line-105"><code>		// Because black and white are &lt; grey, all values &gt;= grey are grey.</code></span>
<span class="codeline" id="line-106"><code>		// Use those values to encode the object's index into the object path.</code></span>
<span class="codeline" id="line-107"><code>		obj.setColor(grey + color(check.push(obj)))</code></span>
<span class="codeline" id="line-108"><code>		defer func() {</code></span>
<span class="codeline" id="line-109"><code>			check.pop().setColor(black)</code></span>
<span class="codeline" id="line-110"><code>		}()</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	case black:</code></span>
<span class="codeline" id="line-113"><code>		assert(obj.Type() != nil)</code></span>
<span class="codeline" id="line-114"><code>		return</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>	default:</code></span>
<span class="codeline" id="line-117"><code>		// Color values other than white or black are considered grey.</code></span>
<span class="codeline" id="line-118"><code>		fallthrough</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>	case grey:</code></span>
<span class="codeline" id="line-121"><code>		// We have a (possibly invalid) cycle.</code></span>
<span class="codeline" id="line-122"><code>		// In the existing code, this is marked by a non-nil type</code></span>
<span class="codeline" id="line-123"><code>		// for the object except for constants and variables whose</code></span>
<span class="codeline" id="line-124"><code>		// type may be non-nil (known), or nil if it depends on the</code></span>
<span class="codeline" id="line-125"><code>		// not-yet known initialization value.</code></span>
<span class="codeline" id="line-126"><code>		// In the former case, set the type to Typ[Invalid] because</code></span>
<span class="codeline" id="line-127"><code>		// we have an initialization cycle. The cycle error will be</code></span>
<span class="codeline" id="line-128"><code>		// reported later, when determining initialization order.</code></span>
<span class="codeline" id="line-129"><code>		// TODO(gri) Report cycle here and simplify initialization</code></span>
<span class="codeline" id="line-130"><code>		// order code.</code></span>
<span class="codeline" id="line-131"><code>		switch obj := obj.(type) {</code></span>
<span class="codeline" id="line-132"><code>		case *Const:</code></span>
<span class="codeline" id="line-133"><code>			if !check.validCycle(obj) || obj.typ == nil {</code></span>
<span class="codeline" id="line-134"><code>				obj.typ = Typ[Invalid]</code></span>
<span class="codeline" id="line-135"><code>			}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>		case *Var:</code></span>
<span class="codeline" id="line-138"><code>			if !check.validCycle(obj) || obj.typ == nil {</code></span>
<span class="codeline" id="line-139"><code>				obj.typ = Typ[Invalid]</code></span>
<span class="codeline" id="line-140"><code>			}</code></span>
<span class="codeline" id="line-141"><code></code></span>
<span class="codeline" id="line-142"><code>		case *TypeName:</code></span>
<span class="codeline" id="line-143"><code>			if !check.validCycle(obj) {</code></span>
<span class="codeline" id="line-144"><code>				// break cycle</code></span>
<span class="codeline" id="line-145"><code>				// (without this, calling underlying()</code></span>
<span class="codeline" id="line-146"><code>				// below may lead to an endless loop</code></span>
<span class="codeline" id="line-147"><code>				// if we have a cycle for a defined</code></span>
<span class="codeline" id="line-148"><code>				// (*Named) type)</code></span>
<span class="codeline" id="line-149"><code>				obj.typ = Typ[Invalid]</code></span>
<span class="codeline" id="line-150"><code>			}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>		case *Func:</code></span>
<span class="codeline" id="line-153"><code>			if !check.validCycle(obj) {</code></span>
<span class="codeline" id="line-154"><code>				// Don't set obj.typ to Typ[Invalid] here</code></span>
<span class="codeline" id="line-155"><code>				// because plenty of code type-asserts that</code></span>
<span class="codeline" id="line-156"><code>				// functions have a *Signature type. Grey</code></span>
<span class="codeline" id="line-157"><code>				// functions have their type set to an empty</code></span>
<span class="codeline" id="line-158"><code>				// signature which makes it impossible to</code></span>
<span class="codeline" id="line-159"><code>				// initialize a variable with the function.</code></span>
<span class="codeline" id="line-160"><code>			}</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>		default:</code></span>
<span class="codeline" id="line-163"><code>			unreachable()</code></span>
<span class="codeline" id="line-164"><code>		}</code></span>
<span class="codeline" id="line-165"><code>		assert(obj.Type() != nil)</code></span>
<span class="codeline" id="line-166"><code>		return</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	d := check.objMap[obj]</code></span>
<span class="codeline" id="line-170"><code>	if d == nil {</code></span>
<span class="codeline" id="line-171"><code>		check.dump("%v: %s should have been declared", obj.Pos(), obj)</code></span>
<span class="codeline" id="line-172"><code>		unreachable()</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>	// save/restore current environment and set up object environment</code></span>
<span class="codeline" id="line-176"><code>	defer func(env environment) {</code></span>
<span class="codeline" id="line-177"><code>		check.environment = env</code></span>
<span class="codeline" id="line-178"><code>	}(check.environment)</code></span>
<span class="codeline" id="line-179"><code>	check.environment = environment{</code></span>
<span class="codeline" id="line-180"><code>		scope: d.file,</code></span>
<span class="codeline" id="line-181"><code>	}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>	// Const and var declarations must not have initialization</code></span>
<span class="codeline" id="line-184"><code>	// cycles. We track them by remembering the current declaration</code></span>
<span class="codeline" id="line-185"><code>	// in check.decl. Initialization expressions depending on other</code></span>
<span class="codeline" id="line-186"><code>	// consts, vars, or functions, add dependencies to the current</code></span>
<span class="codeline" id="line-187"><code>	// check.decl.</code></span>
<span class="codeline" id="line-188"><code>	switch obj := obj.(type) {</code></span>
<span class="codeline" id="line-189"><code>	case *Const:</code></span>
<span class="codeline" id="line-190"><code>		check.decl = d // new package-level const decl</code></span>
<span class="codeline" id="line-191"><code>		check.constDecl(obj, d.vtyp, d.init, d.inherited)</code></span>
<span class="codeline" id="line-192"><code>	case *Var:</code></span>
<span class="codeline" id="line-193"><code>		check.decl = d // new package-level var decl</code></span>
<span class="codeline" id="line-194"><code>		check.varDecl(obj, d.lhs, d.vtyp, d.init)</code></span>
<span class="codeline" id="line-195"><code>	case *TypeName:</code></span>
<span class="codeline" id="line-196"><code>		// invalid recursive types are detected via path</code></span>
<span class="codeline" id="line-197"><code>		check.typeDecl(obj, d.tdecl, def)</code></span>
<span class="codeline" id="line-198"><code>		check.collectMethods(obj) // methods can only be added to top-level types</code></span>
<span class="codeline" id="line-199"><code>	case *Func:</code></span>
<span class="codeline" id="line-200"><code>		// functions may be recursive - no need to track dependencies</code></span>
<span class="codeline" id="line-201"><code>		check.funcDecl(obj, d)</code></span>
<span class="codeline" id="line-202"><code>	default:</code></span>
<span class="codeline" id="line-203"><code>		unreachable()</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>// validCycle checks if the cycle starting with obj is valid and</code></span>
<span class="codeline" id="line-208"><code>// reports an error if it is not.</code></span>
<span class="codeline" id="line-209"><code>func (check *Checker) validCycle(obj Object) (valid bool) {</code></span>
<span class="codeline" id="line-210"><code>	// The object map contains the package scope objects and the non-interface methods.</code></span>
<span class="codeline" id="line-211"><code>	if debug {</code></span>
<span class="codeline" id="line-212"><code>		info := check.objMap[obj]</code></span>
<span class="codeline" id="line-213"><code>		inObjMap := info != nil &amp;&amp; (info.fdecl == nil || info.fdecl.Recv == nil) // exclude methods</code></span>
<span class="codeline" id="line-214"><code>		isPkgObj := obj.Parent() == check.pkg.scope</code></span>
<span class="codeline" id="line-215"><code>		if isPkgObj != inObjMap {</code></span>
<span class="codeline" id="line-216"><code>			check.dump("%v: inconsistent object map for %s (isPkgObj = %v, inObjMap = %v)", obj.Pos(), obj, isPkgObj, inObjMap)</code></span>
<span class="codeline" id="line-217"><code>			unreachable()</code></span>
<span class="codeline" id="line-218"><code>		}</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>	// Count cycle objects.</code></span>
<span class="codeline" id="line-222"><code>	assert(obj.color() &gt;= grey)</code></span>
<span class="codeline" id="line-223"><code>	start := obj.color() - grey // index of obj in objPath</code></span>
<span class="codeline" id="line-224"><code>	cycle := check.objPath[start:]</code></span>
<span class="codeline" id="line-225"><code>	tparCycle := false // if set, the cycle is through a type parameter list</code></span>
<span class="codeline" id="line-226"><code>	nval := 0          // number of (constant or variable) values in the cycle; valid if !generic</code></span>
<span class="codeline" id="line-227"><code>	ndef := 0          // number of type definitions in the cycle; valid if !generic</code></span>
<span class="codeline" id="line-228"><code>loop:</code></span>
<span class="codeline" id="line-229"><code>	for _, obj := range cycle {</code></span>
<span class="codeline" id="line-230"><code>		switch obj := obj.(type) {</code></span>
<span class="codeline" id="line-231"><code>		case *Const, *Var:</code></span>
<span class="codeline" id="line-232"><code>			nval++</code></span>
<span class="codeline" id="line-233"><code>		case *TypeName:</code></span>
<span class="codeline" id="line-234"><code>			// If we reach a generic type that is part of a cycle</code></span>
<span class="codeline" id="line-235"><code>			// and we are in a type parameter list, we have a cycle</code></span>
<span class="codeline" id="line-236"><code>			// through a type parameter list, which is invalid.</code></span>
<span class="codeline" id="line-237"><code>			if check.inTParamList &amp;&amp; isGeneric(obj.typ) {</code></span>
<span class="codeline" id="line-238"><code>				tparCycle = true</code></span>
<span class="codeline" id="line-239"><code>				break loop</code></span>
<span class="codeline" id="line-240"><code>			}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>			// Determine if the type name is an alias or not. For</code></span>
<span class="codeline" id="line-243"><code>			// package-level objects, use the object map which</code></span>
<span class="codeline" id="line-244"><code>			// provides syntactic information (which doesn't rely</code></span>
<span class="codeline" id="line-245"><code>			// on the order in which the objects are set up). For</code></span>
<span class="codeline" id="line-246"><code>			// local objects, we can rely on the order, so use</code></span>
<span class="codeline" id="line-247"><code>			// the object's predicate.</code></span>
<span class="codeline" id="line-248"><code>			// TODO(gri) It would be less fragile to always access</code></span>
<span class="codeline" id="line-249"><code>			// the syntactic information. We should consider storing</code></span>
<span class="codeline" id="line-250"><code>			// this information explicitly in the object.</code></span>
<span class="codeline" id="line-251"><code>			var alias bool</code></span>
<span class="codeline" id="line-252"><code>			if check.enableAlias {</code></span>
<span class="codeline" id="line-253"><code>				alias = obj.IsAlias()</code></span>
<span class="codeline" id="line-254"><code>			} else {</code></span>
<span class="codeline" id="line-255"><code>				if d := check.objMap[obj]; d != nil {</code></span>
<span class="codeline" id="line-256"><code>					alias = d.tdecl.Assign.IsValid() // package-level object</code></span>
<span class="codeline" id="line-257"><code>				} else {</code></span>
<span class="codeline" id="line-258"><code>					alias = obj.IsAlias() // function local object</code></span>
<span class="codeline" id="line-259"><code>				}</code></span>
<span class="codeline" id="line-260"><code>			}</code></span>
<span class="codeline" id="line-261"><code>			if !alias {</code></span>
<span class="codeline" id="line-262"><code>				ndef++</code></span>
<span class="codeline" id="line-263"><code>			}</code></span>
<span class="codeline" id="line-264"><code>		case *Func:</code></span>
<span class="codeline" id="line-265"><code>			// ignored for now</code></span>
<span class="codeline" id="line-266"><code>		default:</code></span>
<span class="codeline" id="line-267"><code>			unreachable()</code></span>
<span class="codeline" id="line-268"><code>		}</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>	if check.conf._Trace {</code></span>
<span class="codeline" id="line-272"><code>		check.trace(obj.Pos(), "## cycle detected: objPath = %s-&gt;%s (len = %d)", pathString(cycle), obj.Name(), len(cycle))</code></span>
<span class="codeline" id="line-273"><code>		if tparCycle {</code></span>
<span class="codeline" id="line-274"><code>			check.trace(obj.Pos(), "## cycle contains: generic type in a type parameter list")</code></span>
<span class="codeline" id="line-275"><code>		} else {</code></span>
<span class="codeline" id="line-276"><code>			check.trace(obj.Pos(), "## cycle contains: %d values, %d type definitions", nval, ndef)</code></span>
<span class="codeline" id="line-277"><code>		}</code></span>
<span class="codeline" id="line-278"><code>		defer func() {</code></span>
<span class="codeline" id="line-279"><code>			if valid {</code></span>
<span class="codeline" id="line-280"><code>				check.trace(obj.Pos(), "=&gt; cycle is valid")</code></span>
<span class="codeline" id="line-281"><code>			} else {</code></span>
<span class="codeline" id="line-282"><code>				check.trace(obj.Pos(), "=&gt; error: cycle is invalid")</code></span>
<span class="codeline" id="line-283"><code>			}</code></span>
<span class="codeline" id="line-284"><code>		}()</code></span>
<span class="codeline" id="line-285"><code>	}</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>	if !tparCycle {</code></span>
<span class="codeline" id="line-288"><code>		// A cycle involving only constants and variables is invalid but we</code></span>
<span class="codeline" id="line-289"><code>		// ignore them here because they are reported via the initialization</code></span>
<span class="codeline" id="line-290"><code>		// cycle check.</code></span>
<span class="codeline" id="line-291"><code>		if nval == len(cycle) {</code></span>
<span class="codeline" id="line-292"><code>			return true</code></span>
<span class="codeline" id="line-293"><code>		}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>		// A cycle involving only types (and possibly functions) must have at least</code></span>
<span class="codeline" id="line-296"><code>		// one type definition to be permitted: If there is no type definition, we</code></span>
<span class="codeline" id="line-297"><code>		// have a sequence of alias type names which will expand ad infinitum.</code></span>
<span class="codeline" id="line-298"><code>		if nval == 0 &amp;&amp; ndef &gt; 0 {</code></span>
<span class="codeline" id="line-299"><code>			return true</code></span>
<span class="codeline" id="line-300"><code>		}</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>	check.cycleError(cycle)</code></span>
<span class="codeline" id="line-304"><code>	return false</code></span>
<span class="codeline" id="line-305"><code>}</code></span>
<span class="codeline" id="line-306"><code></code></span>
<span class="codeline" id="line-307"><code>// cycleError reports a declaration cycle starting with</code></span>
<span class="codeline" id="line-308"><code>// the object in cycle that is "first" in the source.</code></span>
<span class="codeline" id="line-309"><code>func (check *Checker) cycleError(cycle []Object) {</code></span>
<span class="codeline" id="line-310"><code>	// name returns the (possibly qualified) object name.</code></span>
<span class="codeline" id="line-311"><code>	// This is needed because with generic types, cycles</code></span>
<span class="codeline" id="line-312"><code>	// may refer to imported types. See go.dev/issue/50788.</code></span>
<span class="codeline" id="line-313"><code>	// TODO(gri) Thus functionality is used elsewhere. Factor it out.</code></span>
<span class="codeline" id="line-314"><code>	name := func(obj Object) string {</code></span>
<span class="codeline" id="line-315"><code>		return packagePrefix(obj.Pkg(), check.qualifier) + obj.Name()</code></span>
<span class="codeline" id="line-316"><code>	}</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>	// TODO(gri) Should we start with the last (rather than the first) object in the cycle</code></span>
<span class="codeline" id="line-319"><code>	//           since that is the earliest point in the source where we start seeing the</code></span>
<span class="codeline" id="line-320"><code>	//           cycle? That would be more consistent with other error messages.</code></span>
<span class="codeline" id="line-321"><code>	i := firstInSrc(cycle)</code></span>
<span class="codeline" id="line-322"><code>	obj := cycle[i]</code></span>
<span class="codeline" id="line-323"><code>	objName := name(obj)</code></span>
<span class="codeline" id="line-324"><code>	// If obj is a type alias, mark it as valid (not broken) in order to avoid follow-on errors.</code></span>
<span class="codeline" id="line-325"><code>	tname, _ := obj.(*TypeName)</code></span>
<span class="codeline" id="line-326"><code>	if tname != nil &amp;&amp; tname.IsAlias() {</code></span>
<span class="codeline" id="line-327"><code>		// If we use Alias nodes, it is initialized with Typ[Invalid].</code></span>
<span class="codeline" id="line-328"><code>		// TODO(gri) Adjust this code if we initialize with nil.</code></span>
<span class="codeline" id="line-329"><code>		if !check.enableAlias {</code></span>
<span class="codeline" id="line-330"><code>			check.validAlias(tname, Typ[Invalid])</code></span>
<span class="codeline" id="line-331"><code>		}</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>	// report a more concise error for self references</code></span>
<span class="codeline" id="line-335"><code>	if len(cycle) == 1 {</code></span>
<span class="codeline" id="line-336"><code>		if tname != nil {</code></span>
<span class="codeline" id="line-337"><code>			check.errorf(obj, InvalidDeclCycle, "invalid recursive type: %s refers to itself", objName)</code></span>
<span class="codeline" id="line-338"><code>		} else {</code></span>
<span class="codeline" id="line-339"><code>			check.errorf(obj, InvalidDeclCycle, "invalid cycle in declaration: %s refers to itself", objName)</code></span>
<span class="codeline" id="line-340"><code>		}</code></span>
<span class="codeline" id="line-341"><code>		return</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>	if tname != nil {</code></span>
<span class="codeline" id="line-345"><code>		check.errorf(obj, InvalidDeclCycle, "invalid recursive type %s", objName)</code></span>
<span class="codeline" id="line-346"><code>	} else {</code></span>
<span class="codeline" id="line-347"><code>		check.errorf(obj, InvalidDeclCycle, "invalid cycle in declaration of %s", objName)</code></span>
<span class="codeline" id="line-348"><code>	}</code></span>
<span class="codeline" id="line-349"><code>	for range cycle {</code></span>
<span class="codeline" id="line-350"><code>		check.errorf(obj, InvalidDeclCycle, "\t%s refers to", objName) // secondary error, \t indented</code></span>
<span class="codeline" id="line-351"><code>		i++</code></span>
<span class="codeline" id="line-352"><code>		if i &gt;= len(cycle) {</code></span>
<span class="codeline" id="line-353"><code>			i = 0</code></span>
<span class="codeline" id="line-354"><code>		}</code></span>
<span class="codeline" id="line-355"><code>		obj = cycle[i]</code></span>
<span class="codeline" id="line-356"><code>		objName = name(obj)</code></span>
<span class="codeline" id="line-357"><code>	}</code></span>
<span class="codeline" id="line-358"><code>	check.errorf(obj, InvalidDeclCycle, "\t%s", objName)</code></span>
<span class="codeline" id="line-359"><code>}</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>// firstInSrc reports the index of the object with the "smallest"</code></span>
<span class="codeline" id="line-362"><code>// source position in path. path must not be empty.</code></span>
<span class="codeline" id="line-363"><code>func firstInSrc(path []Object) int {</code></span>
<span class="codeline" id="line-364"><code>	fst, pos := 0, path[0].Pos()</code></span>
<span class="codeline" id="line-365"><code>	for i, t := range path[1:] {</code></span>
<span class="codeline" id="line-366"><code>		if cmpPos(t.Pos(), pos) &lt; 0 {</code></span>
<span class="codeline" id="line-367"><code>			fst, pos = i+1, t.Pos()</code></span>
<span class="codeline" id="line-368"><code>		}</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>	return fst</code></span>
<span class="codeline" id="line-371"><code>}</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>type (</code></span>
<span class="codeline" id="line-374"><code>	decl interface {</code></span>
<span class="codeline" id="line-375"><code>		node() ast.Node</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>	importDecl struct{ spec *ast.ImportSpec }</code></span>
<span class="codeline" id="line-379"><code>	constDecl  struct {</code></span>
<span class="codeline" id="line-380"><code>		spec      *ast.ValueSpec</code></span>
<span class="codeline" id="line-381"><code>		iota      int</code></span>
<span class="codeline" id="line-382"><code>		typ       ast.Expr</code></span>
<span class="codeline" id="line-383"><code>		init      []ast.Expr</code></span>
<span class="codeline" id="line-384"><code>		inherited bool</code></span>
<span class="codeline" id="line-385"><code>	}</code></span>
<span class="codeline" id="line-386"><code>	varDecl  struct{ spec *ast.ValueSpec }</code></span>
<span class="codeline" id="line-387"><code>	typeDecl struct{ spec *ast.TypeSpec }</code></span>
<span class="codeline" id="line-388"><code>	funcDecl struct{ decl *ast.FuncDecl }</code></span>
<span class="codeline" id="line-389"><code>)</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>func (d importDecl) node() ast.Node { return d.spec }</code></span>
<span class="codeline" id="line-392"><code>func (d constDecl) node() ast.Node  { return d.spec }</code></span>
<span class="codeline" id="line-393"><code>func (d varDecl) node() ast.Node    { return d.spec }</code></span>
<span class="codeline" id="line-394"><code>func (d typeDecl) node() ast.Node   { return d.spec }</code></span>
<span class="codeline" id="line-395"><code>func (d funcDecl) node() ast.Node   { return d.decl }</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>func (check *Checker) walkDecls(decls []ast.Decl, f func(decl)) {</code></span>
<span class="codeline" id="line-398"><code>	for _, d := range decls {</code></span>
<span class="codeline" id="line-399"><code>		check.walkDecl(d, f)</code></span>
<span class="codeline" id="line-400"><code>	}</code></span>
<span class="codeline" id="line-401"><code>}</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>func (check *Checker) walkDecl(d ast.Decl, f func(decl)) {</code></span>
<span class="codeline" id="line-404"><code>	switch d := d.(type) {</code></span>
<span class="codeline" id="line-405"><code>	case *ast.BadDecl:</code></span>
<span class="codeline" id="line-406"><code>		// ignore</code></span>
<span class="codeline" id="line-407"><code>	case *ast.GenDecl:</code></span>
<span class="codeline" id="line-408"><code>		var last *ast.ValueSpec // last ValueSpec with type or init exprs seen</code></span>
<span class="codeline" id="line-409"><code>		for iota, s := range d.Specs {</code></span>
<span class="codeline" id="line-410"><code>			switch s := s.(type) {</code></span>
<span class="codeline" id="line-411"><code>			case *ast.ImportSpec:</code></span>
<span class="codeline" id="line-412"><code>				f(importDecl{s})</code></span>
<span class="codeline" id="line-413"><code>			case *ast.ValueSpec:</code></span>
<span class="codeline" id="line-414"><code>				switch d.Tok {</code></span>
<span class="codeline" id="line-415"><code>				case token.CONST:</code></span>
<span class="codeline" id="line-416"><code>					// determine which initialization expressions to use</code></span>
<span class="codeline" id="line-417"><code>					inherited := true</code></span>
<span class="codeline" id="line-418"><code>					switch {</code></span>
<span class="codeline" id="line-419"><code>					case s.Type != nil || len(s.Values) &gt; 0:</code></span>
<span class="codeline" id="line-420"><code>						last = s</code></span>
<span class="codeline" id="line-421"><code>						inherited = false</code></span>
<span class="codeline" id="line-422"><code>					case last == nil:</code></span>
<span class="codeline" id="line-423"><code>						last = new(ast.ValueSpec) // make sure last exists</code></span>
<span class="codeline" id="line-424"><code>						inherited = false</code></span>
<span class="codeline" id="line-425"><code>					}</code></span>
<span class="codeline" id="line-426"><code>					check.arityMatch(s, last)</code></span>
<span class="codeline" id="line-427"><code>					f(constDecl{spec: s, iota: iota, typ: last.Type, init: last.Values, inherited: inherited})</code></span>
<span class="codeline" id="line-428"><code>				case token.VAR:</code></span>
<span class="codeline" id="line-429"><code>					check.arityMatch(s, nil)</code></span>
<span class="codeline" id="line-430"><code>					f(varDecl{s})</code></span>
<span class="codeline" id="line-431"><code>				default:</code></span>
<span class="codeline" id="line-432"><code>					check.errorf(s, InvalidSyntaxTree, "invalid token %s", d.Tok)</code></span>
<span class="codeline" id="line-433"><code>				}</code></span>
<span class="codeline" id="line-434"><code>			case *ast.TypeSpec:</code></span>
<span class="codeline" id="line-435"><code>				f(typeDecl{s})</code></span>
<span class="codeline" id="line-436"><code>			default:</code></span>
<span class="codeline" id="line-437"><code>				check.errorf(s, InvalidSyntaxTree, "unknown ast.Spec node %T", s)</code></span>
<span class="codeline" id="line-438"><code>			}</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>	case *ast.FuncDecl:</code></span>
<span class="codeline" id="line-441"><code>		f(funcDecl{d})</code></span>
<span class="codeline" id="line-442"><code>	default:</code></span>
<span class="codeline" id="line-443"><code>		check.errorf(d, InvalidSyntaxTree, "unknown ast.Decl node %T", d)</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>func (check *Checker) constDecl(obj *Const, typ, init ast.Expr, inherited bool) {</code></span>
<span class="codeline" id="line-448"><code>	assert(obj.typ == nil)</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>	// use the correct value of iota</code></span>
<span class="codeline" id="line-451"><code>	defer func(iota constant.Value, errpos positioner) {</code></span>
<span class="codeline" id="line-452"><code>		check.iota = iota</code></span>
<span class="codeline" id="line-453"><code>		check.errpos = errpos</code></span>
<span class="codeline" id="line-454"><code>	}(check.iota, check.errpos)</code></span>
<span class="codeline" id="line-455"><code>	check.iota = obj.val</code></span>
<span class="codeline" id="line-456"><code>	check.errpos = nil</code></span>
<span class="codeline" id="line-457"><code></code></span>
<span class="codeline" id="line-458"><code>	// provide valid constant value under all circumstances</code></span>
<span class="codeline" id="line-459"><code>	obj.val = constant.MakeUnknown()</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	// determine type, if any</code></span>
<span class="codeline" id="line-462"><code>	if typ != nil {</code></span>
<span class="codeline" id="line-463"><code>		t := check.typ(typ)</code></span>
<span class="codeline" id="line-464"><code>		if !isConstType(t) {</code></span>
<span class="codeline" id="line-465"><code>			// don't report an error if the type is an invalid C (defined) type</code></span>
<span class="codeline" id="line-466"><code>			// (go.dev/issue/22090)</code></span>
<span class="codeline" id="line-467"><code>			if isValid(under(t)) {</code></span>
<span class="codeline" id="line-468"><code>				check.errorf(typ, InvalidConstType, "invalid constant type %s", t)</code></span>
<span class="codeline" id="line-469"><code>			}</code></span>
<span class="codeline" id="line-470"><code>			obj.typ = Typ[Invalid]</code></span>
<span class="codeline" id="line-471"><code>			return</code></span>
<span class="codeline" id="line-472"><code>		}</code></span>
<span class="codeline" id="line-473"><code>		obj.typ = t</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>	// check initialization</code></span>
<span class="codeline" id="line-477"><code>	var x operand</code></span>
<span class="codeline" id="line-478"><code>	if init != nil {</code></span>
<span class="codeline" id="line-479"><code>		if inherited {</code></span>
<span class="codeline" id="line-480"><code>			// The initialization expression is inherited from a previous</code></span>
<span class="codeline" id="line-481"><code>			// constant declaration, and (error) positions refer to that</code></span>
<span class="codeline" id="line-482"><code>			// expression and not the current constant declaration. Use</code></span>
<span class="codeline" id="line-483"><code>			// the constant identifier position for any errors during</code></span>
<span class="codeline" id="line-484"><code>			// init expression evaluation since that is all we have</code></span>
<span class="codeline" id="line-485"><code>			// (see issues go.dev/issue/42991, go.dev/issue/42992).</code></span>
<span class="codeline" id="line-486"><code>			check.errpos = atPos(obj.pos)</code></span>
<span class="codeline" id="line-487"><code>		}</code></span>
<span class="codeline" id="line-488"><code>		check.expr(nil, &amp;x, init)</code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code>	check.initConst(obj, &amp;x)</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>func (check *Checker) varDecl(obj *Var, lhs []*Var, typ, init ast.Expr) {</code></span>
<span class="codeline" id="line-494"><code>	assert(obj.typ == nil)</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>	// determine type, if any</code></span>
<span class="codeline" id="line-497"><code>	if typ != nil {</code></span>
<span class="codeline" id="line-498"><code>		obj.typ = check.varType(typ)</code></span>
<span class="codeline" id="line-499"><code>		// We cannot spread the type to all lhs variables if there</code></span>
<span class="codeline" id="line-500"><code>		// are more than one since that would mark them as checked</code></span>
<span class="codeline" id="line-501"><code>		// (see Checker.objDecl) and the assignment of init exprs,</code></span>
<span class="codeline" id="line-502"><code>		// if any, would not be checked.</code></span>
<span class="codeline" id="line-503"><code>		//</code></span>
<span class="codeline" id="line-504"><code>		// TODO(gri) If we have no init expr, we should distribute</code></span>
<span class="codeline" id="line-505"><code>		// a given type otherwise we need to re-evalate the type</code></span>
<span class="codeline" id="line-506"><code>		// expr for each lhs variable, leading to duplicate work.</code></span>
<span class="codeline" id="line-507"><code>	}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	// check initialization</code></span>
<span class="codeline" id="line-510"><code>	if init == nil {</code></span>
<span class="codeline" id="line-511"><code>		if typ == nil {</code></span>
<span class="codeline" id="line-512"><code>			// error reported before by arityMatch</code></span>
<span class="codeline" id="line-513"><code>			obj.typ = Typ[Invalid]</code></span>
<span class="codeline" id="line-514"><code>		}</code></span>
<span class="codeline" id="line-515"><code>		return</code></span>
<span class="codeline" id="line-516"><code>	}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>	if lhs == nil || len(lhs) == 1 {</code></span>
<span class="codeline" id="line-519"><code>		assert(lhs == nil || lhs[0] == obj)</code></span>
<span class="codeline" id="line-520"><code>		var x operand</code></span>
<span class="codeline" id="line-521"><code>		check.expr(newTarget(obj.typ, obj.name), &amp;x, init)</code></span>
<span class="codeline" id="line-522"><code>		check.initVar(obj, &amp;x, "variable declaration")</code></span>
<span class="codeline" id="line-523"><code>		return</code></span>
<span class="codeline" id="line-524"><code>	}</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>	if debug {</code></span>
<span class="codeline" id="line-527"><code>		// obj must be one of lhs</code></span>
<span class="codeline" id="line-528"><code>		found := false</code></span>
<span class="codeline" id="line-529"><code>		for _, lhs := range lhs {</code></span>
<span class="codeline" id="line-530"><code>			if obj == lhs {</code></span>
<span class="codeline" id="line-531"><code>				found = true</code></span>
<span class="codeline" id="line-532"><code>				break</code></span>
<span class="codeline" id="line-533"><code>			}</code></span>
<span class="codeline" id="line-534"><code>		}</code></span>
<span class="codeline" id="line-535"><code>		if !found {</code></span>
<span class="codeline" id="line-536"><code>			panic("inconsistent lhs")</code></span>
<span class="codeline" id="line-537"><code>		}</code></span>
<span class="codeline" id="line-538"><code>	}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>	// We have multiple variables on the lhs and one init expr.</code></span>
<span class="codeline" id="line-541"><code>	// Make sure all variables have been given the same type if</code></span>
<span class="codeline" id="line-542"><code>	// one was specified, otherwise they assume the type of the</code></span>
<span class="codeline" id="line-543"><code>	// init expression values (was go.dev/issue/15755).</code></span>
<span class="codeline" id="line-544"><code>	if typ != nil {</code></span>
<span class="codeline" id="line-545"><code>		for _, lhs := range lhs {</code></span>
<span class="codeline" id="line-546"><code>			lhs.typ = obj.typ</code></span>
<span class="codeline" id="line-547"><code>		}</code></span>
<span class="codeline" id="line-548"><code>	}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>	check.initVars(lhs, []ast.Expr{init}, nil)</code></span>
<span class="codeline" id="line-551"><code>}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>// isImportedConstraint reports whether typ is an imported type constraint.</code></span>
<span class="codeline" id="line-554"><code>func (check *Checker) isImportedConstraint(typ Type) bool {</code></span>
<span class="codeline" id="line-555"><code>	named := asNamed(typ)</code></span>
<span class="codeline" id="line-556"><code>	if named == nil || named.obj.pkg == check.pkg || named.obj.pkg == nil {</code></span>
<span class="codeline" id="line-557"><code>		return false</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code>	u, _ := named.under().(*Interface)</code></span>
<span class="codeline" id="line-560"><code>	return u != nil &amp;&amp; !u.IsMethodSet()</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>func (check *Checker) typeDecl(obj *TypeName, tdecl *ast.TypeSpec, def *TypeName) {</code></span>
<span class="codeline" id="line-564"><code>	assert(obj.typ == nil)</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>	var rhs Type</code></span>
<span class="codeline" id="line-567"><code>	check.later(func() {</code></span>
<span class="codeline" id="line-568"><code>		if t := asNamed(obj.typ); t != nil { // type may be invalid</code></span>
<span class="codeline" id="line-569"><code>			check.validType(t)</code></span>
<span class="codeline" id="line-570"><code>		}</code></span>
<span class="codeline" id="line-571"><code>		// If typ is local, an error was already reported where typ is specified/defined.</code></span>
<span class="codeline" id="line-572"><code>		_ = check.isImportedConstraint(rhs) &amp;&amp; check.verifyVersionf(tdecl.Type, go1_18, "using type constraint %s", rhs)</code></span>
<span class="codeline" id="line-573"><code>	}).describef(obj, "validType(%s)", obj.Name())</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>	aliasDecl := tdecl.Assign.IsValid()</code></span>
<span class="codeline" id="line-576"><code>	if aliasDecl &amp;&amp; tdecl.TypeParams.NumFields() != 0 {</code></span>
<span class="codeline" id="line-577"><code>		// The parser will ensure this but we may still get an invalid AST.</code></span>
<span class="codeline" id="line-578"><code>		// Complain and continue as regular type definition.</code></span>
<span class="codeline" id="line-579"><code>		check.error(atPos(tdecl.Assign), BadDecl, "generic type cannot be alias")</code></span>
<span class="codeline" id="line-580"><code>		aliasDecl = false</code></span>
<span class="codeline" id="line-581"><code>	}</code></span>
<span class="codeline" id="line-582"><code></code></span>
<span class="codeline" id="line-583"><code>	// alias declaration</code></span>
<span class="codeline" id="line-584"><code>	if aliasDecl {</code></span>
<span class="codeline" id="line-585"><code>		check.verifyVersionf(atPos(tdecl.Assign), go1_9, "type aliases")</code></span>
<span class="codeline" id="line-586"><code>		if check.enableAlias {</code></span>
<span class="codeline" id="line-587"><code>			// TODO(gri) Should be able to use nil instead of Typ[Invalid] to mark</code></span>
<span class="codeline" id="line-588"><code>			//           the alias as incomplete. Currently this causes problems</code></span>
<span class="codeline" id="line-589"><code>			//           with certain cycles. Investigate.</code></span>
<span class="codeline" id="line-590"><code>			alias := check.newAlias(obj, Typ[Invalid])</code></span>
<span class="codeline" id="line-591"><code>			setDefType(def, alias)</code></span>
<span class="codeline" id="line-592"><code>			rhs = check.definedType(tdecl.Type, obj)</code></span>
<span class="codeline" id="line-593"><code>			assert(rhs != nil)</code></span>
<span class="codeline" id="line-594"><code>			alias.fromRHS = rhs</code></span>
<span class="codeline" id="line-595"><code>			Unalias(alias) // resolve alias.actual</code></span>
<span class="codeline" id="line-596"><code>		} else {</code></span>
<span class="codeline" id="line-597"><code>			check.brokenAlias(obj)</code></span>
<span class="codeline" id="line-598"><code>			rhs = check.typ(tdecl.Type)</code></span>
<span class="codeline" id="line-599"><code>			check.validAlias(obj, rhs)</code></span>
<span class="codeline" id="line-600"><code>		}</code></span>
<span class="codeline" id="line-601"><code>		return</code></span>
<span class="codeline" id="line-602"><code>	}</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>	// type definition or generic type declaration</code></span>
<span class="codeline" id="line-605"><code>	named := check.newNamed(obj, nil, nil)</code></span>
<span class="codeline" id="line-606"><code>	setDefType(def, named)</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>	if tdecl.TypeParams != nil {</code></span>
<span class="codeline" id="line-609"><code>		check.openScope(tdecl, "type parameters")</code></span>
<span class="codeline" id="line-610"><code>		defer check.closeScope()</code></span>
<span class="codeline" id="line-611"><code>		check.collectTypeParams(&amp;named.tparams, tdecl.TypeParams)</code></span>
<span class="codeline" id="line-612"><code>	}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>	// determine underlying type of named</code></span>
<span class="codeline" id="line-615"><code>	rhs = check.definedType(tdecl.Type, obj)</code></span>
<span class="codeline" id="line-616"><code>	assert(rhs != nil)</code></span>
<span class="codeline" id="line-617"><code>	named.fromRHS = rhs</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>	// If the underlying type was not set while type-checking the right-hand</code></span>
<span class="codeline" id="line-620"><code>	// side, it is invalid and an error should have been reported elsewhere.</code></span>
<span class="codeline" id="line-621"><code>	if named.underlying == nil {</code></span>
<span class="codeline" id="line-622"><code>		named.underlying = Typ[Invalid]</code></span>
<span class="codeline" id="line-623"><code>	}</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>	// Disallow a lone type parameter as the RHS of a type declaration (go.dev/issue/45639).</code></span>
<span class="codeline" id="line-626"><code>	// We don't need this restriction anymore if we make the underlying type of a type</code></span>
<span class="codeline" id="line-627"><code>	// parameter its constraint interface: if the RHS is a lone type parameter, we will</code></span>
<span class="codeline" id="line-628"><code>	// use its underlying type (like we do for any RHS in a type declaration), and its</code></span>
<span class="codeline" id="line-629"><code>	// underlying type is an interface and the type declaration is well defined.</code></span>
<span class="codeline" id="line-630"><code>	if isTypeParam(rhs) {</code></span>
<span class="codeline" id="line-631"><code>		check.error(tdecl.Type, MisplacedTypeParam, "cannot use a type parameter as RHS in type declaration")</code></span>
<span class="codeline" id="line-632"><code>		named.underlying = Typ[Invalid]</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>func (check *Checker) collectTypeParams(dst **TypeParamList, list *ast.FieldList) {</code></span>
<span class="codeline" id="line-637"><code>	var tparams []*TypeParam</code></span>
<span class="codeline" id="line-638"><code>	// Declare type parameters up-front, with empty interface as type bound.</code></span>
<span class="codeline" id="line-639"><code>	// The scope of type parameters starts at the beginning of the type parameter</code></span>
<span class="codeline" id="line-640"><code>	// list (so we can have mutually recursive parameterized interfaces).</code></span>
<span class="codeline" id="line-641"><code>	scopePos := list.Pos()</code></span>
<span class="codeline" id="line-642"><code>	for _, f := range list.List {</code></span>
<span class="codeline" id="line-643"><code>		tparams = check.declareTypeParams(tparams, f.Names, scopePos)</code></span>
<span class="codeline" id="line-644"><code>	}</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>	// Set the type parameters before collecting the type constraints because</code></span>
<span class="codeline" id="line-647"><code>	// the parameterized type may be used by the constraints (go.dev/issue/47887).</code></span>
<span class="codeline" id="line-648"><code>	// Example: type T[P T[P]] interface{}</code></span>
<span class="codeline" id="line-649"><code>	*dst = bindTParams(tparams)</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>	// Signal to cycle detection that we are in a type parameter list.</code></span>
<span class="codeline" id="line-652"><code>	// We can only be inside one type parameter list at any given time:</code></span>
<span class="codeline" id="line-653"><code>	// function closures may appear inside a type parameter list but they</code></span>
<span class="codeline" id="line-654"><code>	// cannot be generic, and their bodies are processed in delayed and</code></span>
<span class="codeline" id="line-655"><code>	// sequential fashion. Note that with each new declaration, we save</code></span>
<span class="codeline" id="line-656"><code>	// the existing environment and restore it when done; thus inTPList is</code></span>
<span class="codeline" id="line-657"><code>	// true exactly only when we are in a specific type parameter list.</code></span>
<span class="codeline" id="line-658"><code>	assert(!check.inTParamList)</code></span>
<span class="codeline" id="line-659"><code>	check.inTParamList = true</code></span>
<span class="codeline" id="line-660"><code>	defer func() {</code></span>
<span class="codeline" id="line-661"><code>		check.inTParamList = false</code></span>
<span class="codeline" id="line-662"><code>	}()</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>	index := 0</code></span>
<span class="codeline" id="line-665"><code>	for _, f := range list.List {</code></span>
<span class="codeline" id="line-666"><code>		var bound Type</code></span>
<span class="codeline" id="line-667"><code>		// NOTE: we may be able to assert that f.Type != nil here, but this is not</code></span>
<span class="codeline" id="line-668"><code>		// an invariant of the AST, so we are cautious.</code></span>
<span class="codeline" id="line-669"><code>		if f.Type != nil {</code></span>
<span class="codeline" id="line-670"><code>			bound = check.bound(f.Type)</code></span>
<span class="codeline" id="line-671"><code>			if isTypeParam(bound) {</code></span>
<span class="codeline" id="line-672"><code>				// We may be able to allow this since it is now well-defined what</code></span>
<span class="codeline" id="line-673"><code>				// the underlying type and thus type set of a type parameter is.</code></span>
<span class="codeline" id="line-674"><code>				// But we may need some additional form of cycle detection within</code></span>
<span class="codeline" id="line-675"><code>				// type parameter lists.</code></span>
<span class="codeline" id="line-676"><code>				check.error(f.Type, MisplacedTypeParam, "cannot use a type parameter as constraint")</code></span>
<span class="codeline" id="line-677"><code>				bound = Typ[Invalid]</code></span>
<span class="codeline" id="line-678"><code>			}</code></span>
<span class="codeline" id="line-679"><code>		} else {</code></span>
<span class="codeline" id="line-680"><code>			bound = Typ[Invalid]</code></span>
<span class="codeline" id="line-681"><code>		}</code></span>
<span class="codeline" id="line-682"><code>		for i := range f.Names {</code></span>
<span class="codeline" id="line-683"><code>			tparams[index+i].bound = bound</code></span>
<span class="codeline" id="line-684"><code>		}</code></span>
<span class="codeline" id="line-685"><code>		index += len(f.Names)</code></span>
<span class="codeline" id="line-686"><code>	}</code></span>
<span class="codeline" id="line-687"><code>}</code></span>
<span class="codeline" id="line-688"><code></code></span>
<span class="codeline" id="line-689"><code>func (check *Checker) bound(x ast.Expr) Type {</code></span>
<span class="codeline" id="line-690"><code>	// A type set literal of the form ~T and A|B may only appear as constraint;</code></span>
<span class="codeline" id="line-691"><code>	// embed it in an implicit interface so that only interface type-checking</code></span>
<span class="codeline" id="line-692"><code>	// needs to take care of such type expressions.</code></span>
<span class="codeline" id="line-693"><code>	wrap := false</code></span>
<span class="codeline" id="line-694"><code>	switch op := x.(type) {</code></span>
<span class="codeline" id="line-695"><code>	case *ast.UnaryExpr:</code></span>
<span class="codeline" id="line-696"><code>		wrap = op.Op == token.TILDE</code></span>
<span class="codeline" id="line-697"><code>	case *ast.BinaryExpr:</code></span>
<span class="codeline" id="line-698"><code>		wrap = op.Op == token.OR</code></span>
<span class="codeline" id="line-699"><code>	}</code></span>
<span class="codeline" id="line-700"><code>	if wrap {</code></span>
<span class="codeline" id="line-701"><code>		x = &amp;ast.InterfaceType{Methods: &amp;ast.FieldList{List: []*ast.Field{{Type: x}}}}</code></span>
<span class="codeline" id="line-702"><code>		t := check.typ(x)</code></span>
<span class="codeline" id="line-703"><code>		// mark t as implicit interface if all went well</code></span>
<span class="codeline" id="line-704"><code>		if t, _ := t.(*Interface); t != nil {</code></span>
<span class="codeline" id="line-705"><code>			t.implicit = true</code></span>
<span class="codeline" id="line-706"><code>		}</code></span>
<span class="codeline" id="line-707"><code>		return t</code></span>
<span class="codeline" id="line-708"><code>	}</code></span>
<span class="codeline" id="line-709"><code>	return check.typ(x)</code></span>
<span class="codeline" id="line-710"><code>}</code></span>
<span class="codeline" id="line-711"><code></code></span>
<span class="codeline" id="line-712"><code>func (check *Checker) declareTypeParams(tparams []*TypeParam, names []*ast.Ident, scopePos token.Pos) []*TypeParam {</code></span>
<span class="codeline" id="line-713"><code>	// Use Typ[Invalid] for the type constraint to ensure that a type</code></span>
<span class="codeline" id="line-714"><code>	// is present even if the actual constraint has not been assigned</code></span>
<span class="codeline" id="line-715"><code>	// yet.</code></span>
<span class="codeline" id="line-716"><code>	// TODO(gri) Need to systematically review all uses of type parameter</code></span>
<span class="codeline" id="line-717"><code>	//           constraints to make sure we don't rely on them if they</code></span>
<span class="codeline" id="line-718"><code>	//           are not properly set yet.</code></span>
<span class="codeline" id="line-719"><code>	for _, name := range names {</code></span>
<span class="codeline" id="line-720"><code>		tname := NewTypeName(name.Pos(), check.pkg, name.Name, nil)</code></span>
<span class="codeline" id="line-721"><code>		tpar := check.newTypeParam(tname, Typ[Invalid]) // assigns type to tpar as a side-effect</code></span>
<span class="codeline" id="line-722"><code>		check.declare(check.scope, name, tname, scopePos)</code></span>
<span class="codeline" id="line-723"><code>		tparams = append(tparams, tpar)</code></span>
<span class="codeline" id="line-724"><code>	}</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>	if check.conf._Trace &amp;&amp; len(names) &gt; 0 {</code></span>
<span class="codeline" id="line-727"><code>		check.trace(names[0].Pos(), "type params = %v", tparams[len(tparams)-len(names):])</code></span>
<span class="codeline" id="line-728"><code>	}</code></span>
<span class="codeline" id="line-729"><code></code></span>
<span class="codeline" id="line-730"><code>	return tparams</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>func (check *Checker) collectMethods(obj *TypeName) {</code></span>
<span class="codeline" id="line-734"><code>	// get associated methods</code></span>
<span class="codeline" id="line-735"><code>	// (Checker.collectObjects only collects methods with non-blank names;</code></span>
<span class="codeline" id="line-736"><code>	// Checker.resolveBaseTypeName ensures that obj is not an alias name</code></span>
<span class="codeline" id="line-737"><code>	// if it has attached methods.)</code></span>
<span class="codeline" id="line-738"><code>	methods := check.methods[obj]</code></span>
<span class="codeline" id="line-739"><code>	if methods == nil {</code></span>
<span class="codeline" id="line-740"><code>		return</code></span>
<span class="codeline" id="line-741"><code>	}</code></span>
<span class="codeline" id="line-742"><code>	delete(check.methods, obj)</code></span>
<span class="codeline" id="line-743"><code>	assert(!check.objMap[obj].tdecl.Assign.IsValid()) // don't use TypeName.IsAlias (requires fully set up object)</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>	// use an objset to check for name conflicts</code></span>
<span class="codeline" id="line-746"><code>	var mset objset</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>	// spec: "If the base type is a struct type, the non-blank method</code></span>
<span class="codeline" id="line-749"><code>	// and field names must be distinct."</code></span>
<span class="codeline" id="line-750"><code>	base := asNamed(obj.typ) // shouldn't fail but be conservative</code></span>
<span class="codeline" id="line-751"><code>	if base != nil {</code></span>
<span class="codeline" id="line-752"><code>		assert(base.TypeArgs().Len() == 0) // collectMethods should not be called on an instantiated type</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>		// See go.dev/issue/52529: we must delay the expansion of underlying here, as</code></span>
<span class="codeline" id="line-755"><code>		// base may not be fully set-up.</code></span>
<span class="codeline" id="line-756"><code>		check.later(func() {</code></span>
<span class="codeline" id="line-757"><code>			check.checkFieldUniqueness(base)</code></span>
<span class="codeline" id="line-758"><code>		}).describef(obj, "verifying field uniqueness for %v", base)</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>		// Checker.Files may be called multiple times; additional package files</code></span>
<span class="codeline" id="line-761"><code>		// may add methods to already type-checked types. Add pre-existing methods</code></span>
<span class="codeline" id="line-762"><code>		// so that we can detect redeclarations.</code></span>
<span class="codeline" id="line-763"><code>		for i := 0; i &lt; base.NumMethods(); i++ {</code></span>
<span class="codeline" id="line-764"><code>			m := base.Method(i)</code></span>
<span class="codeline" id="line-765"><code>			assert(m.name != "_")</code></span>
<span class="codeline" id="line-766"><code>			assert(mset.insert(m) == nil)</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code>	}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	// add valid methods</code></span>
<span class="codeline" id="line-771"><code>	for _, m := range methods {</code></span>
<span class="codeline" id="line-772"><code>		// spec: "For a base type, the non-blank names of methods bound</code></span>
<span class="codeline" id="line-773"><code>		// to it must be unique."</code></span>
<span class="codeline" id="line-774"><code>		assert(m.name != "_")</code></span>
<span class="codeline" id="line-775"><code>		if alt := mset.insert(m); alt != nil {</code></span>
<span class="codeline" id="line-776"><code>			if alt.Pos().IsValid() {</code></span>
<span class="codeline" id="line-777"><code>				check.errorf(m, DuplicateMethod, "method %s.%s already declared at %s", obj.Name(), m.name, alt.Pos())</code></span>
<span class="codeline" id="line-778"><code>			} else {</code></span>
<span class="codeline" id="line-779"><code>				check.errorf(m, DuplicateMethod, "method %s.%s already declared", obj.Name(), m.name)</code></span>
<span class="codeline" id="line-780"><code>			}</code></span>
<span class="codeline" id="line-781"><code>			continue</code></span>
<span class="codeline" id="line-782"><code>		}</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>		if base != nil {</code></span>
<span class="codeline" id="line-785"><code>			base.AddMethod(m)</code></span>
<span class="codeline" id="line-786"><code>		}</code></span>
<span class="codeline" id="line-787"><code>	}</code></span>
<span class="codeline" id="line-788"><code>}</code></span>
<span class="codeline" id="line-789"><code></code></span>
<span class="codeline" id="line-790"><code>func (check *Checker) checkFieldUniqueness(base *Named) {</code></span>
<span class="codeline" id="line-791"><code>	if t, _ := base.under().(*Struct); t != nil {</code></span>
<span class="codeline" id="line-792"><code>		var mset objset</code></span>
<span class="codeline" id="line-793"><code>		for i := 0; i &lt; base.NumMethods(); i++ {</code></span>
<span class="codeline" id="line-794"><code>			m := base.Method(i)</code></span>
<span class="codeline" id="line-795"><code>			assert(m.name != "_")</code></span>
<span class="codeline" id="line-796"><code>			assert(mset.insert(m) == nil)</code></span>
<span class="codeline" id="line-797"><code>		}</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>		// Check that any non-blank field names of base are distinct from its</code></span>
<span class="codeline" id="line-800"><code>		// method names.</code></span>
<span class="codeline" id="line-801"><code>		for _, fld := range t.fields {</code></span>
<span class="codeline" id="line-802"><code>			if fld.name != "_" {</code></span>
<span class="codeline" id="line-803"><code>				if alt := mset.insert(fld); alt != nil {</code></span>
<span class="codeline" id="line-804"><code>					// Struct fields should already be unique, so we should only</code></span>
<span class="codeline" id="line-805"><code>					// encounter an alternate via collision with a method name.</code></span>
<span class="codeline" id="line-806"><code>					_ = alt.(*Func)</code></span>
<span class="codeline" id="line-807"><code></code></span>
<span class="codeline" id="line-808"><code>					// For historical consistency, we report the primary error on the</code></span>
<span class="codeline" id="line-809"><code>					// method, and the alt decl on the field.</code></span>
<span class="codeline" id="line-810"><code>					check.errorf(alt, DuplicateFieldAndMethod, "field and method with the same name %s", fld.name)</code></span>
<span class="codeline" id="line-811"><code>					check.reportAltDecl(fld)</code></span>
<span class="codeline" id="line-812"><code>				}</code></span>
<span class="codeline" id="line-813"><code>			}</code></span>
<span class="codeline" id="line-814"><code>		}</code></span>
<span class="codeline" id="line-815"><code>	}</code></span>
<span class="codeline" id="line-816"><code>}</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>func (check *Checker) funcDecl(obj *Func, decl *declInfo) {</code></span>
<span class="codeline" id="line-819"><code>	assert(obj.typ == nil)</code></span>
<span class="codeline" id="line-820"><code></code></span>
<span class="codeline" id="line-821"><code>	// func declarations cannot use iota</code></span>
<span class="codeline" id="line-822"><code>	assert(check.iota == nil)</code></span>
<span class="codeline" id="line-823"><code></code></span>
<span class="codeline" id="line-824"><code>	sig := new(Signature)</code></span>
<span class="codeline" id="line-825"><code>	obj.typ = sig // guard against cycles</code></span>
<span class="codeline" id="line-826"><code></code></span>
<span class="codeline" id="line-827"><code>	// Avoid cycle error when referring to method while type-checking the signature.</code></span>
<span class="codeline" id="line-828"><code>	// This avoids a nuisance in the best case (non-parameterized receiver type) and</code></span>
<span class="codeline" id="line-829"><code>	// since the method is not a type, we get an error. If we have a parameterized</code></span>
<span class="codeline" id="line-830"><code>	// receiver type, instantiating the receiver type leads to the instantiation of</code></span>
<span class="codeline" id="line-831"><code>	// its methods, and we don't want a cycle error in that case.</code></span>
<span class="codeline" id="line-832"><code>	// TODO(gri) review if this is correct and/or whether we still need this?</code></span>
<span class="codeline" id="line-833"><code>	saved := obj.color_</code></span>
<span class="codeline" id="line-834"><code>	obj.color_ = black</code></span>
<span class="codeline" id="line-835"><code>	fdecl := decl.fdecl</code></span>
<span class="codeline" id="line-836"><code>	check.funcType(sig, fdecl.Recv, fdecl.Type)</code></span>
<span class="codeline" id="line-837"><code>	obj.color_ = saved</code></span>
<span class="codeline" id="line-838"><code></code></span>
<span class="codeline" id="line-839"><code>	// Set the scope's extent to the complete "func (...) { ... }"</code></span>
<span class="codeline" id="line-840"><code>	// so that Scope.Innermost works correctly.</code></span>
<span class="codeline" id="line-841"><code>	sig.scope.pos = fdecl.Pos()</code></span>
<span class="codeline" id="line-842"><code>	sig.scope.end = fdecl.End()</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>	if fdecl.Type.TypeParams.NumFields() &gt; 0 &amp;&amp; fdecl.Body == nil {</code></span>
<span class="codeline" id="line-845"><code>		check.softErrorf(fdecl.Name, BadDecl, "generic function is missing function body")</code></span>
<span class="codeline" id="line-846"><code>	}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>	// function body must be type-checked after global declarations</code></span>
<span class="codeline" id="line-849"><code>	// (functions implemented elsewhere have no body)</code></span>
<span class="codeline" id="line-850"><code>	if !check.conf.IgnoreFuncBodies &amp;&amp; fdecl.Body != nil {</code></span>
<span class="codeline" id="line-851"><code>		check.later(func() {</code></span>
<span class="codeline" id="line-852"><code>			check.funcBody(decl, obj.name, sig, fdecl.Body, nil)</code></span>
<span class="codeline" id="line-853"><code>		}).describef(obj, "func %s", obj.name)</code></span>
<span class="codeline" id="line-854"><code>	}</code></span>
<span class="codeline" id="line-855"><code>}</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>func (check *Checker) declStmt(d ast.Decl) {</code></span>
<span class="codeline" id="line-858"><code>	pkg := check.pkg</code></span>
<span class="codeline" id="line-859"><code></code></span>
<span class="codeline" id="line-860"><code>	check.walkDecl(d, func(d decl) {</code></span>
<span class="codeline" id="line-861"><code>		switch d := d.(type) {</code></span>
<span class="codeline" id="line-862"><code>		case constDecl:</code></span>
<span class="codeline" id="line-863"><code>			top := len(check.delayed)</code></span>
<span class="codeline" id="line-864"><code></code></span>
<span class="codeline" id="line-865"><code>			// declare all constants</code></span>
<span class="codeline" id="line-866"><code>			lhs := make([]*Const, len(d.spec.Names))</code></span>
<span class="codeline" id="line-867"><code>			for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-868"><code>				obj := NewConst(name.Pos(), pkg, name.Name, nil, constant.MakeInt64(int64(d.iota)))</code></span>
<span class="codeline" id="line-869"><code>				lhs[i] = obj</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>				var init ast.Expr</code></span>
<span class="codeline" id="line-872"><code>				if i &lt; len(d.init) {</code></span>
<span class="codeline" id="line-873"><code>					init = d.init[i]</code></span>
<span class="codeline" id="line-874"><code>				}</code></span>
<span class="codeline" id="line-875"><code></code></span>
<span class="codeline" id="line-876"><code>				check.constDecl(obj, d.typ, init, d.inherited)</code></span>
<span class="codeline" id="line-877"><code>			}</code></span>
<span class="codeline" id="line-878"><code></code></span>
<span class="codeline" id="line-879"><code>			// process function literals in init expressions before scope changes</code></span>
<span class="codeline" id="line-880"><code>			check.processDelayed(top)</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>			// spec: "The scope of a constant or variable identifier declared</code></span>
<span class="codeline" id="line-883"><code>			// inside a function begins at the end of the ConstSpec or VarSpec</code></span>
<span class="codeline" id="line-884"><code>			// (ShortVarDecl for short variable declarations) and ends at the</code></span>
<span class="codeline" id="line-885"><code>			// end of the innermost containing block."</code></span>
<span class="codeline" id="line-886"><code>			scopePos := d.spec.End()</code></span>
<span class="codeline" id="line-887"><code>			for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-888"><code>				check.declare(check.scope, name, lhs[i], scopePos)</code></span>
<span class="codeline" id="line-889"><code>			}</code></span>
<span class="codeline" id="line-890"><code></code></span>
<span class="codeline" id="line-891"><code>		case varDecl:</code></span>
<span class="codeline" id="line-892"><code>			top := len(check.delayed)</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>			lhs0 := make([]*Var, len(d.spec.Names))</code></span>
<span class="codeline" id="line-895"><code>			for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-896"><code>				lhs0[i] = NewVar(name.Pos(), pkg, name.Name, nil)</code></span>
<span class="codeline" id="line-897"><code>			}</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>			// initialize all variables</code></span>
<span class="codeline" id="line-900"><code>			for i, obj := range lhs0 {</code></span>
<span class="codeline" id="line-901"><code>				var lhs []*Var</code></span>
<span class="codeline" id="line-902"><code>				var init ast.Expr</code></span>
<span class="codeline" id="line-903"><code>				switch len(d.spec.Values) {</code></span>
<span class="codeline" id="line-904"><code>				case len(d.spec.Names):</code></span>
<span class="codeline" id="line-905"><code>					// lhs and rhs match</code></span>
<span class="codeline" id="line-906"><code>					init = d.spec.Values[i]</code></span>
<span class="codeline" id="line-907"><code>				case 1:</code></span>
<span class="codeline" id="line-908"><code>					// rhs is expected to be a multi-valued expression</code></span>
<span class="codeline" id="line-909"><code>					lhs = lhs0</code></span>
<span class="codeline" id="line-910"><code>					init = d.spec.Values[0]</code></span>
<span class="codeline" id="line-911"><code>				default:</code></span>
<span class="codeline" id="line-912"><code>					if i &lt; len(d.spec.Values) {</code></span>
<span class="codeline" id="line-913"><code>						init = d.spec.Values[i]</code></span>
<span class="codeline" id="line-914"><code>					}</code></span>
<span class="codeline" id="line-915"><code>				}</code></span>
<span class="codeline" id="line-916"><code>				check.varDecl(obj, lhs, d.spec.Type, init)</code></span>
<span class="codeline" id="line-917"><code>				if len(d.spec.Values) == 1 {</code></span>
<span class="codeline" id="line-918"><code>					// If we have a single lhs variable we are done either way.</code></span>
<span class="codeline" id="line-919"><code>					// If we have a single rhs expression, it must be a multi-</code></span>
<span class="codeline" id="line-920"><code>					// valued expression, in which case handling the first lhs</code></span>
<span class="codeline" id="line-921"><code>					// variable will cause all lhs variables to have a type</code></span>
<span class="codeline" id="line-922"><code>					// assigned, and we are done as well.</code></span>
<span class="codeline" id="line-923"><code>					if debug {</code></span>
<span class="codeline" id="line-924"><code>						for _, obj := range lhs0 {</code></span>
<span class="codeline" id="line-925"><code>							assert(obj.typ != nil)</code></span>
<span class="codeline" id="line-926"><code>						}</code></span>
<span class="codeline" id="line-927"><code>					}</code></span>
<span class="codeline" id="line-928"><code>					break</code></span>
<span class="codeline" id="line-929"><code>				}</code></span>
<span class="codeline" id="line-930"><code>			}</code></span>
<span class="codeline" id="line-931"><code></code></span>
<span class="codeline" id="line-932"><code>			// process function literals in init expressions before scope changes</code></span>
<span class="codeline" id="line-933"><code>			check.processDelayed(top)</code></span>
<span class="codeline" id="line-934"><code></code></span>
<span class="codeline" id="line-935"><code>			// declare all variables</code></span>
<span class="codeline" id="line-936"><code>			// (only at this point are the variable scopes (parents) set)</code></span>
<span class="codeline" id="line-937"><code>			scopePos := d.spec.End() // see constant declarations</code></span>
<span class="codeline" id="line-938"><code>			for i, name := range d.spec.Names {</code></span>
<span class="codeline" id="line-939"><code>				// see constant declarations</code></span>
<span class="codeline" id="line-940"><code>				check.declare(check.scope, name, lhs0[i], scopePos)</code></span>
<span class="codeline" id="line-941"><code>			}</code></span>
<span class="codeline" id="line-942"><code></code></span>
<span class="codeline" id="line-943"><code>		case typeDecl:</code></span>
<span class="codeline" id="line-944"><code>			obj := NewTypeName(d.spec.Name.Pos(), pkg, d.spec.Name.Name, nil)</code></span>
<span class="codeline" id="line-945"><code>			// spec: "The scope of a type identifier declared inside a function</code></span>
<span class="codeline" id="line-946"><code>			// begins at the identifier in the TypeSpec and ends at the end of</code></span>
<span class="codeline" id="line-947"><code>			// the innermost containing block."</code></span>
<span class="codeline" id="line-948"><code>			scopePos := d.spec.Name.Pos()</code></span>
<span class="codeline" id="line-949"><code>			check.declare(check.scope, d.spec.Name, obj, scopePos)</code></span>
<span class="codeline" id="line-950"><code>			// mark and unmark type before calling typeDecl; its type is still nil (see Checker.objDecl)</code></span>
<span class="codeline" id="line-951"><code>			obj.setColor(grey + color(check.push(obj)))</code></span>
<span class="codeline" id="line-952"><code>			check.typeDecl(obj, d.spec, nil)</code></span>
<span class="codeline" id="line-953"><code>			check.pop().setColor(black)</code></span>
<span class="codeline" id="line-954"><code>		default:</code></span>
<span class="codeline" id="line-955"><code>			check.errorf(d.node(), InvalidSyntaxTree, "unknown ast.Decl node %T", d.node())</code></span>
<span class="codeline" id="line-956"><code>		}</code></span>
<span class="codeline" id="line-957"><code>	})</code></span>
<span class="codeline" id="line-958"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>