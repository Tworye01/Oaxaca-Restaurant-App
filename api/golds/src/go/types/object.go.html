<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: object.go in package go/types</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	object.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/go/types.html">go/types</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by "go test -run=Generate -write=all"; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-4"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-5"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package types</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"bytes"</code></span>
<span class="codeline" id="line-11"><code>	"fmt"</code></span>
<span class="codeline" id="line-12"><code>	"go/constant"</code></span>
<span class="codeline" id="line-13"><code>	"go/token"</code></span>
<span class="codeline" id="line-14"><code>	"unicode"</code></span>
<span class="codeline" id="line-15"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-16"><code>)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// An Object describes a named language entity such as a package,</code></span>
<span class="codeline" id="line-19"><code>// constant, type, variable, function (incl. methods), or label.</code></span>
<span class="codeline" id="line-20"><code>// All objects implement the Object interface.</code></span>
<span class="codeline" id="line-21"><code>type Object interface {</code></span>
<span class="codeline" id="line-22"><code>	Parent() *Scope // scope in which this object is declared; nil for methods and struct fields</code></span>
<span class="codeline" id="line-23"><code>	Pos() token.Pos // position of object identifier in declaration</code></span>
<span class="codeline" id="line-24"><code>	Pkg() *Package  // package to which this object belongs; nil for labels and objects in the Universe scope</code></span>
<span class="codeline" id="line-25"><code>	Name() string   // package local object name</code></span>
<span class="codeline" id="line-26"><code>	Type() Type     // object type</code></span>
<span class="codeline" id="line-27"><code>	Exported() bool // reports whether the name starts with a capital letter</code></span>
<span class="codeline" id="line-28"><code>	Id() string     // object name if exported, qualified name if not exported (see func Id)</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>	// String returns a human-readable string of the object.</code></span>
<span class="codeline" id="line-31"><code>	String() string</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>	// order reflects a package-level object's source order: if object</code></span>
<span class="codeline" id="line-34"><code>	// a is before object b in the source, then a.order() &lt; b.order().</code></span>
<span class="codeline" id="line-35"><code>	// order returns a value &gt; 0 for package-level objects; it returns</code></span>
<span class="codeline" id="line-36"><code>	// 0 for all other objects (including objects in file scopes).</code></span>
<span class="codeline" id="line-37"><code>	order() uint32</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>	// color returns the object's color.</code></span>
<span class="codeline" id="line-40"><code>	color() color</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>	// setType sets the type of the object.</code></span>
<span class="codeline" id="line-43"><code>	setType(Type)</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>	// setOrder sets the order number of the object. It must be &gt; 0.</code></span>
<span class="codeline" id="line-46"><code>	setOrder(uint32)</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>	// setColor sets the object's color. It must not be white.</code></span>
<span class="codeline" id="line-49"><code>	setColor(color color)</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>	// setParent sets the parent scope of the object.</code></span>
<span class="codeline" id="line-52"><code>	setParent(*Scope)</code></span>
<span class="codeline" id="line-53"><code></code></span>
<span class="codeline" id="line-54"><code>	// sameId reports whether obj.Id() and Id(pkg, name) are the same.</code></span>
<span class="codeline" id="line-55"><code>	sameId(pkg *Package, name string) bool</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>	// scopePos returns the start position of the scope of this Object</code></span>
<span class="codeline" id="line-58"><code>	scopePos() token.Pos</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	// setScopePos sets the start position of the scope for this Object.</code></span>
<span class="codeline" id="line-61"><code>	setScopePos(pos token.Pos)</code></span>
<span class="codeline" id="line-62"><code>}</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>func isExported(name string) bool {</code></span>
<span class="codeline" id="line-65"><code>	ch, _ := utf8.DecodeRuneInString(name)</code></span>
<span class="codeline" id="line-66"><code>	return unicode.IsUpper(ch)</code></span>
<span class="codeline" id="line-67"><code>}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>// Id returns name if it is exported, otherwise it</code></span>
<span class="codeline" id="line-70"><code>// returns the name qualified with the package path.</code></span>
<span class="codeline" id="line-71"><code>func Id(pkg *Package, name string) string {</code></span>
<span class="codeline" id="line-72"><code>	if isExported(name) {</code></span>
<span class="codeline" id="line-73"><code>		return name</code></span>
<span class="codeline" id="line-74"><code>	}</code></span>
<span class="codeline" id="line-75"><code>	// unexported names need the package path for differentiation</code></span>
<span class="codeline" id="line-76"><code>	// (if there's no package, make sure we don't start with '.'</code></span>
<span class="codeline" id="line-77"><code>	// as that may change the order of methods between a setup</code></span>
<span class="codeline" id="line-78"><code>	// inside a package and outside a package - which breaks some</code></span>
<span class="codeline" id="line-79"><code>	// tests)</code></span>
<span class="codeline" id="line-80"><code>	path := "_"</code></span>
<span class="codeline" id="line-81"><code>	// pkg is nil for objects in Universe scope and possibly types</code></span>
<span class="codeline" id="line-82"><code>	// introduced via Eval (see also comment in object.sameId)</code></span>
<span class="codeline" id="line-83"><code>	if pkg != nil &amp;&amp; pkg.path != "" {</code></span>
<span class="codeline" id="line-84"><code>		path = pkg.path</code></span>
<span class="codeline" id="line-85"><code>	}</code></span>
<span class="codeline" id="line-86"><code>	return path + "." + name</code></span>
<span class="codeline" id="line-87"><code>}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>// An object implements the common parts of an Object.</code></span>
<span class="codeline" id="line-90"><code>type object struct {</code></span>
<span class="codeline" id="line-91"><code>	parent    *Scope</code></span>
<span class="codeline" id="line-92"><code>	pos       token.Pos</code></span>
<span class="codeline" id="line-93"><code>	pkg       *Package</code></span>
<span class="codeline" id="line-94"><code>	name      string</code></span>
<span class="codeline" id="line-95"><code>	typ       Type</code></span>
<span class="codeline" id="line-96"><code>	order_    uint32</code></span>
<span class="codeline" id="line-97"><code>	color_    color</code></span>
<span class="codeline" id="line-98"><code>	scopePos_ token.Pos</code></span>
<span class="codeline" id="line-99"><code>}</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>// color encodes the color of an object (see Checker.objDecl for details).</code></span>
<span class="codeline" id="line-102"><code>type color uint32</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>// An object may be painted in one of three colors.</code></span>
<span class="codeline" id="line-105"><code>// Color values other than white or black are considered grey.</code></span>
<span class="codeline" id="line-106"><code>const (</code></span>
<span class="codeline" id="line-107"><code>	white color = iota</code></span>
<span class="codeline" id="line-108"><code>	black</code></span>
<span class="codeline" id="line-109"><code>	grey // must be &gt; white and black</code></span>
<span class="codeline" id="line-110"><code>)</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>func (c color) String() string {</code></span>
<span class="codeline" id="line-113"><code>	switch c {</code></span>
<span class="codeline" id="line-114"><code>	case white:</code></span>
<span class="codeline" id="line-115"><code>		return "white"</code></span>
<span class="codeline" id="line-116"><code>	case black:</code></span>
<span class="codeline" id="line-117"><code>		return "black"</code></span>
<span class="codeline" id="line-118"><code>	default:</code></span>
<span class="codeline" id="line-119"><code>		return "grey"</code></span>
<span class="codeline" id="line-120"><code>	}</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// colorFor returns the (initial) color for an object depending on</code></span>
<span class="codeline" id="line-124"><code>// whether its type t is known or not.</code></span>
<span class="codeline" id="line-125"><code>func colorFor(t Type) color {</code></span>
<span class="codeline" id="line-126"><code>	if t != nil {</code></span>
<span class="codeline" id="line-127"><code>		return black</code></span>
<span class="codeline" id="line-128"><code>	}</code></span>
<span class="codeline" id="line-129"><code>	return white</code></span>
<span class="codeline" id="line-130"><code>}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>// Parent returns the scope in which the object is declared.</code></span>
<span class="codeline" id="line-133"><code>// The result is nil for methods and struct fields.</code></span>
<span class="codeline" id="line-134"><code>func (obj *object) Parent() *Scope { return obj.parent }</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// Pos returns the declaration position of the object's identifier.</code></span>
<span class="codeline" id="line-137"><code>func (obj *object) Pos() token.Pos { return obj.pos }</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>// Pkg returns the package to which the object belongs.</code></span>
<span class="codeline" id="line-140"><code>// The result is nil for labels and objects in the Universe scope.</code></span>
<span class="codeline" id="line-141"><code>func (obj *object) Pkg() *Package { return obj.pkg }</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// Name returns the object's (package-local, unqualified) name.</code></span>
<span class="codeline" id="line-144"><code>func (obj *object) Name() string { return obj.name }</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>// Type returns the object's type.</code></span>
<span class="codeline" id="line-147"><code>func (obj *object) Type() Type { return obj.typ }</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>// Exported reports whether the object is exported (starts with a capital letter).</code></span>
<span class="codeline" id="line-150"><code>// It doesn't take into account whether the object is in a local (function) scope</code></span>
<span class="codeline" id="line-151"><code>// or not.</code></span>
<span class="codeline" id="line-152"><code>func (obj *object) Exported() bool { return isExported(obj.name) }</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>// Id is a wrapper for Id(obj.Pkg(), obj.Name()).</code></span>
<span class="codeline" id="line-155"><code>func (obj *object) Id() string { return Id(obj.pkg, obj.name) }</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>func (obj *object) String() string      { panic("abstract") }</code></span>
<span class="codeline" id="line-158"><code>func (obj *object) order() uint32       { return obj.order_ }</code></span>
<span class="codeline" id="line-159"><code>func (obj *object) color() color        { return obj.color_ }</code></span>
<span class="codeline" id="line-160"><code>func (obj *object) scopePos() token.Pos { return obj.scopePos_ }</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>func (obj *object) setParent(parent *Scope)   { obj.parent = parent }</code></span>
<span class="codeline" id="line-163"><code>func (obj *object) setType(typ Type)          { obj.typ = typ }</code></span>
<span class="codeline" id="line-164"><code>func (obj *object) setOrder(order uint32)     { assert(order &gt; 0); obj.order_ = order }</code></span>
<span class="codeline" id="line-165"><code>func (obj *object) setColor(color color)      { assert(color != white); obj.color_ = color }</code></span>
<span class="codeline" id="line-166"><code>func (obj *object) setScopePos(pos token.Pos) { obj.scopePos_ = pos }</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>func (obj *object) sameId(pkg *Package, name string) bool {</code></span>
<span class="codeline" id="line-169"><code>	// spec:</code></span>
<span class="codeline" id="line-170"><code>	// "Two identifiers are different if they are spelled differently,</code></span>
<span class="codeline" id="line-171"><code>	// or if they appear in different packages and are not exported.</code></span>
<span class="codeline" id="line-172"><code>	// Otherwise, they are the same."</code></span>
<span class="codeline" id="line-173"><code>	if name != obj.name {</code></span>
<span class="codeline" id="line-174"><code>		return false</code></span>
<span class="codeline" id="line-175"><code>	}</code></span>
<span class="codeline" id="line-176"><code>	// obj.Name == name</code></span>
<span class="codeline" id="line-177"><code>	if obj.Exported() {</code></span>
<span class="codeline" id="line-178"><code>		return true</code></span>
<span class="codeline" id="line-179"><code>	}</code></span>
<span class="codeline" id="line-180"><code>	// not exported, so packages must be the same (pkg == nil for</code></span>
<span class="codeline" id="line-181"><code>	// fields in Universe scope; this can only happen for types</code></span>
<span class="codeline" id="line-182"><code>	// introduced via Eval)</code></span>
<span class="codeline" id="line-183"><code>	if pkg == nil || obj.pkg == nil {</code></span>
<span class="codeline" id="line-184"><code>		return pkg == obj.pkg</code></span>
<span class="codeline" id="line-185"><code>	}</code></span>
<span class="codeline" id="line-186"><code>	// pkg != nil &amp;&amp; obj.pkg != nil</code></span>
<span class="codeline" id="line-187"><code>	return pkg.path == obj.pkg.path</code></span>
<span class="codeline" id="line-188"><code>}</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>// less reports whether object a is ordered before object b.</code></span>
<span class="codeline" id="line-191"><code>//</code></span>
<span class="codeline" id="line-192"><code>// Objects are ordered nil before non-nil, exported before</code></span>
<span class="codeline" id="line-193"><code>// non-exported, then by name, and finally (for non-exported</code></span>
<span class="codeline" id="line-194"><code>// functions) by package path.</code></span>
<span class="codeline" id="line-195"><code>func (a *object) less(b *object) bool {</code></span>
<span class="codeline" id="line-196"><code>	if a == b {</code></span>
<span class="codeline" id="line-197"><code>		return false</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>	// Nil before non-nil.</code></span>
<span class="codeline" id="line-201"><code>	if a == nil {</code></span>
<span class="codeline" id="line-202"><code>		return true</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>	if b == nil {</code></span>
<span class="codeline" id="line-205"><code>		return false</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	// Exported functions before non-exported.</code></span>
<span class="codeline" id="line-209"><code>	ea := isExported(a.name)</code></span>
<span class="codeline" id="line-210"><code>	eb := isExported(b.name)</code></span>
<span class="codeline" id="line-211"><code>	if ea != eb {</code></span>
<span class="codeline" id="line-212"><code>		return ea</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>	// Order by name and then (for non-exported names) by package.</code></span>
<span class="codeline" id="line-216"><code>	if a.name != b.name {</code></span>
<span class="codeline" id="line-217"><code>		return a.name &lt; b.name</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code>	if !ea {</code></span>
<span class="codeline" id="line-220"><code>		return a.pkg.path &lt; b.pkg.path</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>	return false</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// A PkgName represents an imported Go package.</code></span>
<span class="codeline" id="line-227"><code>// PkgNames don't have a type.</code></span>
<span class="codeline" id="line-228"><code>type PkgName struct {</code></span>
<span class="codeline" id="line-229"><code>	object</code></span>
<span class="codeline" id="line-230"><code>	imported *Package</code></span>
<span class="codeline" id="line-231"><code>	used     bool // set if the package was used</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// NewPkgName returns a new PkgName object representing an imported package.</code></span>
<span class="codeline" id="line-235"><code>// The remaining arguments set the attributes found with all Objects.</code></span>
<span class="codeline" id="line-236"><code>func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName {</code></span>
<span class="codeline" id="line-237"><code>	return &amp;PkgName{object{nil, pos, pkg, name, Typ[Invalid], 0, black, nopos}, imported, false}</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// Imported returns the package that was imported.</code></span>
<span class="codeline" id="line-241"><code>// It is distinct from Pkg(), which is the package containing the import statement.</code></span>
<span class="codeline" id="line-242"><code>func (obj *PkgName) Imported() *Package { return obj.imported }</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// A Const represents a declared constant.</code></span>
<span class="codeline" id="line-245"><code>type Const struct {</code></span>
<span class="codeline" id="line-246"><code>	object</code></span>
<span class="codeline" id="line-247"><code>	val constant.Value</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// NewConst returns a new constant with value val.</code></span>
<span class="codeline" id="line-251"><code>// The remaining arguments set the attributes found with all Objects.</code></span>
<span class="codeline" id="line-252"><code>func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const {</code></span>
<span class="codeline" id="line-253"><code>	return &amp;Const{object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, val}</code></span>
<span class="codeline" id="line-254"><code>}</code></span>
<span class="codeline" id="line-255"><code></code></span>
<span class="codeline" id="line-256"><code>// Val returns the constant's value.</code></span>
<span class="codeline" id="line-257"><code>func (obj *Const) Val() constant.Value { return obj.val }</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>func (*Const) isDependency() {} // a constant may be a dependency of an initialization expression</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// A TypeName represents a name for a (defined or alias) type.</code></span>
<span class="codeline" id="line-262"><code>type TypeName struct {</code></span>
<span class="codeline" id="line-263"><code>	object</code></span>
<span class="codeline" id="line-264"><code>}</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>// NewTypeName returns a new type name denoting the given typ.</code></span>
<span class="codeline" id="line-267"><code>// The remaining arguments set the attributes found with all Objects.</code></span>
<span class="codeline" id="line-268"><code>//</code></span>
<span class="codeline" id="line-269"><code>// The typ argument may be a defined (Named) type or an alias type.</code></span>
<span class="codeline" id="line-270"><code>// It may also be nil such that the returned TypeName can be used as</code></span>
<span class="codeline" id="line-271"><code>// argument for NewNamed, which will set the TypeName's type as a side-</code></span>
<span class="codeline" id="line-272"><code>// effect.</code></span>
<span class="codeline" id="line-273"><code>func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName {</code></span>
<span class="codeline" id="line-274"><code>	return &amp;TypeName{object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}}</code></span>
<span class="codeline" id="line-275"><code>}</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// NewTypeNameLazy returns a new defined type like NewTypeName, but it</code></span>
<span class="codeline" id="line-278"><code>// lazily calls resolve to finish constructing the Named object.</code></span>
<span class="codeline" id="line-279"><code>func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying Type, methods []*Func)) *TypeName {</code></span>
<span class="codeline" id="line-280"><code>	obj := NewTypeName(pos, pkg, name, nil)</code></span>
<span class="codeline" id="line-281"><code>	NewNamed(obj, nil, nil).loader = load</code></span>
<span class="codeline" id="line-282"><code>	return obj</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// IsAlias reports whether obj is an alias name for a type.</code></span>
<span class="codeline" id="line-286"><code>func (obj *TypeName) IsAlias() bool {</code></span>
<span class="codeline" id="line-287"><code>	switch t := obj.typ.(type) {</code></span>
<span class="codeline" id="line-288"><code>	case nil:</code></span>
<span class="codeline" id="line-289"><code>		return false</code></span>
<span class="codeline" id="line-290"><code>	// case *Alias:</code></span>
<span class="codeline" id="line-291"><code>	//	handled by default case</code></span>
<span class="codeline" id="line-292"><code>	case *Basic:</code></span>
<span class="codeline" id="line-293"><code>		// unsafe.Pointer is not an alias.</code></span>
<span class="codeline" id="line-294"><code>		if obj.pkg == Unsafe {</code></span>
<span class="codeline" id="line-295"><code>			return false</code></span>
<span class="codeline" id="line-296"><code>		}</code></span>
<span class="codeline" id="line-297"><code>		// Any user-defined type name for a basic type is an alias for a</code></span>
<span class="codeline" id="line-298"><code>		// basic type (because basic types are pre-declared in the Universe</code></span>
<span class="codeline" id="line-299"><code>		// scope, outside any package scope), and so is any type name with</code></span>
<span class="codeline" id="line-300"><code>		// a different name than the name of the basic type it refers to.</code></span>
<span class="codeline" id="line-301"><code>		// Additionally, we need to look for "byte" and "rune" because they</code></span>
<span class="codeline" id="line-302"><code>		// are aliases but have the same names (for better error messages).</code></span>
<span class="codeline" id="line-303"><code>		return obj.pkg != nil || t.name != obj.name || t == universeByte || t == universeRune</code></span>
<span class="codeline" id="line-304"><code>	case *Named:</code></span>
<span class="codeline" id="line-305"><code>		return obj != t.obj</code></span>
<span class="codeline" id="line-306"><code>	case *TypeParam:</code></span>
<span class="codeline" id="line-307"><code>		return obj != t.obj</code></span>
<span class="codeline" id="line-308"><code>	default:</code></span>
<span class="codeline" id="line-309"><code>		return true</code></span>
<span class="codeline" id="line-310"><code>	}</code></span>
<span class="codeline" id="line-311"><code>}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>// A Variable represents a declared variable (including function parameters and results, and struct fields).</code></span>
<span class="codeline" id="line-314"><code>type Var struct {</code></span>
<span class="codeline" id="line-315"><code>	object</code></span>
<span class="codeline" id="line-316"><code>	embedded bool // if set, the variable is an embedded struct field, and name is the type name</code></span>
<span class="codeline" id="line-317"><code>	isField  bool // var is struct field</code></span>
<span class="codeline" id="line-318"><code>	used     bool // set if the variable was used</code></span>
<span class="codeline" id="line-319"><code>	origin   *Var // if non-nil, the Var from which this one was instantiated</code></span>
<span class="codeline" id="line-320"><code>}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>// NewVar returns a new variable.</code></span>
<span class="codeline" id="line-323"><code>// The arguments set the attributes found with all Objects.</code></span>
<span class="codeline" id="line-324"><code>func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var {</code></span>
<span class="codeline" id="line-325"><code>	return &amp;Var{object: object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}}</code></span>
<span class="codeline" id="line-326"><code>}</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>// NewParam returns a new variable representing a function parameter.</code></span>
<span class="codeline" id="line-329"><code>func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var {</code></span>
<span class="codeline" id="line-330"><code>	return &amp;Var{object: object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, used: true} // parameters are always 'used'</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>// NewField returns a new variable representing a struct field.</code></span>
<span class="codeline" id="line-334"><code>// For embedded fields, the name is the unqualified type name</code></span>
<span class="codeline" id="line-335"><code>// under which the field is accessible.</code></span>
<span class="codeline" id="line-336"><code>func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var {</code></span>
<span class="codeline" id="line-337"><code>	return &amp;Var{object: object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, embedded: embedded, isField: true}</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// Anonymous reports whether the variable is an embedded field.</code></span>
<span class="codeline" id="line-341"><code>// Same as Embedded; only present for backward-compatibility.</code></span>
<span class="codeline" id="line-342"><code>func (obj *Var) Anonymous() bool { return obj.embedded }</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>// Embedded reports whether the variable is an embedded field.</code></span>
<span class="codeline" id="line-345"><code>func (obj *Var) Embedded() bool { return obj.embedded }</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>// IsField reports whether the variable is a struct field.</code></span>
<span class="codeline" id="line-348"><code>func (obj *Var) IsField() bool { return obj.isField }</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>// Origin returns the canonical Var for its receiver, i.e. the Var object</code></span>
<span class="codeline" id="line-351"><code>// recorded in Info.Defs.</code></span>
<span class="codeline" id="line-352"><code>//</code></span>
<span class="codeline" id="line-353"><code>// For synthetic Vars created during instantiation (such as struct fields or</code></span>
<span class="codeline" id="line-354"><code>// function parameters that depend on type arguments), this will be the</code></span>
<span class="codeline" id="line-355"><code>// corresponding Var on the generic (uninstantiated) type. For all other Vars</code></span>
<span class="codeline" id="line-356"><code>// Origin returns the receiver.</code></span>
<span class="codeline" id="line-357"><code>func (obj *Var) Origin() *Var {</code></span>
<span class="codeline" id="line-358"><code>	if obj.origin != nil {</code></span>
<span class="codeline" id="line-359"><code>		return obj.origin</code></span>
<span class="codeline" id="line-360"><code>	}</code></span>
<span class="codeline" id="line-361"><code>	return obj</code></span>
<span class="codeline" id="line-362"><code>}</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>func (*Var) isDependency() {} // a variable may be a dependency of an initialization expression</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>// A Func represents a declared function, concrete method, or abstract</code></span>
<span class="codeline" id="line-367"><code>// (interface) method. Its Type() is always a *Signature.</code></span>
<span class="codeline" id="line-368"><code>// An abstract method may belong to many interfaces due to embedding.</code></span>
<span class="codeline" id="line-369"><code>type Func struct {</code></span>
<span class="codeline" id="line-370"><code>	object</code></span>
<span class="codeline" id="line-371"><code>	hasPtrRecv_ bool  // only valid for methods that don't have a type yet; use hasPtrRecv() to read</code></span>
<span class="codeline" id="line-372"><code>	origin      *Func // if non-nil, the Func from which this one was instantiated</code></span>
<span class="codeline" id="line-373"><code>}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>// NewFunc returns a new function with the given signature, representing</code></span>
<span class="codeline" id="line-376"><code>// the function's type.</code></span>
<span class="codeline" id="line-377"><code>func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func {</code></span>
<span class="codeline" id="line-378"><code>	// don't store a (typed) nil signature</code></span>
<span class="codeline" id="line-379"><code>	var typ Type</code></span>
<span class="codeline" id="line-380"><code>	if sig != nil {</code></span>
<span class="codeline" id="line-381"><code>		typ = sig</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code>	return &amp;Func{object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, false, nil}</code></span>
<span class="codeline" id="line-384"><code>}</code></span>
<span class="codeline" id="line-385"><code></code></span>
<span class="codeline" id="line-386"><code>// FullName returns the package- or receiver-type-qualified name of</code></span>
<span class="codeline" id="line-387"><code>// function or method obj.</code></span>
<span class="codeline" id="line-388"><code>func (obj *Func) FullName() string {</code></span>
<span class="codeline" id="line-389"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-390"><code>	writeFuncName(&amp;buf, obj, nil)</code></span>
<span class="codeline" id="line-391"><code>	return buf.String()</code></span>
<span class="codeline" id="line-392"><code>}</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>// Scope returns the scope of the function's body block.</code></span>
<span class="codeline" id="line-395"><code>// The result is nil for imported or instantiated functions and methods</code></span>
<span class="codeline" id="line-396"><code>// (but there is also no mechanism to get to an instantiated function).</code></span>
<span class="codeline" id="line-397"><code>func (obj *Func) Scope() *Scope { return obj.typ.(*Signature).scope }</code></span>
<span class="codeline" id="line-398"><code></code></span>
<span class="codeline" id="line-399"><code>// Origin returns the canonical Func for its receiver, i.e. the Func object</code></span>
<span class="codeline" id="line-400"><code>// recorded in Info.Defs.</code></span>
<span class="codeline" id="line-401"><code>//</code></span>
<span class="codeline" id="line-402"><code>// For synthetic functions created during instantiation (such as methods on an</code></span>
<span class="codeline" id="line-403"><code>// instantiated Named type or interface methods that depend on type arguments),</code></span>
<span class="codeline" id="line-404"><code>// this will be the corresponding Func on the generic (uninstantiated) type.</code></span>
<span class="codeline" id="line-405"><code>// For all other Funcs Origin returns the receiver.</code></span>
<span class="codeline" id="line-406"><code>func (obj *Func) Origin() *Func {</code></span>
<span class="codeline" id="line-407"><code>	if obj.origin != nil {</code></span>
<span class="codeline" id="line-408"><code>		return obj.origin</code></span>
<span class="codeline" id="line-409"><code>	}</code></span>
<span class="codeline" id="line-410"><code>	return obj</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>// Pkg returns the package to which the function belongs.</code></span>
<span class="codeline" id="line-414"><code>//</code></span>
<span class="codeline" id="line-415"><code>// The result is nil for methods of types in the Universe scope,</code></span>
<span class="codeline" id="line-416"><code>// like method Error of the error built-in interface type.</code></span>
<span class="codeline" id="line-417"><code>func (obj *Func) Pkg() *Package { return obj.object.Pkg() }</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>// hasPtrRecv reports whether the receiver is of the form *T for the given method obj.</code></span>
<span class="codeline" id="line-420"><code>func (obj *Func) hasPtrRecv() bool {</code></span>
<span class="codeline" id="line-421"><code>	// If a method's receiver type is set, use that as the source of truth for the receiver.</code></span>
<span class="codeline" id="line-422"><code>	// Caution: Checker.funcDecl (decl.go) marks a function by setting its type to an empty</code></span>
<span class="codeline" id="line-423"><code>	// signature. We may reach here before the signature is fully set up: we must explicitly</code></span>
<span class="codeline" id="line-424"><code>	// check if the receiver is set (we cannot just look for non-nil obj.typ).</code></span>
<span class="codeline" id="line-425"><code>	if sig, _ := obj.typ.(*Signature); sig != nil &amp;&amp; sig.recv != nil {</code></span>
<span class="codeline" id="line-426"><code>		_, isPtr := deref(sig.recv.typ)</code></span>
<span class="codeline" id="line-427"><code>		return isPtr</code></span>
<span class="codeline" id="line-428"><code>	}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>	// If a method's type is not set it may be a method/function that is:</code></span>
<span class="codeline" id="line-431"><code>	// 1) client-supplied (via NewFunc with no signature), or</code></span>
<span class="codeline" id="line-432"><code>	// 2) internally created but not yet type-checked.</code></span>
<span class="codeline" id="line-433"><code>	// For case 1) we can't do anything; the client must know what they are doing.</code></span>
<span class="codeline" id="line-434"><code>	// For case 2) we can use the information gathered by the resolver.</code></span>
<span class="codeline" id="line-435"><code>	return obj.hasPtrRecv_</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>func (*Func) isDependency() {} // a function may be a dependency of an initialization expression</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>// A Label represents a declared label.</code></span>
<span class="codeline" id="line-441"><code>// Labels don't have a type.</code></span>
<span class="codeline" id="line-442"><code>type Label struct {</code></span>
<span class="codeline" id="line-443"><code>	object</code></span>
<span class="codeline" id="line-444"><code>	used bool // set if the label was used</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>// NewLabel returns a new label.</code></span>
<span class="codeline" id="line-448"><code>func NewLabel(pos token.Pos, pkg *Package, name string) *Label {</code></span>
<span class="codeline" id="line-449"><code>	return &amp;Label{object{pos: pos, pkg: pkg, name: name, typ: Typ[Invalid], color_: black}, false}</code></span>
<span class="codeline" id="line-450"><code>}</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>// A Builtin represents a built-in function.</code></span>
<span class="codeline" id="line-453"><code>// Builtins don't have a valid type.</code></span>
<span class="codeline" id="line-454"><code>type Builtin struct {</code></span>
<span class="codeline" id="line-455"><code>	object</code></span>
<span class="codeline" id="line-456"><code>	id builtinId</code></span>
<span class="codeline" id="line-457"><code>}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>func newBuiltin(id builtinId) *Builtin {</code></span>
<span class="codeline" id="line-460"><code>	return &amp;Builtin{object{name: predeclaredFuncs[id].name, typ: Typ[Invalid], color_: black}, id}</code></span>
<span class="codeline" id="line-461"><code>}</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>// Nil represents the predeclared value nil.</code></span>
<span class="codeline" id="line-464"><code>type Nil struct {</code></span>
<span class="codeline" id="line-465"><code>	object</code></span>
<span class="codeline" id="line-466"><code>}</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>func writeObject(buf *bytes.Buffer, obj Object, qf Qualifier) {</code></span>
<span class="codeline" id="line-469"><code>	var tname *TypeName</code></span>
<span class="codeline" id="line-470"><code>	typ := obj.Type()</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>	switch obj := obj.(type) {</code></span>
<span class="codeline" id="line-473"><code>	case *PkgName:</code></span>
<span class="codeline" id="line-474"><code>		fmt.Fprintf(buf, "package %s", obj.Name())</code></span>
<span class="codeline" id="line-475"><code>		if path := obj.imported.path; path != "" &amp;&amp; path != obj.name {</code></span>
<span class="codeline" id="line-476"><code>			fmt.Fprintf(buf, " (%q)", path)</code></span>
<span class="codeline" id="line-477"><code>		}</code></span>
<span class="codeline" id="line-478"><code>		return</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	case *Const:</code></span>
<span class="codeline" id="line-481"><code>		buf.WriteString("const")</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	case *TypeName:</code></span>
<span class="codeline" id="line-484"><code>		tname = obj</code></span>
<span class="codeline" id="line-485"><code>		buf.WriteString("type")</code></span>
<span class="codeline" id="line-486"><code>		if isTypeParam(typ) {</code></span>
<span class="codeline" id="line-487"><code>			buf.WriteString(" parameter")</code></span>
<span class="codeline" id="line-488"><code>		}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>	case *Var:</code></span>
<span class="codeline" id="line-491"><code>		if obj.isField {</code></span>
<span class="codeline" id="line-492"><code>			buf.WriteString("field")</code></span>
<span class="codeline" id="line-493"><code>		} else {</code></span>
<span class="codeline" id="line-494"><code>			buf.WriteString("var")</code></span>
<span class="codeline" id="line-495"><code>		}</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>	case *Func:</code></span>
<span class="codeline" id="line-498"><code>		buf.WriteString("func ")</code></span>
<span class="codeline" id="line-499"><code>		writeFuncName(buf, obj, qf)</code></span>
<span class="codeline" id="line-500"><code>		if typ != nil {</code></span>
<span class="codeline" id="line-501"><code>			WriteSignature(buf, typ.(*Signature), qf)</code></span>
<span class="codeline" id="line-502"><code>		}</code></span>
<span class="codeline" id="line-503"><code>		return</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>	case *Label:</code></span>
<span class="codeline" id="line-506"><code>		buf.WriteString("label")</code></span>
<span class="codeline" id="line-507"><code>		typ = nil</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	case *Builtin:</code></span>
<span class="codeline" id="line-510"><code>		buf.WriteString("builtin")</code></span>
<span class="codeline" id="line-511"><code>		typ = nil</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	case *Nil:</code></span>
<span class="codeline" id="line-514"><code>		buf.WriteString("nil")</code></span>
<span class="codeline" id="line-515"><code>		return</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>	default:</code></span>
<span class="codeline" id="line-518"><code>		panic(fmt.Sprintf("writeObject(%T)", obj))</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>	buf.WriteByte(' ')</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	// For package-level objects, qualify the name.</code></span>
<span class="codeline" id="line-524"><code>	if obj.Pkg() != nil &amp;&amp; obj.Pkg().scope.Lookup(obj.Name()) == obj {</code></span>
<span class="codeline" id="line-525"><code>		buf.WriteString(packagePrefix(obj.Pkg(), qf))</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code>	buf.WriteString(obj.Name())</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	if typ == nil {</code></span>
<span class="codeline" id="line-530"><code>		return</code></span>
<span class="codeline" id="line-531"><code>	}</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>	if tname != nil {</code></span>
<span class="codeline" id="line-534"><code>		switch t := typ.(type) {</code></span>
<span class="codeline" id="line-535"><code>		case *Basic:</code></span>
<span class="codeline" id="line-536"><code>			// Don't print anything more for basic types since there's</code></span>
<span class="codeline" id="line-537"><code>			// no more information.</code></span>
<span class="codeline" id="line-538"><code>			return</code></span>
<span class="codeline" id="line-539"><code>		case *Named:</code></span>
<span class="codeline" id="line-540"><code>			if t.TypeParams().Len() &gt; 0 {</code></span>
<span class="codeline" id="line-541"><code>				newTypeWriter(buf, qf).tParamList(t.TypeParams().list())</code></span>
<span class="codeline" id="line-542"><code>			}</code></span>
<span class="codeline" id="line-543"><code>		}</code></span>
<span class="codeline" id="line-544"><code>		if tname.IsAlias() {</code></span>
<span class="codeline" id="line-545"><code>			buf.WriteString(" =")</code></span>
<span class="codeline" id="line-546"><code>		} else if t, _ := typ.(*TypeParam); t != nil {</code></span>
<span class="codeline" id="line-547"><code>			typ = t.bound</code></span>
<span class="codeline" id="line-548"><code>		} else {</code></span>
<span class="codeline" id="line-549"><code>			// TODO(gri) should this be fromRHS for *Named?</code></span>
<span class="codeline" id="line-550"><code>			typ = under(typ)</code></span>
<span class="codeline" id="line-551"><code>		}</code></span>
<span class="codeline" id="line-552"><code>	}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>	// Special handling for any: because WriteType will format 'any' as 'any',</code></span>
<span class="codeline" id="line-555"><code>	// resulting in the object string `type any = any` rather than `type any =</code></span>
<span class="codeline" id="line-556"><code>	// interface{}`. To avoid this, swap in a different empty interface.</code></span>
<span class="codeline" id="line-557"><code>	if obj == universeAny {</code></span>
<span class="codeline" id="line-558"><code>		assert(Identical(typ, &amp;emptyInterface))</code></span>
<span class="codeline" id="line-559"><code>		typ = &amp;emptyInterface</code></span>
<span class="codeline" id="line-560"><code>	}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>	buf.WriteByte(' ')</code></span>
<span class="codeline" id="line-563"><code>	WriteType(buf, typ, qf)</code></span>
<span class="codeline" id="line-564"><code>}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>func packagePrefix(pkg *Package, qf Qualifier) string {</code></span>
<span class="codeline" id="line-567"><code>	if pkg == nil {</code></span>
<span class="codeline" id="line-568"><code>		return ""</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>	var s string</code></span>
<span class="codeline" id="line-571"><code>	if qf != nil {</code></span>
<span class="codeline" id="line-572"><code>		s = qf(pkg)</code></span>
<span class="codeline" id="line-573"><code>	} else {</code></span>
<span class="codeline" id="line-574"><code>		s = pkg.Path()</code></span>
<span class="codeline" id="line-575"><code>	}</code></span>
<span class="codeline" id="line-576"><code>	if s != "" {</code></span>
<span class="codeline" id="line-577"><code>		s += "."</code></span>
<span class="codeline" id="line-578"><code>	}</code></span>
<span class="codeline" id="line-579"><code>	return s</code></span>
<span class="codeline" id="line-580"><code>}</code></span>
<span class="codeline" id="line-581"><code></code></span>
<span class="codeline" id="line-582"><code>// ObjectString returns the string form of obj.</code></span>
<span class="codeline" id="line-583"><code>// The Qualifier controls the printing of</code></span>
<span class="codeline" id="line-584"><code>// package-level objects, and may be nil.</code></span>
<span class="codeline" id="line-585"><code>func ObjectString(obj Object, qf Qualifier) string {</code></span>
<span class="codeline" id="line-586"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-587"><code>	writeObject(&amp;buf, obj, qf)</code></span>
<span class="codeline" id="line-588"><code>	return buf.String()</code></span>
<span class="codeline" id="line-589"><code>}</code></span>
<span class="codeline" id="line-590"><code></code></span>
<span class="codeline" id="line-591"><code>func (obj *PkgName) String() string  { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-592"><code>func (obj *Const) String() string    { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-593"><code>func (obj *TypeName) String() string { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-594"><code>func (obj *Var) String() string      { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-595"><code>func (obj *Func) String() string     { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-596"><code>func (obj *Label) String() string    { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-597"><code>func (obj *Builtin) String() string  { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-598"><code>func (obj *Nil) String() string      { return ObjectString(obj, nil) }</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>func writeFuncName(buf *bytes.Buffer, f *Func, qf Qualifier) {</code></span>
<span class="codeline" id="line-601"><code>	if f.typ != nil {</code></span>
<span class="codeline" id="line-602"><code>		sig := f.typ.(*Signature)</code></span>
<span class="codeline" id="line-603"><code>		if recv := sig.Recv(); recv != nil {</code></span>
<span class="codeline" id="line-604"><code>			buf.WriteByte('(')</code></span>
<span class="codeline" id="line-605"><code>			if _, ok := recv.Type().(*Interface); ok {</code></span>
<span class="codeline" id="line-606"><code>				// gcimporter creates abstract methods of</code></span>
<span class="codeline" id="line-607"><code>				// named interfaces using the interface type</code></span>
<span class="codeline" id="line-608"><code>				// (not the named type) as the receiver.</code></span>
<span class="codeline" id="line-609"><code>				// Don't print it in full.</code></span>
<span class="codeline" id="line-610"><code>				buf.WriteString("interface")</code></span>
<span class="codeline" id="line-611"><code>			} else {</code></span>
<span class="codeline" id="line-612"><code>				WriteType(buf, recv.Type(), qf)</code></span>
<span class="codeline" id="line-613"><code>			}</code></span>
<span class="codeline" id="line-614"><code>			buf.WriteByte(')')</code></span>
<span class="codeline" id="line-615"><code>			buf.WriteByte('.')</code></span>
<span class="codeline" id="line-616"><code>		} else if f.pkg != nil {</code></span>
<span class="codeline" id="line-617"><code>			buf.WriteString(packagePrefix(f.pkg, qf))</code></span>
<span class="codeline" id="line-618"><code>		}</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code>	buf.WriteString(f.name)</code></span>
<span class="codeline" id="line-621"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>