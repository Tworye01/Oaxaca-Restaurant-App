<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: lex.go in package text/template/parse</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	lex.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/text/template/parse.html">text/template/parse</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package parse</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"strings"</code></span>
<span class="codeline" id="line-10"><code>	"unicode"</code></span>
<span class="codeline" id="line-11"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// item represents a token or text string returned from the scanner.</code></span>
<span class="codeline" id="line-15"><code>type item struct {</code></span>
<span class="codeline" id="line-16"><code>	typ  itemType // The type of this item.</code></span>
<span class="codeline" id="line-17"><code>	pos  Pos      // The starting position, in bytes, of this item in the input string.</code></span>
<span class="codeline" id="line-18"><code>	val  string   // The value of this item.</code></span>
<span class="codeline" id="line-19"><code>	line int      // The line number at the start of this item.</code></span>
<span class="codeline" id="line-20"><code>}</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>func (i item) String() string {</code></span>
<span class="codeline" id="line-23"><code>	switch {</code></span>
<span class="codeline" id="line-24"><code>	case i.typ == itemEOF:</code></span>
<span class="codeline" id="line-25"><code>		return "EOF"</code></span>
<span class="codeline" id="line-26"><code>	case i.typ == itemError:</code></span>
<span class="codeline" id="line-27"><code>		return i.val</code></span>
<span class="codeline" id="line-28"><code>	case i.typ &gt; itemKeyword:</code></span>
<span class="codeline" id="line-29"><code>		return fmt.Sprintf("&lt;%s&gt;", i.val)</code></span>
<span class="codeline" id="line-30"><code>	case len(i.val) &gt; 10:</code></span>
<span class="codeline" id="line-31"><code>		return fmt.Sprintf("%.10q...", i.val)</code></span>
<span class="codeline" id="line-32"><code>	}</code></span>
<span class="codeline" id="line-33"><code>	return fmt.Sprintf("%q", i.val)</code></span>
<span class="codeline" id="line-34"><code>}</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// itemType identifies the type of lex items.</code></span>
<span class="codeline" id="line-37"><code>type itemType int</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>const (</code></span>
<span class="codeline" id="line-40"><code>	itemError        itemType = iota // error occurred; value is text of error</code></span>
<span class="codeline" id="line-41"><code>	itemBool                         // boolean constant</code></span>
<span class="codeline" id="line-42"><code>	itemChar                         // printable ASCII character; grab bag for comma etc.</code></span>
<span class="codeline" id="line-43"><code>	itemCharConstant                 // character constant</code></span>
<span class="codeline" id="line-44"><code>	itemComment                      // comment text</code></span>
<span class="codeline" id="line-45"><code>	itemComplex                      // complex constant (1+2i); imaginary is just a number</code></span>
<span class="codeline" id="line-46"><code>	itemAssign                       // equals ('=') introducing an assignment</code></span>
<span class="codeline" id="line-47"><code>	itemDeclare                      // colon-equals (':=') introducing a declaration</code></span>
<span class="codeline" id="line-48"><code>	itemEOF</code></span>
<span class="codeline" id="line-49"><code>	itemField      // alphanumeric identifier starting with '.'</code></span>
<span class="codeline" id="line-50"><code>	itemIdentifier // alphanumeric identifier not starting with '.'</code></span>
<span class="codeline" id="line-51"><code>	itemLeftDelim  // left action delimiter</code></span>
<span class="codeline" id="line-52"><code>	itemLeftParen  // '(' inside action</code></span>
<span class="codeline" id="line-53"><code>	itemNumber     // simple number, including imaginary</code></span>
<span class="codeline" id="line-54"><code>	itemPipe       // pipe symbol</code></span>
<span class="codeline" id="line-55"><code>	itemRawString  // raw quoted string (includes quotes)</code></span>
<span class="codeline" id="line-56"><code>	itemRightDelim // right action delimiter</code></span>
<span class="codeline" id="line-57"><code>	itemRightParen // ')' inside action</code></span>
<span class="codeline" id="line-58"><code>	itemSpace      // run of spaces separating arguments</code></span>
<span class="codeline" id="line-59"><code>	itemString     // quoted string (includes quotes)</code></span>
<span class="codeline" id="line-60"><code>	itemText       // plain text</code></span>
<span class="codeline" id="line-61"><code>	itemVariable   // variable starting with '$', such as '$' or  '$1' or '$hello'</code></span>
<span class="codeline" id="line-62"><code>	// Keywords appear after all the rest.</code></span>
<span class="codeline" id="line-63"><code>	itemKeyword  // used only to delimit the keywords</code></span>
<span class="codeline" id="line-64"><code>	itemBlock    // block keyword</code></span>
<span class="codeline" id="line-65"><code>	itemBreak    // break keyword</code></span>
<span class="codeline" id="line-66"><code>	itemContinue // continue keyword</code></span>
<span class="codeline" id="line-67"><code>	itemDot      // the cursor, spelled '.'</code></span>
<span class="codeline" id="line-68"><code>	itemDefine   // define keyword</code></span>
<span class="codeline" id="line-69"><code>	itemElse     // else keyword</code></span>
<span class="codeline" id="line-70"><code>	itemEnd      // end keyword</code></span>
<span class="codeline" id="line-71"><code>	itemIf       // if keyword</code></span>
<span class="codeline" id="line-72"><code>	itemNil      // the untyped nil constant, easiest to treat as a keyword</code></span>
<span class="codeline" id="line-73"><code>	itemRange    // range keyword</code></span>
<span class="codeline" id="line-74"><code>	itemTemplate // template keyword</code></span>
<span class="codeline" id="line-75"><code>	itemWith     // with keyword</code></span>
<span class="codeline" id="line-76"><code>)</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>var key = map[string]itemType{</code></span>
<span class="codeline" id="line-79"><code>	".":        itemDot,</code></span>
<span class="codeline" id="line-80"><code>	"block":    itemBlock,</code></span>
<span class="codeline" id="line-81"><code>	"break":    itemBreak,</code></span>
<span class="codeline" id="line-82"><code>	"continue": itemContinue,</code></span>
<span class="codeline" id="line-83"><code>	"define":   itemDefine,</code></span>
<span class="codeline" id="line-84"><code>	"else":     itemElse,</code></span>
<span class="codeline" id="line-85"><code>	"end":      itemEnd,</code></span>
<span class="codeline" id="line-86"><code>	"if":       itemIf,</code></span>
<span class="codeline" id="line-87"><code>	"range":    itemRange,</code></span>
<span class="codeline" id="line-88"><code>	"nil":      itemNil,</code></span>
<span class="codeline" id="line-89"><code>	"template": itemTemplate,</code></span>
<span class="codeline" id="line-90"><code>	"with":     itemWith,</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>const eof = -1</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>// Trimming spaces.</code></span>
<span class="codeline" id="line-96"><code>// If the action begins "{{- " rather than "{{", then all space/tab/newlines</code></span>
<span class="codeline" id="line-97"><code>// preceding the action are trimmed; conversely if it ends " -}}" the</code></span>
<span class="codeline" id="line-98"><code>// leading spaces are trimmed. This is done entirely in the lexer; the</code></span>
<span class="codeline" id="line-99"><code>// parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)</code></span>
<span class="codeline" id="line-100"><code>// to be present to avoid ambiguity with things like "{{-3}}". It reads</code></span>
<span class="codeline" id="line-101"><code>// better with the space present anyway. For simplicity, only ASCII</code></span>
<span class="codeline" id="line-102"><code>// does the job.</code></span>
<span class="codeline" id="line-103"><code>const (</code></span>
<span class="codeline" id="line-104"><code>	spaceChars    = " \t\r\n"  // These are the space characters defined by Go itself.</code></span>
<span class="codeline" id="line-105"><code>	trimMarker    = '-'        // Attached to left/right delimiter, trims trailing spaces from preceding/following text.</code></span>
<span class="codeline" id="line-106"><code>	trimMarkerLen = Pos(1 + 1) // marker plus space before or after</code></span>
<span class="codeline" id="line-107"><code>)</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// stateFn represents the state of the scanner as a function that returns the next state.</code></span>
<span class="codeline" id="line-110"><code>type stateFn func(*lexer) stateFn</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>// lexer holds the state of the scanner.</code></span>
<span class="codeline" id="line-113"><code>type lexer struct {</code></span>
<span class="codeline" id="line-114"><code>	name         string // the name of the input; used only for error reports</code></span>
<span class="codeline" id="line-115"><code>	input        string // the string being scanned</code></span>
<span class="codeline" id="line-116"><code>	leftDelim    string // start of action marker</code></span>
<span class="codeline" id="line-117"><code>	rightDelim   string // end of action marker</code></span>
<span class="codeline" id="line-118"><code>	pos          Pos    // current position in the input</code></span>
<span class="codeline" id="line-119"><code>	start        Pos    // start position of this item</code></span>
<span class="codeline" id="line-120"><code>	atEOF        bool   // we have hit the end of input and returned eof</code></span>
<span class="codeline" id="line-121"><code>	parenDepth   int    // nesting depth of ( ) exprs</code></span>
<span class="codeline" id="line-122"><code>	line         int    // 1+number of newlines seen</code></span>
<span class="codeline" id="line-123"><code>	startLine    int    // start line of this item</code></span>
<span class="codeline" id="line-124"><code>	item         item   // item to return to parser</code></span>
<span class="codeline" id="line-125"><code>	insideAction bool   // are we inside an action?</code></span>
<span class="codeline" id="line-126"><code>	options      lexOptions</code></span>
<span class="codeline" id="line-127"><code>}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// lexOptions control behavior of the lexer. All default to false.</code></span>
<span class="codeline" id="line-130"><code>type lexOptions struct {</code></span>
<span class="codeline" id="line-131"><code>	emitComment bool // emit itemComment tokens.</code></span>
<span class="codeline" id="line-132"><code>	breakOK     bool // break keyword allowed</code></span>
<span class="codeline" id="line-133"><code>	continueOK  bool // continue keyword allowed</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>// next returns the next rune in the input.</code></span>
<span class="codeline" id="line-137"><code>func (l *lexer) next() rune {</code></span>
<span class="codeline" id="line-138"><code>	if int(l.pos) &gt;= len(l.input) {</code></span>
<span class="codeline" id="line-139"><code>		l.atEOF = true</code></span>
<span class="codeline" id="line-140"><code>		return eof</code></span>
<span class="codeline" id="line-141"><code>	}</code></span>
<span class="codeline" id="line-142"><code>	r, w := utf8.DecodeRuneInString(l.input[l.pos:])</code></span>
<span class="codeline" id="line-143"><code>	l.pos += Pos(w)</code></span>
<span class="codeline" id="line-144"><code>	if r == '\n' {</code></span>
<span class="codeline" id="line-145"><code>		l.line++</code></span>
<span class="codeline" id="line-146"><code>	}</code></span>
<span class="codeline" id="line-147"><code>	return r</code></span>
<span class="codeline" id="line-148"><code>}</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>// peek returns but does not consume the next rune in the input.</code></span>
<span class="codeline" id="line-151"><code>func (l *lexer) peek() rune {</code></span>
<span class="codeline" id="line-152"><code>	r := l.next()</code></span>
<span class="codeline" id="line-153"><code>	l.backup()</code></span>
<span class="codeline" id="line-154"><code>	return r</code></span>
<span class="codeline" id="line-155"><code>}</code></span>
<span class="codeline" id="line-156"><code></code></span>
<span class="codeline" id="line-157"><code>// backup steps back one rune.</code></span>
<span class="codeline" id="line-158"><code>func (l *lexer) backup() {</code></span>
<span class="codeline" id="line-159"><code>	if !l.atEOF &amp;&amp; l.pos &gt; 0 {</code></span>
<span class="codeline" id="line-160"><code>		r, w := utf8.DecodeLastRuneInString(l.input[:l.pos])</code></span>
<span class="codeline" id="line-161"><code>		l.pos -= Pos(w)</code></span>
<span class="codeline" id="line-162"><code>		// Correct newline count.</code></span>
<span class="codeline" id="line-163"><code>		if r == '\n' {</code></span>
<span class="codeline" id="line-164"><code>			l.line--</code></span>
<span class="codeline" id="line-165"><code>		}</code></span>
<span class="codeline" id="line-166"><code>	}</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>// thisItem returns the item at the current input point with the specified type</code></span>
<span class="codeline" id="line-170"><code>// and advances the input.</code></span>
<span class="codeline" id="line-171"><code>func (l *lexer) thisItem(t itemType) item {</code></span>
<span class="codeline" id="line-172"><code>	i := item{t, l.start, l.input[l.start:l.pos], l.startLine}</code></span>
<span class="codeline" id="line-173"><code>	l.start = l.pos</code></span>
<span class="codeline" id="line-174"><code>	l.startLine = l.line</code></span>
<span class="codeline" id="line-175"><code>	return i</code></span>
<span class="codeline" id="line-176"><code>}</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// emit passes the trailing text as an item back to the parser.</code></span>
<span class="codeline" id="line-179"><code>func (l *lexer) emit(t itemType) stateFn {</code></span>
<span class="codeline" id="line-180"><code>	return l.emitItem(l.thisItem(t))</code></span>
<span class="codeline" id="line-181"><code>}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>// emitItem passes the specified item to the parser.</code></span>
<span class="codeline" id="line-184"><code>func (l *lexer) emitItem(i item) stateFn {</code></span>
<span class="codeline" id="line-185"><code>	l.item = i</code></span>
<span class="codeline" id="line-186"><code>	return nil</code></span>
<span class="codeline" id="line-187"><code>}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>// ignore skips over the pending input before this point.</code></span>
<span class="codeline" id="line-190"><code>// It tracks newlines in the ignored text, so use it only</code></span>
<span class="codeline" id="line-191"><code>// for text that is skipped without calling l.next.</code></span>
<span class="codeline" id="line-192"><code>func (l *lexer) ignore() {</code></span>
<span class="codeline" id="line-193"><code>	l.line += strings.Count(l.input[l.start:l.pos], "\n")</code></span>
<span class="codeline" id="line-194"><code>	l.start = l.pos</code></span>
<span class="codeline" id="line-195"><code>	l.startLine = l.line</code></span>
<span class="codeline" id="line-196"><code>}</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>// accept consumes the next rune if it's from the valid set.</code></span>
<span class="codeline" id="line-199"><code>func (l *lexer) accept(valid string) bool {</code></span>
<span class="codeline" id="line-200"><code>	if strings.ContainsRune(valid, l.next()) {</code></span>
<span class="codeline" id="line-201"><code>		return true</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	l.backup()</code></span>
<span class="codeline" id="line-204"><code>	return false</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>// acceptRun consumes a run of runes from the valid set.</code></span>
<span class="codeline" id="line-208"><code>func (l *lexer) acceptRun(valid string) {</code></span>
<span class="codeline" id="line-209"><code>	for strings.ContainsRune(valid, l.next()) {</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>	l.backup()</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// errorf returns an error token and terminates the scan by passing</code></span>
<span class="codeline" id="line-215"><code>// back a nil pointer that will be the next state, terminating l.nextItem.</code></span>
<span class="codeline" id="line-216"><code>func (l *lexer) errorf(format string, args ...any) stateFn {</code></span>
<span class="codeline" id="line-217"><code>	l.item = item{itemError, l.start, fmt.Sprintf(format, args...), l.startLine}</code></span>
<span class="codeline" id="line-218"><code>	l.start = 0</code></span>
<span class="codeline" id="line-219"><code>	l.pos = 0</code></span>
<span class="codeline" id="line-220"><code>	l.input = l.input[:0]</code></span>
<span class="codeline" id="line-221"><code>	return nil</code></span>
<span class="codeline" id="line-222"><code>}</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>// nextItem returns the next item from the input.</code></span>
<span class="codeline" id="line-225"><code>// Called by the parser, not in the lexing goroutine.</code></span>
<span class="codeline" id="line-226"><code>func (l *lexer) nextItem() item {</code></span>
<span class="codeline" id="line-227"><code>	l.item = item{itemEOF, l.pos, "EOF", l.startLine}</code></span>
<span class="codeline" id="line-228"><code>	state := lexText</code></span>
<span class="codeline" id="line-229"><code>	if l.insideAction {</code></span>
<span class="codeline" id="line-230"><code>		state = lexInsideAction</code></span>
<span class="codeline" id="line-231"><code>	}</code></span>
<span class="codeline" id="line-232"><code>	for {</code></span>
<span class="codeline" id="line-233"><code>		state = state(l)</code></span>
<span class="codeline" id="line-234"><code>		if state == nil {</code></span>
<span class="codeline" id="line-235"><code>			return l.item</code></span>
<span class="codeline" id="line-236"><code>		}</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// lex creates a new scanner for the input string.</code></span>
<span class="codeline" id="line-241"><code>func lex(name, input, left, right string) *lexer {</code></span>
<span class="codeline" id="line-242"><code>	if left == "" {</code></span>
<span class="codeline" id="line-243"><code>		left = leftDelim</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code>	if right == "" {</code></span>
<span class="codeline" id="line-246"><code>		right = rightDelim</code></span>
<span class="codeline" id="line-247"><code>	}</code></span>
<span class="codeline" id="line-248"><code>	l := &amp;lexer{</code></span>
<span class="codeline" id="line-249"><code>		name:         name,</code></span>
<span class="codeline" id="line-250"><code>		input:        input,</code></span>
<span class="codeline" id="line-251"><code>		leftDelim:    left,</code></span>
<span class="codeline" id="line-252"><code>		rightDelim:   right,</code></span>
<span class="codeline" id="line-253"><code>		line:         1,</code></span>
<span class="codeline" id="line-254"><code>		startLine:    1,</code></span>
<span class="codeline" id="line-255"><code>		insideAction: false,</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code>	return l</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// state functions</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>const (</code></span>
<span class="codeline" id="line-263"><code>	leftDelim    = "{{"</code></span>
<span class="codeline" id="line-264"><code>	rightDelim   = "}}"</code></span>
<span class="codeline" id="line-265"><code>	leftComment  = "/*"</code></span>
<span class="codeline" id="line-266"><code>	rightComment = "*/"</code></span>
<span class="codeline" id="line-267"><code>)</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// lexText scans until an opening action delimiter, "{{".</code></span>
<span class="codeline" id="line-270"><code>func lexText(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-271"><code>	if x := strings.Index(l.input[l.pos:], l.leftDelim); x &gt;= 0 {</code></span>
<span class="codeline" id="line-272"><code>		if x &gt; 0 {</code></span>
<span class="codeline" id="line-273"><code>			l.pos += Pos(x)</code></span>
<span class="codeline" id="line-274"><code>			// Do we trim any trailing space?</code></span>
<span class="codeline" id="line-275"><code>			trimLength := Pos(0)</code></span>
<span class="codeline" id="line-276"><code>			delimEnd := l.pos + Pos(len(l.leftDelim))</code></span>
<span class="codeline" id="line-277"><code>			if hasLeftTrimMarker(l.input[delimEnd:]) {</code></span>
<span class="codeline" id="line-278"><code>				trimLength = rightTrimLength(l.input[l.start:l.pos])</code></span>
<span class="codeline" id="line-279"><code>			}</code></span>
<span class="codeline" id="line-280"><code>			l.pos -= trimLength</code></span>
<span class="codeline" id="line-281"><code>			l.line += strings.Count(l.input[l.start:l.pos], "\n")</code></span>
<span class="codeline" id="line-282"><code>			i := l.thisItem(itemText)</code></span>
<span class="codeline" id="line-283"><code>			l.pos += trimLength</code></span>
<span class="codeline" id="line-284"><code>			l.ignore()</code></span>
<span class="codeline" id="line-285"><code>			if len(i.val) &gt; 0 {</code></span>
<span class="codeline" id="line-286"><code>				return l.emitItem(i)</code></span>
<span class="codeline" id="line-287"><code>			}</code></span>
<span class="codeline" id="line-288"><code>		}</code></span>
<span class="codeline" id="line-289"><code>		return lexLeftDelim</code></span>
<span class="codeline" id="line-290"><code>	}</code></span>
<span class="codeline" id="line-291"><code>	l.pos = Pos(len(l.input))</code></span>
<span class="codeline" id="line-292"><code>	// Correctly reached EOF.</code></span>
<span class="codeline" id="line-293"><code>	if l.pos &gt; l.start {</code></span>
<span class="codeline" id="line-294"><code>		l.line += strings.Count(l.input[l.start:l.pos], "\n")</code></span>
<span class="codeline" id="line-295"><code>		return l.emit(itemText)</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	return l.emit(itemEOF)</code></span>
<span class="codeline" id="line-298"><code>}</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>// rightTrimLength returns the length of the spaces at the end of the string.</code></span>
<span class="codeline" id="line-301"><code>func rightTrimLength(s string) Pos {</code></span>
<span class="codeline" id="line-302"><code>	return Pos(len(s) - len(strings.TrimRight(s, spaceChars)))</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>// atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker.</code></span>
<span class="codeline" id="line-306"><code>func (l *lexer) atRightDelim() (delim, trimSpaces bool) {</code></span>
<span class="codeline" id="line-307"><code>	if hasRightTrimMarker(l.input[l.pos:]) &amp;&amp; strings.HasPrefix(l.input[l.pos+trimMarkerLen:], l.rightDelim) { // With trim marker.</code></span>
<span class="codeline" id="line-308"><code>		return true, true</code></span>
<span class="codeline" id="line-309"><code>	}</code></span>
<span class="codeline" id="line-310"><code>	if strings.HasPrefix(l.input[l.pos:], l.rightDelim) { // Without trim marker.</code></span>
<span class="codeline" id="line-311"><code>		return true, false</code></span>
<span class="codeline" id="line-312"><code>	}</code></span>
<span class="codeline" id="line-313"><code>	return false, false</code></span>
<span class="codeline" id="line-314"><code>}</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>// leftTrimLength returns the length of the spaces at the beginning of the string.</code></span>
<span class="codeline" id="line-317"><code>func leftTrimLength(s string) Pos {</code></span>
<span class="codeline" id="line-318"><code>	return Pos(len(s) - len(strings.TrimLeft(s, spaceChars)))</code></span>
<span class="codeline" id="line-319"><code>}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>// lexLeftDelim scans the left delimiter, which is known to be present, possibly with a trim marker.</code></span>
<span class="codeline" id="line-322"><code>// (The text to be trimmed has already been emitted.)</code></span>
<span class="codeline" id="line-323"><code>func lexLeftDelim(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-324"><code>	l.pos += Pos(len(l.leftDelim))</code></span>
<span class="codeline" id="line-325"><code>	trimSpace := hasLeftTrimMarker(l.input[l.pos:])</code></span>
<span class="codeline" id="line-326"><code>	afterMarker := Pos(0)</code></span>
<span class="codeline" id="line-327"><code>	if trimSpace {</code></span>
<span class="codeline" id="line-328"><code>		afterMarker = trimMarkerLen</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	if strings.HasPrefix(l.input[l.pos+afterMarker:], leftComment) {</code></span>
<span class="codeline" id="line-331"><code>		l.pos += afterMarker</code></span>
<span class="codeline" id="line-332"><code>		l.ignore()</code></span>
<span class="codeline" id="line-333"><code>		return lexComment</code></span>
<span class="codeline" id="line-334"><code>	}</code></span>
<span class="codeline" id="line-335"><code>	i := l.thisItem(itemLeftDelim)</code></span>
<span class="codeline" id="line-336"><code>	l.insideAction = true</code></span>
<span class="codeline" id="line-337"><code>	l.pos += afterMarker</code></span>
<span class="codeline" id="line-338"><code>	l.ignore()</code></span>
<span class="codeline" id="line-339"><code>	l.parenDepth = 0</code></span>
<span class="codeline" id="line-340"><code>	return l.emitItem(i)</code></span>
<span class="codeline" id="line-341"><code>}</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>// lexComment scans a comment. The left comment marker is known to be present.</code></span>
<span class="codeline" id="line-344"><code>func lexComment(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-345"><code>	l.pos += Pos(len(leftComment))</code></span>
<span class="codeline" id="line-346"><code>	x := strings.Index(l.input[l.pos:], rightComment)</code></span>
<span class="codeline" id="line-347"><code>	if x &lt; 0 {</code></span>
<span class="codeline" id="line-348"><code>		return l.errorf("unclosed comment")</code></span>
<span class="codeline" id="line-349"><code>	}</code></span>
<span class="codeline" id="line-350"><code>	l.pos += Pos(x + len(rightComment))</code></span>
<span class="codeline" id="line-351"><code>	delim, trimSpace := l.atRightDelim()</code></span>
<span class="codeline" id="line-352"><code>	if !delim {</code></span>
<span class="codeline" id="line-353"><code>		return l.errorf("comment ends before closing delimiter")</code></span>
<span class="codeline" id="line-354"><code>	}</code></span>
<span class="codeline" id="line-355"><code>	i := l.thisItem(itemComment)</code></span>
<span class="codeline" id="line-356"><code>	if trimSpace {</code></span>
<span class="codeline" id="line-357"><code>		l.pos += trimMarkerLen</code></span>
<span class="codeline" id="line-358"><code>	}</code></span>
<span class="codeline" id="line-359"><code>	l.pos += Pos(len(l.rightDelim))</code></span>
<span class="codeline" id="line-360"><code>	if trimSpace {</code></span>
<span class="codeline" id="line-361"><code>		l.pos += leftTrimLength(l.input[l.pos:])</code></span>
<span class="codeline" id="line-362"><code>	}</code></span>
<span class="codeline" id="line-363"><code>	l.ignore()</code></span>
<span class="codeline" id="line-364"><code>	if l.options.emitComment {</code></span>
<span class="codeline" id="line-365"><code>		return l.emitItem(i)</code></span>
<span class="codeline" id="line-366"><code>	}</code></span>
<span class="codeline" id="line-367"><code>	return lexText</code></span>
<span class="codeline" id="line-368"><code>}</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>// lexRightDelim scans the right delimiter, which is known to be present, possibly with a trim marker.</code></span>
<span class="codeline" id="line-371"><code>func lexRightDelim(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-372"><code>	_, trimSpace := l.atRightDelim()</code></span>
<span class="codeline" id="line-373"><code>	if trimSpace {</code></span>
<span class="codeline" id="line-374"><code>		l.pos += trimMarkerLen</code></span>
<span class="codeline" id="line-375"><code>		l.ignore()</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code>	l.pos += Pos(len(l.rightDelim))</code></span>
<span class="codeline" id="line-378"><code>	i := l.thisItem(itemRightDelim)</code></span>
<span class="codeline" id="line-379"><code>	if trimSpace {</code></span>
<span class="codeline" id="line-380"><code>		l.pos += leftTrimLength(l.input[l.pos:])</code></span>
<span class="codeline" id="line-381"><code>		l.ignore()</code></span>
<span class="codeline" id="line-382"><code>	}</code></span>
<span class="codeline" id="line-383"><code>	l.insideAction = false</code></span>
<span class="codeline" id="line-384"><code>	return l.emitItem(i)</code></span>
<span class="codeline" id="line-385"><code>}</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>// lexInsideAction scans the elements inside action delimiters.</code></span>
<span class="codeline" id="line-388"><code>func lexInsideAction(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-389"><code>	// Either number, quoted string, or identifier.</code></span>
<span class="codeline" id="line-390"><code>	// Spaces separate arguments; runs of spaces turn into itemSpace.</code></span>
<span class="codeline" id="line-391"><code>	// Pipe symbols separate and are emitted.</code></span>
<span class="codeline" id="line-392"><code>	delim, _ := l.atRightDelim()</code></span>
<span class="codeline" id="line-393"><code>	if delim {</code></span>
<span class="codeline" id="line-394"><code>		if l.parenDepth == 0 {</code></span>
<span class="codeline" id="line-395"><code>			return lexRightDelim</code></span>
<span class="codeline" id="line-396"><code>		}</code></span>
<span class="codeline" id="line-397"><code>		return l.errorf("unclosed left paren")</code></span>
<span class="codeline" id="line-398"><code>	}</code></span>
<span class="codeline" id="line-399"><code>	switch r := l.next(); {</code></span>
<span class="codeline" id="line-400"><code>	case r == eof:</code></span>
<span class="codeline" id="line-401"><code>		return l.errorf("unclosed action")</code></span>
<span class="codeline" id="line-402"><code>	case isSpace(r):</code></span>
<span class="codeline" id="line-403"><code>		l.backup() // Put space back in case we have " -}}".</code></span>
<span class="codeline" id="line-404"><code>		return lexSpace</code></span>
<span class="codeline" id="line-405"><code>	case r == '=':</code></span>
<span class="codeline" id="line-406"><code>		return l.emit(itemAssign)</code></span>
<span class="codeline" id="line-407"><code>	case r == ':':</code></span>
<span class="codeline" id="line-408"><code>		if l.next() != '=' {</code></span>
<span class="codeline" id="line-409"><code>			return l.errorf("expected :=")</code></span>
<span class="codeline" id="line-410"><code>		}</code></span>
<span class="codeline" id="line-411"><code>		return l.emit(itemDeclare)</code></span>
<span class="codeline" id="line-412"><code>	case r == '|':</code></span>
<span class="codeline" id="line-413"><code>		return l.emit(itemPipe)</code></span>
<span class="codeline" id="line-414"><code>	case r == '"':</code></span>
<span class="codeline" id="line-415"><code>		return lexQuote</code></span>
<span class="codeline" id="line-416"><code>	case r == '`':</code></span>
<span class="codeline" id="line-417"><code>		return lexRawQuote</code></span>
<span class="codeline" id="line-418"><code>	case r == '$':</code></span>
<span class="codeline" id="line-419"><code>		return lexVariable</code></span>
<span class="codeline" id="line-420"><code>	case r == '\'':</code></span>
<span class="codeline" id="line-421"><code>		return lexChar</code></span>
<span class="codeline" id="line-422"><code>	case r == '.':</code></span>
<span class="codeline" id="line-423"><code>		// special look-ahead for ".field" so we don't break l.backup().</code></span>
<span class="codeline" id="line-424"><code>		if l.pos &lt; Pos(len(l.input)) {</code></span>
<span class="codeline" id="line-425"><code>			r := l.input[l.pos]</code></span>
<span class="codeline" id="line-426"><code>			if r &lt; '0' || '9' &lt; r {</code></span>
<span class="codeline" id="line-427"><code>				return lexField</code></span>
<span class="codeline" id="line-428"><code>			}</code></span>
<span class="codeline" id="line-429"><code>		}</code></span>
<span class="codeline" id="line-430"><code>		fallthrough // '.' can start a number.</code></span>
<span class="codeline" id="line-431"><code>	case r == '+' || r == '-' || ('0' &lt;= r &amp;&amp; r &lt;= '9'):</code></span>
<span class="codeline" id="line-432"><code>		l.backup()</code></span>
<span class="codeline" id="line-433"><code>		return lexNumber</code></span>
<span class="codeline" id="line-434"><code>	case isAlphaNumeric(r):</code></span>
<span class="codeline" id="line-435"><code>		l.backup()</code></span>
<span class="codeline" id="line-436"><code>		return lexIdentifier</code></span>
<span class="codeline" id="line-437"><code>	case r == '(':</code></span>
<span class="codeline" id="line-438"><code>		l.parenDepth++</code></span>
<span class="codeline" id="line-439"><code>		return l.emit(itemLeftParen)</code></span>
<span class="codeline" id="line-440"><code>	case r == ')':</code></span>
<span class="codeline" id="line-441"><code>		l.parenDepth--</code></span>
<span class="codeline" id="line-442"><code>		if l.parenDepth &lt; 0 {</code></span>
<span class="codeline" id="line-443"><code>			return l.errorf("unexpected right paren")</code></span>
<span class="codeline" id="line-444"><code>		}</code></span>
<span class="codeline" id="line-445"><code>		return l.emit(itemRightParen)</code></span>
<span class="codeline" id="line-446"><code>	case r &lt;= unicode.MaxASCII &amp;&amp; unicode.IsPrint(r):</code></span>
<span class="codeline" id="line-447"><code>		return l.emit(itemChar)</code></span>
<span class="codeline" id="line-448"><code>	default:</code></span>
<span class="codeline" id="line-449"><code>		return l.errorf("unrecognized character in action: %#U", r)</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>// lexSpace scans a run of space characters.</code></span>
<span class="codeline" id="line-454"><code>// We have not consumed the first space, which is known to be present.</code></span>
<span class="codeline" id="line-455"><code>// Take care if there is a trim-marked right delimiter, which starts with a space.</code></span>
<span class="codeline" id="line-456"><code>func lexSpace(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-457"><code>	var r rune</code></span>
<span class="codeline" id="line-458"><code>	var numSpaces int</code></span>
<span class="codeline" id="line-459"><code>	for {</code></span>
<span class="codeline" id="line-460"><code>		r = l.peek()</code></span>
<span class="codeline" id="line-461"><code>		if !isSpace(r) {</code></span>
<span class="codeline" id="line-462"><code>			break</code></span>
<span class="codeline" id="line-463"><code>		}</code></span>
<span class="codeline" id="line-464"><code>		l.next()</code></span>
<span class="codeline" id="line-465"><code>		numSpaces++</code></span>
<span class="codeline" id="line-466"><code>	}</code></span>
<span class="codeline" id="line-467"><code>	// Be careful about a trim-marked closing delimiter, which has a minus</code></span>
<span class="codeline" id="line-468"><code>	// after a space. We know there is a space, so check for the '-' that might follow.</code></span>
<span class="codeline" id="line-469"><code>	if hasRightTrimMarker(l.input[l.pos-1:]) &amp;&amp; strings.HasPrefix(l.input[l.pos-1+trimMarkerLen:], l.rightDelim) {</code></span>
<span class="codeline" id="line-470"><code>		l.backup() // Before the space.</code></span>
<span class="codeline" id="line-471"><code>		if numSpaces == 1 {</code></span>
<span class="codeline" id="line-472"><code>			return lexRightDelim // On the delim, so go right to that.</code></span>
<span class="codeline" id="line-473"><code>		}</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>	return l.emit(itemSpace)</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>// lexIdentifier scans an alphanumeric.</code></span>
<span class="codeline" id="line-479"><code>func lexIdentifier(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-480"><code>	for {</code></span>
<span class="codeline" id="line-481"><code>		switch r := l.next(); {</code></span>
<span class="codeline" id="line-482"><code>		case isAlphaNumeric(r):</code></span>
<span class="codeline" id="line-483"><code>			// absorb.</code></span>
<span class="codeline" id="line-484"><code>		default:</code></span>
<span class="codeline" id="line-485"><code>			l.backup()</code></span>
<span class="codeline" id="line-486"><code>			word := l.input[l.start:l.pos]</code></span>
<span class="codeline" id="line-487"><code>			if !l.atTerminator() {</code></span>
<span class="codeline" id="line-488"><code>				return l.errorf("bad character %#U", r)</code></span>
<span class="codeline" id="line-489"><code>			}</code></span>
<span class="codeline" id="line-490"><code>			switch {</code></span>
<span class="codeline" id="line-491"><code>			case key[word] &gt; itemKeyword:</code></span>
<span class="codeline" id="line-492"><code>				item := key[word]</code></span>
<span class="codeline" id="line-493"><code>				if item == itemBreak &amp;&amp; !l.options.breakOK || item == itemContinue &amp;&amp; !l.options.continueOK {</code></span>
<span class="codeline" id="line-494"><code>					return l.emit(itemIdentifier)</code></span>
<span class="codeline" id="line-495"><code>				}</code></span>
<span class="codeline" id="line-496"><code>				return l.emit(item)</code></span>
<span class="codeline" id="line-497"><code>			case word[0] == '.':</code></span>
<span class="codeline" id="line-498"><code>				return l.emit(itemField)</code></span>
<span class="codeline" id="line-499"><code>			case word == "true", word == "false":</code></span>
<span class="codeline" id="line-500"><code>				return l.emit(itemBool)</code></span>
<span class="codeline" id="line-501"><code>			default:</code></span>
<span class="codeline" id="line-502"><code>				return l.emit(itemIdentifier)</code></span>
<span class="codeline" id="line-503"><code>			}</code></span>
<span class="codeline" id="line-504"><code>		}</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>// lexField scans a field: .Alphanumeric.</code></span>
<span class="codeline" id="line-509"><code>// The . has been scanned.</code></span>
<span class="codeline" id="line-510"><code>func lexField(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-511"><code>	return lexFieldOrVariable(l, itemField)</code></span>
<span class="codeline" id="line-512"><code>}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>// lexVariable scans a Variable: $Alphanumeric.</code></span>
<span class="codeline" id="line-515"><code>// The $ has been scanned.</code></span>
<span class="codeline" id="line-516"><code>func lexVariable(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-517"><code>	if l.atTerminator() { // Nothing interesting follows -&gt; "$".</code></span>
<span class="codeline" id="line-518"><code>		return l.emit(itemVariable)</code></span>
<span class="codeline" id="line-519"><code>	}</code></span>
<span class="codeline" id="line-520"><code>	return lexFieldOrVariable(l, itemVariable)</code></span>
<span class="codeline" id="line-521"><code>}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>// lexFieldOrVariable scans a field or variable: [.$]Alphanumeric.</code></span>
<span class="codeline" id="line-524"><code>// The . or $ has been scanned.</code></span>
<span class="codeline" id="line-525"><code>func lexFieldOrVariable(l *lexer, typ itemType) stateFn {</code></span>
<span class="codeline" id="line-526"><code>	if l.atTerminator() { // Nothing interesting follows -&gt; "." or "$".</code></span>
<span class="codeline" id="line-527"><code>		if typ == itemVariable {</code></span>
<span class="codeline" id="line-528"><code>			return l.emit(itemVariable)</code></span>
<span class="codeline" id="line-529"><code>		}</code></span>
<span class="codeline" id="line-530"><code>		return l.emit(itemDot)</code></span>
<span class="codeline" id="line-531"><code>	}</code></span>
<span class="codeline" id="line-532"><code>	var r rune</code></span>
<span class="codeline" id="line-533"><code>	for {</code></span>
<span class="codeline" id="line-534"><code>		r = l.next()</code></span>
<span class="codeline" id="line-535"><code>		if !isAlphaNumeric(r) {</code></span>
<span class="codeline" id="line-536"><code>			l.backup()</code></span>
<span class="codeline" id="line-537"><code>			break</code></span>
<span class="codeline" id="line-538"><code>		}</code></span>
<span class="codeline" id="line-539"><code>	}</code></span>
<span class="codeline" id="line-540"><code>	if !l.atTerminator() {</code></span>
<span class="codeline" id="line-541"><code>		return l.errorf("bad character %#U", r)</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code>	return l.emit(typ)</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>// atTerminator reports whether the input is at valid termination character to</code></span>
<span class="codeline" id="line-547"><code>// appear after an identifier. Breaks .X.Y into two pieces. Also catches cases</code></span>
<span class="codeline" id="line-548"><code>// like "$x+2" not being acceptable without a space, in case we decide one</code></span>
<span class="codeline" id="line-549"><code>// day to implement arithmetic.</code></span>
<span class="codeline" id="line-550"><code>func (l *lexer) atTerminator() bool {</code></span>
<span class="codeline" id="line-551"><code>	r := l.peek()</code></span>
<span class="codeline" id="line-552"><code>	if isSpace(r) {</code></span>
<span class="codeline" id="line-553"><code>		return true</code></span>
<span class="codeline" id="line-554"><code>	}</code></span>
<span class="codeline" id="line-555"><code>	switch r {</code></span>
<span class="codeline" id="line-556"><code>	case eof, '.', ',', '|', ':', ')', '(':</code></span>
<span class="codeline" id="line-557"><code>		return true</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code>	return strings.HasPrefix(l.input[l.pos:], l.rightDelim)</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// lexChar scans a character constant. The initial quote is already</code></span>
<span class="codeline" id="line-563"><code>// scanned. Syntax checking is done by the parser.</code></span>
<span class="codeline" id="line-564"><code>func lexChar(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-565"><code>Loop:</code></span>
<span class="codeline" id="line-566"><code>	for {</code></span>
<span class="codeline" id="line-567"><code>		switch l.next() {</code></span>
<span class="codeline" id="line-568"><code>		case '\\':</code></span>
<span class="codeline" id="line-569"><code>			if r := l.next(); r != eof &amp;&amp; r != '\n' {</code></span>
<span class="codeline" id="line-570"><code>				break</code></span>
<span class="codeline" id="line-571"><code>			}</code></span>
<span class="codeline" id="line-572"><code>			fallthrough</code></span>
<span class="codeline" id="line-573"><code>		case eof, '\n':</code></span>
<span class="codeline" id="line-574"><code>			return l.errorf("unterminated character constant")</code></span>
<span class="codeline" id="line-575"><code>		case '\'':</code></span>
<span class="codeline" id="line-576"><code>			break Loop</code></span>
<span class="codeline" id="line-577"><code>		}</code></span>
<span class="codeline" id="line-578"><code>	}</code></span>
<span class="codeline" id="line-579"><code>	return l.emit(itemCharConstant)</code></span>
<span class="codeline" id="line-580"><code>}</code></span>
<span class="codeline" id="line-581"><code></code></span>
<span class="codeline" id="line-582"><code>// lexNumber scans a number: decimal, octal, hex, float, or imaginary. This</code></span>
<span class="codeline" id="line-583"><code>// isn't a perfect number scanner - for instance it accepts "." and "0x0.2"</code></span>
<span class="codeline" id="line-584"><code>// and "089" - but when it's wrong the input is invalid and the parser (via</code></span>
<span class="codeline" id="line-585"><code>// strconv) will notice.</code></span>
<span class="codeline" id="line-586"><code>func lexNumber(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-587"><code>	if !l.scanNumber() {</code></span>
<span class="codeline" id="line-588"><code>		return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])</code></span>
<span class="codeline" id="line-589"><code>	}</code></span>
<span class="codeline" id="line-590"><code>	if sign := l.peek(); sign == '+' || sign == '-' {</code></span>
<span class="codeline" id="line-591"><code>		// Complex: 1+2i. No spaces, must end in 'i'.</code></span>
<span class="codeline" id="line-592"><code>		if !l.scanNumber() || l.input[l.pos-1] != 'i' {</code></span>
<span class="codeline" id="line-593"><code>			return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])</code></span>
<span class="codeline" id="line-594"><code>		}</code></span>
<span class="codeline" id="line-595"><code>		return l.emit(itemComplex)</code></span>
<span class="codeline" id="line-596"><code>	}</code></span>
<span class="codeline" id="line-597"><code>	return l.emit(itemNumber)</code></span>
<span class="codeline" id="line-598"><code>}</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>func (l *lexer) scanNumber() bool {</code></span>
<span class="codeline" id="line-601"><code>	// Optional leading sign.</code></span>
<span class="codeline" id="line-602"><code>	l.accept("+-")</code></span>
<span class="codeline" id="line-603"><code>	// Is it hex?</code></span>
<span class="codeline" id="line-604"><code>	digits := "0123456789_"</code></span>
<span class="codeline" id="line-605"><code>	if l.accept("0") {</code></span>
<span class="codeline" id="line-606"><code>		// Note: Leading 0 does not mean octal in floats.</code></span>
<span class="codeline" id="line-607"><code>		if l.accept("xX") {</code></span>
<span class="codeline" id="line-608"><code>			digits = "0123456789abcdefABCDEF_"</code></span>
<span class="codeline" id="line-609"><code>		} else if l.accept("oO") {</code></span>
<span class="codeline" id="line-610"><code>			digits = "01234567_"</code></span>
<span class="codeline" id="line-611"><code>		} else if l.accept("bB") {</code></span>
<span class="codeline" id="line-612"><code>			digits = "01_"</code></span>
<span class="codeline" id="line-613"><code>		}</code></span>
<span class="codeline" id="line-614"><code>	}</code></span>
<span class="codeline" id="line-615"><code>	l.acceptRun(digits)</code></span>
<span class="codeline" id="line-616"><code>	if l.accept(".") {</code></span>
<span class="codeline" id="line-617"><code>		l.acceptRun(digits)</code></span>
<span class="codeline" id="line-618"><code>	}</code></span>
<span class="codeline" id="line-619"><code>	if len(digits) == 10+1 &amp;&amp; l.accept("eE") {</code></span>
<span class="codeline" id="line-620"><code>		l.accept("+-")</code></span>
<span class="codeline" id="line-621"><code>		l.acceptRun("0123456789_")</code></span>
<span class="codeline" id="line-622"><code>	}</code></span>
<span class="codeline" id="line-623"><code>	if len(digits) == 16+6+1 &amp;&amp; l.accept("pP") {</code></span>
<span class="codeline" id="line-624"><code>		l.accept("+-")</code></span>
<span class="codeline" id="line-625"><code>		l.acceptRun("0123456789_")</code></span>
<span class="codeline" id="line-626"><code>	}</code></span>
<span class="codeline" id="line-627"><code>	// Is it imaginary?</code></span>
<span class="codeline" id="line-628"><code>	l.accept("i")</code></span>
<span class="codeline" id="line-629"><code>	// Next thing mustn't be alphanumeric.</code></span>
<span class="codeline" id="line-630"><code>	if isAlphaNumeric(l.peek()) {</code></span>
<span class="codeline" id="line-631"><code>		l.next()</code></span>
<span class="codeline" id="line-632"><code>		return false</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code>	return true</code></span>
<span class="codeline" id="line-635"><code>}</code></span>
<span class="codeline" id="line-636"><code></code></span>
<span class="codeline" id="line-637"><code>// lexQuote scans a quoted string.</code></span>
<span class="codeline" id="line-638"><code>func lexQuote(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-639"><code>Loop:</code></span>
<span class="codeline" id="line-640"><code>	for {</code></span>
<span class="codeline" id="line-641"><code>		switch l.next() {</code></span>
<span class="codeline" id="line-642"><code>		case '\\':</code></span>
<span class="codeline" id="line-643"><code>			if r := l.next(); r != eof &amp;&amp; r != '\n' {</code></span>
<span class="codeline" id="line-644"><code>				break</code></span>
<span class="codeline" id="line-645"><code>			}</code></span>
<span class="codeline" id="line-646"><code>			fallthrough</code></span>
<span class="codeline" id="line-647"><code>		case eof, '\n':</code></span>
<span class="codeline" id="line-648"><code>			return l.errorf("unterminated quoted string")</code></span>
<span class="codeline" id="line-649"><code>		case '"':</code></span>
<span class="codeline" id="line-650"><code>			break Loop</code></span>
<span class="codeline" id="line-651"><code>		}</code></span>
<span class="codeline" id="line-652"><code>	}</code></span>
<span class="codeline" id="line-653"><code>	return l.emit(itemString)</code></span>
<span class="codeline" id="line-654"><code>}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>// lexRawQuote scans a raw quoted string.</code></span>
<span class="codeline" id="line-657"><code>func lexRawQuote(l *lexer) stateFn {</code></span>
<span class="codeline" id="line-658"><code>Loop:</code></span>
<span class="codeline" id="line-659"><code>	for {</code></span>
<span class="codeline" id="line-660"><code>		switch l.next() {</code></span>
<span class="codeline" id="line-661"><code>		case eof:</code></span>
<span class="codeline" id="line-662"><code>			return l.errorf("unterminated raw quoted string")</code></span>
<span class="codeline" id="line-663"><code>		case '`':</code></span>
<span class="codeline" id="line-664"><code>			break Loop</code></span>
<span class="codeline" id="line-665"><code>		}</code></span>
<span class="codeline" id="line-666"><code>	}</code></span>
<span class="codeline" id="line-667"><code>	return l.emit(itemRawString)</code></span>
<span class="codeline" id="line-668"><code>}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>// isSpace reports whether r is a space character.</code></span>
<span class="codeline" id="line-671"><code>func isSpace(r rune) bool {</code></span>
<span class="codeline" id="line-672"><code>	return r == ' ' || r == '\t' || r == '\r' || r == '\n'</code></span>
<span class="codeline" id="line-673"><code>}</code></span>
<span class="codeline" id="line-674"><code></code></span>
<span class="codeline" id="line-675"><code>// isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.</code></span>
<span class="codeline" id="line-676"><code>func isAlphaNumeric(r rune) bool {</code></span>
<span class="codeline" id="line-677"><code>	return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)</code></span>
<span class="codeline" id="line-678"><code>}</code></span>
<span class="codeline" id="line-679"><code></code></span>
<span class="codeline" id="line-680"><code>func hasLeftTrimMarker(s string) bool {</code></span>
<span class="codeline" id="line-681"><code>	return len(s) &gt;= 2 &amp;&amp; s[0] == trimMarker &amp;&amp; isSpace(rune(s[1]))</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>func hasRightTrimMarker(s string) bool {</code></span>
<span class="codeline" id="line-685"><code>	return len(s) &gt;= 2 &amp;&amp; isSpace(rune(s[0])) &amp;&amp; s[1] == trimMarker</code></span>
<span class="codeline" id="line-686"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>