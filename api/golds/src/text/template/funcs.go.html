<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: funcs.go in package text/template</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	funcs.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/text/template.html">text/template</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package template</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"errors"</code></span>
<span class="codeline" id="line-9"><code>	"fmt"</code></span>
<span class="codeline" id="line-10"><code>	"io"</code></span>
<span class="codeline" id="line-11"><code>	"net/url"</code></span>
<span class="codeline" id="line-12"><code>	"reflect"</code></span>
<span class="codeline" id="line-13"><code>	"strings"</code></span>
<span class="codeline" id="line-14"><code>	"sync"</code></span>
<span class="codeline" id="line-15"><code>	"unicode"</code></span>
<span class="codeline" id="line-16"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// FuncMap is the type of the map defining the mapping from names to functions.</code></span>
<span class="codeline" id="line-20"><code>// Each function must have either a single return value, or two return values of</code></span>
<span class="codeline" id="line-21"><code>// which the second has type error. In that case, if the second (error)</code></span>
<span class="codeline" id="line-22"><code>// return value evaluates to non-nil during execution, execution terminates and</code></span>
<span class="codeline" id="line-23"><code>// Execute returns that error.</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// Errors returned by Execute wrap the underlying error; call errors.As to</code></span>
<span class="codeline" id="line-26"><code>// unwrap them.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>// When template execution invokes a function with an argument list, that list</code></span>
<span class="codeline" id="line-29"><code>// must be assignable to the function's parameter types. Functions meant to</code></span>
<span class="codeline" id="line-30"><code>// apply to arguments of arbitrary type can use parameters of type interface{} or</code></span>
<span class="codeline" id="line-31"><code>// of type reflect.Value. Similarly, functions meant to return a result of arbitrary</code></span>
<span class="codeline" id="line-32"><code>// type can return interface{} or reflect.Value.</code></span>
<span class="codeline" id="line-33"><code>type FuncMap map[string]any</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>// builtins returns the FuncMap.</code></span>
<span class="codeline" id="line-36"><code>// It is not a global variable so the linker can dead code eliminate</code></span>
<span class="codeline" id="line-37"><code>// more when this isn't called. See golang.org/issue/36021.</code></span>
<span class="codeline" id="line-38"><code>// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</code></span>
<span class="codeline" id="line-39"><code>func builtins() FuncMap {</code></span>
<span class="codeline" id="line-40"><code>	return FuncMap{</code></span>
<span class="codeline" id="line-41"><code>		"and":      and,</code></span>
<span class="codeline" id="line-42"><code>		"call":     call,</code></span>
<span class="codeline" id="line-43"><code>		"html":     HTMLEscaper,</code></span>
<span class="codeline" id="line-44"><code>		"index":    index,</code></span>
<span class="codeline" id="line-45"><code>		"slice":    slice,</code></span>
<span class="codeline" id="line-46"><code>		"js":       JSEscaper,</code></span>
<span class="codeline" id="line-47"><code>		"len":      length,</code></span>
<span class="codeline" id="line-48"><code>		"not":      not,</code></span>
<span class="codeline" id="line-49"><code>		"or":       or,</code></span>
<span class="codeline" id="line-50"><code>		"print":    fmt.Sprint,</code></span>
<span class="codeline" id="line-51"><code>		"printf":   fmt.Sprintf,</code></span>
<span class="codeline" id="line-52"><code>		"println":  fmt.Sprintln,</code></span>
<span class="codeline" id="line-53"><code>		"urlquery": URLQueryEscaper,</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>		// Comparisons</code></span>
<span class="codeline" id="line-56"><code>		"eq": eq, // ==</code></span>
<span class="codeline" id="line-57"><code>		"ge": ge, // &gt;=</code></span>
<span class="codeline" id="line-58"><code>		"gt": gt, // &gt;</code></span>
<span class="codeline" id="line-59"><code>		"le": le, // &lt;=</code></span>
<span class="codeline" id="line-60"><code>		"lt": lt, // &lt;</code></span>
<span class="codeline" id="line-61"><code>		"ne": ne, // !=</code></span>
<span class="codeline" id="line-62"><code>	}</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>var builtinFuncsOnce struct {</code></span>
<span class="codeline" id="line-66"><code>	sync.Once</code></span>
<span class="codeline" id="line-67"><code>	v map[string]reflect.Value</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// builtinFuncsOnce lazily computes &amp; caches the builtinFuncs map.</code></span>
<span class="codeline" id="line-71"><code>// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.</code></span>
<span class="codeline" id="line-72"><code>func builtinFuncs() map[string]reflect.Value {</code></span>
<span class="codeline" id="line-73"><code>	builtinFuncsOnce.Do(func() {</code></span>
<span class="codeline" id="line-74"><code>		builtinFuncsOnce.v = createValueFuncs(builtins())</code></span>
<span class="codeline" id="line-75"><code>	})</code></span>
<span class="codeline" id="line-76"><code>	return builtinFuncsOnce.v</code></span>
<span class="codeline" id="line-77"><code>}</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// createValueFuncs turns a FuncMap into a map[string]reflect.Value</code></span>
<span class="codeline" id="line-80"><code>func createValueFuncs(funcMap FuncMap) map[string]reflect.Value {</code></span>
<span class="codeline" id="line-81"><code>	m := make(map[string]reflect.Value)</code></span>
<span class="codeline" id="line-82"><code>	addValueFuncs(m, funcMap)</code></span>
<span class="codeline" id="line-83"><code>	return m</code></span>
<span class="codeline" id="line-84"><code>}</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>// addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.</code></span>
<span class="codeline" id="line-87"><code>func addValueFuncs(out map[string]reflect.Value, in FuncMap) {</code></span>
<span class="codeline" id="line-88"><code>	for name, fn := range in {</code></span>
<span class="codeline" id="line-89"><code>		if !goodName(name) {</code></span>
<span class="codeline" id="line-90"><code>			panic(fmt.Errorf("function name %q is not a valid identifier", name))</code></span>
<span class="codeline" id="line-91"><code>		}</code></span>
<span class="codeline" id="line-92"><code>		v := reflect.ValueOf(fn)</code></span>
<span class="codeline" id="line-93"><code>		if v.Kind() != reflect.Func {</code></span>
<span class="codeline" id="line-94"><code>			panic("value for " + name + " not a function")</code></span>
<span class="codeline" id="line-95"><code>		}</code></span>
<span class="codeline" id="line-96"><code>		if !goodFunc(v.Type()) {</code></span>
<span class="codeline" id="line-97"><code>			panic(fmt.Errorf("can't install method/function %q with %d results", name, v.Type().NumOut()))</code></span>
<span class="codeline" id="line-98"><code>		}</code></span>
<span class="codeline" id="line-99"><code>		out[name] = v</code></span>
<span class="codeline" id="line-100"><code>	}</code></span>
<span class="codeline" id="line-101"><code>}</code></span>
<span class="codeline" id="line-102"><code></code></span>
<span class="codeline" id="line-103"><code>// addFuncs adds to values the functions in funcs. It does no checking of the input -</code></span>
<span class="codeline" id="line-104"><code>// call addValueFuncs first.</code></span>
<span class="codeline" id="line-105"><code>func addFuncs(out, in FuncMap) {</code></span>
<span class="codeline" id="line-106"><code>	for name, fn := range in {</code></span>
<span class="codeline" id="line-107"><code>		out[name] = fn</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>// goodFunc reports whether the function or method has the right result signature.</code></span>
<span class="codeline" id="line-112"><code>func goodFunc(typ reflect.Type) bool {</code></span>
<span class="codeline" id="line-113"><code>	// We allow functions with 1 result or 2 results where the second is an error.</code></span>
<span class="codeline" id="line-114"><code>	switch {</code></span>
<span class="codeline" id="line-115"><code>	case typ.NumOut() == 1:</code></span>
<span class="codeline" id="line-116"><code>		return true</code></span>
<span class="codeline" id="line-117"><code>	case typ.NumOut() == 2 &amp;&amp; typ.Out(1) == errorType:</code></span>
<span class="codeline" id="line-118"><code>		return true</code></span>
<span class="codeline" id="line-119"><code>	}</code></span>
<span class="codeline" id="line-120"><code>	return false</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// goodName reports whether the function name is a valid identifier.</code></span>
<span class="codeline" id="line-124"><code>func goodName(name string) bool {</code></span>
<span class="codeline" id="line-125"><code>	if name == "" {</code></span>
<span class="codeline" id="line-126"><code>		return false</code></span>
<span class="codeline" id="line-127"><code>	}</code></span>
<span class="codeline" id="line-128"><code>	for i, r := range name {</code></span>
<span class="codeline" id="line-129"><code>		switch {</code></span>
<span class="codeline" id="line-130"><code>		case r == '_':</code></span>
<span class="codeline" id="line-131"><code>		case i == 0 &amp;&amp; !unicode.IsLetter(r):</code></span>
<span class="codeline" id="line-132"><code>			return false</code></span>
<span class="codeline" id="line-133"><code>		case !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r):</code></span>
<span class="codeline" id="line-134"><code>			return false</code></span>
<span class="codeline" id="line-135"><code>		}</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	return true</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>// findFunction looks for a function in the template, and global map.</code></span>
<span class="codeline" id="line-141"><code>func findFunction(name string, tmpl *Template) (v reflect.Value, isBuiltin, ok bool) {</code></span>
<span class="codeline" id="line-142"><code>	if tmpl != nil &amp;&amp; tmpl.common != nil {</code></span>
<span class="codeline" id="line-143"><code>		tmpl.muFuncs.RLock()</code></span>
<span class="codeline" id="line-144"><code>		defer tmpl.muFuncs.RUnlock()</code></span>
<span class="codeline" id="line-145"><code>		if fn := tmpl.execFuncs[name]; fn.IsValid() {</code></span>
<span class="codeline" id="line-146"><code>			return fn, false, true</code></span>
<span class="codeline" id="line-147"><code>		}</code></span>
<span class="codeline" id="line-148"><code>	}</code></span>
<span class="codeline" id="line-149"><code>	if fn := builtinFuncs()[name]; fn.IsValid() {</code></span>
<span class="codeline" id="line-150"><code>		return fn, true, true</code></span>
<span class="codeline" id="line-151"><code>	}</code></span>
<span class="codeline" id="line-152"><code>	return reflect.Value{}, false, false</code></span>
<span class="codeline" id="line-153"><code>}</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>// prepareArg checks if value can be used as an argument of type argType, and</code></span>
<span class="codeline" id="line-156"><code>// converts an invalid value to appropriate zero if possible.</code></span>
<span class="codeline" id="line-157"><code>func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) {</code></span>
<span class="codeline" id="line-158"><code>	if !value.IsValid() {</code></span>
<span class="codeline" id="line-159"><code>		if !canBeNil(argType) {</code></span>
<span class="codeline" id="line-160"><code>			return reflect.Value{}, fmt.Errorf("value is nil; should be of type %s", argType)</code></span>
<span class="codeline" id="line-161"><code>		}</code></span>
<span class="codeline" id="line-162"><code>		value = reflect.Zero(argType)</code></span>
<span class="codeline" id="line-163"><code>	}</code></span>
<span class="codeline" id="line-164"><code>	if value.Type().AssignableTo(argType) {</code></span>
<span class="codeline" id="line-165"><code>		return value, nil</code></span>
<span class="codeline" id="line-166"><code>	}</code></span>
<span class="codeline" id="line-167"><code>	if intLike(value.Kind()) &amp;&amp; intLike(argType.Kind()) &amp;&amp; value.Type().ConvertibleTo(argType) {</code></span>
<span class="codeline" id="line-168"><code>		value = value.Convert(argType)</code></span>
<span class="codeline" id="line-169"><code>		return value, nil</code></span>
<span class="codeline" id="line-170"><code>	}</code></span>
<span class="codeline" id="line-171"><code>	return reflect.Value{}, fmt.Errorf("value has type %s; should be %s", value.Type(), argType)</code></span>
<span class="codeline" id="line-172"><code>}</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>func intLike(typ reflect.Kind) bool {</code></span>
<span class="codeline" id="line-175"><code>	switch typ {</code></span>
<span class="codeline" id="line-176"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-177"><code>		return true</code></span>
<span class="codeline" id="line-178"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-179"><code>		return true</code></span>
<span class="codeline" id="line-180"><code>	}</code></span>
<span class="codeline" id="line-181"><code>	return false</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>// indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible.</code></span>
<span class="codeline" id="line-185"><code>func indexArg(index reflect.Value, cap int) (int, error) {</code></span>
<span class="codeline" id="line-186"><code>	var x int64</code></span>
<span class="codeline" id="line-187"><code>	switch index.Kind() {</code></span>
<span class="codeline" id="line-188"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-189"><code>		x = index.Int()</code></span>
<span class="codeline" id="line-190"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-191"><code>		x = int64(index.Uint())</code></span>
<span class="codeline" id="line-192"><code>	case reflect.Invalid:</code></span>
<span class="codeline" id="line-193"><code>		return 0, fmt.Errorf("cannot index slice/array with nil")</code></span>
<span class="codeline" id="line-194"><code>	default:</code></span>
<span class="codeline" id="line-195"><code>		return 0, fmt.Errorf("cannot index slice/array with type %s", index.Type())</code></span>
<span class="codeline" id="line-196"><code>	}</code></span>
<span class="codeline" id="line-197"><code>	if x &lt; 0 || int(x) &lt; 0 || int(x) &gt; cap {</code></span>
<span class="codeline" id="line-198"><code>		return 0, fmt.Errorf("index out of range: %d", x)</code></span>
<span class="codeline" id="line-199"><code>	}</code></span>
<span class="codeline" id="line-200"><code>	return int(x), nil</code></span>
<span class="codeline" id="line-201"><code>}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>// Indexing.</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>// index returns the result of indexing its first argument by the following</code></span>
<span class="codeline" id="line-206"><code>// arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each</code></span>
<span class="codeline" id="line-207"><code>// indexed item must be a map, slice, or array.</code></span>
<span class="codeline" id="line-208"><code>func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {</code></span>
<span class="codeline" id="line-209"><code>	item = indirectInterface(item)</code></span>
<span class="codeline" id="line-210"><code>	if !item.IsValid() {</code></span>
<span class="codeline" id="line-211"><code>		return reflect.Value{}, fmt.Errorf("index of untyped nil")</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code>	for _, index := range indexes {</code></span>
<span class="codeline" id="line-214"><code>		index = indirectInterface(index)</code></span>
<span class="codeline" id="line-215"><code>		var isNil bool</code></span>
<span class="codeline" id="line-216"><code>		if item, isNil = indirect(item); isNil {</code></span>
<span class="codeline" id="line-217"><code>			return reflect.Value{}, fmt.Errorf("index of nil pointer")</code></span>
<span class="codeline" id="line-218"><code>		}</code></span>
<span class="codeline" id="line-219"><code>		switch item.Kind() {</code></span>
<span class="codeline" id="line-220"><code>		case reflect.Array, reflect.Slice, reflect.String:</code></span>
<span class="codeline" id="line-221"><code>			x, err := indexArg(index, item.Len())</code></span>
<span class="codeline" id="line-222"><code>			if err != nil {</code></span>
<span class="codeline" id="line-223"><code>				return reflect.Value{}, err</code></span>
<span class="codeline" id="line-224"><code>			}</code></span>
<span class="codeline" id="line-225"><code>			item = item.Index(x)</code></span>
<span class="codeline" id="line-226"><code>		case reflect.Map:</code></span>
<span class="codeline" id="line-227"><code>			index, err := prepareArg(index, item.Type().Key())</code></span>
<span class="codeline" id="line-228"><code>			if err != nil {</code></span>
<span class="codeline" id="line-229"><code>				return reflect.Value{}, err</code></span>
<span class="codeline" id="line-230"><code>			}</code></span>
<span class="codeline" id="line-231"><code>			if x := item.MapIndex(index); x.IsValid() {</code></span>
<span class="codeline" id="line-232"><code>				item = x</code></span>
<span class="codeline" id="line-233"><code>			} else {</code></span>
<span class="codeline" id="line-234"><code>				item = reflect.Zero(item.Type().Elem())</code></span>
<span class="codeline" id="line-235"><code>			}</code></span>
<span class="codeline" id="line-236"><code>		case reflect.Invalid:</code></span>
<span class="codeline" id="line-237"><code>			// the loop holds invariant: item.IsValid()</code></span>
<span class="codeline" id="line-238"><code>			panic("unreachable")</code></span>
<span class="codeline" id="line-239"><code>		default:</code></span>
<span class="codeline" id="line-240"><code>			return reflect.Value{}, fmt.Errorf("can't index item of type %s", item.Type())</code></span>
<span class="codeline" id="line-241"><code>		}</code></span>
<span class="codeline" id="line-242"><code>	}</code></span>
<span class="codeline" id="line-243"><code>	return item, nil</code></span>
<span class="codeline" id="line-244"><code>}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>// Slicing.</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>// slice returns the result of slicing its first argument by the remaining</code></span>
<span class="codeline" id="line-249"><code>// arguments. Thus "slice x 1 2" is, in Go syntax, x[1:2], while "slice x"</code></span>
<span class="codeline" id="line-250"><code>// is x[:], "slice x 1" is x[1:], and "slice x 1 2 3" is x[1:2:3]. The first</code></span>
<span class="codeline" id="line-251"><code>// argument must be a string, slice, or array.</code></span>
<span class="codeline" id="line-252"><code>func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) {</code></span>
<span class="codeline" id="line-253"><code>	item = indirectInterface(item)</code></span>
<span class="codeline" id="line-254"><code>	if !item.IsValid() {</code></span>
<span class="codeline" id="line-255"><code>		return reflect.Value{}, fmt.Errorf("slice of untyped nil")</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code>	if len(indexes) &gt; 3 {</code></span>
<span class="codeline" id="line-258"><code>		return reflect.Value{}, fmt.Errorf("too many slice indexes: %d", len(indexes))</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	var cap int</code></span>
<span class="codeline" id="line-261"><code>	switch item.Kind() {</code></span>
<span class="codeline" id="line-262"><code>	case reflect.String:</code></span>
<span class="codeline" id="line-263"><code>		if len(indexes) == 3 {</code></span>
<span class="codeline" id="line-264"><code>			return reflect.Value{}, fmt.Errorf("cannot 3-index slice a string")</code></span>
<span class="codeline" id="line-265"><code>		}</code></span>
<span class="codeline" id="line-266"><code>		cap = item.Len()</code></span>
<span class="codeline" id="line-267"><code>	case reflect.Array, reflect.Slice:</code></span>
<span class="codeline" id="line-268"><code>		cap = item.Cap()</code></span>
<span class="codeline" id="line-269"><code>	default:</code></span>
<span class="codeline" id="line-270"><code>		return reflect.Value{}, fmt.Errorf("can't slice item of type %s", item.Type())</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	// set default values for cases item[:], item[i:].</code></span>
<span class="codeline" id="line-273"><code>	idx := [3]int{0, item.Len()}</code></span>
<span class="codeline" id="line-274"><code>	for i, index := range indexes {</code></span>
<span class="codeline" id="line-275"><code>		x, err := indexArg(index, cap)</code></span>
<span class="codeline" id="line-276"><code>		if err != nil {</code></span>
<span class="codeline" id="line-277"><code>			return reflect.Value{}, err</code></span>
<span class="codeline" id="line-278"><code>		}</code></span>
<span class="codeline" id="line-279"><code>		idx[i] = x</code></span>
<span class="codeline" id="line-280"><code>	}</code></span>
<span class="codeline" id="line-281"><code>	// given item[i:j], make sure i &lt;= j.</code></span>
<span class="codeline" id="line-282"><code>	if idx[0] &gt; idx[1] {</code></span>
<span class="codeline" id="line-283"><code>		return reflect.Value{}, fmt.Errorf("invalid slice index: %d &gt; %d", idx[0], idx[1])</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>	if len(indexes) &lt; 3 {</code></span>
<span class="codeline" id="line-286"><code>		return item.Slice(idx[0], idx[1]), nil</code></span>
<span class="codeline" id="line-287"><code>	}</code></span>
<span class="codeline" id="line-288"><code>	// given item[i:j:k], make sure i &lt;= j &lt;= k.</code></span>
<span class="codeline" id="line-289"><code>	if idx[1] &gt; idx[2] {</code></span>
<span class="codeline" id="line-290"><code>		return reflect.Value{}, fmt.Errorf("invalid slice index: %d &gt; %d", idx[1], idx[2])</code></span>
<span class="codeline" id="line-291"><code>	}</code></span>
<span class="codeline" id="line-292"><code>	return item.Slice3(idx[0], idx[1], idx[2]), nil</code></span>
<span class="codeline" id="line-293"><code>}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>// Length</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>// length returns the length of the item, with an error if it has no defined length.</code></span>
<span class="codeline" id="line-298"><code>func length(item reflect.Value) (int, error) {</code></span>
<span class="codeline" id="line-299"><code>	item, isNil := indirect(item)</code></span>
<span class="codeline" id="line-300"><code>	if isNil {</code></span>
<span class="codeline" id="line-301"><code>		return 0, fmt.Errorf("len of nil pointer")</code></span>
<span class="codeline" id="line-302"><code>	}</code></span>
<span class="codeline" id="line-303"><code>	switch item.Kind() {</code></span>
<span class="codeline" id="line-304"><code>	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:</code></span>
<span class="codeline" id="line-305"><code>		return item.Len(), nil</code></span>
<span class="codeline" id="line-306"><code>	}</code></span>
<span class="codeline" id="line-307"><code>	return 0, fmt.Errorf("len of type %s", item.Type())</code></span>
<span class="codeline" id="line-308"><code>}</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>// Function invocation</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// call returns the result of evaluating the first argument as a function.</code></span>
<span class="codeline" id="line-313"><code>// The function must return 1 result, or 2 results, the second of which is an error.</code></span>
<span class="codeline" id="line-314"><code>func call(fn reflect.Value, args ...reflect.Value) (reflect.Value, error) {</code></span>
<span class="codeline" id="line-315"><code>	fn = indirectInterface(fn)</code></span>
<span class="codeline" id="line-316"><code>	if !fn.IsValid() {</code></span>
<span class="codeline" id="line-317"><code>		return reflect.Value{}, fmt.Errorf("call of nil")</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	typ := fn.Type()</code></span>
<span class="codeline" id="line-320"><code>	if typ.Kind() != reflect.Func {</code></span>
<span class="codeline" id="line-321"><code>		return reflect.Value{}, fmt.Errorf("non-function of type %s", typ)</code></span>
<span class="codeline" id="line-322"><code>	}</code></span>
<span class="codeline" id="line-323"><code>	if !goodFunc(typ) {</code></span>
<span class="codeline" id="line-324"><code>		return reflect.Value{}, fmt.Errorf("function called with %d args; should be 1 or 2", typ.NumOut())</code></span>
<span class="codeline" id="line-325"><code>	}</code></span>
<span class="codeline" id="line-326"><code>	numIn := typ.NumIn()</code></span>
<span class="codeline" id="line-327"><code>	var dddType reflect.Type</code></span>
<span class="codeline" id="line-328"><code>	if typ.IsVariadic() {</code></span>
<span class="codeline" id="line-329"><code>		if len(args) &lt; numIn-1 {</code></span>
<span class="codeline" id="line-330"><code>			return reflect.Value{}, fmt.Errorf("wrong number of args: got %d want at least %d", len(args), numIn-1)</code></span>
<span class="codeline" id="line-331"><code>		}</code></span>
<span class="codeline" id="line-332"><code>		dddType = typ.In(numIn - 1).Elem()</code></span>
<span class="codeline" id="line-333"><code>	} else {</code></span>
<span class="codeline" id="line-334"><code>		if len(args) != numIn {</code></span>
<span class="codeline" id="line-335"><code>			return reflect.Value{}, fmt.Errorf("wrong number of args: got %d want %d", len(args), numIn)</code></span>
<span class="codeline" id="line-336"><code>		}</code></span>
<span class="codeline" id="line-337"><code>	}</code></span>
<span class="codeline" id="line-338"><code>	argv := make([]reflect.Value, len(args))</code></span>
<span class="codeline" id="line-339"><code>	for i, arg := range args {</code></span>
<span class="codeline" id="line-340"><code>		arg = indirectInterface(arg)</code></span>
<span class="codeline" id="line-341"><code>		// Compute the expected type. Clumsy because of variadics.</code></span>
<span class="codeline" id="line-342"><code>		argType := dddType</code></span>
<span class="codeline" id="line-343"><code>		if !typ.IsVariadic() || i &lt; numIn-1 {</code></span>
<span class="codeline" id="line-344"><code>			argType = typ.In(i)</code></span>
<span class="codeline" id="line-345"><code>		}</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>		var err error</code></span>
<span class="codeline" id="line-348"><code>		if argv[i], err = prepareArg(arg, argType); err != nil {</code></span>
<span class="codeline" id="line-349"><code>			return reflect.Value{}, fmt.Errorf("arg %d: %w", i, err)</code></span>
<span class="codeline" id="line-350"><code>		}</code></span>
<span class="codeline" id="line-351"><code>	}</code></span>
<span class="codeline" id="line-352"><code>	return safeCall(fn, argv)</code></span>
<span class="codeline" id="line-353"><code>}</code></span>
<span class="codeline" id="line-354"><code></code></span>
<span class="codeline" id="line-355"><code>// safeCall runs fun.Call(args), and returns the resulting value and error, if</code></span>
<span class="codeline" id="line-356"><code>// any. If the call panics, the panic value is returned as an error.</code></span>
<span class="codeline" id="line-357"><code>func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error) {</code></span>
<span class="codeline" id="line-358"><code>	defer func() {</code></span>
<span class="codeline" id="line-359"><code>		if r := recover(); r != nil {</code></span>
<span class="codeline" id="line-360"><code>			if e, ok := r.(error); ok {</code></span>
<span class="codeline" id="line-361"><code>				err = e</code></span>
<span class="codeline" id="line-362"><code>			} else {</code></span>
<span class="codeline" id="line-363"><code>				err = fmt.Errorf("%v", r)</code></span>
<span class="codeline" id="line-364"><code>			}</code></span>
<span class="codeline" id="line-365"><code>		}</code></span>
<span class="codeline" id="line-366"><code>	}()</code></span>
<span class="codeline" id="line-367"><code>	ret := fun.Call(args)</code></span>
<span class="codeline" id="line-368"><code>	if len(ret) == 2 &amp;&amp; !ret[1].IsNil() {</code></span>
<span class="codeline" id="line-369"><code>		return ret[0], ret[1].Interface().(error)</code></span>
<span class="codeline" id="line-370"><code>	}</code></span>
<span class="codeline" id="line-371"><code>	return ret[0], nil</code></span>
<span class="codeline" id="line-372"><code>}</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>// Boolean logic.</code></span>
<span class="codeline" id="line-375"><code></code></span>
<span class="codeline" id="line-376"><code>func truth(arg reflect.Value) bool {</code></span>
<span class="codeline" id="line-377"><code>	t, _ := isTrue(indirectInterface(arg))</code></span>
<span class="codeline" id="line-378"><code>	return t</code></span>
<span class="codeline" id="line-379"><code>}</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>// and computes the Boolean AND of its arguments, returning</code></span>
<span class="codeline" id="line-382"><code>// the first false argument it encounters, or the last argument.</code></span>
<span class="codeline" id="line-383"><code>func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value {</code></span>
<span class="codeline" id="line-384"><code>	panic("unreachable") // implemented as a special case in evalCall</code></span>
<span class="codeline" id="line-385"><code>}</code></span>
<span class="codeline" id="line-386"><code></code></span>
<span class="codeline" id="line-387"><code>// or computes the Boolean OR of its arguments, returning</code></span>
<span class="codeline" id="line-388"><code>// the first true argument it encounters, or the last argument.</code></span>
<span class="codeline" id="line-389"><code>func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value {</code></span>
<span class="codeline" id="line-390"><code>	panic("unreachable") // implemented as a special case in evalCall</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>// not returns the Boolean negation of its argument.</code></span>
<span class="codeline" id="line-394"><code>func not(arg reflect.Value) bool {</code></span>
<span class="codeline" id="line-395"><code>	return !truth(arg)</code></span>
<span class="codeline" id="line-396"><code>}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>// Comparison.</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>// TODO: Perhaps allow comparison between signed and unsigned integers.</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>var (</code></span>
<span class="codeline" id="line-403"><code>	errBadComparisonType = errors.New("invalid type for comparison")</code></span>
<span class="codeline" id="line-404"><code>	errBadComparison     = errors.New("incompatible types for comparison")</code></span>
<span class="codeline" id="line-405"><code>	errNoComparison      = errors.New("missing argument for comparison")</code></span>
<span class="codeline" id="line-406"><code>)</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>type kind int</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>const (</code></span>
<span class="codeline" id="line-411"><code>	invalidKind kind = iota</code></span>
<span class="codeline" id="line-412"><code>	boolKind</code></span>
<span class="codeline" id="line-413"><code>	complexKind</code></span>
<span class="codeline" id="line-414"><code>	intKind</code></span>
<span class="codeline" id="line-415"><code>	floatKind</code></span>
<span class="codeline" id="line-416"><code>	stringKind</code></span>
<span class="codeline" id="line-417"><code>	uintKind</code></span>
<span class="codeline" id="line-418"><code>)</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>func basicKind(v reflect.Value) (kind, error) {</code></span>
<span class="codeline" id="line-421"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-422"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-423"><code>		return boolKind, nil</code></span>
<span class="codeline" id="line-424"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-425"><code>		return intKind, nil</code></span>
<span class="codeline" id="line-426"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-427"><code>		return uintKind, nil</code></span>
<span class="codeline" id="line-428"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-429"><code>		return floatKind, nil</code></span>
<span class="codeline" id="line-430"><code>	case reflect.Complex64, reflect.Complex128:</code></span>
<span class="codeline" id="line-431"><code>		return complexKind, nil</code></span>
<span class="codeline" id="line-432"><code>	case reflect.String:</code></span>
<span class="codeline" id="line-433"><code>		return stringKind, nil</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	return invalidKind, errBadComparisonType</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>// isNil returns true if v is the zero reflect.Value, or nil of its type.</code></span>
<span class="codeline" id="line-439"><code>func isNil(v reflect.Value) bool {</code></span>
<span class="codeline" id="line-440"><code>	if !v.IsValid() {</code></span>
<span class="codeline" id="line-441"><code>		return true</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-444"><code>	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Pointer, reflect.Slice:</code></span>
<span class="codeline" id="line-445"><code>		return v.IsNil()</code></span>
<span class="codeline" id="line-446"><code>	}</code></span>
<span class="codeline" id="line-447"><code>	return false</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>// canCompare reports whether v1 and v2 are both the same kind, or one is nil.</code></span>
<span class="codeline" id="line-451"><code>// Called only when dealing with nillable types, or there's about to be an error.</code></span>
<span class="codeline" id="line-452"><code>func canCompare(v1, v2 reflect.Value) bool {</code></span>
<span class="codeline" id="line-453"><code>	k1 := v1.Kind()</code></span>
<span class="codeline" id="line-454"><code>	k2 := v2.Kind()</code></span>
<span class="codeline" id="line-455"><code>	if k1 == k2 {</code></span>
<span class="codeline" id="line-456"><code>		return true</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code>	// We know the type can be compared to nil.</code></span>
<span class="codeline" id="line-459"><code>	return k1 == reflect.Invalid || k2 == reflect.Invalid</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>// eq evaluates the comparison a == b || a == c || ...</code></span>
<span class="codeline" id="line-463"><code>func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-464"><code>	arg1 = indirectInterface(arg1)</code></span>
<span class="codeline" id="line-465"><code>	if len(arg2) == 0 {</code></span>
<span class="codeline" id="line-466"><code>		return false, errNoComparison</code></span>
<span class="codeline" id="line-467"><code>	}</code></span>
<span class="codeline" id="line-468"><code>	k1, _ := basicKind(arg1)</code></span>
<span class="codeline" id="line-469"><code>	for _, arg := range arg2 {</code></span>
<span class="codeline" id="line-470"><code>		arg = indirectInterface(arg)</code></span>
<span class="codeline" id="line-471"><code>		k2, _ := basicKind(arg)</code></span>
<span class="codeline" id="line-472"><code>		truth := false</code></span>
<span class="codeline" id="line-473"><code>		if k1 != k2 {</code></span>
<span class="codeline" id="line-474"><code>			// Special case: Can compare integer values regardless of type's sign.</code></span>
<span class="codeline" id="line-475"><code>			switch {</code></span>
<span class="codeline" id="line-476"><code>			case k1 == intKind &amp;&amp; k2 == uintKind:</code></span>
<span class="codeline" id="line-477"><code>				truth = arg1.Int() &gt;= 0 &amp;&amp; uint64(arg1.Int()) == arg.Uint()</code></span>
<span class="codeline" id="line-478"><code>			case k1 == uintKind &amp;&amp; k2 == intKind:</code></span>
<span class="codeline" id="line-479"><code>				truth = arg.Int() &gt;= 0 &amp;&amp; arg1.Uint() == uint64(arg.Int())</code></span>
<span class="codeline" id="line-480"><code>			default:</code></span>
<span class="codeline" id="line-481"><code>				if arg1.IsValid() &amp;&amp; arg.IsValid() {</code></span>
<span class="codeline" id="line-482"><code>					return false, errBadComparison</code></span>
<span class="codeline" id="line-483"><code>				}</code></span>
<span class="codeline" id="line-484"><code>			}</code></span>
<span class="codeline" id="line-485"><code>		} else {</code></span>
<span class="codeline" id="line-486"><code>			switch k1 {</code></span>
<span class="codeline" id="line-487"><code>			case boolKind:</code></span>
<span class="codeline" id="line-488"><code>				truth = arg1.Bool() == arg.Bool()</code></span>
<span class="codeline" id="line-489"><code>			case complexKind:</code></span>
<span class="codeline" id="line-490"><code>				truth = arg1.Complex() == arg.Complex()</code></span>
<span class="codeline" id="line-491"><code>			case floatKind:</code></span>
<span class="codeline" id="line-492"><code>				truth = arg1.Float() == arg.Float()</code></span>
<span class="codeline" id="line-493"><code>			case intKind:</code></span>
<span class="codeline" id="line-494"><code>				truth = arg1.Int() == arg.Int()</code></span>
<span class="codeline" id="line-495"><code>			case stringKind:</code></span>
<span class="codeline" id="line-496"><code>				truth = arg1.String() == arg.String()</code></span>
<span class="codeline" id="line-497"><code>			case uintKind:</code></span>
<span class="codeline" id="line-498"><code>				truth = arg1.Uint() == arg.Uint()</code></span>
<span class="codeline" id="line-499"><code>			default:</code></span>
<span class="codeline" id="line-500"><code>				if !canCompare(arg1, arg) {</code></span>
<span class="codeline" id="line-501"><code>					return false, fmt.Errorf("non-comparable types %s: %v, %s: %v", arg1, arg1.Type(), arg.Type(), arg)</code></span>
<span class="codeline" id="line-502"><code>				}</code></span>
<span class="codeline" id="line-503"><code>				if isNil(arg1) || isNil(arg) {</code></span>
<span class="codeline" id="line-504"><code>					truth = isNil(arg) == isNil(arg1)</code></span>
<span class="codeline" id="line-505"><code>				} else {</code></span>
<span class="codeline" id="line-506"><code>					if !arg.Type().Comparable() {</code></span>
<span class="codeline" id="line-507"><code>						return false, fmt.Errorf("non-comparable type %s: %v", arg, arg.Type())</code></span>
<span class="codeline" id="line-508"><code>					}</code></span>
<span class="codeline" id="line-509"><code>					truth = arg1.Interface() == arg.Interface()</code></span>
<span class="codeline" id="line-510"><code>				}</code></span>
<span class="codeline" id="line-511"><code>			}</code></span>
<span class="codeline" id="line-512"><code>		}</code></span>
<span class="codeline" id="line-513"><code>		if truth {</code></span>
<span class="codeline" id="line-514"><code>			return true, nil</code></span>
<span class="codeline" id="line-515"><code>		}</code></span>
<span class="codeline" id="line-516"><code>	}</code></span>
<span class="codeline" id="line-517"><code>	return false, nil</code></span>
<span class="codeline" id="line-518"><code>}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>// ne evaluates the comparison a != b.</code></span>
<span class="codeline" id="line-521"><code>func ne(arg1, arg2 reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-522"><code>	// != is the inverse of ==.</code></span>
<span class="codeline" id="line-523"><code>	equal, err := eq(arg1, arg2)</code></span>
<span class="codeline" id="line-524"><code>	return !equal, err</code></span>
<span class="codeline" id="line-525"><code>}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>// lt evaluates the comparison a &lt; b.</code></span>
<span class="codeline" id="line-528"><code>func lt(arg1, arg2 reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-529"><code>	arg1 = indirectInterface(arg1)</code></span>
<span class="codeline" id="line-530"><code>	k1, err := basicKind(arg1)</code></span>
<span class="codeline" id="line-531"><code>	if err != nil {</code></span>
<span class="codeline" id="line-532"><code>		return false, err</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code>	arg2 = indirectInterface(arg2)</code></span>
<span class="codeline" id="line-535"><code>	k2, err := basicKind(arg2)</code></span>
<span class="codeline" id="line-536"><code>	if err != nil {</code></span>
<span class="codeline" id="line-537"><code>		return false, err</code></span>
<span class="codeline" id="line-538"><code>	}</code></span>
<span class="codeline" id="line-539"><code>	truth := false</code></span>
<span class="codeline" id="line-540"><code>	if k1 != k2 {</code></span>
<span class="codeline" id="line-541"><code>		// Special case: Can compare integer values regardless of type's sign.</code></span>
<span class="codeline" id="line-542"><code>		switch {</code></span>
<span class="codeline" id="line-543"><code>		case k1 == intKind &amp;&amp; k2 == uintKind:</code></span>
<span class="codeline" id="line-544"><code>			truth = arg1.Int() &lt; 0 || uint64(arg1.Int()) &lt; arg2.Uint()</code></span>
<span class="codeline" id="line-545"><code>		case k1 == uintKind &amp;&amp; k2 == intKind:</code></span>
<span class="codeline" id="line-546"><code>			truth = arg2.Int() &gt;= 0 &amp;&amp; arg1.Uint() &lt; uint64(arg2.Int())</code></span>
<span class="codeline" id="line-547"><code>		default:</code></span>
<span class="codeline" id="line-548"><code>			return false, errBadComparison</code></span>
<span class="codeline" id="line-549"><code>		}</code></span>
<span class="codeline" id="line-550"><code>	} else {</code></span>
<span class="codeline" id="line-551"><code>		switch k1 {</code></span>
<span class="codeline" id="line-552"><code>		case boolKind, complexKind:</code></span>
<span class="codeline" id="line-553"><code>			return false, errBadComparisonType</code></span>
<span class="codeline" id="line-554"><code>		case floatKind:</code></span>
<span class="codeline" id="line-555"><code>			truth = arg1.Float() &lt; arg2.Float()</code></span>
<span class="codeline" id="line-556"><code>		case intKind:</code></span>
<span class="codeline" id="line-557"><code>			truth = arg1.Int() &lt; arg2.Int()</code></span>
<span class="codeline" id="line-558"><code>		case stringKind:</code></span>
<span class="codeline" id="line-559"><code>			truth = arg1.String() &lt; arg2.String()</code></span>
<span class="codeline" id="line-560"><code>		case uintKind:</code></span>
<span class="codeline" id="line-561"><code>			truth = arg1.Uint() &lt; arg2.Uint()</code></span>
<span class="codeline" id="line-562"><code>		default:</code></span>
<span class="codeline" id="line-563"><code>			panic("invalid kind")</code></span>
<span class="codeline" id="line-564"><code>		}</code></span>
<span class="codeline" id="line-565"><code>	}</code></span>
<span class="codeline" id="line-566"><code>	return truth, nil</code></span>
<span class="codeline" id="line-567"><code>}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>// le evaluates the comparison &lt;= b.</code></span>
<span class="codeline" id="line-570"><code>func le(arg1, arg2 reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-571"><code>	// &lt;= is &lt; or ==.</code></span>
<span class="codeline" id="line-572"><code>	lessThan, err := lt(arg1, arg2)</code></span>
<span class="codeline" id="line-573"><code>	if lessThan || err != nil {</code></span>
<span class="codeline" id="line-574"><code>		return lessThan, err</code></span>
<span class="codeline" id="line-575"><code>	}</code></span>
<span class="codeline" id="line-576"><code>	return eq(arg1, arg2)</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// gt evaluates the comparison a &gt; b.</code></span>
<span class="codeline" id="line-580"><code>func gt(arg1, arg2 reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-581"><code>	// &gt; is the inverse of &lt;=.</code></span>
<span class="codeline" id="line-582"><code>	lessOrEqual, err := le(arg1, arg2)</code></span>
<span class="codeline" id="line-583"><code>	if err != nil {</code></span>
<span class="codeline" id="line-584"><code>		return false, err</code></span>
<span class="codeline" id="line-585"><code>	}</code></span>
<span class="codeline" id="line-586"><code>	return !lessOrEqual, nil</code></span>
<span class="codeline" id="line-587"><code>}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>// ge evaluates the comparison a &gt;= b.</code></span>
<span class="codeline" id="line-590"><code>func ge(arg1, arg2 reflect.Value) (bool, error) {</code></span>
<span class="codeline" id="line-591"><code>	// &gt;= is the inverse of &lt;.</code></span>
<span class="codeline" id="line-592"><code>	lessThan, err := lt(arg1, arg2)</code></span>
<span class="codeline" id="line-593"><code>	if err != nil {</code></span>
<span class="codeline" id="line-594"><code>		return false, err</code></span>
<span class="codeline" id="line-595"><code>	}</code></span>
<span class="codeline" id="line-596"><code>	return !lessThan, nil</code></span>
<span class="codeline" id="line-597"><code>}</code></span>
<span class="codeline" id="line-598"><code></code></span>
<span class="codeline" id="line-599"><code>// HTML escaping.</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>var (</code></span>
<span class="codeline" id="line-602"><code>	htmlQuot = []byte("&amp;#34;") // shorter than "&amp;quot;"</code></span>
<span class="codeline" id="line-603"><code>	htmlApos = []byte("&amp;#39;") // shorter than "&amp;apos;" and apos was not in HTML until HTML5</code></span>
<span class="codeline" id="line-604"><code>	htmlAmp  = []byte("&amp;amp;")</code></span>
<span class="codeline" id="line-605"><code>	htmlLt   = []byte("&amp;lt;")</code></span>
<span class="codeline" id="line-606"><code>	htmlGt   = []byte("&amp;gt;")</code></span>
<span class="codeline" id="line-607"><code>	htmlNull = []byte("\uFFFD")</code></span>
<span class="codeline" id="line-608"><code>)</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.</code></span>
<span class="codeline" id="line-611"><code>func HTMLEscape(w io.Writer, b []byte) {</code></span>
<span class="codeline" id="line-612"><code>	last := 0</code></span>
<span class="codeline" id="line-613"><code>	for i, c := range b {</code></span>
<span class="codeline" id="line-614"><code>		var html []byte</code></span>
<span class="codeline" id="line-615"><code>		switch c {</code></span>
<span class="codeline" id="line-616"><code>		case '\000':</code></span>
<span class="codeline" id="line-617"><code>			html = htmlNull</code></span>
<span class="codeline" id="line-618"><code>		case '"':</code></span>
<span class="codeline" id="line-619"><code>			html = htmlQuot</code></span>
<span class="codeline" id="line-620"><code>		case '\'':</code></span>
<span class="codeline" id="line-621"><code>			html = htmlApos</code></span>
<span class="codeline" id="line-622"><code>		case '&amp;':</code></span>
<span class="codeline" id="line-623"><code>			html = htmlAmp</code></span>
<span class="codeline" id="line-624"><code>		case '&lt;':</code></span>
<span class="codeline" id="line-625"><code>			html = htmlLt</code></span>
<span class="codeline" id="line-626"><code>		case '&gt;':</code></span>
<span class="codeline" id="line-627"><code>			html = htmlGt</code></span>
<span class="codeline" id="line-628"><code>		default:</code></span>
<span class="codeline" id="line-629"><code>			continue</code></span>
<span class="codeline" id="line-630"><code>		}</code></span>
<span class="codeline" id="line-631"><code>		w.Write(b[last:i])</code></span>
<span class="codeline" id="line-632"><code>		w.Write(html)</code></span>
<span class="codeline" id="line-633"><code>		last = i + 1</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	w.Write(b[last:])</code></span>
<span class="codeline" id="line-636"><code>}</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.</code></span>
<span class="codeline" id="line-639"><code>func HTMLEscapeString(s string) string {</code></span>
<span class="codeline" id="line-640"><code>	// Avoid allocation if we can.</code></span>
<span class="codeline" id="line-641"><code>	if !strings.ContainsAny(s, "'\"&amp;&lt;&gt;\000") {</code></span>
<span class="codeline" id="line-642"><code>		return s</code></span>
<span class="codeline" id="line-643"><code>	}</code></span>
<span class="codeline" id="line-644"><code>	var b strings.Builder</code></span>
<span class="codeline" id="line-645"><code>	HTMLEscape(&amp;b, []byte(s))</code></span>
<span class="codeline" id="line-646"><code>	return b.String()</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>// HTMLEscaper returns the escaped HTML equivalent of the textual</code></span>
<span class="codeline" id="line-650"><code>// representation of its arguments.</code></span>
<span class="codeline" id="line-651"><code>func HTMLEscaper(args ...any) string {</code></span>
<span class="codeline" id="line-652"><code>	return HTMLEscapeString(evalArgs(args))</code></span>
<span class="codeline" id="line-653"><code>}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>// JavaScript escaping.</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>var (</code></span>
<span class="codeline" id="line-658"><code>	jsLowUni = []byte(`\u00`)</code></span>
<span class="codeline" id="line-659"><code>	hex      = []byte("0123456789ABCDEF")</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>	jsBackslash = []byte(`\\`)</code></span>
<span class="codeline" id="line-662"><code>	jsApos      = []byte(`\'`)</code></span>
<span class="codeline" id="line-663"><code>	jsQuot      = []byte(`\"`)</code></span>
<span class="codeline" id="line-664"><code>	jsLt        = []byte(`\u003C`)</code></span>
<span class="codeline" id="line-665"><code>	jsGt        = []byte(`\u003E`)</code></span>
<span class="codeline" id="line-666"><code>	jsAmp       = []byte(`\u0026`)</code></span>
<span class="codeline" id="line-667"><code>	jsEq        = []byte(`\u003D`)</code></span>
<span class="codeline" id="line-668"><code>)</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</code></span>
<span class="codeline" id="line-671"><code>func JSEscape(w io.Writer, b []byte) {</code></span>
<span class="codeline" id="line-672"><code>	last := 0</code></span>
<span class="codeline" id="line-673"><code>	for i := 0; i &lt; len(b); i++ {</code></span>
<span class="codeline" id="line-674"><code>		c := b[i]</code></span>
<span class="codeline" id="line-675"><code></code></span>
<span class="codeline" id="line-676"><code>		if !jsIsSpecial(rune(c)) {</code></span>
<span class="codeline" id="line-677"><code>			// fast path: nothing to do</code></span>
<span class="codeline" id="line-678"><code>			continue</code></span>
<span class="codeline" id="line-679"><code>		}</code></span>
<span class="codeline" id="line-680"><code>		w.Write(b[last:i])</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-683"><code>			// Quotes, slashes and angle brackets get quoted.</code></span>
<span class="codeline" id="line-684"><code>			// Control characters get written as \u00XX.</code></span>
<span class="codeline" id="line-685"><code>			switch c {</code></span>
<span class="codeline" id="line-686"><code>			case '\\':</code></span>
<span class="codeline" id="line-687"><code>				w.Write(jsBackslash)</code></span>
<span class="codeline" id="line-688"><code>			case '\'':</code></span>
<span class="codeline" id="line-689"><code>				w.Write(jsApos)</code></span>
<span class="codeline" id="line-690"><code>			case '"':</code></span>
<span class="codeline" id="line-691"><code>				w.Write(jsQuot)</code></span>
<span class="codeline" id="line-692"><code>			case '&lt;':</code></span>
<span class="codeline" id="line-693"><code>				w.Write(jsLt)</code></span>
<span class="codeline" id="line-694"><code>			case '&gt;':</code></span>
<span class="codeline" id="line-695"><code>				w.Write(jsGt)</code></span>
<span class="codeline" id="line-696"><code>			case '&amp;':</code></span>
<span class="codeline" id="line-697"><code>				w.Write(jsAmp)</code></span>
<span class="codeline" id="line-698"><code>			case '=':</code></span>
<span class="codeline" id="line-699"><code>				w.Write(jsEq)</code></span>
<span class="codeline" id="line-700"><code>			default:</code></span>
<span class="codeline" id="line-701"><code>				w.Write(jsLowUni)</code></span>
<span class="codeline" id="line-702"><code>				t, b := c&gt;&gt;4, c&amp;0x0f</code></span>
<span class="codeline" id="line-703"><code>				w.Write(hex[t : t+1])</code></span>
<span class="codeline" id="line-704"><code>				w.Write(hex[b : b+1])</code></span>
<span class="codeline" id="line-705"><code>			}</code></span>
<span class="codeline" id="line-706"><code>		} else {</code></span>
<span class="codeline" id="line-707"><code>			// Unicode rune.</code></span>
<span class="codeline" id="line-708"><code>			r, size := utf8.DecodeRune(b[i:])</code></span>
<span class="codeline" id="line-709"><code>			if unicode.IsPrint(r) {</code></span>
<span class="codeline" id="line-710"><code>				w.Write(b[i : i+size])</code></span>
<span class="codeline" id="line-711"><code>			} else {</code></span>
<span class="codeline" id="line-712"><code>				fmt.Fprintf(w, "\\u%04X", r)</code></span>
<span class="codeline" id="line-713"><code>			}</code></span>
<span class="codeline" id="line-714"><code>			i += size - 1</code></span>
<span class="codeline" id="line-715"><code>		}</code></span>
<span class="codeline" id="line-716"><code>		last = i + 1</code></span>
<span class="codeline" id="line-717"><code>	}</code></span>
<span class="codeline" id="line-718"><code>	w.Write(b[last:])</code></span>
<span class="codeline" id="line-719"><code>}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</code></span>
<span class="codeline" id="line-722"><code>func JSEscapeString(s string) string {</code></span>
<span class="codeline" id="line-723"><code>	// Avoid allocation if we can.</code></span>
<span class="codeline" id="line-724"><code>	if strings.IndexFunc(s, jsIsSpecial) &lt; 0 {</code></span>
<span class="codeline" id="line-725"><code>		return s</code></span>
<span class="codeline" id="line-726"><code>	}</code></span>
<span class="codeline" id="line-727"><code>	var b strings.Builder</code></span>
<span class="codeline" id="line-728"><code>	JSEscape(&amp;b, []byte(s))</code></span>
<span class="codeline" id="line-729"><code>	return b.String()</code></span>
<span class="codeline" id="line-730"><code>}</code></span>
<span class="codeline" id="line-731"><code></code></span>
<span class="codeline" id="line-732"><code>func jsIsSpecial(r rune) bool {</code></span>
<span class="codeline" id="line-733"><code>	switch r {</code></span>
<span class="codeline" id="line-734"><code>	case '\\', '\'', '"', '&lt;', '&gt;', '&amp;', '=':</code></span>
<span class="codeline" id="line-735"><code>		return true</code></span>
<span class="codeline" id="line-736"><code>	}</code></span>
<span class="codeline" id="line-737"><code>	return r &lt; ' ' || utf8.RuneSelf &lt;= r</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>// JSEscaper returns the escaped JavaScript equivalent of the textual</code></span>
<span class="codeline" id="line-741"><code>// representation of its arguments.</code></span>
<span class="codeline" id="line-742"><code>func JSEscaper(args ...any) string {</code></span>
<span class="codeline" id="line-743"><code>	return JSEscapeString(evalArgs(args))</code></span>
<span class="codeline" id="line-744"><code>}</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>// URLQueryEscaper returns the escaped value of the textual representation of</code></span>
<span class="codeline" id="line-747"><code>// its arguments in a form suitable for embedding in a URL query.</code></span>
<span class="codeline" id="line-748"><code>func URLQueryEscaper(args ...any) string {</code></span>
<span class="codeline" id="line-749"><code>	return url.QueryEscape(evalArgs(args))</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>// evalArgs formats the list of arguments into a string. It is therefore equivalent to</code></span>
<span class="codeline" id="line-753"><code>//</code></span>
<span class="codeline" id="line-754"><code>//	fmt.Sprint(args...)</code></span>
<span class="codeline" id="line-755"><code>//</code></span>
<span class="codeline" id="line-756"><code>// except that each argument is indirected (if a pointer), as required,</code></span>
<span class="codeline" id="line-757"><code>// using the same rules as the default string evaluation during template</code></span>
<span class="codeline" id="line-758"><code>// execution.</code></span>
<span class="codeline" id="line-759"><code>func evalArgs(args []any) string {</code></span>
<span class="codeline" id="line-760"><code>	ok := false</code></span>
<span class="codeline" id="line-761"><code>	var s string</code></span>
<span class="codeline" id="line-762"><code>	// Fast path for simple common case.</code></span>
<span class="codeline" id="line-763"><code>	if len(args) == 1 {</code></span>
<span class="codeline" id="line-764"><code>		s, ok = args[0].(string)</code></span>
<span class="codeline" id="line-765"><code>	}</code></span>
<span class="codeline" id="line-766"><code>	if !ok {</code></span>
<span class="codeline" id="line-767"><code>		for i, arg := range args {</code></span>
<span class="codeline" id="line-768"><code>			a, ok := printableValue(reflect.ValueOf(arg))</code></span>
<span class="codeline" id="line-769"><code>			if ok {</code></span>
<span class="codeline" id="line-770"><code>				args[i] = a</code></span>
<span class="codeline" id="line-771"><code>			} // else let fmt do its thing</code></span>
<span class="codeline" id="line-772"><code>		}</code></span>
<span class="codeline" id="line-773"><code>		s = fmt.Sprint(args...)</code></span>
<span class="codeline" id="line-774"><code>	}</code></span>
<span class="codeline" id="line-775"><code>	return s</code></span>
<span class="codeline" id="line-776"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>