<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: tabwriter.go in package text/tabwriter</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	tabwriter.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/text/tabwriter.html">text/tabwriter</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package tabwriter implements a write filter (tabwriter.Writer) that</code></span>
<span class="codeline" id="line-6"><code>// translates tabbed columns in input into properly aligned text.</code></span>
<span class="codeline" id="line-7"><code>//</code></span>
<span class="codeline" id="line-8"><code>// The package is using the Elastic Tabstops algorithm described at</code></span>
<span class="codeline" id="line-9"><code>// http://nickgravgaard.com/elastictabstops/index.html.</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// The text/tabwriter package is frozen and is not accepting new features.</code></span></div><span class="codeline" id="line-12"><code>package tabwriter</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>import (</code></span>
<span class="codeline" id="line-15"><code>	"io"</code></span>
<span class="codeline" id="line-16"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// ----------------------------------------------------------------------------</code></span>
<span class="codeline" id="line-20"><code>// Filter implementation</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// A cell represents a segment of text terminated by tabs or line breaks.</code></span>
<span class="codeline" id="line-23"><code>// The text itself is stored in a separate buffer; cell only describes the</code></span>
<span class="codeline" id="line-24"><code>// segment's size in bytes, its width in runes, and whether it's an htab</code></span>
<span class="codeline" id="line-25"><code>// ('\t') terminated cell.</code></span>
<span class="codeline" id="line-26"><code>type cell struct {</code></span>
<span class="codeline" id="line-27"><code>	size  int  // cell size in bytes</code></span>
<span class="codeline" id="line-28"><code>	width int  // cell width in runes</code></span>
<span class="codeline" id="line-29"><code>	htab  bool // true if the cell is terminated by an htab ('\t')</code></span>
<span class="codeline" id="line-30"><code>}</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// A Writer is a filter that inserts padding around tab-delimited</code></span>
<span class="codeline" id="line-33"><code>// columns in its input to align them in the output.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// The Writer treats incoming bytes as UTF-8-encoded text consisting</code></span>
<span class="codeline" id="line-36"><code>// of cells terminated by horizontal ('\t') or vertical ('\v') tabs,</code></span>
<span class="codeline" id="line-37"><code>// and newline ('\n') or formfeed ('\f') characters; both newline and</code></span>
<span class="codeline" id="line-38"><code>// formfeed act as line breaks.</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// Tab-terminated cells in contiguous lines constitute a column. The</code></span>
<span class="codeline" id="line-41"><code>// Writer inserts padding as needed to make all cells in a column have</code></span>
<span class="codeline" id="line-42"><code>// the same width, effectively aligning the columns. It assumes that</code></span>
<span class="codeline" id="line-43"><code>// all characters have the same width, except for tabs for which a</code></span>
<span class="codeline" id="line-44"><code>// tabwidth must be specified. Column cells must be tab-terminated, not</code></span>
<span class="codeline" id="line-45"><code>// tab-separated: non-tab terminated trailing text at the end of a line</code></span>
<span class="codeline" id="line-46"><code>// forms a cell but that cell is not part of an aligned column.</code></span>
<span class="codeline" id="line-47"><code>// For instance, in this example (where | stands for a horizontal tab):</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>//	aaaa|bbb|d</code></span>
<span class="codeline" id="line-50"><code>//	aa  |b  |dd</code></span>
<span class="codeline" id="line-51"><code>//	a   |</code></span>
<span class="codeline" id="line-52"><code>//	aa  |cccc|eee</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// the b and c are in distinct columns (the b column is not contiguous</code></span>
<span class="codeline" id="line-55"><code>// all the way). The d and e are not in a column at all (there's no</code></span>
<span class="codeline" id="line-56"><code>// terminating tab, nor would the column be contiguous).</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// The Writer assumes that all Unicode code points have the same width;</code></span>
<span class="codeline" id="line-59"><code>// this may not be true in some fonts or if the string contains combining</code></span>
<span class="codeline" id="line-60"><code>// characters.</code></span>
<span class="codeline" id="line-61"><code>//</code></span>
<span class="codeline" id="line-62"><code>// If DiscardEmptyColumns is set, empty columns that are terminated</code></span>
<span class="codeline" id="line-63"><code>// entirely by vertical (or "soft") tabs are discarded. Columns</code></span>
<span class="codeline" id="line-64"><code>// terminated by horizontal (or "hard") tabs are not affected by</code></span>
<span class="codeline" id="line-65"><code>// this flag.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// If a Writer is configured to filter HTML, HTML tags and entities</code></span>
<span class="codeline" id="line-68"><code>// are passed through. The widths of tags and entities are</code></span>
<span class="codeline" id="line-69"><code>// assumed to be zero (tags) and one (entities) for formatting purposes.</code></span>
<span class="codeline" id="line-70"><code>//</code></span>
<span class="codeline" id="line-71"><code>// A segment of text may be escaped by bracketing it with Escape</code></span>
<span class="codeline" id="line-72"><code>// characters. The tabwriter passes escaped text segments through</code></span>
<span class="codeline" id="line-73"><code>// unchanged. In particular, it does not interpret any tabs or line</code></span>
<span class="codeline" id="line-74"><code>// breaks within the segment. If the StripEscape flag is set, the</code></span>
<span class="codeline" id="line-75"><code>// Escape characters are stripped from the output; otherwise they</code></span>
<span class="codeline" id="line-76"><code>// are passed through as well. For the purpose of formatting, the</code></span>
<span class="codeline" id="line-77"><code>// width of the escaped text is always computed excluding the Escape</code></span>
<span class="codeline" id="line-78"><code>// characters.</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>// The formfeed character acts like a newline but it also terminates</code></span>
<span class="codeline" id="line-81"><code>// all columns in the current line (effectively calling Flush). Tab-</code></span>
<span class="codeline" id="line-82"><code>// terminated cells in the next line start new columns. Unless found</code></span>
<span class="codeline" id="line-83"><code>// inside an HTML tag or inside an escaped text segment, formfeed</code></span>
<span class="codeline" id="line-84"><code>// characters appear as newlines in the output.</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// The Writer must buffer input internally, because proper spacing</code></span>
<span class="codeline" id="line-87"><code>// of one line may depend on the cells in future lines. Clients must</code></span>
<span class="codeline" id="line-88"><code>// call Flush when done calling Write.</code></span>
<span class="codeline" id="line-89"><code>type Writer struct {</code></span>
<span class="codeline" id="line-90"><code>	// configuration</code></span>
<span class="codeline" id="line-91"><code>	output   io.Writer</code></span>
<span class="codeline" id="line-92"><code>	minwidth int</code></span>
<span class="codeline" id="line-93"><code>	tabwidth int</code></span>
<span class="codeline" id="line-94"><code>	padding  int</code></span>
<span class="codeline" id="line-95"><code>	padbytes [8]byte</code></span>
<span class="codeline" id="line-96"><code>	flags    uint</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>	// current state</code></span>
<span class="codeline" id="line-99"><code>	buf     []byte   // collected text excluding tabs or line breaks</code></span>
<span class="codeline" id="line-100"><code>	pos     int      // buffer position up to which cell.width of incomplete cell has been computed</code></span>
<span class="codeline" id="line-101"><code>	cell    cell     // current incomplete cell; cell.width is up to buf[pos] excluding ignored sections</code></span>
<span class="codeline" id="line-102"><code>	endChar byte     // terminating char of escaped sequence (Escape for escapes, '&gt;', ';' for HTML tags/entities, or 0)</code></span>
<span class="codeline" id="line-103"><code>	lines   [][]cell // list of lines; each line is a list of cells</code></span>
<span class="codeline" id="line-104"><code>	widths  []int    // list of column widths in runes - re-used during formatting</code></span>
<span class="codeline" id="line-105"><code>}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>// addLine adds a new line.</code></span>
<span class="codeline" id="line-108"><code>// flushed is a hint indicating whether the underlying writer was just flushed.</code></span>
<span class="codeline" id="line-109"><code>// If so, the previous line is not likely to be a good indicator of the new line's cells.</code></span>
<span class="codeline" id="line-110"><code>func (b *Writer) addLine(flushed bool) {</code></span>
<span class="codeline" id="line-111"><code>	// Grow slice instead of appending,</code></span>
<span class="codeline" id="line-112"><code>	// as that gives us an opportunity</code></span>
<span class="codeline" id="line-113"><code>	// to re-use an existing []cell.</code></span>
<span class="codeline" id="line-114"><code>	if n := len(b.lines) + 1; n &lt;= cap(b.lines) {</code></span>
<span class="codeline" id="line-115"><code>		b.lines = b.lines[:n]</code></span>
<span class="codeline" id="line-116"><code>		b.lines[n-1] = b.lines[n-1][:0]</code></span>
<span class="codeline" id="line-117"><code>	} else {</code></span>
<span class="codeline" id="line-118"><code>		b.lines = append(b.lines, nil)</code></span>
<span class="codeline" id="line-119"><code>	}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	if !flushed {</code></span>
<span class="codeline" id="line-122"><code>		// The previous line is probably a good indicator</code></span>
<span class="codeline" id="line-123"><code>		// of how many cells the current line will have.</code></span>
<span class="codeline" id="line-124"><code>		// If the current line's capacity is smaller than that,</code></span>
<span class="codeline" id="line-125"><code>		// abandon it and make a new one.</code></span>
<span class="codeline" id="line-126"><code>		if n := len(b.lines); n &gt;= 2 {</code></span>
<span class="codeline" id="line-127"><code>			if prev := len(b.lines[n-2]); prev &gt; cap(b.lines[n-1]) {</code></span>
<span class="codeline" id="line-128"><code>				b.lines[n-1] = make([]cell, 0, prev)</code></span>
<span class="codeline" id="line-129"><code>			}</code></span>
<span class="codeline" id="line-130"><code>		}</code></span>
<span class="codeline" id="line-131"><code>	}</code></span>
<span class="codeline" id="line-132"><code>}</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>// Reset the current state.</code></span>
<span class="codeline" id="line-135"><code>func (b *Writer) reset() {</code></span>
<span class="codeline" id="line-136"><code>	b.buf = b.buf[:0]</code></span>
<span class="codeline" id="line-137"><code>	b.pos = 0</code></span>
<span class="codeline" id="line-138"><code>	b.cell = cell{}</code></span>
<span class="codeline" id="line-139"><code>	b.endChar = 0</code></span>
<span class="codeline" id="line-140"><code>	b.lines = b.lines[0:0]</code></span>
<span class="codeline" id="line-141"><code>	b.widths = b.widths[0:0]</code></span>
<span class="codeline" id="line-142"><code>	b.addLine(true)</code></span>
<span class="codeline" id="line-143"><code>}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// Internal representation (current state):</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// - all text written is appended to buf; tabs and line breaks are stripped away</code></span>
<span class="codeline" id="line-148"><code>// - at any given time there is a (possibly empty) incomplete cell at the end</code></span>
<span class="codeline" id="line-149"><code>//   (the cell starts after a tab or line break)</code></span>
<span class="codeline" id="line-150"><code>// - cell.size is the number of bytes belonging to the cell so far</code></span>
<span class="codeline" id="line-151"><code>// - cell.width is text width in runes of that cell from the start of the cell to</code></span>
<span class="codeline" id="line-152"><code>//   position pos; html tags and entities are excluded from this width if html</code></span>
<span class="codeline" id="line-153"><code>//   filtering is enabled</code></span>
<span class="codeline" id="line-154"><code>// - the sizes and widths of processed text are kept in the lines list</code></span>
<span class="codeline" id="line-155"><code>//   which contains a list of cells for each line</code></span>
<span class="codeline" id="line-156"><code>// - the widths list is a temporary list with current widths used during</code></span>
<span class="codeline" id="line-157"><code>//   formatting; it is kept in Writer because it's re-used</code></span>
<span class="codeline" id="line-158"><code>//</code></span>
<span class="codeline" id="line-159"><code>//                    |&lt;---------- size ----------&gt;|</code></span>
<span class="codeline" id="line-160"><code>//                    |                            |</code></span>
<span class="codeline" id="line-161"><code>//                    |&lt;- width -&gt;|&lt;- ignored -&gt;|  |</code></span>
<span class="codeline" id="line-162"><code>//                    |           |             |  |</code></span>
<span class="codeline" id="line-163"><code>// [---processed---tab------------&lt;tag&gt;...&lt;/tag&gt;...]</code></span>
<span class="codeline" id="line-164"><code>// ^                  ^                         ^</code></span>
<span class="codeline" id="line-165"><code>// |                  |                         |</code></span>
<span class="codeline" id="line-166"><code>// buf                start of incomplete cell  pos</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>// Formatting can be controlled with these flags.</code></span>
<span class="codeline" id="line-169"><code>const (</code></span>
<span class="codeline" id="line-170"><code>	// Ignore html tags and treat entities (starting with '&amp;'</code></span>
<span class="codeline" id="line-171"><code>	// and ending in ';') as single characters (width = 1).</code></span>
<span class="codeline" id="line-172"><code>	FilterHTML uint = 1 &lt;&lt; iota</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	// Strip Escape characters bracketing escaped text segments</code></span>
<span class="codeline" id="line-175"><code>	// instead of passing them through unchanged with the text.</code></span>
<span class="codeline" id="line-176"><code>	StripEscape</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>	// Force right-alignment of cell content.</code></span>
<span class="codeline" id="line-179"><code>	// Default is left-alignment.</code></span>
<span class="codeline" id="line-180"><code>	AlignRight</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>	// Handle empty columns as if they were not present in</code></span>
<span class="codeline" id="line-183"><code>	// the input in the first place.</code></span>
<span class="codeline" id="line-184"><code>	DiscardEmptyColumns</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// Always use tabs for indentation columns (i.e., padding of</code></span>
<span class="codeline" id="line-187"><code>	// leading empty cells on the left) independent of padchar.</code></span>
<span class="codeline" id="line-188"><code>	TabIndent</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>	// Print a vertical bar ('|') between columns (after formatting).</code></span>
<span class="codeline" id="line-191"><code>	// Discarded columns appear as zero-width columns ("||").</code></span>
<span class="codeline" id="line-192"><code>	Debug</code></span>
<span class="codeline" id="line-193"><code>)</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>// A Writer must be initialized with a call to Init. The first parameter (output)</code></span>
<span class="codeline" id="line-196"><code>// specifies the filter output. The remaining parameters control the formatting:</code></span>
<span class="codeline" id="line-197"><code>//</code></span>
<span class="codeline" id="line-198"><code>//	minwidth	minimal cell width including any padding</code></span>
<span class="codeline" id="line-199"><code>//	tabwidth	width of tab characters (equivalent number of spaces)</code></span>
<span class="codeline" id="line-200"><code>//	padding		padding added to a cell before computing its width</code></span>
<span class="codeline" id="line-201"><code>//	padchar		ASCII char used for padding</code></span>
<span class="codeline" id="line-202"><code>//			if padchar == '\t', the Writer will assume that the</code></span>
<span class="codeline" id="line-203"><code>//			width of a '\t' in the formatted output is tabwidth,</code></span>
<span class="codeline" id="line-204"><code>//			and cells are left-aligned independent of align_left</code></span>
<span class="codeline" id="line-205"><code>//			(for correct-looking results, tabwidth must correspond</code></span>
<span class="codeline" id="line-206"><code>//			to the tab width in the viewer displaying the result)</code></span>
<span class="codeline" id="line-207"><code>//	flags		formatting control</code></span>
<span class="codeline" id="line-208"><code>func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {</code></span>
<span class="codeline" id="line-209"><code>	if minwidth &lt; 0 || tabwidth &lt; 0 || padding &lt; 0 {</code></span>
<span class="codeline" id="line-210"><code>		panic("negative minwidth, tabwidth, or padding")</code></span>
<span class="codeline" id="line-211"><code>	}</code></span>
<span class="codeline" id="line-212"><code>	b.output = output</code></span>
<span class="codeline" id="line-213"><code>	b.minwidth = minwidth</code></span>
<span class="codeline" id="line-214"><code>	b.tabwidth = tabwidth</code></span>
<span class="codeline" id="line-215"><code>	b.padding = padding</code></span>
<span class="codeline" id="line-216"><code>	for i := range b.padbytes {</code></span>
<span class="codeline" id="line-217"><code>		b.padbytes[i] = padchar</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code>	if padchar == '\t' {</code></span>
<span class="codeline" id="line-220"><code>		// tab padding enforces left-alignment</code></span>
<span class="codeline" id="line-221"><code>		flags &amp;^= AlignRight</code></span>
<span class="codeline" id="line-222"><code>	}</code></span>
<span class="codeline" id="line-223"><code>	b.flags = flags</code></span>
<span class="codeline" id="line-224"><code></code></span>
<span class="codeline" id="line-225"><code>	b.reset()</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>	return b</code></span>
<span class="codeline" id="line-228"><code>}</code></span>
<span class="codeline" id="line-229"><code></code></span>
<span class="codeline" id="line-230"><code>// debugging support (keep code around)</code></span>
<span class="codeline" id="line-231"><code>func (b *Writer) dump() {</code></span>
<span class="codeline" id="line-232"><code>	pos := 0</code></span>
<span class="codeline" id="line-233"><code>	for i, line := range b.lines {</code></span>
<span class="codeline" id="line-234"><code>		print("(", i, ") ")</code></span>
<span class="codeline" id="line-235"><code>		for _, c := range line {</code></span>
<span class="codeline" id="line-236"><code>			print("[", string(b.buf[pos:pos+c.size]), "]")</code></span>
<span class="codeline" id="line-237"><code>			pos += c.size</code></span>
<span class="codeline" id="line-238"><code>		}</code></span>
<span class="codeline" id="line-239"><code>		print("\n")</code></span>
<span class="codeline" id="line-240"><code>	}</code></span>
<span class="codeline" id="line-241"><code>	print("\n")</code></span>
<span class="codeline" id="line-242"><code>}</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// local error wrapper so we can distinguish errors we want to return</code></span>
<span class="codeline" id="line-245"><code>// as errors from genuine panics (which we don't want to return as errors)</code></span>
<span class="codeline" id="line-246"><code>type osError struct {</code></span>
<span class="codeline" id="line-247"><code>	err error</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>func (b *Writer) write0(buf []byte) {</code></span>
<span class="codeline" id="line-251"><code>	n, err := b.output.Write(buf)</code></span>
<span class="codeline" id="line-252"><code>	if n != len(buf) &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-253"><code>		err = io.ErrShortWrite</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code>	if err != nil {</code></span>
<span class="codeline" id="line-256"><code>		panic(osError{err})</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>func (b *Writer) writeN(src []byte, n int) {</code></span>
<span class="codeline" id="line-261"><code>	for n &gt; len(src) {</code></span>
<span class="codeline" id="line-262"><code>		b.write0(src)</code></span>
<span class="codeline" id="line-263"><code>		n -= len(src)</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>	b.write0(src[0:n])</code></span>
<span class="codeline" id="line-266"><code>}</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>var (</code></span>
<span class="codeline" id="line-269"><code>	newline = []byte{'\n'}</code></span>
<span class="codeline" id="line-270"><code>	tabs    = []byte("\t\t\t\t\t\t\t\t")</code></span>
<span class="codeline" id="line-271"><code>)</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>func (b *Writer) writePadding(textw, cellw int, useTabs bool) {</code></span>
<span class="codeline" id="line-274"><code>	if b.padbytes[0] == '\t' || useTabs {</code></span>
<span class="codeline" id="line-275"><code>		// padding is done with tabs</code></span>
<span class="codeline" id="line-276"><code>		if b.tabwidth == 0 {</code></span>
<span class="codeline" id="line-277"><code>			return // tabs have no width - can't do any padding</code></span>
<span class="codeline" id="line-278"><code>		}</code></span>
<span class="codeline" id="line-279"><code>		// make cellw the smallest multiple of b.tabwidth</code></span>
<span class="codeline" id="line-280"><code>		cellw = (cellw + b.tabwidth - 1) / b.tabwidth * b.tabwidth</code></span>
<span class="codeline" id="line-281"><code>		n := cellw - textw // amount of padding</code></span>
<span class="codeline" id="line-282"><code>		if n &lt; 0 {</code></span>
<span class="codeline" id="line-283"><code>			panic("internal error")</code></span>
<span class="codeline" id="line-284"><code>		}</code></span>
<span class="codeline" id="line-285"><code>		b.writeN(tabs, (n+b.tabwidth-1)/b.tabwidth)</code></span>
<span class="codeline" id="line-286"><code>		return</code></span>
<span class="codeline" id="line-287"><code>	}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>	// padding is done with non-tab characters</code></span>
<span class="codeline" id="line-290"><code>	b.writeN(b.padbytes[0:], cellw-textw)</code></span>
<span class="codeline" id="line-291"><code>}</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>var vbar = []byte{'|'}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>func (b *Writer) writeLines(pos0 int, line0, line1 int) (pos int) {</code></span>
<span class="codeline" id="line-296"><code>	pos = pos0</code></span>
<span class="codeline" id="line-297"><code>	for i := line0; i &lt; line1; i++ {</code></span>
<span class="codeline" id="line-298"><code>		line := b.lines[i]</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>		// if TabIndent is set, use tabs to pad leading empty cells</code></span>
<span class="codeline" id="line-301"><code>		useTabs := b.flags&amp;TabIndent != 0</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>		for j, c := range line {</code></span>
<span class="codeline" id="line-304"><code>			if j &gt; 0 &amp;&amp; b.flags&amp;Debug != 0 {</code></span>
<span class="codeline" id="line-305"><code>				// indicate column break</code></span>
<span class="codeline" id="line-306"><code>				b.write0(vbar)</code></span>
<span class="codeline" id="line-307"><code>			}</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>			if c.size == 0 {</code></span>
<span class="codeline" id="line-310"><code>				// empty cell</code></span>
<span class="codeline" id="line-311"><code>				if j &lt; len(b.widths) {</code></span>
<span class="codeline" id="line-312"><code>					b.writePadding(c.width, b.widths[j], useTabs)</code></span>
<span class="codeline" id="line-313"><code>				}</code></span>
<span class="codeline" id="line-314"><code>			} else {</code></span>
<span class="codeline" id="line-315"><code>				// non-empty cell</code></span>
<span class="codeline" id="line-316"><code>				useTabs = false</code></span>
<span class="codeline" id="line-317"><code>				if b.flags&amp;AlignRight == 0 { // align left</code></span>
<span class="codeline" id="line-318"><code>					b.write0(b.buf[pos : pos+c.size])</code></span>
<span class="codeline" id="line-319"><code>					pos += c.size</code></span>
<span class="codeline" id="line-320"><code>					if j &lt; len(b.widths) {</code></span>
<span class="codeline" id="line-321"><code>						b.writePadding(c.width, b.widths[j], false)</code></span>
<span class="codeline" id="line-322"><code>					}</code></span>
<span class="codeline" id="line-323"><code>				} else { // align right</code></span>
<span class="codeline" id="line-324"><code>					if j &lt; len(b.widths) {</code></span>
<span class="codeline" id="line-325"><code>						b.writePadding(c.width, b.widths[j], false)</code></span>
<span class="codeline" id="line-326"><code>					}</code></span>
<span class="codeline" id="line-327"><code>					b.write0(b.buf[pos : pos+c.size])</code></span>
<span class="codeline" id="line-328"><code>					pos += c.size</code></span>
<span class="codeline" id="line-329"><code>				}</code></span>
<span class="codeline" id="line-330"><code>			}</code></span>
<span class="codeline" id="line-331"><code>		}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>		if i+1 == len(b.lines) {</code></span>
<span class="codeline" id="line-334"><code>			// last buffered line - we don't have a newline, so just write</code></span>
<span class="codeline" id="line-335"><code>			// any outstanding buffered data</code></span>
<span class="codeline" id="line-336"><code>			b.write0(b.buf[pos : pos+b.cell.size])</code></span>
<span class="codeline" id="line-337"><code>			pos += b.cell.size</code></span>
<span class="codeline" id="line-338"><code>		} else {</code></span>
<span class="codeline" id="line-339"><code>			// not the last line - write newline</code></span>
<span class="codeline" id="line-340"><code>			b.write0(newline)</code></span>
<span class="codeline" id="line-341"><code>		}</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code>	return</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>// Format the text between line0 and line1 (excluding line1); pos</code></span>
<span class="codeline" id="line-347"><code>// is the buffer position corresponding to the beginning of line0.</code></span>
<span class="codeline" id="line-348"><code>// Returns the buffer position corresponding to the beginning of</code></span>
<span class="codeline" id="line-349"><code>// line1 and an error, if any.</code></span>
<span class="codeline" id="line-350"><code>func (b *Writer) format(pos0 int, line0, line1 int) (pos int) {</code></span>
<span class="codeline" id="line-351"><code>	pos = pos0</code></span>
<span class="codeline" id="line-352"><code>	column := len(b.widths)</code></span>
<span class="codeline" id="line-353"><code>	for this := line0; this &lt; line1; this++ {</code></span>
<span class="codeline" id="line-354"><code>		line := b.lines[this]</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>		if column &gt;= len(line)-1 {</code></span>
<span class="codeline" id="line-357"><code>			continue</code></span>
<span class="codeline" id="line-358"><code>		}</code></span>
<span class="codeline" id="line-359"><code>		// cell exists in this column =&gt; this line</code></span>
<span class="codeline" id="line-360"><code>		// has more cells than the previous line</code></span>
<span class="codeline" id="line-361"><code>		// (the last cell per line is ignored because cells are</code></span>
<span class="codeline" id="line-362"><code>		// tab-terminated; the last cell per line describes the</code></span>
<span class="codeline" id="line-363"><code>		// text before the newline/formfeed and does not belong</code></span>
<span class="codeline" id="line-364"><code>		// to a column)</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>		// print unprinted lines until beginning of block</code></span>
<span class="codeline" id="line-367"><code>		pos = b.writeLines(pos, line0, this)</code></span>
<span class="codeline" id="line-368"><code>		line0 = this</code></span>
<span class="codeline" id="line-369"><code></code></span>
<span class="codeline" id="line-370"><code>		// column block begin</code></span>
<span class="codeline" id="line-371"><code>		width := b.minwidth // minimal column width</code></span>
<span class="codeline" id="line-372"><code>		discardable := true // true if all cells in this column are empty and "soft"</code></span>
<span class="codeline" id="line-373"><code>		for ; this &lt; line1; this++ {</code></span>
<span class="codeline" id="line-374"><code>			line = b.lines[this]</code></span>
<span class="codeline" id="line-375"><code>			if column &gt;= len(line)-1 {</code></span>
<span class="codeline" id="line-376"><code>				break</code></span>
<span class="codeline" id="line-377"><code>			}</code></span>
<span class="codeline" id="line-378"><code>			// cell exists in this column</code></span>
<span class="codeline" id="line-379"><code>			c := line[column]</code></span>
<span class="codeline" id="line-380"><code>			// update width</code></span>
<span class="codeline" id="line-381"><code>			if w := c.width + b.padding; w &gt; width {</code></span>
<span class="codeline" id="line-382"><code>				width = w</code></span>
<span class="codeline" id="line-383"><code>			}</code></span>
<span class="codeline" id="line-384"><code>			// update discardable</code></span>
<span class="codeline" id="line-385"><code>			if c.width &gt; 0 || c.htab {</code></span>
<span class="codeline" id="line-386"><code>				discardable = false</code></span>
<span class="codeline" id="line-387"><code>			}</code></span>
<span class="codeline" id="line-388"><code>		}</code></span>
<span class="codeline" id="line-389"><code>		// column block end</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>		// discard empty columns if necessary</code></span>
<span class="codeline" id="line-392"><code>		if discardable &amp;&amp; b.flags&amp;DiscardEmptyColumns != 0 {</code></span>
<span class="codeline" id="line-393"><code>			width = 0</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>		// format and print all columns to the right of this column</code></span>
<span class="codeline" id="line-397"><code>		// (we know the widths of this column and all columns to the left)</code></span>
<span class="codeline" id="line-398"><code>		b.widths = append(b.widths, width) // push width</code></span>
<span class="codeline" id="line-399"><code>		pos = b.format(pos, line0, this)</code></span>
<span class="codeline" id="line-400"><code>		b.widths = b.widths[0 : len(b.widths)-1] // pop width</code></span>
<span class="codeline" id="line-401"><code>		line0 = this</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>	// print unprinted lines until end</code></span>
<span class="codeline" id="line-405"><code>	return b.writeLines(pos, line0, line1)</code></span>
<span class="codeline" id="line-406"><code>}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>// Append text to current cell.</code></span>
<span class="codeline" id="line-409"><code>func (b *Writer) append(text []byte) {</code></span>
<span class="codeline" id="line-410"><code>	b.buf = append(b.buf, text...)</code></span>
<span class="codeline" id="line-411"><code>	b.cell.size += len(text)</code></span>
<span class="codeline" id="line-412"><code>}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>// Update the cell width.</code></span>
<span class="codeline" id="line-415"><code>func (b *Writer) updateWidth() {</code></span>
<span class="codeline" id="line-416"><code>	b.cell.width += utf8.RuneCount(b.buf[b.pos:])</code></span>
<span class="codeline" id="line-417"><code>	b.pos = len(b.buf)</code></span>
<span class="codeline" id="line-418"><code>}</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>// To escape a text segment, bracket it with Escape characters.</code></span>
<span class="codeline" id="line-421"><code>// For instance, the tab in this string "Ignore this tab: \xff\t\xff"</code></span>
<span class="codeline" id="line-422"><code>// does not terminate a cell and constitutes a single character of</code></span>
<span class="codeline" id="line-423"><code>// width one for formatting purposes.</code></span>
<span class="codeline" id="line-424"><code>//</code></span>
<span class="codeline" id="line-425"><code>// The value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.</code></span>
<span class="codeline" id="line-426"><code>const Escape = '\xff'</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>// Start escaped mode.</code></span>
<span class="codeline" id="line-429"><code>func (b *Writer) startEscape(ch byte) {</code></span>
<span class="codeline" id="line-430"><code>	switch ch {</code></span>
<span class="codeline" id="line-431"><code>	case Escape:</code></span>
<span class="codeline" id="line-432"><code>		b.endChar = Escape</code></span>
<span class="codeline" id="line-433"><code>	case '&lt;':</code></span>
<span class="codeline" id="line-434"><code>		b.endChar = '&gt;'</code></span>
<span class="codeline" id="line-435"><code>	case '&amp;':</code></span>
<span class="codeline" id="line-436"><code>		b.endChar = ';'</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>}</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>// Terminate escaped mode. If the escaped text was an HTML tag, its width</code></span>
<span class="codeline" id="line-441"><code>// is assumed to be zero for formatting purposes; if it was an HTML entity,</code></span>
<span class="codeline" id="line-442"><code>// its width is assumed to be one. In all other cases, the width is the</code></span>
<span class="codeline" id="line-443"><code>// unicode width of the text.</code></span>
<span class="codeline" id="line-444"><code>func (b *Writer) endEscape() {</code></span>
<span class="codeline" id="line-445"><code>	switch b.endChar {</code></span>
<span class="codeline" id="line-446"><code>	case Escape:</code></span>
<span class="codeline" id="line-447"><code>		b.updateWidth()</code></span>
<span class="codeline" id="line-448"><code>		if b.flags&amp;StripEscape == 0 {</code></span>
<span class="codeline" id="line-449"><code>			b.cell.width -= 2 // don't count the Escape chars</code></span>
<span class="codeline" id="line-450"><code>		}</code></span>
<span class="codeline" id="line-451"><code>	case '&gt;': // tag of zero width</code></span>
<span class="codeline" id="line-452"><code>	case ';':</code></span>
<span class="codeline" id="line-453"><code>		b.cell.width++ // entity, count as one rune</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	b.pos = len(b.buf)</code></span>
<span class="codeline" id="line-456"><code>	b.endChar = 0</code></span>
<span class="codeline" id="line-457"><code>}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>// Terminate the current cell by adding it to the list of cells of the</code></span>
<span class="codeline" id="line-460"><code>// current line. Returns the number of cells in that line.</code></span>
<span class="codeline" id="line-461"><code>func (b *Writer) terminateCell(htab bool) int {</code></span>
<span class="codeline" id="line-462"><code>	b.cell.htab = htab</code></span>
<span class="codeline" id="line-463"><code>	line := &amp;b.lines[len(b.lines)-1]</code></span>
<span class="codeline" id="line-464"><code>	*line = append(*line, b.cell)</code></span>
<span class="codeline" id="line-465"><code>	b.cell = cell{}</code></span>
<span class="codeline" id="line-466"><code>	return len(*line)</code></span>
<span class="codeline" id="line-467"><code>}</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>func (b *Writer) handlePanic(err *error, op string) {</code></span>
<span class="codeline" id="line-470"><code>	if e := recover(); e != nil {</code></span>
<span class="codeline" id="line-471"><code>		if op == "Flush" {</code></span>
<span class="codeline" id="line-472"><code>			// If Flush ran into a panic, we still need to reset.</code></span>
<span class="codeline" id="line-473"><code>			b.reset()</code></span>
<span class="codeline" id="line-474"><code>		}</code></span>
<span class="codeline" id="line-475"><code>		if nerr, ok := e.(osError); ok {</code></span>
<span class="codeline" id="line-476"><code>			*err = nerr.err</code></span>
<span class="codeline" id="line-477"><code>			return</code></span>
<span class="codeline" id="line-478"><code>		}</code></span>
<span class="codeline" id="line-479"><code>		panic("tabwriter: panic during " + op)</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code>}</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>// Flush should be called after the last call to Write to ensure</code></span>
<span class="codeline" id="line-484"><code>// that any data buffered in the Writer is written to output. Any</code></span>
<span class="codeline" id="line-485"><code>// incomplete escape sequence at the end is considered</code></span>
<span class="codeline" id="line-486"><code>// complete for formatting purposes.</code></span>
<span class="codeline" id="line-487"><code>func (b *Writer) Flush() error {</code></span>
<span class="codeline" id="line-488"><code>	return b.flush()</code></span>
<span class="codeline" id="line-489"><code>}</code></span>
<span class="codeline" id="line-490"><code></code></span>
<span class="codeline" id="line-491"><code>// flush is the internal version of Flush, with a named return value which we</code></span>
<span class="codeline" id="line-492"><code>// don't want to expose.</code></span>
<span class="codeline" id="line-493"><code>func (b *Writer) flush() (err error) {</code></span>
<span class="codeline" id="line-494"><code>	defer b.handlePanic(&amp;err, "Flush")</code></span>
<span class="codeline" id="line-495"><code>	b.flushNoDefers()</code></span>
<span class="codeline" id="line-496"><code>	return nil</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>// flushNoDefers is like flush, but without a deferred handlePanic call. This</code></span>
<span class="codeline" id="line-500"><code>// can be called from other methods which already have their own deferred</code></span>
<span class="codeline" id="line-501"><code>// handlePanic calls, such as Write, and avoid the extra defer work.</code></span>
<span class="codeline" id="line-502"><code>func (b *Writer) flushNoDefers() {</code></span>
<span class="codeline" id="line-503"><code>	// add current cell if not empty</code></span>
<span class="codeline" id="line-504"><code>	if b.cell.size &gt; 0 {</code></span>
<span class="codeline" id="line-505"><code>		if b.endChar != 0 {</code></span>
<span class="codeline" id="line-506"><code>			// inside escape - terminate it even if incomplete</code></span>
<span class="codeline" id="line-507"><code>			b.endEscape()</code></span>
<span class="codeline" id="line-508"><code>		}</code></span>
<span class="codeline" id="line-509"><code>		b.terminateCell(false)</code></span>
<span class="codeline" id="line-510"><code>	}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>	// format contents of buffer</code></span>
<span class="codeline" id="line-513"><code>	b.format(0, 0, len(b.lines))</code></span>
<span class="codeline" id="line-514"><code>	b.reset()</code></span>
<span class="codeline" id="line-515"><code>}</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>var hbar = []byte("---\n")</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>// Write writes buf to the writer b.</code></span>
<span class="codeline" id="line-520"><code>// The only errors returned are ones encountered</code></span>
<span class="codeline" id="line-521"><code>// while writing to the underlying output stream.</code></span>
<span class="codeline" id="line-522"><code>func (b *Writer) Write(buf []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-523"><code>	defer b.handlePanic(&amp;err, "Write")</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>	// split text into cells</code></span>
<span class="codeline" id="line-526"><code>	n = 0</code></span>
<span class="codeline" id="line-527"><code>	for i, ch := range buf {</code></span>
<span class="codeline" id="line-528"><code>		if b.endChar == 0 {</code></span>
<span class="codeline" id="line-529"><code>			// outside escape</code></span>
<span class="codeline" id="line-530"><code>			switch ch {</code></span>
<span class="codeline" id="line-531"><code>			case '\t', '\v', '\n', '\f':</code></span>
<span class="codeline" id="line-532"><code>				// end of cell</code></span>
<span class="codeline" id="line-533"><code>				b.append(buf[n:i])</code></span>
<span class="codeline" id="line-534"><code>				b.updateWidth()</code></span>
<span class="codeline" id="line-535"><code>				n = i + 1 // ch consumed</code></span>
<span class="codeline" id="line-536"><code>				ncells := b.terminateCell(ch == '\t')</code></span>
<span class="codeline" id="line-537"><code>				if ch == '\n' || ch == '\f' {</code></span>
<span class="codeline" id="line-538"><code>					// terminate line</code></span>
<span class="codeline" id="line-539"><code>					b.addLine(ch == '\f')</code></span>
<span class="codeline" id="line-540"><code>					if ch == '\f' || ncells == 1 {</code></span>
<span class="codeline" id="line-541"><code>						// A '\f' always forces a flush. Otherwise, if the previous</code></span>
<span class="codeline" id="line-542"><code>						// line has only one cell which does not have an impact on</code></span>
<span class="codeline" id="line-543"><code>						// the formatting of the following lines (the last cell per</code></span>
<span class="codeline" id="line-544"><code>						// line is ignored by format()), thus we can flush the</code></span>
<span class="codeline" id="line-545"><code>						// Writer contents.</code></span>
<span class="codeline" id="line-546"><code>						b.flushNoDefers()</code></span>
<span class="codeline" id="line-547"><code>						if ch == '\f' &amp;&amp; b.flags&amp;Debug != 0 {</code></span>
<span class="codeline" id="line-548"><code>							// indicate section break</code></span>
<span class="codeline" id="line-549"><code>							b.write0(hbar)</code></span>
<span class="codeline" id="line-550"><code>						}</code></span>
<span class="codeline" id="line-551"><code>					}</code></span>
<span class="codeline" id="line-552"><code>				}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>			case Escape:</code></span>
<span class="codeline" id="line-555"><code>				// start of escaped sequence</code></span>
<span class="codeline" id="line-556"><code>				b.append(buf[n:i])</code></span>
<span class="codeline" id="line-557"><code>				b.updateWidth()</code></span>
<span class="codeline" id="line-558"><code>				n = i</code></span>
<span class="codeline" id="line-559"><code>				if b.flags&amp;StripEscape != 0 {</code></span>
<span class="codeline" id="line-560"><code>					n++ // strip Escape</code></span>
<span class="codeline" id="line-561"><code>				}</code></span>
<span class="codeline" id="line-562"><code>				b.startEscape(Escape)</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>			case '&lt;', '&amp;':</code></span>
<span class="codeline" id="line-565"><code>				// possibly an html tag/entity</code></span>
<span class="codeline" id="line-566"><code>				if b.flags&amp;FilterHTML != 0 {</code></span>
<span class="codeline" id="line-567"><code>					// begin of tag/entity</code></span>
<span class="codeline" id="line-568"><code>					b.append(buf[n:i])</code></span>
<span class="codeline" id="line-569"><code>					b.updateWidth()</code></span>
<span class="codeline" id="line-570"><code>					n = i</code></span>
<span class="codeline" id="line-571"><code>					b.startEscape(ch)</code></span>
<span class="codeline" id="line-572"><code>				}</code></span>
<span class="codeline" id="line-573"><code>			}</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>		} else {</code></span>
<span class="codeline" id="line-576"><code>			// inside escape</code></span>
<span class="codeline" id="line-577"><code>			if ch == b.endChar {</code></span>
<span class="codeline" id="line-578"><code>				// end of tag/entity</code></span>
<span class="codeline" id="line-579"><code>				j := i + 1</code></span>
<span class="codeline" id="line-580"><code>				if ch == Escape &amp;&amp; b.flags&amp;StripEscape != 0 {</code></span>
<span class="codeline" id="line-581"><code>					j = i // strip Escape</code></span>
<span class="codeline" id="line-582"><code>				}</code></span>
<span class="codeline" id="line-583"><code>				b.append(buf[n:j])</code></span>
<span class="codeline" id="line-584"><code>				n = i + 1 // ch consumed</code></span>
<span class="codeline" id="line-585"><code>				b.endEscape()</code></span>
<span class="codeline" id="line-586"><code>			}</code></span>
<span class="codeline" id="line-587"><code>		}</code></span>
<span class="codeline" id="line-588"><code>	}</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>	// append leftover text</code></span>
<span class="codeline" id="line-591"><code>	b.append(buf[n:])</code></span>
<span class="codeline" id="line-592"><code>	n = len(buf)</code></span>
<span class="codeline" id="line-593"><code>	return</code></span>
<span class="codeline" id="line-594"><code>}</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>// NewWriter allocates and initializes a new tabwriter.Writer.</code></span>
<span class="codeline" id="line-597"><code>// The parameters are the same as for the Init function.</code></span>
<span class="codeline" id="line-598"><code>func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {</code></span>
<span class="codeline" id="line-599"><code>	return new(Writer).Init(output, minwidth, tabwidth, padding, padchar, flags)</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>