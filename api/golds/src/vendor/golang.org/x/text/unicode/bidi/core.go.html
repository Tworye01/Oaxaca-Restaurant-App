<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: core.go in package vendor/golang.org/x/text/unicode/bidi</title>
<link href="../../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	core.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../../pkg/vendor/golang.org/x/text/unicode/bidi.html">vendor/golang.org/x/text/unicode/bidi</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2015 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package bidi</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"fmt"</code></span>
<span class="codeline" id="line-9"><code>	"log"</code></span>
<span class="codeline" id="line-10"><code>)</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>// This implementation is a port based on the reference implementation found at:</code></span>
<span class="codeline" id="line-13"><code>// https://www.unicode.org/Public/PROGRAMS/BidiReferenceJava/</code></span>
<span class="codeline" id="line-14"><code>//</code></span>
<span class="codeline" id="line-15"><code>// described in Unicode Bidirectional Algorithm (UAX #9).</code></span>
<span class="codeline" id="line-16"><code>//</code></span>
<span class="codeline" id="line-17"><code>// Input:</code></span>
<span class="codeline" id="line-18"><code>// There are two levels of input to the algorithm, since clients may prefer to</code></span>
<span class="codeline" id="line-19"><code>// supply some information from out-of-band sources rather than relying on the</code></span>
<span class="codeline" id="line-20"><code>// default behavior.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// - Bidi class array</code></span>
<span class="codeline" id="line-23"><code>// - Bidi class array, with externally supplied base line direction</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// Output:</code></span>
<span class="codeline" id="line-26"><code>// Output is separated into several stages:</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>//  - levels array over entire paragraph</code></span>
<span class="codeline" id="line-29"><code>//  - reordering array over entire paragraph</code></span>
<span class="codeline" id="line-30"><code>//  - levels array over line</code></span>
<span class="codeline" id="line-31"><code>//  - reordering array over line</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// Note that for conformance to the Unicode Bidirectional Algorithm,</code></span>
<span class="codeline" id="line-34"><code>// implementations are only required to generate correct reordering and</code></span>
<span class="codeline" id="line-35"><code>// character directionality (odd or even levels) over a line. Generating</code></span>
<span class="codeline" id="line-36"><code>// identical level arrays over a line is not required. Bidi explicit format</code></span>
<span class="codeline" id="line-37"><code>// codes (LRE, RLE, LRO, RLO, PDF) and BN can be assigned arbitrary levels and</code></span>
<span class="codeline" id="line-38"><code>// positions as long as the rest of the input is properly reordered.</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// As the algorithm is defined to operate on a single paragraph at a time, this</code></span>
<span class="codeline" id="line-41"><code>// implementation is written to handle single paragraphs. Thus rule P1 is</code></span>
<span class="codeline" id="line-42"><code>// presumed by this implementation-- the data provided to the implementation is</code></span>
<span class="codeline" id="line-43"><code>// assumed to be a single paragraph, and either contains no 'B' codes, or a</code></span>
<span class="codeline" id="line-44"><code>// single 'B' code at the end of the input. 'B' is allowed as input to</code></span>
<span class="codeline" id="line-45"><code>// illustrate how the algorithm assigns it a level.</code></span>
<span class="codeline" id="line-46"><code>//</code></span>
<span class="codeline" id="line-47"><code>// Also note that rules L3 and L4 depend on the rendering engine that uses the</code></span>
<span class="codeline" id="line-48"><code>// result of the bidi algorithm. This implementation assumes that the rendering</code></span>
<span class="codeline" id="line-49"><code>// engine expects combining marks in visual order (e.g. to the left of their</code></span>
<span class="codeline" id="line-50"><code>// base character in RTL runs) and that it adjusts the glyphs used to render</code></span>
<span class="codeline" id="line-51"><code>// mirrored characters that are in RTL runs so that they render appropriately.</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>// level is the embedding level of a character. Even embedding levels indicate</code></span>
<span class="codeline" id="line-54"><code>// left-to-right order and odd levels indicate right-to-left order. The special</code></span>
<span class="codeline" id="line-55"><code>// level of -1 is reserved for undefined order.</code></span>
<span class="codeline" id="line-56"><code>type level int8</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>const implicitLevel level = -1</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// in returns if x is equal to any of the values in set.</code></span>
<span class="codeline" id="line-61"><code>func (c Class) in(set ...Class) bool {</code></span>
<span class="codeline" id="line-62"><code>	for _, s := range set {</code></span>
<span class="codeline" id="line-63"><code>		if c == s {</code></span>
<span class="codeline" id="line-64"><code>			return true</code></span>
<span class="codeline" id="line-65"><code>		}</code></span>
<span class="codeline" id="line-66"><code>	}</code></span>
<span class="codeline" id="line-67"><code>	return false</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// A paragraph contains the state of a paragraph.</code></span>
<span class="codeline" id="line-71"><code>type paragraph struct {</code></span>
<span class="codeline" id="line-72"><code>	initialTypes []Class</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>	// Arrays of properties needed for paired bracket evaluation in N0</code></span>
<span class="codeline" id="line-75"><code>	pairTypes  []bracketType // paired Bracket types for paragraph</code></span>
<span class="codeline" id="line-76"><code>	pairValues []rune        // rune for opening bracket or pbOpen and pbClose; 0 for pbNone</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>	embeddingLevel level // default: = implicitLevel;</code></span>
<span class="codeline" id="line-79"><code></code></span>
<span class="codeline" id="line-80"><code>	// at the paragraph levels</code></span>
<span class="codeline" id="line-81"><code>	resultTypes  []Class</code></span>
<span class="codeline" id="line-82"><code>	resultLevels []level</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>	// Index of matching PDI for isolate initiator characters. For other</code></span>
<span class="codeline" id="line-85"><code>	// characters, the value of matchingPDI will be set to -1. For isolate</code></span>
<span class="codeline" id="line-86"><code>	// initiators with no matching PDI, matchingPDI will be set to the length of</code></span>
<span class="codeline" id="line-87"><code>	// the input string.</code></span>
<span class="codeline" id="line-88"><code>	matchingPDI []int</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>	// Index of matching isolate initiator for PDI characters. For other</code></span>
<span class="codeline" id="line-91"><code>	// characters, and for PDIs with no matching isolate initiator, the value of</code></span>
<span class="codeline" id="line-92"><code>	// matchingIsolateInitiator will be set to -1.</code></span>
<span class="codeline" id="line-93"><code>	matchingIsolateInitiator []int</code></span>
<span class="codeline" id="line-94"><code>}</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>// newParagraph initializes a paragraph. The user needs to supply a few arrays</code></span>
<span class="codeline" id="line-97"><code>// corresponding to the preprocessed text input. The types correspond to the</code></span>
<span class="codeline" id="line-98"><code>// Unicode BiDi classes for each rune. pairTypes indicates the bracket type for</code></span>
<span class="codeline" id="line-99"><code>// each rune. pairValues provides a unique bracket class identifier for each</code></span>
<span class="codeline" id="line-100"><code>// rune (suggested is the rune of the open bracket for opening and matching</code></span>
<span class="codeline" id="line-101"><code>// close brackets, after normalization). The embedding levels are optional, but</code></span>
<span class="codeline" id="line-102"><code>// may be supplied to encode embedding levels of styled text.</code></span>
<span class="codeline" id="line-103"><code>func newParagraph(types []Class, pairTypes []bracketType, pairValues []rune, levels level) (*paragraph, error) {</code></span>
<span class="codeline" id="line-104"><code>	var err error</code></span>
<span class="codeline" id="line-105"><code>	if err = validateTypes(types); err != nil {</code></span>
<span class="codeline" id="line-106"><code>		return nil, err</code></span>
<span class="codeline" id="line-107"><code>	}</code></span>
<span class="codeline" id="line-108"><code>	if err = validatePbTypes(pairTypes); err != nil {</code></span>
<span class="codeline" id="line-109"><code>		return nil, err</code></span>
<span class="codeline" id="line-110"><code>	}</code></span>
<span class="codeline" id="line-111"><code>	if err = validatePbValues(pairValues, pairTypes); err != nil {</code></span>
<span class="codeline" id="line-112"><code>		return nil, err</code></span>
<span class="codeline" id="line-113"><code>	}</code></span>
<span class="codeline" id="line-114"><code>	if err = validateParagraphEmbeddingLevel(levels); err != nil {</code></span>
<span class="codeline" id="line-115"><code>		return nil, err</code></span>
<span class="codeline" id="line-116"><code>	}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>	p := &amp;paragraph{</code></span>
<span class="codeline" id="line-119"><code>		initialTypes:   append([]Class(nil), types...),</code></span>
<span class="codeline" id="line-120"><code>		embeddingLevel: levels,</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>		pairTypes:  pairTypes,</code></span>
<span class="codeline" id="line-123"><code>		pairValues: pairValues,</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>		resultTypes: append([]Class(nil), types...),</code></span>
<span class="codeline" id="line-126"><code>	}</code></span>
<span class="codeline" id="line-127"><code>	p.run()</code></span>
<span class="codeline" id="line-128"><code>	return p, nil</code></span>
<span class="codeline" id="line-129"><code>}</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>func (p *paragraph) Len() int { return len(p.initialTypes) }</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>// The algorithm. Does not include line-based processing (Rules L1, L2).</code></span>
<span class="codeline" id="line-134"><code>// These are applied later in the line-based phase of the algorithm.</code></span>
<span class="codeline" id="line-135"><code>func (p *paragraph) run() {</code></span>
<span class="codeline" id="line-136"><code>	p.determineMatchingIsolates()</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>	// 1) determining the paragraph level</code></span>
<span class="codeline" id="line-139"><code>	// Rule P1 is the requirement for entering this algorithm.</code></span>
<span class="codeline" id="line-140"><code>	// Rules P2, P3.</code></span>
<span class="codeline" id="line-141"><code>	// If no externally supplied paragraph embedding level, use default.</code></span>
<span class="codeline" id="line-142"><code>	if p.embeddingLevel == implicitLevel {</code></span>
<span class="codeline" id="line-143"><code>		p.embeddingLevel = p.determineParagraphEmbeddingLevel(0, p.Len())</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	// Initialize result levels to paragraph embedding level.</code></span>
<span class="codeline" id="line-147"><code>	p.resultLevels = make([]level, p.Len())</code></span>
<span class="codeline" id="line-148"><code>	setLevels(p.resultLevels, p.embeddingLevel)</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>	// 2) Explicit levels and directions</code></span>
<span class="codeline" id="line-151"><code>	// Rules X1-X8.</code></span>
<span class="codeline" id="line-152"><code>	p.determineExplicitEmbeddingLevels()</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>	// Rule X9.</code></span>
<span class="codeline" id="line-155"><code>	// We do not remove the embeddings, the overrides, the PDFs, and the BNs</code></span>
<span class="codeline" id="line-156"><code>	// from the string explicitly. But they are not copied into isolating run</code></span>
<span class="codeline" id="line-157"><code>	// sequences when they are created, so they are removed for all</code></span>
<span class="codeline" id="line-158"><code>	// practical purposes.</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>	// Rule X10.</code></span>
<span class="codeline" id="line-161"><code>	// Run remainder of algorithm one isolating run sequence at a time</code></span>
<span class="codeline" id="line-162"><code>	for _, seq := range p.determineIsolatingRunSequences() {</code></span>
<span class="codeline" id="line-163"><code>		// 3) resolving weak types</code></span>
<span class="codeline" id="line-164"><code>		// Rules W1-W7.</code></span>
<span class="codeline" id="line-165"><code>		seq.resolveWeakTypes()</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>		// 4a) resolving paired brackets</code></span>
<span class="codeline" id="line-168"><code>		// Rule N0</code></span>
<span class="codeline" id="line-169"><code>		resolvePairedBrackets(seq)</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>		// 4b) resolving neutral types</code></span>
<span class="codeline" id="line-172"><code>		// Rules N1-N3.</code></span>
<span class="codeline" id="line-173"><code>		seq.resolveNeutralTypes()</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>		// 5) resolving implicit embedding levels</code></span>
<span class="codeline" id="line-176"><code>		// Rules I1, I2.</code></span>
<span class="codeline" id="line-177"><code>		seq.resolveImplicitLevels()</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>		// Apply the computed levels and types</code></span>
<span class="codeline" id="line-180"><code>		seq.applyLevelsAndTypes()</code></span>
<span class="codeline" id="line-181"><code>	}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>	// Assign appropriate levels to 'hide' LREs, RLEs, LROs, RLOs, PDFs, and</code></span>
<span class="codeline" id="line-184"><code>	// BNs. This is for convenience, so the resulting level array will have</code></span>
<span class="codeline" id="line-185"><code>	// a value for every character.</code></span>
<span class="codeline" id="line-186"><code>	p.assignLevelsToCharactersRemovedByX9()</code></span>
<span class="codeline" id="line-187"><code>}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>// determineMatchingIsolates determines the matching PDI for each isolate</code></span>
<span class="codeline" id="line-190"><code>// initiator and vice versa.</code></span>
<span class="codeline" id="line-191"><code>//</code></span>
<span class="codeline" id="line-192"><code>// Definition BD9.</code></span>
<span class="codeline" id="line-193"><code>//</code></span>
<span class="codeline" id="line-194"><code>// At the end of this function:</code></span>
<span class="codeline" id="line-195"><code>//</code></span>
<span class="codeline" id="line-196"><code>//   - The member variable matchingPDI is set to point to the index of the</code></span>
<span class="codeline" id="line-197"><code>//     matching PDI character for each isolate initiator character. If there is</code></span>
<span class="codeline" id="line-198"><code>//     no matching PDI, it is set to the length of the input text. For other</code></span>
<span class="codeline" id="line-199"><code>//     characters, it is set to -1.</code></span>
<span class="codeline" id="line-200"><code>//   - The member variable matchingIsolateInitiator is set to point to the</code></span>
<span class="codeline" id="line-201"><code>//     index of the matching isolate initiator character for each PDI character.</code></span>
<span class="codeline" id="line-202"><code>//     If there is no matching isolate initiator, or the character is not a PDI,</code></span>
<span class="codeline" id="line-203"><code>//     it is set to -1.</code></span>
<span class="codeline" id="line-204"><code>func (p *paragraph) determineMatchingIsolates() {</code></span>
<span class="codeline" id="line-205"><code>	p.matchingPDI = make([]int, p.Len())</code></span>
<span class="codeline" id="line-206"><code>	p.matchingIsolateInitiator = make([]int, p.Len())</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	for i := range p.matchingIsolateInitiator {</code></span>
<span class="codeline" id="line-209"><code>		p.matchingIsolateInitiator[i] = -1</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	for i := range p.matchingPDI {</code></span>
<span class="codeline" id="line-213"><code>		p.matchingPDI[i] = -1</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>		if t := p.resultTypes[i]; t.in(LRI, RLI, FSI) {</code></span>
<span class="codeline" id="line-216"><code>			depthCounter := 1</code></span>
<span class="codeline" id="line-217"><code>			for j := i + 1; j &lt; p.Len(); j++ {</code></span>
<span class="codeline" id="line-218"><code>				if u := p.resultTypes[j]; u.in(LRI, RLI, FSI) {</code></span>
<span class="codeline" id="line-219"><code>					depthCounter++</code></span>
<span class="codeline" id="line-220"><code>				} else if u == PDI {</code></span>
<span class="codeline" id="line-221"><code>					if depthCounter--; depthCounter == 0 {</code></span>
<span class="codeline" id="line-222"><code>						p.matchingPDI[i] = j</code></span>
<span class="codeline" id="line-223"><code>						p.matchingIsolateInitiator[j] = i</code></span>
<span class="codeline" id="line-224"><code>						break</code></span>
<span class="codeline" id="line-225"><code>					}</code></span>
<span class="codeline" id="line-226"><code>				}</code></span>
<span class="codeline" id="line-227"><code>			}</code></span>
<span class="codeline" id="line-228"><code>			if p.matchingPDI[i] == -1 {</code></span>
<span class="codeline" id="line-229"><code>				p.matchingPDI[i] = p.Len()</code></span>
<span class="codeline" id="line-230"><code>			}</code></span>
<span class="codeline" id="line-231"><code>		}</code></span>
<span class="codeline" id="line-232"><code>	}</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>// determineParagraphEmbeddingLevel reports the resolved paragraph direction of</code></span>
<span class="codeline" id="line-236"><code>// the substring limited by the given range [start, end).</code></span>
<span class="codeline" id="line-237"><code>//</code></span>
<span class="codeline" id="line-238"><code>// Determines the paragraph level based on rules P2, P3. This is also used</code></span>
<span class="codeline" id="line-239"><code>// in rule X5c to find if an FSI should resolve to LRI or RLI.</code></span>
<span class="codeline" id="line-240"><code>func (p *paragraph) determineParagraphEmbeddingLevel(start, end int) level {</code></span>
<span class="codeline" id="line-241"><code>	var strongType Class = unknownClass</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>	// Rule P2.</code></span>
<span class="codeline" id="line-244"><code>	for i := start; i &lt; end; i++ {</code></span>
<span class="codeline" id="line-245"><code>		if t := p.resultTypes[i]; t.in(L, AL, R) {</code></span>
<span class="codeline" id="line-246"><code>			strongType = t</code></span>
<span class="codeline" id="line-247"><code>			break</code></span>
<span class="codeline" id="line-248"><code>		} else if t.in(FSI, LRI, RLI) {</code></span>
<span class="codeline" id="line-249"><code>			i = p.matchingPDI[i] // skip over to the matching PDI</code></span>
<span class="codeline" id="line-250"><code>			if i &gt; end {</code></span>
<span class="codeline" id="line-251"><code>				log.Panic("assert (i &lt;= end)")</code></span>
<span class="codeline" id="line-252"><code>			}</code></span>
<span class="codeline" id="line-253"><code>		}</code></span>
<span class="codeline" id="line-254"><code>	}</code></span>
<span class="codeline" id="line-255"><code>	// Rule P3.</code></span>
<span class="codeline" id="line-256"><code>	switch strongType {</code></span>
<span class="codeline" id="line-257"><code>	case unknownClass: // none found</code></span>
<span class="codeline" id="line-258"><code>		// default embedding level when no strong types found is 0.</code></span>
<span class="codeline" id="line-259"><code>		return 0</code></span>
<span class="codeline" id="line-260"><code>	case L:</code></span>
<span class="codeline" id="line-261"><code>		return 0</code></span>
<span class="codeline" id="line-262"><code>	default: // AL, R</code></span>
<span class="codeline" id="line-263"><code>		return 1</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>}</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>const maxDepth = 125</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>// This stack will store the embedding levels and override and isolated</code></span>
<span class="codeline" id="line-270"><code>// statuses</code></span>
<span class="codeline" id="line-271"><code>type directionalStatusStack struct {</code></span>
<span class="codeline" id="line-272"><code>	stackCounter        int</code></span>
<span class="codeline" id="line-273"><code>	embeddingLevelStack [maxDepth + 1]level</code></span>
<span class="codeline" id="line-274"><code>	overrideStatusStack [maxDepth + 1]Class</code></span>
<span class="codeline" id="line-275"><code>	isolateStatusStack  [maxDepth + 1]bool</code></span>
<span class="codeline" id="line-276"><code>}</code></span>
<span class="codeline" id="line-277"><code></code></span>
<span class="codeline" id="line-278"><code>func (s *directionalStatusStack) empty()     { s.stackCounter = 0 }</code></span>
<span class="codeline" id="line-279"><code>func (s *directionalStatusStack) pop()       { s.stackCounter-- }</code></span>
<span class="codeline" id="line-280"><code>func (s *directionalStatusStack) depth() int { return s.stackCounter }</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>func (s *directionalStatusStack) push(level level, overrideStatus Class, isolateStatus bool) {</code></span>
<span class="codeline" id="line-283"><code>	s.embeddingLevelStack[s.stackCounter] = level</code></span>
<span class="codeline" id="line-284"><code>	s.overrideStatusStack[s.stackCounter] = overrideStatus</code></span>
<span class="codeline" id="line-285"><code>	s.isolateStatusStack[s.stackCounter] = isolateStatus</code></span>
<span class="codeline" id="line-286"><code>	s.stackCounter++</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>func (s *directionalStatusStack) lastEmbeddingLevel() level {</code></span>
<span class="codeline" id="line-290"><code>	return s.embeddingLevelStack[s.stackCounter-1]</code></span>
<span class="codeline" id="line-291"><code>}</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>func (s *directionalStatusStack) lastDirectionalOverrideStatus() Class {</code></span>
<span class="codeline" id="line-294"><code>	return s.overrideStatusStack[s.stackCounter-1]</code></span>
<span class="codeline" id="line-295"><code>}</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>func (s *directionalStatusStack) lastDirectionalIsolateStatus() bool {</code></span>
<span class="codeline" id="line-298"><code>	return s.isolateStatusStack[s.stackCounter-1]</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// Determine explicit levels using rules X1 - X8</code></span>
<span class="codeline" id="line-302"><code>func (p *paragraph) determineExplicitEmbeddingLevels() {</code></span>
<span class="codeline" id="line-303"><code>	var stack directionalStatusStack</code></span>
<span class="codeline" id="line-304"><code>	var overflowIsolateCount, overflowEmbeddingCount, validIsolateCount int</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>	// Rule X1.</code></span>
<span class="codeline" id="line-307"><code>	stack.push(p.embeddingLevel, ON, false)</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>	for i, t := range p.resultTypes {</code></span>
<span class="codeline" id="line-310"><code>		// Rules X2, X3, X4, X5, X5a, X5b, X5c</code></span>
<span class="codeline" id="line-311"><code>		switch t {</code></span>
<span class="codeline" id="line-312"><code>		case RLE, LRE, RLO, LRO, RLI, LRI, FSI:</code></span>
<span class="codeline" id="line-313"><code>			isIsolate := t.in(RLI, LRI, FSI)</code></span>
<span class="codeline" id="line-314"><code>			isRTL := t.in(RLE, RLO, RLI)</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>			// override if this is an FSI that resolves to RLI</code></span>
<span class="codeline" id="line-317"><code>			if t == FSI {</code></span>
<span class="codeline" id="line-318"><code>				isRTL = (p.determineParagraphEmbeddingLevel(i+1, p.matchingPDI[i]) == 1)</code></span>
<span class="codeline" id="line-319"><code>			}</code></span>
<span class="codeline" id="line-320"><code>			if isIsolate {</code></span>
<span class="codeline" id="line-321"><code>				p.resultLevels[i] = stack.lastEmbeddingLevel()</code></span>
<span class="codeline" id="line-322"><code>				if stack.lastDirectionalOverrideStatus() != ON {</code></span>
<span class="codeline" id="line-323"><code>					p.resultTypes[i] = stack.lastDirectionalOverrideStatus()</code></span>
<span class="codeline" id="line-324"><code>				}</code></span>
<span class="codeline" id="line-325"><code>			}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>			var newLevel level</code></span>
<span class="codeline" id="line-328"><code>			if isRTL {</code></span>
<span class="codeline" id="line-329"><code>				// least greater odd</code></span>
<span class="codeline" id="line-330"><code>				newLevel = (stack.lastEmbeddingLevel() + 1) | 1</code></span>
<span class="codeline" id="line-331"><code>			} else {</code></span>
<span class="codeline" id="line-332"><code>				// least greater even</code></span>
<span class="codeline" id="line-333"><code>				newLevel = (stack.lastEmbeddingLevel() + 2) &amp;^ 1</code></span>
<span class="codeline" id="line-334"><code>			}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>			if newLevel &lt;= maxDepth &amp;&amp; overflowIsolateCount == 0 &amp;&amp; overflowEmbeddingCount == 0 {</code></span>
<span class="codeline" id="line-337"><code>				if isIsolate {</code></span>
<span class="codeline" id="line-338"><code>					validIsolateCount++</code></span>
<span class="codeline" id="line-339"><code>				}</code></span>
<span class="codeline" id="line-340"><code>				// Push new embedding level, override status, and isolated</code></span>
<span class="codeline" id="line-341"><code>				// status.</code></span>
<span class="codeline" id="line-342"><code>				// No check for valid stack counter, since the level check</code></span>
<span class="codeline" id="line-343"><code>				// suffices.</code></span>
<span class="codeline" id="line-344"><code>				switch t {</code></span>
<span class="codeline" id="line-345"><code>				case LRO:</code></span>
<span class="codeline" id="line-346"><code>					stack.push(newLevel, L, isIsolate)</code></span>
<span class="codeline" id="line-347"><code>				case RLO:</code></span>
<span class="codeline" id="line-348"><code>					stack.push(newLevel, R, isIsolate)</code></span>
<span class="codeline" id="line-349"><code>				default:</code></span>
<span class="codeline" id="line-350"><code>					stack.push(newLevel, ON, isIsolate)</code></span>
<span class="codeline" id="line-351"><code>				}</code></span>
<span class="codeline" id="line-352"><code>				// Not really part of the spec</code></span>
<span class="codeline" id="line-353"><code>				if !isIsolate {</code></span>
<span class="codeline" id="line-354"><code>					p.resultLevels[i] = newLevel</code></span>
<span class="codeline" id="line-355"><code>				}</code></span>
<span class="codeline" id="line-356"><code>			} else {</code></span>
<span class="codeline" id="line-357"><code>				// This is an invalid explicit formatting character,</code></span>
<span class="codeline" id="line-358"><code>				// so apply the "Otherwise" part of rules X2-X5b.</code></span>
<span class="codeline" id="line-359"><code>				if isIsolate {</code></span>
<span class="codeline" id="line-360"><code>					overflowIsolateCount++</code></span>
<span class="codeline" id="line-361"><code>				} else { // !isIsolate</code></span>
<span class="codeline" id="line-362"><code>					if overflowIsolateCount == 0 {</code></span>
<span class="codeline" id="line-363"><code>						overflowEmbeddingCount++</code></span>
<span class="codeline" id="line-364"><code>					}</code></span>
<span class="codeline" id="line-365"><code>				}</code></span>
<span class="codeline" id="line-366"><code>			}</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>		// Rule X6a</code></span>
<span class="codeline" id="line-369"><code>		case PDI:</code></span>
<span class="codeline" id="line-370"><code>			if overflowIsolateCount &gt; 0 {</code></span>
<span class="codeline" id="line-371"><code>				overflowIsolateCount--</code></span>
<span class="codeline" id="line-372"><code>			} else if validIsolateCount == 0 {</code></span>
<span class="codeline" id="line-373"><code>				// do nothing</code></span>
<span class="codeline" id="line-374"><code>			} else {</code></span>
<span class="codeline" id="line-375"><code>				overflowEmbeddingCount = 0</code></span>
<span class="codeline" id="line-376"><code>				for !stack.lastDirectionalIsolateStatus() {</code></span>
<span class="codeline" id="line-377"><code>					stack.pop()</code></span>
<span class="codeline" id="line-378"><code>				}</code></span>
<span class="codeline" id="line-379"><code>				stack.pop()</code></span>
<span class="codeline" id="line-380"><code>				validIsolateCount--</code></span>
<span class="codeline" id="line-381"><code>			}</code></span>
<span class="codeline" id="line-382"><code>			p.resultLevels[i] = stack.lastEmbeddingLevel()</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>		// Rule X7</code></span>
<span class="codeline" id="line-385"><code>		case PDF:</code></span>
<span class="codeline" id="line-386"><code>			// Not really part of the spec</code></span>
<span class="codeline" id="line-387"><code>			p.resultLevels[i] = stack.lastEmbeddingLevel()</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>			if overflowIsolateCount &gt; 0 {</code></span>
<span class="codeline" id="line-390"><code>				// do nothing</code></span>
<span class="codeline" id="line-391"><code>			} else if overflowEmbeddingCount &gt; 0 {</code></span>
<span class="codeline" id="line-392"><code>				overflowEmbeddingCount--</code></span>
<span class="codeline" id="line-393"><code>			} else if !stack.lastDirectionalIsolateStatus() &amp;&amp; stack.depth() &gt;= 2 {</code></span>
<span class="codeline" id="line-394"><code>				stack.pop()</code></span>
<span class="codeline" id="line-395"><code>			}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>		case B: // paragraph separator.</code></span>
<span class="codeline" id="line-398"><code>			// Rule X8.</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>			// These values are reset for clarity, in this implementation B</code></span>
<span class="codeline" id="line-401"><code>			// can only occur as the last code in the array.</code></span>
<span class="codeline" id="line-402"><code>			stack.empty()</code></span>
<span class="codeline" id="line-403"><code>			overflowIsolateCount = 0</code></span>
<span class="codeline" id="line-404"><code>			overflowEmbeddingCount = 0</code></span>
<span class="codeline" id="line-405"><code>			validIsolateCount = 0</code></span>
<span class="codeline" id="line-406"><code>			p.resultLevels[i] = p.embeddingLevel</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>		default:</code></span>
<span class="codeline" id="line-409"><code>			p.resultLevels[i] = stack.lastEmbeddingLevel()</code></span>
<span class="codeline" id="line-410"><code>			if stack.lastDirectionalOverrideStatus() != ON {</code></span>
<span class="codeline" id="line-411"><code>				p.resultTypes[i] = stack.lastDirectionalOverrideStatus()</code></span>
<span class="codeline" id="line-412"><code>			}</code></span>
<span class="codeline" id="line-413"><code>		}</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>type isolatingRunSequence struct {</code></span>
<span class="codeline" id="line-418"><code>	p *paragraph</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	indexes []int // indexes to the original string</code></span>
<span class="codeline" id="line-421"><code></code></span>
<span class="codeline" id="line-422"><code>	types          []Class // type of each character using the index</code></span>
<span class="codeline" id="line-423"><code>	resolvedLevels []level // resolved levels after application of rules</code></span>
<span class="codeline" id="line-424"><code>	level          level</code></span>
<span class="codeline" id="line-425"><code>	sos, eos       Class</code></span>
<span class="codeline" id="line-426"><code>}</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>func (i *isolatingRunSequence) Len() int { return len(i.indexes) }</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>func maxLevel(a, b level) level {</code></span>
<span class="codeline" id="line-431"><code>	if a &gt; b {</code></span>
<span class="codeline" id="line-432"><code>		return a</code></span>
<span class="codeline" id="line-433"><code>	}</code></span>
<span class="codeline" id="line-434"><code>	return b</code></span>
<span class="codeline" id="line-435"><code>}</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>// Rule X10, second bullet: Determine the start-of-sequence (sos) and end-of-sequence (eos) types,</code></span>
<span class="codeline" id="line-438"><code>// either L or R, for each isolating run sequence.</code></span>
<span class="codeline" id="line-439"><code>func (p *paragraph) isolatingRunSequence(indexes []int) *isolatingRunSequence {</code></span>
<span class="codeline" id="line-440"><code>	length := len(indexes)</code></span>
<span class="codeline" id="line-441"><code>	types := make([]Class, length)</code></span>
<span class="codeline" id="line-442"><code>	for i, x := range indexes {</code></span>
<span class="codeline" id="line-443"><code>		types[i] = p.resultTypes[x]</code></span>
<span class="codeline" id="line-444"><code>	}</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>	// assign level, sos and eos</code></span>
<span class="codeline" id="line-447"><code>	prevChar := indexes[0] - 1</code></span>
<span class="codeline" id="line-448"><code>	for prevChar &gt;= 0 &amp;&amp; isRemovedByX9(p.initialTypes[prevChar]) {</code></span>
<span class="codeline" id="line-449"><code>		prevChar--</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code>	prevLevel := p.embeddingLevel</code></span>
<span class="codeline" id="line-452"><code>	if prevChar &gt;= 0 {</code></span>
<span class="codeline" id="line-453"><code>		prevLevel = p.resultLevels[prevChar]</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	var succLevel level</code></span>
<span class="codeline" id="line-457"><code>	lastType := types[length-1]</code></span>
<span class="codeline" id="line-458"><code>	if lastType.in(LRI, RLI, FSI) {</code></span>
<span class="codeline" id="line-459"><code>		succLevel = p.embeddingLevel</code></span>
<span class="codeline" id="line-460"><code>	} else {</code></span>
<span class="codeline" id="line-461"><code>		// the first character after the end of run sequence</code></span>
<span class="codeline" id="line-462"><code>		limit := indexes[length-1] + 1</code></span>
<span class="codeline" id="line-463"><code>		for ; limit &lt; p.Len() &amp;&amp; isRemovedByX9(p.initialTypes[limit]); limit++ {</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>		}</code></span>
<span class="codeline" id="line-466"><code>		succLevel = p.embeddingLevel</code></span>
<span class="codeline" id="line-467"><code>		if limit &lt; p.Len() {</code></span>
<span class="codeline" id="line-468"><code>			succLevel = p.resultLevels[limit]</code></span>
<span class="codeline" id="line-469"><code>		}</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code>	level := p.resultLevels[indexes[0]]</code></span>
<span class="codeline" id="line-472"><code>	return &amp;isolatingRunSequence{</code></span>
<span class="codeline" id="line-473"><code>		p:       p,</code></span>
<span class="codeline" id="line-474"><code>		indexes: indexes,</code></span>
<span class="codeline" id="line-475"><code>		types:   types,</code></span>
<span class="codeline" id="line-476"><code>		level:   level,</code></span>
<span class="codeline" id="line-477"><code>		sos:     typeForLevel(maxLevel(prevLevel, level)),</code></span>
<span class="codeline" id="line-478"><code>		eos:     typeForLevel(maxLevel(succLevel, level)),</code></span>
<span class="codeline" id="line-479"><code>	}</code></span>
<span class="codeline" id="line-480"><code>}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>// Resolving weak types Rules W1-W7.</code></span>
<span class="codeline" id="line-483"><code>//</code></span>
<span class="codeline" id="line-484"><code>// Note that some weak types (EN, AN) remain after this processing is</code></span>
<span class="codeline" id="line-485"><code>// complete.</code></span>
<span class="codeline" id="line-486"><code>func (s *isolatingRunSequence) resolveWeakTypes() {</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>	// on entry, only these types remain</code></span>
<span class="codeline" id="line-489"><code>	s.assertOnly(L, R, AL, EN, ES, ET, AN, CS, B, S, WS, ON, NSM, LRI, RLI, FSI, PDI)</code></span>
<span class="codeline" id="line-490"><code></code></span>
<span class="codeline" id="line-491"><code>	// Rule W1.</code></span>
<span class="codeline" id="line-492"><code>	// Changes all NSMs.</code></span>
<span class="codeline" id="line-493"><code>	precedingCharacterType := s.sos</code></span>
<span class="codeline" id="line-494"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-495"><code>		if t == NSM {</code></span>
<span class="codeline" id="line-496"><code>			s.types[i] = precedingCharacterType</code></span>
<span class="codeline" id="line-497"><code>		} else {</code></span>
<span class="codeline" id="line-498"><code>			// if t.in(LRI, RLI, FSI, PDI) {</code></span>
<span class="codeline" id="line-499"><code>			// 	precedingCharacterType = ON</code></span>
<span class="codeline" id="line-500"><code>			// }</code></span>
<span class="codeline" id="line-501"><code>			precedingCharacterType = t</code></span>
<span class="codeline" id="line-502"><code>		}</code></span>
<span class="codeline" id="line-503"><code>	}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>	// Rule W2.</code></span>
<span class="codeline" id="line-506"><code>	// EN does not change at the start of the run, because sos != AL.</code></span>
<span class="codeline" id="line-507"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-508"><code>		if t == EN {</code></span>
<span class="codeline" id="line-509"><code>			for j := i - 1; j &gt;= 0; j-- {</code></span>
<span class="codeline" id="line-510"><code>				if t := s.types[j]; t.in(L, R, AL) {</code></span>
<span class="codeline" id="line-511"><code>					if t == AL {</code></span>
<span class="codeline" id="line-512"><code>						s.types[i] = AN</code></span>
<span class="codeline" id="line-513"><code>					}</code></span>
<span class="codeline" id="line-514"><code>					break</code></span>
<span class="codeline" id="line-515"><code>				}</code></span>
<span class="codeline" id="line-516"><code>			}</code></span>
<span class="codeline" id="line-517"><code>		}</code></span>
<span class="codeline" id="line-518"><code>	}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>	// Rule W3.</code></span>
<span class="codeline" id="line-521"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-522"><code>		if t == AL {</code></span>
<span class="codeline" id="line-523"><code>			s.types[i] = R</code></span>
<span class="codeline" id="line-524"><code>		}</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>	// Rule W4.</code></span>
<span class="codeline" id="line-528"><code>	// Since there must be values on both sides for this rule to have an</code></span>
<span class="codeline" id="line-529"><code>	// effect, the scan skips the first and last value.</code></span>
<span class="codeline" id="line-530"><code>	//</code></span>
<span class="codeline" id="line-531"><code>	// Although the scan proceeds left to right, and changes the type</code></span>
<span class="codeline" id="line-532"><code>	// values in a way that would appear to affect the computations</code></span>
<span class="codeline" id="line-533"><code>	// later in the scan, there is actually no problem. A change in the</code></span>
<span class="codeline" id="line-534"><code>	// current value can only affect the value to its immediate right,</code></span>
<span class="codeline" id="line-535"><code>	// and only affect it if it is ES or CS. But the current value can</code></span>
<span class="codeline" id="line-536"><code>	// only change if the value to its right is not ES or CS. Thus</code></span>
<span class="codeline" id="line-537"><code>	// either the current value will not change, or its change will have</code></span>
<span class="codeline" id="line-538"><code>	// no effect on the remainder of the analysis.</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>	for i := 1; i &lt; s.Len()-1; i++ {</code></span>
<span class="codeline" id="line-541"><code>		t := s.types[i]</code></span>
<span class="codeline" id="line-542"><code>		if t == ES || t == CS {</code></span>
<span class="codeline" id="line-543"><code>			prevSepType := s.types[i-1]</code></span>
<span class="codeline" id="line-544"><code>			succSepType := s.types[i+1]</code></span>
<span class="codeline" id="line-545"><code>			if prevSepType == EN &amp;&amp; succSepType == EN {</code></span>
<span class="codeline" id="line-546"><code>				s.types[i] = EN</code></span>
<span class="codeline" id="line-547"><code>			} else if s.types[i] == CS &amp;&amp; prevSepType == AN &amp;&amp; succSepType == AN {</code></span>
<span class="codeline" id="line-548"><code>				s.types[i] = AN</code></span>
<span class="codeline" id="line-549"><code>			}</code></span>
<span class="codeline" id="line-550"><code>		}</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>	// Rule W5.</code></span>
<span class="codeline" id="line-554"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-555"><code>		if t == ET {</code></span>
<span class="codeline" id="line-556"><code>			// locate end of sequence</code></span>
<span class="codeline" id="line-557"><code>			runStart := i</code></span>
<span class="codeline" id="line-558"><code>			runEnd := s.findRunLimit(runStart, ET)</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>			// check values at ends of sequence</code></span>
<span class="codeline" id="line-561"><code>			t := s.sos</code></span>
<span class="codeline" id="line-562"><code>			if runStart &gt; 0 {</code></span>
<span class="codeline" id="line-563"><code>				t = s.types[runStart-1]</code></span>
<span class="codeline" id="line-564"><code>			}</code></span>
<span class="codeline" id="line-565"><code>			if t != EN {</code></span>
<span class="codeline" id="line-566"><code>				t = s.eos</code></span>
<span class="codeline" id="line-567"><code>				if runEnd &lt; len(s.types) {</code></span>
<span class="codeline" id="line-568"><code>					t = s.types[runEnd]</code></span>
<span class="codeline" id="line-569"><code>				}</code></span>
<span class="codeline" id="line-570"><code>			}</code></span>
<span class="codeline" id="line-571"><code>			if t == EN {</code></span>
<span class="codeline" id="line-572"><code>				setTypes(s.types[runStart:runEnd], EN)</code></span>
<span class="codeline" id="line-573"><code>			}</code></span>
<span class="codeline" id="line-574"><code>			// continue at end of sequence</code></span>
<span class="codeline" id="line-575"><code>			i = runEnd</code></span>
<span class="codeline" id="line-576"><code>		}</code></span>
<span class="codeline" id="line-577"><code>	}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>	// Rule W6.</code></span>
<span class="codeline" id="line-580"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-581"><code>		if t.in(ES, ET, CS) {</code></span>
<span class="codeline" id="line-582"><code>			s.types[i] = ON</code></span>
<span class="codeline" id="line-583"><code>		}</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>	// Rule W7.</code></span>
<span class="codeline" id="line-587"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-588"><code>		if t == EN {</code></span>
<span class="codeline" id="line-589"><code>			// set default if we reach start of run</code></span>
<span class="codeline" id="line-590"><code>			prevStrongType := s.sos</code></span>
<span class="codeline" id="line-591"><code>			for j := i - 1; j &gt;= 0; j-- {</code></span>
<span class="codeline" id="line-592"><code>				t = s.types[j]</code></span>
<span class="codeline" id="line-593"><code>				if t == L || t == R { // AL's have been changed to R</code></span>
<span class="codeline" id="line-594"><code>					prevStrongType = t</code></span>
<span class="codeline" id="line-595"><code>					break</code></span>
<span class="codeline" id="line-596"><code>				}</code></span>
<span class="codeline" id="line-597"><code>			}</code></span>
<span class="codeline" id="line-598"><code>			if prevStrongType == L {</code></span>
<span class="codeline" id="line-599"><code>				s.types[i] = L</code></span>
<span class="codeline" id="line-600"><code>			}</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code>	}</code></span>
<span class="codeline" id="line-603"><code>}</code></span>
<span class="codeline" id="line-604"><code></code></span>
<span class="codeline" id="line-605"><code>// 6) resolving neutral types Rules N1-N2.</code></span>
<span class="codeline" id="line-606"><code>func (s *isolatingRunSequence) resolveNeutralTypes() {</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>	// on entry, only these types can be in resultTypes</code></span>
<span class="codeline" id="line-609"><code>	s.assertOnly(L, R, EN, AN, B, S, WS, ON, RLI, LRI, FSI, PDI)</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-612"><code>		switch t {</code></span>
<span class="codeline" id="line-613"><code>		case WS, ON, B, S, RLI, LRI, FSI, PDI:</code></span>
<span class="codeline" id="line-614"><code>			// find bounds of run of neutrals</code></span>
<span class="codeline" id="line-615"><code>			runStart := i</code></span>
<span class="codeline" id="line-616"><code>			runEnd := s.findRunLimit(runStart, B, S, WS, ON, RLI, LRI, FSI, PDI)</code></span>
<span class="codeline" id="line-617"><code></code></span>
<span class="codeline" id="line-618"><code>			// determine effective types at ends of run</code></span>
<span class="codeline" id="line-619"><code>			var leadType, trailType Class</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>			// Note that the character found can only be L, R, AN, or</code></span>
<span class="codeline" id="line-622"><code>			// EN.</code></span>
<span class="codeline" id="line-623"><code>			if runStart == 0 {</code></span>
<span class="codeline" id="line-624"><code>				leadType = s.sos</code></span>
<span class="codeline" id="line-625"><code>			} else {</code></span>
<span class="codeline" id="line-626"><code>				leadType = s.types[runStart-1]</code></span>
<span class="codeline" id="line-627"><code>				if leadType.in(AN, EN) {</code></span>
<span class="codeline" id="line-628"><code>					leadType = R</code></span>
<span class="codeline" id="line-629"><code>				}</code></span>
<span class="codeline" id="line-630"><code>			}</code></span>
<span class="codeline" id="line-631"><code>			if runEnd == len(s.types) {</code></span>
<span class="codeline" id="line-632"><code>				trailType = s.eos</code></span>
<span class="codeline" id="line-633"><code>			} else {</code></span>
<span class="codeline" id="line-634"><code>				trailType = s.types[runEnd]</code></span>
<span class="codeline" id="line-635"><code>				if trailType.in(AN, EN) {</code></span>
<span class="codeline" id="line-636"><code>					trailType = R</code></span>
<span class="codeline" id="line-637"><code>				}</code></span>
<span class="codeline" id="line-638"><code>			}</code></span>
<span class="codeline" id="line-639"><code></code></span>
<span class="codeline" id="line-640"><code>			var resolvedType Class</code></span>
<span class="codeline" id="line-641"><code>			if leadType == trailType {</code></span>
<span class="codeline" id="line-642"><code>				// Rule N1.</code></span>
<span class="codeline" id="line-643"><code>				resolvedType = leadType</code></span>
<span class="codeline" id="line-644"><code>			} else {</code></span>
<span class="codeline" id="line-645"><code>				// Rule N2.</code></span>
<span class="codeline" id="line-646"><code>				// Notice the embedding level of the run is used, not</code></span>
<span class="codeline" id="line-647"><code>				// the paragraph embedding level.</code></span>
<span class="codeline" id="line-648"><code>				resolvedType = typeForLevel(s.level)</code></span>
<span class="codeline" id="line-649"><code>			}</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>			setTypes(s.types[runStart:runEnd], resolvedType)</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>			// skip over run of (former) neutrals</code></span>
<span class="codeline" id="line-654"><code>			i = runEnd</code></span>
<span class="codeline" id="line-655"><code>		}</code></span>
<span class="codeline" id="line-656"><code>	}</code></span>
<span class="codeline" id="line-657"><code>}</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>func setLevels(levels []level, newLevel level) {</code></span>
<span class="codeline" id="line-660"><code>	for i := range levels {</code></span>
<span class="codeline" id="line-661"><code>		levels[i] = newLevel</code></span>
<span class="codeline" id="line-662"><code>	}</code></span>
<span class="codeline" id="line-663"><code>}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>func setTypes(types []Class, newType Class) {</code></span>
<span class="codeline" id="line-666"><code>	for i := range types {</code></span>
<span class="codeline" id="line-667"><code>		types[i] = newType</code></span>
<span class="codeline" id="line-668"><code>	}</code></span>
<span class="codeline" id="line-669"><code>}</code></span>
<span class="codeline" id="line-670"><code></code></span>
<span class="codeline" id="line-671"><code>// 7) resolving implicit embedding levels Rules I1, I2.</code></span>
<span class="codeline" id="line-672"><code>func (s *isolatingRunSequence) resolveImplicitLevels() {</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	// on entry, only these types can be in resultTypes</code></span>
<span class="codeline" id="line-675"><code>	s.assertOnly(L, R, EN, AN)</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	s.resolvedLevels = make([]level, len(s.types))</code></span>
<span class="codeline" id="line-678"><code>	setLevels(s.resolvedLevels, s.level)</code></span>
<span class="codeline" id="line-679"><code></code></span>
<span class="codeline" id="line-680"><code>	if (s.level &amp; 1) == 0 { // even level</code></span>
<span class="codeline" id="line-681"><code>		for i, t := range s.types {</code></span>
<span class="codeline" id="line-682"><code>			// Rule I1.</code></span>
<span class="codeline" id="line-683"><code>			if t == L {</code></span>
<span class="codeline" id="line-684"><code>				// no change</code></span>
<span class="codeline" id="line-685"><code>			} else if t == R {</code></span>
<span class="codeline" id="line-686"><code>				s.resolvedLevels[i] += 1</code></span>
<span class="codeline" id="line-687"><code>			} else { // t == AN || t == EN</code></span>
<span class="codeline" id="line-688"><code>				s.resolvedLevels[i] += 2</code></span>
<span class="codeline" id="line-689"><code>			}</code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>	} else { // odd level</code></span>
<span class="codeline" id="line-692"><code>		for i, t := range s.types {</code></span>
<span class="codeline" id="line-693"><code>			// Rule I2.</code></span>
<span class="codeline" id="line-694"><code>			if t == R {</code></span>
<span class="codeline" id="line-695"><code>				// no change</code></span>
<span class="codeline" id="line-696"><code>			} else { // t == L || t == AN || t == EN</code></span>
<span class="codeline" id="line-697"><code>				s.resolvedLevels[i] += 1</code></span>
<span class="codeline" id="line-698"><code>			}</code></span>
<span class="codeline" id="line-699"><code>		}</code></span>
<span class="codeline" id="line-700"><code>	}</code></span>
<span class="codeline" id="line-701"><code>}</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>// Applies the levels and types resolved in rules W1-I2 to the</code></span>
<span class="codeline" id="line-704"><code>// resultLevels array.</code></span>
<span class="codeline" id="line-705"><code>func (s *isolatingRunSequence) applyLevelsAndTypes() {</code></span>
<span class="codeline" id="line-706"><code>	for i, x := range s.indexes {</code></span>
<span class="codeline" id="line-707"><code>		s.p.resultTypes[x] = s.types[i]</code></span>
<span class="codeline" id="line-708"><code>		s.p.resultLevels[x] = s.resolvedLevels[i]</code></span>
<span class="codeline" id="line-709"><code>	}</code></span>
<span class="codeline" id="line-710"><code>}</code></span>
<span class="codeline" id="line-711"><code></code></span>
<span class="codeline" id="line-712"><code>// Return the limit of the run consisting only of the types in validSet</code></span>
<span class="codeline" id="line-713"><code>// starting at index. This checks the value at index, and will return</code></span>
<span class="codeline" id="line-714"><code>// index if that value is not in validSet.</code></span>
<span class="codeline" id="line-715"><code>func (s *isolatingRunSequence) findRunLimit(index int, validSet ...Class) int {</code></span>
<span class="codeline" id="line-716"><code>loop:</code></span>
<span class="codeline" id="line-717"><code>	for ; index &lt; len(s.types); index++ {</code></span>
<span class="codeline" id="line-718"><code>		t := s.types[index]</code></span>
<span class="codeline" id="line-719"><code>		for _, valid := range validSet {</code></span>
<span class="codeline" id="line-720"><code>			if t == valid {</code></span>
<span class="codeline" id="line-721"><code>				continue loop</code></span>
<span class="codeline" id="line-722"><code>			}</code></span>
<span class="codeline" id="line-723"><code>		}</code></span>
<span class="codeline" id="line-724"><code>		return index // didn't find a match in validSet</code></span>
<span class="codeline" id="line-725"><code>	}</code></span>
<span class="codeline" id="line-726"><code>	return len(s.types)</code></span>
<span class="codeline" id="line-727"><code>}</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>// Algorithm validation. Assert that all values in types are in the</code></span>
<span class="codeline" id="line-730"><code>// provided set.</code></span>
<span class="codeline" id="line-731"><code>func (s *isolatingRunSequence) assertOnly(codes ...Class) {</code></span>
<span class="codeline" id="line-732"><code>loop:</code></span>
<span class="codeline" id="line-733"><code>	for i, t := range s.types {</code></span>
<span class="codeline" id="line-734"><code>		for _, c := range codes {</code></span>
<span class="codeline" id="line-735"><code>			if t == c {</code></span>
<span class="codeline" id="line-736"><code>				continue loop</code></span>
<span class="codeline" id="line-737"><code>			}</code></span>
<span class="codeline" id="line-738"><code>		}</code></span>
<span class="codeline" id="line-739"><code>		log.Panicf("invalid bidi code %v present in assertOnly at position %d", t, s.indexes[i])</code></span>
<span class="codeline" id="line-740"><code>	}</code></span>
<span class="codeline" id="line-741"><code>}</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>// determineLevelRuns returns an array of level runs. Each level run is</code></span>
<span class="codeline" id="line-744"><code>// described as an array of indexes into the input string.</code></span>
<span class="codeline" id="line-745"><code>//</code></span>
<span class="codeline" id="line-746"><code>// Determines the level runs. Rule X9 will be applied in determining the</code></span>
<span class="codeline" id="line-747"><code>// runs, in the way that makes sure the characters that are supposed to be</code></span>
<span class="codeline" id="line-748"><code>// removed are not included in the runs.</code></span>
<span class="codeline" id="line-749"><code>func (p *paragraph) determineLevelRuns() [][]int {</code></span>
<span class="codeline" id="line-750"><code>	run := []int{}</code></span>
<span class="codeline" id="line-751"><code>	allRuns := [][]int{}</code></span>
<span class="codeline" id="line-752"><code>	currentLevel := implicitLevel</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>	for i := range p.initialTypes {</code></span>
<span class="codeline" id="line-755"><code>		if !isRemovedByX9(p.initialTypes[i]) {</code></span>
<span class="codeline" id="line-756"><code>			if p.resultLevels[i] != currentLevel {</code></span>
<span class="codeline" id="line-757"><code>				// we just encountered a new run; wrap up last run</code></span>
<span class="codeline" id="line-758"><code>				if currentLevel &gt;= 0 { // only wrap it up if there was a run</code></span>
<span class="codeline" id="line-759"><code>					allRuns = append(allRuns, run)</code></span>
<span class="codeline" id="line-760"><code>					run = nil</code></span>
<span class="codeline" id="line-761"><code>				}</code></span>
<span class="codeline" id="line-762"><code>				// Start new run</code></span>
<span class="codeline" id="line-763"><code>				currentLevel = p.resultLevels[i]</code></span>
<span class="codeline" id="line-764"><code>			}</code></span>
<span class="codeline" id="line-765"><code>			run = append(run, i)</code></span>
<span class="codeline" id="line-766"><code>		}</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code>	// Wrap up the final run, if any</code></span>
<span class="codeline" id="line-769"><code>	if len(run) &gt; 0 {</code></span>
<span class="codeline" id="line-770"><code>		allRuns = append(allRuns, run)</code></span>
<span class="codeline" id="line-771"><code>	}</code></span>
<span class="codeline" id="line-772"><code>	return allRuns</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>// Definition BD13. Determine isolating run sequences.</code></span>
<span class="codeline" id="line-776"><code>func (p *paragraph) determineIsolatingRunSequences() []*isolatingRunSequence {</code></span>
<span class="codeline" id="line-777"><code>	levelRuns := p.determineLevelRuns()</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>	// Compute the run that each character belongs to</code></span>
<span class="codeline" id="line-780"><code>	runForCharacter := make([]int, p.Len())</code></span>
<span class="codeline" id="line-781"><code>	for i, run := range levelRuns {</code></span>
<span class="codeline" id="line-782"><code>		for _, index := range run {</code></span>
<span class="codeline" id="line-783"><code>			runForCharacter[index] = i</code></span>
<span class="codeline" id="line-784"><code>		}</code></span>
<span class="codeline" id="line-785"><code>	}</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>	sequences := []*isolatingRunSequence{}</code></span>
<span class="codeline" id="line-788"><code></code></span>
<span class="codeline" id="line-789"><code>	var currentRunSequence []int</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>	for _, run := range levelRuns {</code></span>
<span class="codeline" id="line-792"><code>		first := run[0]</code></span>
<span class="codeline" id="line-793"><code>		if p.initialTypes[first] != PDI || p.matchingIsolateInitiator[first] == -1 {</code></span>
<span class="codeline" id="line-794"><code>			currentRunSequence = nil</code></span>
<span class="codeline" id="line-795"><code>			// int run = i;</code></span>
<span class="codeline" id="line-796"><code>			for {</code></span>
<span class="codeline" id="line-797"><code>				// Copy this level run into currentRunSequence</code></span>
<span class="codeline" id="line-798"><code>				currentRunSequence = append(currentRunSequence, run...)</code></span>
<span class="codeline" id="line-799"><code></code></span>
<span class="codeline" id="line-800"><code>				last := currentRunSequence[len(currentRunSequence)-1]</code></span>
<span class="codeline" id="line-801"><code>				lastT := p.initialTypes[last]</code></span>
<span class="codeline" id="line-802"><code>				if lastT.in(LRI, RLI, FSI) &amp;&amp; p.matchingPDI[last] != p.Len() {</code></span>
<span class="codeline" id="line-803"><code>					run = levelRuns[runForCharacter[p.matchingPDI[last]]]</code></span>
<span class="codeline" id="line-804"><code>				} else {</code></span>
<span class="codeline" id="line-805"><code>					break</code></span>
<span class="codeline" id="line-806"><code>				}</code></span>
<span class="codeline" id="line-807"><code>			}</code></span>
<span class="codeline" id="line-808"><code>			sequences = append(sequences, p.isolatingRunSequence(currentRunSequence))</code></span>
<span class="codeline" id="line-809"><code>		}</code></span>
<span class="codeline" id="line-810"><code>	}</code></span>
<span class="codeline" id="line-811"><code>	return sequences</code></span>
<span class="codeline" id="line-812"><code>}</code></span>
<span class="codeline" id="line-813"><code></code></span>
<span class="codeline" id="line-814"><code>// Assign level information to characters removed by rule X9. This is for</code></span>
<span class="codeline" id="line-815"><code>// ease of relating the level information to the original input data. Note</code></span>
<span class="codeline" id="line-816"><code>// that the levels assigned to these codes are arbitrary, they're chosen so</code></span>
<span class="codeline" id="line-817"><code>// as to avoid breaking level runs.</code></span>
<span class="codeline" id="line-818"><code>func (p *paragraph) assignLevelsToCharactersRemovedByX9() {</code></span>
<span class="codeline" id="line-819"><code>	for i, t := range p.initialTypes {</code></span>
<span class="codeline" id="line-820"><code>		if t.in(LRE, RLE, LRO, RLO, PDF, BN) {</code></span>
<span class="codeline" id="line-821"><code>			p.resultTypes[i] = t</code></span>
<span class="codeline" id="line-822"><code>			p.resultLevels[i] = -1</code></span>
<span class="codeline" id="line-823"><code>		}</code></span>
<span class="codeline" id="line-824"><code>	}</code></span>
<span class="codeline" id="line-825"><code>	// now propagate forward the levels information (could have</code></span>
<span class="codeline" id="line-826"><code>	// propagated backward, the main thing is not to introduce a level</code></span>
<span class="codeline" id="line-827"><code>	// break where one doesn't already exist).</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>	if p.resultLevels[0] == -1 {</code></span>
<span class="codeline" id="line-830"><code>		p.resultLevels[0] = p.embeddingLevel</code></span>
<span class="codeline" id="line-831"><code>	}</code></span>
<span class="codeline" id="line-832"><code>	for i := 1; i &lt; len(p.initialTypes); i++ {</code></span>
<span class="codeline" id="line-833"><code>		if p.resultLevels[i] == -1 {</code></span>
<span class="codeline" id="line-834"><code>			p.resultLevels[i] = p.resultLevels[i-1]</code></span>
<span class="codeline" id="line-835"><code>		}</code></span>
<span class="codeline" id="line-836"><code>	}</code></span>
<span class="codeline" id="line-837"><code>	// Embedding information is for informational purposes only so need not be</code></span>
<span class="codeline" id="line-838"><code>	// adjusted.</code></span>
<span class="codeline" id="line-839"><code>}</code></span>
<span class="codeline" id="line-840"><code></code></span>
<span class="codeline" id="line-841"><code>//</code></span>
<span class="codeline" id="line-842"><code>// Output</code></span>
<span class="codeline" id="line-843"><code>//</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>// getLevels computes levels array breaking lines at offsets in linebreaks.</code></span>
<span class="codeline" id="line-846"><code>// Rule L1.</code></span>
<span class="codeline" id="line-847"><code>//</code></span>
<span class="codeline" id="line-848"><code>// The linebreaks array must include at least one value. The values must be</code></span>
<span class="codeline" id="line-849"><code>// in strictly increasing order (no duplicates) between 1 and the length of</code></span>
<span class="codeline" id="line-850"><code>// the text, inclusive. The last value must be the length of the text.</code></span>
<span class="codeline" id="line-851"><code>func (p *paragraph) getLevels(linebreaks []int) []level {</code></span>
<span class="codeline" id="line-852"><code>	// Note that since the previous processing has removed all</code></span>
<span class="codeline" id="line-853"><code>	// P, S, and WS values from resultTypes, the values referred to</code></span>
<span class="codeline" id="line-854"><code>	// in these rules are the initial types, before any processing</code></span>
<span class="codeline" id="line-855"><code>	// has been applied (including processing of overrides).</code></span>
<span class="codeline" id="line-856"><code>	//</code></span>
<span class="codeline" id="line-857"><code>	// This example implementation has reinserted explicit format codes</code></span>
<span class="codeline" id="line-858"><code>	// and BN, in order that the levels array correspond to the</code></span>
<span class="codeline" id="line-859"><code>	// initial text. Their final placement is not normative.</code></span>
<span class="codeline" id="line-860"><code>	// These codes are treated like WS in this implementation,</code></span>
<span class="codeline" id="line-861"><code>	// so they don't interrupt sequences of WS.</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>	validateLineBreaks(linebreaks, p.Len())</code></span>
<span class="codeline" id="line-864"><code></code></span>
<span class="codeline" id="line-865"><code>	result := append([]level(nil), p.resultLevels...)</code></span>
<span class="codeline" id="line-866"><code></code></span>
<span class="codeline" id="line-867"><code>	// don't worry about linebreaks since if there is a break within</code></span>
<span class="codeline" id="line-868"><code>	// a series of WS values preceding S, the linebreak itself</code></span>
<span class="codeline" id="line-869"><code>	// causes the reset.</code></span>
<span class="codeline" id="line-870"><code>	for i, t := range p.initialTypes {</code></span>
<span class="codeline" id="line-871"><code>		if t.in(B, S) {</code></span>
<span class="codeline" id="line-872"><code>			// Rule L1, clauses one and two.</code></span>
<span class="codeline" id="line-873"><code>			result[i] = p.embeddingLevel</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>			// Rule L1, clause three.</code></span>
<span class="codeline" id="line-876"><code>			for j := i - 1; j &gt;= 0; j-- {</code></span>
<span class="codeline" id="line-877"><code>				if isWhitespace(p.initialTypes[j]) { // including format codes</code></span>
<span class="codeline" id="line-878"><code>					result[j] = p.embeddingLevel</code></span>
<span class="codeline" id="line-879"><code>				} else {</code></span>
<span class="codeline" id="line-880"><code>					break</code></span>
<span class="codeline" id="line-881"><code>				}</code></span>
<span class="codeline" id="line-882"><code>			}</code></span>
<span class="codeline" id="line-883"><code>		}</code></span>
<span class="codeline" id="line-884"><code>	}</code></span>
<span class="codeline" id="line-885"><code></code></span>
<span class="codeline" id="line-886"><code>	// Rule L1, clause four.</code></span>
<span class="codeline" id="line-887"><code>	start := 0</code></span>
<span class="codeline" id="line-888"><code>	for _, limit := range linebreaks {</code></span>
<span class="codeline" id="line-889"><code>		for j := limit - 1; j &gt;= start; j-- {</code></span>
<span class="codeline" id="line-890"><code>			if isWhitespace(p.initialTypes[j]) { // including format codes</code></span>
<span class="codeline" id="line-891"><code>				result[j] = p.embeddingLevel</code></span>
<span class="codeline" id="line-892"><code>			} else {</code></span>
<span class="codeline" id="line-893"><code>				break</code></span>
<span class="codeline" id="line-894"><code>			}</code></span>
<span class="codeline" id="line-895"><code>		}</code></span>
<span class="codeline" id="line-896"><code>		start = limit</code></span>
<span class="codeline" id="line-897"><code>	}</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>	return result</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// getReordering returns the reordering of lines from a visual index to a</code></span>
<span class="codeline" id="line-903"><code>// logical index for line breaks at the given offsets.</code></span>
<span class="codeline" id="line-904"><code>//</code></span>
<span class="codeline" id="line-905"><code>// Lines are concatenated from left to right. So for example, the fifth</code></span>
<span class="codeline" id="line-906"><code>// character from the left on the third line is</code></span>
<span class="codeline" id="line-907"><code>//</code></span>
<span class="codeline" id="line-908"><code>//	getReordering(linebreaks)[linebreaks[1] + 4]</code></span>
<span class="codeline" id="line-909"><code>//</code></span>
<span class="codeline" id="line-910"><code>// (linebreaks[1] is the position after the last character of the second</code></span>
<span class="codeline" id="line-911"><code>// line, which is also the index of the first character on the third line,</code></span>
<span class="codeline" id="line-912"><code>// and adding four gets the fifth character from the left).</code></span>
<span class="codeline" id="line-913"><code>//</code></span>
<span class="codeline" id="line-914"><code>// The linebreaks array must include at least one value. The values must be</code></span>
<span class="codeline" id="line-915"><code>// in strictly increasing order (no duplicates) between 1 and the length of</code></span>
<span class="codeline" id="line-916"><code>// the text, inclusive. The last value must be the length of the text.</code></span>
<span class="codeline" id="line-917"><code>func (p *paragraph) getReordering(linebreaks []int) []int {</code></span>
<span class="codeline" id="line-918"><code>	validateLineBreaks(linebreaks, p.Len())</code></span>
<span class="codeline" id="line-919"><code></code></span>
<span class="codeline" id="line-920"><code>	return computeMultilineReordering(p.getLevels(linebreaks), linebreaks)</code></span>
<span class="codeline" id="line-921"><code>}</code></span>
<span class="codeline" id="line-922"><code></code></span>
<span class="codeline" id="line-923"><code>// Return multiline reordering array for a given level array. Reordering</code></span>
<span class="codeline" id="line-924"><code>// does not occur across a line break.</code></span>
<span class="codeline" id="line-925"><code>func computeMultilineReordering(levels []level, linebreaks []int) []int {</code></span>
<span class="codeline" id="line-926"><code>	result := make([]int, len(levels))</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>	start := 0</code></span>
<span class="codeline" id="line-929"><code>	for _, limit := range linebreaks {</code></span>
<span class="codeline" id="line-930"><code>		tempLevels := make([]level, limit-start)</code></span>
<span class="codeline" id="line-931"><code>		copy(tempLevels, levels[start:])</code></span>
<span class="codeline" id="line-932"><code></code></span>
<span class="codeline" id="line-933"><code>		for j, order := range computeReordering(tempLevels) {</code></span>
<span class="codeline" id="line-934"><code>			result[start+j] = order + start</code></span>
<span class="codeline" id="line-935"><code>		}</code></span>
<span class="codeline" id="line-936"><code>		start = limit</code></span>
<span class="codeline" id="line-937"><code>	}</code></span>
<span class="codeline" id="line-938"><code>	return result</code></span>
<span class="codeline" id="line-939"><code>}</code></span>
<span class="codeline" id="line-940"><code></code></span>
<span class="codeline" id="line-941"><code>// Return reordering array for a given level array. This reorders a single</code></span>
<span class="codeline" id="line-942"><code>// line. The reordering is a visual to logical map. For example, the</code></span>
<span class="codeline" id="line-943"><code>// leftmost char is string.charAt(order[0]). Rule L2.</code></span>
<span class="codeline" id="line-944"><code>func computeReordering(levels []level) []int {</code></span>
<span class="codeline" id="line-945"><code>	result := make([]int, len(levels))</code></span>
<span class="codeline" id="line-946"><code>	// initialize order</code></span>
<span class="codeline" id="line-947"><code>	for i := range result {</code></span>
<span class="codeline" id="line-948"><code>		result[i] = i</code></span>
<span class="codeline" id="line-949"><code>	}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>	// locate highest level found on line.</code></span>
<span class="codeline" id="line-952"><code>	// Note the rules say text, but no reordering across line bounds is</code></span>
<span class="codeline" id="line-953"><code>	// performed, so this is sufficient.</code></span>
<span class="codeline" id="line-954"><code>	highestLevel := level(0)</code></span>
<span class="codeline" id="line-955"><code>	lowestOddLevel := level(maxDepth + 2)</code></span>
<span class="codeline" id="line-956"><code>	for _, level := range levels {</code></span>
<span class="codeline" id="line-957"><code>		if level &gt; highestLevel {</code></span>
<span class="codeline" id="line-958"><code>			highestLevel = level</code></span>
<span class="codeline" id="line-959"><code>		}</code></span>
<span class="codeline" id="line-960"><code>		if level&amp;1 != 0 &amp;&amp; level &lt; lowestOddLevel {</code></span>
<span class="codeline" id="line-961"><code>			lowestOddLevel = level</code></span>
<span class="codeline" id="line-962"><code>		}</code></span>
<span class="codeline" id="line-963"><code>	}</code></span>
<span class="codeline" id="line-964"><code></code></span>
<span class="codeline" id="line-965"><code>	for level := highestLevel; level &gt;= lowestOddLevel; level-- {</code></span>
<span class="codeline" id="line-966"><code>		for i := 0; i &lt; len(levels); i++ {</code></span>
<span class="codeline" id="line-967"><code>			if levels[i] &gt;= level {</code></span>
<span class="codeline" id="line-968"><code>				// find range of text at or above this level</code></span>
<span class="codeline" id="line-969"><code>				start := i</code></span>
<span class="codeline" id="line-970"><code>				limit := i + 1</code></span>
<span class="codeline" id="line-971"><code>				for limit &lt; len(levels) &amp;&amp; levels[limit] &gt;= level {</code></span>
<span class="codeline" id="line-972"><code>					limit++</code></span>
<span class="codeline" id="line-973"><code>				}</code></span>
<span class="codeline" id="line-974"><code></code></span>
<span class="codeline" id="line-975"><code>				for j, k := start, limit-1; j &lt; k; j, k = j+1, k-1 {</code></span>
<span class="codeline" id="line-976"><code>					result[j], result[k] = result[k], result[j]</code></span>
<span class="codeline" id="line-977"><code>				}</code></span>
<span class="codeline" id="line-978"><code>				// skip to end of level run</code></span>
<span class="codeline" id="line-979"><code>				i = limit</code></span>
<span class="codeline" id="line-980"><code>			}</code></span>
<span class="codeline" id="line-981"><code>		}</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code></code></span>
<span class="codeline" id="line-984"><code>	return result</code></span>
<span class="codeline" id="line-985"><code>}</code></span>
<span class="codeline" id="line-986"><code></code></span>
<span class="codeline" id="line-987"><code>// isWhitespace reports whether the type is considered a whitespace type for the</code></span>
<span class="codeline" id="line-988"><code>// line break rules.</code></span>
<span class="codeline" id="line-989"><code>func isWhitespace(c Class) bool {</code></span>
<span class="codeline" id="line-990"><code>	switch c {</code></span>
<span class="codeline" id="line-991"><code>	case LRE, RLE, LRO, RLO, PDF, LRI, RLI, FSI, PDI, BN, WS:</code></span>
<span class="codeline" id="line-992"><code>		return true</code></span>
<span class="codeline" id="line-993"><code>	}</code></span>
<span class="codeline" id="line-994"><code>	return false</code></span>
<span class="codeline" id="line-995"><code>}</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>// isRemovedByX9 reports whether the type is one of the types removed in X9.</code></span>
<span class="codeline" id="line-998"><code>func isRemovedByX9(c Class) bool {</code></span>
<span class="codeline" id="line-999"><code>	switch c {</code></span>
<span class="codeline" id="line-1000"><code>	case LRE, RLE, LRO, RLO, PDF, BN:</code></span>
<span class="codeline" id="line-1001"><code>		return true</code></span>
<span class="codeline" id="line-1002"><code>	}</code></span>
<span class="codeline" id="line-1003"><code>	return false</code></span>
<span class="codeline" id="line-1004"><code>}</code></span>
<span class="codeline" id="line-1005"><code></code></span>
<span class="codeline" id="line-1006"><code>// typeForLevel reports the strong type (L or R) corresponding to the level.</code></span>
<span class="codeline" id="line-1007"><code>func typeForLevel(level level) Class {</code></span>
<span class="codeline" id="line-1008"><code>	if (level &amp; 0x1) == 0 {</code></span>
<span class="codeline" id="line-1009"><code>		return L</code></span>
<span class="codeline" id="line-1010"><code>	}</code></span>
<span class="codeline" id="line-1011"><code>	return R</code></span>
<span class="codeline" id="line-1012"><code>}</code></span>
<span class="codeline" id="line-1013"><code></code></span>
<span class="codeline" id="line-1014"><code>func validateTypes(types []Class) error {</code></span>
<span class="codeline" id="line-1015"><code>	if len(types) == 0 {</code></span>
<span class="codeline" id="line-1016"><code>		return fmt.Errorf("types is null")</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code>	for i, t := range types[:len(types)-1] {</code></span>
<span class="codeline" id="line-1019"><code>		if t == B {</code></span>
<span class="codeline" id="line-1020"><code>			return fmt.Errorf("B type before end of paragraph at index: %d", i)</code></span>
<span class="codeline" id="line-1021"><code>		}</code></span>
<span class="codeline" id="line-1022"><code>	}</code></span>
<span class="codeline" id="line-1023"><code>	return nil</code></span>
<span class="codeline" id="line-1024"><code>}</code></span>
<span class="codeline" id="line-1025"><code></code></span>
<span class="codeline" id="line-1026"><code>func validateParagraphEmbeddingLevel(embeddingLevel level) error {</code></span>
<span class="codeline" id="line-1027"><code>	if embeddingLevel != implicitLevel &amp;&amp;</code></span>
<span class="codeline" id="line-1028"><code>		embeddingLevel != 0 &amp;&amp;</code></span>
<span class="codeline" id="line-1029"><code>		embeddingLevel != 1 {</code></span>
<span class="codeline" id="line-1030"><code>		return fmt.Errorf("illegal paragraph embedding level: %d", embeddingLevel)</code></span>
<span class="codeline" id="line-1031"><code>	}</code></span>
<span class="codeline" id="line-1032"><code>	return nil</code></span>
<span class="codeline" id="line-1033"><code>}</code></span>
<span class="codeline" id="line-1034"><code></code></span>
<span class="codeline" id="line-1035"><code>func validateLineBreaks(linebreaks []int, textLength int) error {</code></span>
<span class="codeline" id="line-1036"><code>	prev := 0</code></span>
<span class="codeline" id="line-1037"><code>	for i, next := range linebreaks {</code></span>
<span class="codeline" id="line-1038"><code>		if next &lt;= prev {</code></span>
<span class="codeline" id="line-1039"><code>			return fmt.Errorf("bad linebreak: %d at index: %d", next, i)</code></span>
<span class="codeline" id="line-1040"><code>		}</code></span>
<span class="codeline" id="line-1041"><code>		prev = next</code></span>
<span class="codeline" id="line-1042"><code>	}</code></span>
<span class="codeline" id="line-1043"><code>	if prev != textLength {</code></span>
<span class="codeline" id="line-1044"><code>		return fmt.Errorf("last linebreak was %d, want %d", prev, textLength)</code></span>
<span class="codeline" id="line-1045"><code>	}</code></span>
<span class="codeline" id="line-1046"><code>	return nil</code></span>
<span class="codeline" id="line-1047"><code>}</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>func validatePbTypes(pairTypes []bracketType) error {</code></span>
<span class="codeline" id="line-1050"><code>	if len(pairTypes) == 0 {</code></span>
<span class="codeline" id="line-1051"><code>		return fmt.Errorf("pairTypes is null")</code></span>
<span class="codeline" id="line-1052"><code>	}</code></span>
<span class="codeline" id="line-1053"><code>	for i, pt := range pairTypes {</code></span>
<span class="codeline" id="line-1054"><code>		switch pt {</code></span>
<span class="codeline" id="line-1055"><code>		case bpNone, bpOpen, bpClose:</code></span>
<span class="codeline" id="line-1056"><code>		default:</code></span>
<span class="codeline" id="line-1057"><code>			return fmt.Errorf("illegal pairType value at %d: %v", i, pairTypes[i])</code></span>
<span class="codeline" id="line-1058"><code>		}</code></span>
<span class="codeline" id="line-1059"><code>	}</code></span>
<span class="codeline" id="line-1060"><code>	return nil</code></span>
<span class="codeline" id="line-1061"><code>}</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>func validatePbValues(pairValues []rune, pairTypes []bracketType) error {</code></span>
<span class="codeline" id="line-1064"><code>	if pairValues == nil {</code></span>
<span class="codeline" id="line-1065"><code>		return fmt.Errorf("pairValues is null")</code></span>
<span class="codeline" id="line-1066"><code>	}</code></span>
<span class="codeline" id="line-1067"><code>	if len(pairTypes) != len(pairValues) {</code></span>
<span class="codeline" id="line-1068"><code>		return fmt.Errorf("pairTypes is different length from pairValues")</code></span>
<span class="codeline" id="line-1069"><code>	}</code></span>
<span class="codeline" id="line-1070"><code>	return nil</code></span>
<span class="codeline" id="line-1071"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>