<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: testing.go in package testing</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	testing.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/testing.html">testing</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package testing provides support for automated testing of Go packages.</code></span>
<span class="codeline" id="line-6"><code>// It is intended to be used in concert with the "go test" command, which automates</code></span>
<span class="codeline" id="line-7"><code>// execution of any function of the form</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>//	func TestXxx(*testing.T)</code></span>
<span class="codeline" id="line-10"><code>//</code></span>
<span class="codeline" id="line-11"><code>// where Xxx does not start with a lowercase letter. The function name</code></span>
<span class="codeline" id="line-12"><code>// serves to identify the test routine.</code></span>
<span class="codeline" id="line-13"><code>//</code></span>
<span class="codeline" id="line-14"><code>// Within these functions, use the Error, Fail or related methods to signal failure.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// To write a new test suite, create a file that</code></span>
<span class="codeline" id="line-17"><code>// contains the TestXxx functions as described here,</code></span>
<span class="codeline" id="line-18"><code>// and give that file a name ending in "_test.go".</code></span>
<span class="codeline" id="line-19"><code>// The file will be excluded from regular</code></span>
<span class="codeline" id="line-20"><code>// package builds but will be included when the "go test" command is run.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// The test file can be in the same package as the one being tested,</code></span>
<span class="codeline" id="line-23"><code>// or in a corresponding package with the suffix "_test".</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// If the test file is in the same package, it may refer to unexported</code></span>
<span class="codeline" id="line-26"><code>// identifiers within the package, as in this example:</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>//	package abs</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>//	import "testing"</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>//	func TestAbs(t *testing.T) {</code></span>
<span class="codeline" id="line-33"><code>//	    got := Abs(-1)</code></span>
<span class="codeline" id="line-34"><code>//	    if got != 1 {</code></span>
<span class="codeline" id="line-35"><code>//	        t.Errorf("Abs(-1) = %d; want 1", got)</code></span>
<span class="codeline" id="line-36"><code>//	    }</code></span>
<span class="codeline" id="line-37"><code>//	}</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// If the file is in a separate "_test" package, the package being tested</code></span>
<span class="codeline" id="line-40"><code>// must be imported explicitly and only its exported identifiers may be used.</code></span>
<span class="codeline" id="line-41"><code>// This is known as "black box" testing.</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>//	package abs_test</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>//	import (</code></span>
<span class="codeline" id="line-46"><code>//		"testing"</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>//		"path_to_pkg/abs"</code></span>
<span class="codeline" id="line-49"><code>//	)</code></span>
<span class="codeline" id="line-50"><code>//</code></span>
<span class="codeline" id="line-51"><code>//	func TestAbs(t *testing.T) {</code></span>
<span class="codeline" id="line-52"><code>//	    got := abs.Abs(-1)</code></span>
<span class="codeline" id="line-53"><code>//	    if got != 1 {</code></span>
<span class="codeline" id="line-54"><code>//	        t.Errorf("Abs(-1) = %d; want 1", got)</code></span>
<span class="codeline" id="line-55"><code>//	    }</code></span>
<span class="codeline" id="line-56"><code>//	}</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// For more detail, run "go help test" and "go help testflag".</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>// # Benchmarks</code></span>
<span class="codeline" id="line-61"><code>//</code></span>
<span class="codeline" id="line-62"><code>// Functions of the form</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>//	func BenchmarkXxx(*testing.B)</code></span>
<span class="codeline" id="line-65"><code>//</code></span>
<span class="codeline" id="line-66"><code>// are considered benchmarks, and are executed by the "go test" command when</code></span>
<span class="codeline" id="line-67"><code>// its -bench flag is provided. Benchmarks are run sequentially.</code></span>
<span class="codeline" id="line-68"><code>//</code></span>
<span class="codeline" id="line-69"><code>// For a description of the testing flags, see</code></span>
<span class="codeline" id="line-70"><code>// https://golang.org/cmd/go/#hdr-Testing_flags.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>// A sample benchmark function looks like this:</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>//	func BenchmarkRandInt(b *testing.B) {</code></span>
<span class="codeline" id="line-75"><code>//	    for i := 0; i &lt; b.N; i++ {</code></span>
<span class="codeline" id="line-76"><code>//	        rand.Int()</code></span>
<span class="codeline" id="line-77"><code>//	    }</code></span>
<span class="codeline" id="line-78"><code>//	}</code></span>
<span class="codeline" id="line-79"><code>//</code></span>
<span class="codeline" id="line-80"><code>// The benchmark function must run the target code b.N times.</code></span>
<span class="codeline" id="line-81"><code>// During benchmark execution, b.N is adjusted until the benchmark function lasts</code></span>
<span class="codeline" id="line-82"><code>// long enough to be timed reliably. The output</code></span>
<span class="codeline" id="line-83"><code>//</code></span>
<span class="codeline" id="line-84"><code>//	BenchmarkRandInt-8   	68453040	        17.8 ns/op</code></span>
<span class="codeline" id="line-85"><code>//</code></span>
<span class="codeline" id="line-86"><code>// means that the loop ran 68453040 times at a speed of 17.8 ns per loop.</code></span>
<span class="codeline" id="line-87"><code>//</code></span>
<span class="codeline" id="line-88"><code>// If a benchmark needs some expensive setup before running, the timer</code></span>
<span class="codeline" id="line-89"><code>// may be reset:</code></span>
<span class="codeline" id="line-90"><code>//</code></span>
<span class="codeline" id="line-91"><code>//	func BenchmarkBigLen(b *testing.B) {</code></span>
<span class="codeline" id="line-92"><code>//	    big := NewBig()</code></span>
<span class="codeline" id="line-93"><code>//	    b.ResetTimer()</code></span>
<span class="codeline" id="line-94"><code>//	    for i := 0; i &lt; b.N; i++ {</code></span>
<span class="codeline" id="line-95"><code>//	        big.Len()</code></span>
<span class="codeline" id="line-96"><code>//	    }</code></span>
<span class="codeline" id="line-97"><code>//	}</code></span>
<span class="codeline" id="line-98"><code>//</code></span>
<span class="codeline" id="line-99"><code>// If a benchmark needs to test performance in a parallel setting, it may use</code></span>
<span class="codeline" id="line-100"><code>// the RunParallel helper function; such benchmarks are intended to be used with</code></span>
<span class="codeline" id="line-101"><code>// the go test -cpu flag:</code></span>
<span class="codeline" id="line-102"><code>//</code></span>
<span class="codeline" id="line-103"><code>//	func BenchmarkTemplateParallel(b *testing.B) {</code></span>
<span class="codeline" id="line-104"><code>//	    templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))</code></span>
<span class="codeline" id="line-105"><code>//	    b.RunParallel(func(pb *testing.PB) {</code></span>
<span class="codeline" id="line-106"><code>//	        var buf bytes.Buffer</code></span>
<span class="codeline" id="line-107"><code>//	        for pb.Next() {</code></span>
<span class="codeline" id="line-108"><code>//	            buf.Reset()</code></span>
<span class="codeline" id="line-109"><code>//	            templ.Execute(&amp;buf, "World")</code></span>
<span class="codeline" id="line-110"><code>//	        }</code></span>
<span class="codeline" id="line-111"><code>//	    })</code></span>
<span class="codeline" id="line-112"><code>//	}</code></span>
<span class="codeline" id="line-113"><code>//</code></span>
<span class="codeline" id="line-114"><code>// A detailed specification of the benchmark results format is given</code></span>
<span class="codeline" id="line-115"><code>// in https://golang.org/design/14313-benchmark-format.</code></span>
<span class="codeline" id="line-116"><code>//</code></span>
<span class="codeline" id="line-117"><code>// There are standard tools for working with benchmark results at</code></span>
<span class="codeline" id="line-118"><code>// https://golang.org/x/perf/cmd.</code></span>
<span class="codeline" id="line-119"><code>// In particular, https://golang.org/x/perf/cmd/benchstat performs</code></span>
<span class="codeline" id="line-120"><code>// statistically robust A/B comparisons.</code></span>
<span class="codeline" id="line-121"><code>//</code></span>
<span class="codeline" id="line-122"><code>// # Examples</code></span>
<span class="codeline" id="line-123"><code>//</code></span>
<span class="codeline" id="line-124"><code>// The package also runs and verifies example code. Example functions may</code></span>
<span class="codeline" id="line-125"><code>// include a concluding line comment that begins with "Output:" and is compared with</code></span>
<span class="codeline" id="line-126"><code>// the standard output of the function when the tests are run. (The comparison</code></span>
<span class="codeline" id="line-127"><code>// ignores leading and trailing space.) These are examples of an example:</code></span>
<span class="codeline" id="line-128"><code>//</code></span>
<span class="codeline" id="line-129"><code>//	func ExampleHello() {</code></span>
<span class="codeline" id="line-130"><code>//	    fmt.Println("hello")</code></span>
<span class="codeline" id="line-131"><code>//	    // Output: hello</code></span>
<span class="codeline" id="line-132"><code>//	}</code></span>
<span class="codeline" id="line-133"><code>//</code></span>
<span class="codeline" id="line-134"><code>//	func ExampleSalutations() {</code></span>
<span class="codeline" id="line-135"><code>//	    fmt.Println("hello, and")</code></span>
<span class="codeline" id="line-136"><code>//	    fmt.Println("goodbye")</code></span>
<span class="codeline" id="line-137"><code>//	    // Output:</code></span>
<span class="codeline" id="line-138"><code>//	    // hello, and</code></span>
<span class="codeline" id="line-139"><code>//	    // goodbye</code></span>
<span class="codeline" id="line-140"><code>//	}</code></span>
<span class="codeline" id="line-141"><code>//</code></span>
<span class="codeline" id="line-142"><code>// The comment prefix "Unordered output:" is like "Output:", but matches any</code></span>
<span class="codeline" id="line-143"><code>// line order:</code></span>
<span class="codeline" id="line-144"><code>//</code></span>
<span class="codeline" id="line-145"><code>//	func ExamplePerm() {</code></span>
<span class="codeline" id="line-146"><code>//	    for _, value := range Perm(5) {</code></span>
<span class="codeline" id="line-147"><code>//	        fmt.Println(value)</code></span>
<span class="codeline" id="line-148"><code>//	    }</code></span>
<span class="codeline" id="line-149"><code>//	    // Unordered output: 4</code></span>
<span class="codeline" id="line-150"><code>//	    // 2</code></span>
<span class="codeline" id="line-151"><code>//	    // 1</code></span>
<span class="codeline" id="line-152"><code>//	    // 3</code></span>
<span class="codeline" id="line-153"><code>//	    // 0</code></span>
<span class="codeline" id="line-154"><code>//	}</code></span>
<span class="codeline" id="line-155"><code>//</code></span>
<span class="codeline" id="line-156"><code>// Example functions without output comments are compiled but not executed.</code></span>
<span class="codeline" id="line-157"><code>//</code></span>
<span class="codeline" id="line-158"><code>// The naming convention to declare examples for the package, a function F, a type T and</code></span>
<span class="codeline" id="line-159"><code>// method M on type T are:</code></span>
<span class="codeline" id="line-160"><code>//</code></span>
<span class="codeline" id="line-161"><code>//	func Example() { ... }</code></span>
<span class="codeline" id="line-162"><code>//	func ExampleF() { ... }</code></span>
<span class="codeline" id="line-163"><code>//	func ExampleT() { ... }</code></span>
<span class="codeline" id="line-164"><code>//	func ExampleT_M() { ... }</code></span>
<span class="codeline" id="line-165"><code>//</code></span>
<span class="codeline" id="line-166"><code>// Multiple example functions for a package/type/function/method may be provided by</code></span>
<span class="codeline" id="line-167"><code>// appending a distinct suffix to the name. The suffix must start with a</code></span>
<span class="codeline" id="line-168"><code>// lower-case letter.</code></span>
<span class="codeline" id="line-169"><code>//</code></span>
<span class="codeline" id="line-170"><code>//	func Example_suffix() { ... }</code></span>
<span class="codeline" id="line-171"><code>//	func ExampleF_suffix() { ... }</code></span>
<span class="codeline" id="line-172"><code>//	func ExampleT_suffix() { ... }</code></span>
<span class="codeline" id="line-173"><code>//	func ExampleT_M_suffix() { ... }</code></span>
<span class="codeline" id="line-174"><code>//</code></span>
<span class="codeline" id="line-175"><code>// The entire test file is presented as the example when it contains a single</code></span>
<span class="codeline" id="line-176"><code>// example function, at least one other function, type, variable, or constant</code></span>
<span class="codeline" id="line-177"><code>// declaration, and no test or benchmark functions.</code></span>
<span class="codeline" id="line-178"><code>//</code></span>
<span class="codeline" id="line-179"><code>// # Fuzzing</code></span>
<span class="codeline" id="line-180"><code>//</code></span>
<span class="codeline" id="line-181"><code>// 'go test' and the testing package support fuzzing, a testing technique where</code></span>
<span class="codeline" id="line-182"><code>// a function is called with randomly generated inputs to find bugs not</code></span>
<span class="codeline" id="line-183"><code>// anticipated by unit tests.</code></span>
<span class="codeline" id="line-184"><code>//</code></span>
<span class="codeline" id="line-185"><code>// Functions of the form</code></span>
<span class="codeline" id="line-186"><code>//</code></span>
<span class="codeline" id="line-187"><code>//	func FuzzXxx(*testing.F)</code></span>
<span class="codeline" id="line-188"><code>//</code></span>
<span class="codeline" id="line-189"><code>// are considered fuzz tests.</code></span>
<span class="codeline" id="line-190"><code>//</code></span>
<span class="codeline" id="line-191"><code>// For example:</code></span>
<span class="codeline" id="line-192"><code>//</code></span>
<span class="codeline" id="line-193"><code>//	func FuzzHex(f *testing.F) {</code></span>
<span class="codeline" id="line-194"><code>//	  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {</code></span>
<span class="codeline" id="line-195"><code>//	    f.Add(seed)</code></span>
<span class="codeline" id="line-196"><code>//	  }</code></span>
<span class="codeline" id="line-197"><code>//	  f.Fuzz(func(t *testing.T, in []byte) {</code></span>
<span class="codeline" id="line-198"><code>//	    enc := hex.EncodeToString(in)</code></span>
<span class="codeline" id="line-199"><code>//	    out, err := hex.DecodeString(enc)</code></span>
<span class="codeline" id="line-200"><code>//	    if err != nil {</code></span>
<span class="codeline" id="line-201"><code>//	      t.Fatalf("%v: decode: %v", in, err)</code></span>
<span class="codeline" id="line-202"><code>//	    }</code></span>
<span class="codeline" id="line-203"><code>//	    if !bytes.Equal(in, out) {</code></span>
<span class="codeline" id="line-204"><code>//	      t.Fatalf("%v: not equal after round trip: %v", in, out)</code></span>
<span class="codeline" id="line-205"><code>//	    }</code></span>
<span class="codeline" id="line-206"><code>//	  })</code></span>
<span class="codeline" id="line-207"><code>//	}</code></span>
<span class="codeline" id="line-208"><code>//</code></span>
<span class="codeline" id="line-209"><code>// A fuzz test maintains a seed corpus, or a set of inputs which are run by</code></span>
<span class="codeline" id="line-210"><code>// default, and can seed input generation. Seed inputs may be registered by</code></span>
<span class="codeline" id="line-211"><code>// calling (*F).Add or by storing files in the directory testdata/fuzz/&lt;Name&gt;</code></span>
<span class="codeline" id="line-212"><code>// (where &lt;Name&gt; is the name of the fuzz test) within the package containing</code></span>
<span class="codeline" id="line-213"><code>// the fuzz test. Seed inputs are optional, but the fuzzing engine may find</code></span>
<span class="codeline" id="line-214"><code>// bugs more efficiently when provided with a set of small seed inputs with good</code></span>
<span class="codeline" id="line-215"><code>// code coverage. These seed inputs can also serve as regression tests for bugs</code></span>
<span class="codeline" id="line-216"><code>// identified through fuzzing.</code></span>
<span class="codeline" id="line-217"><code>//</code></span>
<span class="codeline" id="line-218"><code>// The function passed to (*F).Fuzz within the fuzz test is considered the fuzz</code></span>
<span class="codeline" id="line-219"><code>// target. A fuzz target must accept a *T parameter, followed by one or more</code></span>
<span class="codeline" id="line-220"><code>// parameters for random inputs. The types of arguments passed to (*F).Add must</code></span>
<span class="codeline" id="line-221"><code>// be identical to the types of these parameters. The fuzz target may signal</code></span>
<span class="codeline" id="line-222"><code>// that it's found a problem the same way tests do: by calling T.Fail (or any</code></span>
<span class="codeline" id="line-223"><code>// method that calls it like T.Error or T.Fatal) or by panicking.</code></span>
<span class="codeline" id="line-224"><code>//</code></span>
<span class="codeline" id="line-225"><code>// When fuzzing is enabled (by setting the -fuzz flag to a regular expression</code></span>
<span class="codeline" id="line-226"><code>// that matches a specific fuzz test), the fuzz target is called with arguments</code></span>
<span class="codeline" id="line-227"><code>// generated by repeatedly making random changes to the seed inputs. On</code></span>
<span class="codeline" id="line-228"><code>// supported platforms, 'go test' compiles the test executable with fuzzing</code></span>
<span class="codeline" id="line-229"><code>// coverage instrumentation. The fuzzing engine uses that instrumentation to</code></span>
<span class="codeline" id="line-230"><code>// find and cache inputs that expand coverage, increasing the likelihood of</code></span>
<span class="codeline" id="line-231"><code>// finding bugs. If the fuzz target fails for a given input, the fuzzing engine</code></span>
<span class="codeline" id="line-232"><code>// writes the inputs that caused the failure to a file in the directory</code></span>
<span class="codeline" id="line-233"><code>// testdata/fuzz/&lt;Name&gt; within the package directory. This file later serves as</code></span>
<span class="codeline" id="line-234"><code>// a seed input. If the file can't be written at that location (for example,</code></span>
<span class="codeline" id="line-235"><code>// because the directory is read-only), the fuzzing engine writes the file to</code></span>
<span class="codeline" id="line-236"><code>// the fuzz cache directory within the build cache instead.</code></span>
<span class="codeline" id="line-237"><code>//</code></span>
<span class="codeline" id="line-238"><code>// When fuzzing is disabled, the fuzz target is called with the seed inputs</code></span>
<span class="codeline" id="line-239"><code>// registered with F.Add and seed inputs from testdata/fuzz/&lt;Name&gt;. In this</code></span>
<span class="codeline" id="line-240"><code>// mode, the fuzz test acts much like a regular test, with subtests started</code></span>
<span class="codeline" id="line-241"><code>// with F.Fuzz instead of T.Run.</code></span>
<span class="codeline" id="line-242"><code>//</code></span>
<span class="codeline" id="line-243"><code>// See https://go.dev/doc/fuzz for documentation about fuzzing.</code></span>
<span class="codeline" id="line-244"><code>//</code></span>
<span class="codeline" id="line-245"><code>// # Skipping</code></span>
<span class="codeline" id="line-246"><code>//</code></span>
<span class="codeline" id="line-247"><code>// Tests or benchmarks may be skipped at run time with a call to</code></span>
<span class="codeline" id="line-248"><code>// the Skip method of *T or *B:</code></span>
<span class="codeline" id="line-249"><code>//</code></span>
<span class="codeline" id="line-250"><code>//	func TestTimeConsuming(t *testing.T) {</code></span>
<span class="codeline" id="line-251"><code>//	    if testing.Short() {</code></span>
<span class="codeline" id="line-252"><code>//	        t.Skip("skipping test in short mode.")</code></span>
<span class="codeline" id="line-253"><code>//	    }</code></span>
<span class="codeline" id="line-254"><code>//	    ...</code></span>
<span class="codeline" id="line-255"><code>//	}</code></span>
<span class="codeline" id="line-256"><code>//</code></span>
<span class="codeline" id="line-257"><code>// The Skip method of *T can be used in a fuzz target if the input is invalid,</code></span>
<span class="codeline" id="line-258"><code>// but should not be considered a failing input. For example:</code></span>
<span class="codeline" id="line-259"><code>//</code></span>
<span class="codeline" id="line-260"><code>//	func FuzzJSONMarshaling(f *testing.F) {</code></span>
<span class="codeline" id="line-261"><code>//	    f.Fuzz(func(t *testing.T, b []byte) {</code></span>
<span class="codeline" id="line-262"><code>//	        var v interface{}</code></span>
<span class="codeline" id="line-263"><code>//	        if err := json.Unmarshal(b, &amp;v); err != nil {</code></span>
<span class="codeline" id="line-264"><code>//	            t.Skip()</code></span>
<span class="codeline" id="line-265"><code>//	        }</code></span>
<span class="codeline" id="line-266"><code>//	        if _, err := json.Marshal(v); err != nil {</code></span>
<span class="codeline" id="line-267"><code>//	            t.Errorf("Marshal: %v", err)</code></span>
<span class="codeline" id="line-268"><code>//	        }</code></span>
<span class="codeline" id="line-269"><code>//	    })</code></span>
<span class="codeline" id="line-270"><code>//	}</code></span>
<span class="codeline" id="line-271"><code>//</code></span>
<span class="codeline" id="line-272"><code>// # Subtests and Sub-benchmarks</code></span>
<span class="codeline" id="line-273"><code>//</code></span>
<span class="codeline" id="line-274"><code>// The Run methods of T and B allow defining subtests and sub-benchmarks,</code></span>
<span class="codeline" id="line-275"><code>// without having to define separate functions for each. This enables uses</code></span>
<span class="codeline" id="line-276"><code>// like table-driven benchmarks and creating hierarchical tests.</code></span>
<span class="codeline" id="line-277"><code>// It also provides a way to share common setup and tear-down code:</code></span>
<span class="codeline" id="line-278"><code>//</code></span>
<span class="codeline" id="line-279"><code>//	func TestFoo(t *testing.T) {</code></span>
<span class="codeline" id="line-280"><code>//	    // &lt;setup code&gt;</code></span>
<span class="codeline" id="line-281"><code>//	    t.Run("A=1", func(t *testing.T) { ... })</code></span>
<span class="codeline" id="line-282"><code>//	    t.Run("A=2", func(t *testing.T) { ... })</code></span>
<span class="codeline" id="line-283"><code>//	    t.Run("B=1", func(t *testing.T) { ... })</code></span>
<span class="codeline" id="line-284"><code>//	    // &lt;tear-down code&gt;</code></span>
<span class="codeline" id="line-285"><code>//	}</code></span>
<span class="codeline" id="line-286"><code>//</code></span>
<span class="codeline" id="line-287"><code>// Each subtest and sub-benchmark has a unique name: the combination of the name</code></span>
<span class="codeline" id="line-288"><code>// of the top-level test and the sequence of names passed to Run, separated by</code></span>
<span class="codeline" id="line-289"><code>// slashes, with an optional trailing sequence number for disambiguation.</code></span>
<span class="codeline" id="line-290"><code>//</code></span>
<span class="codeline" id="line-291"><code>// The argument to the -run, -bench, and -fuzz command-line flags is an unanchored regular</code></span>
<span class="codeline" id="line-292"><code>// expression that matches the test's name. For tests with multiple slash-separated</code></span>
<span class="codeline" id="line-293"><code>// elements, such as subtests, the argument is itself slash-separated, with</code></span>
<span class="codeline" id="line-294"><code>// expressions matching each name element in turn. Because it is unanchored, an</code></span>
<span class="codeline" id="line-295"><code>// empty expression matches any string.</code></span>
<span class="codeline" id="line-296"><code>// For example, using "matching" to mean "whose name contains":</code></span>
<span class="codeline" id="line-297"><code>//</code></span>
<span class="codeline" id="line-298"><code>//	go test -run ''        # Run all tests.</code></span>
<span class="codeline" id="line-299"><code>//	go test -run Foo       # Run top-level tests matching "Foo", such as "TestFooBar".</code></span>
<span class="codeline" id="line-300"><code>//	go test -run Foo/A=    # For top-level tests matching "Foo", run subtests matching "A=".</code></span>
<span class="codeline" id="line-301"><code>//	go test -run /A=1      # For all top-level tests, run subtests matching "A=1".</code></span>
<span class="codeline" id="line-302"><code>//	go test -fuzz FuzzFoo  # Fuzz the target matching "FuzzFoo"</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>// The -run argument can also be used to run a specific value in the seed</code></span>
<span class="codeline" id="line-305"><code>// corpus, for debugging. For example:</code></span>
<span class="codeline" id="line-306"><code>//</code></span>
<span class="codeline" id="line-307"><code>//	go test -run=FuzzFoo/9ddb952d9814</code></span>
<span class="codeline" id="line-308"><code>//</code></span>
<span class="codeline" id="line-309"><code>// The -fuzz and -run flags can both be set, in order to fuzz a target but</code></span>
<span class="codeline" id="line-310"><code>// skip the execution of all other tests.</code></span>
<span class="codeline" id="line-311"><code>//</code></span>
<span class="codeline" id="line-312"><code>// Subtests can also be used to control parallelism. A parent test will only</code></span>
<span class="codeline" id="line-313"><code>// complete once all of its subtests complete. In this example, all tests are</code></span>
<span class="codeline" id="line-314"><code>// run in parallel with each other, and only with each other, regardless of</code></span>
<span class="codeline" id="line-315"><code>// other top-level tests that may be defined:</code></span>
<span class="codeline" id="line-316"><code>//</code></span>
<span class="codeline" id="line-317"><code>//	func TestGroupedParallel(t *testing.T) {</code></span>
<span class="codeline" id="line-318"><code>//	    for _, tc := range tests {</code></span>
<span class="codeline" id="line-319"><code>//	        tc := tc // capture range variable</code></span>
<span class="codeline" id="line-320"><code>//	        t.Run(tc.Name, func(t *testing.T) {</code></span>
<span class="codeline" id="line-321"><code>//	            t.Parallel()</code></span>
<span class="codeline" id="line-322"><code>//	            ...</code></span>
<span class="codeline" id="line-323"><code>//	        })</code></span>
<span class="codeline" id="line-324"><code>//	    }</code></span>
<span class="codeline" id="line-325"><code>//	}</code></span>
<span class="codeline" id="line-326"><code>//</code></span>
<span class="codeline" id="line-327"><code>// Run does not return until parallel subtests have completed, providing a way</code></span>
<span class="codeline" id="line-328"><code>// to clean up after a group of parallel tests:</code></span>
<span class="codeline" id="line-329"><code>//</code></span>
<span class="codeline" id="line-330"><code>//	func TestTeardownParallel(t *testing.T) {</code></span>
<span class="codeline" id="line-331"><code>//	    // This Run will not return until the parallel tests finish.</code></span>
<span class="codeline" id="line-332"><code>//	    t.Run("group", func(t *testing.T) {</code></span>
<span class="codeline" id="line-333"><code>//	        t.Run("Test1", parallelTest1)</code></span>
<span class="codeline" id="line-334"><code>//	        t.Run("Test2", parallelTest2)</code></span>
<span class="codeline" id="line-335"><code>//	        t.Run("Test3", parallelTest3)</code></span>
<span class="codeline" id="line-336"><code>//	    })</code></span>
<span class="codeline" id="line-337"><code>//	    // &lt;tear-down code&gt;</code></span>
<span class="codeline" id="line-338"><code>//	}</code></span>
<span class="codeline" id="line-339"><code>//</code></span>
<span class="codeline" id="line-340"><code>// # Main</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// It is sometimes necessary for a test or benchmark program to do extra setup or teardown</code></span>
<span class="codeline" id="line-343"><code>// before or after it executes. It is also sometimes necessary to control</code></span>
<span class="codeline" id="line-344"><code>// which code runs on the main thread. To support these and other cases,</code></span>
<span class="codeline" id="line-345"><code>// if a test file contains a function:</code></span>
<span class="codeline" id="line-346"><code>//</code></span>
<span class="codeline" id="line-347"><code>//	func TestMain(m *testing.M)</code></span>
<span class="codeline" id="line-348"><code>//</code></span>
<span class="codeline" id="line-349"><code>// then the generated test will call TestMain(m) instead of running the tests or benchmarks</code></span>
<span class="codeline" id="line-350"><code>// directly. TestMain runs in the main goroutine and can do whatever setup</code></span>
<span class="codeline" id="line-351"><code>// and teardown is necessary around a call to m.Run. m.Run will return an exit</code></span>
<span class="codeline" id="line-352"><code>// code that may be passed to os.Exit. If TestMain returns, the test wrapper</code></span>
<span class="codeline" id="line-353"><code>// will pass the result of m.Run to os.Exit itself.</code></span>
<span class="codeline" id="line-354"><code>//</code></span>
<span class="codeline" id="line-355"><code>// When TestMain is called, flag.Parse has not been run. If TestMain depends on</code></span>
<span class="codeline" id="line-356"><code>// command-line flags, including those of the testing package, it should call</code></span>
<span class="codeline" id="line-357"><code>// flag.Parse explicitly. Command line flags are always parsed by the time test</code></span>
<span class="codeline" id="line-358"><code>// or benchmark functions run.</code></span>
<span class="codeline" id="line-359"><code>//</code></span>
<span class="codeline" id="line-360"><code>// A simple implementation of TestMain is:</code></span>
<span class="codeline" id="line-361"><code>//</code></span>
<span class="codeline" id="line-362"><code>//	func TestMain(m *testing.M) {</code></span>
<span class="codeline" id="line-363"><code>//		// call flag.Parse() here if TestMain uses flags</code></span>
<span class="codeline" id="line-364"><code>//		os.Exit(m.Run())</code></span>
<span class="codeline" id="line-365"><code>//	}</code></span>
<span class="codeline" id="line-366"><code>//</code></span>
<span class="codeline" id="line-367"><code>// TestMain is a low-level primitive and should not be necessary for casual</code></span>
<span class="codeline" id="line-368"><code>// testing needs, where ordinary test functions suffice.</code></span></div><span class="codeline" id="line-369"><code>package testing</code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code>import (</code></span>
<span class="codeline" id="line-372"><code>	"bytes"</code></span>
<span class="codeline" id="line-373"><code>	"errors"</code></span>
<span class="codeline" id="line-374"><code>	"flag"</code></span>
<span class="codeline" id="line-375"><code>	"fmt"</code></span>
<span class="codeline" id="line-376"><code>	"internal/goexperiment"</code></span>
<span class="codeline" id="line-377"><code>	"internal/race"</code></span>
<span class="codeline" id="line-378"><code>	"io"</code></span>
<span class="codeline" id="line-379"><code>	"math/rand"</code></span>
<span class="codeline" id="line-380"><code>	"os"</code></span>
<span class="codeline" id="line-381"><code>	"reflect"</code></span>
<span class="codeline" id="line-382"><code>	"runtime"</code></span>
<span class="codeline" id="line-383"><code>	"runtime/debug"</code></span>
<span class="codeline" id="line-384"><code>	"runtime/trace"</code></span>
<span class="codeline" id="line-385"><code>	"sort"</code></span>
<span class="codeline" id="line-386"><code>	"strconv"</code></span>
<span class="codeline" id="line-387"><code>	"strings"</code></span>
<span class="codeline" id="line-388"><code>	"sync"</code></span>
<span class="codeline" id="line-389"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-390"><code>	"time"</code></span>
<span class="codeline" id="line-391"><code>	"unicode"</code></span>
<span class="codeline" id="line-392"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-393"><code>)</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>var initRan bool</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>// Init registers testing flags. These flags are automatically registered by</code></span>
<span class="codeline" id="line-398"><code>// the "go test" command before running test functions, so Init is only needed</code></span>
<span class="codeline" id="line-399"><code>// when calling functions such as Benchmark without using "go test".</code></span>
<span class="codeline" id="line-400"><code>//</code></span>
<span class="codeline" id="line-401"><code>// Init is not safe to call concurrently. It has no effect if it was already called.</code></span>
<span class="codeline" id="line-402"><code>func Init() {</code></span>
<span class="codeline" id="line-403"><code>	if initRan {</code></span>
<span class="codeline" id="line-404"><code>		return</code></span>
<span class="codeline" id="line-405"><code>	}</code></span>
<span class="codeline" id="line-406"><code>	initRan = true</code></span>
<span class="codeline" id="line-407"><code>	// The short flag requests that tests run more quickly, but its functionality</code></span>
<span class="codeline" id="line-408"><code>	// is provided by test writers themselves. The testing package is just its</code></span>
<span class="codeline" id="line-409"><code>	// home. The all.bash installation script sets it to make installation more</code></span>
<span class="codeline" id="line-410"><code>	// efficient, but by default the flag is off so a plain "go test" will do a</code></span>
<span class="codeline" id="line-411"><code>	// full test of the package.</code></span>
<span class="codeline" id="line-412"><code>	short = flag.Bool("test.short", false, "run smaller test suite to save time")</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>	// The failfast flag requests that test execution stop after the first test failure.</code></span>
<span class="codeline" id="line-415"><code>	failFast = flag.Bool("test.failfast", false, "do not start new tests after the first test failure")</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	// The directory in which to create profile files and the like. When run from</code></span>
<span class="codeline" id="line-418"><code>	// "go test", the binary always runs in the source directory for the package;</code></span>
<span class="codeline" id="line-419"><code>	// this flag lets "go test" tell the binary to write the files in the directory where</code></span>
<span class="codeline" id="line-420"><code>	// the "go test" command is run.</code></span>
<span class="codeline" id="line-421"><code>	outputDir = flag.String("test.outputdir", "", "write profiles to `dir`")</code></span>
<span class="codeline" id="line-422"><code>	// Report as tests are run; default is silent for success.</code></span>
<span class="codeline" id="line-423"><code>	flag.Var(&amp;chatty, "test.v", "verbose: print additional output")</code></span>
<span class="codeline" id="line-424"><code>	count = flag.Uint("test.count", 1, "run tests and benchmarks `n` times")</code></span>
<span class="codeline" id="line-425"><code>	coverProfile = flag.String("test.coverprofile", "", "write a coverage profile to `file`")</code></span>
<span class="codeline" id="line-426"><code>	gocoverdir = flag.String("test.gocoverdir", "", "write coverage intermediate files to this directory")</code></span>
<span class="codeline" id="line-427"><code>	matchList = flag.String("test.list", "", "list tests, examples, and benchmarks matching `regexp` then exit")</code></span>
<span class="codeline" id="line-428"><code>	match = flag.String("test.run", "", "run only tests and examples matching `regexp`")</code></span>
<span class="codeline" id="line-429"><code>	skip = flag.String("test.skip", "", "do not list or run tests matching `regexp`")</code></span>
<span class="codeline" id="line-430"><code>	memProfile = flag.String("test.memprofile", "", "write an allocation profile to `file`")</code></span>
<span class="codeline" id="line-431"><code>	memProfileRate = flag.Int("test.memprofilerate", 0, "set memory allocation profiling `rate` (see runtime.MemProfileRate)")</code></span>
<span class="codeline" id="line-432"><code>	cpuProfile = flag.String("test.cpuprofile", "", "write a cpu profile to `file`")</code></span>
<span class="codeline" id="line-433"><code>	blockProfile = flag.String("test.blockprofile", "", "write a goroutine blocking profile to `file`")</code></span>
<span class="codeline" id="line-434"><code>	blockProfileRate = flag.Int("test.blockprofilerate", 1, "set blocking profile `rate` (see runtime.SetBlockProfileRate)")</code></span>
<span class="codeline" id="line-435"><code>	mutexProfile = flag.String("test.mutexprofile", "", "write a mutex contention profile to the named file after execution")</code></span>
<span class="codeline" id="line-436"><code>	mutexProfileFraction = flag.Int("test.mutexprofilefraction", 1, "if &gt;= 0, calls runtime.SetMutexProfileFraction()")</code></span>
<span class="codeline" id="line-437"><code>	panicOnExit0 = flag.Bool("test.paniconexit0", false, "panic on call to os.Exit(0)")</code></span>
<span class="codeline" id="line-438"><code>	traceFile = flag.String("test.trace", "", "write an execution trace to `file`")</code></span>
<span class="codeline" id="line-439"><code>	timeout = flag.Duration("test.timeout", 0, "panic test binary after duration `d` (default 0, timeout disabled)")</code></span>
<span class="codeline" id="line-440"><code>	cpuListStr = flag.String("test.cpu", "", "comma-separated `list` of cpu counts to run each test with")</code></span>
<span class="codeline" id="line-441"><code>	parallel = flag.Int("test.parallel", runtime.GOMAXPROCS(0), "run at most `n` tests in parallel")</code></span>
<span class="codeline" id="line-442"><code>	testlog = flag.String("test.testlogfile", "", "write test action log to `file` (for use only by cmd/go)")</code></span>
<span class="codeline" id="line-443"><code>	shuffle = flag.String("test.shuffle", "off", "randomize the execution order of tests and benchmarks")</code></span>
<span class="codeline" id="line-444"><code>	fullPath = flag.Bool("test.fullpath", false, "show full file names in error messages")</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>	initBenchmarkFlags()</code></span>
<span class="codeline" id="line-447"><code>	initFuzzFlags()</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>var (</code></span>
<span class="codeline" id="line-451"><code>	// Flags, registered during Init.</code></span>
<span class="codeline" id="line-452"><code>	short                *bool</code></span>
<span class="codeline" id="line-453"><code>	failFast             *bool</code></span>
<span class="codeline" id="line-454"><code>	outputDir            *string</code></span>
<span class="codeline" id="line-455"><code>	chatty               chattyFlag</code></span>
<span class="codeline" id="line-456"><code>	count                *uint</code></span>
<span class="codeline" id="line-457"><code>	coverProfile         *string</code></span>
<span class="codeline" id="line-458"><code>	gocoverdir           *string</code></span>
<span class="codeline" id="line-459"><code>	matchList            *string</code></span>
<span class="codeline" id="line-460"><code>	match                *string</code></span>
<span class="codeline" id="line-461"><code>	skip                 *string</code></span>
<span class="codeline" id="line-462"><code>	memProfile           *string</code></span>
<span class="codeline" id="line-463"><code>	memProfileRate       *int</code></span>
<span class="codeline" id="line-464"><code>	cpuProfile           *string</code></span>
<span class="codeline" id="line-465"><code>	blockProfile         *string</code></span>
<span class="codeline" id="line-466"><code>	blockProfileRate     *int</code></span>
<span class="codeline" id="line-467"><code>	mutexProfile         *string</code></span>
<span class="codeline" id="line-468"><code>	mutexProfileFraction *int</code></span>
<span class="codeline" id="line-469"><code>	panicOnExit0         *bool</code></span>
<span class="codeline" id="line-470"><code>	traceFile            *string</code></span>
<span class="codeline" id="line-471"><code>	timeout              *time.Duration</code></span>
<span class="codeline" id="line-472"><code>	cpuListStr           *string</code></span>
<span class="codeline" id="line-473"><code>	parallel             *int</code></span>
<span class="codeline" id="line-474"><code>	shuffle              *string</code></span>
<span class="codeline" id="line-475"><code>	testlog              *string</code></span>
<span class="codeline" id="line-476"><code>	fullPath             *bool</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>	haveExamples bool // are there examples?</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	cpuList     []int</code></span>
<span class="codeline" id="line-481"><code>	testlogFile *os.File</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	numFailed atomic.Uint32 // number of test failures</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>	running sync.Map // map[string]time.Time of running, unpaused tests</code></span>
<span class="codeline" id="line-486"><code>)</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>type chattyFlag struct {</code></span>
<span class="codeline" id="line-489"><code>	on   bool // -v is set in some form</code></span>
<span class="codeline" id="line-490"><code>	json bool // -v=test2json is set, to make output better for test2json</code></span>
<span class="codeline" id="line-491"><code>}</code></span>
<span class="codeline" id="line-492"><code></code></span>
<span class="codeline" id="line-493"><code>func (*chattyFlag) IsBoolFlag() bool { return true }</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>func (f *chattyFlag) Set(arg string) error {</code></span>
<span class="codeline" id="line-496"><code>	switch arg {</code></span>
<span class="codeline" id="line-497"><code>	default:</code></span>
<span class="codeline" id="line-498"><code>		return fmt.Errorf("invalid flag -test.v=%s", arg)</code></span>
<span class="codeline" id="line-499"><code>	case "true", "test2json":</code></span>
<span class="codeline" id="line-500"><code>		f.on = true</code></span>
<span class="codeline" id="line-501"><code>		f.json = arg == "test2json"</code></span>
<span class="codeline" id="line-502"><code>	case "false":</code></span>
<span class="codeline" id="line-503"><code>		f.on = false</code></span>
<span class="codeline" id="line-504"><code>		f.json = false</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>	return nil</code></span>
<span class="codeline" id="line-507"><code>}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>func (f *chattyFlag) String() string {</code></span>
<span class="codeline" id="line-510"><code>	if f.json {</code></span>
<span class="codeline" id="line-511"><code>		return "test2json"</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code>	if f.on {</code></span>
<span class="codeline" id="line-514"><code>		return "true"</code></span>
<span class="codeline" id="line-515"><code>	}</code></span>
<span class="codeline" id="line-516"><code>	return "false"</code></span>
<span class="codeline" id="line-517"><code>}</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>func (f *chattyFlag) Get() any {</code></span>
<span class="codeline" id="line-520"><code>	if f.json {</code></span>
<span class="codeline" id="line-521"><code>		return "test2json"</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code>	return f.on</code></span>
<span class="codeline" id="line-524"><code>}</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>const marker = byte(0x16) // ^V for framing</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>func (f *chattyFlag) prefix() string {</code></span>
<span class="codeline" id="line-529"><code>	if f.json {</code></span>
<span class="codeline" id="line-530"><code>		return string(marker)</code></span>
<span class="codeline" id="line-531"><code>	}</code></span>
<span class="codeline" id="line-532"><code>	return ""</code></span>
<span class="codeline" id="line-533"><code>}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>type chattyPrinter struct {</code></span>
<span class="codeline" id="line-536"><code>	w          io.Writer</code></span>
<span class="codeline" id="line-537"><code>	lastNameMu sync.Mutex // guards lastName</code></span>
<span class="codeline" id="line-538"><code>	lastName   string     // last printed test name in chatty mode</code></span>
<span class="codeline" id="line-539"><code>	json       bool       // -v=json output mode</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>func newChattyPrinter(w io.Writer) *chattyPrinter {</code></span>
<span class="codeline" id="line-543"><code>	return &amp;chattyPrinter{w: w, json: chatty.json}</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>// prefix is like chatty.prefix but using p.json instead of chatty.json.</code></span>
<span class="codeline" id="line-547"><code>// Using p.json allows tests to check the json behavior without modifying</code></span>
<span class="codeline" id="line-548"><code>// the global variable. For convenience, we allow p == nil and treat</code></span>
<span class="codeline" id="line-549"><code>// that as not in json mode (because it's not chatty at all).</code></span>
<span class="codeline" id="line-550"><code>func (p *chattyPrinter) prefix() string {</code></span>
<span class="codeline" id="line-551"><code>	if p != nil &amp;&amp; p.json {</code></span>
<span class="codeline" id="line-552"><code>		return string(marker)</code></span>
<span class="codeline" id="line-553"><code>	}</code></span>
<span class="codeline" id="line-554"><code>	return ""</code></span>
<span class="codeline" id="line-555"><code>}</code></span>
<span class="codeline" id="line-556"><code></code></span>
<span class="codeline" id="line-557"><code>// Updatef prints a message about the status of the named test to w.</code></span>
<span class="codeline" id="line-558"><code>//</code></span>
<span class="codeline" id="line-559"><code>// The formatted message must include the test name itself.</code></span>
<span class="codeline" id="line-560"><code>func (p *chattyPrinter) Updatef(testName, format string, args ...any) {</code></span>
<span class="codeline" id="line-561"><code>	p.lastNameMu.Lock()</code></span>
<span class="codeline" id="line-562"><code>	defer p.lastNameMu.Unlock()</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>	// Since the message already implies an association with a specific new test,</code></span>
<span class="codeline" id="line-565"><code>	// we don't need to check what the old test name was or log an extra NAME line</code></span>
<span class="codeline" id="line-566"><code>	// for it. (We're updating it anyway, and the current message already includes</code></span>
<span class="codeline" id="line-567"><code>	// the test name.)</code></span>
<span class="codeline" id="line-568"><code>	p.lastName = testName</code></span>
<span class="codeline" id="line-569"><code>	fmt.Fprintf(p.w, p.prefix()+format, args...)</code></span>
<span class="codeline" id="line-570"><code>}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>// Printf prints a message, generated by the named test, that does not</code></span>
<span class="codeline" id="line-573"><code>// necessarily mention that tests's name itself.</code></span>
<span class="codeline" id="line-574"><code>func (p *chattyPrinter) Printf(testName, format string, args ...any) {</code></span>
<span class="codeline" id="line-575"><code>	p.lastNameMu.Lock()</code></span>
<span class="codeline" id="line-576"><code>	defer p.lastNameMu.Unlock()</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>	if p.lastName == "" {</code></span>
<span class="codeline" id="line-579"><code>		p.lastName = testName</code></span>
<span class="codeline" id="line-580"><code>	} else if p.lastName != testName {</code></span>
<span class="codeline" id="line-581"><code>		fmt.Fprintf(p.w, "%s=== NAME  %s\n", p.prefix(), testName)</code></span>
<span class="codeline" id="line-582"><code>		p.lastName = testName</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code></code></span>
<span class="codeline" id="line-585"><code>	fmt.Fprintf(p.w, format, args...)</code></span>
<span class="codeline" id="line-586"><code>}</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>// The maximum number of stack frames to go through when skipping helper functions for</code></span>
<span class="codeline" id="line-589"><code>// the purpose of decorating log messages.</code></span>
<span class="codeline" id="line-590"><code>const maxStackLen = 50</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>// common holds the elements common between T and B and</code></span>
<span class="codeline" id="line-593"><code>// captures common methods such as Errorf.</code></span>
<span class="codeline" id="line-594"><code>type common struct {</code></span>
<span class="codeline" id="line-595"><code>	mu          sync.RWMutex         // guards this group of fields</code></span>
<span class="codeline" id="line-596"><code>	output      []byte               // Output generated by test or benchmark.</code></span>
<span class="codeline" id="line-597"><code>	w           io.Writer            // For flushToParent.</code></span>
<span class="codeline" id="line-598"><code>	ran         bool                 // Test or benchmark (or one of its subtests) was executed.</code></span>
<span class="codeline" id="line-599"><code>	failed      bool                 // Test or benchmark has failed.</code></span>
<span class="codeline" id="line-600"><code>	skipped     bool                 // Test or benchmark has been skipped.</code></span>
<span class="codeline" id="line-601"><code>	done        bool                 // Test is finished and all subtests have completed.</code></span>
<span class="codeline" id="line-602"><code>	helperPCs   map[uintptr]struct{} // functions to be skipped when writing file/line info</code></span>
<span class="codeline" id="line-603"><code>	helperNames map[string]struct{}  // helperPCs converted to function names</code></span>
<span class="codeline" id="line-604"><code>	cleanups    []func()             // optional functions to be called at the end of the test</code></span>
<span class="codeline" id="line-605"><code>	cleanupName string               // Name of the cleanup function.</code></span>
<span class="codeline" id="line-606"><code>	cleanupPc   []uintptr            // The stack trace at the point where Cleanup was called.</code></span>
<span class="codeline" id="line-607"><code>	finished    bool                 // Test function has completed.</code></span>
<span class="codeline" id="line-608"><code>	inFuzzFn    bool                 // Whether the fuzz target, if this is one, is running.</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>	chatty         *chattyPrinter // A copy of chattyPrinter, if the chatty flag is set.</code></span>
<span class="codeline" id="line-611"><code>	bench          bool           // Whether the current test is a benchmark.</code></span>
<span class="codeline" id="line-612"><code>	hasSub         atomic.Bool    // whether there are sub-benchmarks.</code></span>
<span class="codeline" id="line-613"><code>	cleanupStarted atomic.Bool    // Registered cleanup callbacks have started to execute</code></span>
<span class="codeline" id="line-614"><code>	runner         string         // Function name of tRunner running the test.</code></span>
<span class="codeline" id="line-615"><code>	isParallel     bool           // Whether the test is parallel.</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>	parent   *common</code></span>
<span class="codeline" id="line-618"><code>	level    int       // Nesting depth of test or benchmark.</code></span>
<span class="codeline" id="line-619"><code>	creator  []uintptr // If level &gt; 0, the stack trace at the point where the parent called t.Run.</code></span>
<span class="codeline" id="line-620"><code>	name     string    // Name of test or benchmark.</code></span>
<span class="codeline" id="line-621"><code>	start    time.Time // Time test or benchmark started</code></span>
<span class="codeline" id="line-622"><code>	duration time.Duration</code></span>
<span class="codeline" id="line-623"><code>	barrier  chan bool // To signal parallel subtests they may start. Nil when T.Parallel is not present (B) or not usable (when fuzzing).</code></span>
<span class="codeline" id="line-624"><code>	signal   chan bool // To signal a test is done.</code></span>
<span class="codeline" id="line-625"><code>	sub      []*T      // Queue of subtests to be run in parallel.</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>	lastRaceErrors  atomic.Int64 // Max value of race.Errors seen during the test or its subtests.</code></span>
<span class="codeline" id="line-628"><code>	raceErrorLogged atomic.Bool</code></span>
<span class="codeline" id="line-629"><code></code></span>
<span class="codeline" id="line-630"><code>	tempDirMu  sync.Mutex</code></span>
<span class="codeline" id="line-631"><code>	tempDir    string</code></span>
<span class="codeline" id="line-632"><code>	tempDirErr error</code></span>
<span class="codeline" id="line-633"><code>	tempDirSeq int32</code></span>
<span class="codeline" id="line-634"><code>}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>// Short reports whether the -test.short flag is set.</code></span>
<span class="codeline" id="line-637"><code>func Short() bool {</code></span>
<span class="codeline" id="line-638"><code>	if short == nil {</code></span>
<span class="codeline" id="line-639"><code>		panic("testing: Short called before Init")</code></span>
<span class="codeline" id="line-640"><code>	}</code></span>
<span class="codeline" id="line-641"><code>	// Catch code that calls this from TestMain without first calling flag.Parse.</code></span>
<span class="codeline" id="line-642"><code>	if !flag.Parsed() {</code></span>
<span class="codeline" id="line-643"><code>		panic("testing: Short called before Parse")</code></span>
<span class="codeline" id="line-644"><code>	}</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>	return *short</code></span>
<span class="codeline" id="line-647"><code>}</code></span>
<span class="codeline" id="line-648"><code></code></span>
<span class="codeline" id="line-649"><code>// testBinary is set by cmd/go to "1" if this is a binary built by "go test".</code></span>
<span class="codeline" id="line-650"><code>// The value is set to "1" by a -X option to cmd/link. We assume that</code></span>
<span class="codeline" id="line-651"><code>// because this is possible, the compiler will not optimize testBinary</code></span>
<span class="codeline" id="line-652"><code>// into a constant on the basis that it is an unexported package-scope</code></span>
<span class="codeline" id="line-653"><code>// variable that is never changed. If the compiler ever starts implementing</code></span>
<span class="codeline" id="line-654"><code>// such an optimization, we will need some technique to mark this variable</code></span>
<span class="codeline" id="line-655"><code>// as "changed by a cmd/link -X option".</code></span>
<span class="codeline" id="line-656"><code>var testBinary = "0"</code></span>
<span class="codeline" id="line-657"><code></code></span>
<span class="codeline" id="line-658"><code>// Testing reports whether the current code is being run in a test.</code></span>
<span class="codeline" id="line-659"><code>// This will report true in programs created by "go test",</code></span>
<span class="codeline" id="line-660"><code>// false in programs created by "go build".</code></span>
<span class="codeline" id="line-661"><code>func Testing() bool {</code></span>
<span class="codeline" id="line-662"><code>	return testBinary == "1"</code></span>
<span class="codeline" id="line-663"><code>}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>// CoverMode reports what the test coverage mode is set to. The</code></span>
<span class="codeline" id="line-666"><code>// values are "set", "count", or "atomic". The return value will be</code></span>
<span class="codeline" id="line-667"><code>// empty if test coverage is not enabled.</code></span>
<span class="codeline" id="line-668"><code>func CoverMode() string {</code></span>
<span class="codeline" id="line-669"><code>	if goexperiment.CoverageRedesign {</code></span>
<span class="codeline" id="line-670"><code>		return cover2.mode</code></span>
<span class="codeline" id="line-671"><code>	}</code></span>
<span class="codeline" id="line-672"><code>	return cover.Mode</code></span>
<span class="codeline" id="line-673"><code>}</code></span>
<span class="codeline" id="line-674"><code></code></span>
<span class="codeline" id="line-675"><code>// Verbose reports whether the -test.v flag is set.</code></span>
<span class="codeline" id="line-676"><code>func Verbose() bool {</code></span>
<span class="codeline" id="line-677"><code>	// Same as in Short.</code></span>
<span class="codeline" id="line-678"><code>	if !flag.Parsed() {</code></span>
<span class="codeline" id="line-679"><code>		panic("testing: Verbose called before Parse")</code></span>
<span class="codeline" id="line-680"><code>	}</code></span>
<span class="codeline" id="line-681"><code>	return chatty.on</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>func (c *common) checkFuzzFn(name string) {</code></span>
<span class="codeline" id="line-685"><code>	if c.inFuzzFn {</code></span>
<span class="codeline" id="line-686"><code>		panic(fmt.Sprintf("testing: f.%s was called inside the fuzz target, use t.%s instead", name, name))</code></span>
<span class="codeline" id="line-687"><code>	}</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// frameSkip searches, starting after skip frames, for the first caller frame</code></span>
<span class="codeline" id="line-691"><code>// in a function not marked as a helper and returns that frame.</code></span>
<span class="codeline" id="line-692"><code>// The search stops if it finds a tRunner function that</code></span>
<span class="codeline" id="line-693"><code>// was the entry point into the test and the test is not a subtest.</code></span>
<span class="codeline" id="line-694"><code>// This function must be called with c.mu held.</code></span>
<span class="codeline" id="line-695"><code>func (c *common) frameSkip(skip int) runtime.Frame {</code></span>
<span class="codeline" id="line-696"><code>	// If the search continues into the parent test, we'll have to hold</code></span>
<span class="codeline" id="line-697"><code>	// its mu temporarily. If we then return, we need to unlock it.</code></span>
<span class="codeline" id="line-698"><code>	shouldUnlock := false</code></span>
<span class="codeline" id="line-699"><code>	defer func() {</code></span>
<span class="codeline" id="line-700"><code>		if shouldUnlock {</code></span>
<span class="codeline" id="line-701"><code>			c.mu.Unlock()</code></span>
<span class="codeline" id="line-702"><code>		}</code></span>
<span class="codeline" id="line-703"><code>	}()</code></span>
<span class="codeline" id="line-704"><code>	var pc [maxStackLen]uintptr</code></span>
<span class="codeline" id="line-705"><code>	// Skip two extra frames to account for this function</code></span>
<span class="codeline" id="line-706"><code>	// and runtime.Callers itself.</code></span>
<span class="codeline" id="line-707"><code>	n := runtime.Callers(skip+2, pc[:])</code></span>
<span class="codeline" id="line-708"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-709"><code>		panic("testing: zero callers found")</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code>	frames := runtime.CallersFrames(pc[:n])</code></span>
<span class="codeline" id="line-712"><code>	var firstFrame, prevFrame, frame runtime.Frame</code></span>
<span class="codeline" id="line-713"><code>	for more := true; more; prevFrame = frame {</code></span>
<span class="codeline" id="line-714"><code>		frame, more = frames.Next()</code></span>
<span class="codeline" id="line-715"><code>		if frame.Function == "runtime.gopanic" {</code></span>
<span class="codeline" id="line-716"><code>			continue</code></span>
<span class="codeline" id="line-717"><code>		}</code></span>
<span class="codeline" id="line-718"><code>		if frame.Function == c.cleanupName {</code></span>
<span class="codeline" id="line-719"><code>			frames = runtime.CallersFrames(c.cleanupPc)</code></span>
<span class="codeline" id="line-720"><code>			continue</code></span>
<span class="codeline" id="line-721"><code>		}</code></span>
<span class="codeline" id="line-722"><code>		if firstFrame.PC == 0 {</code></span>
<span class="codeline" id="line-723"><code>			firstFrame = frame</code></span>
<span class="codeline" id="line-724"><code>		}</code></span>
<span class="codeline" id="line-725"><code>		if frame.Function == c.runner {</code></span>
<span class="codeline" id="line-726"><code>			// We've gone up all the way to the tRunner calling</code></span>
<span class="codeline" id="line-727"><code>			// the test function (so the user must have</code></span>
<span class="codeline" id="line-728"><code>			// called tb.Helper from inside that test function).</code></span>
<span class="codeline" id="line-729"><code>			// If this is a top-level test, only skip up to the test function itself.</code></span>
<span class="codeline" id="line-730"><code>			// If we're in a subtest, continue searching in the parent test,</code></span>
<span class="codeline" id="line-731"><code>			// starting from the point of the call to Run which created this subtest.</code></span>
<span class="codeline" id="line-732"><code>			if c.level &gt; 1 {</code></span>
<span class="codeline" id="line-733"><code>				frames = runtime.CallersFrames(c.creator)</code></span>
<span class="codeline" id="line-734"><code>				parent := c.parent</code></span>
<span class="codeline" id="line-735"><code>				// We're no longer looking at the current c after this point,</code></span>
<span class="codeline" id="line-736"><code>				// so we should unlock its mu, unless it's the original receiver,</code></span>
<span class="codeline" id="line-737"><code>				// in which case our caller doesn't expect us to do that.</code></span>
<span class="codeline" id="line-738"><code>				if shouldUnlock {</code></span>
<span class="codeline" id="line-739"><code>					c.mu.Unlock()</code></span>
<span class="codeline" id="line-740"><code>				}</code></span>
<span class="codeline" id="line-741"><code>				c = parent</code></span>
<span class="codeline" id="line-742"><code>				// Remember to unlock c.mu when we no longer need it, either</code></span>
<span class="codeline" id="line-743"><code>				// because we went up another nesting level, or because we</code></span>
<span class="codeline" id="line-744"><code>				// returned.</code></span>
<span class="codeline" id="line-745"><code>				shouldUnlock = true</code></span>
<span class="codeline" id="line-746"><code>				c.mu.Lock()</code></span>
<span class="codeline" id="line-747"><code>				continue</code></span>
<span class="codeline" id="line-748"><code>			}</code></span>
<span class="codeline" id="line-749"><code>			return prevFrame</code></span>
<span class="codeline" id="line-750"><code>		}</code></span>
<span class="codeline" id="line-751"><code>		// If more helper PCs have been added since we last did the conversion</code></span>
<span class="codeline" id="line-752"><code>		if c.helperNames == nil {</code></span>
<span class="codeline" id="line-753"><code>			c.helperNames = make(map[string]struct{})</code></span>
<span class="codeline" id="line-754"><code>			for pc := range c.helperPCs {</code></span>
<span class="codeline" id="line-755"><code>				c.helperNames[pcToName(pc)] = struct{}{}</code></span>
<span class="codeline" id="line-756"><code>			}</code></span>
<span class="codeline" id="line-757"><code>		}</code></span>
<span class="codeline" id="line-758"><code>		if _, ok := c.helperNames[frame.Function]; !ok {</code></span>
<span class="codeline" id="line-759"><code>			// Found a frame that wasn't inside a helper function.</code></span>
<span class="codeline" id="line-760"><code>			return frame</code></span>
<span class="codeline" id="line-761"><code>		}</code></span>
<span class="codeline" id="line-762"><code>	}</code></span>
<span class="codeline" id="line-763"><code>	return firstFrame</code></span>
<span class="codeline" id="line-764"><code>}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>// decorate prefixes the string with the file and line of the call site</code></span>
<span class="codeline" id="line-767"><code>// and inserts the final newline if needed and indentation spaces for formatting.</code></span>
<span class="codeline" id="line-768"><code>// This function must be called with c.mu held.</code></span>
<span class="codeline" id="line-769"><code>func (c *common) decorate(s string, skip int) string {</code></span>
<span class="codeline" id="line-770"><code>	frame := c.frameSkip(skip)</code></span>
<span class="codeline" id="line-771"><code>	file := frame.File</code></span>
<span class="codeline" id="line-772"><code>	line := frame.Line</code></span>
<span class="codeline" id="line-773"><code>	if file != "" {</code></span>
<span class="codeline" id="line-774"><code>		if *fullPath {</code></span>
<span class="codeline" id="line-775"><code>			// If relative path, truncate file name at last file name separator.</code></span>
<span class="codeline" id="line-776"><code>		} else if index := strings.LastIndexAny(file, `/\`); index &gt;= 0 {</code></span>
<span class="codeline" id="line-777"><code>			file = file[index+1:]</code></span>
<span class="codeline" id="line-778"><code>		}</code></span>
<span class="codeline" id="line-779"><code>	} else {</code></span>
<span class="codeline" id="line-780"><code>		file = "???"</code></span>
<span class="codeline" id="line-781"><code>	}</code></span>
<span class="codeline" id="line-782"><code>	if line == 0 {</code></span>
<span class="codeline" id="line-783"><code>		line = 1</code></span>
<span class="codeline" id="line-784"><code>	}</code></span>
<span class="codeline" id="line-785"><code>	buf := new(strings.Builder)</code></span>
<span class="codeline" id="line-786"><code>	// Every line is indented at least 4 spaces.</code></span>
<span class="codeline" id="line-787"><code>	buf.WriteString("    ")</code></span>
<span class="codeline" id="line-788"><code>	fmt.Fprintf(buf, "%s:%d: ", file, line)</code></span>
<span class="codeline" id="line-789"><code>	lines := strings.Split(s, "\n")</code></span>
<span class="codeline" id="line-790"><code>	if l := len(lines); l &gt; 1 &amp;&amp; lines[l-1] == "" {</code></span>
<span class="codeline" id="line-791"><code>		lines = lines[:l-1]</code></span>
<span class="codeline" id="line-792"><code>	}</code></span>
<span class="codeline" id="line-793"><code>	for i, line := range lines {</code></span>
<span class="codeline" id="line-794"><code>		if i &gt; 0 {</code></span>
<span class="codeline" id="line-795"><code>			// Second and subsequent lines are indented an additional 4 spaces.</code></span>
<span class="codeline" id="line-796"><code>			buf.WriteString("\n        ")</code></span>
<span class="codeline" id="line-797"><code>		}</code></span>
<span class="codeline" id="line-798"><code>		buf.WriteString(line)</code></span>
<span class="codeline" id="line-799"><code>	}</code></span>
<span class="codeline" id="line-800"><code>	buf.WriteByte('\n')</code></span>
<span class="codeline" id="line-801"><code>	return buf.String()</code></span>
<span class="codeline" id="line-802"><code>}</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>// flushToParent writes c.output to the parent after first writing the header</code></span>
<span class="codeline" id="line-805"><code>// with the given format and arguments.</code></span>
<span class="codeline" id="line-806"><code>func (c *common) flushToParent(testName, format string, args ...any) {</code></span>
<span class="codeline" id="line-807"><code>	p := c.parent</code></span>
<span class="codeline" id="line-808"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-809"><code>	defer p.mu.Unlock()</code></span>
<span class="codeline" id="line-810"><code></code></span>
<span class="codeline" id="line-811"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-812"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-813"><code></code></span>
<span class="codeline" id="line-814"><code>	if len(c.output) &gt; 0 {</code></span>
<span class="codeline" id="line-815"><code>		// Add the current c.output to the print,</code></span>
<span class="codeline" id="line-816"><code>		// and then arrange for the print to replace c.output.</code></span>
<span class="codeline" id="line-817"><code>		// (This displays the logged output after the --- FAIL line.)</code></span>
<span class="codeline" id="line-818"><code>		format += "%s"</code></span>
<span class="codeline" id="line-819"><code>		args = append(args[:len(args):len(args)], c.output)</code></span>
<span class="codeline" id="line-820"><code>		c.output = c.output[:0]</code></span>
<span class="codeline" id="line-821"><code>	}</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>	if c.chatty != nil &amp;&amp; (p.w == c.chatty.w || c.chatty.json) {</code></span>
<span class="codeline" id="line-824"><code>		// We're flushing to the actual output, so track that this output is</code></span>
<span class="codeline" id="line-825"><code>		// associated with a specific test (and, specifically, that the next output</code></span>
<span class="codeline" id="line-826"><code>		// is *not* associated with that test).</code></span>
<span class="codeline" id="line-827"><code>		//</code></span>
<span class="codeline" id="line-828"><code>		// Moreover, if c.output is non-empty it is important that this write be</code></span>
<span class="codeline" id="line-829"><code>		// atomic with respect to the output of other tests, so that we don't end up</code></span>
<span class="codeline" id="line-830"><code>		// with confusing '=== NAME' lines in the middle of our '--- PASS' block.</code></span>
<span class="codeline" id="line-831"><code>		// Neither humans nor cmd/test2json can parse those easily.</code></span>
<span class="codeline" id="line-832"><code>		// (See https://go.dev/issue/40771.)</code></span>
<span class="codeline" id="line-833"><code>		//</code></span>
<span class="codeline" id="line-834"><code>		// If test2json is used, we never flush to parent tests,</code></span>
<span class="codeline" id="line-835"><code>		// so that the json stream shows subtests as they finish.</code></span>
<span class="codeline" id="line-836"><code>		// (See https://go.dev/issue/29811.)</code></span>
<span class="codeline" id="line-837"><code>		c.chatty.Updatef(testName, format, args...)</code></span>
<span class="codeline" id="line-838"><code>	} else {</code></span>
<span class="codeline" id="line-839"><code>		// We're flushing to the output buffer of the parent test, which will</code></span>
<span class="codeline" id="line-840"><code>		// itself follow a test-name header when it is finally flushed to stdout.</code></span>
<span class="codeline" id="line-841"><code>		fmt.Fprintf(p.w, c.chatty.prefix()+format, args...)</code></span>
<span class="codeline" id="line-842"><code>	}</code></span>
<span class="codeline" id="line-843"><code>}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>type indenter struct {</code></span>
<span class="codeline" id="line-846"><code>	c *common</code></span>
<span class="codeline" id="line-847"><code>}</code></span>
<span class="codeline" id="line-848"><code></code></span>
<span class="codeline" id="line-849"><code>func (w indenter) Write(b []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-850"><code>	n = len(b)</code></span>
<span class="codeline" id="line-851"><code>	for len(b) &gt; 0 {</code></span>
<span class="codeline" id="line-852"><code>		end := bytes.IndexByte(b, '\n')</code></span>
<span class="codeline" id="line-853"><code>		if end == -1 {</code></span>
<span class="codeline" id="line-854"><code>			end = len(b)</code></span>
<span class="codeline" id="line-855"><code>		} else {</code></span>
<span class="codeline" id="line-856"><code>			end++</code></span>
<span class="codeline" id="line-857"><code>		}</code></span>
<span class="codeline" id="line-858"><code>		// An indent of 4 spaces will neatly align the dashes with the status</code></span>
<span class="codeline" id="line-859"><code>		// indicator of the parent.</code></span>
<span class="codeline" id="line-860"><code>		line := b[:end]</code></span>
<span class="codeline" id="line-861"><code>		if line[0] == marker {</code></span>
<span class="codeline" id="line-862"><code>			w.c.output = append(w.c.output, marker)</code></span>
<span class="codeline" id="line-863"><code>			line = line[1:]</code></span>
<span class="codeline" id="line-864"><code>		}</code></span>
<span class="codeline" id="line-865"><code>		const indent = "    "</code></span>
<span class="codeline" id="line-866"><code>		w.c.output = append(w.c.output, indent...)</code></span>
<span class="codeline" id="line-867"><code>		w.c.output = append(w.c.output, line...)</code></span>
<span class="codeline" id="line-868"><code>		b = b[end:]</code></span>
<span class="codeline" id="line-869"><code>	}</code></span>
<span class="codeline" id="line-870"><code>	return</code></span>
<span class="codeline" id="line-871"><code>}</code></span>
<span class="codeline" id="line-872"><code></code></span>
<span class="codeline" id="line-873"><code>// fmtDuration returns a string representing d in the form "87.00s".</code></span>
<span class="codeline" id="line-874"><code>func fmtDuration(d time.Duration) string {</code></span>
<span class="codeline" id="line-875"><code>	return fmt.Sprintf("%.2fs", d.Seconds())</code></span>
<span class="codeline" id="line-876"><code>}</code></span>
<span class="codeline" id="line-877"><code></code></span>
<span class="codeline" id="line-878"><code>// TB is the interface common to T, B, and F.</code></span>
<span class="codeline" id="line-879"><code>type TB interface {</code></span>
<span class="codeline" id="line-880"><code>	Cleanup(func())</code></span>
<span class="codeline" id="line-881"><code>	Error(args ...any)</code></span>
<span class="codeline" id="line-882"><code>	Errorf(format string, args ...any)</code></span>
<span class="codeline" id="line-883"><code>	Fail()</code></span>
<span class="codeline" id="line-884"><code>	FailNow()</code></span>
<span class="codeline" id="line-885"><code>	Failed() bool</code></span>
<span class="codeline" id="line-886"><code>	Fatal(args ...any)</code></span>
<span class="codeline" id="line-887"><code>	Fatalf(format string, args ...any)</code></span>
<span class="codeline" id="line-888"><code>	Helper()</code></span>
<span class="codeline" id="line-889"><code>	Log(args ...any)</code></span>
<span class="codeline" id="line-890"><code>	Logf(format string, args ...any)</code></span>
<span class="codeline" id="line-891"><code>	Name() string</code></span>
<span class="codeline" id="line-892"><code>	Setenv(key, value string)</code></span>
<span class="codeline" id="line-893"><code>	Skip(args ...any)</code></span>
<span class="codeline" id="line-894"><code>	SkipNow()</code></span>
<span class="codeline" id="line-895"><code>	Skipf(format string, args ...any)</code></span>
<span class="codeline" id="line-896"><code>	Skipped() bool</code></span>
<span class="codeline" id="line-897"><code>	TempDir() string</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>	// A private method to prevent users implementing the</code></span>
<span class="codeline" id="line-900"><code>	// interface and so future additions to it will not</code></span>
<span class="codeline" id="line-901"><code>	// violate Go 1 compatibility.</code></span>
<span class="codeline" id="line-902"><code>	private()</code></span>
<span class="codeline" id="line-903"><code>}</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>var _ TB = (*T)(nil)</code></span>
<span class="codeline" id="line-906"><code>var _ TB = (*B)(nil)</code></span>
<span class="codeline" id="line-907"><code></code></span>
<span class="codeline" id="line-908"><code>// T is a type passed to Test functions to manage test state and support formatted test logs.</code></span>
<span class="codeline" id="line-909"><code>//</code></span>
<span class="codeline" id="line-910"><code>// A test ends when its Test function returns or calls any of the methods</code></span>
<span class="codeline" id="line-911"><code>// FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as</code></span>
<span class="codeline" id="line-912"><code>// the Parallel method, must be called only from the goroutine running the</code></span>
<span class="codeline" id="line-913"><code>// Test function.</code></span>
<span class="codeline" id="line-914"><code>//</code></span>
<span class="codeline" id="line-915"><code>// The other reporting methods, such as the variations of Log and Error,</code></span>
<span class="codeline" id="line-916"><code>// may be called simultaneously from multiple goroutines.</code></span>
<span class="codeline" id="line-917"><code>type T struct {</code></span>
<span class="codeline" id="line-918"><code>	common</code></span>
<span class="codeline" id="line-919"><code>	isEnvSet bool</code></span>
<span class="codeline" id="line-920"><code>	context  *testContext // For running tests and subtests.</code></span>
<span class="codeline" id="line-921"><code>}</code></span>
<span class="codeline" id="line-922"><code></code></span>
<span class="codeline" id="line-923"><code>func (c *common) private() {}</code></span>
<span class="codeline" id="line-924"><code></code></span>
<span class="codeline" id="line-925"><code>// Name returns the name of the running (sub-) test or benchmark.</code></span>
<span class="codeline" id="line-926"><code>//</code></span>
<span class="codeline" id="line-927"><code>// The name will include the name of the test along with the names of</code></span>
<span class="codeline" id="line-928"><code>// any nested sub-tests. If two sibling sub-tests have the same name,</code></span>
<span class="codeline" id="line-929"><code>// Name will append a suffix to guarantee the returned name is unique.</code></span>
<span class="codeline" id="line-930"><code>func (c *common) Name() string {</code></span>
<span class="codeline" id="line-931"><code>	return c.name</code></span>
<span class="codeline" id="line-932"><code>}</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>func (c *common) setRan() {</code></span>
<span class="codeline" id="line-935"><code>	if c.parent != nil {</code></span>
<span class="codeline" id="line-936"><code>		c.parent.setRan()</code></span>
<span class="codeline" id="line-937"><code>	}</code></span>
<span class="codeline" id="line-938"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-939"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-940"><code>	c.ran = true</code></span>
<span class="codeline" id="line-941"><code>}</code></span>
<span class="codeline" id="line-942"><code></code></span>
<span class="codeline" id="line-943"><code>// Fail marks the function as having failed but continues execution.</code></span>
<span class="codeline" id="line-944"><code>func (c *common) Fail() {</code></span>
<span class="codeline" id="line-945"><code>	if c.parent != nil {</code></span>
<span class="codeline" id="line-946"><code>		c.parent.Fail()</code></span>
<span class="codeline" id="line-947"><code>	}</code></span>
<span class="codeline" id="line-948"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-949"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-950"><code>	// c.done needs to be locked to synchronize checks to c.done in parent tests.</code></span>
<span class="codeline" id="line-951"><code>	if c.done {</code></span>
<span class="codeline" id="line-952"><code>		panic("Fail in goroutine after " + c.name + " has completed")</code></span>
<span class="codeline" id="line-953"><code>	}</code></span>
<span class="codeline" id="line-954"><code>	c.failed = true</code></span>
<span class="codeline" id="line-955"><code>}</code></span>
<span class="codeline" id="line-956"><code></code></span>
<span class="codeline" id="line-957"><code>// Failed reports whether the function has failed.</code></span>
<span class="codeline" id="line-958"><code>func (c *common) Failed() bool {</code></span>
<span class="codeline" id="line-959"><code>	c.mu.RLock()</code></span>
<span class="codeline" id="line-960"><code>	defer c.mu.RUnlock()</code></span>
<span class="codeline" id="line-961"><code></code></span>
<span class="codeline" id="line-962"><code>	if !c.done &amp;&amp; int64(race.Errors()) &gt; c.lastRaceErrors.Load() {</code></span>
<span class="codeline" id="line-963"><code>		c.mu.RUnlock()</code></span>
<span class="codeline" id="line-964"><code>		c.checkRaces()</code></span>
<span class="codeline" id="line-965"><code>		c.mu.RLock()</code></span>
<span class="codeline" id="line-966"><code>	}</code></span>
<span class="codeline" id="line-967"><code></code></span>
<span class="codeline" id="line-968"><code>	return c.failed</code></span>
<span class="codeline" id="line-969"><code>}</code></span>
<span class="codeline" id="line-970"><code></code></span>
<span class="codeline" id="line-971"><code>// FailNow marks the function as having failed and stops its execution</code></span>
<span class="codeline" id="line-972"><code>// by calling runtime.Goexit (which then runs all deferred calls in the</code></span>
<span class="codeline" id="line-973"><code>// current goroutine).</code></span>
<span class="codeline" id="line-974"><code>// Execution will continue at the next test or benchmark.</code></span>
<span class="codeline" id="line-975"><code>// FailNow must be called from the goroutine running the</code></span>
<span class="codeline" id="line-976"><code>// test or benchmark function, not from other goroutines</code></span>
<span class="codeline" id="line-977"><code>// created during the test. Calling FailNow does not stop</code></span>
<span class="codeline" id="line-978"><code>// those other goroutines.</code></span>
<span class="codeline" id="line-979"><code>func (c *common) FailNow() {</code></span>
<span class="codeline" id="line-980"><code>	c.checkFuzzFn("FailNow")</code></span>
<span class="codeline" id="line-981"><code>	c.Fail()</code></span>
<span class="codeline" id="line-982"><code></code></span>
<span class="codeline" id="line-983"><code>	// Calling runtime.Goexit will exit the goroutine, which</code></span>
<span class="codeline" id="line-984"><code>	// will run the deferred functions in this goroutine,</code></span>
<span class="codeline" id="line-985"><code>	// which will eventually run the deferred lines in tRunner,</code></span>
<span class="codeline" id="line-986"><code>	// which will signal to the test loop that this test is done.</code></span>
<span class="codeline" id="line-987"><code>	//</code></span>
<span class="codeline" id="line-988"><code>	// A previous version of this code said:</code></span>
<span class="codeline" id="line-989"><code>	//</code></span>
<span class="codeline" id="line-990"><code>	//	c.duration = ...</code></span>
<span class="codeline" id="line-991"><code>	//	c.signal &lt;- c.self</code></span>
<span class="codeline" id="line-992"><code>	//	runtime.Goexit()</code></span>
<span class="codeline" id="line-993"><code>	//</code></span>
<span class="codeline" id="line-994"><code>	// This previous version duplicated code (those lines are in</code></span>
<span class="codeline" id="line-995"><code>	// tRunner no matter what), but worse the goroutine teardown</code></span>
<span class="codeline" id="line-996"><code>	// implicit in runtime.Goexit was not guaranteed to complete</code></span>
<span class="codeline" id="line-997"><code>	// before the test exited. If a test deferred an important cleanup</code></span>
<span class="codeline" id="line-998"><code>	// function (like removing temporary files), there was no guarantee</code></span>
<span class="codeline" id="line-999"><code>	// it would run on a test failure. Because we send on c.signal during</code></span>
<span class="codeline" id="line-1000"><code>	// a top-of-stack deferred function now, we know that the send</code></span>
<span class="codeline" id="line-1001"><code>	// only happens after any other stacked defers have completed.</code></span>
<span class="codeline" id="line-1002"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1003"><code>	c.finished = true</code></span>
<span class="codeline" id="line-1004"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-1005"><code>	runtime.Goexit()</code></span>
<span class="codeline" id="line-1006"><code>}</code></span>
<span class="codeline" id="line-1007"><code></code></span>
<span class="codeline" id="line-1008"><code>// log generates the output. It's always at the same stack depth.</code></span>
<span class="codeline" id="line-1009"><code>func (c *common) log(s string) {</code></span>
<span class="codeline" id="line-1010"><code>	c.logDepth(s, 3) // logDepth + log + public function</code></span>
<span class="codeline" id="line-1011"><code>}</code></span>
<span class="codeline" id="line-1012"><code></code></span>
<span class="codeline" id="line-1013"><code>// logDepth generates the output at an arbitrary stack depth.</code></span>
<span class="codeline" id="line-1014"><code>func (c *common) logDepth(s string, depth int) {</code></span>
<span class="codeline" id="line-1015"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1016"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1017"><code>	if c.done {</code></span>
<span class="codeline" id="line-1018"><code>		// This test has already finished. Try and log this message</code></span>
<span class="codeline" id="line-1019"><code>		// with our parent. If we don't have a parent, panic.</code></span>
<span class="codeline" id="line-1020"><code>		for parent := c.parent; parent != nil; parent = parent.parent {</code></span>
<span class="codeline" id="line-1021"><code>			parent.mu.Lock()</code></span>
<span class="codeline" id="line-1022"><code>			defer parent.mu.Unlock()</code></span>
<span class="codeline" id="line-1023"><code>			if !parent.done {</code></span>
<span class="codeline" id="line-1024"><code>				parent.output = append(parent.output, parent.decorate(s, depth+1)...)</code></span>
<span class="codeline" id="line-1025"><code>				return</code></span>
<span class="codeline" id="line-1026"><code>			}</code></span>
<span class="codeline" id="line-1027"><code>		}</code></span>
<span class="codeline" id="line-1028"><code>		panic("Log in goroutine after " + c.name + " has completed: " + s)</code></span>
<span class="codeline" id="line-1029"><code>	} else {</code></span>
<span class="codeline" id="line-1030"><code>		if c.chatty != nil {</code></span>
<span class="codeline" id="line-1031"><code>			if c.bench {</code></span>
<span class="codeline" id="line-1032"><code>				// Benchmarks don't print === CONT, so we should skip the test</code></span>
<span class="codeline" id="line-1033"><code>				// printer and just print straight to stdout.</code></span>
<span class="codeline" id="line-1034"><code>				fmt.Print(c.decorate(s, depth+1))</code></span>
<span class="codeline" id="line-1035"><code>			} else {</code></span>
<span class="codeline" id="line-1036"><code>				c.chatty.Printf(c.name, "%s", c.decorate(s, depth+1))</code></span>
<span class="codeline" id="line-1037"><code>			}</code></span>
<span class="codeline" id="line-1038"><code></code></span>
<span class="codeline" id="line-1039"><code>			return</code></span>
<span class="codeline" id="line-1040"><code>		}</code></span>
<span class="codeline" id="line-1041"><code>		c.output = append(c.output, c.decorate(s, depth+1)...)</code></span>
<span class="codeline" id="line-1042"><code>	}</code></span>
<span class="codeline" id="line-1043"><code>}</code></span>
<span class="codeline" id="line-1044"><code></code></span>
<span class="codeline" id="line-1045"><code>// Log formats its arguments using default formatting, analogous to Println,</code></span>
<span class="codeline" id="line-1046"><code>// and records the text in the error log. For tests, the text will be printed only if</code></span>
<span class="codeline" id="line-1047"><code>// the test fails or the -test.v flag is set. For benchmarks, the text is always</code></span>
<span class="codeline" id="line-1048"><code>// printed to avoid having performance depend on the value of the -test.v flag.</code></span>
<span class="codeline" id="line-1049"><code>func (c *common) Log(args ...any) {</code></span>
<span class="codeline" id="line-1050"><code>	c.checkFuzzFn("Log")</code></span>
<span class="codeline" id="line-1051"><code>	c.log(fmt.Sprintln(args...))</code></span>
<span class="codeline" id="line-1052"><code>}</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>// Logf formats its arguments according to the format, analogous to Printf, and</code></span>
<span class="codeline" id="line-1055"><code>// records the text in the error log. A final newline is added if not provided. For</code></span>
<span class="codeline" id="line-1056"><code>// tests, the text will be printed only if the test fails or the -test.v flag is</code></span>
<span class="codeline" id="line-1057"><code>// set. For benchmarks, the text is always printed to avoid having performance</code></span>
<span class="codeline" id="line-1058"><code>// depend on the value of the -test.v flag.</code></span>
<span class="codeline" id="line-1059"><code>func (c *common) Logf(format string, args ...any) {</code></span>
<span class="codeline" id="line-1060"><code>	c.checkFuzzFn("Logf")</code></span>
<span class="codeline" id="line-1061"><code>	c.log(fmt.Sprintf(format, args...))</code></span>
<span class="codeline" id="line-1062"><code>}</code></span>
<span class="codeline" id="line-1063"><code></code></span>
<span class="codeline" id="line-1064"><code>// Error is equivalent to Log followed by Fail.</code></span>
<span class="codeline" id="line-1065"><code>func (c *common) Error(args ...any) {</code></span>
<span class="codeline" id="line-1066"><code>	c.checkFuzzFn("Error")</code></span>
<span class="codeline" id="line-1067"><code>	c.log(fmt.Sprintln(args...))</code></span>
<span class="codeline" id="line-1068"><code>	c.Fail()</code></span>
<span class="codeline" id="line-1069"><code>}</code></span>
<span class="codeline" id="line-1070"><code></code></span>
<span class="codeline" id="line-1071"><code>// Errorf is equivalent to Logf followed by Fail.</code></span>
<span class="codeline" id="line-1072"><code>func (c *common) Errorf(format string, args ...any) {</code></span>
<span class="codeline" id="line-1073"><code>	c.checkFuzzFn("Errorf")</code></span>
<span class="codeline" id="line-1074"><code>	c.log(fmt.Sprintf(format, args...))</code></span>
<span class="codeline" id="line-1075"><code>	c.Fail()</code></span>
<span class="codeline" id="line-1076"><code>}</code></span>
<span class="codeline" id="line-1077"><code></code></span>
<span class="codeline" id="line-1078"><code>// Fatal is equivalent to Log followed by FailNow.</code></span>
<span class="codeline" id="line-1079"><code>func (c *common) Fatal(args ...any) {</code></span>
<span class="codeline" id="line-1080"><code>	c.checkFuzzFn("Fatal")</code></span>
<span class="codeline" id="line-1081"><code>	c.log(fmt.Sprintln(args...))</code></span>
<span class="codeline" id="line-1082"><code>	c.FailNow()</code></span>
<span class="codeline" id="line-1083"><code>}</code></span>
<span class="codeline" id="line-1084"><code></code></span>
<span class="codeline" id="line-1085"><code>// Fatalf is equivalent to Logf followed by FailNow.</code></span>
<span class="codeline" id="line-1086"><code>func (c *common) Fatalf(format string, args ...any) {</code></span>
<span class="codeline" id="line-1087"><code>	c.checkFuzzFn("Fatalf")</code></span>
<span class="codeline" id="line-1088"><code>	c.log(fmt.Sprintf(format, args...))</code></span>
<span class="codeline" id="line-1089"><code>	c.FailNow()</code></span>
<span class="codeline" id="line-1090"><code>}</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>// Skip is equivalent to Log followed by SkipNow.</code></span>
<span class="codeline" id="line-1093"><code>func (c *common) Skip(args ...any) {</code></span>
<span class="codeline" id="line-1094"><code>	c.checkFuzzFn("Skip")</code></span>
<span class="codeline" id="line-1095"><code>	c.log(fmt.Sprintln(args...))</code></span>
<span class="codeline" id="line-1096"><code>	c.SkipNow()</code></span>
<span class="codeline" id="line-1097"><code>}</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>// Skipf is equivalent to Logf followed by SkipNow.</code></span>
<span class="codeline" id="line-1100"><code>func (c *common) Skipf(format string, args ...any) {</code></span>
<span class="codeline" id="line-1101"><code>	c.checkFuzzFn("Skipf")</code></span>
<span class="codeline" id="line-1102"><code>	c.log(fmt.Sprintf(format, args...))</code></span>
<span class="codeline" id="line-1103"><code>	c.SkipNow()</code></span>
<span class="codeline" id="line-1104"><code>}</code></span>
<span class="codeline" id="line-1105"><code></code></span>
<span class="codeline" id="line-1106"><code>// SkipNow marks the test as having been skipped and stops its execution</code></span>
<span class="codeline" id="line-1107"><code>// by calling [runtime.Goexit].</code></span>
<span class="codeline" id="line-1108"><code>// If a test fails (see Error, Errorf, Fail) and is then skipped,</code></span>
<span class="codeline" id="line-1109"><code>// it is still considered to have failed.</code></span>
<span class="codeline" id="line-1110"><code>// Execution will continue at the next test or benchmark. See also FailNow.</code></span>
<span class="codeline" id="line-1111"><code>// SkipNow must be called from the goroutine running the test, not from</code></span>
<span class="codeline" id="line-1112"><code>// other goroutines created during the test. Calling SkipNow does not stop</code></span>
<span class="codeline" id="line-1113"><code>// those other goroutines.</code></span>
<span class="codeline" id="line-1114"><code>func (c *common) SkipNow() {</code></span>
<span class="codeline" id="line-1115"><code>	c.checkFuzzFn("SkipNow")</code></span>
<span class="codeline" id="line-1116"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1117"><code>	c.skipped = true</code></span>
<span class="codeline" id="line-1118"><code>	c.finished = true</code></span>
<span class="codeline" id="line-1119"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-1120"><code>	runtime.Goexit()</code></span>
<span class="codeline" id="line-1121"><code>}</code></span>
<span class="codeline" id="line-1122"><code></code></span>
<span class="codeline" id="line-1123"><code>// Skipped reports whether the test was skipped.</code></span>
<span class="codeline" id="line-1124"><code>func (c *common) Skipped() bool {</code></span>
<span class="codeline" id="line-1125"><code>	c.mu.RLock()</code></span>
<span class="codeline" id="line-1126"><code>	defer c.mu.RUnlock()</code></span>
<span class="codeline" id="line-1127"><code>	return c.skipped</code></span>
<span class="codeline" id="line-1128"><code>}</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>// Helper marks the calling function as a test helper function.</code></span>
<span class="codeline" id="line-1131"><code>// When printing file and line information, that function will be skipped.</code></span>
<span class="codeline" id="line-1132"><code>// Helper may be called simultaneously from multiple goroutines.</code></span>
<span class="codeline" id="line-1133"><code>func (c *common) Helper() {</code></span>
<span class="codeline" id="line-1134"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1135"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1136"><code>	if c.helperPCs == nil {</code></span>
<span class="codeline" id="line-1137"><code>		c.helperPCs = make(map[uintptr]struct{})</code></span>
<span class="codeline" id="line-1138"><code>	}</code></span>
<span class="codeline" id="line-1139"><code>	// repeating code from callerName here to save walking a stack frame</code></span>
<span class="codeline" id="line-1140"><code>	var pc [1]uintptr</code></span>
<span class="codeline" id="line-1141"><code>	n := runtime.Callers(2, pc[:]) // skip runtime.Callers + Helper</code></span>
<span class="codeline" id="line-1142"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1143"><code>		panic("testing: zero callers found")</code></span>
<span class="codeline" id="line-1144"><code>	}</code></span>
<span class="codeline" id="line-1145"><code>	if _, found := c.helperPCs[pc[0]]; !found {</code></span>
<span class="codeline" id="line-1146"><code>		c.helperPCs[pc[0]] = struct{}{}</code></span>
<span class="codeline" id="line-1147"><code>		c.helperNames = nil // map will be recreated next time it is needed</code></span>
<span class="codeline" id="line-1148"><code>	}</code></span>
<span class="codeline" id="line-1149"><code>}</code></span>
<span class="codeline" id="line-1150"><code></code></span>
<span class="codeline" id="line-1151"><code>// Cleanup registers a function to be called when the test (or subtest) and all its</code></span>
<span class="codeline" id="line-1152"><code>// subtests complete. Cleanup functions will be called in last added,</code></span>
<span class="codeline" id="line-1153"><code>// first called order.</code></span>
<span class="codeline" id="line-1154"><code>func (c *common) Cleanup(f func()) {</code></span>
<span class="codeline" id="line-1155"><code>	c.checkFuzzFn("Cleanup")</code></span>
<span class="codeline" id="line-1156"><code>	var pc [maxStackLen]uintptr</code></span>
<span class="codeline" id="line-1157"><code>	// Skip two extra frames to account for this function and runtime.Callers itself.</code></span>
<span class="codeline" id="line-1158"><code>	n := runtime.Callers(2, pc[:])</code></span>
<span class="codeline" id="line-1159"><code>	cleanupPc := pc[:n]</code></span>
<span class="codeline" id="line-1160"><code></code></span>
<span class="codeline" id="line-1161"><code>	fn := func() {</code></span>
<span class="codeline" id="line-1162"><code>		defer func() {</code></span>
<span class="codeline" id="line-1163"><code>			c.mu.Lock()</code></span>
<span class="codeline" id="line-1164"><code>			defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1165"><code>			c.cleanupName = ""</code></span>
<span class="codeline" id="line-1166"><code>			c.cleanupPc = nil</code></span>
<span class="codeline" id="line-1167"><code>		}()</code></span>
<span class="codeline" id="line-1168"><code></code></span>
<span class="codeline" id="line-1169"><code>		name := callerName(0)</code></span>
<span class="codeline" id="line-1170"><code>		c.mu.Lock()</code></span>
<span class="codeline" id="line-1171"><code>		c.cleanupName = name</code></span>
<span class="codeline" id="line-1172"><code>		c.cleanupPc = cleanupPc</code></span>
<span class="codeline" id="line-1173"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-1174"><code></code></span>
<span class="codeline" id="line-1175"><code>		f()</code></span>
<span class="codeline" id="line-1176"><code>	}</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1179"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1180"><code>	c.cleanups = append(c.cleanups, fn)</code></span>
<span class="codeline" id="line-1181"><code>}</code></span>
<span class="codeline" id="line-1182"><code></code></span>
<span class="codeline" id="line-1183"><code>// TempDir returns a temporary directory for the test to use.</code></span>
<span class="codeline" id="line-1184"><code>// The directory is automatically removed when the test and</code></span>
<span class="codeline" id="line-1185"><code>// all its subtests complete.</code></span>
<span class="codeline" id="line-1186"><code>// Each subsequent call to t.TempDir returns a unique directory;</code></span>
<span class="codeline" id="line-1187"><code>// if the directory creation fails, TempDir terminates the test by calling Fatal.</code></span>
<span class="codeline" id="line-1188"><code>func (c *common) TempDir() string {</code></span>
<span class="codeline" id="line-1189"><code>	c.checkFuzzFn("TempDir")</code></span>
<span class="codeline" id="line-1190"><code>	// Use a single parent directory for all the temporary directories</code></span>
<span class="codeline" id="line-1191"><code>	// created by a test, each numbered sequentially.</code></span>
<span class="codeline" id="line-1192"><code>	c.tempDirMu.Lock()</code></span>
<span class="codeline" id="line-1193"><code>	var nonExistent bool</code></span>
<span class="codeline" id="line-1194"><code>	if c.tempDir == "" { // Usually the case with js/wasm</code></span>
<span class="codeline" id="line-1195"><code>		nonExistent = true</code></span>
<span class="codeline" id="line-1196"><code>	} else {</code></span>
<span class="codeline" id="line-1197"><code>		_, err := os.Stat(c.tempDir)</code></span>
<span class="codeline" id="line-1198"><code>		nonExistent = os.IsNotExist(err)</code></span>
<span class="codeline" id="line-1199"><code>		if err != nil &amp;&amp; !nonExistent {</code></span>
<span class="codeline" id="line-1200"><code>			c.Fatalf("TempDir: %v", err)</code></span>
<span class="codeline" id="line-1201"><code>		}</code></span>
<span class="codeline" id="line-1202"><code>	}</code></span>
<span class="codeline" id="line-1203"><code></code></span>
<span class="codeline" id="line-1204"><code>	if nonExistent {</code></span>
<span class="codeline" id="line-1205"><code>		c.Helper()</code></span>
<span class="codeline" id="line-1206"><code></code></span>
<span class="codeline" id="line-1207"><code>		// Drop unusual characters (such as path separators or</code></span>
<span class="codeline" id="line-1208"><code>		// characters interacting with globs) from the directory name to</code></span>
<span class="codeline" id="line-1209"><code>		// avoid surprising os.MkdirTemp behavior.</code></span>
<span class="codeline" id="line-1210"><code>		mapper := func(r rune) rune {</code></span>
<span class="codeline" id="line-1211"><code>			if r &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1212"><code>				const allowed = "!#$%&amp;()+,-.=@^_{}~ "</code></span>
<span class="codeline" id="line-1213"><code>				if '0' &lt;= r &amp;&amp; r &lt;= '9' ||</code></span>
<span class="codeline" id="line-1214"><code>					'a' &lt;= r &amp;&amp; r &lt;= 'z' ||</code></span>
<span class="codeline" id="line-1215"><code>					'A' &lt;= r &amp;&amp; r &lt;= 'Z' {</code></span>
<span class="codeline" id="line-1216"><code>					return r</code></span>
<span class="codeline" id="line-1217"><code>				}</code></span>
<span class="codeline" id="line-1218"><code>				if strings.ContainsRune(allowed, r) {</code></span>
<span class="codeline" id="line-1219"><code>					return r</code></span>
<span class="codeline" id="line-1220"><code>				}</code></span>
<span class="codeline" id="line-1221"><code>			} else if unicode.IsLetter(r) || unicode.IsNumber(r) {</code></span>
<span class="codeline" id="line-1222"><code>				return r</code></span>
<span class="codeline" id="line-1223"><code>			}</code></span>
<span class="codeline" id="line-1224"><code>			return -1</code></span>
<span class="codeline" id="line-1225"><code>		}</code></span>
<span class="codeline" id="line-1226"><code>		pattern := strings.Map(mapper, c.Name())</code></span>
<span class="codeline" id="line-1227"><code>		c.tempDir, c.tempDirErr = os.MkdirTemp("", pattern)</code></span>
<span class="codeline" id="line-1228"><code>		if c.tempDirErr == nil {</code></span>
<span class="codeline" id="line-1229"><code>			c.Cleanup(func() {</code></span>
<span class="codeline" id="line-1230"><code>				if err := removeAll(c.tempDir); err != nil {</code></span>
<span class="codeline" id="line-1231"><code>					c.Errorf("TempDir RemoveAll cleanup: %v", err)</code></span>
<span class="codeline" id="line-1232"><code>				}</code></span>
<span class="codeline" id="line-1233"><code>			})</code></span>
<span class="codeline" id="line-1234"><code>		}</code></span>
<span class="codeline" id="line-1235"><code>	}</code></span>
<span class="codeline" id="line-1236"><code></code></span>
<span class="codeline" id="line-1237"><code>	if c.tempDirErr == nil {</code></span>
<span class="codeline" id="line-1238"><code>		c.tempDirSeq++</code></span>
<span class="codeline" id="line-1239"><code>	}</code></span>
<span class="codeline" id="line-1240"><code>	seq := c.tempDirSeq</code></span>
<span class="codeline" id="line-1241"><code>	c.tempDirMu.Unlock()</code></span>
<span class="codeline" id="line-1242"><code></code></span>
<span class="codeline" id="line-1243"><code>	if c.tempDirErr != nil {</code></span>
<span class="codeline" id="line-1244"><code>		c.Fatalf("TempDir: %v", c.tempDirErr)</code></span>
<span class="codeline" id="line-1245"><code>	}</code></span>
<span class="codeline" id="line-1246"><code></code></span>
<span class="codeline" id="line-1247"><code>	dir := fmt.Sprintf("%s%c%03d", c.tempDir, os.PathSeparator, seq)</code></span>
<span class="codeline" id="line-1248"><code>	if err := os.Mkdir(dir, 0777); err != nil {</code></span>
<span class="codeline" id="line-1249"><code>		c.Fatalf("TempDir: %v", err)</code></span>
<span class="codeline" id="line-1250"><code>	}</code></span>
<span class="codeline" id="line-1251"><code>	return dir</code></span>
<span class="codeline" id="line-1252"><code>}</code></span>
<span class="codeline" id="line-1253"><code></code></span>
<span class="codeline" id="line-1254"><code>// removeAll is like os.RemoveAll, but retries Windows "Access is denied."</code></span>
<span class="codeline" id="line-1255"><code>// errors up to an arbitrary timeout.</code></span>
<span class="codeline" id="line-1256"><code>//</code></span>
<span class="codeline" id="line-1257"><code>// Those errors have been known to occur spuriously on at least the</code></span>
<span class="codeline" id="line-1258"><code>// windows-amd64-2012 builder (https://go.dev/issue/50051), and can only occur</code></span>
<span class="codeline" id="line-1259"><code>// legitimately if the test leaves behind a temp file that either is still open</code></span>
<span class="codeline" id="line-1260"><code>// or the test otherwise lacks permission to delete. In the case of legitimate</code></span>
<span class="codeline" id="line-1261"><code>// failures, a failing test may take a bit longer to fail, but once the test is</code></span>
<span class="codeline" id="line-1262"><code>// fixed the extra latency will go away.</code></span>
<span class="codeline" id="line-1263"><code>func removeAll(path string) error {</code></span>
<span class="codeline" id="line-1264"><code>	const arbitraryTimeout = 2 * time.Second</code></span>
<span class="codeline" id="line-1265"><code>	var (</code></span>
<span class="codeline" id="line-1266"><code>		start     time.Time</code></span>
<span class="codeline" id="line-1267"><code>		nextSleep = 1 * time.Millisecond</code></span>
<span class="codeline" id="line-1268"><code>	)</code></span>
<span class="codeline" id="line-1269"><code>	for {</code></span>
<span class="codeline" id="line-1270"><code>		err := os.RemoveAll(path)</code></span>
<span class="codeline" id="line-1271"><code>		if !isWindowsRetryable(err) {</code></span>
<span class="codeline" id="line-1272"><code>			return err</code></span>
<span class="codeline" id="line-1273"><code>		}</code></span>
<span class="codeline" id="line-1274"><code>		if start.IsZero() {</code></span>
<span class="codeline" id="line-1275"><code>			start = time.Now()</code></span>
<span class="codeline" id="line-1276"><code>		} else if d := time.Since(start) + nextSleep; d &gt;= arbitraryTimeout {</code></span>
<span class="codeline" id="line-1277"><code>			return err</code></span>
<span class="codeline" id="line-1278"><code>		}</code></span>
<span class="codeline" id="line-1279"><code>		time.Sleep(nextSleep)</code></span>
<span class="codeline" id="line-1280"><code>		nextSleep += time.Duration(rand.Int63n(int64(nextSleep)))</code></span>
<span class="codeline" id="line-1281"><code>	}</code></span>
<span class="codeline" id="line-1282"><code>}</code></span>
<span class="codeline" id="line-1283"><code></code></span>
<span class="codeline" id="line-1284"><code>// Setenv calls os.Setenv(key, value) and uses Cleanup to</code></span>
<span class="codeline" id="line-1285"><code>// restore the environment variable to its original value</code></span>
<span class="codeline" id="line-1286"><code>// after the test.</code></span>
<span class="codeline" id="line-1287"><code>//</code></span>
<span class="codeline" id="line-1288"><code>// Because Setenv affects the whole process, it cannot be used</code></span>
<span class="codeline" id="line-1289"><code>// in parallel tests or tests with parallel ancestors.</code></span>
<span class="codeline" id="line-1290"><code>func (c *common) Setenv(key, value string) {</code></span>
<span class="codeline" id="line-1291"><code>	c.checkFuzzFn("Setenv")</code></span>
<span class="codeline" id="line-1292"><code>	prevValue, ok := os.LookupEnv(key)</code></span>
<span class="codeline" id="line-1293"><code></code></span>
<span class="codeline" id="line-1294"><code>	if err := os.Setenv(key, value); err != nil {</code></span>
<span class="codeline" id="line-1295"><code>		c.Fatalf("cannot set environment variable: %v", err)</code></span>
<span class="codeline" id="line-1296"><code>	}</code></span>
<span class="codeline" id="line-1297"><code></code></span>
<span class="codeline" id="line-1298"><code>	if ok {</code></span>
<span class="codeline" id="line-1299"><code>		c.Cleanup(func() {</code></span>
<span class="codeline" id="line-1300"><code>			os.Setenv(key, prevValue)</code></span>
<span class="codeline" id="line-1301"><code>		})</code></span>
<span class="codeline" id="line-1302"><code>	} else {</code></span>
<span class="codeline" id="line-1303"><code>		c.Cleanup(func() {</code></span>
<span class="codeline" id="line-1304"><code>			os.Unsetenv(key)</code></span>
<span class="codeline" id="line-1305"><code>		})</code></span>
<span class="codeline" id="line-1306"><code>	}</code></span>
<span class="codeline" id="line-1307"><code>}</code></span>
<span class="codeline" id="line-1308"><code></code></span>
<span class="codeline" id="line-1309"><code>// panicHanding controls the panic handling used by runCleanup.</code></span>
<span class="codeline" id="line-1310"><code>type panicHandling int</code></span>
<span class="codeline" id="line-1311"><code></code></span>
<span class="codeline" id="line-1312"><code>const (</code></span>
<span class="codeline" id="line-1313"><code>	normalPanic panicHandling = iota</code></span>
<span class="codeline" id="line-1314"><code>	recoverAndReturnPanic</code></span>
<span class="codeline" id="line-1315"><code>)</code></span>
<span class="codeline" id="line-1316"><code></code></span>
<span class="codeline" id="line-1317"><code>// runCleanup is called at the end of the test.</code></span>
<span class="codeline" id="line-1318"><code>// If ph is recoverAndReturnPanic, it will catch panics, and return the</code></span>
<span class="codeline" id="line-1319"><code>// recovered value if any.</code></span>
<span class="codeline" id="line-1320"><code>func (c *common) runCleanup(ph panicHandling) (panicVal any) {</code></span>
<span class="codeline" id="line-1321"><code>	c.cleanupStarted.Store(true)</code></span>
<span class="codeline" id="line-1322"><code>	defer c.cleanupStarted.Store(false)</code></span>
<span class="codeline" id="line-1323"><code></code></span>
<span class="codeline" id="line-1324"><code>	if ph == recoverAndReturnPanic {</code></span>
<span class="codeline" id="line-1325"><code>		defer func() {</code></span>
<span class="codeline" id="line-1326"><code>			panicVal = recover()</code></span>
<span class="codeline" id="line-1327"><code>		}()</code></span>
<span class="codeline" id="line-1328"><code>	}</code></span>
<span class="codeline" id="line-1329"><code></code></span>
<span class="codeline" id="line-1330"><code>	// Make sure that if a cleanup function panics,</code></span>
<span class="codeline" id="line-1331"><code>	// we still run the remaining cleanup functions.</code></span>
<span class="codeline" id="line-1332"><code>	defer func() {</code></span>
<span class="codeline" id="line-1333"><code>		c.mu.Lock()</code></span>
<span class="codeline" id="line-1334"><code>		recur := len(c.cleanups) &gt; 0</code></span>
<span class="codeline" id="line-1335"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-1336"><code>		if recur {</code></span>
<span class="codeline" id="line-1337"><code>			c.runCleanup(normalPanic)</code></span>
<span class="codeline" id="line-1338"><code>		}</code></span>
<span class="codeline" id="line-1339"><code>	}()</code></span>
<span class="codeline" id="line-1340"><code></code></span>
<span class="codeline" id="line-1341"><code>	for {</code></span>
<span class="codeline" id="line-1342"><code>		var cleanup func()</code></span>
<span class="codeline" id="line-1343"><code>		c.mu.Lock()</code></span>
<span class="codeline" id="line-1344"><code>		if len(c.cleanups) &gt; 0 {</code></span>
<span class="codeline" id="line-1345"><code>			last := len(c.cleanups) - 1</code></span>
<span class="codeline" id="line-1346"><code>			cleanup = c.cleanups[last]</code></span>
<span class="codeline" id="line-1347"><code>			c.cleanups = c.cleanups[:last]</code></span>
<span class="codeline" id="line-1348"><code>		}</code></span>
<span class="codeline" id="line-1349"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-1350"><code>		if cleanup == nil {</code></span>
<span class="codeline" id="line-1351"><code>			return nil</code></span>
<span class="codeline" id="line-1352"><code>		}</code></span>
<span class="codeline" id="line-1353"><code>		cleanup()</code></span>
<span class="codeline" id="line-1354"><code>	}</code></span>
<span class="codeline" id="line-1355"><code>}</code></span>
<span class="codeline" id="line-1356"><code></code></span>
<span class="codeline" id="line-1357"><code>// resetRaces updates c.parent's count of data race errors (or the global count,</code></span>
<span class="codeline" id="line-1358"><code>// if c has no parent), and updates c.lastRaceErrors to match.</code></span>
<span class="codeline" id="line-1359"><code>//</code></span>
<span class="codeline" id="line-1360"><code>// Any races that occurred prior to this call to resetRaces will</code></span>
<span class="codeline" id="line-1361"><code>// not be attributed to c.</code></span>
<span class="codeline" id="line-1362"><code>func (c *common) resetRaces() {</code></span>
<span class="codeline" id="line-1363"><code>	if c.parent == nil {</code></span>
<span class="codeline" id="line-1364"><code>		c.lastRaceErrors.Store(int64(race.Errors()))</code></span>
<span class="codeline" id="line-1365"><code>	} else {</code></span>
<span class="codeline" id="line-1366"><code>		c.lastRaceErrors.Store(c.parent.checkRaces())</code></span>
<span class="codeline" id="line-1367"><code>	}</code></span>
<span class="codeline" id="line-1368"><code>}</code></span>
<span class="codeline" id="line-1369"><code></code></span>
<span class="codeline" id="line-1370"><code>// checkRaces checks whether the global count of data race errors has increased</code></span>
<span class="codeline" id="line-1371"><code>// since c's count was last reset.</code></span>
<span class="codeline" id="line-1372"><code>//</code></span>
<span class="codeline" id="line-1373"><code>// If so, it marks c as having failed due to those races (logging an error for</code></span>
<span class="codeline" id="line-1374"><code>// the first such race), and updates the race counts for the parents of c so</code></span>
<span class="codeline" id="line-1375"><code>// that if they are currently suspended (such as in a call to T.Run) they will</code></span>
<span class="codeline" id="line-1376"><code>// not log separate errors for the race(s).</code></span>
<span class="codeline" id="line-1377"><code>//</code></span>
<span class="codeline" id="line-1378"><code>// Note that multiple tests may be marked as failed due to the same race if they</code></span>
<span class="codeline" id="line-1379"><code>// are executing in parallel.</code></span>
<span class="codeline" id="line-1380"><code>func (c *common) checkRaces() (raceErrors int64) {</code></span>
<span class="codeline" id="line-1381"><code>	raceErrors = int64(race.Errors())</code></span>
<span class="codeline" id="line-1382"><code>	for {</code></span>
<span class="codeline" id="line-1383"><code>		last := c.lastRaceErrors.Load()</code></span>
<span class="codeline" id="line-1384"><code>		if raceErrors &lt;= last {</code></span>
<span class="codeline" id="line-1385"><code>			// All races have already been reported.</code></span>
<span class="codeline" id="line-1386"><code>			return raceErrors</code></span>
<span class="codeline" id="line-1387"><code>		}</code></span>
<span class="codeline" id="line-1388"><code>		if c.lastRaceErrors.CompareAndSwap(last, raceErrors) {</code></span>
<span class="codeline" id="line-1389"><code>			break</code></span>
<span class="codeline" id="line-1390"><code>		}</code></span>
<span class="codeline" id="line-1391"><code>	}</code></span>
<span class="codeline" id="line-1392"><code></code></span>
<span class="codeline" id="line-1393"><code>	if c.raceErrorLogged.CompareAndSwap(false, true) {</code></span>
<span class="codeline" id="line-1394"><code>		// This is the first race we've encountered for this test.</code></span>
<span class="codeline" id="line-1395"><code>		// Mark the test as failed, and log the reason why only once.</code></span>
<span class="codeline" id="line-1396"><code>		// (Note that the race detector itself will still write a goroutine</code></span>
<span class="codeline" id="line-1397"><code>		// dump for any further races it detects.)</code></span>
<span class="codeline" id="line-1398"><code>		c.Errorf("race detected during execution of test")</code></span>
<span class="codeline" id="line-1399"><code>	}</code></span>
<span class="codeline" id="line-1400"><code></code></span>
<span class="codeline" id="line-1401"><code>	// Update the parent(s) of this test so that they don't re-report the race.</code></span>
<span class="codeline" id="line-1402"><code>	parent := c.parent</code></span>
<span class="codeline" id="line-1403"><code>	for parent != nil {</code></span>
<span class="codeline" id="line-1404"><code>		for {</code></span>
<span class="codeline" id="line-1405"><code>			last := parent.lastRaceErrors.Load()</code></span>
<span class="codeline" id="line-1406"><code>			if raceErrors &lt;= last {</code></span>
<span class="codeline" id="line-1407"><code>				// This race was already reported by another (likely parallel) subtest.</code></span>
<span class="codeline" id="line-1408"><code>				return raceErrors</code></span>
<span class="codeline" id="line-1409"><code>			}</code></span>
<span class="codeline" id="line-1410"><code>			if parent.lastRaceErrors.CompareAndSwap(last, raceErrors) {</code></span>
<span class="codeline" id="line-1411"><code>				break</code></span>
<span class="codeline" id="line-1412"><code>			}</code></span>
<span class="codeline" id="line-1413"><code>		}</code></span>
<span class="codeline" id="line-1414"><code>		parent = parent.parent</code></span>
<span class="codeline" id="line-1415"><code>	}</code></span>
<span class="codeline" id="line-1416"><code></code></span>
<span class="codeline" id="line-1417"><code>	return raceErrors</code></span>
<span class="codeline" id="line-1418"><code>}</code></span>
<span class="codeline" id="line-1419"><code></code></span>
<span class="codeline" id="line-1420"><code>// callerName gives the function name (qualified with a package path)</code></span>
<span class="codeline" id="line-1421"><code>// for the caller after skip frames (where 0 means the current function).</code></span>
<span class="codeline" id="line-1422"><code>func callerName(skip int) string {</code></span>
<span class="codeline" id="line-1423"><code>	var pc [1]uintptr</code></span>
<span class="codeline" id="line-1424"><code>	n := runtime.Callers(skip+2, pc[:]) // skip + runtime.Callers + callerName</code></span>
<span class="codeline" id="line-1425"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1426"><code>		panic("testing: zero callers found")</code></span>
<span class="codeline" id="line-1427"><code>	}</code></span>
<span class="codeline" id="line-1428"><code>	return pcToName(pc[0])</code></span>
<span class="codeline" id="line-1429"><code>}</code></span>
<span class="codeline" id="line-1430"><code></code></span>
<span class="codeline" id="line-1431"><code>func pcToName(pc uintptr) string {</code></span>
<span class="codeline" id="line-1432"><code>	pcs := []uintptr{pc}</code></span>
<span class="codeline" id="line-1433"><code>	frames := runtime.CallersFrames(pcs)</code></span>
<span class="codeline" id="line-1434"><code>	frame, _ := frames.Next()</code></span>
<span class="codeline" id="line-1435"><code>	return frame.Function</code></span>
<span class="codeline" id="line-1436"><code>}</code></span>
<span class="codeline" id="line-1437"><code></code></span>
<span class="codeline" id="line-1438"><code>// Parallel signals that this test is to be run in parallel with (and only with)</code></span>
<span class="codeline" id="line-1439"><code>// other parallel tests. When a test is run multiple times due to use of</code></span>
<span class="codeline" id="line-1440"><code>// -test.count or -test.cpu, multiple instances of a single test never run in</code></span>
<span class="codeline" id="line-1441"><code>// parallel with each other.</code></span>
<span class="codeline" id="line-1442"><code>func (t *T) Parallel() {</code></span>
<span class="codeline" id="line-1443"><code>	if t.isParallel {</code></span>
<span class="codeline" id="line-1444"><code>		panic("testing: t.Parallel called multiple times")</code></span>
<span class="codeline" id="line-1445"><code>	}</code></span>
<span class="codeline" id="line-1446"><code>	if t.isEnvSet {</code></span>
<span class="codeline" id="line-1447"><code>		panic("testing: t.Parallel called after t.Setenv; cannot set environment variables in parallel tests")</code></span>
<span class="codeline" id="line-1448"><code>	}</code></span>
<span class="codeline" id="line-1449"><code>	t.isParallel = true</code></span>
<span class="codeline" id="line-1450"><code>	if t.parent.barrier == nil {</code></span>
<span class="codeline" id="line-1451"><code>		// T.Parallel has no effect when fuzzing.</code></span>
<span class="codeline" id="line-1452"><code>		// Multiple processes may run in parallel, but only one input can run at a</code></span>
<span class="codeline" id="line-1453"><code>		// time per process so we can attribute crashes to specific inputs.</code></span>
<span class="codeline" id="line-1454"><code>		return</code></span>
<span class="codeline" id="line-1455"><code>	}</code></span>
<span class="codeline" id="line-1456"><code></code></span>
<span class="codeline" id="line-1457"><code>	// We don't want to include the time we spend waiting for serial tests</code></span>
<span class="codeline" id="line-1458"><code>	// in the test duration. Record the elapsed time thus far and reset the</code></span>
<span class="codeline" id="line-1459"><code>	// timer afterwards.</code></span>
<span class="codeline" id="line-1460"><code>	t.duration += time.Since(t.start)</code></span>
<span class="codeline" id="line-1461"><code></code></span>
<span class="codeline" id="line-1462"><code>	// Add to the list of tests to be released by the parent.</code></span>
<span class="codeline" id="line-1463"><code>	t.parent.sub = append(t.parent.sub, t)</code></span>
<span class="codeline" id="line-1464"><code></code></span>
<span class="codeline" id="line-1465"><code>	// Report any races during execution of this test up to this point.</code></span>
<span class="codeline" id="line-1466"><code>	//</code></span>
<span class="codeline" id="line-1467"><code>	// We will assume that any races that occur between here and the point where</code></span>
<span class="codeline" id="line-1468"><code>	// we unblock are not caused by this subtest. That assumption usually holds,</code></span>
<span class="codeline" id="line-1469"><code>	// although it can be wrong if the test spawns a goroutine that races in the</code></span>
<span class="codeline" id="line-1470"><code>	// background while the rest of the test is blocked on the call to Parallel.</code></span>
<span class="codeline" id="line-1471"><code>	// If that happens, we will misattribute the background race to some other</code></span>
<span class="codeline" id="line-1472"><code>	// test, or to no test at all — but that false-negative is so unlikely that it</code></span>
<span class="codeline" id="line-1473"><code>	// is not worth adding race-report noise for the common case where the test is</code></span>
<span class="codeline" id="line-1474"><code>	// completely suspended during the call to Parallel.</code></span>
<span class="codeline" id="line-1475"><code>	t.checkRaces()</code></span>
<span class="codeline" id="line-1476"><code></code></span>
<span class="codeline" id="line-1477"><code>	if t.chatty != nil {</code></span>
<span class="codeline" id="line-1478"><code>		t.chatty.Updatef(t.name, "=== PAUSE %s\n", t.name)</code></span>
<span class="codeline" id="line-1479"><code>	}</code></span>
<span class="codeline" id="line-1480"><code>	running.Delete(t.name)</code></span>
<span class="codeline" id="line-1481"><code></code></span>
<span class="codeline" id="line-1482"><code>	t.signal &lt;- true   // Release calling test.</code></span>
<span class="codeline" id="line-1483"><code>	&lt;-t.parent.barrier // Wait for the parent test to complete.</code></span>
<span class="codeline" id="line-1484"><code>	t.context.waitParallel()</code></span>
<span class="codeline" id="line-1485"><code></code></span>
<span class="codeline" id="line-1486"><code>	if t.chatty != nil {</code></span>
<span class="codeline" id="line-1487"><code>		t.chatty.Updatef(t.name, "=== CONT  %s\n", t.name)</code></span>
<span class="codeline" id="line-1488"><code>	}</code></span>
<span class="codeline" id="line-1489"><code>	running.Store(t.name, time.Now())</code></span>
<span class="codeline" id="line-1490"><code>	t.start = time.Now()</code></span>
<span class="codeline" id="line-1491"><code></code></span>
<span class="codeline" id="line-1492"><code>	// Reset the local race counter to ignore any races that happened while this</code></span>
<span class="codeline" id="line-1493"><code>	// goroutine was blocked, such as in the parent test or in other parallel</code></span>
<span class="codeline" id="line-1494"><code>	// subtests.</code></span>
<span class="codeline" id="line-1495"><code>	//</code></span>
<span class="codeline" id="line-1496"><code>	// (Note that we don't call parent.checkRaces here:</code></span>
<span class="codeline" id="line-1497"><code>	// if other parallel subtests have already introduced races, we want to</code></span>
<span class="codeline" id="line-1498"><code>	// let them report those races instead of attributing them to the parent.)</code></span>
<span class="codeline" id="line-1499"><code>	t.lastRaceErrors.Store(int64(race.Errors()))</code></span>
<span class="codeline" id="line-1500"><code>}</code></span>
<span class="codeline" id="line-1501"><code></code></span>
<span class="codeline" id="line-1502"><code>// Setenv calls os.Setenv(key, value) and uses Cleanup to</code></span>
<span class="codeline" id="line-1503"><code>// restore the environment variable to its original value</code></span>
<span class="codeline" id="line-1504"><code>// after the test.</code></span>
<span class="codeline" id="line-1505"><code>//</code></span>
<span class="codeline" id="line-1506"><code>// Because Setenv affects the whole process, it cannot be used</code></span>
<span class="codeline" id="line-1507"><code>// in parallel tests or tests with parallel ancestors.</code></span>
<span class="codeline" id="line-1508"><code>func (t *T) Setenv(key, value string) {</code></span>
<span class="codeline" id="line-1509"><code>	// Non-parallel subtests that have parallel ancestors may still</code></span>
<span class="codeline" id="line-1510"><code>	// run in parallel with other tests: they are only non-parallel</code></span>
<span class="codeline" id="line-1511"><code>	// with respect to the other subtests of the same parent.</code></span>
<span class="codeline" id="line-1512"><code>	// Since SetEnv affects the whole process, we need to disallow it</code></span>
<span class="codeline" id="line-1513"><code>	// if the current test or any parent is parallel.</code></span>
<span class="codeline" id="line-1514"><code>	isParallel := false</code></span>
<span class="codeline" id="line-1515"><code>	for c := &amp;t.common; c != nil; c = c.parent {</code></span>
<span class="codeline" id="line-1516"><code>		if c.isParallel {</code></span>
<span class="codeline" id="line-1517"><code>			isParallel = true</code></span>
<span class="codeline" id="line-1518"><code>			break</code></span>
<span class="codeline" id="line-1519"><code>		}</code></span>
<span class="codeline" id="line-1520"><code>	}</code></span>
<span class="codeline" id="line-1521"><code>	if isParallel {</code></span>
<span class="codeline" id="line-1522"><code>		panic("testing: t.Setenv called after t.Parallel; cannot set environment variables in parallel tests")</code></span>
<span class="codeline" id="line-1523"><code>	}</code></span>
<span class="codeline" id="line-1524"><code></code></span>
<span class="codeline" id="line-1525"><code>	t.isEnvSet = true</code></span>
<span class="codeline" id="line-1526"><code></code></span>
<span class="codeline" id="line-1527"><code>	t.common.Setenv(key, value)</code></span>
<span class="codeline" id="line-1528"><code>}</code></span>
<span class="codeline" id="line-1529"><code></code></span>
<span class="codeline" id="line-1530"><code>// InternalTest is an internal type but exported because it is cross-package;</code></span>
<span class="codeline" id="line-1531"><code>// it is part of the implementation of the "go test" command.</code></span>
<span class="codeline" id="line-1532"><code>type InternalTest struct {</code></span>
<span class="codeline" id="line-1533"><code>	Name string</code></span>
<span class="codeline" id="line-1534"><code>	F    func(*T)</code></span>
<span class="codeline" id="line-1535"><code>}</code></span>
<span class="codeline" id="line-1536"><code></code></span>
<span class="codeline" id="line-1537"><code>var errNilPanicOrGoexit = errors.New("test executed panic(nil) or runtime.Goexit")</code></span>
<span class="codeline" id="line-1538"><code></code></span>
<span class="codeline" id="line-1539"><code>func tRunner(t *T, fn func(t *T)) {</code></span>
<span class="codeline" id="line-1540"><code>	t.runner = callerName(0)</code></span>
<span class="codeline" id="line-1541"><code></code></span>
<span class="codeline" id="line-1542"><code>	// When this goroutine is done, either because fn(t)</code></span>
<span class="codeline" id="line-1543"><code>	// returned normally or because a test failure triggered</code></span>
<span class="codeline" id="line-1544"><code>	// a call to runtime.Goexit, record the duration and send</code></span>
<span class="codeline" id="line-1545"><code>	// a signal saying that the test is done.</code></span>
<span class="codeline" id="line-1546"><code>	defer func() {</code></span>
<span class="codeline" id="line-1547"><code>		t.checkRaces()</code></span>
<span class="codeline" id="line-1548"><code></code></span>
<span class="codeline" id="line-1549"><code>		// TODO(#61034): This is the wrong place for this check.</code></span>
<span class="codeline" id="line-1550"><code>		if t.Failed() {</code></span>
<span class="codeline" id="line-1551"><code>			numFailed.Add(1)</code></span>
<span class="codeline" id="line-1552"><code>		}</code></span>
<span class="codeline" id="line-1553"><code></code></span>
<span class="codeline" id="line-1554"><code>		// Check if the test panicked or Goexited inappropriately.</code></span>
<span class="codeline" id="line-1555"><code>		//</code></span>
<span class="codeline" id="line-1556"><code>		// If this happens in a normal test, print output but continue panicking.</code></span>
<span class="codeline" id="line-1557"><code>		// tRunner is called in its own goroutine, so this terminates the process.</code></span>
<span class="codeline" id="line-1558"><code>		//</code></span>
<span class="codeline" id="line-1559"><code>		// If this happens while fuzzing, recover from the panic and treat it like a</code></span>
<span class="codeline" id="line-1560"><code>		// normal failure. It's important that the process keeps running in order to</code></span>
<span class="codeline" id="line-1561"><code>		// find short inputs that cause panics.</code></span>
<span class="codeline" id="line-1562"><code>		err := recover()</code></span>
<span class="codeline" id="line-1563"><code>		signal := true</code></span>
<span class="codeline" id="line-1564"><code></code></span>
<span class="codeline" id="line-1565"><code>		t.mu.RLock()</code></span>
<span class="codeline" id="line-1566"><code>		finished := t.finished</code></span>
<span class="codeline" id="line-1567"><code>		t.mu.RUnlock()</code></span>
<span class="codeline" id="line-1568"><code>		if !finished &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-1569"><code>			err = errNilPanicOrGoexit</code></span>
<span class="codeline" id="line-1570"><code>			for p := t.parent; p != nil; p = p.parent {</code></span>
<span class="codeline" id="line-1571"><code>				p.mu.RLock()</code></span>
<span class="codeline" id="line-1572"><code>				finished = p.finished</code></span>
<span class="codeline" id="line-1573"><code>				p.mu.RUnlock()</code></span>
<span class="codeline" id="line-1574"><code>				if finished {</code></span>
<span class="codeline" id="line-1575"><code>					if !t.isParallel {</code></span>
<span class="codeline" id="line-1576"><code>						t.Errorf("%v: subtest may have called FailNow on a parent test", err)</code></span>
<span class="codeline" id="line-1577"><code>						err = nil</code></span>
<span class="codeline" id="line-1578"><code>					}</code></span>
<span class="codeline" id="line-1579"><code>					signal = false</code></span>
<span class="codeline" id="line-1580"><code>					break</code></span>
<span class="codeline" id="line-1581"><code>				}</code></span>
<span class="codeline" id="line-1582"><code>			}</code></span>
<span class="codeline" id="line-1583"><code>		}</code></span>
<span class="codeline" id="line-1584"><code></code></span>
<span class="codeline" id="line-1585"><code>		if err != nil &amp;&amp; t.context.isFuzzing {</code></span>
<span class="codeline" id="line-1586"><code>			prefix := "panic: "</code></span>
<span class="codeline" id="line-1587"><code>			if err == errNilPanicOrGoexit {</code></span>
<span class="codeline" id="line-1588"><code>				prefix = ""</code></span>
<span class="codeline" id="line-1589"><code>			}</code></span>
<span class="codeline" id="line-1590"><code>			t.Errorf("%s%s\n%s\n", prefix, err, string(debug.Stack()))</code></span>
<span class="codeline" id="line-1591"><code>			t.mu.Lock()</code></span>
<span class="codeline" id="line-1592"><code>			t.finished = true</code></span>
<span class="codeline" id="line-1593"><code>			t.mu.Unlock()</code></span>
<span class="codeline" id="line-1594"><code>			err = nil</code></span>
<span class="codeline" id="line-1595"><code>		}</code></span>
<span class="codeline" id="line-1596"><code></code></span>
<span class="codeline" id="line-1597"><code>		// Use a deferred call to ensure that we report that the test is</code></span>
<span class="codeline" id="line-1598"><code>		// complete even if a cleanup function calls t.FailNow. See issue 41355.</code></span>
<span class="codeline" id="line-1599"><code>		didPanic := false</code></span>
<span class="codeline" id="line-1600"><code>		defer func() {</code></span>
<span class="codeline" id="line-1601"><code>			// Only report that the test is complete if it doesn't panic,</code></span>
<span class="codeline" id="line-1602"><code>			// as otherwise the test binary can exit before the panic is</code></span>
<span class="codeline" id="line-1603"><code>			// reported to the user. See issue 41479.</code></span>
<span class="codeline" id="line-1604"><code>			if didPanic {</code></span>
<span class="codeline" id="line-1605"><code>				return</code></span>
<span class="codeline" id="line-1606"><code>			}</code></span>
<span class="codeline" id="line-1607"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1608"><code>				panic(err)</code></span>
<span class="codeline" id="line-1609"><code>			}</code></span>
<span class="codeline" id="line-1610"><code>			running.Delete(t.name)</code></span>
<span class="codeline" id="line-1611"><code>			t.signal &lt;- signal</code></span>
<span class="codeline" id="line-1612"><code>		}()</code></span>
<span class="codeline" id="line-1613"><code></code></span>
<span class="codeline" id="line-1614"><code>		doPanic := func(err any) {</code></span>
<span class="codeline" id="line-1615"><code>			t.Fail()</code></span>
<span class="codeline" id="line-1616"><code>			if r := t.runCleanup(recoverAndReturnPanic); r != nil {</code></span>
<span class="codeline" id="line-1617"><code>				t.Logf("cleanup panicked with %v", r)</code></span>
<span class="codeline" id="line-1618"><code>			}</code></span>
<span class="codeline" id="line-1619"><code>			// Flush the output log up to the root before dying.</code></span>
<span class="codeline" id="line-1620"><code>			for root := &amp;t.common; root.parent != nil; root = root.parent {</code></span>
<span class="codeline" id="line-1621"><code>				root.mu.Lock()</code></span>
<span class="codeline" id="line-1622"><code>				root.duration += time.Since(root.start)</code></span>
<span class="codeline" id="line-1623"><code>				d := root.duration</code></span>
<span class="codeline" id="line-1624"><code>				root.mu.Unlock()</code></span>
<span class="codeline" id="line-1625"><code>				root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))</code></span>
<span class="codeline" id="line-1626"><code>				if r := root.parent.runCleanup(recoverAndReturnPanic); r != nil {</code></span>
<span class="codeline" id="line-1627"><code>					fmt.Fprintf(root.parent.w, "cleanup panicked with %v", r)</code></span>
<span class="codeline" id="line-1628"><code>				}</code></span>
<span class="codeline" id="line-1629"><code>			}</code></span>
<span class="codeline" id="line-1630"><code>			didPanic = true</code></span>
<span class="codeline" id="line-1631"><code>			panic(err)</code></span>
<span class="codeline" id="line-1632"><code>		}</code></span>
<span class="codeline" id="line-1633"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1634"><code>			doPanic(err)</code></span>
<span class="codeline" id="line-1635"><code>		}</code></span>
<span class="codeline" id="line-1636"><code></code></span>
<span class="codeline" id="line-1637"><code>		t.duration += time.Since(t.start)</code></span>
<span class="codeline" id="line-1638"><code></code></span>
<span class="codeline" id="line-1639"><code>		if len(t.sub) &gt; 0 {</code></span>
<span class="codeline" id="line-1640"><code>			// Run parallel subtests.</code></span>
<span class="codeline" id="line-1641"><code></code></span>
<span class="codeline" id="line-1642"><code>			// Decrease the running count for this test and mark it as no longer running.</code></span>
<span class="codeline" id="line-1643"><code>			t.context.release()</code></span>
<span class="codeline" id="line-1644"><code>			running.Delete(t.name)</code></span>
<span class="codeline" id="line-1645"><code></code></span>
<span class="codeline" id="line-1646"><code>			// Release the parallel subtests.</code></span>
<span class="codeline" id="line-1647"><code>			close(t.barrier)</code></span>
<span class="codeline" id="line-1648"><code>			// Wait for subtests to complete.</code></span>
<span class="codeline" id="line-1649"><code>			for _, sub := range t.sub {</code></span>
<span class="codeline" id="line-1650"><code>				&lt;-sub.signal</code></span>
<span class="codeline" id="line-1651"><code>			}</code></span>
<span class="codeline" id="line-1652"><code></code></span>
<span class="codeline" id="line-1653"><code>			// Run any cleanup callbacks, marking the test as running</code></span>
<span class="codeline" id="line-1654"><code>			// in case the cleanup hangs.</code></span>
<span class="codeline" id="line-1655"><code>			cleanupStart := time.Now()</code></span>
<span class="codeline" id="line-1656"><code>			running.Store(t.name, cleanupStart)</code></span>
<span class="codeline" id="line-1657"><code>			err := t.runCleanup(recoverAndReturnPanic)</code></span>
<span class="codeline" id="line-1658"><code>			t.duration += time.Since(cleanupStart)</code></span>
<span class="codeline" id="line-1659"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1660"><code>				doPanic(err)</code></span>
<span class="codeline" id="line-1661"><code>			}</code></span>
<span class="codeline" id="line-1662"><code>			t.checkRaces()</code></span>
<span class="codeline" id="line-1663"><code>			if !t.isParallel {</code></span>
<span class="codeline" id="line-1664"><code>				// Reacquire the count for sequential tests. See comment in Run.</code></span>
<span class="codeline" id="line-1665"><code>				t.context.waitParallel()</code></span>
<span class="codeline" id="line-1666"><code>			}</code></span>
<span class="codeline" id="line-1667"><code>		} else if t.isParallel {</code></span>
<span class="codeline" id="line-1668"><code>			// Only release the count for this test if it was run as a parallel</code></span>
<span class="codeline" id="line-1669"><code>			// test. See comment in Run method.</code></span>
<span class="codeline" id="line-1670"><code>			t.context.release()</code></span>
<span class="codeline" id="line-1671"><code>		}</code></span>
<span class="codeline" id="line-1672"><code>		t.report() // Report after all subtests have finished.</code></span>
<span class="codeline" id="line-1673"><code></code></span>
<span class="codeline" id="line-1674"><code>		// Do not lock t.done to allow race detector to detect race in case</code></span>
<span class="codeline" id="line-1675"><code>		// the user does not appropriately synchronize a goroutine.</code></span>
<span class="codeline" id="line-1676"><code>		t.done = true</code></span>
<span class="codeline" id="line-1677"><code>		if t.parent != nil &amp;&amp; !t.hasSub.Load() {</code></span>
<span class="codeline" id="line-1678"><code>			t.setRan()</code></span>
<span class="codeline" id="line-1679"><code>		}</code></span>
<span class="codeline" id="line-1680"><code>	}()</code></span>
<span class="codeline" id="line-1681"><code>	defer func() {</code></span>
<span class="codeline" id="line-1682"><code>		if len(t.sub) == 0 {</code></span>
<span class="codeline" id="line-1683"><code>			t.runCleanup(normalPanic)</code></span>
<span class="codeline" id="line-1684"><code>		}</code></span>
<span class="codeline" id="line-1685"><code>	}()</code></span>
<span class="codeline" id="line-1686"><code></code></span>
<span class="codeline" id="line-1687"><code>	t.start = time.Now()</code></span>
<span class="codeline" id="line-1688"><code>	t.resetRaces()</code></span>
<span class="codeline" id="line-1689"><code>	fn(t)</code></span>
<span class="codeline" id="line-1690"><code></code></span>
<span class="codeline" id="line-1691"><code>	// code beyond here will not be executed when FailNow is invoked</code></span>
<span class="codeline" id="line-1692"><code>	t.mu.Lock()</code></span>
<span class="codeline" id="line-1693"><code>	t.finished = true</code></span>
<span class="codeline" id="line-1694"><code>	t.mu.Unlock()</code></span>
<span class="codeline" id="line-1695"><code>}</code></span>
<span class="codeline" id="line-1696"><code></code></span>
<span class="codeline" id="line-1697"><code>// Run runs f as a subtest of t called name. It runs f in a separate goroutine</code></span>
<span class="codeline" id="line-1698"><code>// and blocks until f returns or calls t.Parallel to become a parallel test.</code></span>
<span class="codeline" id="line-1699"><code>// Run reports whether f succeeded (or at least did not fail before calling t.Parallel).</code></span>
<span class="codeline" id="line-1700"><code>//</code></span>
<span class="codeline" id="line-1701"><code>// Run may be called simultaneously from multiple goroutines, but all such calls</code></span>
<span class="codeline" id="line-1702"><code>// must return before the outer test function for t returns.</code></span>
<span class="codeline" id="line-1703"><code>func (t *T) Run(name string, f func(t *T)) bool {</code></span>
<span class="codeline" id="line-1704"><code>	if t.cleanupStarted.Load() {</code></span>
<span class="codeline" id="line-1705"><code>		panic("testing: t.Run called during t.Cleanup")</code></span>
<span class="codeline" id="line-1706"><code>	}</code></span>
<span class="codeline" id="line-1707"><code></code></span>
<span class="codeline" id="line-1708"><code>	t.hasSub.Store(true)</code></span>
<span class="codeline" id="line-1709"><code>	testName, ok, _ := t.context.match.fullName(&amp;t.common, name)</code></span>
<span class="codeline" id="line-1710"><code>	if !ok || shouldFailFast() {</code></span>
<span class="codeline" id="line-1711"><code>		return true</code></span>
<span class="codeline" id="line-1712"><code>	}</code></span>
<span class="codeline" id="line-1713"><code>	// Record the stack trace at the point of this call so that if the subtest</code></span>
<span class="codeline" id="line-1714"><code>	// function - which runs in a separate stack - is marked as a helper, we can</code></span>
<span class="codeline" id="line-1715"><code>	// continue walking the stack into the parent test.</code></span>
<span class="codeline" id="line-1716"><code>	var pc [maxStackLen]uintptr</code></span>
<span class="codeline" id="line-1717"><code>	n := runtime.Callers(2, pc[:])</code></span>
<span class="codeline" id="line-1718"><code>	t = &amp;T{</code></span>
<span class="codeline" id="line-1719"><code>		common: common{</code></span>
<span class="codeline" id="line-1720"><code>			barrier: make(chan bool),</code></span>
<span class="codeline" id="line-1721"><code>			signal:  make(chan bool, 1),</code></span>
<span class="codeline" id="line-1722"><code>			name:    testName,</code></span>
<span class="codeline" id="line-1723"><code>			parent:  &amp;t.common,</code></span>
<span class="codeline" id="line-1724"><code>			level:   t.level + 1,</code></span>
<span class="codeline" id="line-1725"><code>			creator: pc[:n],</code></span>
<span class="codeline" id="line-1726"><code>			chatty:  t.chatty,</code></span>
<span class="codeline" id="line-1727"><code>		},</code></span>
<span class="codeline" id="line-1728"><code>		context: t.context,</code></span>
<span class="codeline" id="line-1729"><code>	}</code></span>
<span class="codeline" id="line-1730"><code>	t.w = indenter{&amp;t.common}</code></span>
<span class="codeline" id="line-1731"><code></code></span>
<span class="codeline" id="line-1732"><code>	if t.chatty != nil {</code></span>
<span class="codeline" id="line-1733"><code>		t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)</code></span>
<span class="codeline" id="line-1734"><code>	}</code></span>
<span class="codeline" id="line-1735"><code>	running.Store(t.name, time.Now())</code></span>
<span class="codeline" id="line-1736"><code></code></span>
<span class="codeline" id="line-1737"><code>	// Instead of reducing the running count of this test before calling the</code></span>
<span class="codeline" id="line-1738"><code>	// tRunner and increasing it afterwards, we rely on tRunner keeping the</code></span>
<span class="codeline" id="line-1739"><code>	// count correct. This ensures that a sequence of sequential tests runs</code></span>
<span class="codeline" id="line-1740"><code>	// without being preempted, even when their parent is a parallel test. This</code></span>
<span class="codeline" id="line-1741"><code>	// may especially reduce surprises if *parallel == 1.</code></span>
<span class="codeline" id="line-1742"><code>	go tRunner(t, f)</code></span>
<span class="codeline" id="line-1743"><code></code></span>
<span class="codeline" id="line-1744"><code>	// The parent goroutine will block until the subtest either finishes or calls</code></span>
<span class="codeline" id="line-1745"><code>	// Parallel, but in general we don't know whether the parent goroutine is the</code></span>
<span class="codeline" id="line-1746"><code>	// top-level test function or some other goroutine it has spawned.</code></span>
<span class="codeline" id="line-1747"><code>	// To avoid confusing false-negatives, we leave the parent in the running map</code></span>
<span class="codeline" id="line-1748"><code>	// even though in the typical case it is blocked.</code></span>
<span class="codeline" id="line-1749"><code></code></span>
<span class="codeline" id="line-1750"><code>	if !&lt;-t.signal {</code></span>
<span class="codeline" id="line-1751"><code>		// At this point, it is likely that FailNow was called on one of the</code></span>
<span class="codeline" id="line-1752"><code>		// parent tests by one of the subtests. Continue aborting up the chain.</code></span>
<span class="codeline" id="line-1753"><code>		runtime.Goexit()</code></span>
<span class="codeline" id="line-1754"><code>	}</code></span>
<span class="codeline" id="line-1755"><code></code></span>
<span class="codeline" id="line-1756"><code>	if t.chatty != nil &amp;&amp; t.chatty.json {</code></span>
<span class="codeline" id="line-1757"><code>		t.chatty.Updatef(t.parent.name, "=== NAME  %s\n", t.parent.name)</code></span>
<span class="codeline" id="line-1758"><code>	}</code></span>
<span class="codeline" id="line-1759"><code>	return !t.failed</code></span>
<span class="codeline" id="line-1760"><code>}</code></span>
<span class="codeline" id="line-1761"><code></code></span>
<span class="codeline" id="line-1762"><code>// Deadline reports the time at which the test binary will have</code></span>
<span class="codeline" id="line-1763"><code>// exceeded the timeout specified by the -timeout flag.</code></span>
<span class="codeline" id="line-1764"><code>//</code></span>
<span class="codeline" id="line-1765"><code>// The ok result is false if the -timeout flag indicates “no timeout” (0).</code></span>
<span class="codeline" id="line-1766"><code>func (t *T) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-1767"><code>	deadline = t.context.deadline</code></span>
<span class="codeline" id="line-1768"><code>	return deadline, !deadline.IsZero()</code></span>
<span class="codeline" id="line-1769"><code>}</code></span>
<span class="codeline" id="line-1770"><code></code></span>
<span class="codeline" id="line-1771"><code>// testContext holds all fields that are common to all tests. This includes</code></span>
<span class="codeline" id="line-1772"><code>// synchronization primitives to run at most *parallel tests.</code></span>
<span class="codeline" id="line-1773"><code>type testContext struct {</code></span>
<span class="codeline" id="line-1774"><code>	match    *matcher</code></span>
<span class="codeline" id="line-1775"><code>	deadline time.Time</code></span>
<span class="codeline" id="line-1776"><code></code></span>
<span class="codeline" id="line-1777"><code>	// isFuzzing is true in the context used when generating random inputs</code></span>
<span class="codeline" id="line-1778"><code>	// for fuzz targets. isFuzzing is false when running normal tests and</code></span>
<span class="codeline" id="line-1779"><code>	// when running fuzz tests as unit tests (without -fuzz or when -fuzz</code></span>
<span class="codeline" id="line-1780"><code>	// does not match).</code></span>
<span class="codeline" id="line-1781"><code>	isFuzzing bool</code></span>
<span class="codeline" id="line-1782"><code></code></span>
<span class="codeline" id="line-1783"><code>	mu sync.Mutex</code></span>
<span class="codeline" id="line-1784"><code></code></span>
<span class="codeline" id="line-1785"><code>	// Channel used to signal tests that are ready to be run in parallel.</code></span>
<span class="codeline" id="line-1786"><code>	startParallel chan bool</code></span>
<span class="codeline" id="line-1787"><code></code></span>
<span class="codeline" id="line-1788"><code>	// running is the number of tests currently running in parallel.</code></span>
<span class="codeline" id="line-1789"><code>	// This does not include tests that are waiting for subtests to complete.</code></span>
<span class="codeline" id="line-1790"><code>	running int</code></span>
<span class="codeline" id="line-1791"><code></code></span>
<span class="codeline" id="line-1792"><code>	// numWaiting is the number tests waiting to be run in parallel.</code></span>
<span class="codeline" id="line-1793"><code>	numWaiting int</code></span>
<span class="codeline" id="line-1794"><code></code></span>
<span class="codeline" id="line-1795"><code>	// maxParallel is a copy of the parallel flag.</code></span>
<span class="codeline" id="line-1796"><code>	maxParallel int</code></span>
<span class="codeline" id="line-1797"><code>}</code></span>
<span class="codeline" id="line-1798"><code></code></span>
<span class="codeline" id="line-1799"><code>func newTestContext(maxParallel int, m *matcher) *testContext {</code></span>
<span class="codeline" id="line-1800"><code>	return &amp;testContext{</code></span>
<span class="codeline" id="line-1801"><code>		match:         m,</code></span>
<span class="codeline" id="line-1802"><code>		startParallel: make(chan bool),</code></span>
<span class="codeline" id="line-1803"><code>		maxParallel:   maxParallel,</code></span>
<span class="codeline" id="line-1804"><code>		running:       1, // Set the count to 1 for the main (sequential) test.</code></span>
<span class="codeline" id="line-1805"><code>	}</code></span>
<span class="codeline" id="line-1806"><code>}</code></span>
<span class="codeline" id="line-1807"><code></code></span>
<span class="codeline" id="line-1808"><code>func (c *testContext) waitParallel() {</code></span>
<span class="codeline" id="line-1809"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1810"><code>	if c.running &lt; c.maxParallel {</code></span>
<span class="codeline" id="line-1811"><code>		c.running++</code></span>
<span class="codeline" id="line-1812"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-1813"><code>		return</code></span>
<span class="codeline" id="line-1814"><code>	}</code></span>
<span class="codeline" id="line-1815"><code>	c.numWaiting++</code></span>
<span class="codeline" id="line-1816"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-1817"><code>	&lt;-c.startParallel</code></span>
<span class="codeline" id="line-1818"><code>}</code></span>
<span class="codeline" id="line-1819"><code></code></span>
<span class="codeline" id="line-1820"><code>func (c *testContext) release() {</code></span>
<span class="codeline" id="line-1821"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1822"><code>	if c.numWaiting == 0 {</code></span>
<span class="codeline" id="line-1823"><code>		c.running--</code></span>
<span class="codeline" id="line-1824"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-1825"><code>		return</code></span>
<span class="codeline" id="line-1826"><code>	}</code></span>
<span class="codeline" id="line-1827"><code>	c.numWaiting--</code></span>
<span class="codeline" id="line-1828"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-1829"><code>	c.startParallel &lt;- true // Pick a waiting test to be run.</code></span>
<span class="codeline" id="line-1830"><code>}</code></span>
<span class="codeline" id="line-1831"><code></code></span>
<span class="codeline" id="line-1832"><code>// No one should be using func Main anymore.</code></span>
<span class="codeline" id="line-1833"><code>// See the doc comment on func Main and use MainStart instead.</code></span>
<span class="codeline" id="line-1834"><code>var errMain = errors.New("testing: unexpected use of func Main")</code></span>
<span class="codeline" id="line-1835"><code></code></span>
<span class="codeline" id="line-1836"><code>type matchStringOnly func(pat, str string) (bool, error)</code></span>
<span class="codeline" id="line-1837"><code></code></span>
<span class="codeline" id="line-1838"><code>func (f matchStringOnly) MatchString(pat, str string) (bool, error)   { return f(pat, str) }</code></span>
<span class="codeline" id="line-1839"><code>func (f matchStringOnly) StartCPUProfile(w io.Writer) error           { return errMain }</code></span>
<span class="codeline" id="line-1840"><code>func (f matchStringOnly) StopCPUProfile()                             {}</code></span>
<span class="codeline" id="line-1841"><code>func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error { return errMain }</code></span>
<span class="codeline" id="line-1842"><code>func (f matchStringOnly) ImportPath() string                          { return "" }</code></span>
<span class="codeline" id="line-1843"><code>func (f matchStringOnly) StartTestLog(io.Writer)                      {}</code></span>
<span class="codeline" id="line-1844"><code>func (f matchStringOnly) StopTestLog() error                          { return errMain }</code></span>
<span class="codeline" id="line-1845"><code>func (f matchStringOnly) SetPanicOnExit0(bool)                        {}</code></span>
<span class="codeline" id="line-1846"><code>func (f matchStringOnly) CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error {</code></span>
<span class="codeline" id="line-1847"><code>	return errMain</code></span>
<span class="codeline" id="line-1848"><code>}</code></span>
<span class="codeline" id="line-1849"><code>func (f matchStringOnly) RunFuzzWorker(func(corpusEntry) error) error { return errMain }</code></span>
<span class="codeline" id="line-1850"><code>func (f matchStringOnly) ReadCorpus(string, []reflect.Type) ([]corpusEntry, error) {</code></span>
<span class="codeline" id="line-1851"><code>	return nil, errMain</code></span>
<span class="codeline" id="line-1852"><code>}</code></span>
<span class="codeline" id="line-1853"><code>func (f matchStringOnly) CheckCorpus([]any, []reflect.Type) error { return nil }</code></span>
<span class="codeline" id="line-1854"><code>func (f matchStringOnly) ResetCoverage()                          {}</code></span>
<span class="codeline" id="line-1855"><code>func (f matchStringOnly) SnapshotCoverage()                       {}</code></span>
<span class="codeline" id="line-1856"><code></code></span>
<span class="codeline" id="line-1857"><code>// Main is an internal function, part of the implementation of the "go test" command.</code></span>
<span class="codeline" id="line-1858"><code>// It was exported because it is cross-package and predates "internal" packages.</code></span>
<span class="codeline" id="line-1859"><code>// It is no longer used by "go test" but preserved, as much as possible, for other</code></span>
<span class="codeline" id="line-1860"><code>// systems that simulate "go test" using Main, but Main sometimes cannot be updated as</code></span>
<span class="codeline" id="line-1861"><code>// new functionality is added to the testing package.</code></span>
<span class="codeline" id="line-1862"><code>// Systems simulating "go test" should be updated to use MainStart.</code></span>
<span class="codeline" id="line-1863"><code>func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) {</code></span>
<span class="codeline" id="line-1864"><code>	os.Exit(MainStart(matchStringOnly(matchString), tests, benchmarks, nil, examples).Run())</code></span>
<span class="codeline" id="line-1865"><code>}</code></span>
<span class="codeline" id="line-1866"><code></code></span>
<span class="codeline" id="line-1867"><code>// M is a type passed to a TestMain function to run the actual tests.</code></span>
<span class="codeline" id="line-1868"><code>type M struct {</code></span>
<span class="codeline" id="line-1869"><code>	deps        testDeps</code></span>
<span class="codeline" id="line-1870"><code>	tests       []InternalTest</code></span>
<span class="codeline" id="line-1871"><code>	benchmarks  []InternalBenchmark</code></span>
<span class="codeline" id="line-1872"><code>	fuzzTargets []InternalFuzzTarget</code></span>
<span class="codeline" id="line-1873"><code>	examples    []InternalExample</code></span>
<span class="codeline" id="line-1874"><code></code></span>
<span class="codeline" id="line-1875"><code>	timer     *time.Timer</code></span>
<span class="codeline" id="line-1876"><code>	afterOnce sync.Once</code></span>
<span class="codeline" id="line-1877"><code></code></span>
<span class="codeline" id="line-1878"><code>	numRun int</code></span>
<span class="codeline" id="line-1879"><code></code></span>
<span class="codeline" id="line-1880"><code>	// value to pass to os.Exit, the outer test func main</code></span>
<span class="codeline" id="line-1881"><code>	// harness calls os.Exit with this code. See #34129.</code></span>
<span class="codeline" id="line-1882"><code>	exitCode int</code></span>
<span class="codeline" id="line-1883"><code>}</code></span>
<span class="codeline" id="line-1884"><code></code></span>
<span class="codeline" id="line-1885"><code>// testDeps is an internal interface of functionality that is</code></span>
<span class="codeline" id="line-1886"><code>// passed into this package by a test's generated main package.</code></span>
<span class="codeline" id="line-1887"><code>// The canonical implementation of this interface is</code></span>
<span class="codeline" id="line-1888"><code>// testing/internal/testdeps's TestDeps.</code></span>
<span class="codeline" id="line-1889"><code>type testDeps interface {</code></span>
<span class="codeline" id="line-1890"><code>	ImportPath() string</code></span>
<span class="codeline" id="line-1891"><code>	MatchString(pat, str string) (bool, error)</code></span>
<span class="codeline" id="line-1892"><code>	SetPanicOnExit0(bool)</code></span>
<span class="codeline" id="line-1893"><code>	StartCPUProfile(io.Writer) error</code></span>
<span class="codeline" id="line-1894"><code>	StopCPUProfile()</code></span>
<span class="codeline" id="line-1895"><code>	StartTestLog(io.Writer)</code></span>
<span class="codeline" id="line-1896"><code>	StopTestLog() error</code></span>
<span class="codeline" id="line-1897"><code>	WriteProfileTo(string, io.Writer, int) error</code></span>
<span class="codeline" id="line-1898"><code>	CoordinateFuzzing(time.Duration, int64, time.Duration, int64, int, []corpusEntry, []reflect.Type, string, string) error</code></span>
<span class="codeline" id="line-1899"><code>	RunFuzzWorker(func(corpusEntry) error) error</code></span>
<span class="codeline" id="line-1900"><code>	ReadCorpus(string, []reflect.Type) ([]corpusEntry, error)</code></span>
<span class="codeline" id="line-1901"><code>	CheckCorpus([]any, []reflect.Type) error</code></span>
<span class="codeline" id="line-1902"><code>	ResetCoverage()</code></span>
<span class="codeline" id="line-1903"><code>	SnapshotCoverage()</code></span>
<span class="codeline" id="line-1904"><code>}</code></span>
<span class="codeline" id="line-1905"><code></code></span>
<span class="codeline" id="line-1906"><code>// MainStart is meant for use by tests generated by 'go test'.</code></span>
<span class="codeline" id="line-1907"><code>// It is not meant to be called directly and is not subject to the Go 1 compatibility document.</code></span>
<span class="codeline" id="line-1908"><code>// It may change signature from release to release.</code></span>
<span class="codeline" id="line-1909"><code>func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M {</code></span>
<span class="codeline" id="line-1910"><code>	Init()</code></span>
<span class="codeline" id="line-1911"><code>	return &amp;M{</code></span>
<span class="codeline" id="line-1912"><code>		deps:        deps,</code></span>
<span class="codeline" id="line-1913"><code>		tests:       tests,</code></span>
<span class="codeline" id="line-1914"><code>		benchmarks:  benchmarks,</code></span>
<span class="codeline" id="line-1915"><code>		fuzzTargets: fuzzTargets,</code></span>
<span class="codeline" id="line-1916"><code>		examples:    examples,</code></span>
<span class="codeline" id="line-1917"><code>	}</code></span>
<span class="codeline" id="line-1918"><code>}</code></span>
<span class="codeline" id="line-1919"><code></code></span>
<span class="codeline" id="line-1920"><code>var testingTesting bool</code></span>
<span class="codeline" id="line-1921"><code>var realStderr *os.File</code></span>
<span class="codeline" id="line-1922"><code></code></span>
<span class="codeline" id="line-1923"><code>// Run runs the tests. It returns an exit code to pass to os.Exit.</code></span>
<span class="codeline" id="line-1924"><code>func (m *M) Run() (code int) {</code></span>
<span class="codeline" id="line-1925"><code>	defer func() {</code></span>
<span class="codeline" id="line-1926"><code>		code = m.exitCode</code></span>
<span class="codeline" id="line-1927"><code>	}()</code></span>
<span class="codeline" id="line-1928"><code></code></span>
<span class="codeline" id="line-1929"><code>	// Count the number of calls to m.Run.</code></span>
<span class="codeline" id="line-1930"><code>	// We only ever expected 1, but we didn't enforce that,</code></span>
<span class="codeline" id="line-1931"><code>	// and now there are tests in the wild that call m.Run multiple times.</code></span>
<span class="codeline" id="line-1932"><code>	// Sigh. go.dev/issue/23129.</code></span>
<span class="codeline" id="line-1933"><code>	m.numRun++</code></span>
<span class="codeline" id="line-1934"><code></code></span>
<span class="codeline" id="line-1935"><code>	// TestMain may have already called flag.Parse.</code></span>
<span class="codeline" id="line-1936"><code>	if !flag.Parsed() {</code></span>
<span class="codeline" id="line-1937"><code>		flag.Parse()</code></span>
<span class="codeline" id="line-1938"><code>	}</code></span>
<span class="codeline" id="line-1939"><code></code></span>
<span class="codeline" id="line-1940"><code>	if chatty.json {</code></span>
<span class="codeline" id="line-1941"><code>		// With -v=json, stdout and stderr are pointing to the same pipe,</code></span>
<span class="codeline" id="line-1942"><code>		// which is leading into test2json. In general, operating systems</code></span>
<span class="codeline" id="line-1943"><code>		// do a good job of ensuring that writes to the same pipe through</code></span>
<span class="codeline" id="line-1944"><code>		// different file descriptors are delivered whole, so that writing</code></span>
<span class="codeline" id="line-1945"><code>		// AAA to stdout and BBB to stderr simultaneously produces</code></span>
<span class="codeline" id="line-1946"><code>		// AAABBB or BBBAAA on the pipe, not something like AABBBA.</code></span>
<span class="codeline" id="line-1947"><code>		// However, the exception to this is when the pipe fills: in that</code></span>
<span class="codeline" id="line-1948"><code>		// case, Go's use of non-blocking I/O means that writing AAA</code></span>
<span class="codeline" id="line-1949"><code>		// or BBB might be split across multiple system calls, making it</code></span>
<span class="codeline" id="line-1950"><code>		// entirely possible to get output like AABBBA. The same problem</code></span>
<span class="codeline" id="line-1951"><code>		// happens inside the operating system kernel if we switch to</code></span>
<span class="codeline" id="line-1952"><code>		// blocking I/O on the pipe. This interleaved output can do things</code></span>
<span class="codeline" id="line-1953"><code>		// like print unrelated messages in the middle of a TestFoo line,</code></span>
<span class="codeline" id="line-1954"><code>		// which confuses test2json. Setting os.Stderr = os.Stdout will make</code></span>
<span class="codeline" id="line-1955"><code>		// them share a single pfd, which will hold a lock for each program</code></span>
<span class="codeline" id="line-1956"><code>		// write, preventing any interleaving.</code></span>
<span class="codeline" id="line-1957"><code>		//</code></span>
<span class="codeline" id="line-1958"><code>		// It might be nice to set Stderr = Stdout always, or perhaps if</code></span>
<span class="codeline" id="line-1959"><code>		// we can tell they are the same file, but for now -v=json is</code></span>
<span class="codeline" id="line-1960"><code>		// a very clear signal. Making the two files the same may cause</code></span>
<span class="codeline" id="line-1961"><code>		// surprises if programs close os.Stdout but expect to be able</code></span>
<span class="codeline" id="line-1962"><code>		// to continue to write to os.Stderr, but it's hard to see why a</code></span>
<span class="codeline" id="line-1963"><code>		// test would think it could take over global state that way.</code></span>
<span class="codeline" id="line-1964"><code>		//</code></span>
<span class="codeline" id="line-1965"><code>		// This fix only helps programs where the output is coming directly</code></span>
<span class="codeline" id="line-1966"><code>		// from Go code. It does not help programs in which a subprocess is</code></span>
<span class="codeline" id="line-1967"><code>		// writing to stderr or stdout at the same time that a Go test is writing output.</code></span>
<span class="codeline" id="line-1968"><code>		// It also does not help when the output is coming from the runtime,</code></span>
<span class="codeline" id="line-1969"><code>		// such as when using the print/println functions, since that code writes</code></span>
<span class="codeline" id="line-1970"><code>		// directly to fd 2 without any locking.</code></span>
<span class="codeline" id="line-1971"><code>		// We keep realStderr around to prevent fd 2 from being closed.</code></span>
<span class="codeline" id="line-1972"><code>		//</code></span>
<span class="codeline" id="line-1973"><code>		// See go.dev/issue/33419.</code></span>
<span class="codeline" id="line-1974"><code>		realStderr = os.Stderr</code></span>
<span class="codeline" id="line-1975"><code>		os.Stderr = os.Stdout</code></span>
<span class="codeline" id="line-1976"><code>	}</code></span>
<span class="codeline" id="line-1977"><code></code></span>
<span class="codeline" id="line-1978"><code>	if *parallel &lt; 1 {</code></span>
<span class="codeline" id="line-1979"><code>		fmt.Fprintln(os.Stderr, "testing: -parallel can only be given a positive integer")</code></span>
<span class="codeline" id="line-1980"><code>		flag.Usage()</code></span>
<span class="codeline" id="line-1981"><code>		m.exitCode = 2</code></span>
<span class="codeline" id="line-1982"><code>		return</code></span>
<span class="codeline" id="line-1983"><code>	}</code></span>
<span class="codeline" id="line-1984"><code>	if *matchFuzz != "" &amp;&amp; *fuzzCacheDir == "" {</code></span>
<span class="codeline" id="line-1985"><code>		fmt.Fprintln(os.Stderr, "testing: -test.fuzzcachedir must be set if -test.fuzz is set")</code></span>
<span class="codeline" id="line-1986"><code>		flag.Usage()</code></span>
<span class="codeline" id="line-1987"><code>		m.exitCode = 2</code></span>
<span class="codeline" id="line-1988"><code>		return</code></span>
<span class="codeline" id="line-1989"><code>	}</code></span>
<span class="codeline" id="line-1990"><code></code></span>
<span class="codeline" id="line-1991"><code>	if *matchList != "" {</code></span>
<span class="codeline" id="line-1992"><code>		listTests(m.deps.MatchString, m.tests, m.benchmarks, m.fuzzTargets, m.examples)</code></span>
<span class="codeline" id="line-1993"><code>		m.exitCode = 0</code></span>
<span class="codeline" id="line-1994"><code>		return</code></span>
<span class="codeline" id="line-1995"><code>	}</code></span>
<span class="codeline" id="line-1996"><code></code></span>
<span class="codeline" id="line-1997"><code>	if *shuffle != "off" {</code></span>
<span class="codeline" id="line-1998"><code>		var n int64</code></span>
<span class="codeline" id="line-1999"><code>		var err error</code></span>
<span class="codeline" id="line-2000"><code>		if *shuffle == "on" {</code></span>
<span class="codeline" id="line-2001"><code>			n = time.Now().UnixNano()</code></span>
<span class="codeline" id="line-2002"><code>		} else {</code></span>
<span class="codeline" id="line-2003"><code>			n, err = strconv.ParseInt(*shuffle, 10, 64)</code></span>
<span class="codeline" id="line-2004"><code>			if err != nil {</code></span>
<span class="codeline" id="line-2005"><code>				fmt.Fprintln(os.Stderr, `testing: -shuffle should be "off", "on", or a valid integer:`, err)</code></span>
<span class="codeline" id="line-2006"><code>				m.exitCode = 2</code></span>
<span class="codeline" id="line-2007"><code>				return</code></span>
<span class="codeline" id="line-2008"><code>			}</code></span>
<span class="codeline" id="line-2009"><code>		}</code></span>
<span class="codeline" id="line-2010"><code>		fmt.Println("-test.shuffle", n)</code></span>
<span class="codeline" id="line-2011"><code>		rng := rand.New(rand.NewSource(n))</code></span>
<span class="codeline" id="line-2012"><code>		rng.Shuffle(len(m.tests), func(i, j int) { m.tests[i], m.tests[j] = m.tests[j], m.tests[i] })</code></span>
<span class="codeline" id="line-2013"><code>		rng.Shuffle(len(m.benchmarks), func(i, j int) { m.benchmarks[i], m.benchmarks[j] = m.benchmarks[j], m.benchmarks[i] })</code></span>
<span class="codeline" id="line-2014"><code>	}</code></span>
<span class="codeline" id="line-2015"><code></code></span>
<span class="codeline" id="line-2016"><code>	parseCpuList()</code></span>
<span class="codeline" id="line-2017"><code></code></span>
<span class="codeline" id="line-2018"><code>	m.before()</code></span>
<span class="codeline" id="line-2019"><code>	defer m.after()</code></span>
<span class="codeline" id="line-2020"><code></code></span>
<span class="codeline" id="line-2021"><code>	// Run tests, examples, and benchmarks unless this is a fuzz worker process.</code></span>
<span class="codeline" id="line-2022"><code>	// Workers start after this is done by their parent process, and they should</code></span>
<span class="codeline" id="line-2023"><code>	// not repeat this work.</code></span>
<span class="codeline" id="line-2024"><code>	if !*isFuzzWorker {</code></span>
<span class="codeline" id="line-2025"><code>		deadline := m.startAlarm()</code></span>
<span class="codeline" id="line-2026"><code>		haveExamples = len(m.examples) &gt; 0</code></span>
<span class="codeline" id="line-2027"><code>		testRan, testOk := runTests(m.deps.MatchString, m.tests, deadline)</code></span>
<span class="codeline" id="line-2028"><code>		fuzzTargetsRan, fuzzTargetsOk := runFuzzTests(m.deps, m.fuzzTargets, deadline)</code></span>
<span class="codeline" id="line-2029"><code>		exampleRan, exampleOk := runExamples(m.deps.MatchString, m.examples)</code></span>
<span class="codeline" id="line-2030"><code>		m.stopAlarm()</code></span>
<span class="codeline" id="line-2031"><code>		if !testRan &amp;&amp; !exampleRan &amp;&amp; !fuzzTargetsRan &amp;&amp; *matchBenchmarks == "" &amp;&amp; *matchFuzz == "" {</code></span>
<span class="codeline" id="line-2032"><code>			fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")</code></span>
<span class="codeline" id="line-2033"><code>			if testingTesting &amp;&amp; *match != "^$" {</code></span>
<span class="codeline" id="line-2034"><code>				// If this happens during testing of package testing it could be that</code></span>
<span class="codeline" id="line-2035"><code>				// package testing's own logic for when to run a test is broken,</code></span>
<span class="codeline" id="line-2036"><code>				// in which case every test will run nothing and succeed,</code></span>
<span class="codeline" id="line-2037"><code>				// with no obvious way to detect this problem (since no tests are running).</code></span>
<span class="codeline" id="line-2038"><code>				// So make 'no tests to run' a hard failure when testing package testing itself.</code></span>
<span class="codeline" id="line-2039"><code>				fmt.Print(chatty.prefix(), "FAIL: package testing must run tests\n")</code></span>
<span class="codeline" id="line-2040"><code>				testOk = false</code></span>
<span class="codeline" id="line-2041"><code>			}</code></span>
<span class="codeline" id="line-2042"><code>		}</code></span>
<span class="codeline" id="line-2043"><code>		anyFailed := !testOk || !exampleOk || !fuzzTargetsOk || !runBenchmarks(m.deps.ImportPath(), m.deps.MatchString, m.benchmarks)</code></span>
<span class="codeline" id="line-2044"><code>		if !anyFailed &amp;&amp; race.Errors() &gt; 0 {</code></span>
<span class="codeline" id="line-2045"><code>			fmt.Print(chatty.prefix(), "testing: race detected outside of test execution\n")</code></span>
<span class="codeline" id="line-2046"><code>			anyFailed = true</code></span>
<span class="codeline" id="line-2047"><code>		}</code></span>
<span class="codeline" id="line-2048"><code>		if anyFailed {</code></span>
<span class="codeline" id="line-2049"><code>			fmt.Print(chatty.prefix(), "FAIL\n")</code></span>
<span class="codeline" id="line-2050"><code>			m.exitCode = 1</code></span>
<span class="codeline" id="line-2051"><code>			return</code></span>
<span class="codeline" id="line-2052"><code>		}</code></span>
<span class="codeline" id="line-2053"><code>	}</code></span>
<span class="codeline" id="line-2054"><code></code></span>
<span class="codeline" id="line-2055"><code>	fuzzingOk := runFuzzing(m.deps, m.fuzzTargets)</code></span>
<span class="codeline" id="line-2056"><code>	if !fuzzingOk {</code></span>
<span class="codeline" id="line-2057"><code>		fmt.Print(chatty.prefix(), "FAIL\n")</code></span>
<span class="codeline" id="line-2058"><code>		if *isFuzzWorker {</code></span>
<span class="codeline" id="line-2059"><code>			m.exitCode = fuzzWorkerExitCode</code></span>
<span class="codeline" id="line-2060"><code>		} else {</code></span>
<span class="codeline" id="line-2061"><code>			m.exitCode = 1</code></span>
<span class="codeline" id="line-2062"><code>		}</code></span>
<span class="codeline" id="line-2063"><code>		return</code></span>
<span class="codeline" id="line-2064"><code>	}</code></span>
<span class="codeline" id="line-2065"><code></code></span>
<span class="codeline" id="line-2066"><code>	m.exitCode = 0</code></span>
<span class="codeline" id="line-2067"><code>	if !*isFuzzWorker {</code></span>
<span class="codeline" id="line-2068"><code>		fmt.Print(chatty.prefix(), "PASS\n")</code></span>
<span class="codeline" id="line-2069"><code>	}</code></span>
<span class="codeline" id="line-2070"><code>	return</code></span>
<span class="codeline" id="line-2071"><code>}</code></span>
<span class="codeline" id="line-2072"><code></code></span>
<span class="codeline" id="line-2073"><code>func (t *T) report() {</code></span>
<span class="codeline" id="line-2074"><code>	if t.parent == nil {</code></span>
<span class="codeline" id="line-2075"><code>		return</code></span>
<span class="codeline" id="line-2076"><code>	}</code></span>
<span class="codeline" id="line-2077"><code>	dstr := fmtDuration(t.duration)</code></span>
<span class="codeline" id="line-2078"><code>	format := "--- %s: %s (%s)\n"</code></span>
<span class="codeline" id="line-2079"><code>	if t.Failed() {</code></span>
<span class="codeline" id="line-2080"><code>		t.flushToParent(t.name, format, "FAIL", t.name, dstr)</code></span>
<span class="codeline" id="line-2081"><code>	} else if t.chatty != nil {</code></span>
<span class="codeline" id="line-2082"><code>		if t.Skipped() {</code></span>
<span class="codeline" id="line-2083"><code>			t.flushToParent(t.name, format, "SKIP", t.name, dstr)</code></span>
<span class="codeline" id="line-2084"><code>		} else {</code></span>
<span class="codeline" id="line-2085"><code>			t.flushToParent(t.name, format, "PASS", t.name, dstr)</code></span>
<span class="codeline" id="line-2086"><code>		}</code></span>
<span class="codeline" id="line-2087"><code>	}</code></span>
<span class="codeline" id="line-2088"><code>}</code></span>
<span class="codeline" id="line-2089"><code></code></span>
<span class="codeline" id="line-2090"><code>func listTests(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) {</code></span>
<span class="codeline" id="line-2091"><code>	if _, err := matchString(*matchList, "non-empty"); err != nil {</code></span>
<span class="codeline" id="line-2092"><code>		fmt.Fprintf(os.Stderr, "testing: invalid regexp in -test.list (%q): %s\n", *matchList, err)</code></span>
<span class="codeline" id="line-2093"><code>		os.Exit(1)</code></span>
<span class="codeline" id="line-2094"><code>	}</code></span>
<span class="codeline" id="line-2095"><code></code></span>
<span class="codeline" id="line-2096"><code>	for _, test := range tests {</code></span>
<span class="codeline" id="line-2097"><code>		if ok, _ := matchString(*matchList, test.Name); ok {</code></span>
<span class="codeline" id="line-2098"><code>			fmt.Println(test.Name)</code></span>
<span class="codeline" id="line-2099"><code>		}</code></span>
<span class="codeline" id="line-2100"><code>	}</code></span>
<span class="codeline" id="line-2101"><code>	for _, bench := range benchmarks {</code></span>
<span class="codeline" id="line-2102"><code>		if ok, _ := matchString(*matchList, bench.Name); ok {</code></span>
<span class="codeline" id="line-2103"><code>			fmt.Println(bench.Name)</code></span>
<span class="codeline" id="line-2104"><code>		}</code></span>
<span class="codeline" id="line-2105"><code>	}</code></span>
<span class="codeline" id="line-2106"><code>	for _, fuzzTarget := range fuzzTargets {</code></span>
<span class="codeline" id="line-2107"><code>		if ok, _ := matchString(*matchList, fuzzTarget.Name); ok {</code></span>
<span class="codeline" id="line-2108"><code>			fmt.Println(fuzzTarget.Name)</code></span>
<span class="codeline" id="line-2109"><code>		}</code></span>
<span class="codeline" id="line-2110"><code>	}</code></span>
<span class="codeline" id="line-2111"><code>	for _, example := range examples {</code></span>
<span class="codeline" id="line-2112"><code>		if ok, _ := matchString(*matchList, example.Name); ok {</code></span>
<span class="codeline" id="line-2113"><code>			fmt.Println(example.Name)</code></span>
<span class="codeline" id="line-2114"><code>		}</code></span>
<span class="codeline" id="line-2115"><code>	}</code></span>
<span class="codeline" id="line-2116"><code>}</code></span>
<span class="codeline" id="line-2117"><code></code></span>
<span class="codeline" id="line-2118"><code>// RunTests is an internal function but exported because it is cross-package;</code></span>
<span class="codeline" id="line-2119"><code>// it is part of the implementation of the "go test" command.</code></span>
<span class="codeline" id="line-2120"><code>func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool) {</code></span>
<span class="codeline" id="line-2121"><code>	var deadline time.Time</code></span>
<span class="codeline" id="line-2122"><code>	if *timeout &gt; 0 {</code></span>
<span class="codeline" id="line-2123"><code>		deadline = time.Now().Add(*timeout)</code></span>
<span class="codeline" id="line-2124"><code>	}</code></span>
<span class="codeline" id="line-2125"><code>	ran, ok := runTests(matchString, tests, deadline)</code></span>
<span class="codeline" id="line-2126"><code>	if !ran &amp;&amp; !haveExamples {</code></span>
<span class="codeline" id="line-2127"><code>		fmt.Fprintln(os.Stderr, "testing: warning: no tests to run")</code></span>
<span class="codeline" id="line-2128"><code>	}</code></span>
<span class="codeline" id="line-2129"><code>	return ok</code></span>
<span class="codeline" id="line-2130"><code>}</code></span>
<span class="codeline" id="line-2131"><code></code></span>
<span class="codeline" id="line-2132"><code>func runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool) {</code></span>
<span class="codeline" id="line-2133"><code>	ok = true</code></span>
<span class="codeline" id="line-2134"><code>	for _, procs := range cpuList {</code></span>
<span class="codeline" id="line-2135"><code>		runtime.GOMAXPROCS(procs)</code></span>
<span class="codeline" id="line-2136"><code>		for i := uint(0); i &lt; *count; i++ {</code></span>
<span class="codeline" id="line-2137"><code>			if shouldFailFast() {</code></span>
<span class="codeline" id="line-2138"><code>				break</code></span>
<span class="codeline" id="line-2139"><code>			}</code></span>
<span class="codeline" id="line-2140"><code>			if i &gt; 0 &amp;&amp; !ran {</code></span>
<span class="codeline" id="line-2141"><code>				// There were no tests to run on the first</code></span>
<span class="codeline" id="line-2142"><code>				// iteration. This won't change, so no reason</code></span>
<span class="codeline" id="line-2143"><code>				// to keep trying.</code></span>
<span class="codeline" id="line-2144"><code>				break</code></span>
<span class="codeline" id="line-2145"><code>			}</code></span>
<span class="codeline" id="line-2146"><code>			ctx := newTestContext(*parallel, newMatcher(matchString, *match, "-test.run", *skip))</code></span>
<span class="codeline" id="line-2147"><code>			ctx.deadline = deadline</code></span>
<span class="codeline" id="line-2148"><code>			t := &amp;T{</code></span>
<span class="codeline" id="line-2149"><code>				common: common{</code></span>
<span class="codeline" id="line-2150"><code>					signal:  make(chan bool, 1),</code></span>
<span class="codeline" id="line-2151"><code>					barrier: make(chan bool),</code></span>
<span class="codeline" id="line-2152"><code>					w:       os.Stdout,</code></span>
<span class="codeline" id="line-2153"><code>				},</code></span>
<span class="codeline" id="line-2154"><code>				context: ctx,</code></span>
<span class="codeline" id="line-2155"><code>			}</code></span>
<span class="codeline" id="line-2156"><code>			if Verbose() {</code></span>
<span class="codeline" id="line-2157"><code>				t.chatty = newChattyPrinter(t.w)</code></span>
<span class="codeline" id="line-2158"><code>			}</code></span>
<span class="codeline" id="line-2159"><code>			tRunner(t, func(t *T) {</code></span>
<span class="codeline" id="line-2160"><code>				for _, test := range tests {</code></span>
<span class="codeline" id="line-2161"><code>					t.Run(test.Name, test.F)</code></span>
<span class="codeline" id="line-2162"><code>				}</code></span>
<span class="codeline" id="line-2163"><code>			})</code></span>
<span class="codeline" id="line-2164"><code>			select {</code></span>
<span class="codeline" id="line-2165"><code>			case &lt;-t.signal:</code></span>
<span class="codeline" id="line-2166"><code>			default:</code></span>
<span class="codeline" id="line-2167"><code>				panic("internal error: tRunner exited without sending on t.signal")</code></span>
<span class="codeline" id="line-2168"><code>			}</code></span>
<span class="codeline" id="line-2169"><code>			ok = ok &amp;&amp; !t.Failed()</code></span>
<span class="codeline" id="line-2170"><code>			ran = ran || t.ran</code></span>
<span class="codeline" id="line-2171"><code>		}</code></span>
<span class="codeline" id="line-2172"><code>	}</code></span>
<span class="codeline" id="line-2173"><code>	return ran, ok</code></span>
<span class="codeline" id="line-2174"><code>}</code></span>
<span class="codeline" id="line-2175"><code></code></span>
<span class="codeline" id="line-2176"><code>// before runs before all testing.</code></span>
<span class="codeline" id="line-2177"><code>func (m *M) before() {</code></span>
<span class="codeline" id="line-2178"><code>	if *memProfileRate &gt; 0 {</code></span>
<span class="codeline" id="line-2179"><code>		runtime.MemProfileRate = *memProfileRate</code></span>
<span class="codeline" id="line-2180"><code>	}</code></span>
<span class="codeline" id="line-2181"><code>	if *cpuProfile != "" {</code></span>
<span class="codeline" id="line-2182"><code>		f, err := os.Create(toOutputDir(*cpuProfile))</code></span>
<span class="codeline" id="line-2183"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2184"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2185"><code>			return</code></span>
<span class="codeline" id="line-2186"><code>		}</code></span>
<span class="codeline" id="line-2187"><code>		if err := m.deps.StartCPUProfile(f); err != nil {</code></span>
<span class="codeline" id="line-2188"><code>			fmt.Fprintf(os.Stderr, "testing: can't start cpu profile: %s\n", err)</code></span>
<span class="codeline" id="line-2189"><code>			f.Close()</code></span>
<span class="codeline" id="line-2190"><code>			return</code></span>
<span class="codeline" id="line-2191"><code>		}</code></span>
<span class="codeline" id="line-2192"><code>		// Could save f so after can call f.Close; not worth the effort.</code></span>
<span class="codeline" id="line-2193"><code>	}</code></span>
<span class="codeline" id="line-2194"><code>	if *traceFile != "" {</code></span>
<span class="codeline" id="line-2195"><code>		f, err := os.Create(toOutputDir(*traceFile))</code></span>
<span class="codeline" id="line-2196"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2197"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2198"><code>			return</code></span>
<span class="codeline" id="line-2199"><code>		}</code></span>
<span class="codeline" id="line-2200"><code>		if err := trace.Start(f); err != nil {</code></span>
<span class="codeline" id="line-2201"><code>			fmt.Fprintf(os.Stderr, "testing: can't start tracing: %s\n", err)</code></span>
<span class="codeline" id="line-2202"><code>			f.Close()</code></span>
<span class="codeline" id="line-2203"><code>			return</code></span>
<span class="codeline" id="line-2204"><code>		}</code></span>
<span class="codeline" id="line-2205"><code>		// Could save f so after can call f.Close; not worth the effort.</code></span>
<span class="codeline" id="line-2206"><code>	}</code></span>
<span class="codeline" id="line-2207"><code>	if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 {</code></span>
<span class="codeline" id="line-2208"><code>		runtime.SetBlockProfileRate(*blockProfileRate)</code></span>
<span class="codeline" id="line-2209"><code>	}</code></span>
<span class="codeline" id="line-2210"><code>	if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 {</code></span>
<span class="codeline" id="line-2211"><code>		runtime.SetMutexProfileFraction(*mutexProfileFraction)</code></span>
<span class="codeline" id="line-2212"><code>	}</code></span>
<span class="codeline" id="line-2213"><code>	if *coverProfile != "" &amp;&amp; CoverMode() == "" {</code></span>
<span class="codeline" id="line-2214"><code>		fmt.Fprintf(os.Stderr, "testing: cannot use -test.coverprofile because test binary was not built with coverage enabled\n")</code></span>
<span class="codeline" id="line-2215"><code>		os.Exit(2)</code></span>
<span class="codeline" id="line-2216"><code>	}</code></span>
<span class="codeline" id="line-2217"><code>	if *gocoverdir != "" &amp;&amp; CoverMode() == "" {</code></span>
<span class="codeline" id="line-2218"><code>		fmt.Fprintf(os.Stderr, "testing: cannot use -test.gocoverdir because test binary was not built with coverage enabled\n")</code></span>
<span class="codeline" id="line-2219"><code>		os.Exit(2)</code></span>
<span class="codeline" id="line-2220"><code>	}</code></span>
<span class="codeline" id="line-2221"><code>	if *testlog != "" {</code></span>
<span class="codeline" id="line-2222"><code>		// Note: Not using toOutputDir.</code></span>
<span class="codeline" id="line-2223"><code>		// This file is for use by cmd/go, not users.</code></span>
<span class="codeline" id="line-2224"><code>		var f *os.File</code></span>
<span class="codeline" id="line-2225"><code>		var err error</code></span>
<span class="codeline" id="line-2226"><code>		if m.numRun == 1 {</code></span>
<span class="codeline" id="line-2227"><code>			f, err = os.Create(*testlog)</code></span>
<span class="codeline" id="line-2228"><code>		} else {</code></span>
<span class="codeline" id="line-2229"><code>			f, err = os.OpenFile(*testlog, os.O_WRONLY, 0)</code></span>
<span class="codeline" id="line-2230"><code>			if err == nil {</code></span>
<span class="codeline" id="line-2231"><code>				f.Seek(0, io.SeekEnd)</code></span>
<span class="codeline" id="line-2232"><code>			}</code></span>
<span class="codeline" id="line-2233"><code>		}</code></span>
<span class="codeline" id="line-2234"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2235"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2236"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2237"><code>		}</code></span>
<span class="codeline" id="line-2238"><code>		m.deps.StartTestLog(f)</code></span>
<span class="codeline" id="line-2239"><code>		testlogFile = f</code></span>
<span class="codeline" id="line-2240"><code>	}</code></span>
<span class="codeline" id="line-2241"><code>	if *panicOnExit0 {</code></span>
<span class="codeline" id="line-2242"><code>		m.deps.SetPanicOnExit0(true)</code></span>
<span class="codeline" id="line-2243"><code>	}</code></span>
<span class="codeline" id="line-2244"><code>}</code></span>
<span class="codeline" id="line-2245"><code></code></span>
<span class="codeline" id="line-2246"><code>// after runs after all testing.</code></span>
<span class="codeline" id="line-2247"><code>func (m *M) after() {</code></span>
<span class="codeline" id="line-2248"><code>	m.afterOnce.Do(func() {</code></span>
<span class="codeline" id="line-2249"><code>		m.writeProfiles()</code></span>
<span class="codeline" id="line-2250"><code>	})</code></span>
<span class="codeline" id="line-2251"><code></code></span>
<span class="codeline" id="line-2252"><code>	// Restore PanicOnExit0 after every run, because we set it to true before</code></span>
<span class="codeline" id="line-2253"><code>	// every run. Otherwise, if m.Run is called multiple times the behavior of</code></span>
<span class="codeline" id="line-2254"><code>	// os.Exit(0) will not be restored after the second run.</code></span>
<span class="codeline" id="line-2255"><code>	if *panicOnExit0 {</code></span>
<span class="codeline" id="line-2256"><code>		m.deps.SetPanicOnExit0(false)</code></span>
<span class="codeline" id="line-2257"><code>	}</code></span>
<span class="codeline" id="line-2258"><code>}</code></span>
<span class="codeline" id="line-2259"><code></code></span>
<span class="codeline" id="line-2260"><code>func (m *M) writeProfiles() {</code></span>
<span class="codeline" id="line-2261"><code>	if *testlog != "" {</code></span>
<span class="codeline" id="line-2262"><code>		if err := m.deps.StopTestLog(); err != nil {</code></span>
<span class="codeline" id="line-2263"><code>			fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)</code></span>
<span class="codeline" id="line-2264"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2265"><code>		}</code></span>
<span class="codeline" id="line-2266"><code>		if err := testlogFile.Close(); err != nil {</code></span>
<span class="codeline" id="line-2267"><code>			fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *testlog, err)</code></span>
<span class="codeline" id="line-2268"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2269"><code>		}</code></span>
<span class="codeline" id="line-2270"><code>	}</code></span>
<span class="codeline" id="line-2271"><code>	if *cpuProfile != "" {</code></span>
<span class="codeline" id="line-2272"><code>		m.deps.StopCPUProfile() // flushes profile to disk</code></span>
<span class="codeline" id="line-2273"><code>	}</code></span>
<span class="codeline" id="line-2274"><code>	if *traceFile != "" {</code></span>
<span class="codeline" id="line-2275"><code>		trace.Stop() // flushes trace to disk</code></span>
<span class="codeline" id="line-2276"><code>	}</code></span>
<span class="codeline" id="line-2277"><code>	if *memProfile != "" {</code></span>
<span class="codeline" id="line-2278"><code>		f, err := os.Create(toOutputDir(*memProfile))</code></span>
<span class="codeline" id="line-2279"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2280"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2281"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2282"><code>		}</code></span>
<span class="codeline" id="line-2283"><code>		runtime.GC() // materialize all statistics</code></span>
<span class="codeline" id="line-2284"><code>		if err = m.deps.WriteProfileTo("allocs", f, 0); err != nil {</code></span>
<span class="codeline" id="line-2285"><code>			fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *memProfile, err)</code></span>
<span class="codeline" id="line-2286"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2287"><code>		}</code></span>
<span class="codeline" id="line-2288"><code>		f.Close()</code></span>
<span class="codeline" id="line-2289"><code>	}</code></span>
<span class="codeline" id="line-2290"><code>	if *blockProfile != "" &amp;&amp; *blockProfileRate &gt;= 0 {</code></span>
<span class="codeline" id="line-2291"><code>		f, err := os.Create(toOutputDir(*blockProfile))</code></span>
<span class="codeline" id="line-2292"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2293"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2294"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2295"><code>		}</code></span>
<span class="codeline" id="line-2296"><code>		if err = m.deps.WriteProfileTo("block", f, 0); err != nil {</code></span>
<span class="codeline" id="line-2297"><code>			fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *blockProfile, err)</code></span>
<span class="codeline" id="line-2298"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2299"><code>		}</code></span>
<span class="codeline" id="line-2300"><code>		f.Close()</code></span>
<span class="codeline" id="line-2301"><code>	}</code></span>
<span class="codeline" id="line-2302"><code>	if *mutexProfile != "" &amp;&amp; *mutexProfileFraction &gt;= 0 {</code></span>
<span class="codeline" id="line-2303"><code>		f, err := os.Create(toOutputDir(*mutexProfile))</code></span>
<span class="codeline" id="line-2304"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2305"><code>			fmt.Fprintf(os.Stderr, "testing: %s\n", err)</code></span>
<span class="codeline" id="line-2306"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2307"><code>		}</code></span>
<span class="codeline" id="line-2308"><code>		if err = m.deps.WriteProfileTo("mutex", f, 0); err != nil {</code></span>
<span class="codeline" id="line-2309"><code>			fmt.Fprintf(os.Stderr, "testing: can't write %s: %s\n", *mutexProfile, err)</code></span>
<span class="codeline" id="line-2310"><code>			os.Exit(2)</code></span>
<span class="codeline" id="line-2311"><code>		}</code></span>
<span class="codeline" id="line-2312"><code>		f.Close()</code></span>
<span class="codeline" id="line-2313"><code>	}</code></span>
<span class="codeline" id="line-2314"><code>	if CoverMode() != "" {</code></span>
<span class="codeline" id="line-2315"><code>		coverReport()</code></span>
<span class="codeline" id="line-2316"><code>	}</code></span>
<span class="codeline" id="line-2317"><code>}</code></span>
<span class="codeline" id="line-2318"><code></code></span>
<span class="codeline" id="line-2319"><code>// toOutputDir returns the file name relocated, if required, to outputDir.</code></span>
<span class="codeline" id="line-2320"><code>// Simple implementation to avoid pulling in path/filepath.</code></span>
<span class="codeline" id="line-2321"><code>func toOutputDir(path string) string {</code></span>
<span class="codeline" id="line-2322"><code>	if *outputDir == "" || path == "" {</code></span>
<span class="codeline" id="line-2323"><code>		return path</code></span>
<span class="codeline" id="line-2324"><code>	}</code></span>
<span class="codeline" id="line-2325"><code>	// On Windows, it's clumsy, but we can be almost always correct</code></span>
<span class="codeline" id="line-2326"><code>	// by just looking for a drive letter and a colon.</code></span>
<span class="codeline" id="line-2327"><code>	// Absolute paths always have a drive letter (ignoring UNC).</code></span>
<span class="codeline" id="line-2328"><code>	// Problem: if path == "C:A" and outputdir == "C:\Go" it's unclear</code></span>
<span class="codeline" id="line-2329"><code>	// what to do, but even then path/filepath doesn't help.</code></span>
<span class="codeline" id="line-2330"><code>	// TODO: Worth doing better? Probably not, because we're here only</code></span>
<span class="codeline" id="line-2331"><code>	// under the management of go test.</code></span>
<span class="codeline" id="line-2332"><code>	if runtime.GOOS == "windows" &amp;&amp; len(path) &gt;= 2 {</code></span>
<span class="codeline" id="line-2333"><code>		letter, colon := path[0], path[1]</code></span>
<span class="codeline" id="line-2334"><code>		if ('a' &lt;= letter &amp;&amp; letter &lt;= 'z' || 'A' &lt;= letter &amp;&amp; letter &lt;= 'Z') &amp;&amp; colon == ':' {</code></span>
<span class="codeline" id="line-2335"><code>			// If path starts with a drive letter we're stuck with it regardless.</code></span>
<span class="codeline" id="line-2336"><code>			return path</code></span>
<span class="codeline" id="line-2337"><code>		}</code></span>
<span class="codeline" id="line-2338"><code>	}</code></span>
<span class="codeline" id="line-2339"><code>	if os.IsPathSeparator(path[0]) {</code></span>
<span class="codeline" id="line-2340"><code>		return path</code></span>
<span class="codeline" id="line-2341"><code>	}</code></span>
<span class="codeline" id="line-2342"><code>	return fmt.Sprintf("%s%c%s", *outputDir, os.PathSeparator, path)</code></span>
<span class="codeline" id="line-2343"><code>}</code></span>
<span class="codeline" id="line-2344"><code></code></span>
<span class="codeline" id="line-2345"><code>// startAlarm starts an alarm if requested.</code></span>
<span class="codeline" id="line-2346"><code>func (m *M) startAlarm() time.Time {</code></span>
<span class="codeline" id="line-2347"><code>	if *timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-2348"><code>		return time.Time{}</code></span>
<span class="codeline" id="line-2349"><code>	}</code></span>
<span class="codeline" id="line-2350"><code></code></span>
<span class="codeline" id="line-2351"><code>	deadline := time.Now().Add(*timeout)</code></span>
<span class="codeline" id="line-2352"><code>	m.timer = time.AfterFunc(*timeout, func() {</code></span>
<span class="codeline" id="line-2353"><code>		m.after()</code></span>
<span class="codeline" id="line-2354"><code>		debug.SetTraceback("all")</code></span>
<span class="codeline" id="line-2355"><code>		extra := ""</code></span>
<span class="codeline" id="line-2356"><code></code></span>
<span class="codeline" id="line-2357"><code>		if list := runningList(); len(list) &gt; 0 {</code></span>
<span class="codeline" id="line-2358"><code>			var b strings.Builder</code></span>
<span class="codeline" id="line-2359"><code>			b.WriteString("\nrunning tests:")</code></span>
<span class="codeline" id="line-2360"><code>			for _, name := range list {</code></span>
<span class="codeline" id="line-2361"><code>				b.WriteString("\n\t")</code></span>
<span class="codeline" id="line-2362"><code>				b.WriteString(name)</code></span>
<span class="codeline" id="line-2363"><code>			}</code></span>
<span class="codeline" id="line-2364"><code>			extra = b.String()</code></span>
<span class="codeline" id="line-2365"><code>		}</code></span>
<span class="codeline" id="line-2366"><code>		panic(fmt.Sprintf("test timed out after %v%s", *timeout, extra))</code></span>
<span class="codeline" id="line-2367"><code>	})</code></span>
<span class="codeline" id="line-2368"><code>	return deadline</code></span>
<span class="codeline" id="line-2369"><code>}</code></span>
<span class="codeline" id="line-2370"><code></code></span>
<span class="codeline" id="line-2371"><code>// runningList returns the list of running tests.</code></span>
<span class="codeline" id="line-2372"><code>func runningList() []string {</code></span>
<span class="codeline" id="line-2373"><code>	var list []string</code></span>
<span class="codeline" id="line-2374"><code>	running.Range(func(k, v any) bool {</code></span>
<span class="codeline" id="line-2375"><code>		list = append(list, fmt.Sprintf("%s (%v)", k.(string), time.Since(v.(time.Time)).Round(time.Second)))</code></span>
<span class="codeline" id="line-2376"><code>		return true</code></span>
<span class="codeline" id="line-2377"><code>	})</code></span>
<span class="codeline" id="line-2378"><code>	sort.Strings(list)</code></span>
<span class="codeline" id="line-2379"><code>	return list</code></span>
<span class="codeline" id="line-2380"><code>}</code></span>
<span class="codeline" id="line-2381"><code></code></span>
<span class="codeline" id="line-2382"><code>// stopAlarm turns off the alarm.</code></span>
<span class="codeline" id="line-2383"><code>func (m *M) stopAlarm() {</code></span>
<span class="codeline" id="line-2384"><code>	if *timeout &gt; 0 {</code></span>
<span class="codeline" id="line-2385"><code>		m.timer.Stop()</code></span>
<span class="codeline" id="line-2386"><code>	}</code></span>
<span class="codeline" id="line-2387"><code>}</code></span>
<span class="codeline" id="line-2388"><code></code></span>
<span class="codeline" id="line-2389"><code>func parseCpuList() {</code></span>
<span class="codeline" id="line-2390"><code>	for _, val := range strings.Split(*cpuListStr, ",") {</code></span>
<span class="codeline" id="line-2391"><code>		val = strings.TrimSpace(val)</code></span>
<span class="codeline" id="line-2392"><code>		if val == "" {</code></span>
<span class="codeline" id="line-2393"><code>			continue</code></span>
<span class="codeline" id="line-2394"><code>		}</code></span>
<span class="codeline" id="line-2395"><code>		cpu, err := strconv.Atoi(val)</code></span>
<span class="codeline" id="line-2396"><code>		if err != nil || cpu &lt;= 0 {</code></span>
<span class="codeline" id="line-2397"><code>			fmt.Fprintf(os.Stderr, "testing: invalid value %q for -test.cpu\n", val)</code></span>
<span class="codeline" id="line-2398"><code>			os.Exit(1)</code></span>
<span class="codeline" id="line-2399"><code>		}</code></span>
<span class="codeline" id="line-2400"><code>		cpuList = append(cpuList, cpu)</code></span>
<span class="codeline" id="line-2401"><code>	}</code></span>
<span class="codeline" id="line-2402"><code>	if cpuList == nil {</code></span>
<span class="codeline" id="line-2403"><code>		cpuList = append(cpuList, runtime.GOMAXPROCS(-1))</code></span>
<span class="codeline" id="line-2404"><code>	}</code></span>
<span class="codeline" id="line-2405"><code>}</code></span>
<span class="codeline" id="line-2406"><code></code></span>
<span class="codeline" id="line-2407"><code>func shouldFailFast() bool {</code></span>
<span class="codeline" id="line-2408"><code>	return *failFast &amp;&amp; numFailed.Load() &gt; 0</code></span>
<span class="codeline" id="line-2409"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>