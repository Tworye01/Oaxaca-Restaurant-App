<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: parse.go in package golang.org/x/text/internal/language</title>
<link href="../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	parse.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../pkg/golang.org/x/text/internal/language.html">golang.org/x/text/internal/language</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2013 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package language</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"bytes"</code></span>
<span class="codeline" id="line-9"><code>	"errors"</code></span>
<span class="codeline" id="line-10"><code>	"fmt"</code></span>
<span class="codeline" id="line-11"><code>	"sort"</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>	"golang.org/x/text/internal/tag"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// isAlpha returns true if the byte is not a digit.</code></span>
<span class="codeline" id="line-17"><code>// b must be an ASCII letter or digit.</code></span>
<span class="codeline" id="line-18"><code>func isAlpha(b byte) bool {</code></span>
<span class="codeline" id="line-19"><code>	return b &gt; '9'</code></span>
<span class="codeline" id="line-20"><code>}</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>// isAlphaNum returns true if the string contains only ASCII letters or digits.</code></span>
<span class="codeline" id="line-23"><code>func isAlphaNum(s []byte) bool {</code></span>
<span class="codeline" id="line-24"><code>	for _, c := range s {</code></span>
<span class="codeline" id="line-25"><code>		if !('a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z' || '0' &lt;= c &amp;&amp; c &lt;= '9') {</code></span>
<span class="codeline" id="line-26"><code>			return false</code></span>
<span class="codeline" id="line-27"><code>		}</code></span>
<span class="codeline" id="line-28"><code>	}</code></span>
<span class="codeline" id="line-29"><code>	return true</code></span>
<span class="codeline" id="line-30"><code>}</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// ErrSyntax is returned by any of the parsing functions when the</code></span>
<span class="codeline" id="line-33"><code>// input is not well-formed, according to BCP 47.</code></span>
<span class="codeline" id="line-34"><code>// TODO: return the position at which the syntax error occurred?</code></span>
<span class="codeline" id="line-35"><code>var ErrSyntax = errors.New("language: tag is not well-formed")</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>// ErrDuplicateKey is returned when a tag contains the same key twice with</code></span>
<span class="codeline" id="line-38"><code>// different values in the -u section.</code></span>
<span class="codeline" id="line-39"><code>var ErrDuplicateKey = errors.New("language: different values for same key in -u extension")</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>// ValueError is returned by any of the parsing functions when the</code></span>
<span class="codeline" id="line-42"><code>// input is well-formed but the respective subtag is not recognized</code></span>
<span class="codeline" id="line-43"><code>// as a valid value.</code></span>
<span class="codeline" id="line-44"><code>type ValueError struct {</code></span>
<span class="codeline" id="line-45"><code>	v [8]byte</code></span>
<span class="codeline" id="line-46"><code>}</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>// NewValueError creates a new ValueError.</code></span>
<span class="codeline" id="line-49"><code>func NewValueError(tag []byte) ValueError {</code></span>
<span class="codeline" id="line-50"><code>	var e ValueError</code></span>
<span class="codeline" id="line-51"><code>	copy(e.v[:], tag)</code></span>
<span class="codeline" id="line-52"><code>	return e</code></span>
<span class="codeline" id="line-53"><code>}</code></span>
<span class="codeline" id="line-54"><code></code></span>
<span class="codeline" id="line-55"><code>func (e ValueError) tag() []byte {</code></span>
<span class="codeline" id="line-56"><code>	n := bytes.IndexByte(e.v[:], 0)</code></span>
<span class="codeline" id="line-57"><code>	if n == -1 {</code></span>
<span class="codeline" id="line-58"><code>		n = 8</code></span>
<span class="codeline" id="line-59"><code>	}</code></span>
<span class="codeline" id="line-60"><code>	return e.v[:n]</code></span>
<span class="codeline" id="line-61"><code>}</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>// Error implements the error interface.</code></span>
<span class="codeline" id="line-64"><code>func (e ValueError) Error() string {</code></span>
<span class="codeline" id="line-65"><code>	return fmt.Sprintf("language: subtag %q is well-formed but unknown", e.tag())</code></span>
<span class="codeline" id="line-66"><code>}</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>// Subtag returns the subtag for which the error occurred.</code></span>
<span class="codeline" id="line-69"><code>func (e ValueError) Subtag() string {</code></span>
<span class="codeline" id="line-70"><code>	return string(e.tag())</code></span>
<span class="codeline" id="line-71"><code>}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// scanner is used to scan BCP 47 tokens, which are separated by _ or -.</code></span>
<span class="codeline" id="line-74"><code>type scanner struct {</code></span>
<span class="codeline" id="line-75"><code>	b     []byte</code></span>
<span class="codeline" id="line-76"><code>	bytes [max99thPercentileSize]byte</code></span>
<span class="codeline" id="line-77"><code>	token []byte</code></span>
<span class="codeline" id="line-78"><code>	start int // start position of the current token</code></span>
<span class="codeline" id="line-79"><code>	end   int // end position of the current token</code></span>
<span class="codeline" id="line-80"><code>	next  int // next point for scan</code></span>
<span class="codeline" id="line-81"><code>	err   error</code></span>
<span class="codeline" id="line-82"><code>	done  bool</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>func makeScannerString(s string) scanner {</code></span>
<span class="codeline" id="line-86"><code>	scan := scanner{}</code></span>
<span class="codeline" id="line-87"><code>	if len(s) &lt;= len(scan.bytes) {</code></span>
<span class="codeline" id="line-88"><code>		scan.b = scan.bytes[:copy(scan.bytes[:], s)]</code></span>
<span class="codeline" id="line-89"><code>	} else {</code></span>
<span class="codeline" id="line-90"><code>		scan.b = []byte(s)</code></span>
<span class="codeline" id="line-91"><code>	}</code></span>
<span class="codeline" id="line-92"><code>	scan.init()</code></span>
<span class="codeline" id="line-93"><code>	return scan</code></span>
<span class="codeline" id="line-94"><code>}</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>// makeScanner returns a scanner using b as the input buffer.</code></span>
<span class="codeline" id="line-97"><code>// b is not copied and may be modified by the scanner routines.</code></span>
<span class="codeline" id="line-98"><code>func makeScanner(b []byte) scanner {</code></span>
<span class="codeline" id="line-99"><code>	scan := scanner{b: b}</code></span>
<span class="codeline" id="line-100"><code>	scan.init()</code></span>
<span class="codeline" id="line-101"><code>	return scan</code></span>
<span class="codeline" id="line-102"><code>}</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>func (s *scanner) init() {</code></span>
<span class="codeline" id="line-105"><code>	for i, c := range s.b {</code></span>
<span class="codeline" id="line-106"><code>		if c == '_' {</code></span>
<span class="codeline" id="line-107"><code>			s.b[i] = '-'</code></span>
<span class="codeline" id="line-108"><code>		}</code></span>
<span class="codeline" id="line-109"><code>	}</code></span>
<span class="codeline" id="line-110"><code>	s.scan()</code></span>
<span class="codeline" id="line-111"><code>}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>// restToLower converts the string between start and end to lower case.</code></span>
<span class="codeline" id="line-114"><code>func (s *scanner) toLower(start, end int) {</code></span>
<span class="codeline" id="line-115"><code>	for i := start; i &lt; end; i++ {</code></span>
<span class="codeline" id="line-116"><code>		c := s.b[i]</code></span>
<span class="codeline" id="line-117"><code>		if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-118"><code>			s.b[i] += 'a' - 'A'</code></span>
<span class="codeline" id="line-119"><code>		}</code></span>
<span class="codeline" id="line-120"><code>	}</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>func (s *scanner) setError(e error) {</code></span>
<span class="codeline" id="line-124"><code>	if s.err == nil || (e == ErrSyntax &amp;&amp; s.err != ErrSyntax) {</code></span>
<span class="codeline" id="line-125"><code>		s.err = e</code></span>
<span class="codeline" id="line-126"><code>	}</code></span>
<span class="codeline" id="line-127"><code>}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// resizeRange shrinks or grows the array at position oldStart such that</code></span>
<span class="codeline" id="line-130"><code>// a new string of size newSize can fit between oldStart and oldEnd.</code></span>
<span class="codeline" id="line-131"><code>// Sets the scan point to after the resized range.</code></span>
<span class="codeline" id="line-132"><code>func (s *scanner) resizeRange(oldStart, oldEnd, newSize int) {</code></span>
<span class="codeline" id="line-133"><code>	s.start = oldStart</code></span>
<span class="codeline" id="line-134"><code>	if end := oldStart + newSize; end != oldEnd {</code></span>
<span class="codeline" id="line-135"><code>		diff := end - oldEnd</code></span>
<span class="codeline" id="line-136"><code>		var b []byte</code></span>
<span class="codeline" id="line-137"><code>		if n := len(s.b) + diff; n &gt; cap(s.b) {</code></span>
<span class="codeline" id="line-138"><code>			b = make([]byte, n)</code></span>
<span class="codeline" id="line-139"><code>			copy(b, s.b[:oldStart])</code></span>
<span class="codeline" id="line-140"><code>		} else {</code></span>
<span class="codeline" id="line-141"><code>			b = s.b[:n]</code></span>
<span class="codeline" id="line-142"><code>		}</code></span>
<span class="codeline" id="line-143"><code>		copy(b[end:], s.b[oldEnd:])</code></span>
<span class="codeline" id="line-144"><code>		s.b = b</code></span>
<span class="codeline" id="line-145"><code>		s.next = end + (s.next - s.end)</code></span>
<span class="codeline" id="line-146"><code>		s.end = end</code></span>
<span class="codeline" id="line-147"><code>	}</code></span>
<span class="codeline" id="line-148"><code>}</code></span>
<span class="codeline" id="line-149"><code></code></span>
<span class="codeline" id="line-150"><code>// replace replaces the current token with repl.</code></span>
<span class="codeline" id="line-151"><code>func (s *scanner) replace(repl string) {</code></span>
<span class="codeline" id="line-152"><code>	s.resizeRange(s.start, s.end, len(repl))</code></span>
<span class="codeline" id="line-153"><code>	copy(s.b[s.start:], repl)</code></span>
<span class="codeline" id="line-154"><code>}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>// gobble removes the current token from the input.</code></span>
<span class="codeline" id="line-157"><code>// Caller must call scan after calling gobble.</code></span>
<span class="codeline" id="line-158"><code>func (s *scanner) gobble(e error) {</code></span>
<span class="codeline" id="line-159"><code>	s.setError(e)</code></span>
<span class="codeline" id="line-160"><code>	if s.start == 0 {</code></span>
<span class="codeline" id="line-161"><code>		s.b = s.b[:+copy(s.b, s.b[s.next:])]</code></span>
<span class="codeline" id="line-162"><code>		s.end = 0</code></span>
<span class="codeline" id="line-163"><code>	} else {</code></span>
<span class="codeline" id="line-164"><code>		s.b = s.b[:s.start-1+copy(s.b[s.start-1:], s.b[s.end:])]</code></span>
<span class="codeline" id="line-165"><code>		s.end = s.start - 1</code></span>
<span class="codeline" id="line-166"><code>	}</code></span>
<span class="codeline" id="line-167"><code>	s.next = s.start</code></span>
<span class="codeline" id="line-168"><code>}</code></span>
<span class="codeline" id="line-169"><code></code></span>
<span class="codeline" id="line-170"><code>// deleteRange removes the given range from s.b before the current token.</code></span>
<span class="codeline" id="line-171"><code>func (s *scanner) deleteRange(start, end int) {</code></span>
<span class="codeline" id="line-172"><code>	s.b = s.b[:start+copy(s.b[start:], s.b[end:])]</code></span>
<span class="codeline" id="line-173"><code>	diff := end - start</code></span>
<span class="codeline" id="line-174"><code>	s.next -= diff</code></span>
<span class="codeline" id="line-175"><code>	s.start -= diff</code></span>
<span class="codeline" id="line-176"><code>	s.end -= diff</code></span>
<span class="codeline" id="line-177"><code>}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>// scan parses the next token of a BCP 47 string.  Tokens that are larger</code></span>
<span class="codeline" id="line-180"><code>// than 8 characters or include non-alphanumeric characters result in an error</code></span>
<span class="codeline" id="line-181"><code>// and are gobbled and removed from the output.</code></span>
<span class="codeline" id="line-182"><code>// It returns the end position of the last token consumed.</code></span>
<span class="codeline" id="line-183"><code>func (s *scanner) scan() (end int) {</code></span>
<span class="codeline" id="line-184"><code>	end = s.end</code></span>
<span class="codeline" id="line-185"><code>	s.token = nil</code></span>
<span class="codeline" id="line-186"><code>	for s.start = s.next; s.next &lt; len(s.b); {</code></span>
<span class="codeline" id="line-187"><code>		i := bytes.IndexByte(s.b[s.next:], '-')</code></span>
<span class="codeline" id="line-188"><code>		if i == -1 {</code></span>
<span class="codeline" id="line-189"><code>			s.end = len(s.b)</code></span>
<span class="codeline" id="line-190"><code>			s.next = len(s.b)</code></span>
<span class="codeline" id="line-191"><code>			i = s.end - s.start</code></span>
<span class="codeline" id="line-192"><code>		} else {</code></span>
<span class="codeline" id="line-193"><code>			s.end = s.next + i</code></span>
<span class="codeline" id="line-194"><code>			s.next = s.end + 1</code></span>
<span class="codeline" id="line-195"><code>		}</code></span>
<span class="codeline" id="line-196"><code>		token := s.b[s.start:s.end]</code></span>
<span class="codeline" id="line-197"><code>		if i &lt; 1 || i &gt; 8 || !isAlphaNum(token) {</code></span>
<span class="codeline" id="line-198"><code>			s.gobble(ErrSyntax)</code></span>
<span class="codeline" id="line-199"><code>			continue</code></span>
<span class="codeline" id="line-200"><code>		}</code></span>
<span class="codeline" id="line-201"><code>		s.token = token</code></span>
<span class="codeline" id="line-202"><code>		return end</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>	if n := len(s.b); n &gt; 0 &amp;&amp; s.b[n-1] == '-' {</code></span>
<span class="codeline" id="line-205"><code>		s.setError(ErrSyntax)</code></span>
<span class="codeline" id="line-206"><code>		s.b = s.b[:len(s.b)-1]</code></span>
<span class="codeline" id="line-207"><code>	}</code></span>
<span class="codeline" id="line-208"><code>	s.done = true</code></span>
<span class="codeline" id="line-209"><code>	return end</code></span>
<span class="codeline" id="line-210"><code>}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>// acceptMinSize parses multiple tokens of the given size or greater.</code></span>
<span class="codeline" id="line-213"><code>// It returns the end position of the last token consumed.</code></span>
<span class="codeline" id="line-214"><code>func (s *scanner) acceptMinSize(min int) (end int) {</code></span>
<span class="codeline" id="line-215"><code>	end = s.end</code></span>
<span class="codeline" id="line-216"><code>	s.scan()</code></span>
<span class="codeline" id="line-217"><code>	for ; len(s.token) &gt;= min; s.scan() {</code></span>
<span class="codeline" id="line-218"><code>		end = s.end</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code>	return end</code></span>
<span class="codeline" id="line-221"><code>}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>// Parse parses the given BCP 47 string and returns a valid Tag. If parsing</code></span>
<span class="codeline" id="line-224"><code>// failed it returns an error and any part of the tag that could be parsed.</code></span>
<span class="codeline" id="line-225"><code>// If parsing succeeded but an unknown value was found, it returns</code></span>
<span class="codeline" id="line-226"><code>// ValueError. The Tag returned in this case is just stripped of the unknown</code></span>
<span class="codeline" id="line-227"><code>// value. All other values are preserved. It accepts tags in the BCP 47 format</code></span>
<span class="codeline" id="line-228"><code>// and extensions to this standard defined in</code></span>
<span class="codeline" id="line-229"><code>// https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.</code></span>
<span class="codeline" id="line-230"><code>func Parse(s string) (t Tag, err error) {</code></span>
<span class="codeline" id="line-231"><code>	// TODO: consider supporting old-style locale key-value pairs.</code></span>
<span class="codeline" id="line-232"><code>	if s == "" {</code></span>
<span class="codeline" id="line-233"><code>		return Und, ErrSyntax</code></span>
<span class="codeline" id="line-234"><code>	}</code></span>
<span class="codeline" id="line-235"><code>	defer func() {</code></span>
<span class="codeline" id="line-236"><code>		if recover() != nil {</code></span>
<span class="codeline" id="line-237"><code>			t = Und</code></span>
<span class="codeline" id="line-238"><code>			err = ErrSyntax</code></span>
<span class="codeline" id="line-239"><code>			return</code></span>
<span class="codeline" id="line-240"><code>		}</code></span>
<span class="codeline" id="line-241"><code>	}()</code></span>
<span class="codeline" id="line-242"><code>	if len(s) &lt;= maxAltTaglen {</code></span>
<span class="codeline" id="line-243"><code>		b := [maxAltTaglen]byte{}</code></span>
<span class="codeline" id="line-244"><code>		for i, c := range s {</code></span>
<span class="codeline" id="line-245"><code>			// Generating invalid UTF-8 is okay as it won't match.</code></span>
<span class="codeline" id="line-246"><code>			if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-247"><code>				c += 'a' - 'A'</code></span>
<span class="codeline" id="line-248"><code>			} else if c == '_' {</code></span>
<span class="codeline" id="line-249"><code>				c = '-'</code></span>
<span class="codeline" id="line-250"><code>			}</code></span>
<span class="codeline" id="line-251"><code>			b[i] = byte(c)</code></span>
<span class="codeline" id="line-252"><code>		}</code></span>
<span class="codeline" id="line-253"><code>		if t, ok := grandfathered(b); ok {</code></span>
<span class="codeline" id="line-254"><code>			return t, nil</code></span>
<span class="codeline" id="line-255"><code>		}</code></span>
<span class="codeline" id="line-256"><code>	}</code></span>
<span class="codeline" id="line-257"><code>	scan := makeScannerString(s)</code></span>
<span class="codeline" id="line-258"><code>	return parse(&amp;scan, s)</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>func parse(scan *scanner, s string) (t Tag, err error) {</code></span>
<span class="codeline" id="line-262"><code>	t = Und</code></span>
<span class="codeline" id="line-263"><code>	var end int</code></span>
<span class="codeline" id="line-264"><code>	if n := len(scan.token); n &lt;= 1 {</code></span>
<span class="codeline" id="line-265"><code>		scan.toLower(0, len(scan.b))</code></span>
<span class="codeline" id="line-266"><code>		if n == 0 || scan.token[0] != 'x' {</code></span>
<span class="codeline" id="line-267"><code>			return t, ErrSyntax</code></span>
<span class="codeline" id="line-268"><code>		}</code></span>
<span class="codeline" id="line-269"><code>		end = parseExtensions(scan)</code></span>
<span class="codeline" id="line-270"><code>	} else if n &gt;= 4 {</code></span>
<span class="codeline" id="line-271"><code>		return Und, ErrSyntax</code></span>
<span class="codeline" id="line-272"><code>	} else { // the usual case</code></span>
<span class="codeline" id="line-273"><code>		t, end = parseTag(scan, true)</code></span>
<span class="codeline" id="line-274"><code>		if n := len(scan.token); n == 1 {</code></span>
<span class="codeline" id="line-275"><code>			t.pExt = uint16(end)</code></span>
<span class="codeline" id="line-276"><code>			end = parseExtensions(scan)</code></span>
<span class="codeline" id="line-277"><code>		} else if end &lt; len(scan.b) {</code></span>
<span class="codeline" id="line-278"><code>			scan.setError(ErrSyntax)</code></span>
<span class="codeline" id="line-279"><code>			scan.b = scan.b[:end]</code></span>
<span class="codeline" id="line-280"><code>		}</code></span>
<span class="codeline" id="line-281"><code>	}</code></span>
<span class="codeline" id="line-282"><code>	if int(t.pVariant) &lt; len(scan.b) {</code></span>
<span class="codeline" id="line-283"><code>		if end &lt; len(s) {</code></span>
<span class="codeline" id="line-284"><code>			s = s[:end]</code></span>
<span class="codeline" id="line-285"><code>		}</code></span>
<span class="codeline" id="line-286"><code>		if len(s) &gt; 0 &amp;&amp; tag.Compare(s, scan.b) == 0 {</code></span>
<span class="codeline" id="line-287"><code>			t.str = s</code></span>
<span class="codeline" id="line-288"><code>		} else {</code></span>
<span class="codeline" id="line-289"><code>			t.str = string(scan.b)</code></span>
<span class="codeline" id="line-290"><code>		}</code></span>
<span class="codeline" id="line-291"><code>	} else {</code></span>
<span class="codeline" id="line-292"><code>		t.pVariant, t.pExt = 0, 0</code></span>
<span class="codeline" id="line-293"><code>	}</code></span>
<span class="codeline" id="line-294"><code>	return t, scan.err</code></span>
<span class="codeline" id="line-295"><code>}</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>// parseTag parses language, script, region and variants.</code></span>
<span class="codeline" id="line-298"><code>// It returns a Tag and the end position in the input that was parsed.</code></span>
<span class="codeline" id="line-299"><code>// If doNorm is true, then &lt;lang&gt;-&lt;extlang&gt; will be normalized to &lt;extlang&gt;.</code></span>
<span class="codeline" id="line-300"><code>func parseTag(scan *scanner, doNorm bool) (t Tag, end int) {</code></span>
<span class="codeline" id="line-301"><code>	var e error</code></span>
<span class="codeline" id="line-302"><code>	// TODO: set an error if an unknown lang, script or region is encountered.</code></span>
<span class="codeline" id="line-303"><code>	t.LangID, e = getLangID(scan.token)</code></span>
<span class="codeline" id="line-304"><code>	scan.setError(e)</code></span>
<span class="codeline" id="line-305"><code>	scan.replace(t.LangID.String())</code></span>
<span class="codeline" id="line-306"><code>	langStart := scan.start</code></span>
<span class="codeline" id="line-307"><code>	end = scan.scan()</code></span>
<span class="codeline" id="line-308"><code>	for len(scan.token) == 3 &amp;&amp; isAlpha(scan.token[0]) {</code></span>
<span class="codeline" id="line-309"><code>		// From http://tools.ietf.org/html/bcp47, &lt;lang&gt;-&lt;extlang&gt; tags are equivalent</code></span>
<span class="codeline" id="line-310"><code>		// to a tag of the form &lt;extlang&gt;.</code></span>
<span class="codeline" id="line-311"><code>		if doNorm {</code></span>
<span class="codeline" id="line-312"><code>			lang, e := getLangID(scan.token)</code></span>
<span class="codeline" id="line-313"><code>			if lang != 0 {</code></span>
<span class="codeline" id="line-314"><code>				t.LangID = lang</code></span>
<span class="codeline" id="line-315"><code>				langStr := lang.String()</code></span>
<span class="codeline" id="line-316"><code>				copy(scan.b[langStart:], langStr)</code></span>
<span class="codeline" id="line-317"><code>				scan.b[langStart+len(langStr)] = '-'</code></span>
<span class="codeline" id="line-318"><code>				scan.start = langStart + len(langStr) + 1</code></span>
<span class="codeline" id="line-319"><code>			}</code></span>
<span class="codeline" id="line-320"><code>			scan.gobble(e)</code></span>
<span class="codeline" id="line-321"><code>		}</code></span>
<span class="codeline" id="line-322"><code>		end = scan.scan()</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code>	if len(scan.token) == 4 &amp;&amp; isAlpha(scan.token[0]) {</code></span>
<span class="codeline" id="line-325"><code>		t.ScriptID, e = getScriptID(script, scan.token)</code></span>
<span class="codeline" id="line-326"><code>		if t.ScriptID == 0 {</code></span>
<span class="codeline" id="line-327"><code>			scan.gobble(e)</code></span>
<span class="codeline" id="line-328"><code>		}</code></span>
<span class="codeline" id="line-329"><code>		end = scan.scan()</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	if n := len(scan.token); n &gt;= 2 &amp;&amp; n &lt;= 3 {</code></span>
<span class="codeline" id="line-332"><code>		t.RegionID, e = getRegionID(scan.token)</code></span>
<span class="codeline" id="line-333"><code>		if t.RegionID == 0 {</code></span>
<span class="codeline" id="line-334"><code>			scan.gobble(e)</code></span>
<span class="codeline" id="line-335"><code>		} else {</code></span>
<span class="codeline" id="line-336"><code>			scan.replace(t.RegionID.String())</code></span>
<span class="codeline" id="line-337"><code>		}</code></span>
<span class="codeline" id="line-338"><code>		end = scan.scan()</code></span>
<span class="codeline" id="line-339"><code>	}</code></span>
<span class="codeline" id="line-340"><code>	scan.toLower(scan.start, len(scan.b))</code></span>
<span class="codeline" id="line-341"><code>	t.pVariant = byte(end)</code></span>
<span class="codeline" id="line-342"><code>	end = parseVariants(scan, end, t)</code></span>
<span class="codeline" id="line-343"><code>	t.pExt = uint16(end)</code></span>
<span class="codeline" id="line-344"><code>	return t, end</code></span>
<span class="codeline" id="line-345"><code>}</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>var separator = []byte{'-'}</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>// parseVariants scans tokens as long as each token is a valid variant string.</code></span>
<span class="codeline" id="line-350"><code>// Duplicate variants are removed.</code></span>
<span class="codeline" id="line-351"><code>func parseVariants(scan *scanner, end int, t Tag) int {</code></span>
<span class="codeline" id="line-352"><code>	start := scan.start</code></span>
<span class="codeline" id="line-353"><code>	varIDBuf := [4]uint8{}</code></span>
<span class="codeline" id="line-354"><code>	variantBuf := [4][]byte{}</code></span>
<span class="codeline" id="line-355"><code>	varID := varIDBuf[:0]</code></span>
<span class="codeline" id="line-356"><code>	variant := variantBuf[:0]</code></span>
<span class="codeline" id="line-357"><code>	last := -1</code></span>
<span class="codeline" id="line-358"><code>	needSort := false</code></span>
<span class="codeline" id="line-359"><code>	for ; len(scan.token) &gt;= 4; scan.scan() {</code></span>
<span class="codeline" id="line-360"><code>		// TODO: measure the impact of needing this conversion and redesign</code></span>
<span class="codeline" id="line-361"><code>		// the data structure if there is an issue.</code></span>
<span class="codeline" id="line-362"><code>		v, ok := variantIndex[string(scan.token)]</code></span>
<span class="codeline" id="line-363"><code>		if !ok {</code></span>
<span class="codeline" id="line-364"><code>			// unknown variant</code></span>
<span class="codeline" id="line-365"><code>			// TODO: allow user-defined variants?</code></span>
<span class="codeline" id="line-366"><code>			scan.gobble(NewValueError(scan.token))</code></span>
<span class="codeline" id="line-367"><code>			continue</code></span>
<span class="codeline" id="line-368"><code>		}</code></span>
<span class="codeline" id="line-369"><code>		varID = append(varID, v)</code></span>
<span class="codeline" id="line-370"><code>		variant = append(variant, scan.token)</code></span>
<span class="codeline" id="line-371"><code>		if !needSort {</code></span>
<span class="codeline" id="line-372"><code>			if last &lt; int(v) {</code></span>
<span class="codeline" id="line-373"><code>				last = int(v)</code></span>
<span class="codeline" id="line-374"><code>			} else {</code></span>
<span class="codeline" id="line-375"><code>				needSort = true</code></span>
<span class="codeline" id="line-376"><code>				// There is no legal combinations of more than 7 variants</code></span>
<span class="codeline" id="line-377"><code>				// (and this is by no means a useful sequence).</code></span>
<span class="codeline" id="line-378"><code>				const maxVariants = 8</code></span>
<span class="codeline" id="line-379"><code>				if len(varID) &gt; maxVariants {</code></span>
<span class="codeline" id="line-380"><code>					break</code></span>
<span class="codeline" id="line-381"><code>				}</code></span>
<span class="codeline" id="line-382"><code>			}</code></span>
<span class="codeline" id="line-383"><code>		}</code></span>
<span class="codeline" id="line-384"><code>		end = scan.end</code></span>
<span class="codeline" id="line-385"><code>	}</code></span>
<span class="codeline" id="line-386"><code>	if needSort {</code></span>
<span class="codeline" id="line-387"><code>		sort.Sort(variantsSort{varID, variant})</code></span>
<span class="codeline" id="line-388"><code>		k, l := 0, -1</code></span>
<span class="codeline" id="line-389"><code>		for i, v := range varID {</code></span>
<span class="codeline" id="line-390"><code>			w := int(v)</code></span>
<span class="codeline" id="line-391"><code>			if l == w {</code></span>
<span class="codeline" id="line-392"><code>				// Remove duplicates.</code></span>
<span class="codeline" id="line-393"><code>				continue</code></span>
<span class="codeline" id="line-394"><code>			}</code></span>
<span class="codeline" id="line-395"><code>			varID[k] = varID[i]</code></span>
<span class="codeline" id="line-396"><code>			variant[k] = variant[i]</code></span>
<span class="codeline" id="line-397"><code>			k++</code></span>
<span class="codeline" id="line-398"><code>			l = w</code></span>
<span class="codeline" id="line-399"><code>		}</code></span>
<span class="codeline" id="line-400"><code>		if str := bytes.Join(variant[:k], separator); len(str) == 0 {</code></span>
<span class="codeline" id="line-401"><code>			end = start - 1</code></span>
<span class="codeline" id="line-402"><code>		} else {</code></span>
<span class="codeline" id="line-403"><code>			scan.resizeRange(start, end, len(str))</code></span>
<span class="codeline" id="line-404"><code>			copy(scan.b[scan.start:], str)</code></span>
<span class="codeline" id="line-405"><code>			end = scan.end</code></span>
<span class="codeline" id="line-406"><code>		}</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code>	return end</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>type variantsSort struct {</code></span>
<span class="codeline" id="line-412"><code>	i []uint8</code></span>
<span class="codeline" id="line-413"><code>	v [][]byte</code></span>
<span class="codeline" id="line-414"><code>}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>func (s variantsSort) Len() int {</code></span>
<span class="codeline" id="line-417"><code>	return len(s.i)</code></span>
<span class="codeline" id="line-418"><code>}</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>func (s variantsSort) Swap(i, j int) {</code></span>
<span class="codeline" id="line-421"><code>	s.i[i], s.i[j] = s.i[j], s.i[i]</code></span>
<span class="codeline" id="line-422"><code>	s.v[i], s.v[j] = s.v[j], s.v[i]</code></span>
<span class="codeline" id="line-423"><code>}</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>func (s variantsSort) Less(i, j int) bool {</code></span>
<span class="codeline" id="line-426"><code>	return s.i[i] &lt; s.i[j]</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>type bytesSort struct {</code></span>
<span class="codeline" id="line-430"><code>	b [][]byte</code></span>
<span class="codeline" id="line-431"><code>	n int // first n bytes to compare</code></span>
<span class="codeline" id="line-432"><code>}</code></span>
<span class="codeline" id="line-433"><code></code></span>
<span class="codeline" id="line-434"><code>func (b bytesSort) Len() int {</code></span>
<span class="codeline" id="line-435"><code>	return len(b.b)</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>func (b bytesSort) Swap(i, j int) {</code></span>
<span class="codeline" id="line-439"><code>	b.b[i], b.b[j] = b.b[j], b.b[i]</code></span>
<span class="codeline" id="line-440"><code>}</code></span>
<span class="codeline" id="line-441"><code></code></span>
<span class="codeline" id="line-442"><code>func (b bytesSort) Less(i, j int) bool {</code></span>
<span class="codeline" id="line-443"><code>	for k := 0; k &lt; b.n; k++ {</code></span>
<span class="codeline" id="line-444"><code>		if b.b[i][k] == b.b[j][k] {</code></span>
<span class="codeline" id="line-445"><code>			continue</code></span>
<span class="codeline" id="line-446"><code>		}</code></span>
<span class="codeline" id="line-447"><code>		return b.b[i][k] &lt; b.b[j][k]</code></span>
<span class="codeline" id="line-448"><code>	}</code></span>
<span class="codeline" id="line-449"><code>	return false</code></span>
<span class="codeline" id="line-450"><code>}</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>// parseExtensions parses and normalizes the extensions in the buffer.</code></span>
<span class="codeline" id="line-453"><code>// It returns the last position of scan.b that is part of any extension.</code></span>
<span class="codeline" id="line-454"><code>// It also trims scan.b to remove excess parts accordingly.</code></span>
<span class="codeline" id="line-455"><code>func parseExtensions(scan *scanner) int {</code></span>
<span class="codeline" id="line-456"><code>	start := scan.start</code></span>
<span class="codeline" id="line-457"><code>	exts := [][]byte{}</code></span>
<span class="codeline" id="line-458"><code>	private := []byte{}</code></span>
<span class="codeline" id="line-459"><code>	end := scan.end</code></span>
<span class="codeline" id="line-460"><code>	for len(scan.token) == 1 {</code></span>
<span class="codeline" id="line-461"><code>		extStart := scan.start</code></span>
<span class="codeline" id="line-462"><code>		ext := scan.token[0]</code></span>
<span class="codeline" id="line-463"><code>		end = parseExtension(scan)</code></span>
<span class="codeline" id="line-464"><code>		extension := scan.b[extStart:end]</code></span>
<span class="codeline" id="line-465"><code>		if len(extension) &lt; 3 || (ext != 'x' &amp;&amp; len(extension) &lt; 4) {</code></span>
<span class="codeline" id="line-466"><code>			scan.setError(ErrSyntax)</code></span>
<span class="codeline" id="line-467"><code>			end = extStart</code></span>
<span class="codeline" id="line-468"><code>			continue</code></span>
<span class="codeline" id="line-469"><code>		} else if start == extStart &amp;&amp; (ext == 'x' || scan.start == len(scan.b)) {</code></span>
<span class="codeline" id="line-470"><code>			scan.b = scan.b[:end]</code></span>
<span class="codeline" id="line-471"><code>			return end</code></span>
<span class="codeline" id="line-472"><code>		} else if ext == 'x' {</code></span>
<span class="codeline" id="line-473"><code>			private = extension</code></span>
<span class="codeline" id="line-474"><code>			break</code></span>
<span class="codeline" id="line-475"><code>		}</code></span>
<span class="codeline" id="line-476"><code>		exts = append(exts, extension)</code></span>
<span class="codeline" id="line-477"><code>	}</code></span>
<span class="codeline" id="line-478"><code>	sort.Sort(bytesSort{exts, 1})</code></span>
<span class="codeline" id="line-479"><code>	if len(private) &gt; 0 {</code></span>
<span class="codeline" id="line-480"><code>		exts = append(exts, private)</code></span>
<span class="codeline" id="line-481"><code>	}</code></span>
<span class="codeline" id="line-482"><code>	scan.b = scan.b[:start]</code></span>
<span class="codeline" id="line-483"><code>	if len(exts) &gt; 0 {</code></span>
<span class="codeline" id="line-484"><code>		scan.b = append(scan.b, bytes.Join(exts, separator)...)</code></span>
<span class="codeline" id="line-485"><code>	} else if start &gt; 0 {</code></span>
<span class="codeline" id="line-486"><code>		// Strip trailing '-'.</code></span>
<span class="codeline" id="line-487"><code>		scan.b = scan.b[:start-1]</code></span>
<span class="codeline" id="line-488"><code>	}</code></span>
<span class="codeline" id="line-489"><code>	return end</code></span>
<span class="codeline" id="line-490"><code>}</code></span>
<span class="codeline" id="line-491"><code></code></span>
<span class="codeline" id="line-492"><code>// parseExtension parses a single extension and returns the position of</code></span>
<span class="codeline" id="line-493"><code>// the extension end.</code></span>
<span class="codeline" id="line-494"><code>func parseExtension(scan *scanner) int {</code></span>
<span class="codeline" id="line-495"><code>	start, end := scan.start, scan.end</code></span>
<span class="codeline" id="line-496"><code>	switch scan.token[0] {</code></span>
<span class="codeline" id="line-497"><code>	case 'u': // https://www.ietf.org/rfc/rfc6067.txt</code></span>
<span class="codeline" id="line-498"><code>		attrStart := end</code></span>
<span class="codeline" id="line-499"><code>		scan.scan()</code></span>
<span class="codeline" id="line-500"><code>		for last := []byte{}; len(scan.token) &gt; 2; scan.scan() {</code></span>
<span class="codeline" id="line-501"><code>			if bytes.Compare(scan.token, last) != -1 {</code></span>
<span class="codeline" id="line-502"><code>				// Attributes are unsorted. Start over from scratch.</code></span>
<span class="codeline" id="line-503"><code>				p := attrStart + 1</code></span>
<span class="codeline" id="line-504"><code>				scan.next = p</code></span>
<span class="codeline" id="line-505"><code>				attrs := [][]byte{}</code></span>
<span class="codeline" id="line-506"><code>				for scan.scan(); len(scan.token) &gt; 2; scan.scan() {</code></span>
<span class="codeline" id="line-507"><code>					attrs = append(attrs, scan.token)</code></span>
<span class="codeline" id="line-508"><code>					end = scan.end</code></span>
<span class="codeline" id="line-509"><code>				}</code></span>
<span class="codeline" id="line-510"><code>				sort.Sort(bytesSort{attrs, 3})</code></span>
<span class="codeline" id="line-511"><code>				copy(scan.b[p:], bytes.Join(attrs, separator))</code></span>
<span class="codeline" id="line-512"><code>				break</code></span>
<span class="codeline" id="line-513"><code>			}</code></span>
<span class="codeline" id="line-514"><code>			last = scan.token</code></span>
<span class="codeline" id="line-515"><code>			end = scan.end</code></span>
<span class="codeline" id="line-516"><code>		}</code></span>
<span class="codeline" id="line-517"><code>		// Scan key-type sequences. A key is of length 2 and may be followed</code></span>
<span class="codeline" id="line-518"><code>		// by 0 or more "type" subtags from 3 to the maximum of 8 letters.</code></span>
<span class="codeline" id="line-519"><code>		var last, key []byte</code></span>
<span class="codeline" id="line-520"><code>		for attrEnd := end; len(scan.token) == 2; last = key {</code></span>
<span class="codeline" id="line-521"><code>			key = scan.token</code></span>
<span class="codeline" id="line-522"><code>			end = scan.end</code></span>
<span class="codeline" id="line-523"><code>			for scan.scan(); end &lt; scan.end &amp;&amp; len(scan.token) &gt; 2; scan.scan() {</code></span>
<span class="codeline" id="line-524"><code>				end = scan.end</code></span>
<span class="codeline" id="line-525"><code>			}</code></span>
<span class="codeline" id="line-526"><code>			// TODO: check key value validity</code></span>
<span class="codeline" id="line-527"><code>			if bytes.Compare(key, last) != 1 || scan.err != nil {</code></span>
<span class="codeline" id="line-528"><code>				// We have an invalid key or the keys are not sorted.</code></span>
<span class="codeline" id="line-529"><code>				// Start scanning keys from scratch and reorder.</code></span>
<span class="codeline" id="line-530"><code>				p := attrEnd + 1</code></span>
<span class="codeline" id="line-531"><code>				scan.next = p</code></span>
<span class="codeline" id="line-532"><code>				keys := [][]byte{}</code></span>
<span class="codeline" id="line-533"><code>				for scan.scan(); len(scan.token) == 2; {</code></span>
<span class="codeline" id="line-534"><code>					keyStart := scan.start</code></span>
<span class="codeline" id="line-535"><code>					end = scan.end</code></span>
<span class="codeline" id="line-536"><code>					for scan.scan(); end &lt; scan.end &amp;&amp; len(scan.token) &gt; 2; scan.scan() {</code></span>
<span class="codeline" id="line-537"><code>						end = scan.end</code></span>
<span class="codeline" id="line-538"><code>					}</code></span>
<span class="codeline" id="line-539"><code>					keys = append(keys, scan.b[keyStart:end])</code></span>
<span class="codeline" id="line-540"><code>				}</code></span>
<span class="codeline" id="line-541"><code>				sort.Stable(bytesSort{keys, 2})</code></span>
<span class="codeline" id="line-542"><code>				if n := len(keys); n &gt; 0 {</code></span>
<span class="codeline" id="line-543"><code>					k := 0</code></span>
<span class="codeline" id="line-544"><code>					for i := 1; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-545"><code>						if !bytes.Equal(keys[k][:2], keys[i][:2]) {</code></span>
<span class="codeline" id="line-546"><code>							k++</code></span>
<span class="codeline" id="line-547"><code>							keys[k] = keys[i]</code></span>
<span class="codeline" id="line-548"><code>						} else if !bytes.Equal(keys[k], keys[i]) {</code></span>
<span class="codeline" id="line-549"><code>							scan.setError(ErrDuplicateKey)</code></span>
<span class="codeline" id="line-550"><code>						}</code></span>
<span class="codeline" id="line-551"><code>					}</code></span>
<span class="codeline" id="line-552"><code>					keys = keys[:k+1]</code></span>
<span class="codeline" id="line-553"><code>				}</code></span>
<span class="codeline" id="line-554"><code>				reordered := bytes.Join(keys, separator)</code></span>
<span class="codeline" id="line-555"><code>				if e := p + len(reordered); e &lt; end {</code></span>
<span class="codeline" id="line-556"><code>					scan.deleteRange(e, end)</code></span>
<span class="codeline" id="line-557"><code>					end = e</code></span>
<span class="codeline" id="line-558"><code>				}</code></span>
<span class="codeline" id="line-559"><code>				copy(scan.b[p:], reordered)</code></span>
<span class="codeline" id="line-560"><code>				break</code></span>
<span class="codeline" id="line-561"><code>			}</code></span>
<span class="codeline" id="line-562"><code>		}</code></span>
<span class="codeline" id="line-563"><code>	case 't': // https://www.ietf.org/rfc/rfc6497.txt</code></span>
<span class="codeline" id="line-564"><code>		scan.scan()</code></span>
<span class="codeline" id="line-565"><code>		if n := len(scan.token); n &gt;= 2 &amp;&amp; n &lt;= 3 &amp;&amp; isAlpha(scan.token[1]) {</code></span>
<span class="codeline" id="line-566"><code>			_, end = parseTag(scan, false)</code></span>
<span class="codeline" id="line-567"><code>			scan.toLower(start, end)</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code>		for len(scan.token) == 2 &amp;&amp; !isAlpha(scan.token[1]) {</code></span>
<span class="codeline" id="line-570"><code>			end = scan.acceptMinSize(3)</code></span>
<span class="codeline" id="line-571"><code>		}</code></span>
<span class="codeline" id="line-572"><code>	case 'x':</code></span>
<span class="codeline" id="line-573"><code>		end = scan.acceptMinSize(1)</code></span>
<span class="codeline" id="line-574"><code>	default:</code></span>
<span class="codeline" id="line-575"><code>		end = scan.acceptMinSize(2)</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code>	return end</code></span>
<span class="codeline" id="line-578"><code>}</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>// getExtension returns the name, body and end position of the extension.</code></span>
<span class="codeline" id="line-581"><code>func getExtension(s string, p int) (end int, ext string) {</code></span>
<span class="codeline" id="line-582"><code>	if s[p] == '-' {</code></span>
<span class="codeline" id="line-583"><code>		p++</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code>	if s[p] == 'x' {</code></span>
<span class="codeline" id="line-586"><code>		return len(s), s[p:]</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code>	end = nextExtension(s, p)</code></span>
<span class="codeline" id="line-589"><code>	return end, s[p:end]</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>// nextExtension finds the next extension within the string, searching</code></span>
<span class="codeline" id="line-593"><code>// for the -&lt;char&gt;- pattern from position p.</code></span>
<span class="codeline" id="line-594"><code>// In the fast majority of cases, language tags will have at most</code></span>
<span class="codeline" id="line-595"><code>// one extension and extensions tend to be small.</code></span>
<span class="codeline" id="line-596"><code>func nextExtension(s string, p int) int {</code></span>
<span class="codeline" id="line-597"><code>	for n := len(s) - 3; p &lt; n; {</code></span>
<span class="codeline" id="line-598"><code>		if s[p] == '-' {</code></span>
<span class="codeline" id="line-599"><code>			if s[p+2] == '-' {</code></span>
<span class="codeline" id="line-600"><code>				return p</code></span>
<span class="codeline" id="line-601"><code>			}</code></span>
<span class="codeline" id="line-602"><code>			p += 3</code></span>
<span class="codeline" id="line-603"><code>		} else {</code></span>
<span class="codeline" id="line-604"><code>			p++</code></span>
<span class="codeline" id="line-605"><code>		}</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	return len(s)</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>