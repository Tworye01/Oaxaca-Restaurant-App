<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: syscall_linux.go in package golang.org/x/sys/unix</title>
<link href="../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	syscall_linux.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/golang.org/x/sys/unix.html">golang.org/x/sys/unix</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// Linux system calls.</code></span>
<span class="codeline" id="line-6"><code>// This file is compiled as ordinary Go code,</code></span>
<span class="codeline" id="line-7"><code>// but it is also input to mksyscall,</code></span>
<span class="codeline" id="line-8"><code>// which parses the //sys lines and generates system call stubs.</code></span>
<span class="codeline" id="line-9"><code>// Note that sometimes we use a lowercase //sys name and</code></span>
<span class="codeline" id="line-10"><code>// wrap it in our own nicer implementation.</code></span>
<span class="codeline" id="line-11"><code></code></span>
<span class="codeline" id="line-12"><code>package unix</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>import (</code></span>
<span class="codeline" id="line-15"><code>	"encoding/binary"</code></span>
<span class="codeline" id="line-16"><code>	"strconv"</code></span>
<span class="codeline" id="line-17"><code>	"syscall"</code></span>
<span class="codeline" id="line-18"><code>	"time"</code></span>
<span class="codeline" id="line-19"><code>	"unsafe"</code></span>
<span class="codeline" id="line-20"><code>)</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>/*</code></span>
<span class="codeline" id="line-23"><code> * Wrapped</code></span>
<span class="codeline" id="line-24"><code> */</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>func Access(path string, mode uint32) (err error) {</code></span>
<span class="codeline" id="line-27"><code>	return Faccessat(AT_FDCWD, path, mode, 0)</code></span>
<span class="codeline" id="line-28"><code>}</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>func Chmod(path string, mode uint32) (err error) {</code></span>
<span class="codeline" id="line-31"><code>	return Fchmodat(AT_FDCWD, path, mode, 0)</code></span>
<span class="codeline" id="line-32"><code>}</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>func Chown(path string, uid int, gid int) (err error) {</code></span>
<span class="codeline" id="line-35"><code>	return Fchownat(AT_FDCWD, path, uid, gid, 0)</code></span>
<span class="codeline" id="line-36"><code>}</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>func Creat(path string, mode uint32) (fd int, err error) {</code></span>
<span class="codeline" id="line-39"><code>	return Open(path, O_CREAT|O_WRONLY|O_TRUNC, mode)</code></span>
<span class="codeline" id="line-40"><code>}</code></span>
<span class="codeline" id="line-41"><code></code></span>
<span class="codeline" id="line-42"><code>func EpollCreate(size int) (fd int, err error) {</code></span>
<span class="codeline" id="line-43"><code>	if size &lt;= 0 {</code></span>
<span class="codeline" id="line-44"><code>		return -1, EINVAL</code></span>
<span class="codeline" id="line-45"><code>	}</code></span>
<span class="codeline" id="line-46"><code>	return EpollCreate1(0)</code></span>
<span class="codeline" id="line-47"><code>}</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>//sys	FanotifyInit(flags uint, event_f_flags uint) (fd int, err error)</code></span>
<span class="codeline" id="line-50"><code>//sys	fanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname *byte) (err error)</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>func FanotifyMark(fd int, flags uint, mask uint64, dirFd int, pathname string) (err error) {</code></span>
<span class="codeline" id="line-53"><code>	if pathname == "" {</code></span>
<span class="codeline" id="line-54"><code>		return fanotifyMark(fd, flags, mask, dirFd, nil)</code></span>
<span class="codeline" id="line-55"><code>	}</code></span>
<span class="codeline" id="line-56"><code>	p, err := BytePtrFromString(pathname)</code></span>
<span class="codeline" id="line-57"><code>	if err != nil {</code></span>
<span class="codeline" id="line-58"><code>		return err</code></span>
<span class="codeline" id="line-59"><code>	}</code></span>
<span class="codeline" id="line-60"><code>	return fanotifyMark(fd, flags, mask, dirFd, p)</code></span>
<span class="codeline" id="line-61"><code>}</code></span>
<span class="codeline" id="line-62"><code></code></span>
<span class="codeline" id="line-63"><code>//sys	fchmodat(dirfd int, path string, mode uint32) (err error)</code></span>
<span class="codeline" id="line-64"><code>//sys	fchmodat2(dirfd int, path string, mode uint32, flags int) (err error)</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>func Fchmodat(dirfd int, path string, mode uint32, flags int) error {</code></span>
<span class="codeline" id="line-67"><code>	// Linux fchmodat doesn't support the flags parameter, but fchmodat2 does.</code></span>
<span class="codeline" id="line-68"><code>	// Try fchmodat2 if flags are specified.</code></span>
<span class="codeline" id="line-69"><code>	if flags != 0 {</code></span>
<span class="codeline" id="line-70"><code>		err := fchmodat2(dirfd, path, mode, flags)</code></span>
<span class="codeline" id="line-71"><code>		if err == ENOSYS {</code></span>
<span class="codeline" id="line-72"><code>			// fchmodat2 isn't available. If the flags are known to be valid,</code></span>
<span class="codeline" id="line-73"><code>			// return EOPNOTSUPP to indicate that fchmodat doesn't support them.</code></span>
<span class="codeline" id="line-74"><code>			if flags&amp;^(AT_SYMLINK_NOFOLLOW|AT_EMPTY_PATH) != 0 {</code></span>
<span class="codeline" id="line-75"><code>				return EINVAL</code></span>
<span class="codeline" id="line-76"><code>			} else if flags&amp;(AT_SYMLINK_NOFOLLOW|AT_EMPTY_PATH) != 0 {</code></span>
<span class="codeline" id="line-77"><code>				return EOPNOTSUPP</code></span>
<span class="codeline" id="line-78"><code>			}</code></span>
<span class="codeline" id="line-79"><code>		}</code></span>
<span class="codeline" id="line-80"><code>		return err</code></span>
<span class="codeline" id="line-81"><code>	}</code></span>
<span class="codeline" id="line-82"><code>	return fchmodat(dirfd, path, mode)</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>func InotifyInit() (fd int, err error) {</code></span>
<span class="codeline" id="line-86"><code>	return InotifyInit1(0)</code></span>
<span class="codeline" id="line-87"><code>}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>//sys	ioctl(fd int, req uint, arg uintptr) (err error) = SYS_IOCTL</code></span>
<span class="codeline" id="line-90"><code>//sys	ioctlPtr(fd int, req uint, arg unsafe.Pointer) (err error) = SYS_IOCTL</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// ioctl itself should not be exposed directly, but additional get/set functions</code></span>
<span class="codeline" id="line-93"><code>// for specific types are permissible. These are defined in ioctl.go and</code></span>
<span class="codeline" id="line-94"><code>// ioctl_linux.go.</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// The third argument to ioctl is often a pointer but sometimes an integer.</code></span>
<span class="codeline" id="line-97"><code>// Callers should use ioctlPtr when the third argument is a pointer and ioctl</code></span>
<span class="codeline" id="line-98"><code>// when the third argument is an integer.</code></span>
<span class="codeline" id="line-99"><code>//</code></span>
<span class="codeline" id="line-100"><code>// TODO: some existing code incorrectly uses ioctl when it should use ioctlPtr.</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>//sys	Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error)</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code>func Link(oldpath string, newpath string) (err error) {</code></span>
<span class="codeline" id="line-105"><code>	return Linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0)</code></span>
<span class="codeline" id="line-106"><code>}</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>func Mkdir(path string, mode uint32) (err error) {</code></span>
<span class="codeline" id="line-109"><code>	return Mkdirat(AT_FDCWD, path, mode)</code></span>
<span class="codeline" id="line-110"><code>}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>func Mknod(path string, mode uint32, dev int) (err error) {</code></span>
<span class="codeline" id="line-113"><code>	return Mknodat(AT_FDCWD, path, mode, dev)</code></span>
<span class="codeline" id="line-114"><code>}</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>func Open(path string, mode int, perm uint32) (fd int, err error) {</code></span>
<span class="codeline" id="line-117"><code>	return openat(AT_FDCWD, path, mode|O_LARGEFILE, perm)</code></span>
<span class="codeline" id="line-118"><code>}</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>//sys	openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {</code></span>
<span class="codeline" id="line-123"><code>	return openat(dirfd, path, flags|O_LARGEFILE, mode)</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>//sys	openat2(dirfd int, path string, open_how *OpenHow, size int) (fd int, err error)</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>func Openat2(dirfd int, path string, how *OpenHow) (fd int, err error) {</code></span>
<span class="codeline" id="line-129"><code>	return openat2(dirfd, path, how, SizeofOpenHow)</code></span>
<span class="codeline" id="line-130"><code>}</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>func Pipe(p []int) error {</code></span>
<span class="codeline" id="line-133"><code>	return Pipe2(p, 0)</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>//sysnb	pipe2(p *[2]_C_int, flags int) (err error)</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>func Pipe2(p []int, flags int) error {</code></span>
<span class="codeline" id="line-139"><code>	if len(p) != 2 {</code></span>
<span class="codeline" id="line-140"><code>		return EINVAL</code></span>
<span class="codeline" id="line-141"><code>	}</code></span>
<span class="codeline" id="line-142"><code>	var pp [2]_C_int</code></span>
<span class="codeline" id="line-143"><code>	err := pipe2(&amp;pp, flags)</code></span>
<span class="codeline" id="line-144"><code>	if err == nil {</code></span>
<span class="codeline" id="line-145"><code>		p[0] = int(pp[0])</code></span>
<span class="codeline" id="line-146"><code>		p[1] = int(pp[1])</code></span>
<span class="codeline" id="line-147"><code>	}</code></span>
<span class="codeline" id="line-148"><code>	return err</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>//sys	ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error)</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>func Ppoll(fds []PollFd, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {</code></span>
<span class="codeline" id="line-154"><code>	if len(fds) == 0 {</code></span>
<span class="codeline" id="line-155"><code>		return ppoll(nil, 0, timeout, sigmask)</code></span>
<span class="codeline" id="line-156"><code>	}</code></span>
<span class="codeline" id="line-157"><code>	return ppoll(&amp;fds[0], len(fds), timeout, sigmask)</code></span>
<span class="codeline" id="line-158"><code>}</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>func Poll(fds []PollFd, timeout int) (n int, err error) {</code></span>
<span class="codeline" id="line-161"><code>	var ts *Timespec</code></span>
<span class="codeline" id="line-162"><code>	if timeout &gt;= 0 {</code></span>
<span class="codeline" id="line-163"><code>		ts = new(Timespec)</code></span>
<span class="codeline" id="line-164"><code>		*ts = NsecToTimespec(int64(timeout) * 1e6)</code></span>
<span class="codeline" id="line-165"><code>	}</code></span>
<span class="codeline" id="line-166"><code>	return Ppoll(fds, ts, nil)</code></span>
<span class="codeline" id="line-167"><code>}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>//sys	Readlinkat(dirfd int, path string, buf []byte) (n int, err error)</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>func Readlink(path string, buf []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-172"><code>	return Readlinkat(AT_FDCWD, path, buf)</code></span>
<span class="codeline" id="line-173"><code>}</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>func Rename(oldpath string, newpath string) (err error) {</code></span>
<span class="codeline" id="line-176"><code>	return Renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath)</code></span>
<span class="codeline" id="line-177"><code>}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>func Rmdir(path string) error {</code></span>
<span class="codeline" id="line-180"><code>	return Unlinkat(AT_FDCWD, path, AT_REMOVEDIR)</code></span>
<span class="codeline" id="line-181"><code>}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>//sys	Symlinkat(oldpath string, newdirfd int, newpath string) (err error)</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>func Symlink(oldpath string, newpath string) (err error) {</code></span>
<span class="codeline" id="line-186"><code>	return Symlinkat(oldpath, AT_FDCWD, newpath)</code></span>
<span class="codeline" id="line-187"><code>}</code></span>
<span class="codeline" id="line-188"><code></code></span>
<span class="codeline" id="line-189"><code>func Unlink(path string) error {</code></span>
<span class="codeline" id="line-190"><code>	return Unlinkat(AT_FDCWD, path, 0)</code></span>
<span class="codeline" id="line-191"><code>}</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>//sys	Unlinkat(dirfd int, path string, flags int) (err error)</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>func Utimes(path string, tv []Timeval) error {</code></span>
<span class="codeline" id="line-196"><code>	if tv == nil {</code></span>
<span class="codeline" id="line-197"><code>		err := utimensat(AT_FDCWD, path, nil, 0)</code></span>
<span class="codeline" id="line-198"><code>		if err != ENOSYS {</code></span>
<span class="codeline" id="line-199"><code>			return err</code></span>
<span class="codeline" id="line-200"><code>		}</code></span>
<span class="codeline" id="line-201"><code>		return utimes(path, nil)</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	if len(tv) != 2 {</code></span>
<span class="codeline" id="line-204"><code>		return EINVAL</code></span>
<span class="codeline" id="line-205"><code>	}</code></span>
<span class="codeline" id="line-206"><code>	var ts [2]Timespec</code></span>
<span class="codeline" id="line-207"><code>	ts[0] = NsecToTimespec(TimevalToNsec(tv[0]))</code></span>
<span class="codeline" id="line-208"><code>	ts[1] = NsecToTimespec(TimevalToNsec(tv[1]))</code></span>
<span class="codeline" id="line-209"><code>	err := utimensat(AT_FDCWD, path, (*[2]Timespec)(unsafe.Pointer(&amp;ts[0])), 0)</code></span>
<span class="codeline" id="line-210"><code>	if err != ENOSYS {</code></span>
<span class="codeline" id="line-211"><code>		return err</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code>	return utimes(path, (*[2]Timeval)(unsafe.Pointer(&amp;tv[0])))</code></span>
<span class="codeline" id="line-214"><code>}</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>//sys	utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error)</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>func UtimesNano(path string, ts []Timespec) error {</code></span>
<span class="codeline" id="line-219"><code>	return UtimesNanoAt(AT_FDCWD, path, ts, 0)</code></span>
<span class="codeline" id="line-220"><code>}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>func UtimesNanoAt(dirfd int, path string, ts []Timespec, flags int) error {</code></span>
<span class="codeline" id="line-223"><code>	if ts == nil {</code></span>
<span class="codeline" id="line-224"><code>		return utimensat(dirfd, path, nil, flags)</code></span>
<span class="codeline" id="line-225"><code>	}</code></span>
<span class="codeline" id="line-226"><code>	if len(ts) != 2 {</code></span>
<span class="codeline" id="line-227"><code>		return EINVAL</code></span>
<span class="codeline" id="line-228"><code>	}</code></span>
<span class="codeline" id="line-229"><code>	return utimensat(dirfd, path, (*[2]Timespec)(unsafe.Pointer(&amp;ts[0])), flags)</code></span>
<span class="codeline" id="line-230"><code>}</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>func Futimesat(dirfd int, path string, tv []Timeval) error {</code></span>
<span class="codeline" id="line-233"><code>	if tv == nil {</code></span>
<span class="codeline" id="line-234"><code>		return futimesat(dirfd, path, nil)</code></span>
<span class="codeline" id="line-235"><code>	}</code></span>
<span class="codeline" id="line-236"><code>	if len(tv) != 2 {</code></span>
<span class="codeline" id="line-237"><code>		return EINVAL</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code>	return futimesat(dirfd, path, (*[2]Timeval)(unsafe.Pointer(&amp;tv[0])))</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>func Futimes(fd int, tv []Timeval) (err error) {</code></span>
<span class="codeline" id="line-243"><code>	// Believe it or not, this is the best we can do on Linux</code></span>
<span class="codeline" id="line-244"><code>	// (and is what glibc does).</code></span>
<span class="codeline" id="line-245"><code>	return Utimes("/proc/self/fd/"+strconv.Itoa(fd), tv)</code></span>
<span class="codeline" id="line-246"><code>}</code></span>
<span class="codeline" id="line-247"><code></code></span>
<span class="codeline" id="line-248"><code>const ImplementsGetwd = true</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>//sys	Getcwd(buf []byte) (n int, err error)</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>func Getwd() (wd string, err error) {</code></span>
<span class="codeline" id="line-253"><code>	var buf [PathMax]byte</code></span>
<span class="codeline" id="line-254"><code>	n, err := Getcwd(buf[0:])</code></span>
<span class="codeline" id="line-255"><code>	if err != nil {</code></span>
<span class="codeline" id="line-256"><code>		return "", err</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>	// Getcwd returns the number of bytes written to buf, including the NUL.</code></span>
<span class="codeline" id="line-259"><code>	if n &lt; 1 || n &gt; len(buf) || buf[n-1] != 0 {</code></span>
<span class="codeline" id="line-260"><code>		return "", EINVAL</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>	// In some cases, Linux can return a path that starts with the</code></span>
<span class="codeline" id="line-263"><code>	// "(unreachable)" prefix, which can potentially be a valid relative</code></span>
<span class="codeline" id="line-264"><code>	// path. To work around that, return ENOENT if path is not absolute.</code></span>
<span class="codeline" id="line-265"><code>	if buf[0] != '/' {</code></span>
<span class="codeline" id="line-266"><code>		return "", ENOENT</code></span>
<span class="codeline" id="line-267"><code>	}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>	return string(buf[0 : n-1]), nil</code></span>
<span class="codeline" id="line-270"><code>}</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>func Getgroups() (gids []int, err error) {</code></span>
<span class="codeline" id="line-273"><code>	n, err := getgroups(0, nil)</code></span>
<span class="codeline" id="line-274"><code>	if err != nil {</code></span>
<span class="codeline" id="line-275"><code>		return nil, err</code></span>
<span class="codeline" id="line-276"><code>	}</code></span>
<span class="codeline" id="line-277"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-278"><code>		return nil, nil</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// Sanity check group count. Max is 1&lt;&lt;16 on Linux.</code></span>
<span class="codeline" id="line-282"><code>	if n &lt; 0 || n &gt; 1&lt;&lt;20 {</code></span>
<span class="codeline" id="line-283"><code>		return nil, EINVAL</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code></code></span>
<span class="codeline" id="line-286"><code>	a := make([]_Gid_t, n)</code></span>
<span class="codeline" id="line-287"><code>	n, err = getgroups(n, &amp;a[0])</code></span>
<span class="codeline" id="line-288"><code>	if err != nil {</code></span>
<span class="codeline" id="line-289"><code>		return nil, err</code></span>
<span class="codeline" id="line-290"><code>	}</code></span>
<span class="codeline" id="line-291"><code>	gids = make([]int, n)</code></span>
<span class="codeline" id="line-292"><code>	for i, v := range a[0:n] {</code></span>
<span class="codeline" id="line-293"><code>		gids[i] = int(v)</code></span>
<span class="codeline" id="line-294"><code>	}</code></span>
<span class="codeline" id="line-295"><code>	return</code></span>
<span class="codeline" id="line-296"><code>}</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>func Setgroups(gids []int) (err error) {</code></span>
<span class="codeline" id="line-299"><code>	if len(gids) == 0 {</code></span>
<span class="codeline" id="line-300"><code>		return setgroups(0, nil)</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>	a := make([]_Gid_t, len(gids))</code></span>
<span class="codeline" id="line-304"><code>	for i, v := range gids {</code></span>
<span class="codeline" id="line-305"><code>		a[i] = _Gid_t(v)</code></span>
<span class="codeline" id="line-306"><code>	}</code></span>
<span class="codeline" id="line-307"><code>	return setgroups(len(a), &amp;a[0])</code></span>
<span class="codeline" id="line-308"><code>}</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>type WaitStatus uint32</code></span>
<span class="codeline" id="line-311"><code></code></span>
<span class="codeline" id="line-312"><code>// Wait status is 7 bits at bottom, either 0 (exited),</code></span>
<span class="codeline" id="line-313"><code>// 0x7F (stopped), or a signal number that caused an exit.</code></span>
<span class="codeline" id="line-314"><code>// The 0x80 bit is whether there was a core dump.</code></span>
<span class="codeline" id="line-315"><code>// An extra number (exit code, signal causing a stop)</code></span>
<span class="codeline" id="line-316"><code>// is in the high bits. At least that's the idea.</code></span>
<span class="codeline" id="line-317"><code>// There are various irregularities. For example, the</code></span>
<span class="codeline" id="line-318"><code>// "continued" status is 0xFFFF, distinguishing itself</code></span>
<span class="codeline" id="line-319"><code>// from stopped via the core dump bit.</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>const (</code></span>
<span class="codeline" id="line-322"><code>	mask    = 0x7F</code></span>
<span class="codeline" id="line-323"><code>	core    = 0x80</code></span>
<span class="codeline" id="line-324"><code>	exited  = 0x00</code></span>
<span class="codeline" id="line-325"><code>	stopped = 0x7F</code></span>
<span class="codeline" id="line-326"><code>	shift   = 8</code></span>
<span class="codeline" id="line-327"><code>)</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>func (w WaitStatus) Exited() bool { return w&amp;mask == exited }</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>func (w WaitStatus) Signaled() bool { return w&amp;mask != stopped &amp;&amp; w&amp;mask != exited }</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>func (w WaitStatus) Stopped() bool { return w&amp;0xFF == stopped }</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>func (w WaitStatus) Continued() bool { return w == 0xFFFF }</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>func (w WaitStatus) CoreDump() bool { return w.Signaled() &amp;&amp; w&amp;core != 0 }</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>func (w WaitStatus) ExitStatus() int {</code></span>
<span class="codeline" id="line-340"><code>	if !w.Exited() {</code></span>
<span class="codeline" id="line-341"><code>		return -1</code></span>
<span class="codeline" id="line-342"><code>	}</code></span>
<span class="codeline" id="line-343"><code>	return int(w&gt;&gt;shift) &amp; 0xFF</code></span>
<span class="codeline" id="line-344"><code>}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>func (w WaitStatus) Signal() syscall.Signal {</code></span>
<span class="codeline" id="line-347"><code>	if !w.Signaled() {</code></span>
<span class="codeline" id="line-348"><code>		return -1</code></span>
<span class="codeline" id="line-349"><code>	}</code></span>
<span class="codeline" id="line-350"><code>	return syscall.Signal(w &amp; mask)</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>func (w WaitStatus) StopSignal() syscall.Signal {</code></span>
<span class="codeline" id="line-354"><code>	if !w.Stopped() {</code></span>
<span class="codeline" id="line-355"><code>		return -1</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code>	return syscall.Signal(w&gt;&gt;shift) &amp; 0xFF</code></span>
<span class="codeline" id="line-358"><code>}</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>func (w WaitStatus) TrapCause() int {</code></span>
<span class="codeline" id="line-361"><code>	if w.StopSignal() != SIGTRAP {</code></span>
<span class="codeline" id="line-362"><code>		return -1</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>	return int(w&gt;&gt;shift) &gt;&gt; 8</code></span>
<span class="codeline" id="line-365"><code>}</code></span>
<span class="codeline" id="line-366"><code></code></span>
<span class="codeline" id="line-367"><code>//sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {</code></span>
<span class="codeline" id="line-370"><code>	var status _C_int</code></span>
<span class="codeline" id="line-371"><code>	wpid, err = wait4(pid, &amp;status, options, rusage)</code></span>
<span class="codeline" id="line-372"><code>	if wstatus != nil {</code></span>
<span class="codeline" id="line-373"><code>		*wstatus = WaitStatus(status)</code></span>
<span class="codeline" id="line-374"><code>	}</code></span>
<span class="codeline" id="line-375"><code>	return</code></span>
<span class="codeline" id="line-376"><code>}</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>//sys	Waitid(idType int, id int, info *Siginfo, options int, rusage *Rusage) (err error)</code></span>
<span class="codeline" id="line-379"><code></code></span>
<span class="codeline" id="line-380"><code>func Mkfifo(path string, mode uint32) error {</code></span>
<span class="codeline" id="line-381"><code>	return Mknod(path, mode|S_IFIFO, 0)</code></span>
<span class="codeline" id="line-382"><code>}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>func Mkfifoat(dirfd int, path string, mode uint32) error {</code></span>
<span class="codeline" id="line-385"><code>	return Mknodat(dirfd, path, mode|S_IFIFO, 0)</code></span>
<span class="codeline" id="line-386"><code>}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-389"><code>	if sa.Port &lt; 0 || sa.Port &gt; 0xFFFF {</code></span>
<span class="codeline" id="line-390"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-391"><code>	}</code></span>
<span class="codeline" id="line-392"><code>	sa.raw.Family = AF_INET</code></span>
<span class="codeline" id="line-393"><code>	p := (*[2]byte)(unsafe.Pointer(&amp;sa.raw.Port))</code></span>
<span class="codeline" id="line-394"><code>	p[0] = byte(sa.Port &gt;&gt; 8)</code></span>
<span class="codeline" id="line-395"><code>	p[1] = byte(sa.Port)</code></span>
<span class="codeline" id="line-396"><code>	sa.raw.Addr = sa.Addr</code></span>
<span class="codeline" id="line-397"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrInet4, nil</code></span>
<span class="codeline" id="line-398"><code>}</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-401"><code>	if sa.Port &lt; 0 || sa.Port &gt; 0xFFFF {</code></span>
<span class="codeline" id="line-402"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-403"><code>	}</code></span>
<span class="codeline" id="line-404"><code>	sa.raw.Family = AF_INET6</code></span>
<span class="codeline" id="line-405"><code>	p := (*[2]byte)(unsafe.Pointer(&amp;sa.raw.Port))</code></span>
<span class="codeline" id="line-406"><code>	p[0] = byte(sa.Port &gt;&gt; 8)</code></span>
<span class="codeline" id="line-407"><code>	p[1] = byte(sa.Port)</code></span>
<span class="codeline" id="line-408"><code>	sa.raw.Scope_id = sa.ZoneId</code></span>
<span class="codeline" id="line-409"><code>	sa.raw.Addr = sa.Addr</code></span>
<span class="codeline" id="line-410"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrInet6, nil</code></span>
<span class="codeline" id="line-411"><code>}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-414"><code>	name := sa.Name</code></span>
<span class="codeline" id="line-415"><code>	n := len(name)</code></span>
<span class="codeline" id="line-416"><code>	if n &gt;= len(sa.raw.Path) {</code></span>
<span class="codeline" id="line-417"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code>	sa.raw.Family = AF_UNIX</code></span>
<span class="codeline" id="line-420"><code>	for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-421"><code>		sa.raw.Path[i] = int8(name[i])</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code>	// length is family (uint16), name, NUL.</code></span>
<span class="codeline" id="line-424"><code>	sl := _Socklen(2)</code></span>
<span class="codeline" id="line-425"><code>	if n &gt; 0 {</code></span>
<span class="codeline" id="line-426"><code>		sl += _Socklen(n) + 1</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	if sa.raw.Path[0] == '@' || (sa.raw.Path[0] == 0 &amp;&amp; sl &gt; 3) {</code></span>
<span class="codeline" id="line-429"><code>		// Check sl &gt; 3 so we don't change unnamed socket behavior.</code></span>
<span class="codeline" id="line-430"><code>		sa.raw.Path[0] = 0</code></span>
<span class="codeline" id="line-431"><code>		// Don't count trailing NUL for abstract address.</code></span>
<span class="codeline" id="line-432"><code>		sl--</code></span>
<span class="codeline" id="line-433"><code>	}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>	return unsafe.Pointer(&amp;sa.raw), sl, nil</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>// SockaddrLinklayer implements the Sockaddr interface for AF_PACKET type sockets.</code></span>
<span class="codeline" id="line-439"><code>type SockaddrLinklayer struct {</code></span>
<span class="codeline" id="line-440"><code>	Protocol uint16</code></span>
<span class="codeline" id="line-441"><code>	Ifindex  int</code></span>
<span class="codeline" id="line-442"><code>	Hatype   uint16</code></span>
<span class="codeline" id="line-443"><code>	Pkttype  uint8</code></span>
<span class="codeline" id="line-444"><code>	Halen    uint8</code></span>
<span class="codeline" id="line-445"><code>	Addr     [8]byte</code></span>
<span class="codeline" id="line-446"><code>	raw      RawSockaddrLinklayer</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>func (sa *SockaddrLinklayer) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-450"><code>	if sa.Ifindex &lt; 0 || sa.Ifindex &gt; 0x7fffffff {</code></span>
<span class="codeline" id="line-451"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code>	sa.raw.Family = AF_PACKET</code></span>
<span class="codeline" id="line-454"><code>	sa.raw.Protocol = sa.Protocol</code></span>
<span class="codeline" id="line-455"><code>	sa.raw.Ifindex = int32(sa.Ifindex)</code></span>
<span class="codeline" id="line-456"><code>	sa.raw.Hatype = sa.Hatype</code></span>
<span class="codeline" id="line-457"><code>	sa.raw.Pkttype = sa.Pkttype</code></span>
<span class="codeline" id="line-458"><code>	sa.raw.Halen = sa.Halen</code></span>
<span class="codeline" id="line-459"><code>	sa.raw.Addr = sa.Addr</code></span>
<span class="codeline" id="line-460"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrLinklayer, nil</code></span>
<span class="codeline" id="line-461"><code>}</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>// SockaddrNetlink implements the Sockaddr interface for AF_NETLINK type sockets.</code></span>
<span class="codeline" id="line-464"><code>type SockaddrNetlink struct {</code></span>
<span class="codeline" id="line-465"><code>	Family uint16</code></span>
<span class="codeline" id="line-466"><code>	Pad    uint16</code></span>
<span class="codeline" id="line-467"><code>	Pid    uint32</code></span>
<span class="codeline" id="line-468"><code>	Groups uint32</code></span>
<span class="codeline" id="line-469"><code>	raw    RawSockaddrNetlink</code></span>
<span class="codeline" id="line-470"><code>}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>func (sa *SockaddrNetlink) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-473"><code>	sa.raw.Family = AF_NETLINK</code></span>
<span class="codeline" id="line-474"><code>	sa.raw.Pad = sa.Pad</code></span>
<span class="codeline" id="line-475"><code>	sa.raw.Pid = sa.Pid</code></span>
<span class="codeline" id="line-476"><code>	sa.raw.Groups = sa.Groups</code></span>
<span class="codeline" id="line-477"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrNetlink, nil</code></span>
<span class="codeline" id="line-478"><code>}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>// SockaddrHCI implements the Sockaddr interface for AF_BLUETOOTH type sockets</code></span>
<span class="codeline" id="line-481"><code>// using the HCI protocol.</code></span>
<span class="codeline" id="line-482"><code>type SockaddrHCI struct {</code></span>
<span class="codeline" id="line-483"><code>	Dev     uint16</code></span>
<span class="codeline" id="line-484"><code>	Channel uint16</code></span>
<span class="codeline" id="line-485"><code>	raw     RawSockaddrHCI</code></span>
<span class="codeline" id="line-486"><code>}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>func (sa *SockaddrHCI) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-489"><code>	sa.raw.Family = AF_BLUETOOTH</code></span>
<span class="codeline" id="line-490"><code>	sa.raw.Dev = sa.Dev</code></span>
<span class="codeline" id="line-491"><code>	sa.raw.Channel = sa.Channel</code></span>
<span class="codeline" id="line-492"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrHCI, nil</code></span>
<span class="codeline" id="line-493"><code>}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>// SockaddrL2 implements the Sockaddr interface for AF_BLUETOOTH type sockets</code></span>
<span class="codeline" id="line-496"><code>// using the L2CAP protocol.</code></span>
<span class="codeline" id="line-497"><code>type SockaddrL2 struct {</code></span>
<span class="codeline" id="line-498"><code>	PSM      uint16</code></span>
<span class="codeline" id="line-499"><code>	CID      uint16</code></span>
<span class="codeline" id="line-500"><code>	Addr     [6]uint8</code></span>
<span class="codeline" id="line-501"><code>	AddrType uint8</code></span>
<span class="codeline" id="line-502"><code>	raw      RawSockaddrL2</code></span>
<span class="codeline" id="line-503"><code>}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>func (sa *SockaddrL2) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-506"><code>	sa.raw.Family = AF_BLUETOOTH</code></span>
<span class="codeline" id="line-507"><code>	psm := (*[2]byte)(unsafe.Pointer(&amp;sa.raw.Psm))</code></span>
<span class="codeline" id="line-508"><code>	psm[0] = byte(sa.PSM)</code></span>
<span class="codeline" id="line-509"><code>	psm[1] = byte(sa.PSM &gt;&gt; 8)</code></span>
<span class="codeline" id="line-510"><code>	for i := 0; i &lt; len(sa.Addr); i++ {</code></span>
<span class="codeline" id="line-511"><code>		sa.raw.Bdaddr[i] = sa.Addr[len(sa.Addr)-1-i]</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code>	cid := (*[2]byte)(unsafe.Pointer(&amp;sa.raw.Cid))</code></span>
<span class="codeline" id="line-514"><code>	cid[0] = byte(sa.CID)</code></span>
<span class="codeline" id="line-515"><code>	cid[1] = byte(sa.CID &gt;&gt; 8)</code></span>
<span class="codeline" id="line-516"><code>	sa.raw.Bdaddr_type = sa.AddrType</code></span>
<span class="codeline" id="line-517"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrL2, nil</code></span>
<span class="codeline" id="line-518"><code>}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>// SockaddrRFCOMM implements the Sockaddr interface for AF_BLUETOOTH type sockets</code></span>
<span class="codeline" id="line-521"><code>// using the RFCOMM protocol.</code></span>
<span class="codeline" id="line-522"><code>//</code></span>
<span class="codeline" id="line-523"><code>// Server example:</code></span>
<span class="codeline" id="line-524"><code>//</code></span>
<span class="codeline" id="line-525"><code>//	fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)</code></span>
<span class="codeline" id="line-526"><code>//	_ = unix.Bind(fd, &amp;unix.SockaddrRFCOMM{</code></span>
<span class="codeline" id="line-527"><code>//		Channel: 1,</code></span>
<span class="codeline" id="line-528"><code>//		Addr:    [6]uint8{0, 0, 0, 0, 0, 0}, // BDADDR_ANY or 00:00:00:00:00:00</code></span>
<span class="codeline" id="line-529"><code>//	})</code></span>
<span class="codeline" id="line-530"><code>//	_ = Listen(fd, 1)</code></span>
<span class="codeline" id="line-531"><code>//	nfd, sa, _ := Accept(fd)</code></span>
<span class="codeline" id="line-532"><code>//	fmt.Printf("conn addr=%v fd=%d", sa.(*unix.SockaddrRFCOMM).Addr, nfd)</code></span>
<span class="codeline" id="line-533"><code>//	Read(nfd, buf)</code></span>
<span class="codeline" id="line-534"><code>//</code></span>
<span class="codeline" id="line-535"><code>// Client example:</code></span>
<span class="codeline" id="line-536"><code>//</code></span>
<span class="codeline" id="line-537"><code>//	fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)</code></span>
<span class="codeline" id="line-538"><code>//	_ = Connect(fd, &amp;SockaddrRFCOMM{</code></span>
<span class="codeline" id="line-539"><code>//		Channel: 1,</code></span>
<span class="codeline" id="line-540"><code>//		Addr:    [6]byte{0x11, 0x22, 0x33, 0xaa, 0xbb, 0xcc}, // CC:BB:AA:33:22:11</code></span>
<span class="codeline" id="line-541"><code>//	})</code></span>
<span class="codeline" id="line-542"><code>//	Write(fd, []byte(`hello`))</code></span>
<span class="codeline" id="line-543"><code>type SockaddrRFCOMM struct {</code></span>
<span class="codeline" id="line-544"><code>	// Addr represents a bluetooth address, byte ordering is little-endian.</code></span>
<span class="codeline" id="line-545"><code>	Addr [6]uint8</code></span>
<span class="codeline" id="line-546"><code></code></span>
<span class="codeline" id="line-547"><code>	// Channel is a designated bluetooth channel, only 1-30 are available for use.</code></span>
<span class="codeline" id="line-548"><code>	// Since Linux 2.6.7 and further zero value is the first available channel.</code></span>
<span class="codeline" id="line-549"><code>	Channel uint8</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>	raw RawSockaddrRFCOMM</code></span>
<span class="codeline" id="line-552"><code>}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>func (sa *SockaddrRFCOMM) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-555"><code>	sa.raw.Family = AF_BLUETOOTH</code></span>
<span class="codeline" id="line-556"><code>	sa.raw.Channel = sa.Channel</code></span>
<span class="codeline" id="line-557"><code>	sa.raw.Bdaddr = sa.Addr</code></span>
<span class="codeline" id="line-558"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrRFCOMM, nil</code></span>
<span class="codeline" id="line-559"><code>}</code></span>
<span class="codeline" id="line-560"><code></code></span>
<span class="codeline" id="line-561"><code>// SockaddrCAN implements the Sockaddr interface for AF_CAN type sockets.</code></span>
<span class="codeline" id="line-562"><code>// The RxID and TxID fields are used for transport protocol addressing in</code></span>
<span class="codeline" id="line-563"><code>// (CAN_TP16, CAN_TP20, CAN_MCNET, and CAN_ISOTP), they can be left with</code></span>
<span class="codeline" id="line-564"><code>// zero values for CAN_RAW and CAN_BCM sockets as they have no meaning.</code></span>
<span class="codeline" id="line-565"><code>//</code></span>
<span class="codeline" id="line-566"><code>// The SockaddrCAN struct must be bound to the socket file descriptor</code></span>
<span class="codeline" id="line-567"><code>// using Bind before the CAN socket can be used.</code></span>
<span class="codeline" id="line-568"><code>//</code></span>
<span class="codeline" id="line-569"><code>//	// Read one raw CAN frame</code></span>
<span class="codeline" id="line-570"><code>//	fd, _ := Socket(AF_CAN, SOCK_RAW, CAN_RAW)</code></span>
<span class="codeline" id="line-571"><code>//	addr := &amp;SockaddrCAN{Ifindex: index}</code></span>
<span class="codeline" id="line-572"><code>//	Bind(fd, addr)</code></span>
<span class="codeline" id="line-573"><code>//	frame := make([]byte, 16)</code></span>
<span class="codeline" id="line-574"><code>//	Read(fd, frame)</code></span>
<span class="codeline" id="line-575"><code>//</code></span>
<span class="codeline" id="line-576"><code>// The full SocketCAN documentation can be found in the linux kernel</code></span>
<span class="codeline" id="line-577"><code>// archives at: https://www.kernel.org/doc/Documentation/networking/can.txt</code></span>
<span class="codeline" id="line-578"><code>type SockaddrCAN struct {</code></span>
<span class="codeline" id="line-579"><code>	Ifindex int</code></span>
<span class="codeline" id="line-580"><code>	RxID    uint32</code></span>
<span class="codeline" id="line-581"><code>	TxID    uint32</code></span>
<span class="codeline" id="line-582"><code>	raw     RawSockaddrCAN</code></span>
<span class="codeline" id="line-583"><code>}</code></span>
<span class="codeline" id="line-584"><code></code></span>
<span class="codeline" id="line-585"><code>func (sa *SockaddrCAN) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-586"><code>	if sa.Ifindex &lt; 0 || sa.Ifindex &gt; 0x7fffffff {</code></span>
<span class="codeline" id="line-587"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-588"><code>	}</code></span>
<span class="codeline" id="line-589"><code>	sa.raw.Family = AF_CAN</code></span>
<span class="codeline" id="line-590"><code>	sa.raw.Ifindex = int32(sa.Ifindex)</code></span>
<span class="codeline" id="line-591"><code>	rx := (*[4]byte)(unsafe.Pointer(&amp;sa.RxID))</code></span>
<span class="codeline" id="line-592"><code>	for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-593"><code>		sa.raw.Addr[i] = rx[i]</code></span>
<span class="codeline" id="line-594"><code>	}</code></span>
<span class="codeline" id="line-595"><code>	tx := (*[4]byte)(unsafe.Pointer(&amp;sa.TxID))</code></span>
<span class="codeline" id="line-596"><code>	for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-597"><code>		sa.raw.Addr[i+4] = tx[i]</code></span>
<span class="codeline" id="line-598"><code>	}</code></span>
<span class="codeline" id="line-599"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrCAN, nil</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>// SockaddrCANJ1939 implements the Sockaddr interface for AF_CAN using J1939</code></span>
<span class="codeline" id="line-603"><code>// protocol (https://en.wikipedia.org/wiki/SAE_J1939). For more information</code></span>
<span class="codeline" id="line-604"><code>// on the purposes of the fields, check the official linux kernel documentation</code></span>
<span class="codeline" id="line-605"><code>// available here: https://www.kernel.org/doc/Documentation/networking/j1939.rst</code></span>
<span class="codeline" id="line-606"><code>type SockaddrCANJ1939 struct {</code></span>
<span class="codeline" id="line-607"><code>	Ifindex int</code></span>
<span class="codeline" id="line-608"><code>	Name    uint64</code></span>
<span class="codeline" id="line-609"><code>	PGN     uint32</code></span>
<span class="codeline" id="line-610"><code>	Addr    uint8</code></span>
<span class="codeline" id="line-611"><code>	raw     RawSockaddrCAN</code></span>
<span class="codeline" id="line-612"><code>}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>func (sa *SockaddrCANJ1939) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-615"><code>	if sa.Ifindex &lt; 0 || sa.Ifindex &gt; 0x7fffffff {</code></span>
<span class="codeline" id="line-616"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-617"><code>	}</code></span>
<span class="codeline" id="line-618"><code>	sa.raw.Family = AF_CAN</code></span>
<span class="codeline" id="line-619"><code>	sa.raw.Ifindex = int32(sa.Ifindex)</code></span>
<span class="codeline" id="line-620"><code>	n := (*[8]byte)(unsafe.Pointer(&amp;sa.Name))</code></span>
<span class="codeline" id="line-621"><code>	for i := 0; i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-622"><code>		sa.raw.Addr[i] = n[i]</code></span>
<span class="codeline" id="line-623"><code>	}</code></span>
<span class="codeline" id="line-624"><code>	p := (*[4]byte)(unsafe.Pointer(&amp;sa.PGN))</code></span>
<span class="codeline" id="line-625"><code>	for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-626"><code>		sa.raw.Addr[i+8] = p[i]</code></span>
<span class="codeline" id="line-627"><code>	}</code></span>
<span class="codeline" id="line-628"><code>	sa.raw.Addr[12] = sa.Addr</code></span>
<span class="codeline" id="line-629"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrCAN, nil</code></span>
<span class="codeline" id="line-630"><code>}</code></span>
<span class="codeline" id="line-631"><code></code></span>
<span class="codeline" id="line-632"><code>// SockaddrALG implements the Sockaddr interface for AF_ALG type sockets.</code></span>
<span class="codeline" id="line-633"><code>// SockaddrALG enables userspace access to the Linux kernel's cryptography</code></span>
<span class="codeline" id="line-634"><code>// subsystem. The Type and Name fields specify which type of hash or cipher</code></span>
<span class="codeline" id="line-635"><code>// should be used with a given socket.</code></span>
<span class="codeline" id="line-636"><code>//</code></span>
<span class="codeline" id="line-637"><code>// To create a file descriptor that provides access to a hash or cipher, both</code></span>
<span class="codeline" id="line-638"><code>// Bind and Accept must be used. Once the setup process is complete, input</code></span>
<span class="codeline" id="line-639"><code>// data can be written to the socket, processed by the kernel, and then read</code></span>
<span class="codeline" id="line-640"><code>// back as hash output or ciphertext.</code></span>
<span class="codeline" id="line-641"><code>//</code></span>
<span class="codeline" id="line-642"><code>// Here is an example of using an AF_ALG socket with SHA1 hashing.</code></span>
<span class="codeline" id="line-643"><code>// The initial socket setup process is as follows:</code></span>
<span class="codeline" id="line-644"><code>//</code></span>
<span class="codeline" id="line-645"><code>//	// Open a socket to perform SHA1 hashing.</code></span>
<span class="codeline" id="line-646"><code>//	fd, _ := unix.Socket(unix.AF_ALG, unix.SOCK_SEQPACKET, 0)</code></span>
<span class="codeline" id="line-647"><code>//	addr := &amp;unix.SockaddrALG{Type: "hash", Name: "sha1"}</code></span>
<span class="codeline" id="line-648"><code>//	unix.Bind(fd, addr)</code></span>
<span class="codeline" id="line-649"><code>//	// Note: unix.Accept does not work at this time; must invoke accept()</code></span>
<span class="codeline" id="line-650"><code>//	// manually using unix.Syscall.</code></span>
<span class="codeline" id="line-651"><code>//	hashfd, _, _ := unix.Syscall(unix.SYS_ACCEPT, uintptr(fd), 0, 0)</code></span>
<span class="codeline" id="line-652"><code>//</code></span>
<span class="codeline" id="line-653"><code>// Once a file descriptor has been returned from Accept, it may be used to</code></span>
<span class="codeline" id="line-654"><code>// perform SHA1 hashing. The descriptor is not safe for concurrent use, but</code></span>
<span class="codeline" id="line-655"><code>// may be re-used repeatedly with subsequent Write and Read operations.</code></span>
<span class="codeline" id="line-656"><code>//</code></span>
<span class="codeline" id="line-657"><code>// When hashing a small byte slice or string, a single Write and Read may</code></span>
<span class="codeline" id="line-658"><code>// be used:</code></span>
<span class="codeline" id="line-659"><code>//</code></span>
<span class="codeline" id="line-660"><code>//	// Assume hashfd is already configured using the setup process.</code></span>
<span class="codeline" id="line-661"><code>//	hash := os.NewFile(hashfd, "sha1")</code></span>
<span class="codeline" id="line-662"><code>//	// Hash an input string and read the results. Each Write discards</code></span>
<span class="codeline" id="line-663"><code>//	// previous hash state. Read always reads the current state.</code></span>
<span class="codeline" id="line-664"><code>//	b := make([]byte, 20)</code></span>
<span class="codeline" id="line-665"><code>//	for i := 0; i &lt; 2; i++ {</code></span>
<span class="codeline" id="line-666"><code>//	    io.WriteString(hash, "Hello, world.")</code></span>
<span class="codeline" id="line-667"><code>//	    hash.Read(b)</code></span>
<span class="codeline" id="line-668"><code>//	    fmt.Println(hex.EncodeToString(b))</code></span>
<span class="codeline" id="line-669"><code>//	}</code></span>
<span class="codeline" id="line-670"><code>//	// Output:</code></span>
<span class="codeline" id="line-671"><code>//	// 2ae01472317d1935a84797ec1983ae243fc6aa28</code></span>
<span class="codeline" id="line-672"><code>//	// 2ae01472317d1935a84797ec1983ae243fc6aa28</code></span>
<span class="codeline" id="line-673"><code>//</code></span>
<span class="codeline" id="line-674"><code>// For hashing larger byte slices, or byte streams such as those read from</code></span>
<span class="codeline" id="line-675"><code>// a file or socket, use Sendto with MSG_MORE to instruct the kernel to update</code></span>
<span class="codeline" id="line-676"><code>// the hash digest instead of creating a new one for a given chunk and finalizing it.</code></span>
<span class="codeline" id="line-677"><code>//</code></span>
<span class="codeline" id="line-678"><code>//	// Assume hashfd and addr are already configured using the setup process.</code></span>
<span class="codeline" id="line-679"><code>//	hash := os.NewFile(hashfd, "sha1")</code></span>
<span class="codeline" id="line-680"><code>//	// Hash the contents of a file.</code></span>
<span class="codeline" id="line-681"><code>//	f, _ := os.Open("/tmp/linux-4.10-rc7.tar.xz")</code></span>
<span class="codeline" id="line-682"><code>//	b := make([]byte, 4096)</code></span>
<span class="codeline" id="line-683"><code>//	for {</code></span>
<span class="codeline" id="line-684"><code>//	    n, err := f.Read(b)</code></span>
<span class="codeline" id="line-685"><code>//	    if err == io.EOF {</code></span>
<span class="codeline" id="line-686"><code>//	        break</code></span>
<span class="codeline" id="line-687"><code>//	    }</code></span>
<span class="codeline" id="line-688"><code>//	    unix.Sendto(hashfd, b[:n], unix.MSG_MORE, addr)</code></span>
<span class="codeline" id="line-689"><code>//	}</code></span>
<span class="codeline" id="line-690"><code>//	hash.Read(b)</code></span>
<span class="codeline" id="line-691"><code>//	fmt.Println(hex.EncodeToString(b))</code></span>
<span class="codeline" id="line-692"><code>//	// Output: 85cdcad0c06eef66f805ecce353bec9accbeecc5</code></span>
<span class="codeline" id="line-693"><code>//</code></span>
<span class="codeline" id="line-694"><code>// For more information, see: http://www.chronox.de/crypto-API/crypto/userspace-if.html.</code></span>
<span class="codeline" id="line-695"><code>type SockaddrALG struct {</code></span>
<span class="codeline" id="line-696"><code>	Type    string</code></span>
<span class="codeline" id="line-697"><code>	Name    string</code></span>
<span class="codeline" id="line-698"><code>	Feature uint32</code></span>
<span class="codeline" id="line-699"><code>	Mask    uint32</code></span>
<span class="codeline" id="line-700"><code>	raw     RawSockaddrALG</code></span>
<span class="codeline" id="line-701"><code>}</code></span>
<span class="codeline" id="line-702"><code></code></span>
<span class="codeline" id="line-703"><code>func (sa *SockaddrALG) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-704"><code>	// Leave room for NUL byte terminator.</code></span>
<span class="codeline" id="line-705"><code>	if len(sa.Type) &gt; len(sa.raw.Type)-1 {</code></span>
<span class="codeline" id="line-706"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	if len(sa.Name) &gt; len(sa.raw.Name)-1 {</code></span>
<span class="codeline" id="line-709"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-710"><code>	}</code></span>
<span class="codeline" id="line-711"><code></code></span>
<span class="codeline" id="line-712"><code>	sa.raw.Family = AF_ALG</code></span>
<span class="codeline" id="line-713"><code>	sa.raw.Feat = sa.Feature</code></span>
<span class="codeline" id="line-714"><code>	sa.raw.Mask = sa.Mask</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>	copy(sa.raw.Type[:], sa.Type)</code></span>
<span class="codeline" id="line-717"><code>	copy(sa.raw.Name[:], sa.Name)</code></span>
<span class="codeline" id="line-718"><code></code></span>
<span class="codeline" id="line-719"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrALG, nil</code></span>
<span class="codeline" id="line-720"><code>}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.</code></span>
<span class="codeline" id="line-723"><code>// SockaddrVM provides access to Linux VM sockets: a mechanism that enables</code></span>
<span class="codeline" id="line-724"><code>// bidirectional communication between a hypervisor and its guest virtual</code></span>
<span class="codeline" id="line-725"><code>// machines.</code></span>
<span class="codeline" id="line-726"><code>type SockaddrVM struct {</code></span>
<span class="codeline" id="line-727"><code>	// CID and Port specify a context ID and port address for a VM socket.</code></span>
<span class="codeline" id="line-728"><code>	// Guests have a unique CID, and hosts may have a well-known CID of:</code></span>
<span class="codeline" id="line-729"><code>	//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.</code></span>
<span class="codeline" id="line-730"><code>	//  - VMADDR_CID_LOCAL: refers to local communication (loopback).</code></span>
<span class="codeline" id="line-731"><code>	//  - VMADDR_CID_HOST: refers to other processes on the host.</code></span>
<span class="codeline" id="line-732"><code>	CID   uint32</code></span>
<span class="codeline" id="line-733"><code>	Port  uint32</code></span>
<span class="codeline" id="line-734"><code>	Flags uint8</code></span>
<span class="codeline" id="line-735"><code>	raw   RawSockaddrVM</code></span>
<span class="codeline" id="line-736"><code>}</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>func (sa *SockaddrVM) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-739"><code>	sa.raw.Family = AF_VSOCK</code></span>
<span class="codeline" id="line-740"><code>	sa.raw.Port = sa.Port</code></span>
<span class="codeline" id="line-741"><code>	sa.raw.Cid = sa.CID</code></span>
<span class="codeline" id="line-742"><code>	sa.raw.Flags = sa.Flags</code></span>
<span class="codeline" id="line-743"><code></code></span>
<span class="codeline" id="line-744"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrVM, nil</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>type SockaddrXDP struct {</code></span>
<span class="codeline" id="line-748"><code>	Flags        uint16</code></span>
<span class="codeline" id="line-749"><code>	Ifindex      uint32</code></span>
<span class="codeline" id="line-750"><code>	QueueID      uint32</code></span>
<span class="codeline" id="line-751"><code>	SharedUmemFD uint32</code></span>
<span class="codeline" id="line-752"><code>	raw          RawSockaddrXDP</code></span>
<span class="codeline" id="line-753"><code>}</code></span>
<span class="codeline" id="line-754"><code></code></span>
<span class="codeline" id="line-755"><code>func (sa *SockaddrXDP) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-756"><code>	sa.raw.Family = AF_XDP</code></span>
<span class="codeline" id="line-757"><code>	sa.raw.Flags = sa.Flags</code></span>
<span class="codeline" id="line-758"><code>	sa.raw.Ifindex = sa.Ifindex</code></span>
<span class="codeline" id="line-759"><code>	sa.raw.Queue_id = sa.QueueID</code></span>
<span class="codeline" id="line-760"><code>	sa.raw.Shared_umem_fd = sa.SharedUmemFD</code></span>
<span class="codeline" id="line-761"><code></code></span>
<span class="codeline" id="line-762"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrXDP, nil</code></span>
<span class="codeline" id="line-763"><code>}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>// This constant mirrors the #define of PX_PROTO_OE in</code></span>
<span class="codeline" id="line-766"><code>// linux/if_pppox.h. We're defining this by hand here instead of</code></span>
<span class="codeline" id="line-767"><code>// autogenerating through mkerrors.sh because including</code></span>
<span class="codeline" id="line-768"><code>// linux/if_pppox.h causes some declaration conflicts with other</code></span>
<span class="codeline" id="line-769"><code>// includes (linux/if_pppox.h includes linux/in.h, which conflicts</code></span>
<span class="codeline" id="line-770"><code>// with netinet/in.h). Given that we only need a single zero constant</code></span>
<span class="codeline" id="line-771"><code>// out of that file, it's cleaner to just define it by hand here.</code></span>
<span class="codeline" id="line-772"><code>const px_proto_oe = 0</code></span>
<span class="codeline" id="line-773"><code></code></span>
<span class="codeline" id="line-774"><code>type SockaddrPPPoE struct {</code></span>
<span class="codeline" id="line-775"><code>	SID    uint16</code></span>
<span class="codeline" id="line-776"><code>	Remote []byte</code></span>
<span class="codeline" id="line-777"><code>	Dev    string</code></span>
<span class="codeline" id="line-778"><code>	raw    RawSockaddrPPPoX</code></span>
<span class="codeline" id="line-779"><code>}</code></span>
<span class="codeline" id="line-780"><code></code></span>
<span class="codeline" id="line-781"><code>func (sa *SockaddrPPPoE) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-782"><code>	if len(sa.Remote) != 6 {</code></span>
<span class="codeline" id="line-783"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-784"><code>	}</code></span>
<span class="codeline" id="line-785"><code>	if len(sa.Dev) &gt; IFNAMSIZ-1 {</code></span>
<span class="codeline" id="line-786"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-787"><code>	}</code></span>
<span class="codeline" id="line-788"><code></code></span>
<span class="codeline" id="line-789"><code>	*(*uint16)(unsafe.Pointer(&amp;sa.raw[0])) = AF_PPPOX</code></span>
<span class="codeline" id="line-790"><code>	// This next field is in host-endian byte order. We can't use the</code></span>
<span class="codeline" id="line-791"><code>	// same unsafe pointer cast as above, because this value is not</code></span>
<span class="codeline" id="line-792"><code>	// 32-bit aligned and some architectures don't allow unaligned</code></span>
<span class="codeline" id="line-793"><code>	// access.</code></span>
<span class="codeline" id="line-794"><code>	//</code></span>
<span class="codeline" id="line-795"><code>	// However, the value of px_proto_oe is 0, so we can use</code></span>
<span class="codeline" id="line-796"><code>	// encoding/binary helpers to write the bytes without worrying</code></span>
<span class="codeline" id="line-797"><code>	// about the ordering.</code></span>
<span class="codeline" id="line-798"><code>	binary.BigEndian.PutUint32(sa.raw[2:6], px_proto_oe)</code></span>
<span class="codeline" id="line-799"><code>	// This field is deliberately big-endian, unlike the previous</code></span>
<span class="codeline" id="line-800"><code>	// one. The kernel expects SID to be in network byte order.</code></span>
<span class="codeline" id="line-801"><code>	binary.BigEndian.PutUint16(sa.raw[6:8], sa.SID)</code></span>
<span class="codeline" id="line-802"><code>	copy(sa.raw[8:14], sa.Remote)</code></span>
<span class="codeline" id="line-803"><code>	for i := 14; i &lt; 14+IFNAMSIZ; i++ {</code></span>
<span class="codeline" id="line-804"><code>		sa.raw[i] = 0</code></span>
<span class="codeline" id="line-805"><code>	}</code></span>
<span class="codeline" id="line-806"><code>	copy(sa.raw[14:], sa.Dev)</code></span>
<span class="codeline" id="line-807"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrPPPoX, nil</code></span>
<span class="codeline" id="line-808"><code>}</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>// SockaddrTIPC implements the Sockaddr interface for AF_TIPC type sockets.</code></span>
<span class="codeline" id="line-811"><code>// For more information on TIPC, see: http://tipc.sourceforge.net/.</code></span>
<span class="codeline" id="line-812"><code>type SockaddrTIPC struct {</code></span>
<span class="codeline" id="line-813"><code>	// Scope is the publication scopes when binding service/service range.</code></span>
<span class="codeline" id="line-814"><code>	// Should be set to TIPC_CLUSTER_SCOPE or TIPC_NODE_SCOPE.</code></span>
<span class="codeline" id="line-815"><code>	Scope int</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>	// Addr is the type of address used to manipulate a socket. Addr must be</code></span>
<span class="codeline" id="line-818"><code>	// one of:</code></span>
<span class="codeline" id="line-819"><code>	//  - *TIPCSocketAddr: "id" variant in the C addr union</code></span>
<span class="codeline" id="line-820"><code>	//  - *TIPCServiceRange: "nameseq" variant in the C addr union</code></span>
<span class="codeline" id="line-821"><code>	//  - *TIPCServiceName: "name" variant in the C addr union</code></span>
<span class="codeline" id="line-822"><code>	//</code></span>
<span class="codeline" id="line-823"><code>	// If nil, EINVAL will be returned when the structure is used.</code></span>
<span class="codeline" id="line-824"><code>	Addr TIPCAddr</code></span>
<span class="codeline" id="line-825"><code></code></span>
<span class="codeline" id="line-826"><code>	raw RawSockaddrTIPC</code></span>
<span class="codeline" id="line-827"><code>}</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>// TIPCAddr is implemented by types that can be used as an address for</code></span>
<span class="codeline" id="line-830"><code>// SockaddrTIPC. It is only implemented by *TIPCSocketAddr, *TIPCServiceRange,</code></span>
<span class="codeline" id="line-831"><code>// and *TIPCServiceName.</code></span>
<span class="codeline" id="line-832"><code>type TIPCAddr interface {</code></span>
<span class="codeline" id="line-833"><code>	tipcAddrtype() uint8</code></span>
<span class="codeline" id="line-834"><code>	tipcAddr() [12]byte</code></span>
<span class="codeline" id="line-835"><code>}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>func (sa *TIPCSocketAddr) tipcAddr() [12]byte {</code></span>
<span class="codeline" id="line-838"><code>	var out [12]byte</code></span>
<span class="codeline" id="line-839"><code>	copy(out[:], (*(*[unsafe.Sizeof(TIPCSocketAddr{})]byte)(unsafe.Pointer(sa)))[:])</code></span>
<span class="codeline" id="line-840"><code>	return out</code></span>
<span class="codeline" id="line-841"><code>}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>func (sa *TIPCSocketAddr) tipcAddrtype() uint8 { return TIPC_SOCKET_ADDR }</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>func (sa *TIPCServiceRange) tipcAddr() [12]byte {</code></span>
<span class="codeline" id="line-846"><code>	var out [12]byte</code></span>
<span class="codeline" id="line-847"><code>	copy(out[:], (*(*[unsafe.Sizeof(TIPCServiceRange{})]byte)(unsafe.Pointer(sa)))[:])</code></span>
<span class="codeline" id="line-848"><code>	return out</code></span>
<span class="codeline" id="line-849"><code>}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>func (sa *TIPCServiceRange) tipcAddrtype() uint8 { return TIPC_SERVICE_RANGE }</code></span>
<span class="codeline" id="line-852"><code></code></span>
<span class="codeline" id="line-853"><code>func (sa *TIPCServiceName) tipcAddr() [12]byte {</code></span>
<span class="codeline" id="line-854"><code>	var out [12]byte</code></span>
<span class="codeline" id="line-855"><code>	copy(out[:], (*(*[unsafe.Sizeof(TIPCServiceName{})]byte)(unsafe.Pointer(sa)))[:])</code></span>
<span class="codeline" id="line-856"><code>	return out</code></span>
<span class="codeline" id="line-857"><code>}</code></span>
<span class="codeline" id="line-858"><code></code></span>
<span class="codeline" id="line-859"><code>func (sa *TIPCServiceName) tipcAddrtype() uint8 { return TIPC_SERVICE_ADDR }</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>func (sa *SockaddrTIPC) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-862"><code>	if sa.Addr == nil {</code></span>
<span class="codeline" id="line-863"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-864"><code>	}</code></span>
<span class="codeline" id="line-865"><code>	sa.raw.Family = AF_TIPC</code></span>
<span class="codeline" id="line-866"><code>	sa.raw.Scope = int8(sa.Scope)</code></span>
<span class="codeline" id="line-867"><code>	sa.raw.Addrtype = sa.Addr.tipcAddrtype()</code></span>
<span class="codeline" id="line-868"><code>	sa.raw.Addr = sa.Addr.tipcAddr()</code></span>
<span class="codeline" id="line-869"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrTIPC, nil</code></span>
<span class="codeline" id="line-870"><code>}</code></span>
<span class="codeline" id="line-871"><code></code></span>
<span class="codeline" id="line-872"><code>// SockaddrL2TPIP implements the Sockaddr interface for IPPROTO_L2TP/AF_INET sockets.</code></span>
<span class="codeline" id="line-873"><code>type SockaddrL2TPIP struct {</code></span>
<span class="codeline" id="line-874"><code>	Addr   [4]byte</code></span>
<span class="codeline" id="line-875"><code>	ConnId uint32</code></span>
<span class="codeline" id="line-876"><code>	raw    RawSockaddrL2TPIP</code></span>
<span class="codeline" id="line-877"><code>}</code></span>
<span class="codeline" id="line-878"><code></code></span>
<span class="codeline" id="line-879"><code>func (sa *SockaddrL2TPIP) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-880"><code>	sa.raw.Family = AF_INET</code></span>
<span class="codeline" id="line-881"><code>	sa.raw.Conn_id = sa.ConnId</code></span>
<span class="codeline" id="line-882"><code>	sa.raw.Addr = sa.Addr</code></span>
<span class="codeline" id="line-883"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrL2TPIP, nil</code></span>
<span class="codeline" id="line-884"><code>}</code></span>
<span class="codeline" id="line-885"><code></code></span>
<span class="codeline" id="line-886"><code>// SockaddrL2TPIP6 implements the Sockaddr interface for IPPROTO_L2TP/AF_INET6 sockets.</code></span>
<span class="codeline" id="line-887"><code>type SockaddrL2TPIP6 struct {</code></span>
<span class="codeline" id="line-888"><code>	Addr   [16]byte</code></span>
<span class="codeline" id="line-889"><code>	ZoneId uint32</code></span>
<span class="codeline" id="line-890"><code>	ConnId uint32</code></span>
<span class="codeline" id="line-891"><code>	raw    RawSockaddrL2TPIP6</code></span>
<span class="codeline" id="line-892"><code>}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>func (sa *SockaddrL2TPIP6) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-895"><code>	sa.raw.Family = AF_INET6</code></span>
<span class="codeline" id="line-896"><code>	sa.raw.Conn_id = sa.ConnId</code></span>
<span class="codeline" id="line-897"><code>	sa.raw.Scope_id = sa.ZoneId</code></span>
<span class="codeline" id="line-898"><code>	sa.raw.Addr = sa.Addr</code></span>
<span class="codeline" id="line-899"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrL2TPIP6, nil</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// SockaddrIUCV implements the Sockaddr interface for AF_IUCV sockets.</code></span>
<span class="codeline" id="line-903"><code>type SockaddrIUCV struct {</code></span>
<span class="codeline" id="line-904"><code>	UserID string</code></span>
<span class="codeline" id="line-905"><code>	Name   string</code></span>
<span class="codeline" id="line-906"><code>	raw    RawSockaddrIUCV</code></span>
<span class="codeline" id="line-907"><code>}</code></span>
<span class="codeline" id="line-908"><code></code></span>
<span class="codeline" id="line-909"><code>func (sa *SockaddrIUCV) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-910"><code>	sa.raw.Family = AF_IUCV</code></span>
<span class="codeline" id="line-911"><code>	// These are EBCDIC encoded by the kernel, but we still need to pad them</code></span>
<span class="codeline" id="line-912"><code>	// with blanks. Initializing with blanks allows the caller to feed in either</code></span>
<span class="codeline" id="line-913"><code>	// a padded or an unpadded string.</code></span>
<span class="codeline" id="line-914"><code>	for i := 0; i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-915"><code>		sa.raw.Nodeid[i] = ' '</code></span>
<span class="codeline" id="line-916"><code>		sa.raw.User_id[i] = ' '</code></span>
<span class="codeline" id="line-917"><code>		sa.raw.Name[i] = ' '</code></span>
<span class="codeline" id="line-918"><code>	}</code></span>
<span class="codeline" id="line-919"><code>	if len(sa.UserID) &gt; 8 || len(sa.Name) &gt; 8 {</code></span>
<span class="codeline" id="line-920"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-921"><code>	}</code></span>
<span class="codeline" id="line-922"><code>	for i, b := range []byte(sa.UserID[:]) {</code></span>
<span class="codeline" id="line-923"><code>		sa.raw.User_id[i] = int8(b)</code></span>
<span class="codeline" id="line-924"><code>	}</code></span>
<span class="codeline" id="line-925"><code>	for i, b := range []byte(sa.Name[:]) {</code></span>
<span class="codeline" id="line-926"><code>		sa.raw.Name[i] = int8(b)</code></span>
<span class="codeline" id="line-927"><code>	}</code></span>
<span class="codeline" id="line-928"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrIUCV, nil</code></span>
<span class="codeline" id="line-929"><code>}</code></span>
<span class="codeline" id="line-930"><code></code></span>
<span class="codeline" id="line-931"><code>type SockaddrNFC struct {</code></span>
<span class="codeline" id="line-932"><code>	DeviceIdx   uint32</code></span>
<span class="codeline" id="line-933"><code>	TargetIdx   uint32</code></span>
<span class="codeline" id="line-934"><code>	NFCProtocol uint32</code></span>
<span class="codeline" id="line-935"><code>	raw         RawSockaddrNFC</code></span>
<span class="codeline" id="line-936"><code>}</code></span>
<span class="codeline" id="line-937"><code></code></span>
<span class="codeline" id="line-938"><code>func (sa *SockaddrNFC) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-939"><code>	sa.raw.Sa_family = AF_NFC</code></span>
<span class="codeline" id="line-940"><code>	sa.raw.Dev_idx = sa.DeviceIdx</code></span>
<span class="codeline" id="line-941"><code>	sa.raw.Target_idx = sa.TargetIdx</code></span>
<span class="codeline" id="line-942"><code>	sa.raw.Nfc_protocol = sa.NFCProtocol</code></span>
<span class="codeline" id="line-943"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrNFC, nil</code></span>
<span class="codeline" id="line-944"><code>}</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>type SockaddrNFCLLCP struct {</code></span>
<span class="codeline" id="line-947"><code>	DeviceIdx      uint32</code></span>
<span class="codeline" id="line-948"><code>	TargetIdx      uint32</code></span>
<span class="codeline" id="line-949"><code>	NFCProtocol    uint32</code></span>
<span class="codeline" id="line-950"><code>	DestinationSAP uint8</code></span>
<span class="codeline" id="line-951"><code>	SourceSAP      uint8</code></span>
<span class="codeline" id="line-952"><code>	ServiceName    string</code></span>
<span class="codeline" id="line-953"><code>	raw            RawSockaddrNFCLLCP</code></span>
<span class="codeline" id="line-954"><code>}</code></span>
<span class="codeline" id="line-955"><code></code></span>
<span class="codeline" id="line-956"><code>func (sa *SockaddrNFCLLCP) sockaddr() (unsafe.Pointer, _Socklen, error) {</code></span>
<span class="codeline" id="line-957"><code>	sa.raw.Sa_family = AF_NFC</code></span>
<span class="codeline" id="line-958"><code>	sa.raw.Dev_idx = sa.DeviceIdx</code></span>
<span class="codeline" id="line-959"><code>	sa.raw.Target_idx = sa.TargetIdx</code></span>
<span class="codeline" id="line-960"><code>	sa.raw.Nfc_protocol = sa.NFCProtocol</code></span>
<span class="codeline" id="line-961"><code>	sa.raw.Dsap = sa.DestinationSAP</code></span>
<span class="codeline" id="line-962"><code>	sa.raw.Ssap = sa.SourceSAP</code></span>
<span class="codeline" id="line-963"><code>	if len(sa.ServiceName) &gt; len(sa.raw.Service_name) {</code></span>
<span class="codeline" id="line-964"><code>		return nil, 0, EINVAL</code></span>
<span class="codeline" id="line-965"><code>	}</code></span>
<span class="codeline" id="line-966"><code>	copy(sa.raw.Service_name[:], sa.ServiceName)</code></span>
<span class="codeline" id="line-967"><code>	sa.raw.SetServiceNameLen(len(sa.ServiceName))</code></span>
<span class="codeline" id="line-968"><code>	return unsafe.Pointer(&amp;sa.raw), SizeofSockaddrNFCLLCP, nil</code></span>
<span class="codeline" id="line-969"><code>}</code></span>
<span class="codeline" id="line-970"><code></code></span>
<span class="codeline" id="line-971"><code>var socketProtocol = func(fd int) (int, error) {</code></span>
<span class="codeline" id="line-972"><code>	return GetsockoptInt(fd, SOL_SOCKET, SO_PROTOCOL)</code></span>
<span class="codeline" id="line-973"><code>}</code></span>
<span class="codeline" id="line-974"><code></code></span>
<span class="codeline" id="line-975"><code>func anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) {</code></span>
<span class="codeline" id="line-976"><code>	switch rsa.Addr.Family {</code></span>
<span class="codeline" id="line-977"><code>	case AF_NETLINK:</code></span>
<span class="codeline" id="line-978"><code>		pp := (*RawSockaddrNetlink)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-979"><code>		sa := new(SockaddrNetlink)</code></span>
<span class="codeline" id="line-980"><code>		sa.Family = pp.Family</code></span>
<span class="codeline" id="line-981"><code>		sa.Pad = pp.Pad</code></span>
<span class="codeline" id="line-982"><code>		sa.Pid = pp.Pid</code></span>
<span class="codeline" id="line-983"><code>		sa.Groups = pp.Groups</code></span>
<span class="codeline" id="line-984"><code>		return sa, nil</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>	case AF_PACKET:</code></span>
<span class="codeline" id="line-987"><code>		pp := (*RawSockaddrLinklayer)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-988"><code>		sa := new(SockaddrLinklayer)</code></span>
<span class="codeline" id="line-989"><code>		sa.Protocol = pp.Protocol</code></span>
<span class="codeline" id="line-990"><code>		sa.Ifindex = int(pp.Ifindex)</code></span>
<span class="codeline" id="line-991"><code>		sa.Hatype = pp.Hatype</code></span>
<span class="codeline" id="line-992"><code>		sa.Pkttype = pp.Pkttype</code></span>
<span class="codeline" id="line-993"><code>		sa.Halen = pp.Halen</code></span>
<span class="codeline" id="line-994"><code>		sa.Addr = pp.Addr</code></span>
<span class="codeline" id="line-995"><code>		return sa, nil</code></span>
<span class="codeline" id="line-996"><code></code></span>
<span class="codeline" id="line-997"><code>	case AF_UNIX:</code></span>
<span class="codeline" id="line-998"><code>		pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-999"><code>		sa := new(SockaddrUnix)</code></span>
<span class="codeline" id="line-1000"><code>		if pp.Path[0] == 0 {</code></span>
<span class="codeline" id="line-1001"><code>			// "Abstract" Unix domain socket.</code></span>
<span class="codeline" id="line-1002"><code>			// Rewrite leading NUL as @ for textual display.</code></span>
<span class="codeline" id="line-1003"><code>			// (This is the standard convention.)</code></span>
<span class="codeline" id="line-1004"><code>			// Not friendly to overwrite in place,</code></span>
<span class="codeline" id="line-1005"><code>			// but the callers below don't care.</code></span>
<span class="codeline" id="line-1006"><code>			pp.Path[0] = '@'</code></span>
<span class="codeline" id="line-1007"><code>		}</code></span>
<span class="codeline" id="line-1008"><code></code></span>
<span class="codeline" id="line-1009"><code>		// Assume path ends at NUL.</code></span>
<span class="codeline" id="line-1010"><code>		// This is not technically the Linux semantics for</code></span>
<span class="codeline" id="line-1011"><code>		// abstract Unix domain sockets--they are supposed</code></span>
<span class="codeline" id="line-1012"><code>		// to be uninterpreted fixed-size binary blobs--but</code></span>
<span class="codeline" id="line-1013"><code>		// everyone uses this convention.</code></span>
<span class="codeline" id="line-1014"><code>		n := 0</code></span>
<span class="codeline" id="line-1015"><code>		for n &lt; len(pp.Path) &amp;&amp; pp.Path[n] != 0 {</code></span>
<span class="codeline" id="line-1016"><code>			n++</code></span>
<span class="codeline" id="line-1017"><code>		}</code></span>
<span class="codeline" id="line-1018"><code>		sa.Name = string(unsafe.Slice((*byte)(unsafe.Pointer(&amp;pp.Path[0])), n))</code></span>
<span class="codeline" id="line-1019"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1020"><code></code></span>
<span class="codeline" id="line-1021"><code>	case AF_INET:</code></span>
<span class="codeline" id="line-1022"><code>		proto, err := socketProtocol(fd)</code></span>
<span class="codeline" id="line-1023"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1024"><code>			return nil, err</code></span>
<span class="codeline" id="line-1025"><code>		}</code></span>
<span class="codeline" id="line-1026"><code></code></span>
<span class="codeline" id="line-1027"><code>		switch proto {</code></span>
<span class="codeline" id="line-1028"><code>		case IPPROTO_L2TP:</code></span>
<span class="codeline" id="line-1029"><code>			pp := (*RawSockaddrL2TPIP)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1030"><code>			sa := new(SockaddrL2TPIP)</code></span>
<span class="codeline" id="line-1031"><code>			sa.ConnId = pp.Conn_id</code></span>
<span class="codeline" id="line-1032"><code>			sa.Addr = pp.Addr</code></span>
<span class="codeline" id="line-1033"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1034"><code>		default:</code></span>
<span class="codeline" id="line-1035"><code>			pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1036"><code>			sa := new(SockaddrInet4)</code></span>
<span class="codeline" id="line-1037"><code>			p := (*[2]byte)(unsafe.Pointer(&amp;pp.Port))</code></span>
<span class="codeline" id="line-1038"><code>			sa.Port = int(p[0])&lt;&lt;8 + int(p[1])</code></span>
<span class="codeline" id="line-1039"><code>			sa.Addr = pp.Addr</code></span>
<span class="codeline" id="line-1040"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1041"><code>		}</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>	case AF_INET6:</code></span>
<span class="codeline" id="line-1044"><code>		proto, err := socketProtocol(fd)</code></span>
<span class="codeline" id="line-1045"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1046"><code>			return nil, err</code></span>
<span class="codeline" id="line-1047"><code>		}</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>		switch proto {</code></span>
<span class="codeline" id="line-1050"><code>		case IPPROTO_L2TP:</code></span>
<span class="codeline" id="line-1051"><code>			pp := (*RawSockaddrL2TPIP6)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1052"><code>			sa := new(SockaddrL2TPIP6)</code></span>
<span class="codeline" id="line-1053"><code>			sa.ConnId = pp.Conn_id</code></span>
<span class="codeline" id="line-1054"><code>			sa.ZoneId = pp.Scope_id</code></span>
<span class="codeline" id="line-1055"><code>			sa.Addr = pp.Addr</code></span>
<span class="codeline" id="line-1056"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1057"><code>		default:</code></span>
<span class="codeline" id="line-1058"><code>			pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1059"><code>			sa := new(SockaddrInet6)</code></span>
<span class="codeline" id="line-1060"><code>			p := (*[2]byte)(unsafe.Pointer(&amp;pp.Port))</code></span>
<span class="codeline" id="line-1061"><code>			sa.Port = int(p[0])&lt;&lt;8 + int(p[1])</code></span>
<span class="codeline" id="line-1062"><code>			sa.ZoneId = pp.Scope_id</code></span>
<span class="codeline" id="line-1063"><code>			sa.Addr = pp.Addr</code></span>
<span class="codeline" id="line-1064"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1065"><code>		}</code></span>
<span class="codeline" id="line-1066"><code></code></span>
<span class="codeline" id="line-1067"><code>	case AF_VSOCK:</code></span>
<span class="codeline" id="line-1068"><code>		pp := (*RawSockaddrVM)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1069"><code>		sa := &amp;SockaddrVM{</code></span>
<span class="codeline" id="line-1070"><code>			CID:   pp.Cid,</code></span>
<span class="codeline" id="line-1071"><code>			Port:  pp.Port,</code></span>
<span class="codeline" id="line-1072"><code>			Flags: pp.Flags,</code></span>
<span class="codeline" id="line-1073"><code>		}</code></span>
<span class="codeline" id="line-1074"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1075"><code>	case AF_BLUETOOTH:</code></span>
<span class="codeline" id="line-1076"><code>		proto, err := socketProtocol(fd)</code></span>
<span class="codeline" id="line-1077"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1078"><code>			return nil, err</code></span>
<span class="codeline" id="line-1079"><code>		}</code></span>
<span class="codeline" id="line-1080"><code>		// only BTPROTO_L2CAP and BTPROTO_RFCOMM can accept connections</code></span>
<span class="codeline" id="line-1081"><code>		switch proto {</code></span>
<span class="codeline" id="line-1082"><code>		case BTPROTO_L2CAP:</code></span>
<span class="codeline" id="line-1083"><code>			pp := (*RawSockaddrL2)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1084"><code>			sa := &amp;SockaddrL2{</code></span>
<span class="codeline" id="line-1085"><code>				PSM:      pp.Psm,</code></span>
<span class="codeline" id="line-1086"><code>				CID:      pp.Cid,</code></span>
<span class="codeline" id="line-1087"><code>				Addr:     pp.Bdaddr,</code></span>
<span class="codeline" id="line-1088"><code>				AddrType: pp.Bdaddr_type,</code></span>
<span class="codeline" id="line-1089"><code>			}</code></span>
<span class="codeline" id="line-1090"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1091"><code>		case BTPROTO_RFCOMM:</code></span>
<span class="codeline" id="line-1092"><code>			pp := (*RawSockaddrRFCOMM)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1093"><code>			sa := &amp;SockaddrRFCOMM{</code></span>
<span class="codeline" id="line-1094"><code>				Channel: pp.Channel,</code></span>
<span class="codeline" id="line-1095"><code>				Addr:    pp.Bdaddr,</code></span>
<span class="codeline" id="line-1096"><code>			}</code></span>
<span class="codeline" id="line-1097"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1098"><code>		}</code></span>
<span class="codeline" id="line-1099"><code>	case AF_XDP:</code></span>
<span class="codeline" id="line-1100"><code>		pp := (*RawSockaddrXDP)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1101"><code>		sa := &amp;SockaddrXDP{</code></span>
<span class="codeline" id="line-1102"><code>			Flags:        pp.Flags,</code></span>
<span class="codeline" id="line-1103"><code>			Ifindex:      pp.Ifindex,</code></span>
<span class="codeline" id="line-1104"><code>			QueueID:      pp.Queue_id,</code></span>
<span class="codeline" id="line-1105"><code>			SharedUmemFD: pp.Shared_umem_fd,</code></span>
<span class="codeline" id="line-1106"><code>		}</code></span>
<span class="codeline" id="line-1107"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1108"><code>	case AF_PPPOX:</code></span>
<span class="codeline" id="line-1109"><code>		pp := (*RawSockaddrPPPoX)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1110"><code>		if binary.BigEndian.Uint32(pp[2:6]) != px_proto_oe {</code></span>
<span class="codeline" id="line-1111"><code>			return nil, EINVAL</code></span>
<span class="codeline" id="line-1112"><code>		}</code></span>
<span class="codeline" id="line-1113"><code>		sa := &amp;SockaddrPPPoE{</code></span>
<span class="codeline" id="line-1114"><code>			SID:    binary.BigEndian.Uint16(pp[6:8]),</code></span>
<span class="codeline" id="line-1115"><code>			Remote: pp[8:14],</code></span>
<span class="codeline" id="line-1116"><code>		}</code></span>
<span class="codeline" id="line-1117"><code>		for i := 14; i &lt; 14+IFNAMSIZ; i++ {</code></span>
<span class="codeline" id="line-1118"><code>			if pp[i] == 0 {</code></span>
<span class="codeline" id="line-1119"><code>				sa.Dev = string(pp[14:i])</code></span>
<span class="codeline" id="line-1120"><code>				break</code></span>
<span class="codeline" id="line-1121"><code>			}</code></span>
<span class="codeline" id="line-1122"><code>		}</code></span>
<span class="codeline" id="line-1123"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1124"><code>	case AF_TIPC:</code></span>
<span class="codeline" id="line-1125"><code>		pp := (*RawSockaddrTIPC)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1126"><code></code></span>
<span class="codeline" id="line-1127"><code>		sa := &amp;SockaddrTIPC{</code></span>
<span class="codeline" id="line-1128"><code>			Scope: int(pp.Scope),</code></span>
<span class="codeline" id="line-1129"><code>		}</code></span>
<span class="codeline" id="line-1130"><code></code></span>
<span class="codeline" id="line-1131"><code>		// Determine which union variant is present in pp.Addr by checking</code></span>
<span class="codeline" id="line-1132"><code>		// pp.Addrtype.</code></span>
<span class="codeline" id="line-1133"><code>		switch pp.Addrtype {</code></span>
<span class="codeline" id="line-1134"><code>		case TIPC_SERVICE_RANGE:</code></span>
<span class="codeline" id="line-1135"><code>			sa.Addr = (*TIPCServiceRange)(unsafe.Pointer(&amp;pp.Addr))</code></span>
<span class="codeline" id="line-1136"><code>		case TIPC_SERVICE_ADDR:</code></span>
<span class="codeline" id="line-1137"><code>			sa.Addr = (*TIPCServiceName)(unsafe.Pointer(&amp;pp.Addr))</code></span>
<span class="codeline" id="line-1138"><code>		case TIPC_SOCKET_ADDR:</code></span>
<span class="codeline" id="line-1139"><code>			sa.Addr = (*TIPCSocketAddr)(unsafe.Pointer(&amp;pp.Addr))</code></span>
<span class="codeline" id="line-1140"><code>		default:</code></span>
<span class="codeline" id="line-1141"><code>			return nil, EINVAL</code></span>
<span class="codeline" id="line-1142"><code>		}</code></span>
<span class="codeline" id="line-1143"><code></code></span>
<span class="codeline" id="line-1144"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1145"><code>	case AF_IUCV:</code></span>
<span class="codeline" id="line-1146"><code>		pp := (*RawSockaddrIUCV)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1147"><code></code></span>
<span class="codeline" id="line-1148"><code>		var user [8]byte</code></span>
<span class="codeline" id="line-1149"><code>		var name [8]byte</code></span>
<span class="codeline" id="line-1150"><code></code></span>
<span class="codeline" id="line-1151"><code>		for i := 0; i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-1152"><code>			user[i] = byte(pp.User_id[i])</code></span>
<span class="codeline" id="line-1153"><code>			name[i] = byte(pp.Name[i])</code></span>
<span class="codeline" id="line-1154"><code>		}</code></span>
<span class="codeline" id="line-1155"><code></code></span>
<span class="codeline" id="line-1156"><code>		sa := &amp;SockaddrIUCV{</code></span>
<span class="codeline" id="line-1157"><code>			UserID: string(user[:]),</code></span>
<span class="codeline" id="line-1158"><code>			Name:   string(name[:]),</code></span>
<span class="codeline" id="line-1159"><code>		}</code></span>
<span class="codeline" id="line-1160"><code>		return sa, nil</code></span>
<span class="codeline" id="line-1161"><code></code></span>
<span class="codeline" id="line-1162"><code>	case AF_CAN:</code></span>
<span class="codeline" id="line-1163"><code>		proto, err := socketProtocol(fd)</code></span>
<span class="codeline" id="line-1164"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1165"><code>			return nil, err</code></span>
<span class="codeline" id="line-1166"><code>		}</code></span>
<span class="codeline" id="line-1167"><code></code></span>
<span class="codeline" id="line-1168"><code>		pp := (*RawSockaddrCAN)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1169"><code></code></span>
<span class="codeline" id="line-1170"><code>		switch proto {</code></span>
<span class="codeline" id="line-1171"><code>		case CAN_J1939:</code></span>
<span class="codeline" id="line-1172"><code>			sa := &amp;SockaddrCANJ1939{</code></span>
<span class="codeline" id="line-1173"><code>				Ifindex: int(pp.Ifindex),</code></span>
<span class="codeline" id="line-1174"><code>			}</code></span>
<span class="codeline" id="line-1175"><code>			name := (*[8]byte)(unsafe.Pointer(&amp;sa.Name))</code></span>
<span class="codeline" id="line-1176"><code>			for i := 0; i &lt; 8; i++ {</code></span>
<span class="codeline" id="line-1177"><code>				name[i] = pp.Addr[i]</code></span>
<span class="codeline" id="line-1178"><code>			}</code></span>
<span class="codeline" id="line-1179"><code>			pgn := (*[4]byte)(unsafe.Pointer(&amp;sa.PGN))</code></span>
<span class="codeline" id="line-1180"><code>			for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-1181"><code>				pgn[i] = pp.Addr[i+8]</code></span>
<span class="codeline" id="line-1182"><code>			}</code></span>
<span class="codeline" id="line-1183"><code>			addr := (*[1]byte)(unsafe.Pointer(&amp;sa.Addr))</code></span>
<span class="codeline" id="line-1184"><code>			addr[0] = pp.Addr[12]</code></span>
<span class="codeline" id="line-1185"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1186"><code>		default:</code></span>
<span class="codeline" id="line-1187"><code>			sa := &amp;SockaddrCAN{</code></span>
<span class="codeline" id="line-1188"><code>				Ifindex: int(pp.Ifindex),</code></span>
<span class="codeline" id="line-1189"><code>			}</code></span>
<span class="codeline" id="line-1190"><code>			rx := (*[4]byte)(unsafe.Pointer(&amp;sa.RxID))</code></span>
<span class="codeline" id="line-1191"><code>			for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-1192"><code>				rx[i] = pp.Addr[i]</code></span>
<span class="codeline" id="line-1193"><code>			}</code></span>
<span class="codeline" id="line-1194"><code>			tx := (*[4]byte)(unsafe.Pointer(&amp;sa.TxID))</code></span>
<span class="codeline" id="line-1195"><code>			for i := 0; i &lt; 4; i++ {</code></span>
<span class="codeline" id="line-1196"><code>				tx[i] = pp.Addr[i+4]</code></span>
<span class="codeline" id="line-1197"><code>			}</code></span>
<span class="codeline" id="line-1198"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1199"><code>		}</code></span>
<span class="codeline" id="line-1200"><code>	case AF_NFC:</code></span>
<span class="codeline" id="line-1201"><code>		proto, err := socketProtocol(fd)</code></span>
<span class="codeline" id="line-1202"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1203"><code>			return nil, err</code></span>
<span class="codeline" id="line-1204"><code>		}</code></span>
<span class="codeline" id="line-1205"><code>		switch proto {</code></span>
<span class="codeline" id="line-1206"><code>		case NFC_SOCKPROTO_RAW:</code></span>
<span class="codeline" id="line-1207"><code>			pp := (*RawSockaddrNFC)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1208"><code>			sa := &amp;SockaddrNFC{</code></span>
<span class="codeline" id="line-1209"><code>				DeviceIdx:   pp.Dev_idx,</code></span>
<span class="codeline" id="line-1210"><code>				TargetIdx:   pp.Target_idx,</code></span>
<span class="codeline" id="line-1211"><code>				NFCProtocol: pp.Nfc_protocol,</code></span>
<span class="codeline" id="line-1212"><code>			}</code></span>
<span class="codeline" id="line-1213"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1214"><code>		case NFC_SOCKPROTO_LLCP:</code></span>
<span class="codeline" id="line-1215"><code>			pp := (*RawSockaddrNFCLLCP)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1216"><code>			if uint64(pp.Service_name_len) &gt; uint64(len(pp.Service_name)) {</code></span>
<span class="codeline" id="line-1217"><code>				return nil, EINVAL</code></span>
<span class="codeline" id="line-1218"><code>			}</code></span>
<span class="codeline" id="line-1219"><code>			sa := &amp;SockaddrNFCLLCP{</code></span>
<span class="codeline" id="line-1220"><code>				DeviceIdx:      pp.Dev_idx,</code></span>
<span class="codeline" id="line-1221"><code>				TargetIdx:      pp.Target_idx,</code></span>
<span class="codeline" id="line-1222"><code>				NFCProtocol:    pp.Nfc_protocol,</code></span>
<span class="codeline" id="line-1223"><code>				DestinationSAP: pp.Dsap,</code></span>
<span class="codeline" id="line-1224"><code>				SourceSAP:      pp.Ssap,</code></span>
<span class="codeline" id="line-1225"><code>				ServiceName:    string(pp.Service_name[:pp.Service_name_len]),</code></span>
<span class="codeline" id="line-1226"><code>			}</code></span>
<span class="codeline" id="line-1227"><code>			return sa, nil</code></span>
<span class="codeline" id="line-1228"><code>		default:</code></span>
<span class="codeline" id="line-1229"><code>			return nil, EINVAL</code></span>
<span class="codeline" id="line-1230"><code>		}</code></span>
<span class="codeline" id="line-1231"><code>	}</code></span>
<span class="codeline" id="line-1232"><code>	return nil, EAFNOSUPPORT</code></span>
<span class="codeline" id="line-1233"><code>}</code></span>
<span class="codeline" id="line-1234"><code></code></span>
<span class="codeline" id="line-1235"><code>func Accept(fd int) (nfd int, sa Sockaddr, err error) {</code></span>
<span class="codeline" id="line-1236"><code>	var rsa RawSockaddrAny</code></span>
<span class="codeline" id="line-1237"><code>	var len _Socklen = SizeofSockaddrAny</code></span>
<span class="codeline" id="line-1238"><code>	nfd, err = accept4(fd, &amp;rsa, &amp;len, 0)</code></span>
<span class="codeline" id="line-1239"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1240"><code>		return</code></span>
<span class="codeline" id="line-1241"><code>	}</code></span>
<span class="codeline" id="line-1242"><code>	sa, err = anyToSockaddr(fd, &amp;rsa)</code></span>
<span class="codeline" id="line-1243"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1244"><code>		Close(nfd)</code></span>
<span class="codeline" id="line-1245"><code>		nfd = 0</code></span>
<span class="codeline" id="line-1246"><code>	}</code></span>
<span class="codeline" id="line-1247"><code>	return</code></span>
<span class="codeline" id="line-1248"><code>}</code></span>
<span class="codeline" id="line-1249"><code></code></span>
<span class="codeline" id="line-1250"><code>func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) {</code></span>
<span class="codeline" id="line-1251"><code>	var rsa RawSockaddrAny</code></span>
<span class="codeline" id="line-1252"><code>	var len _Socklen = SizeofSockaddrAny</code></span>
<span class="codeline" id="line-1253"><code>	nfd, err = accept4(fd, &amp;rsa, &amp;len, flags)</code></span>
<span class="codeline" id="line-1254"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1255"><code>		return</code></span>
<span class="codeline" id="line-1256"><code>	}</code></span>
<span class="codeline" id="line-1257"><code>	if len &gt; SizeofSockaddrAny {</code></span>
<span class="codeline" id="line-1258"><code>		panic("RawSockaddrAny too small")</code></span>
<span class="codeline" id="line-1259"><code>	}</code></span>
<span class="codeline" id="line-1260"><code>	sa, err = anyToSockaddr(fd, &amp;rsa)</code></span>
<span class="codeline" id="line-1261"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1262"><code>		Close(nfd)</code></span>
<span class="codeline" id="line-1263"><code>		nfd = 0</code></span>
<span class="codeline" id="line-1264"><code>	}</code></span>
<span class="codeline" id="line-1265"><code>	return</code></span>
<span class="codeline" id="line-1266"><code>}</code></span>
<span class="codeline" id="line-1267"><code></code></span>
<span class="codeline" id="line-1268"><code>func Getsockname(fd int) (sa Sockaddr, err error) {</code></span>
<span class="codeline" id="line-1269"><code>	var rsa RawSockaddrAny</code></span>
<span class="codeline" id="line-1270"><code>	var len _Socklen = SizeofSockaddrAny</code></span>
<span class="codeline" id="line-1271"><code>	if err = getsockname(fd, &amp;rsa, &amp;len); err != nil {</code></span>
<span class="codeline" id="line-1272"><code>		return</code></span>
<span class="codeline" id="line-1273"><code>	}</code></span>
<span class="codeline" id="line-1274"><code>	return anyToSockaddr(fd, &amp;rsa)</code></span>
<span class="codeline" id="line-1275"><code>}</code></span>
<span class="codeline" id="line-1276"><code></code></span>
<span class="codeline" id="line-1277"><code>func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) {</code></span>
<span class="codeline" id="line-1278"><code>	var value IPMreqn</code></span>
<span class="codeline" id="line-1279"><code>	vallen := _Socklen(SizeofIPMreqn)</code></span>
<span class="codeline" id="line-1280"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;value), &amp;vallen)</code></span>
<span class="codeline" id="line-1281"><code>	return &amp;value, err</code></span>
<span class="codeline" id="line-1282"><code>}</code></span>
<span class="codeline" id="line-1283"><code></code></span>
<span class="codeline" id="line-1284"><code>func GetsockoptUcred(fd, level, opt int) (*Ucred, error) {</code></span>
<span class="codeline" id="line-1285"><code>	var value Ucred</code></span>
<span class="codeline" id="line-1286"><code>	vallen := _Socklen(SizeofUcred)</code></span>
<span class="codeline" id="line-1287"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;value), &amp;vallen)</code></span>
<span class="codeline" id="line-1288"><code>	return &amp;value, err</code></span>
<span class="codeline" id="line-1289"><code>}</code></span>
<span class="codeline" id="line-1290"><code></code></span>
<span class="codeline" id="line-1291"><code>func GetsockoptTCPInfo(fd, level, opt int) (*TCPInfo, error) {</code></span>
<span class="codeline" id="line-1292"><code>	var value TCPInfo</code></span>
<span class="codeline" id="line-1293"><code>	vallen := _Socklen(SizeofTCPInfo)</code></span>
<span class="codeline" id="line-1294"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;value), &amp;vallen)</code></span>
<span class="codeline" id="line-1295"><code>	return &amp;value, err</code></span>
<span class="codeline" id="line-1296"><code>}</code></span>
<span class="codeline" id="line-1297"><code></code></span>
<span class="codeline" id="line-1298"><code>// GetsockoptString returns the string value of the socket option opt for the</code></span>
<span class="codeline" id="line-1299"><code>// socket associated with fd at the given socket level.</code></span>
<span class="codeline" id="line-1300"><code>func GetsockoptString(fd, level, opt int) (string, error) {</code></span>
<span class="codeline" id="line-1301"><code>	buf := make([]byte, 256)</code></span>
<span class="codeline" id="line-1302"><code>	vallen := _Socklen(len(buf))</code></span>
<span class="codeline" id="line-1303"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;buf[0]), &amp;vallen)</code></span>
<span class="codeline" id="line-1304"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1305"><code>		if err == ERANGE {</code></span>
<span class="codeline" id="line-1306"><code>			buf = make([]byte, vallen)</code></span>
<span class="codeline" id="line-1307"><code>			err = getsockopt(fd, level, opt, unsafe.Pointer(&amp;buf[0]), &amp;vallen)</code></span>
<span class="codeline" id="line-1308"><code>		}</code></span>
<span class="codeline" id="line-1309"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1310"><code>			return "", err</code></span>
<span class="codeline" id="line-1311"><code>		}</code></span>
<span class="codeline" id="line-1312"><code>	}</code></span>
<span class="codeline" id="line-1313"><code>	return ByteSliceToString(buf[:vallen]), nil</code></span>
<span class="codeline" id="line-1314"><code>}</code></span>
<span class="codeline" id="line-1315"><code></code></span>
<span class="codeline" id="line-1316"><code>func GetsockoptTpacketStats(fd, level, opt int) (*TpacketStats, error) {</code></span>
<span class="codeline" id="line-1317"><code>	var value TpacketStats</code></span>
<span class="codeline" id="line-1318"><code>	vallen := _Socklen(SizeofTpacketStats)</code></span>
<span class="codeline" id="line-1319"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;value), &amp;vallen)</code></span>
<span class="codeline" id="line-1320"><code>	return &amp;value, err</code></span>
<span class="codeline" id="line-1321"><code>}</code></span>
<span class="codeline" id="line-1322"><code></code></span>
<span class="codeline" id="line-1323"><code>func GetsockoptTpacketStatsV3(fd, level, opt int) (*TpacketStatsV3, error) {</code></span>
<span class="codeline" id="line-1324"><code>	var value TpacketStatsV3</code></span>
<span class="codeline" id="line-1325"><code>	vallen := _Socklen(SizeofTpacketStatsV3)</code></span>
<span class="codeline" id="line-1326"><code>	err := getsockopt(fd, level, opt, unsafe.Pointer(&amp;value), &amp;vallen)</code></span>
<span class="codeline" id="line-1327"><code>	return &amp;value, err</code></span>
<span class="codeline" id="line-1328"><code>}</code></span>
<span class="codeline" id="line-1329"><code></code></span>
<span class="codeline" id="line-1330"><code>func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) {</code></span>
<span class="codeline" id="line-1331"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))</code></span>
<span class="codeline" id="line-1332"><code>}</code></span>
<span class="codeline" id="line-1333"><code></code></span>
<span class="codeline" id="line-1334"><code>func SetsockoptPacketMreq(fd, level, opt int, mreq *PacketMreq) error {</code></span>
<span class="codeline" id="line-1335"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))</code></span>
<span class="codeline" id="line-1336"><code>}</code></span>
<span class="codeline" id="line-1337"><code></code></span>
<span class="codeline" id="line-1338"><code>// SetsockoptSockFprog attaches a classic BPF or an extended BPF program to a</code></span>
<span class="codeline" id="line-1339"><code>// socket to filter incoming packets.  See 'man 7 socket' for usage information.</code></span>
<span class="codeline" id="line-1340"><code>func SetsockoptSockFprog(fd, level, opt int, fprog *SockFprog) error {</code></span>
<span class="codeline" id="line-1341"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(fprog), unsafe.Sizeof(*fprog))</code></span>
<span class="codeline" id="line-1342"><code>}</code></span>
<span class="codeline" id="line-1343"><code></code></span>
<span class="codeline" id="line-1344"><code>func SetsockoptCanRawFilter(fd, level, opt int, filter []CanFilter) error {</code></span>
<span class="codeline" id="line-1345"><code>	var p unsafe.Pointer</code></span>
<span class="codeline" id="line-1346"><code>	if len(filter) &gt; 0 {</code></span>
<span class="codeline" id="line-1347"><code>		p = unsafe.Pointer(&amp;filter[0])</code></span>
<span class="codeline" id="line-1348"><code>	}</code></span>
<span class="codeline" id="line-1349"><code>	return setsockopt(fd, level, opt, p, uintptr(len(filter)*SizeofCanFilter))</code></span>
<span class="codeline" id="line-1350"><code>}</code></span>
<span class="codeline" id="line-1351"><code></code></span>
<span class="codeline" id="line-1352"><code>func SetsockoptTpacketReq(fd, level, opt int, tp *TpacketReq) error {</code></span>
<span class="codeline" id="line-1353"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(tp), unsafe.Sizeof(*tp))</code></span>
<span class="codeline" id="line-1354"><code>}</code></span>
<span class="codeline" id="line-1355"><code></code></span>
<span class="codeline" id="line-1356"><code>func SetsockoptTpacketReq3(fd, level, opt int, tp *TpacketReq3) error {</code></span>
<span class="codeline" id="line-1357"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(tp), unsafe.Sizeof(*tp))</code></span>
<span class="codeline" id="line-1358"><code>}</code></span>
<span class="codeline" id="line-1359"><code></code></span>
<span class="codeline" id="line-1360"><code>func SetsockoptTCPRepairOpt(fd, level, opt int, o []TCPRepairOpt) (err error) {</code></span>
<span class="codeline" id="line-1361"><code>	if len(o) == 0 {</code></span>
<span class="codeline" id="line-1362"><code>		return EINVAL</code></span>
<span class="codeline" id="line-1363"><code>	}</code></span>
<span class="codeline" id="line-1364"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(&amp;o[0]), uintptr(SizeofTCPRepairOpt*len(o)))</code></span>
<span class="codeline" id="line-1365"><code>}</code></span>
<span class="codeline" id="line-1366"><code></code></span>
<span class="codeline" id="line-1367"><code>func SetsockoptTCPMD5Sig(fd, level, opt int, s *TCPMD5Sig) error {</code></span>
<span class="codeline" id="line-1368"><code>	return setsockopt(fd, level, opt, unsafe.Pointer(s), unsafe.Sizeof(*s))</code></span>
<span class="codeline" id="line-1369"><code>}</code></span>
<span class="codeline" id="line-1370"><code></code></span>
<span class="codeline" id="line-1371"><code>// Keyctl Commands (http://man7.org/linux/man-pages/man2/keyctl.2.html)</code></span>
<span class="codeline" id="line-1372"><code></code></span>
<span class="codeline" id="line-1373"><code>// KeyctlInt calls keyctl commands in which each argument is an int.</code></span>
<span class="codeline" id="line-1374"><code>// These commands are KEYCTL_REVOKE, KEYCTL_CHOWN, KEYCTL_CLEAR, KEYCTL_LINK,</code></span>
<span class="codeline" id="line-1375"><code>// KEYCTL_UNLINK, KEYCTL_NEGATE, KEYCTL_SET_REQKEY_KEYRING, KEYCTL_SET_TIMEOUT,</code></span>
<span class="codeline" id="line-1376"><code>// KEYCTL_ASSUME_AUTHORITY, KEYCTL_SESSION_TO_PARENT, KEYCTL_REJECT,</code></span>
<span class="codeline" id="line-1377"><code>// KEYCTL_INVALIDATE, and KEYCTL_GET_PERSISTENT.</code></span>
<span class="codeline" id="line-1378"><code>//sys	KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1379"><code></code></span>
<span class="codeline" id="line-1380"><code>// KeyctlBuffer calls keyctl commands in which the third and fourth</code></span>
<span class="codeline" id="line-1381"><code>// arguments are a buffer and its length, respectively.</code></span>
<span class="codeline" id="line-1382"><code>// These commands are KEYCTL_UPDATE, KEYCTL_READ, and KEYCTL_INSTANTIATE.</code></span>
<span class="codeline" id="line-1383"><code>//sys	KeyctlBuffer(cmd int, arg2 int, buf []byte, arg5 int) (ret int, err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1384"><code></code></span>
<span class="codeline" id="line-1385"><code>// KeyctlString calls keyctl commands which return a string.</code></span>
<span class="codeline" id="line-1386"><code>// These commands are KEYCTL_DESCRIBE and KEYCTL_GET_SECURITY.</code></span>
<span class="codeline" id="line-1387"><code>func KeyctlString(cmd int, id int) (string, error) {</code></span>
<span class="codeline" id="line-1388"><code>	// We must loop as the string data may change in between the syscalls.</code></span>
<span class="codeline" id="line-1389"><code>	// We could allocate a large buffer here to reduce the chance that the</code></span>
<span class="codeline" id="line-1390"><code>	// syscall needs to be called twice; however, this is unnecessary as</code></span>
<span class="codeline" id="line-1391"><code>	// the performance loss is negligible.</code></span>
<span class="codeline" id="line-1392"><code>	var buffer []byte</code></span>
<span class="codeline" id="line-1393"><code>	for {</code></span>
<span class="codeline" id="line-1394"><code>		// Try to fill the buffer with data</code></span>
<span class="codeline" id="line-1395"><code>		length, err := KeyctlBuffer(cmd, id, buffer, 0)</code></span>
<span class="codeline" id="line-1396"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1397"><code>			return "", err</code></span>
<span class="codeline" id="line-1398"><code>		}</code></span>
<span class="codeline" id="line-1399"><code></code></span>
<span class="codeline" id="line-1400"><code>		// Check if the data was written</code></span>
<span class="codeline" id="line-1401"><code>		if length &lt;= len(buffer) {</code></span>
<span class="codeline" id="line-1402"><code>			// Exclude the null terminator</code></span>
<span class="codeline" id="line-1403"><code>			return string(buffer[:length-1]), nil</code></span>
<span class="codeline" id="line-1404"><code>		}</code></span>
<span class="codeline" id="line-1405"><code></code></span>
<span class="codeline" id="line-1406"><code>		// Make a bigger buffer if needed</code></span>
<span class="codeline" id="line-1407"><code>		buffer = make([]byte, length)</code></span>
<span class="codeline" id="line-1408"><code>	}</code></span>
<span class="codeline" id="line-1409"><code>}</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>// Keyctl commands with special signatures.</code></span>
<span class="codeline" id="line-1412"><code></code></span>
<span class="codeline" id="line-1413"><code>// KeyctlGetKeyringID implements the KEYCTL_GET_KEYRING_ID command.</code></span>
<span class="codeline" id="line-1414"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1415"><code>// http://man7.org/linux/man-pages/man3/keyctl_get_keyring_ID.3.html</code></span>
<span class="codeline" id="line-1416"><code>func KeyctlGetKeyringID(id int, create bool) (ringid int, err error) {</code></span>
<span class="codeline" id="line-1417"><code>	createInt := 0</code></span>
<span class="codeline" id="line-1418"><code>	if create {</code></span>
<span class="codeline" id="line-1419"><code>		createInt = 1</code></span>
<span class="codeline" id="line-1420"><code>	}</code></span>
<span class="codeline" id="line-1421"><code>	return KeyctlInt(KEYCTL_GET_KEYRING_ID, id, createInt, 0, 0)</code></span>
<span class="codeline" id="line-1422"><code>}</code></span>
<span class="codeline" id="line-1423"><code></code></span>
<span class="codeline" id="line-1424"><code>// KeyctlSetperm implements the KEYCTL_SETPERM command. The perm value is the</code></span>
<span class="codeline" id="line-1425"><code>// key handle permission mask as described in the "keyctl setperm" section of</code></span>
<span class="codeline" id="line-1426"><code>// http://man7.org/linux/man-pages/man1/keyctl.1.html.</code></span>
<span class="codeline" id="line-1427"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1428"><code>// http://man7.org/linux/man-pages/man3/keyctl_setperm.3.html</code></span>
<span class="codeline" id="line-1429"><code>func KeyctlSetperm(id int, perm uint32) error {</code></span>
<span class="codeline" id="line-1430"><code>	_, err := KeyctlInt(KEYCTL_SETPERM, id, int(perm), 0, 0)</code></span>
<span class="codeline" id="line-1431"><code>	return err</code></span>
<span class="codeline" id="line-1432"><code>}</code></span>
<span class="codeline" id="line-1433"><code></code></span>
<span class="codeline" id="line-1434"><code>//sys	keyctlJoin(cmd int, arg2 string) (ret int, err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1435"><code></code></span>
<span class="codeline" id="line-1436"><code>// KeyctlJoinSessionKeyring implements the KEYCTL_JOIN_SESSION_KEYRING command.</code></span>
<span class="codeline" id="line-1437"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1438"><code>// http://man7.org/linux/man-pages/man3/keyctl_join_session_keyring.3.html</code></span>
<span class="codeline" id="line-1439"><code>func KeyctlJoinSessionKeyring(name string) (ringid int, err error) {</code></span>
<span class="codeline" id="line-1440"><code>	return keyctlJoin(KEYCTL_JOIN_SESSION_KEYRING, name)</code></span>
<span class="codeline" id="line-1441"><code>}</code></span>
<span class="codeline" id="line-1442"><code></code></span>
<span class="codeline" id="line-1443"><code>//sys	keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1444"><code></code></span>
<span class="codeline" id="line-1445"><code>// KeyctlSearch implements the KEYCTL_SEARCH command.</code></span>
<span class="codeline" id="line-1446"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1447"><code>// http://man7.org/linux/man-pages/man3/keyctl_search.3.html</code></span>
<span class="codeline" id="line-1448"><code>func KeyctlSearch(ringid int, keyType, description string, destRingid int) (id int, err error) {</code></span>
<span class="codeline" id="line-1449"><code>	return keyctlSearch(KEYCTL_SEARCH, ringid, keyType, description, destRingid)</code></span>
<span class="codeline" id="line-1450"><code>}</code></span>
<span class="codeline" id="line-1451"><code></code></span>
<span class="codeline" id="line-1452"><code>//sys	keyctlIOV(cmd int, arg2 int, payload []Iovec, arg5 int) (err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1453"><code></code></span>
<span class="codeline" id="line-1454"><code>// KeyctlInstantiateIOV implements the KEYCTL_INSTANTIATE_IOV command. This</code></span>
<span class="codeline" id="line-1455"><code>// command is similar to KEYCTL_INSTANTIATE, except that the payload is a slice</code></span>
<span class="codeline" id="line-1456"><code>// of Iovec (each of which represents a buffer) instead of a single buffer.</code></span>
<span class="codeline" id="line-1457"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1458"><code>// http://man7.org/linux/man-pages/man3/keyctl_instantiate_iov.3.html</code></span>
<span class="codeline" id="line-1459"><code>func KeyctlInstantiateIOV(id int, payload []Iovec, ringid int) error {</code></span>
<span class="codeline" id="line-1460"><code>	return keyctlIOV(KEYCTL_INSTANTIATE_IOV, id, payload, ringid)</code></span>
<span class="codeline" id="line-1461"><code>}</code></span>
<span class="codeline" id="line-1462"><code></code></span>
<span class="codeline" id="line-1463"><code>//sys	keyctlDH(cmd int, arg2 *KeyctlDHParams, buf []byte) (ret int, err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1464"><code></code></span>
<span class="codeline" id="line-1465"><code>// KeyctlDHCompute implements the KEYCTL_DH_COMPUTE command. This command</code></span>
<span class="codeline" id="line-1466"><code>// computes a Diffie-Hellman shared secret based on the provide params. The</code></span>
<span class="codeline" id="line-1467"><code>// secret is written to the provided buffer and the returned size is the number</code></span>
<span class="codeline" id="line-1468"><code>// of bytes written (returning an error if there is insufficient space in the</code></span>
<span class="codeline" id="line-1469"><code>// buffer). If a nil buffer is passed in, this function returns the minimum</code></span>
<span class="codeline" id="line-1470"><code>// buffer length needed to store the appropriate data. Note that this differs</code></span>
<span class="codeline" id="line-1471"><code>// from KEYCTL_READ's behavior which always returns the requested payload size.</code></span>
<span class="codeline" id="line-1472"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1473"><code>// http://man7.org/linux/man-pages/man3/keyctl_dh_compute.3.html</code></span>
<span class="codeline" id="line-1474"><code>func KeyctlDHCompute(params *KeyctlDHParams, buffer []byte) (size int, err error) {</code></span>
<span class="codeline" id="line-1475"><code>	return keyctlDH(KEYCTL_DH_COMPUTE, params, buffer)</code></span>
<span class="codeline" id="line-1476"><code>}</code></span>
<span class="codeline" id="line-1477"><code></code></span>
<span class="codeline" id="line-1478"><code>// KeyctlRestrictKeyring implements the KEYCTL_RESTRICT_KEYRING command. This</code></span>
<span class="codeline" id="line-1479"><code>// command limits the set of keys that can be linked to the keyring, regardless</code></span>
<span class="codeline" id="line-1480"><code>// of keyring permissions. The command requires the "setattr" permission.</code></span>
<span class="codeline" id="line-1481"><code>//</code></span>
<span class="codeline" id="line-1482"><code>// When called with an empty keyType the command locks the keyring, preventing</code></span>
<span class="codeline" id="line-1483"><code>// any further keys from being linked to the keyring.</code></span>
<span class="codeline" id="line-1484"><code>//</code></span>
<span class="codeline" id="line-1485"><code>// The "asymmetric" keyType defines restrictions requiring key payloads to be</code></span>
<span class="codeline" id="line-1486"><code>// DER encoded X.509 certificates signed by keys in another keyring. Restrictions</code></span>
<span class="codeline" id="line-1487"><code>// for "asymmetric" include "builtin_trusted", "builtin_and_secondary_trusted",</code></span>
<span class="codeline" id="line-1488"><code>// "key_or_keyring:&lt;key&gt;", and "key_or_keyring:&lt;key&gt;:chain".</code></span>
<span class="codeline" id="line-1489"><code>//</code></span>
<span class="codeline" id="line-1490"><code>// As of Linux 4.12, only the "asymmetric" keyType defines type-specific</code></span>
<span class="codeline" id="line-1491"><code>// restrictions.</code></span>
<span class="codeline" id="line-1492"><code>//</code></span>
<span class="codeline" id="line-1493"><code>// See the full documentation at:</code></span>
<span class="codeline" id="line-1494"><code>// http://man7.org/linux/man-pages/man3/keyctl_restrict_keyring.3.html</code></span>
<span class="codeline" id="line-1495"><code>// http://man7.org/linux/man-pages/man2/keyctl.2.html</code></span>
<span class="codeline" id="line-1496"><code>func KeyctlRestrictKeyring(ringid int, keyType string, restriction string) error {</code></span>
<span class="codeline" id="line-1497"><code>	if keyType == "" {</code></span>
<span class="codeline" id="line-1498"><code>		return keyctlRestrictKeyring(KEYCTL_RESTRICT_KEYRING, ringid)</code></span>
<span class="codeline" id="line-1499"><code>	}</code></span>
<span class="codeline" id="line-1500"><code>	return keyctlRestrictKeyringByType(KEYCTL_RESTRICT_KEYRING, ringid, keyType, restriction)</code></span>
<span class="codeline" id="line-1501"><code>}</code></span>
<span class="codeline" id="line-1502"><code></code></span>
<span class="codeline" id="line-1503"><code>//sys	keyctlRestrictKeyringByType(cmd int, arg2 int, keyType string, restriction string) (err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1504"><code>//sys	keyctlRestrictKeyring(cmd int, arg2 int) (err error) = SYS_KEYCTL</code></span>
<span class="codeline" id="line-1505"><code></code></span>
<span class="codeline" id="line-1506"><code>func recvmsgRaw(fd int, iov []Iovec, oob []byte, flags int, rsa *RawSockaddrAny) (n, oobn int, recvflags int, err error) {</code></span>
<span class="codeline" id="line-1507"><code>	var msg Msghdr</code></span>
<span class="codeline" id="line-1508"><code>	msg.Name = (*byte)(unsafe.Pointer(rsa))</code></span>
<span class="codeline" id="line-1509"><code>	msg.Namelen = uint32(SizeofSockaddrAny)</code></span>
<span class="codeline" id="line-1510"><code>	var dummy byte</code></span>
<span class="codeline" id="line-1511"><code>	if len(oob) &gt; 0 {</code></span>
<span class="codeline" id="line-1512"><code>		if emptyIovecs(iov) {</code></span>
<span class="codeline" id="line-1513"><code>			var sockType int</code></span>
<span class="codeline" id="line-1514"><code>			sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)</code></span>
<span class="codeline" id="line-1515"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1516"><code>				return</code></span>
<span class="codeline" id="line-1517"><code>			}</code></span>
<span class="codeline" id="line-1518"><code>			// receive at least one normal byte</code></span>
<span class="codeline" id="line-1519"><code>			if sockType != SOCK_DGRAM {</code></span>
<span class="codeline" id="line-1520"><code>				var iova [1]Iovec</code></span>
<span class="codeline" id="line-1521"><code>				iova[0].Base = &amp;dummy</code></span>
<span class="codeline" id="line-1522"><code>				iova[0].SetLen(1)</code></span>
<span class="codeline" id="line-1523"><code>				iov = iova[:]</code></span>
<span class="codeline" id="line-1524"><code>			}</code></span>
<span class="codeline" id="line-1525"><code>		}</code></span>
<span class="codeline" id="line-1526"><code>		msg.Control = &amp;oob[0]</code></span>
<span class="codeline" id="line-1527"><code>		msg.SetControllen(len(oob))</code></span>
<span class="codeline" id="line-1528"><code>	}</code></span>
<span class="codeline" id="line-1529"><code>	if len(iov) &gt; 0 {</code></span>
<span class="codeline" id="line-1530"><code>		msg.Iov = &amp;iov[0]</code></span>
<span class="codeline" id="line-1531"><code>		msg.SetIovlen(len(iov))</code></span>
<span class="codeline" id="line-1532"><code>	}</code></span>
<span class="codeline" id="line-1533"><code>	if n, err = recvmsg(fd, &amp;msg, flags); err != nil {</code></span>
<span class="codeline" id="line-1534"><code>		return</code></span>
<span class="codeline" id="line-1535"><code>	}</code></span>
<span class="codeline" id="line-1536"><code>	oobn = int(msg.Controllen)</code></span>
<span class="codeline" id="line-1537"><code>	recvflags = int(msg.Flags)</code></span>
<span class="codeline" id="line-1538"><code>	return</code></span>
<span class="codeline" id="line-1539"><code>}</code></span>
<span class="codeline" id="line-1540"><code></code></span>
<span class="codeline" id="line-1541"><code>func sendmsgN(fd int, iov []Iovec, oob []byte, ptr unsafe.Pointer, salen _Socklen, flags int) (n int, err error) {</code></span>
<span class="codeline" id="line-1542"><code>	var msg Msghdr</code></span>
<span class="codeline" id="line-1543"><code>	msg.Name = (*byte)(ptr)</code></span>
<span class="codeline" id="line-1544"><code>	msg.Namelen = uint32(salen)</code></span>
<span class="codeline" id="line-1545"><code>	var dummy byte</code></span>
<span class="codeline" id="line-1546"><code>	var empty bool</code></span>
<span class="codeline" id="line-1547"><code>	if len(oob) &gt; 0 {</code></span>
<span class="codeline" id="line-1548"><code>		empty = emptyIovecs(iov)</code></span>
<span class="codeline" id="line-1549"><code>		if empty {</code></span>
<span class="codeline" id="line-1550"><code>			var sockType int</code></span>
<span class="codeline" id="line-1551"><code>			sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)</code></span>
<span class="codeline" id="line-1552"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1553"><code>				return 0, err</code></span>
<span class="codeline" id="line-1554"><code>			}</code></span>
<span class="codeline" id="line-1555"><code>			// send at least one normal byte</code></span>
<span class="codeline" id="line-1556"><code>			if sockType != SOCK_DGRAM {</code></span>
<span class="codeline" id="line-1557"><code>				var iova [1]Iovec</code></span>
<span class="codeline" id="line-1558"><code>				iova[0].Base = &amp;dummy</code></span>
<span class="codeline" id="line-1559"><code>				iova[0].SetLen(1)</code></span>
<span class="codeline" id="line-1560"><code>				iov = iova[:]</code></span>
<span class="codeline" id="line-1561"><code>			}</code></span>
<span class="codeline" id="line-1562"><code>		}</code></span>
<span class="codeline" id="line-1563"><code>		msg.Control = &amp;oob[0]</code></span>
<span class="codeline" id="line-1564"><code>		msg.SetControllen(len(oob))</code></span>
<span class="codeline" id="line-1565"><code>	}</code></span>
<span class="codeline" id="line-1566"><code>	if len(iov) &gt; 0 {</code></span>
<span class="codeline" id="line-1567"><code>		msg.Iov = &amp;iov[0]</code></span>
<span class="codeline" id="line-1568"><code>		msg.SetIovlen(len(iov))</code></span>
<span class="codeline" id="line-1569"><code>	}</code></span>
<span class="codeline" id="line-1570"><code>	if n, err = sendmsg(fd, &amp;msg, flags); err != nil {</code></span>
<span class="codeline" id="line-1571"><code>		return 0, err</code></span>
<span class="codeline" id="line-1572"><code>	}</code></span>
<span class="codeline" id="line-1573"><code>	if len(oob) &gt; 0 &amp;&amp; empty {</code></span>
<span class="codeline" id="line-1574"><code>		n = 0</code></span>
<span class="codeline" id="line-1575"><code>	}</code></span>
<span class="codeline" id="line-1576"><code>	return n, nil</code></span>
<span class="codeline" id="line-1577"><code>}</code></span>
<span class="codeline" id="line-1578"><code></code></span>
<span class="codeline" id="line-1579"><code>// BindToDevice binds the socket associated with fd to device.</code></span>
<span class="codeline" id="line-1580"><code>func BindToDevice(fd int, device string) (err error) {</code></span>
<span class="codeline" id="line-1581"><code>	return SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)</code></span>
<span class="codeline" id="line-1582"><code>}</code></span>
<span class="codeline" id="line-1583"><code></code></span>
<span class="codeline" id="line-1584"><code>//sys	ptrace(request int, pid int, addr uintptr, data uintptr) (err error)</code></span>
<span class="codeline" id="line-1585"><code>//sys	ptracePtr(request int, pid int, addr uintptr, data unsafe.Pointer) (err error) = SYS_PTRACE</code></span>
<span class="codeline" id="line-1586"><code></code></span>
<span class="codeline" id="line-1587"><code>func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1588"><code>	// The peek requests are machine-size oriented, so we wrap it</code></span>
<span class="codeline" id="line-1589"><code>	// to retrieve arbitrary-length data.</code></span>
<span class="codeline" id="line-1590"><code></code></span>
<span class="codeline" id="line-1591"><code>	// The ptrace syscall differs from glibc's ptrace.</code></span>
<span class="codeline" id="line-1592"><code>	// Peeks returns the word in *data, not as the return value.</code></span>
<span class="codeline" id="line-1593"><code></code></span>
<span class="codeline" id="line-1594"><code>	var buf [SizeofPtr]byte</code></span>
<span class="codeline" id="line-1595"><code></code></span>
<span class="codeline" id="line-1596"><code>	// Leading edge. PEEKTEXT/PEEKDATA don't require aligned</code></span>
<span class="codeline" id="line-1597"><code>	// access (PEEKUSER warns that it might), but if we don't</code></span>
<span class="codeline" id="line-1598"><code>	// align our reads, we might straddle an unmapped page</code></span>
<span class="codeline" id="line-1599"><code>	// boundary and not get the bytes leading up to the page</code></span>
<span class="codeline" id="line-1600"><code>	// boundary.</code></span>
<span class="codeline" id="line-1601"><code>	n := 0</code></span>
<span class="codeline" id="line-1602"><code>	if addr%SizeofPtr != 0 {</code></span>
<span class="codeline" id="line-1603"><code>		err = ptracePtr(req, pid, addr-addr%SizeofPtr, unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-1604"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1605"><code>			return 0, err</code></span>
<span class="codeline" id="line-1606"><code>		}</code></span>
<span class="codeline" id="line-1607"><code>		n += copy(out, buf[addr%SizeofPtr:])</code></span>
<span class="codeline" id="line-1608"><code>		out = out[n:]</code></span>
<span class="codeline" id="line-1609"><code>	}</code></span>
<span class="codeline" id="line-1610"><code></code></span>
<span class="codeline" id="line-1611"><code>	// Remainder.</code></span>
<span class="codeline" id="line-1612"><code>	for len(out) &gt; 0 {</code></span>
<span class="codeline" id="line-1613"><code>		// We use an internal buffer to guarantee alignment.</code></span>
<span class="codeline" id="line-1614"><code>		// It's not documented if this is necessary, but we're paranoid.</code></span>
<span class="codeline" id="line-1615"><code>		err = ptracePtr(req, pid, addr+uintptr(n), unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-1616"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1617"><code>			return n, err</code></span>
<span class="codeline" id="line-1618"><code>		}</code></span>
<span class="codeline" id="line-1619"><code>		copied := copy(out, buf[0:])</code></span>
<span class="codeline" id="line-1620"><code>		n += copied</code></span>
<span class="codeline" id="line-1621"><code>		out = out[copied:]</code></span>
<span class="codeline" id="line-1622"><code>	}</code></span>
<span class="codeline" id="line-1623"><code></code></span>
<span class="codeline" id="line-1624"><code>	return n, nil</code></span>
<span class="codeline" id="line-1625"><code>}</code></span>
<span class="codeline" id="line-1626"><code></code></span>
<span class="codeline" id="line-1627"><code>func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1628"><code>	return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)</code></span>
<span class="codeline" id="line-1629"><code>}</code></span>
<span class="codeline" id="line-1630"><code></code></span>
<span class="codeline" id="line-1631"><code>func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1632"><code>	return ptracePeek(PTRACE_PEEKDATA, pid, addr, out)</code></span>
<span class="codeline" id="line-1633"><code>}</code></span>
<span class="codeline" id="line-1634"><code></code></span>
<span class="codeline" id="line-1635"><code>func PtracePeekUser(pid int, addr uintptr, out []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1636"><code>	return ptracePeek(PTRACE_PEEKUSR, pid, addr, out)</code></span>
<span class="codeline" id="line-1637"><code>}</code></span>
<span class="codeline" id="line-1638"><code></code></span>
<span class="codeline" id="line-1639"><code>func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1640"><code>	// As for ptracePeek, we need to align our accesses to deal</code></span>
<span class="codeline" id="line-1641"><code>	// with the possibility of straddling an invalid page.</code></span>
<span class="codeline" id="line-1642"><code></code></span>
<span class="codeline" id="line-1643"><code>	// Leading edge.</code></span>
<span class="codeline" id="line-1644"><code>	n := 0</code></span>
<span class="codeline" id="line-1645"><code>	if addr%SizeofPtr != 0 {</code></span>
<span class="codeline" id="line-1646"><code>		var buf [SizeofPtr]byte</code></span>
<span class="codeline" id="line-1647"><code>		err = ptracePtr(peekReq, pid, addr-addr%SizeofPtr, unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-1648"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1649"><code>			return 0, err</code></span>
<span class="codeline" id="line-1650"><code>		}</code></span>
<span class="codeline" id="line-1651"><code>		n += copy(buf[addr%SizeofPtr:], data)</code></span>
<span class="codeline" id="line-1652"><code>		word := *((*uintptr)(unsafe.Pointer(&amp;buf[0])))</code></span>
<span class="codeline" id="line-1653"><code>		err = ptrace(pokeReq, pid, addr-addr%SizeofPtr, word)</code></span>
<span class="codeline" id="line-1654"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1655"><code>			return 0, err</code></span>
<span class="codeline" id="line-1656"><code>		}</code></span>
<span class="codeline" id="line-1657"><code>		data = data[n:]</code></span>
<span class="codeline" id="line-1658"><code>	}</code></span>
<span class="codeline" id="line-1659"><code></code></span>
<span class="codeline" id="line-1660"><code>	// Interior.</code></span>
<span class="codeline" id="line-1661"><code>	for len(data) &gt; SizeofPtr {</code></span>
<span class="codeline" id="line-1662"><code>		word := *((*uintptr)(unsafe.Pointer(&amp;data[0])))</code></span>
<span class="codeline" id="line-1663"><code>		err = ptrace(pokeReq, pid, addr+uintptr(n), word)</code></span>
<span class="codeline" id="line-1664"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1665"><code>			return n, err</code></span>
<span class="codeline" id="line-1666"><code>		}</code></span>
<span class="codeline" id="line-1667"><code>		n += SizeofPtr</code></span>
<span class="codeline" id="line-1668"><code>		data = data[SizeofPtr:]</code></span>
<span class="codeline" id="line-1669"><code>	}</code></span>
<span class="codeline" id="line-1670"><code></code></span>
<span class="codeline" id="line-1671"><code>	// Trailing edge.</code></span>
<span class="codeline" id="line-1672"><code>	if len(data) &gt; 0 {</code></span>
<span class="codeline" id="line-1673"><code>		var buf [SizeofPtr]byte</code></span>
<span class="codeline" id="line-1674"><code>		err = ptracePtr(peekReq, pid, addr+uintptr(n), unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-1675"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1676"><code>			return n, err</code></span>
<span class="codeline" id="line-1677"><code>		}</code></span>
<span class="codeline" id="line-1678"><code>		copy(buf[0:], data)</code></span>
<span class="codeline" id="line-1679"><code>		word := *((*uintptr)(unsafe.Pointer(&amp;buf[0])))</code></span>
<span class="codeline" id="line-1680"><code>		err = ptrace(pokeReq, pid, addr+uintptr(n), word)</code></span>
<span class="codeline" id="line-1681"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1682"><code>			return n, err</code></span>
<span class="codeline" id="line-1683"><code>		}</code></span>
<span class="codeline" id="line-1684"><code>		n += len(data)</code></span>
<span class="codeline" id="line-1685"><code>	}</code></span>
<span class="codeline" id="line-1686"><code></code></span>
<span class="codeline" id="line-1687"><code>	return n, nil</code></span>
<span class="codeline" id="line-1688"><code>}</code></span>
<span class="codeline" id="line-1689"><code></code></span>
<span class="codeline" id="line-1690"><code>func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1691"><code>	return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)</code></span>
<span class="codeline" id="line-1692"><code>}</code></span>
<span class="codeline" id="line-1693"><code></code></span>
<span class="codeline" id="line-1694"><code>func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1695"><code>	return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)</code></span>
<span class="codeline" id="line-1696"><code>}</code></span>
<span class="codeline" id="line-1697"><code></code></span>
<span class="codeline" id="line-1698"><code>func PtracePokeUser(pid int, addr uintptr, data []byte) (count int, err error) {</code></span>
<span class="codeline" id="line-1699"><code>	return ptracePoke(PTRACE_POKEUSR, PTRACE_PEEKUSR, pid, addr, data)</code></span>
<span class="codeline" id="line-1700"><code>}</code></span>
<span class="codeline" id="line-1701"><code></code></span>
<span class="codeline" id="line-1702"><code>// elfNT_PRSTATUS is a copy of the debug/elf.NT_PRSTATUS constant so</code></span>
<span class="codeline" id="line-1703"><code>// x/sys/unix doesn't need to depend on debug/elf and thus</code></span>
<span class="codeline" id="line-1704"><code>// compress/zlib, debug/dwarf, and other packages.</code></span>
<span class="codeline" id="line-1705"><code>const elfNT_PRSTATUS = 1</code></span>
<span class="codeline" id="line-1706"><code></code></span>
<span class="codeline" id="line-1707"><code>func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {</code></span>
<span class="codeline" id="line-1708"><code>	var iov Iovec</code></span>
<span class="codeline" id="line-1709"><code>	iov.Base = (*byte)(unsafe.Pointer(regsout))</code></span>
<span class="codeline" id="line-1710"><code>	iov.SetLen(int(unsafe.Sizeof(*regsout)))</code></span>
<span class="codeline" id="line-1711"><code>	return ptracePtr(PTRACE_GETREGSET, pid, uintptr(elfNT_PRSTATUS), unsafe.Pointer(&amp;iov))</code></span>
<span class="codeline" id="line-1712"><code>}</code></span>
<span class="codeline" id="line-1713"><code></code></span>
<span class="codeline" id="line-1714"><code>func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {</code></span>
<span class="codeline" id="line-1715"><code>	var iov Iovec</code></span>
<span class="codeline" id="line-1716"><code>	iov.Base = (*byte)(unsafe.Pointer(regs))</code></span>
<span class="codeline" id="line-1717"><code>	iov.SetLen(int(unsafe.Sizeof(*regs)))</code></span>
<span class="codeline" id="line-1718"><code>	return ptracePtr(PTRACE_SETREGSET, pid, uintptr(elfNT_PRSTATUS), unsafe.Pointer(&amp;iov))</code></span>
<span class="codeline" id="line-1719"><code>}</code></span>
<span class="codeline" id="line-1720"><code></code></span>
<span class="codeline" id="line-1721"><code>func PtraceSetOptions(pid int, options int) (err error) {</code></span>
<span class="codeline" id="line-1722"><code>	return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))</code></span>
<span class="codeline" id="line-1723"><code>}</code></span>
<span class="codeline" id="line-1724"><code></code></span>
<span class="codeline" id="line-1725"><code>func PtraceGetEventMsg(pid int) (msg uint, err error) {</code></span>
<span class="codeline" id="line-1726"><code>	var data _C_long</code></span>
<span class="codeline" id="line-1727"><code>	err = ptracePtr(PTRACE_GETEVENTMSG, pid, 0, unsafe.Pointer(&amp;data))</code></span>
<span class="codeline" id="line-1728"><code>	msg = uint(data)</code></span>
<span class="codeline" id="line-1729"><code>	return</code></span>
<span class="codeline" id="line-1730"><code>}</code></span>
<span class="codeline" id="line-1731"><code></code></span>
<span class="codeline" id="line-1732"><code>func PtraceCont(pid int, signal int) (err error) {</code></span>
<span class="codeline" id="line-1733"><code>	return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))</code></span>
<span class="codeline" id="line-1734"><code>}</code></span>
<span class="codeline" id="line-1735"><code></code></span>
<span class="codeline" id="line-1736"><code>func PtraceSyscall(pid int, signal int) (err error) {</code></span>
<span class="codeline" id="line-1737"><code>	return ptrace(PTRACE_SYSCALL, pid, 0, uintptr(signal))</code></span>
<span class="codeline" id="line-1738"><code>}</code></span>
<span class="codeline" id="line-1739"><code></code></span>
<span class="codeline" id="line-1740"><code>func PtraceSingleStep(pid int) (err error) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }</code></span>
<span class="codeline" id="line-1741"><code></code></span>
<span class="codeline" id="line-1742"><code>func PtraceInterrupt(pid int) (err error) { return ptrace(PTRACE_INTERRUPT, pid, 0, 0) }</code></span>
<span class="codeline" id="line-1743"><code></code></span>
<span class="codeline" id="line-1744"><code>func PtraceAttach(pid int) (err error) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }</code></span>
<span class="codeline" id="line-1745"><code></code></span>
<span class="codeline" id="line-1746"><code>func PtraceSeize(pid int) (err error) { return ptrace(PTRACE_SEIZE, pid, 0, 0) }</code></span>
<span class="codeline" id="line-1747"><code></code></span>
<span class="codeline" id="line-1748"><code>func PtraceDetach(pid int) (err error) { return ptrace(PTRACE_DETACH, pid, 0, 0) }</code></span>
<span class="codeline" id="line-1749"><code></code></span>
<span class="codeline" id="line-1750"><code>//sys	reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error)</code></span>
<span class="codeline" id="line-1751"><code></code></span>
<span class="codeline" id="line-1752"><code>func Reboot(cmd int) (err error) {</code></span>
<span class="codeline" id="line-1753"><code>	return reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, "")</code></span>
<span class="codeline" id="line-1754"><code>}</code></span>
<span class="codeline" id="line-1755"><code></code></span>
<span class="codeline" id="line-1756"><code>func direntIno(buf []byte) (uint64, bool) {</code></span>
<span class="codeline" id="line-1757"><code>	return readInt(buf, unsafe.Offsetof(Dirent{}.Ino), unsafe.Sizeof(Dirent{}.Ino))</code></span>
<span class="codeline" id="line-1758"><code>}</code></span>
<span class="codeline" id="line-1759"><code></code></span>
<span class="codeline" id="line-1760"><code>func direntReclen(buf []byte) (uint64, bool) {</code></span>
<span class="codeline" id="line-1761"><code>	return readInt(buf, unsafe.Offsetof(Dirent{}.Reclen), unsafe.Sizeof(Dirent{}.Reclen))</code></span>
<span class="codeline" id="line-1762"><code>}</code></span>
<span class="codeline" id="line-1763"><code></code></span>
<span class="codeline" id="line-1764"><code>func direntNamlen(buf []byte) (uint64, bool) {</code></span>
<span class="codeline" id="line-1765"><code>	reclen, ok := direntReclen(buf)</code></span>
<span class="codeline" id="line-1766"><code>	if !ok {</code></span>
<span class="codeline" id="line-1767"><code>		return 0, false</code></span>
<span class="codeline" id="line-1768"><code>	}</code></span>
<span class="codeline" id="line-1769"><code>	return reclen - uint64(unsafe.Offsetof(Dirent{}.Name)), true</code></span>
<span class="codeline" id="line-1770"><code>}</code></span>
<span class="codeline" id="line-1771"><code></code></span>
<span class="codeline" id="line-1772"><code>//sys	mount(source string, target string, fstype string, flags uintptr, data *byte) (err error)</code></span>
<span class="codeline" id="line-1773"><code></code></span>
<span class="codeline" id="line-1774"><code>func Mount(source string, target string, fstype string, flags uintptr, data string) (err error) {</code></span>
<span class="codeline" id="line-1775"><code>	// Certain file systems get rather angry and EINVAL if you give</code></span>
<span class="codeline" id="line-1776"><code>	// them an empty string of data, rather than NULL.</code></span>
<span class="codeline" id="line-1777"><code>	if data == "" {</code></span>
<span class="codeline" id="line-1778"><code>		return mount(source, target, fstype, flags, nil)</code></span>
<span class="codeline" id="line-1779"><code>	}</code></span>
<span class="codeline" id="line-1780"><code>	datap, err := BytePtrFromString(data)</code></span>
<span class="codeline" id="line-1781"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1782"><code>		return err</code></span>
<span class="codeline" id="line-1783"><code>	}</code></span>
<span class="codeline" id="line-1784"><code>	return mount(source, target, fstype, flags, datap)</code></span>
<span class="codeline" id="line-1785"><code>}</code></span>
<span class="codeline" id="line-1786"><code></code></span>
<span class="codeline" id="line-1787"><code>//sys	mountSetattr(dirfd int, pathname string, flags uint, attr *MountAttr, size uintptr) (err error) = SYS_MOUNT_SETATTR</code></span>
<span class="codeline" id="line-1788"><code></code></span>
<span class="codeline" id="line-1789"><code>// MountSetattr is a wrapper for mount_setattr(2).</code></span>
<span class="codeline" id="line-1790"><code>// https://man7.org/linux/man-pages/man2/mount_setattr.2.html</code></span>
<span class="codeline" id="line-1791"><code>//</code></span>
<span class="codeline" id="line-1792"><code>// Requires kernel &gt;= 5.12.</code></span>
<span class="codeline" id="line-1793"><code>func MountSetattr(dirfd int, pathname string, flags uint, attr *MountAttr) error {</code></span>
<span class="codeline" id="line-1794"><code>	return mountSetattr(dirfd, pathname, flags, attr, unsafe.Sizeof(*attr))</code></span>
<span class="codeline" id="line-1795"><code>}</code></span>
<span class="codeline" id="line-1796"><code></code></span>
<span class="codeline" id="line-1797"><code>func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {</code></span>
<span class="codeline" id="line-1798"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-1799"><code>		raceReleaseMerge(unsafe.Pointer(&amp;ioSync))</code></span>
<span class="codeline" id="line-1800"><code>	}</code></span>
<span class="codeline" id="line-1801"><code>	return sendfile(outfd, infd, offset, count)</code></span>
<span class="codeline" id="line-1802"><code>}</code></span>
<span class="codeline" id="line-1803"><code></code></span>
<span class="codeline" id="line-1804"><code>// Sendto</code></span>
<span class="codeline" id="line-1805"><code>// Recvfrom</code></span>
<span class="codeline" id="line-1806"><code>// Socketpair</code></span>
<span class="codeline" id="line-1807"><code></code></span>
<span class="codeline" id="line-1808"><code>/*</code></span>
<span class="codeline" id="line-1809"><code> * Direct access</code></span>
<span class="codeline" id="line-1810"><code> */</code></span>
<span class="codeline" id="line-1811"><code>//sys	Acct(path string) (err error)</code></span>
<span class="codeline" id="line-1812"><code>//sys	AddKey(keyType string, description string, payload []byte, ringid int) (id int, err error)</code></span>
<span class="codeline" id="line-1813"><code>//sys	Adjtimex(buf *Timex) (state int, err error)</code></span>
<span class="codeline" id="line-1814"><code>//sysnb	Capget(hdr *CapUserHeader, data *CapUserData) (err error)</code></span>
<span class="codeline" id="line-1815"><code>//sysnb	Capset(hdr *CapUserHeader, data *CapUserData) (err error)</code></span>
<span class="codeline" id="line-1816"><code>//sys	Chdir(path string) (err error)</code></span>
<span class="codeline" id="line-1817"><code>//sys	Chroot(path string) (err error)</code></span>
<span class="codeline" id="line-1818"><code>//sys	ClockAdjtime(clockid int32, buf *Timex) (state int, err error)</code></span>
<span class="codeline" id="line-1819"><code>//sys	ClockGetres(clockid int32, res *Timespec) (err error)</code></span>
<span class="codeline" id="line-1820"><code>//sys	ClockGettime(clockid int32, time *Timespec) (err error)</code></span>
<span class="codeline" id="line-1821"><code>//sys	ClockNanosleep(clockid int32, flags int, request *Timespec, remain *Timespec) (err error)</code></span>
<span class="codeline" id="line-1822"><code>//sys	Close(fd int) (err error)</code></span>
<span class="codeline" id="line-1823"><code>//sys	CloseRange(first uint, last uint, flags uint) (err error)</code></span>
<span class="codeline" id="line-1824"><code>//sys	CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)</code></span>
<span class="codeline" id="line-1825"><code>//sys	DeleteModule(name string, flags int) (err error)</code></span>
<span class="codeline" id="line-1826"><code>//sys	Dup(oldfd int) (fd int, err error)</code></span>
<span class="codeline" id="line-1827"><code></code></span>
<span class="codeline" id="line-1828"><code>func Dup2(oldfd, newfd int) error {</code></span>
<span class="codeline" id="line-1829"><code>	return Dup3(oldfd, newfd, 0)</code></span>
<span class="codeline" id="line-1830"><code>}</code></span>
<span class="codeline" id="line-1831"><code></code></span>
<span class="codeline" id="line-1832"><code>//sys	Dup3(oldfd int, newfd int, flags int) (err error)</code></span>
<span class="codeline" id="line-1833"><code>//sysnb	EpollCreate1(flag int) (fd int, err error)</code></span>
<span class="codeline" id="line-1834"><code>//sysnb	EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)</code></span>
<span class="codeline" id="line-1835"><code>//sys	Eventfd(initval uint, flags int) (fd int, err error) = SYS_EVENTFD2</code></span>
<span class="codeline" id="line-1836"><code>//sys	Exit(code int) = SYS_EXIT_GROUP</code></span>
<span class="codeline" id="line-1837"><code>//sys	Fallocate(fd int, mode uint32, off int64, len int64) (err error)</code></span>
<span class="codeline" id="line-1838"><code>//sys	Fchdir(fd int) (err error)</code></span>
<span class="codeline" id="line-1839"><code>//sys	Fchmod(fd int, mode uint32) (err error)</code></span>
<span class="codeline" id="line-1840"><code>//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)</code></span>
<span class="codeline" id="line-1841"><code>//sys	Fdatasync(fd int) (err error)</code></span>
<span class="codeline" id="line-1842"><code>//sys	Fgetxattr(fd int, attr string, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1843"><code>//sys	FinitModule(fd int, params string, flags int) (err error)</code></span>
<span class="codeline" id="line-1844"><code>//sys	Flistxattr(fd int, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1845"><code>//sys	Flock(fd int, how int) (err error)</code></span>
<span class="codeline" id="line-1846"><code>//sys	Fremovexattr(fd int, attr string) (err error)</code></span>
<span class="codeline" id="line-1847"><code>//sys	Fsetxattr(fd int, attr string, dest []byte, flags int) (err error)</code></span>
<span class="codeline" id="line-1848"><code>//sys	Fsync(fd int) (err error)</code></span>
<span class="codeline" id="line-1849"><code>//sys	Fsmount(fd int, flags int, mountAttrs int) (fsfd int, err error)</code></span>
<span class="codeline" id="line-1850"><code>//sys	Fsopen(fsName string, flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1851"><code>//sys	Fspick(dirfd int, pathName string, flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1852"><code>//sys	Getdents(fd int, buf []byte) (n int, err error) = SYS_GETDENTS64</code></span>
<span class="codeline" id="line-1853"><code>//sysnb	Getpgid(pid int) (pgid int, err error)</code></span>
<span class="codeline" id="line-1854"><code></code></span>
<span class="codeline" id="line-1855"><code>func Getpgrp() (pid int) {</code></span>
<span class="codeline" id="line-1856"><code>	pid, _ = Getpgid(0)</code></span>
<span class="codeline" id="line-1857"><code>	return</code></span>
<span class="codeline" id="line-1858"><code>}</code></span>
<span class="codeline" id="line-1859"><code></code></span>
<span class="codeline" id="line-1860"><code>//sysnb	Getpid() (pid int)</code></span>
<span class="codeline" id="line-1861"><code>//sysnb	Getppid() (ppid int)</code></span>
<span class="codeline" id="line-1862"><code>//sys	Getpriority(which int, who int) (prio int, err error)</code></span>
<span class="codeline" id="line-1863"><code>//sys	Getrandom(buf []byte, flags int) (n int, err error)</code></span>
<span class="codeline" id="line-1864"><code>//sysnb	Getrusage(who int, rusage *Rusage) (err error)</code></span>
<span class="codeline" id="line-1865"><code>//sysnb	Getsid(pid int) (sid int, err error)</code></span>
<span class="codeline" id="line-1866"><code>//sysnb	Gettid() (tid int)</code></span>
<span class="codeline" id="line-1867"><code>//sys	Getxattr(path string, attr string, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1868"><code>//sys	InitModule(moduleImage []byte, params string) (err error)</code></span>
<span class="codeline" id="line-1869"><code>//sys	InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)</code></span>
<span class="codeline" id="line-1870"><code>//sysnb	InotifyInit1(flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1871"><code>//sysnb	InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)</code></span>
<span class="codeline" id="line-1872"><code>//sysnb	Kill(pid int, sig syscall.Signal) (err error)</code></span>
<span class="codeline" id="line-1873"><code>//sys	Klogctl(typ int, buf []byte) (n int, err error) = SYS_SYSLOG</code></span>
<span class="codeline" id="line-1874"><code>//sys	Lgetxattr(path string, attr string, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1875"><code>//sys	Listxattr(path string, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1876"><code>//sys	Llistxattr(path string, dest []byte) (sz int, err error)</code></span>
<span class="codeline" id="line-1877"><code>//sys	Lremovexattr(path string, attr string) (err error)</code></span>
<span class="codeline" id="line-1878"><code>//sys	Lsetxattr(path string, attr string, data []byte, flags int) (err error)</code></span>
<span class="codeline" id="line-1879"><code>//sys	MemfdCreate(name string, flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1880"><code>//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)</code></span>
<span class="codeline" id="line-1881"><code>//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)</code></span>
<span class="codeline" id="line-1882"><code>//sys	MoveMount(fromDirfd int, fromPathName string, toDirfd int, toPathName string, flags int) (err error)</code></span>
<span class="codeline" id="line-1883"><code>//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)</code></span>
<span class="codeline" id="line-1884"><code>//sys	OpenTree(dfd int, fileName string, flags uint) (r int, err error)</code></span>
<span class="codeline" id="line-1885"><code>//sys	PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1886"><code>//sys	PivotRoot(newroot string, putold string) (err error) = SYS_PIVOT_ROOT</code></span>
<span class="codeline" id="line-1887"><code>//sys	Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error)</code></span>
<span class="codeline" id="line-1888"><code>//sys	pselect6(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *sigset_argpack) (n int, err error)</code></span>
<span class="codeline" id="line-1889"><code>//sys	read(fd int, p []byte) (n int, err error)</code></span>
<span class="codeline" id="line-1890"><code>//sys	Removexattr(path string, attr string) (err error)</code></span>
<span class="codeline" id="line-1891"><code>//sys	Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error)</code></span>
<span class="codeline" id="line-1892"><code>//sys	RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error)</code></span>
<span class="codeline" id="line-1893"><code>//sys	Setdomainname(p []byte) (err error)</code></span>
<span class="codeline" id="line-1894"><code>//sys	Sethostname(p []byte) (err error)</code></span>
<span class="codeline" id="line-1895"><code>//sysnb	Setpgid(pid int, pgid int) (err error)</code></span>
<span class="codeline" id="line-1896"><code>//sysnb	Setsid() (pid int, err error)</code></span>
<span class="codeline" id="line-1897"><code>//sysnb	Settimeofday(tv *Timeval) (err error)</code></span>
<span class="codeline" id="line-1898"><code>//sys	Setns(fd int, nstype int) (err error)</code></span>
<span class="codeline" id="line-1899"><code></code></span>
<span class="codeline" id="line-1900"><code>//go:linkname syscall_prlimit syscall.prlimit</code></span>
<span class="codeline" id="line-1901"><code>func syscall_prlimit(pid, resource int, newlimit, old *syscall.Rlimit) error</code></span>
<span class="codeline" id="line-1902"><code></code></span>
<span class="codeline" id="line-1903"><code>func Prlimit(pid, resource int, newlimit, old *Rlimit) error {</code></span>
<span class="codeline" id="line-1904"><code>	// Just call the syscall version, because as of Go 1.21</code></span>
<span class="codeline" id="line-1905"><code>	// it will affect starting a new process.</code></span>
<span class="codeline" id="line-1906"><code>	return syscall_prlimit(pid, resource, (*syscall.Rlimit)(newlimit), (*syscall.Rlimit)(old))</code></span>
<span class="codeline" id="line-1907"><code>}</code></span>
<span class="codeline" id="line-1908"><code></code></span>
<span class="codeline" id="line-1909"><code>// PrctlRetInt performs a prctl operation specified by option and further</code></span>
<span class="codeline" id="line-1910"><code>// optional arguments arg2 through arg5 depending on option. It returns a</code></span>
<span class="codeline" id="line-1911"><code>// non-negative integer that is returned by the prctl syscall.</code></span>
<span class="codeline" id="line-1912"><code>func PrctlRetInt(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (int, error) {</code></span>
<span class="codeline" id="line-1913"><code>	ret, _, err := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)</code></span>
<span class="codeline" id="line-1914"><code>	if err != 0 {</code></span>
<span class="codeline" id="line-1915"><code>		return 0, err</code></span>
<span class="codeline" id="line-1916"><code>	}</code></span>
<span class="codeline" id="line-1917"><code>	return int(ret), nil</code></span>
<span class="codeline" id="line-1918"><code>}</code></span>
<span class="codeline" id="line-1919"><code></code></span>
<span class="codeline" id="line-1920"><code>func Setuid(uid int) (err error) {</code></span>
<span class="codeline" id="line-1921"><code>	return syscall.Setuid(uid)</code></span>
<span class="codeline" id="line-1922"><code>}</code></span>
<span class="codeline" id="line-1923"><code></code></span>
<span class="codeline" id="line-1924"><code>func Setgid(gid int) (err error) {</code></span>
<span class="codeline" id="line-1925"><code>	return syscall.Setgid(gid)</code></span>
<span class="codeline" id="line-1926"><code>}</code></span>
<span class="codeline" id="line-1927"><code></code></span>
<span class="codeline" id="line-1928"><code>func Setreuid(ruid, euid int) (err error) {</code></span>
<span class="codeline" id="line-1929"><code>	return syscall.Setreuid(ruid, euid)</code></span>
<span class="codeline" id="line-1930"><code>}</code></span>
<span class="codeline" id="line-1931"><code></code></span>
<span class="codeline" id="line-1932"><code>func Setregid(rgid, egid int) (err error) {</code></span>
<span class="codeline" id="line-1933"><code>	return syscall.Setregid(rgid, egid)</code></span>
<span class="codeline" id="line-1934"><code>}</code></span>
<span class="codeline" id="line-1935"><code></code></span>
<span class="codeline" id="line-1936"><code>func Setresuid(ruid, euid, suid int) (err error) {</code></span>
<span class="codeline" id="line-1937"><code>	return syscall.Setresuid(ruid, euid, suid)</code></span>
<span class="codeline" id="line-1938"><code>}</code></span>
<span class="codeline" id="line-1939"><code></code></span>
<span class="codeline" id="line-1940"><code>func Setresgid(rgid, egid, sgid int) (err error) {</code></span>
<span class="codeline" id="line-1941"><code>	return syscall.Setresgid(rgid, egid, sgid)</code></span>
<span class="codeline" id="line-1942"><code>}</code></span>
<span class="codeline" id="line-1943"><code></code></span>
<span class="codeline" id="line-1944"><code>// SetfsgidRetGid sets fsgid for current thread and returns previous fsgid set.</code></span>
<span class="codeline" id="line-1945"><code>// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability.</code></span>
<span class="codeline" id="line-1946"><code>// If the call fails due to other reasons, current fsgid will be returned.</code></span>
<span class="codeline" id="line-1947"><code>func SetfsgidRetGid(gid int) (int, error) {</code></span>
<span class="codeline" id="line-1948"><code>	return setfsgid(gid)</code></span>
<span class="codeline" id="line-1949"><code>}</code></span>
<span class="codeline" id="line-1950"><code></code></span>
<span class="codeline" id="line-1951"><code>// SetfsuidRetUid sets fsuid for current thread and returns previous fsuid set.</code></span>
<span class="codeline" id="line-1952"><code>// setfsgid(2) will return a non-nil error only if its caller lacks CAP_SETUID capability</code></span>
<span class="codeline" id="line-1953"><code>// If the call fails due to other reasons, current fsuid will be returned.</code></span>
<span class="codeline" id="line-1954"><code>func SetfsuidRetUid(uid int) (int, error) {</code></span>
<span class="codeline" id="line-1955"><code>	return setfsuid(uid)</code></span>
<span class="codeline" id="line-1956"><code>}</code></span>
<span class="codeline" id="line-1957"><code></code></span>
<span class="codeline" id="line-1958"><code>func Setfsgid(gid int) error {</code></span>
<span class="codeline" id="line-1959"><code>	_, err := setfsgid(gid)</code></span>
<span class="codeline" id="line-1960"><code>	return err</code></span>
<span class="codeline" id="line-1961"><code>}</code></span>
<span class="codeline" id="line-1962"><code></code></span>
<span class="codeline" id="line-1963"><code>func Setfsuid(uid int) error {</code></span>
<span class="codeline" id="line-1964"><code>	_, err := setfsuid(uid)</code></span>
<span class="codeline" id="line-1965"><code>	return err</code></span>
<span class="codeline" id="line-1966"><code>}</code></span>
<span class="codeline" id="line-1967"><code></code></span>
<span class="codeline" id="line-1968"><code>func Signalfd(fd int, sigmask *Sigset_t, flags int) (newfd int, err error) {</code></span>
<span class="codeline" id="line-1969"><code>	return signalfd(fd, sigmask, _C__NSIG/8, flags)</code></span>
<span class="codeline" id="line-1970"><code>}</code></span>
<span class="codeline" id="line-1971"><code></code></span>
<span class="codeline" id="line-1972"><code>//sys	Setpriority(which int, who int, prio int) (err error)</code></span>
<span class="codeline" id="line-1973"><code>//sys	Setxattr(path string, attr string, data []byte, flags int) (err error)</code></span>
<span class="codeline" id="line-1974"><code>//sys	signalfd(fd int, sigmask *Sigset_t, maskSize uintptr, flags int) (newfd int, err error) = SYS_SIGNALFD4</code></span>
<span class="codeline" id="line-1975"><code>//sys	Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)</code></span>
<span class="codeline" id="line-1976"><code>//sys	Sync()</code></span>
<span class="codeline" id="line-1977"><code>//sys	Syncfs(fd int) (err error)</code></span>
<span class="codeline" id="line-1978"><code>//sysnb	Sysinfo(info *Sysinfo_t) (err error)</code></span>
<span class="codeline" id="line-1979"><code>//sys	Tee(rfd int, wfd int, len int, flags int) (n int64, err error)</code></span>
<span class="codeline" id="line-1980"><code>//sysnb	TimerfdCreate(clockid int, flags int) (fd int, err error)</code></span>
<span class="codeline" id="line-1981"><code>//sysnb	TimerfdGettime(fd int, currValue *ItimerSpec) (err error)</code></span>
<span class="codeline" id="line-1982"><code>//sysnb	TimerfdSettime(fd int, flags int, newValue *ItimerSpec, oldValue *ItimerSpec) (err error)</code></span>
<span class="codeline" id="line-1983"><code>//sysnb	Tgkill(tgid int, tid int, sig syscall.Signal) (err error)</code></span>
<span class="codeline" id="line-1984"><code>//sysnb	Times(tms *Tms) (ticks uintptr, err error)</code></span>
<span class="codeline" id="line-1985"><code>//sysnb	Umask(mask int) (oldmask int)</code></span>
<span class="codeline" id="line-1986"><code>//sysnb	Uname(buf *Utsname) (err error)</code></span>
<span class="codeline" id="line-1987"><code>//sys	Unmount(target string, flags int) (err error) = SYS_UMOUNT2</code></span>
<span class="codeline" id="line-1988"><code>//sys	Unshare(flags int) (err error)</code></span>
<span class="codeline" id="line-1989"><code>//sys	write(fd int, p []byte) (n int, err error)</code></span>
<span class="codeline" id="line-1990"><code>//sys	exitThread(code int) (err error) = SYS_EXIT</code></span>
<span class="codeline" id="line-1991"><code>//sys	readv(fd int, iovs []Iovec) (n int, err error) = SYS_READV</code></span>
<span class="codeline" id="line-1992"><code>//sys	writev(fd int, iovs []Iovec) (n int, err error) = SYS_WRITEV</code></span>
<span class="codeline" id="line-1993"><code>//sys	preadv(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr) (n int, err error) = SYS_PREADV</code></span>
<span class="codeline" id="line-1994"><code>//sys	pwritev(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr) (n int, err error) = SYS_PWRITEV</code></span>
<span class="codeline" id="line-1995"><code>//sys	preadv2(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) = SYS_PREADV2</code></span>
<span class="codeline" id="line-1996"><code>//sys	pwritev2(fd int, iovs []Iovec, offs_l uintptr, offs_h uintptr, flags int) (n int, err error) = SYS_PWRITEV2</code></span>
<span class="codeline" id="line-1997"><code></code></span>
<span class="codeline" id="line-1998"><code>// minIovec is the size of the small initial allocation used by</code></span>
<span class="codeline" id="line-1999"><code>// Readv, Writev, etc.</code></span>
<span class="codeline" id="line-2000"><code>//</code></span>
<span class="codeline" id="line-2001"><code>// This small allocation gets stack allocated, which lets the</code></span>
<span class="codeline" id="line-2002"><code>// common use case of len(iovs) &lt;= minIovs avoid more expensive</code></span>
<span class="codeline" id="line-2003"><code>// heap allocations.</code></span>
<span class="codeline" id="line-2004"><code>const minIovec = 8</code></span>
<span class="codeline" id="line-2005"><code></code></span>
<span class="codeline" id="line-2006"><code>// appendBytes converts bs to Iovecs and appends them to vecs.</code></span>
<span class="codeline" id="line-2007"><code>func appendBytes(vecs []Iovec, bs [][]byte) []Iovec {</code></span>
<span class="codeline" id="line-2008"><code>	for _, b := range bs {</code></span>
<span class="codeline" id="line-2009"><code>		var v Iovec</code></span>
<span class="codeline" id="line-2010"><code>		v.SetLen(len(b))</code></span>
<span class="codeline" id="line-2011"><code>		if len(b) &gt; 0 {</code></span>
<span class="codeline" id="line-2012"><code>			v.Base = &amp;b[0]</code></span>
<span class="codeline" id="line-2013"><code>		} else {</code></span>
<span class="codeline" id="line-2014"><code>			v.Base = (*byte)(unsafe.Pointer(&amp;_zero))</code></span>
<span class="codeline" id="line-2015"><code>		}</code></span>
<span class="codeline" id="line-2016"><code>		vecs = append(vecs, v)</code></span>
<span class="codeline" id="line-2017"><code>	}</code></span>
<span class="codeline" id="line-2018"><code>	return vecs</code></span>
<span class="codeline" id="line-2019"><code>}</code></span>
<span class="codeline" id="line-2020"><code></code></span>
<span class="codeline" id="line-2021"><code>// offs2lohi splits offs into its low and high order bits.</code></span>
<span class="codeline" id="line-2022"><code>func offs2lohi(offs int64) (lo, hi uintptr) {</code></span>
<span class="codeline" id="line-2023"><code>	const longBits = SizeofLong * 8</code></span>
<span class="codeline" id="line-2024"><code>	return uintptr(offs), uintptr(uint64(offs) &gt;&gt; (longBits - 1) &gt;&gt; 1) // two shifts to avoid false positive in vet</code></span>
<span class="codeline" id="line-2025"><code>}</code></span>
<span class="codeline" id="line-2026"><code></code></span>
<span class="codeline" id="line-2027"><code>func Readv(fd int, iovs [][]byte) (n int, err error) {</code></span>
<span class="codeline" id="line-2028"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2029"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2030"><code>	n, err = readv(fd, iovecs)</code></span>
<span class="codeline" id="line-2031"><code>	readvRacedetect(iovecs, n, err)</code></span>
<span class="codeline" id="line-2032"><code>	return n, err</code></span>
<span class="codeline" id="line-2033"><code>}</code></span>
<span class="codeline" id="line-2034"><code></code></span>
<span class="codeline" id="line-2035"><code>func Preadv(fd int, iovs [][]byte, offset int64) (n int, err error) {</code></span>
<span class="codeline" id="line-2036"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2037"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2038"><code>	lo, hi := offs2lohi(offset)</code></span>
<span class="codeline" id="line-2039"><code>	n, err = preadv(fd, iovecs, lo, hi)</code></span>
<span class="codeline" id="line-2040"><code>	readvRacedetect(iovecs, n, err)</code></span>
<span class="codeline" id="line-2041"><code>	return n, err</code></span>
<span class="codeline" id="line-2042"><code>}</code></span>
<span class="codeline" id="line-2043"><code></code></span>
<span class="codeline" id="line-2044"><code>func Preadv2(fd int, iovs [][]byte, offset int64, flags int) (n int, err error) {</code></span>
<span class="codeline" id="line-2045"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2046"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2047"><code>	lo, hi := offs2lohi(offset)</code></span>
<span class="codeline" id="line-2048"><code>	n, err = preadv2(fd, iovecs, lo, hi, flags)</code></span>
<span class="codeline" id="line-2049"><code>	readvRacedetect(iovecs, n, err)</code></span>
<span class="codeline" id="line-2050"><code>	return n, err</code></span>
<span class="codeline" id="line-2051"><code>}</code></span>
<span class="codeline" id="line-2052"><code></code></span>
<span class="codeline" id="line-2053"><code>func readvRacedetect(iovecs []Iovec, n int, err error) {</code></span>
<span class="codeline" id="line-2054"><code>	if !raceenabled {</code></span>
<span class="codeline" id="line-2055"><code>		return</code></span>
<span class="codeline" id="line-2056"><code>	}</code></span>
<span class="codeline" id="line-2057"><code>	for i := 0; n &gt; 0 &amp;&amp; i &lt; len(iovecs); i++ {</code></span>
<span class="codeline" id="line-2058"><code>		m := int(iovecs[i].Len)</code></span>
<span class="codeline" id="line-2059"><code>		if m &gt; n {</code></span>
<span class="codeline" id="line-2060"><code>			m = n</code></span>
<span class="codeline" id="line-2061"><code>		}</code></span>
<span class="codeline" id="line-2062"><code>		n -= m</code></span>
<span class="codeline" id="line-2063"><code>		if m &gt; 0 {</code></span>
<span class="codeline" id="line-2064"><code>			raceWriteRange(unsafe.Pointer(iovecs[i].Base), m)</code></span>
<span class="codeline" id="line-2065"><code>		}</code></span>
<span class="codeline" id="line-2066"><code>	}</code></span>
<span class="codeline" id="line-2067"><code>	if err == nil {</code></span>
<span class="codeline" id="line-2068"><code>		raceAcquire(unsafe.Pointer(&amp;ioSync))</code></span>
<span class="codeline" id="line-2069"><code>	}</code></span>
<span class="codeline" id="line-2070"><code>}</code></span>
<span class="codeline" id="line-2071"><code></code></span>
<span class="codeline" id="line-2072"><code>func Writev(fd int, iovs [][]byte) (n int, err error) {</code></span>
<span class="codeline" id="line-2073"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2074"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2075"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-2076"><code>		raceReleaseMerge(unsafe.Pointer(&amp;ioSync))</code></span>
<span class="codeline" id="line-2077"><code>	}</code></span>
<span class="codeline" id="line-2078"><code>	n, err = writev(fd, iovecs)</code></span>
<span class="codeline" id="line-2079"><code>	writevRacedetect(iovecs, n)</code></span>
<span class="codeline" id="line-2080"><code>	return n, err</code></span>
<span class="codeline" id="line-2081"><code>}</code></span>
<span class="codeline" id="line-2082"><code></code></span>
<span class="codeline" id="line-2083"><code>func Pwritev(fd int, iovs [][]byte, offset int64) (n int, err error) {</code></span>
<span class="codeline" id="line-2084"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2085"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2086"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-2087"><code>		raceReleaseMerge(unsafe.Pointer(&amp;ioSync))</code></span>
<span class="codeline" id="line-2088"><code>	}</code></span>
<span class="codeline" id="line-2089"><code>	lo, hi := offs2lohi(offset)</code></span>
<span class="codeline" id="line-2090"><code>	n, err = pwritev(fd, iovecs, lo, hi)</code></span>
<span class="codeline" id="line-2091"><code>	writevRacedetect(iovecs, n)</code></span>
<span class="codeline" id="line-2092"><code>	return n, err</code></span>
<span class="codeline" id="line-2093"><code>}</code></span>
<span class="codeline" id="line-2094"><code></code></span>
<span class="codeline" id="line-2095"><code>func Pwritev2(fd int, iovs [][]byte, offset int64, flags int) (n int, err error) {</code></span>
<span class="codeline" id="line-2096"><code>	iovecs := make([]Iovec, 0, minIovec)</code></span>
<span class="codeline" id="line-2097"><code>	iovecs = appendBytes(iovecs, iovs)</code></span>
<span class="codeline" id="line-2098"><code>	if raceenabled {</code></span>
<span class="codeline" id="line-2099"><code>		raceReleaseMerge(unsafe.Pointer(&amp;ioSync))</code></span>
<span class="codeline" id="line-2100"><code>	}</code></span>
<span class="codeline" id="line-2101"><code>	lo, hi := offs2lohi(offset)</code></span>
<span class="codeline" id="line-2102"><code>	n, err = pwritev2(fd, iovecs, lo, hi, flags)</code></span>
<span class="codeline" id="line-2103"><code>	writevRacedetect(iovecs, n)</code></span>
<span class="codeline" id="line-2104"><code>	return n, err</code></span>
<span class="codeline" id="line-2105"><code>}</code></span>
<span class="codeline" id="line-2106"><code></code></span>
<span class="codeline" id="line-2107"><code>func writevRacedetect(iovecs []Iovec, n int) {</code></span>
<span class="codeline" id="line-2108"><code>	if !raceenabled {</code></span>
<span class="codeline" id="line-2109"><code>		return</code></span>
<span class="codeline" id="line-2110"><code>	}</code></span>
<span class="codeline" id="line-2111"><code>	for i := 0; n &gt; 0 &amp;&amp; i &lt; len(iovecs); i++ {</code></span>
<span class="codeline" id="line-2112"><code>		m := int(iovecs[i].Len)</code></span>
<span class="codeline" id="line-2113"><code>		if m &gt; n {</code></span>
<span class="codeline" id="line-2114"><code>			m = n</code></span>
<span class="codeline" id="line-2115"><code>		}</code></span>
<span class="codeline" id="line-2116"><code>		n -= m</code></span>
<span class="codeline" id="line-2117"><code>		if m &gt; 0 {</code></span>
<span class="codeline" id="line-2118"><code>			raceReadRange(unsafe.Pointer(iovecs[i].Base), m)</code></span>
<span class="codeline" id="line-2119"><code>		}</code></span>
<span class="codeline" id="line-2120"><code>	}</code></span>
<span class="codeline" id="line-2121"><code>}</code></span>
<span class="codeline" id="line-2122"><code></code></span>
<span class="codeline" id="line-2123"><code>// mmap varies by architecture; see syscall_linux_*.go.</code></span>
<span class="codeline" id="line-2124"><code>//sys	munmap(addr uintptr, length uintptr) (err error)</code></span>
<span class="codeline" id="line-2125"><code>//sys	mremap(oldaddr uintptr, oldlength uintptr, newlength uintptr, flags int, newaddr uintptr) (xaddr uintptr, err error)</code></span>
<span class="codeline" id="line-2126"><code>//sys	Madvise(b []byte, advice int) (err error)</code></span>
<span class="codeline" id="line-2127"><code>//sys	Mprotect(b []byte, prot int) (err error)</code></span>
<span class="codeline" id="line-2128"><code>//sys	Mlock(b []byte) (err error)</code></span>
<span class="codeline" id="line-2129"><code>//sys	Mlockall(flags int) (err error)</code></span>
<span class="codeline" id="line-2130"><code>//sys	Msync(b []byte, flags int) (err error)</code></span>
<span class="codeline" id="line-2131"><code>//sys	Munlock(b []byte) (err error)</code></span>
<span class="codeline" id="line-2132"><code>//sys	Munlockall() (err error)</code></span>
<span class="codeline" id="line-2133"><code></code></span>
<span class="codeline" id="line-2134"><code>const (</code></span>
<span class="codeline" id="line-2135"><code>	mremapFixed     = MREMAP_FIXED</code></span>
<span class="codeline" id="line-2136"><code>	mremapDontunmap = MREMAP_DONTUNMAP</code></span>
<span class="codeline" id="line-2137"><code>	mremapMaymove   = MREMAP_MAYMOVE</code></span>
<span class="codeline" id="line-2138"><code>)</code></span>
<span class="codeline" id="line-2139"><code></code></span>
<span class="codeline" id="line-2140"><code>// Vmsplice splices user pages from a slice of Iovecs into a pipe specified by fd,</code></span>
<span class="codeline" id="line-2141"><code>// using the specified flags.</code></span>
<span class="codeline" id="line-2142"><code>func Vmsplice(fd int, iovs []Iovec, flags int) (int, error) {</code></span>
<span class="codeline" id="line-2143"><code>	var p unsafe.Pointer</code></span>
<span class="codeline" id="line-2144"><code>	if len(iovs) &gt; 0 {</code></span>
<span class="codeline" id="line-2145"><code>		p = unsafe.Pointer(&amp;iovs[0])</code></span>
<span class="codeline" id="line-2146"><code>	}</code></span>
<span class="codeline" id="line-2147"><code></code></span>
<span class="codeline" id="line-2148"><code>	n, _, errno := Syscall6(SYS_VMSPLICE, uintptr(fd), uintptr(p), uintptr(len(iovs)), uintptr(flags), 0, 0)</code></span>
<span class="codeline" id="line-2149"><code>	if errno != 0 {</code></span>
<span class="codeline" id="line-2150"><code>		return 0, syscall.Errno(errno)</code></span>
<span class="codeline" id="line-2151"><code>	}</code></span>
<span class="codeline" id="line-2152"><code></code></span>
<span class="codeline" id="line-2153"><code>	return int(n), nil</code></span>
<span class="codeline" id="line-2154"><code>}</code></span>
<span class="codeline" id="line-2155"><code></code></span>
<span class="codeline" id="line-2156"><code>func isGroupMember(gid int) bool {</code></span>
<span class="codeline" id="line-2157"><code>	groups, err := Getgroups()</code></span>
<span class="codeline" id="line-2158"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2159"><code>		return false</code></span>
<span class="codeline" id="line-2160"><code>	}</code></span>
<span class="codeline" id="line-2161"><code></code></span>
<span class="codeline" id="line-2162"><code>	for _, g := range groups {</code></span>
<span class="codeline" id="line-2163"><code>		if g == gid {</code></span>
<span class="codeline" id="line-2164"><code>			return true</code></span>
<span class="codeline" id="line-2165"><code>		}</code></span>
<span class="codeline" id="line-2166"><code>	}</code></span>
<span class="codeline" id="line-2167"><code>	return false</code></span>
<span class="codeline" id="line-2168"><code>}</code></span>
<span class="codeline" id="line-2169"><code></code></span>
<span class="codeline" id="line-2170"><code>func isCapDacOverrideSet() bool {</code></span>
<span class="codeline" id="line-2171"><code>	hdr := CapUserHeader{Version: LINUX_CAPABILITY_VERSION_3}</code></span>
<span class="codeline" id="line-2172"><code>	data := [2]CapUserData{}</code></span>
<span class="codeline" id="line-2173"><code>	err := Capget(&amp;hdr, &amp;data[0])</code></span>
<span class="codeline" id="line-2174"><code></code></span>
<span class="codeline" id="line-2175"><code>	return err == nil &amp;&amp; data[0].Effective&amp;(1&lt;&lt;CAP_DAC_OVERRIDE) != 0</code></span>
<span class="codeline" id="line-2176"><code>}</code></span>
<span class="codeline" id="line-2177"><code></code></span>
<span class="codeline" id="line-2178"><code>//sys	faccessat(dirfd int, path string, mode uint32) (err error)</code></span>
<span class="codeline" id="line-2179"><code>//sys	Faccessat2(dirfd int, path string, mode uint32, flags int) (err error)</code></span>
<span class="codeline" id="line-2180"><code></code></span>
<span class="codeline" id="line-2181"><code>func Faccessat(dirfd int, path string, mode uint32, flags int) (err error) {</code></span>
<span class="codeline" id="line-2182"><code>	if flags == 0 {</code></span>
<span class="codeline" id="line-2183"><code>		return faccessat(dirfd, path, mode)</code></span>
<span class="codeline" id="line-2184"><code>	}</code></span>
<span class="codeline" id="line-2185"><code></code></span>
<span class="codeline" id="line-2186"><code>	if err := Faccessat2(dirfd, path, mode, flags); err != ENOSYS &amp;&amp; err != EPERM {</code></span>
<span class="codeline" id="line-2187"><code>		return err</code></span>
<span class="codeline" id="line-2188"><code>	}</code></span>
<span class="codeline" id="line-2189"><code></code></span>
<span class="codeline" id="line-2190"><code>	// The Linux kernel faccessat system call does not take any flags.</code></span>
<span class="codeline" id="line-2191"><code>	// The glibc faccessat implements the flags itself; see</code></span>
<span class="codeline" id="line-2192"><code>	// https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/faccessat.c;hb=HEAD</code></span>
<span class="codeline" id="line-2193"><code>	// Because people naturally expect syscall.Faccessat to act</code></span>
<span class="codeline" id="line-2194"><code>	// like C faccessat, we do the same.</code></span>
<span class="codeline" id="line-2195"><code></code></span>
<span class="codeline" id="line-2196"><code>	if flags &amp; ^(AT_SYMLINK_NOFOLLOW|AT_EACCESS) != 0 {</code></span>
<span class="codeline" id="line-2197"><code>		return EINVAL</code></span>
<span class="codeline" id="line-2198"><code>	}</code></span>
<span class="codeline" id="line-2199"><code></code></span>
<span class="codeline" id="line-2200"><code>	var st Stat_t</code></span>
<span class="codeline" id="line-2201"><code>	if err := Fstatat(dirfd, path, &amp;st, flags&amp;AT_SYMLINK_NOFOLLOW); err != nil {</code></span>
<span class="codeline" id="line-2202"><code>		return err</code></span>
<span class="codeline" id="line-2203"><code>	}</code></span>
<span class="codeline" id="line-2204"><code></code></span>
<span class="codeline" id="line-2205"><code>	mode &amp;= 7</code></span>
<span class="codeline" id="line-2206"><code>	if mode == 0 {</code></span>
<span class="codeline" id="line-2207"><code>		return nil</code></span>
<span class="codeline" id="line-2208"><code>	}</code></span>
<span class="codeline" id="line-2209"><code></code></span>
<span class="codeline" id="line-2210"><code>	var uid int</code></span>
<span class="codeline" id="line-2211"><code>	if flags&amp;AT_EACCESS != 0 {</code></span>
<span class="codeline" id="line-2212"><code>		uid = Geteuid()</code></span>
<span class="codeline" id="line-2213"><code>		if uid != 0 &amp;&amp; isCapDacOverrideSet() {</code></span>
<span class="codeline" id="line-2214"><code>			// If CAP_DAC_OVERRIDE is set, file access check is</code></span>
<span class="codeline" id="line-2215"><code>			// done by the kernel in the same way as for root</code></span>
<span class="codeline" id="line-2216"><code>			// (see generic_permission() in the Linux sources).</code></span>
<span class="codeline" id="line-2217"><code>			uid = 0</code></span>
<span class="codeline" id="line-2218"><code>		}</code></span>
<span class="codeline" id="line-2219"><code>	} else {</code></span>
<span class="codeline" id="line-2220"><code>		uid = Getuid()</code></span>
<span class="codeline" id="line-2221"><code>	}</code></span>
<span class="codeline" id="line-2222"><code></code></span>
<span class="codeline" id="line-2223"><code>	if uid == 0 {</code></span>
<span class="codeline" id="line-2224"><code>		if mode&amp;1 == 0 {</code></span>
<span class="codeline" id="line-2225"><code>			// Root can read and write any file.</code></span>
<span class="codeline" id="line-2226"><code>			return nil</code></span>
<span class="codeline" id="line-2227"><code>		}</code></span>
<span class="codeline" id="line-2228"><code>		if st.Mode&amp;0111 != 0 {</code></span>
<span class="codeline" id="line-2229"><code>			// Root can execute any file that anybody can execute.</code></span>
<span class="codeline" id="line-2230"><code>			return nil</code></span>
<span class="codeline" id="line-2231"><code>		}</code></span>
<span class="codeline" id="line-2232"><code>		return EACCES</code></span>
<span class="codeline" id="line-2233"><code>	}</code></span>
<span class="codeline" id="line-2234"><code></code></span>
<span class="codeline" id="line-2235"><code>	var fmode uint32</code></span>
<span class="codeline" id="line-2236"><code>	if uint32(uid) == st.Uid {</code></span>
<span class="codeline" id="line-2237"><code>		fmode = (st.Mode &gt;&gt; 6) &amp; 7</code></span>
<span class="codeline" id="line-2238"><code>	} else {</code></span>
<span class="codeline" id="line-2239"><code>		var gid int</code></span>
<span class="codeline" id="line-2240"><code>		if flags&amp;AT_EACCESS != 0 {</code></span>
<span class="codeline" id="line-2241"><code>			gid = Getegid()</code></span>
<span class="codeline" id="line-2242"><code>		} else {</code></span>
<span class="codeline" id="line-2243"><code>			gid = Getgid()</code></span>
<span class="codeline" id="line-2244"><code>		}</code></span>
<span class="codeline" id="line-2245"><code></code></span>
<span class="codeline" id="line-2246"><code>		if uint32(gid) == st.Gid || isGroupMember(int(st.Gid)) {</code></span>
<span class="codeline" id="line-2247"><code>			fmode = (st.Mode &gt;&gt; 3) &amp; 7</code></span>
<span class="codeline" id="line-2248"><code>		} else {</code></span>
<span class="codeline" id="line-2249"><code>			fmode = st.Mode &amp; 7</code></span>
<span class="codeline" id="line-2250"><code>		}</code></span>
<span class="codeline" id="line-2251"><code>	}</code></span>
<span class="codeline" id="line-2252"><code></code></span>
<span class="codeline" id="line-2253"><code>	if fmode&amp;mode == mode {</code></span>
<span class="codeline" id="line-2254"><code>		return nil</code></span>
<span class="codeline" id="line-2255"><code>	}</code></span>
<span class="codeline" id="line-2256"><code></code></span>
<span class="codeline" id="line-2257"><code>	return EACCES</code></span>
<span class="codeline" id="line-2258"><code>}</code></span>
<span class="codeline" id="line-2259"><code></code></span>
<span class="codeline" id="line-2260"><code>//sys	nameToHandleAt(dirFD int, pathname string, fh *fileHandle, mountID *_C_int, flags int) (err error) = SYS_NAME_TO_HANDLE_AT</code></span>
<span class="codeline" id="line-2261"><code>//sys	openByHandleAt(mountFD int, fh *fileHandle, flags int) (fd int, err error) = SYS_OPEN_BY_HANDLE_AT</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>// fileHandle is the argument to nameToHandleAt and openByHandleAt. We</code></span>
<span class="codeline" id="line-2264"><code>// originally tried to generate it via unix/linux/types.go with "type</code></span>
<span class="codeline" id="line-2265"><code>// fileHandle C.struct_file_handle" but that generated empty structs</code></span>
<span class="codeline" id="line-2266"><code>// for mips64 and mips64le. Instead, hard code it for now (it's the</code></span>
<span class="codeline" id="line-2267"><code>// same everywhere else) until the mips64 generator issue is fixed.</code></span>
<span class="codeline" id="line-2268"><code>type fileHandle struct {</code></span>
<span class="codeline" id="line-2269"><code>	Bytes uint32</code></span>
<span class="codeline" id="line-2270"><code>	Type  int32</code></span>
<span class="codeline" id="line-2271"><code>}</code></span>
<span class="codeline" id="line-2272"><code></code></span>
<span class="codeline" id="line-2273"><code>// FileHandle represents the C struct file_handle used by</code></span>
<span class="codeline" id="line-2274"><code>// name_to_handle_at (see NameToHandleAt) and open_by_handle_at (see</code></span>
<span class="codeline" id="line-2275"><code>// OpenByHandleAt).</code></span>
<span class="codeline" id="line-2276"><code>type FileHandle struct {</code></span>
<span class="codeline" id="line-2277"><code>	*fileHandle</code></span>
<span class="codeline" id="line-2278"><code>}</code></span>
<span class="codeline" id="line-2279"><code></code></span>
<span class="codeline" id="line-2280"><code>// NewFileHandle constructs a FileHandle.</code></span>
<span class="codeline" id="line-2281"><code>func NewFileHandle(handleType int32, handle []byte) FileHandle {</code></span>
<span class="codeline" id="line-2282"><code>	const hdrSize = unsafe.Sizeof(fileHandle{})</code></span>
<span class="codeline" id="line-2283"><code>	buf := make([]byte, hdrSize+uintptr(len(handle)))</code></span>
<span class="codeline" id="line-2284"><code>	copy(buf[hdrSize:], handle)</code></span>
<span class="codeline" id="line-2285"><code>	fh := (*fileHandle)(unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-2286"><code>	fh.Type = handleType</code></span>
<span class="codeline" id="line-2287"><code>	fh.Bytes = uint32(len(handle))</code></span>
<span class="codeline" id="line-2288"><code>	return FileHandle{fh}</code></span>
<span class="codeline" id="line-2289"><code>}</code></span>
<span class="codeline" id="line-2290"><code></code></span>
<span class="codeline" id="line-2291"><code>func (fh *FileHandle) Size() int   { return int(fh.fileHandle.Bytes) }</code></span>
<span class="codeline" id="line-2292"><code>func (fh *FileHandle) Type() int32 { return fh.fileHandle.Type }</code></span>
<span class="codeline" id="line-2293"><code>func (fh *FileHandle) Bytes() []byte {</code></span>
<span class="codeline" id="line-2294"><code>	n := fh.Size()</code></span>
<span class="codeline" id="line-2295"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-2296"><code>		return nil</code></span>
<span class="codeline" id="line-2297"><code>	}</code></span>
<span class="codeline" id="line-2298"><code>	return unsafe.Slice((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;fh.fileHandle.Type))+4)), n)</code></span>
<span class="codeline" id="line-2299"><code>}</code></span>
<span class="codeline" id="line-2300"><code></code></span>
<span class="codeline" id="line-2301"><code>// NameToHandleAt wraps the name_to_handle_at system call; it obtains</code></span>
<span class="codeline" id="line-2302"><code>// a handle for a path name.</code></span>
<span class="codeline" id="line-2303"><code>func NameToHandleAt(dirfd int, path string, flags int) (handle FileHandle, mountID int, err error) {</code></span>
<span class="codeline" id="line-2304"><code>	var mid _C_int</code></span>
<span class="codeline" id="line-2305"><code>	// Try first with a small buffer, assuming the handle will</code></span>
<span class="codeline" id="line-2306"><code>	// only be 32 bytes.</code></span>
<span class="codeline" id="line-2307"><code>	size := uint32(32 + unsafe.Sizeof(fileHandle{}))</code></span>
<span class="codeline" id="line-2308"><code>	didResize := false</code></span>
<span class="codeline" id="line-2309"><code>	for {</code></span>
<span class="codeline" id="line-2310"><code>		buf := make([]byte, size)</code></span>
<span class="codeline" id="line-2311"><code>		fh := (*fileHandle)(unsafe.Pointer(&amp;buf[0]))</code></span>
<span class="codeline" id="line-2312"><code>		fh.Bytes = size - uint32(unsafe.Sizeof(fileHandle{}))</code></span>
<span class="codeline" id="line-2313"><code>		err = nameToHandleAt(dirfd, path, fh, &amp;mid, flags)</code></span>
<span class="codeline" id="line-2314"><code>		if err == EOVERFLOW {</code></span>
<span class="codeline" id="line-2315"><code>			if didResize {</code></span>
<span class="codeline" id="line-2316"><code>				// We shouldn't need to resize more than once</code></span>
<span class="codeline" id="line-2317"><code>				return</code></span>
<span class="codeline" id="line-2318"><code>			}</code></span>
<span class="codeline" id="line-2319"><code>			didResize = true</code></span>
<span class="codeline" id="line-2320"><code>			size = fh.Bytes + uint32(unsafe.Sizeof(fileHandle{}))</code></span>
<span class="codeline" id="line-2321"><code>			continue</code></span>
<span class="codeline" id="line-2322"><code>		}</code></span>
<span class="codeline" id="line-2323"><code>		if err != nil {</code></span>
<span class="codeline" id="line-2324"><code>			return</code></span>
<span class="codeline" id="line-2325"><code>		}</code></span>
<span class="codeline" id="line-2326"><code>		return FileHandle{fh}, int(mid), nil</code></span>
<span class="codeline" id="line-2327"><code>	}</code></span>
<span class="codeline" id="line-2328"><code>}</code></span>
<span class="codeline" id="line-2329"><code></code></span>
<span class="codeline" id="line-2330"><code>// OpenByHandleAt wraps the open_by_handle_at system call; it opens a</code></span>
<span class="codeline" id="line-2331"><code>// file via a handle as previously returned by NameToHandleAt.</code></span>
<span class="codeline" id="line-2332"><code>func OpenByHandleAt(mountFD int, handle FileHandle, flags int) (fd int, err error) {</code></span>
<span class="codeline" id="line-2333"><code>	return openByHandleAt(mountFD, handle.fileHandle, flags)</code></span>
<span class="codeline" id="line-2334"><code>}</code></span>
<span class="codeline" id="line-2335"><code></code></span>
<span class="codeline" id="line-2336"><code>// Klogset wraps the sys_syslog system call; it sets console_loglevel to</code></span>
<span class="codeline" id="line-2337"><code>// the value specified by arg and passes a dummy pointer to bufp.</code></span>
<span class="codeline" id="line-2338"><code>func Klogset(typ int, arg int) (err error) {</code></span>
<span class="codeline" id="line-2339"><code>	var p unsafe.Pointer</code></span>
<span class="codeline" id="line-2340"><code>	_, _, errno := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(p), uintptr(arg))</code></span>
<span class="codeline" id="line-2341"><code>	if errno != 0 {</code></span>
<span class="codeline" id="line-2342"><code>		return errnoErr(errno)</code></span>
<span class="codeline" id="line-2343"><code>	}</code></span>
<span class="codeline" id="line-2344"><code>	return nil</code></span>
<span class="codeline" id="line-2345"><code>}</code></span>
<span class="codeline" id="line-2346"><code></code></span>
<span class="codeline" id="line-2347"><code>// RemoteIovec is Iovec with the pointer replaced with an integer.</code></span>
<span class="codeline" id="line-2348"><code>// It is used for ProcessVMReadv and ProcessVMWritev, where the pointer</code></span>
<span class="codeline" id="line-2349"><code>// refers to a location in a different process' address space, which</code></span>
<span class="codeline" id="line-2350"><code>// would confuse the Go garbage collector.</code></span>
<span class="codeline" id="line-2351"><code>type RemoteIovec struct {</code></span>
<span class="codeline" id="line-2352"><code>	Base uintptr</code></span>
<span class="codeline" id="line-2353"><code>	Len  int</code></span>
<span class="codeline" id="line-2354"><code>}</code></span>
<span class="codeline" id="line-2355"><code></code></span>
<span class="codeline" id="line-2356"><code>//sys	ProcessVMReadv(pid int, localIov []Iovec, remoteIov []RemoteIovec, flags uint) (n int, err error) = SYS_PROCESS_VM_READV</code></span>
<span class="codeline" id="line-2357"><code>//sys	ProcessVMWritev(pid int, localIov []Iovec, remoteIov []RemoteIovec, flags uint) (n int, err error) = SYS_PROCESS_VM_WRITEV</code></span>
<span class="codeline" id="line-2358"><code></code></span>
<span class="codeline" id="line-2359"><code>//sys	PidfdOpen(pid int, flags int) (fd int, err error) = SYS_PIDFD_OPEN</code></span>
<span class="codeline" id="line-2360"><code>//sys	PidfdGetfd(pidfd int, targetfd int, flags int) (fd int, err error) = SYS_PIDFD_GETFD</code></span>
<span class="codeline" id="line-2361"><code>//sys	PidfdSendSignal(pidfd int, sig Signal, info *Siginfo, flags int) (err error) = SYS_PIDFD_SEND_SIGNAL</code></span>
<span class="codeline" id="line-2362"><code></code></span>
<span class="codeline" id="line-2363"><code>//sys	shmat(id int, addr uintptr, flag int) (ret uintptr, err error)</code></span>
<span class="codeline" id="line-2364"><code>//sys	shmctl(id int, cmd int, buf *SysvShmDesc) (result int, err error)</code></span>
<span class="codeline" id="line-2365"><code>//sys	shmdt(addr uintptr) (err error)</code></span>
<span class="codeline" id="line-2366"><code>//sys	shmget(key int, size int, flag int) (id int, err error)</code></span>
<span class="codeline" id="line-2367"><code></code></span>
<span class="codeline" id="line-2368"><code>//sys	getitimer(which int, currValue *Itimerval) (err error)</code></span>
<span class="codeline" id="line-2369"><code>//sys	setitimer(which int, newValue *Itimerval, oldValue *Itimerval) (err error)</code></span>
<span class="codeline" id="line-2370"><code></code></span>
<span class="codeline" id="line-2371"><code>// MakeItimerval creates an Itimerval from interval and value durations.</code></span>
<span class="codeline" id="line-2372"><code>func MakeItimerval(interval, value time.Duration) Itimerval {</code></span>
<span class="codeline" id="line-2373"><code>	return Itimerval{</code></span>
<span class="codeline" id="line-2374"><code>		Interval: NsecToTimeval(interval.Nanoseconds()),</code></span>
<span class="codeline" id="line-2375"><code>		Value:    NsecToTimeval(value.Nanoseconds()),</code></span>
<span class="codeline" id="line-2376"><code>	}</code></span>
<span class="codeline" id="line-2377"><code>}</code></span>
<span class="codeline" id="line-2378"><code></code></span>
<span class="codeline" id="line-2379"><code>// A value which may be passed to the which parameter for Getitimer and</code></span>
<span class="codeline" id="line-2380"><code>// Setitimer.</code></span>
<span class="codeline" id="line-2381"><code>type ItimerWhich int</code></span>
<span class="codeline" id="line-2382"><code></code></span>
<span class="codeline" id="line-2383"><code>// Possible which values for Getitimer and Setitimer.</code></span>
<span class="codeline" id="line-2384"><code>const (</code></span>
<span class="codeline" id="line-2385"><code>	ItimerReal    ItimerWhich = ITIMER_REAL</code></span>
<span class="codeline" id="line-2386"><code>	ItimerVirtual ItimerWhich = ITIMER_VIRTUAL</code></span>
<span class="codeline" id="line-2387"><code>	ItimerProf    ItimerWhich = ITIMER_PROF</code></span>
<span class="codeline" id="line-2388"><code>)</code></span>
<span class="codeline" id="line-2389"><code></code></span>
<span class="codeline" id="line-2390"><code>// Getitimer wraps getitimer(2) to return the current value of the timer</code></span>
<span class="codeline" id="line-2391"><code>// specified by which.</code></span>
<span class="codeline" id="line-2392"><code>func Getitimer(which ItimerWhich) (Itimerval, error) {</code></span>
<span class="codeline" id="line-2393"><code>	var it Itimerval</code></span>
<span class="codeline" id="line-2394"><code>	if err := getitimer(int(which), &amp;it); err != nil {</code></span>
<span class="codeline" id="line-2395"><code>		return Itimerval{}, err</code></span>
<span class="codeline" id="line-2396"><code>	}</code></span>
<span class="codeline" id="line-2397"><code></code></span>
<span class="codeline" id="line-2398"><code>	return it, nil</code></span>
<span class="codeline" id="line-2399"><code>}</code></span>
<span class="codeline" id="line-2400"><code></code></span>
<span class="codeline" id="line-2401"><code>// Setitimer wraps setitimer(2) to arm or disarm the timer specified by which.</code></span>
<span class="codeline" id="line-2402"><code>// It returns the previous value of the timer.</code></span>
<span class="codeline" id="line-2403"><code>//</code></span>
<span class="codeline" id="line-2404"><code>// If the Itimerval argument is the zero value, the timer will be disarmed.</code></span>
<span class="codeline" id="line-2405"><code>func Setitimer(which ItimerWhich, it Itimerval) (Itimerval, error) {</code></span>
<span class="codeline" id="line-2406"><code>	var prev Itimerval</code></span>
<span class="codeline" id="line-2407"><code>	if err := setitimer(int(which), &amp;it, &amp;prev); err != nil {</code></span>
<span class="codeline" id="line-2408"><code>		return Itimerval{}, err</code></span>
<span class="codeline" id="line-2409"><code>	}</code></span>
<span class="codeline" id="line-2410"><code></code></span>
<span class="codeline" id="line-2411"><code>	return prev, nil</code></span>
<span class="codeline" id="line-2412"><code>}</code></span>
<span class="codeline" id="line-2413"><code></code></span>
<span class="codeline" id="line-2414"><code>//sysnb	rtSigprocmask(how int, set *Sigset_t, oldset *Sigset_t, sigsetsize uintptr) (err error) = SYS_RT_SIGPROCMASK</code></span>
<span class="codeline" id="line-2415"><code></code></span>
<span class="codeline" id="line-2416"><code>func PthreadSigmask(how int, set, oldset *Sigset_t) error {</code></span>
<span class="codeline" id="line-2417"><code>	if oldset != nil {</code></span>
<span class="codeline" id="line-2418"><code>		// Explicitly clear in case Sigset_t is larger than _C__NSIG.</code></span>
<span class="codeline" id="line-2419"><code>		*oldset = Sigset_t{}</code></span>
<span class="codeline" id="line-2420"><code>	}</code></span>
<span class="codeline" id="line-2421"><code>	return rtSigprocmask(how, set, oldset, _C__NSIG/8)</code></span>
<span class="codeline" id="line-2422"><code>}</code></span>
<span class="codeline" id="line-2423"><code></code></span>
<span class="codeline" id="line-2424"><code>//sysnb	getresuid(ruid *_C_int, euid *_C_int, suid *_C_int)</code></span>
<span class="codeline" id="line-2425"><code>//sysnb	getresgid(rgid *_C_int, egid *_C_int, sgid *_C_int)</code></span>
<span class="codeline" id="line-2426"><code></code></span>
<span class="codeline" id="line-2427"><code>func Getresuid() (ruid, euid, suid int) {</code></span>
<span class="codeline" id="line-2428"><code>	var r, e, s _C_int</code></span>
<span class="codeline" id="line-2429"><code>	getresuid(&amp;r, &amp;e, &amp;s)</code></span>
<span class="codeline" id="line-2430"><code>	return int(r), int(e), int(s)</code></span>
<span class="codeline" id="line-2431"><code>}</code></span>
<span class="codeline" id="line-2432"><code></code></span>
<span class="codeline" id="line-2433"><code>func Getresgid() (rgid, egid, sgid int) {</code></span>
<span class="codeline" id="line-2434"><code>	var r, e, s _C_int</code></span>
<span class="codeline" id="line-2435"><code>	getresgid(&amp;r, &amp;e, &amp;s)</code></span>
<span class="codeline" id="line-2436"><code>	return int(r), int(e), int(s)</code></span>
<span class="codeline" id="line-2437"><code>}</code></span>
<span class="codeline" id="line-2438"><code></code></span>
<span class="codeline" id="line-2439"><code>// Pselect is a wrapper around the Linux pselect6 system call.</code></span>
<span class="codeline" id="line-2440"><code>// This version does not modify the timeout argument.</code></span>
<span class="codeline" id="line-2441"><code>func Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {</code></span>
<span class="codeline" id="line-2442"><code>	// Per https://man7.org/linux/man-pages/man2/select.2.html#NOTES,</code></span>
<span class="codeline" id="line-2443"><code>	// The Linux pselect6() system call modifies its timeout argument.</code></span>
<span class="codeline" id="line-2444"><code>	// [Not modifying the argument] is the behavior required by POSIX.1-2001.</code></span>
<span class="codeline" id="line-2445"><code>	var mutableTimeout *Timespec</code></span>
<span class="codeline" id="line-2446"><code>	if timeout != nil {</code></span>
<span class="codeline" id="line-2447"><code>		mutableTimeout = new(Timespec)</code></span>
<span class="codeline" id="line-2448"><code>		*mutableTimeout = *timeout</code></span>
<span class="codeline" id="line-2449"><code>	}</code></span>
<span class="codeline" id="line-2450"><code></code></span>
<span class="codeline" id="line-2451"><code>	// The final argument of the pselect6() system call is not a</code></span>
<span class="codeline" id="line-2452"><code>	// sigset_t * pointer, but is instead a structure</code></span>
<span class="codeline" id="line-2453"><code>	var kernelMask *sigset_argpack</code></span>
<span class="codeline" id="line-2454"><code>	if sigmask != nil {</code></span>
<span class="codeline" id="line-2455"><code>		wordBits := 32 &lt;&lt; (^uintptr(0) &gt;&gt; 63) // see math.intSize</code></span>
<span class="codeline" id="line-2456"><code></code></span>
<span class="codeline" id="line-2457"><code>		// A sigset stores one bit per signal,</code></span>
<span class="codeline" id="line-2458"><code>		// offset by 1 (because signal 0 does not exist).</code></span>
<span class="codeline" id="line-2459"><code>		// So the number of words needed is __C_NSIG - 1 / wordBits.</code></span>
<span class="codeline" id="line-2460"><code>		sigsetWords := (_C__NSIG - 1 + wordBits - 1) / (wordBits)</code></span>
<span class="codeline" id="line-2461"><code></code></span>
<span class="codeline" id="line-2462"><code>		sigsetBytes := uintptr(sigsetWords * (wordBits / 8))</code></span>
<span class="codeline" id="line-2463"><code>		kernelMask = &amp;sigset_argpack{</code></span>
<span class="codeline" id="line-2464"><code>			ss:    sigmask,</code></span>
<span class="codeline" id="line-2465"><code>			ssLen: sigsetBytes,</code></span>
<span class="codeline" id="line-2466"><code>		}</code></span>
<span class="codeline" id="line-2467"><code>	}</code></span>
<span class="codeline" id="line-2468"><code></code></span>
<span class="codeline" id="line-2469"><code>	return pselect6(nfd, r, w, e, mutableTimeout, kernelMask)</code></span>
<span class="codeline" id="line-2470"><code>}</code></span>
<span class="codeline" id="line-2471"><code></code></span>
<span class="codeline" id="line-2472"><code>//sys	schedSetattr(pid int, attr *SchedAttr, flags uint) (err error)</code></span>
<span class="codeline" id="line-2473"><code>//sys	schedGetattr(pid int, attr *SchedAttr, size uint, flags uint) (err error)</code></span>
<span class="codeline" id="line-2474"><code></code></span>
<span class="codeline" id="line-2475"><code>// SchedSetAttr is a wrapper for sched_setattr(2) syscall.</code></span>
<span class="codeline" id="line-2476"><code>// https://man7.org/linux/man-pages/man2/sched_setattr.2.html</code></span>
<span class="codeline" id="line-2477"><code>func SchedSetAttr(pid int, attr *SchedAttr, flags uint) error {</code></span>
<span class="codeline" id="line-2478"><code>	if attr == nil {</code></span>
<span class="codeline" id="line-2479"><code>		return EINVAL</code></span>
<span class="codeline" id="line-2480"><code>	}</code></span>
<span class="codeline" id="line-2481"><code>	attr.Size = SizeofSchedAttr</code></span>
<span class="codeline" id="line-2482"><code>	return schedSetattr(pid, attr, flags)</code></span>
<span class="codeline" id="line-2483"><code>}</code></span>
<span class="codeline" id="line-2484"><code></code></span>
<span class="codeline" id="line-2485"><code>// SchedGetAttr is a wrapper for sched_getattr(2) syscall.</code></span>
<span class="codeline" id="line-2486"><code>// https://man7.org/linux/man-pages/man2/sched_getattr.2.html</code></span>
<span class="codeline" id="line-2487"><code>func SchedGetAttr(pid int, flags uint) (*SchedAttr, error) {</code></span>
<span class="codeline" id="line-2488"><code>	attr := &amp;SchedAttr{}</code></span>
<span class="codeline" id="line-2489"><code>	if err := schedGetattr(pid, attr, SizeofSchedAttr, flags); err != nil {</code></span>
<span class="codeline" id="line-2490"><code>		return nil, err</code></span>
<span class="codeline" id="line-2491"><code>	}</code></span>
<span class="codeline" id="line-2492"><code>	return attr, nil</code></span>
<span class="codeline" id="line-2493"><code>}</code></span>
<span class="codeline" id="line-2494"><code></code></span>
<span class="codeline" id="line-2495"><code>//sys	Cachestat(fd uint, crange *CachestatRange, cstat *Cachestat_t, flags uint) (err error)</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>