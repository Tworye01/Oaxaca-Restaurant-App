<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: bsoncore.go in package go.mongodb.org/mongo-driver/x/bsonx/bsoncore</title>
<link href="../../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	bsoncore.go

<span class="title">Belonging Package</span>
	<a href="../../../../../../pkg/go.mongodb.org/mongo-driver/x/bsonx/bsoncore.html">go.mongodb.org/mongo-driver/x/bsonx/bsoncore</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright (C) MongoDB, Inc. 2017-present.</code></span>
<span class="codeline" id="line-2"><code>//</code></span>
<span class="codeline" id="line-3"><code>// Licensed under the Apache License, Version 2.0 (the "License"); you may</code></span>
<span class="codeline" id="line-4"><code>// not use this file except in compliance with the License. You may obtain</code></span>
<span class="codeline" id="line-5"><code>// a copy of the License at http://www.apache.org/licenses/LICENSE-2.0</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package bsoncore // import "go.mongodb.org/mongo-driver/x/bsonx/bsoncore"</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"bytes"</code></span>
<span class="codeline" id="line-11"><code>	"fmt"</code></span>
<span class="codeline" id="line-12"><code>	"math"</code></span>
<span class="codeline" id="line-13"><code>	"strconv"</code></span>
<span class="codeline" id="line-14"><code>	"strings"</code></span>
<span class="codeline" id="line-15"><code>	"time"</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>	"go.mongodb.org/mongo-driver/bson/bsontype"</code></span>
<span class="codeline" id="line-18"><code>	"go.mongodb.org/mongo-driver/bson/primitive"</code></span>
<span class="codeline" id="line-19"><code>)</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>const (</code></span>
<span class="codeline" id="line-22"><code>	// EmptyDocumentLength is the length of a document that has been started/ended but has no elements.</code></span>
<span class="codeline" id="line-23"><code>	EmptyDocumentLength = 5</code></span>
<span class="codeline" id="line-24"><code>	// nullTerminator is a string version of the 0 byte that is appended at the end of cstrings.</code></span>
<span class="codeline" id="line-25"><code>	nullTerminator       = string(byte(0))</code></span>
<span class="codeline" id="line-26"><code>	invalidKeyPanicMsg   = "BSON element keys cannot contain null bytes"</code></span>
<span class="codeline" id="line-27"><code>	invalidRegexPanicMsg = "BSON regex values cannot contain null bytes"</code></span>
<span class="codeline" id="line-28"><code>)</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>// AppendType will append t to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-31"><code>func AppendType(dst []byte, t bsontype.Type) []byte { return append(dst, byte(t)) }</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>// AppendKey will append key to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-34"><code>func AppendKey(dst []byte, key string) []byte { return append(dst, key+nullTerminator...) }</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// AppendHeader will append Type t and key to dst and return the extended</code></span>
<span class="codeline" id="line-37"><code>// buffer.</code></span>
<span class="codeline" id="line-38"><code>func AppendHeader(dst []byte, t bsontype.Type, key string) []byte {</code></span>
<span class="codeline" id="line-39"><code>	if !isValidCString(key) {</code></span>
<span class="codeline" id="line-40"><code>		panic(invalidKeyPanicMsg)</code></span>
<span class="codeline" id="line-41"><code>	}</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>	dst = AppendType(dst, t)</code></span>
<span class="codeline" id="line-44"><code>	dst = append(dst, key...)</code></span>
<span class="codeline" id="line-45"><code>	return append(dst, 0x00)</code></span>
<span class="codeline" id="line-46"><code>	// return append(AppendType(dst, t), key+string(0x00)...)</code></span>
<span class="codeline" id="line-47"><code>}</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>// TODO(skriptble): All of the Read* functions should return src resliced to start just after what was read.</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// ReadType will return the first byte of the provided []byte as a type. If</code></span>
<span class="codeline" id="line-52"><code>// there is no available byte, false is returned.</code></span>
<span class="codeline" id="line-53"><code>func ReadType(src []byte) (bsontype.Type, []byte, bool) {</code></span>
<span class="codeline" id="line-54"><code>	if len(src) &lt; 1 {</code></span>
<span class="codeline" id="line-55"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-56"><code>	}</code></span>
<span class="codeline" id="line-57"><code>	return bsontype.Type(src[0]), src[1:], true</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// ReadKey will read a key from src. The 0x00 byte will not be present</code></span>
<span class="codeline" id="line-61"><code>// in the returned string. If there are not enough bytes available, false is</code></span>
<span class="codeline" id="line-62"><code>// returned.</code></span>
<span class="codeline" id="line-63"><code>func ReadKey(src []byte) (string, []byte, bool) { return readcstring(src) }</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// ReadKeyBytes will read a key from src as bytes. The 0x00 byte will</code></span>
<span class="codeline" id="line-66"><code>// not be present in the returned string. If there are not enough bytes</code></span>
<span class="codeline" id="line-67"><code>// available, false is returned.</code></span>
<span class="codeline" id="line-68"><code>func ReadKeyBytes(src []byte) ([]byte, []byte, bool) { return readcstringbytes(src) }</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// ReadHeader will read a type byte and a key from src. If both of these</code></span>
<span class="codeline" id="line-71"><code>// values cannot be read, false is returned.</code></span>
<span class="codeline" id="line-72"><code>func ReadHeader(src []byte) (t bsontype.Type, key string, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-73"><code>	t, rem, ok = ReadType(src)</code></span>
<span class="codeline" id="line-74"><code>	if !ok {</code></span>
<span class="codeline" id="line-75"><code>		return 0, "", src, false</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code>	key, rem, ok = ReadKey(rem)</code></span>
<span class="codeline" id="line-78"><code>	if !ok {</code></span>
<span class="codeline" id="line-79"><code>		return 0, "", src, false</code></span>
<span class="codeline" id="line-80"><code>	}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>	return t, key, rem, true</code></span>
<span class="codeline" id="line-83"><code>}</code></span>
<span class="codeline" id="line-84"><code></code></span>
<span class="codeline" id="line-85"><code>// ReadHeaderBytes will read a type and a key from src and the remainder of the bytes</code></span>
<span class="codeline" id="line-86"><code>// are returned as rem. If either the type or key cannot be red, ok will be false.</code></span>
<span class="codeline" id="line-87"><code>func ReadHeaderBytes(src []byte) (header []byte, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-88"><code>	if len(src) &lt; 1 {</code></span>
<span class="codeline" id="line-89"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-90"><code>	}</code></span>
<span class="codeline" id="line-91"><code>	idx := bytes.IndexByte(src[1:], 0x00)</code></span>
<span class="codeline" id="line-92"><code>	if idx == -1 {</code></span>
<span class="codeline" id="line-93"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-94"><code>	}</code></span>
<span class="codeline" id="line-95"><code>	return src[:idx], src[idx+1:], true</code></span>
<span class="codeline" id="line-96"><code>}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>// ReadElement reads the next full element from src. It returns the element, the remaining bytes in</code></span>
<span class="codeline" id="line-99"><code>// the slice, and a boolean indicating if the read was successful.</code></span>
<span class="codeline" id="line-100"><code>func ReadElement(src []byte) (Element, []byte, bool) {</code></span>
<span class="codeline" id="line-101"><code>	if len(src) &lt; 1 {</code></span>
<span class="codeline" id="line-102"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-103"><code>	}</code></span>
<span class="codeline" id="line-104"><code>	t := bsontype.Type(src[0])</code></span>
<span class="codeline" id="line-105"><code>	idx := bytes.IndexByte(src[1:], 0x00)</code></span>
<span class="codeline" id="line-106"><code>	if idx == -1 {</code></span>
<span class="codeline" id="line-107"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>	length, ok := valueLength(src[idx+2:], t) // We add 2 here because we called IndexByte with src[1:]</code></span>
<span class="codeline" id="line-110"><code>	if !ok {</code></span>
<span class="codeline" id="line-111"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-112"><code>	}</code></span>
<span class="codeline" id="line-113"><code>	elemLength := 1 + idx + 1 + int(length)</code></span>
<span class="codeline" id="line-114"><code>	if elemLength &gt; len(src) {</code></span>
<span class="codeline" id="line-115"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-116"><code>	}</code></span>
<span class="codeline" id="line-117"><code>	if elemLength &lt; 0 {</code></span>
<span class="codeline" id="line-118"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-119"><code>	}</code></span>
<span class="codeline" id="line-120"><code>	return src[:elemLength], src[elemLength:], true</code></span>
<span class="codeline" id="line-121"><code>}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>// AppendValueElement appends value to dst as an element using key as the element's key.</code></span>
<span class="codeline" id="line-124"><code>func AppendValueElement(dst []byte, key string, value Value) []byte {</code></span>
<span class="codeline" id="line-125"><code>	dst = AppendHeader(dst, value.Type, key)</code></span>
<span class="codeline" id="line-126"><code>	dst = append(dst, value.Data...)</code></span>
<span class="codeline" id="line-127"><code>	return dst</code></span>
<span class="codeline" id="line-128"><code>}</code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>// ReadValue reads the next value as the provided types and returns a Value, the remaining bytes,</code></span>
<span class="codeline" id="line-131"><code>// and a boolean indicating if the read was successful.</code></span>
<span class="codeline" id="line-132"><code>func ReadValue(src []byte, t bsontype.Type) (Value, []byte, bool) {</code></span>
<span class="codeline" id="line-133"><code>	data, rem, ok := readValue(src, t)</code></span>
<span class="codeline" id="line-134"><code>	if !ok {</code></span>
<span class="codeline" id="line-135"><code>		return Value{}, src, false</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	return Value{Type: t, Data: data}, rem, true</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>// AppendDouble will append f to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-141"><code>func AppendDouble(dst []byte, f float64) []byte {</code></span>
<span class="codeline" id="line-142"><code>	return appendu64(dst, math.Float64bits(f))</code></span>
<span class="codeline" id="line-143"><code>}</code></span>
<span class="codeline" id="line-144"><code></code></span>
<span class="codeline" id="line-145"><code>// AppendDoubleElement will append a BSON double element using key and f to dst</code></span>
<span class="codeline" id="line-146"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-147"><code>func AppendDoubleElement(dst []byte, key string, f float64) []byte {</code></span>
<span class="codeline" id="line-148"><code>	return AppendDouble(AppendHeader(dst, bsontype.Double, key), f)</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>// ReadDouble will read a float64 from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-152"><code>// will return false.</code></span>
<span class="codeline" id="line-153"><code>func ReadDouble(src []byte) (float64, []byte, bool) {</code></span>
<span class="codeline" id="line-154"><code>	bits, src, ok := readu64(src)</code></span>
<span class="codeline" id="line-155"><code>	if !ok {</code></span>
<span class="codeline" id="line-156"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-157"><code>	}</code></span>
<span class="codeline" id="line-158"><code>	return math.Float64frombits(bits), src, true</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>// AppendString will append s to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-162"><code>func AppendString(dst []byte, s string) []byte {</code></span>
<span class="codeline" id="line-163"><code>	return appendstring(dst, s)</code></span>
<span class="codeline" id="line-164"><code>}</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>// AppendStringElement will append a BSON string element using key and val to dst</code></span>
<span class="codeline" id="line-167"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-168"><code>func AppendStringElement(dst []byte, key, val string) []byte {</code></span>
<span class="codeline" id="line-169"><code>	return AppendString(AppendHeader(dst, bsontype.String, key), val)</code></span>
<span class="codeline" id="line-170"><code>}</code></span>
<span class="codeline" id="line-171"><code></code></span>
<span class="codeline" id="line-172"><code>// ReadString will read a string from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-173"><code>// will return false.</code></span>
<span class="codeline" id="line-174"><code>func ReadString(src []byte) (string, []byte, bool) {</code></span>
<span class="codeline" id="line-175"><code>	return readstring(src)</code></span>
<span class="codeline" id="line-176"><code>}</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>// AppendDocumentStart reserves a document's length and returns the index where the length begins.</code></span>
<span class="codeline" id="line-179"><code>// This index can later be used to write the length of the document.</code></span>
<span class="codeline" id="line-180"><code>func AppendDocumentStart(dst []byte) (index int32, b []byte) {</code></span>
<span class="codeline" id="line-181"><code>	// TODO(skriptble): We really need AppendDocumentStart and AppendDocumentEnd.  AppendDocumentStart would handle calling</code></span>
<span class="codeline" id="line-182"><code>	// TODO ReserveLength and providing the index of the start of the document. AppendDocumentEnd would handle taking that</code></span>
<span class="codeline" id="line-183"><code>	// TODO start index, adding the null byte, calculating the length, and filling in the length at the start of the</code></span>
<span class="codeline" id="line-184"><code>	// TODO document.</code></span>
<span class="codeline" id="line-185"><code>	return ReserveLength(dst)</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// AppendDocumentStartInline functions the same as AppendDocumentStart but takes a pointer to the</code></span>
<span class="codeline" id="line-189"><code>// index int32 which allows this function to be used inline.</code></span>
<span class="codeline" id="line-190"><code>func AppendDocumentStartInline(dst []byte, index *int32) []byte {</code></span>
<span class="codeline" id="line-191"><code>	idx, doc := AppendDocumentStart(dst)</code></span>
<span class="codeline" id="line-192"><code>	*index = idx</code></span>
<span class="codeline" id="line-193"><code>	return doc</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// AppendDocumentElementStart writes a document element header and then reserves the length bytes.</code></span>
<span class="codeline" id="line-197"><code>func AppendDocumentElementStart(dst []byte, key string) (index int32, b []byte) {</code></span>
<span class="codeline" id="line-198"><code>	return AppendDocumentStart(AppendHeader(dst, bsontype.EmbeddedDocument, key))</code></span>
<span class="codeline" id="line-199"><code>}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>// AppendDocumentEnd writes the null byte for a document and updates the length of the document.</code></span>
<span class="codeline" id="line-202"><code>// The index should be the beginning of the document's length bytes.</code></span>
<span class="codeline" id="line-203"><code>func AppendDocumentEnd(dst []byte, index int32) ([]byte, error) {</code></span>
<span class="codeline" id="line-204"><code>	if int(index) &gt; len(dst)-4 {</code></span>
<span class="codeline" id="line-205"><code>		return dst, fmt.Errorf("not enough bytes available after index to write length")</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	dst = append(dst, 0x00)</code></span>
<span class="codeline" id="line-208"><code>	dst = UpdateLength(dst, index, int32(len(dst[index:])))</code></span>
<span class="codeline" id="line-209"><code>	return dst, nil</code></span>
<span class="codeline" id="line-210"><code>}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>// AppendDocument will append doc to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-213"><code>func AppendDocument(dst []byte, doc []byte) []byte { return append(dst, doc...) }</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>// AppendDocumentElement will append a BSON embedded document element using key</code></span>
<span class="codeline" id="line-216"><code>// and doc to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-217"><code>func AppendDocumentElement(dst []byte, key string, doc []byte) []byte {</code></span>
<span class="codeline" id="line-218"><code>	return AppendDocument(AppendHeader(dst, bsontype.EmbeddedDocument, key), doc)</code></span>
<span class="codeline" id="line-219"><code>}</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>// BuildDocument will create a document with the given slice of elements and will append</code></span>
<span class="codeline" id="line-222"><code>// it to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-223"><code>func BuildDocument(dst []byte, elems ...[]byte) []byte {</code></span>
<span class="codeline" id="line-224"><code>	idx, dst := ReserveLength(dst)</code></span>
<span class="codeline" id="line-225"><code>	for _, elem := range elems {</code></span>
<span class="codeline" id="line-226"><code>		dst = append(dst, elem...)</code></span>
<span class="codeline" id="line-227"><code>	}</code></span>
<span class="codeline" id="line-228"><code>	dst = append(dst, 0x00)</code></span>
<span class="codeline" id="line-229"><code>	dst = UpdateLength(dst, idx, int32(len(dst[idx:])))</code></span>
<span class="codeline" id="line-230"><code>	return dst</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// BuildDocumentValue creates an Embedded Document value from the given elements.</code></span>
<span class="codeline" id="line-234"><code>func BuildDocumentValue(elems ...[]byte) Value {</code></span>
<span class="codeline" id="line-235"><code>	return Value{Type: bsontype.EmbeddedDocument, Data: BuildDocument(nil, elems...)}</code></span>
<span class="codeline" id="line-236"><code>}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>// BuildDocumentElement will append a BSON embedded document element using key and the provided</code></span>
<span class="codeline" id="line-239"><code>// elements and return the extended buffer.</code></span>
<span class="codeline" id="line-240"><code>func BuildDocumentElement(dst []byte, key string, elems ...[]byte) []byte {</code></span>
<span class="codeline" id="line-241"><code>	return BuildDocument(AppendHeader(dst, bsontype.EmbeddedDocument, key), elems...)</code></span>
<span class="codeline" id="line-242"><code>}</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// BuildDocumentFromElements is an alaias for the BuildDocument function.</code></span>
<span class="codeline" id="line-245"><code>var BuildDocumentFromElements = BuildDocument</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>// ReadDocument will read a document from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-248"><code>// will return false.</code></span>
<span class="codeline" id="line-249"><code>func ReadDocument(src []byte) (doc Document, rem []byte, ok bool) { return readLengthBytes(src) }</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>// AppendArrayStart appends the length bytes to an array and then returns the index of the start</code></span>
<span class="codeline" id="line-252"><code>// of those length bytes.</code></span>
<span class="codeline" id="line-253"><code>func AppendArrayStart(dst []byte) (index int32, b []byte) { return ReserveLength(dst) }</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>// AppendArrayElementStart appends an array element header and then the length bytes for an array,</code></span>
<span class="codeline" id="line-256"><code>// returning the index where the length starts.</code></span>
<span class="codeline" id="line-257"><code>func AppendArrayElementStart(dst []byte, key string) (index int32, b []byte) {</code></span>
<span class="codeline" id="line-258"><code>	return AppendArrayStart(AppendHeader(dst, bsontype.Array, key))</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// AppendArrayEnd appends the null byte to an array and calculates the length, inserting that</code></span>
<span class="codeline" id="line-262"><code>// calculated length starting at index.</code></span>
<span class="codeline" id="line-263"><code>func AppendArrayEnd(dst []byte, index int32) ([]byte, error) { return AppendDocumentEnd(dst, index) }</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// AppendArray will append arr to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-266"><code>func AppendArray(dst []byte, arr []byte) []byte { return append(dst, arr...) }</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>// AppendArrayElement will append a BSON array element using key and arr to dst</code></span>
<span class="codeline" id="line-269"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-270"><code>func AppendArrayElement(dst []byte, key string, arr []byte) []byte {</code></span>
<span class="codeline" id="line-271"><code>	return AppendArray(AppendHeader(dst, bsontype.Array, key), arr)</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// BuildArray will append a BSON array to dst built from values.</code></span>
<span class="codeline" id="line-275"><code>func BuildArray(dst []byte, values ...Value) []byte {</code></span>
<span class="codeline" id="line-276"><code>	idx, dst := ReserveLength(dst)</code></span>
<span class="codeline" id="line-277"><code>	for pos, val := range values {</code></span>
<span class="codeline" id="line-278"><code>		dst = AppendValueElement(dst, strconv.Itoa(pos), val)</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code>	dst = append(dst, 0x00)</code></span>
<span class="codeline" id="line-281"><code>	dst = UpdateLength(dst, idx, int32(len(dst[idx:])))</code></span>
<span class="codeline" id="line-282"><code>	return dst</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// BuildArrayElement will create an array element using the provided values.</code></span>
<span class="codeline" id="line-286"><code>func BuildArrayElement(dst []byte, key string, values ...Value) []byte {</code></span>
<span class="codeline" id="line-287"><code>	return BuildArray(AppendHeader(dst, bsontype.Array, key), values...)</code></span>
<span class="codeline" id="line-288"><code>}</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>// ReadArray will read an array from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-291"><code>// will return false.</code></span>
<span class="codeline" id="line-292"><code>func ReadArray(src []byte) (arr Array, rem []byte, ok bool) { return readLengthBytes(src) }</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>// AppendBinary will append subtype and b to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-295"><code>func AppendBinary(dst []byte, subtype byte, b []byte) []byte {</code></span>
<span class="codeline" id="line-296"><code>	if subtype == 0x02 {</code></span>
<span class="codeline" id="line-297"><code>		return appendBinarySubtype2(dst, subtype, b)</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	dst = append(appendLength(dst, int32(len(b))), subtype)</code></span>
<span class="codeline" id="line-300"><code>	return append(dst, b...)</code></span>
<span class="codeline" id="line-301"><code>}</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>// AppendBinaryElement will append a BSON binary element using key, subtype, and</code></span>
<span class="codeline" id="line-304"><code>// b to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-305"><code>func AppendBinaryElement(dst []byte, key string, subtype byte, b []byte) []byte {</code></span>
<span class="codeline" id="line-306"><code>	return AppendBinary(AppendHeader(dst, bsontype.Binary, key), subtype, b)</code></span>
<span class="codeline" id="line-307"><code>}</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>// ReadBinary will read a subtype and bin from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-310"><code>// will return false.</code></span>
<span class="codeline" id="line-311"><code>func ReadBinary(src []byte) (subtype byte, bin []byte, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-312"><code>	length, rem, ok := ReadLength(src)</code></span>
<span class="codeline" id="line-313"><code>	if !ok {</code></span>
<span class="codeline" id="line-314"><code>		return 0x00, nil, src, false</code></span>
<span class="codeline" id="line-315"><code>	}</code></span>
<span class="codeline" id="line-316"><code>	if len(rem) &lt; 1 { // subtype</code></span>
<span class="codeline" id="line-317"><code>		return 0x00, nil, src, false</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	subtype, rem = rem[0], rem[1:]</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>	if len(rem) &lt; int(length) {</code></span>
<span class="codeline" id="line-322"><code>		return 0x00, nil, src, false</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	if subtype == 0x02 {</code></span>
<span class="codeline" id="line-326"><code>		length, rem, ok = ReadLength(rem)</code></span>
<span class="codeline" id="line-327"><code>		if !ok || len(rem) &lt; int(length) {</code></span>
<span class="codeline" id="line-328"><code>			return 0x00, nil, src, false</code></span>
<span class="codeline" id="line-329"><code>		}</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>	return subtype, rem[:length], rem[length:], true</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// AppendUndefinedElement will append a BSON undefined element using key to dst</code></span>
<span class="codeline" id="line-336"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-337"><code>func AppendUndefinedElement(dst []byte, key string) []byte {</code></span>
<span class="codeline" id="line-338"><code>	return AppendHeader(dst, bsontype.Undefined, key)</code></span>
<span class="codeline" id="line-339"><code>}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>// AppendObjectID will append oid to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-342"><code>func AppendObjectID(dst []byte, oid primitive.ObjectID) []byte { return append(dst, oid[:]...) }</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>// AppendObjectIDElement will append a BSON ObjectID element using key and oid to dst</code></span>
<span class="codeline" id="line-345"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-346"><code>func AppendObjectIDElement(dst []byte, key string, oid primitive.ObjectID) []byte {</code></span>
<span class="codeline" id="line-347"><code>	return AppendObjectID(AppendHeader(dst, bsontype.ObjectID, key), oid)</code></span>
<span class="codeline" id="line-348"><code>}</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>// ReadObjectID will read an ObjectID from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-351"><code>// will return false.</code></span>
<span class="codeline" id="line-352"><code>func ReadObjectID(src []byte) (primitive.ObjectID, []byte, bool) {</code></span>
<span class="codeline" id="line-353"><code>	if len(src) &lt; 12 {</code></span>
<span class="codeline" id="line-354"><code>		return primitive.ObjectID{}, src, false</code></span>
<span class="codeline" id="line-355"><code>	}</code></span>
<span class="codeline" id="line-356"><code>	var oid primitive.ObjectID</code></span>
<span class="codeline" id="line-357"><code>	copy(oid[:], src[0:12])</code></span>
<span class="codeline" id="line-358"><code>	return oid, src[12:], true</code></span>
<span class="codeline" id="line-359"><code>}</code></span>
<span class="codeline" id="line-360"><code></code></span>
<span class="codeline" id="line-361"><code>// AppendBoolean will append b to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-362"><code>func AppendBoolean(dst []byte, b bool) []byte {</code></span>
<span class="codeline" id="line-363"><code>	if b {</code></span>
<span class="codeline" id="line-364"><code>		return append(dst, 0x01)</code></span>
<span class="codeline" id="line-365"><code>	}</code></span>
<span class="codeline" id="line-366"><code>	return append(dst, 0x00)</code></span>
<span class="codeline" id="line-367"><code>}</code></span>
<span class="codeline" id="line-368"><code></code></span>
<span class="codeline" id="line-369"><code>// AppendBooleanElement will append a BSON boolean element using key and b to dst</code></span>
<span class="codeline" id="line-370"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-371"><code>func AppendBooleanElement(dst []byte, key string, b bool) []byte {</code></span>
<span class="codeline" id="line-372"><code>	return AppendBoolean(AppendHeader(dst, bsontype.Boolean, key), b)</code></span>
<span class="codeline" id="line-373"><code>}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>// ReadBoolean will read a bool from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-376"><code>// will return false.</code></span>
<span class="codeline" id="line-377"><code>func ReadBoolean(src []byte) (bool, []byte, bool) {</code></span>
<span class="codeline" id="line-378"><code>	if len(src) &lt; 1 {</code></span>
<span class="codeline" id="line-379"><code>		return false, src, false</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>	return src[0] == 0x01, src[1:], true</code></span>
<span class="codeline" id="line-383"><code>}</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>// AppendDateTime will append dt to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-386"><code>func AppendDateTime(dst []byte, dt int64) []byte { return appendi64(dst, dt) }</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>// AppendDateTimeElement will append a BSON datetime element using key and dt to dst</code></span>
<span class="codeline" id="line-389"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-390"><code>func AppendDateTimeElement(dst []byte, key string, dt int64) []byte {</code></span>
<span class="codeline" id="line-391"><code>	return AppendDateTime(AppendHeader(dst, bsontype.DateTime, key), dt)</code></span>
<span class="codeline" id="line-392"><code>}</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>// ReadDateTime will read an int64 datetime from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-395"><code>// will return false.</code></span>
<span class="codeline" id="line-396"><code>func ReadDateTime(src []byte) (int64, []byte, bool) { return readi64(src) }</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>// AppendTime will append time as a BSON DateTime to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-399"><code>func AppendTime(dst []byte, t time.Time) []byte {</code></span>
<span class="codeline" id="line-400"><code>	return AppendDateTime(dst, t.Unix()*1000+int64(t.Nanosecond()/1e6))</code></span>
<span class="codeline" id="line-401"><code>}</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>// AppendTimeElement will append a BSON datetime element using key and dt to dst</code></span>
<span class="codeline" id="line-404"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-405"><code>func AppendTimeElement(dst []byte, key string, t time.Time) []byte {</code></span>
<span class="codeline" id="line-406"><code>	return AppendTime(AppendHeader(dst, bsontype.DateTime, key), t)</code></span>
<span class="codeline" id="line-407"><code>}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>// ReadTime will read an time.Time datetime from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-410"><code>// will return false.</code></span>
<span class="codeline" id="line-411"><code>func ReadTime(src []byte) (time.Time, []byte, bool) {</code></span>
<span class="codeline" id="line-412"><code>	dt, rem, ok := readi64(src)</code></span>
<span class="codeline" id="line-413"><code>	return time.Unix(dt/1e3, dt%1e3*1e6), rem, ok</code></span>
<span class="codeline" id="line-414"><code>}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>// AppendNullElement will append a BSON null element using key to dst</code></span>
<span class="codeline" id="line-417"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-418"><code>func AppendNullElement(dst []byte, key string) []byte { return AppendHeader(dst, bsontype.Null, key) }</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>// AppendRegex will append pattern and options to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-421"><code>func AppendRegex(dst []byte, pattern, options string) []byte {</code></span>
<span class="codeline" id="line-422"><code>	if !isValidCString(pattern) || !isValidCString(options) {</code></span>
<span class="codeline" id="line-423"><code>		panic(invalidRegexPanicMsg)</code></span>
<span class="codeline" id="line-424"><code>	}</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>	return append(dst, pattern+nullTerminator+options+nullTerminator...)</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>// AppendRegexElement will append a BSON regex element using key, pattern, and</code></span>
<span class="codeline" id="line-430"><code>// options to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-431"><code>func AppendRegexElement(dst []byte, key, pattern, options string) []byte {</code></span>
<span class="codeline" id="line-432"><code>	return AppendRegex(AppendHeader(dst, bsontype.Regex, key), pattern, options)</code></span>
<span class="codeline" id="line-433"><code>}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>// ReadRegex will read a pattern and options from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-436"><code>// will return false.</code></span>
<span class="codeline" id="line-437"><code>func ReadRegex(src []byte) (pattern, options string, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-438"><code>	pattern, rem, ok = readcstring(src)</code></span>
<span class="codeline" id="line-439"><code>	if !ok {</code></span>
<span class="codeline" id="line-440"><code>		return "", "", src, false</code></span>
<span class="codeline" id="line-441"><code>	}</code></span>
<span class="codeline" id="line-442"><code>	options, rem, ok = readcstring(rem)</code></span>
<span class="codeline" id="line-443"><code>	if !ok {</code></span>
<span class="codeline" id="line-444"><code>		return "", "", src, false</code></span>
<span class="codeline" id="line-445"><code>	}</code></span>
<span class="codeline" id="line-446"><code>	return pattern, options, rem, true</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>// AppendDBPointer will append ns and oid to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-450"><code>func AppendDBPointer(dst []byte, ns string, oid primitive.ObjectID) []byte {</code></span>
<span class="codeline" id="line-451"><code>	return append(appendstring(dst, ns), oid[:]...)</code></span>
<span class="codeline" id="line-452"><code>}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>// AppendDBPointerElement will append a BSON DBPointer element using key, ns,</code></span>
<span class="codeline" id="line-455"><code>// and oid to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-456"><code>func AppendDBPointerElement(dst []byte, key, ns string, oid primitive.ObjectID) []byte {</code></span>
<span class="codeline" id="line-457"><code>	return AppendDBPointer(AppendHeader(dst, bsontype.DBPointer, key), ns, oid)</code></span>
<span class="codeline" id="line-458"><code>}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>// ReadDBPointer will read a ns and oid from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-461"><code>// will return false.</code></span>
<span class="codeline" id="line-462"><code>func ReadDBPointer(src []byte) (ns string, oid primitive.ObjectID, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-463"><code>	ns, rem, ok = readstring(src)</code></span>
<span class="codeline" id="line-464"><code>	if !ok {</code></span>
<span class="codeline" id="line-465"><code>		return "", primitive.ObjectID{}, src, false</code></span>
<span class="codeline" id="line-466"><code>	}</code></span>
<span class="codeline" id="line-467"><code>	oid, rem, ok = ReadObjectID(rem)</code></span>
<span class="codeline" id="line-468"><code>	if !ok {</code></span>
<span class="codeline" id="line-469"><code>		return "", primitive.ObjectID{}, src, false</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code>	return ns, oid, rem, true</code></span>
<span class="codeline" id="line-472"><code>}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>// AppendJavaScript will append js to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-475"><code>func AppendJavaScript(dst []byte, js string) []byte { return appendstring(dst, js) }</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>// AppendJavaScriptElement will append a BSON JavaScript element using key and</code></span>
<span class="codeline" id="line-478"><code>// js to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-479"><code>func AppendJavaScriptElement(dst []byte, key, js string) []byte {</code></span>
<span class="codeline" id="line-480"><code>	return AppendJavaScript(AppendHeader(dst, bsontype.JavaScript, key), js)</code></span>
<span class="codeline" id="line-481"><code>}</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>// ReadJavaScript will read a js string from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-484"><code>// will return false.</code></span>
<span class="codeline" id="line-485"><code>func ReadJavaScript(src []byte) (js string, rem []byte, ok bool) { return readstring(src) }</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>// AppendSymbol will append symbol to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-488"><code>func AppendSymbol(dst []byte, symbol string) []byte { return appendstring(dst, symbol) }</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>// AppendSymbolElement will append a BSON symbol element using key and symbol to dst</code></span>
<span class="codeline" id="line-491"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-492"><code>func AppendSymbolElement(dst []byte, key, symbol string) []byte {</code></span>
<span class="codeline" id="line-493"><code>	return AppendSymbol(AppendHeader(dst, bsontype.Symbol, key), symbol)</code></span>
<span class="codeline" id="line-494"><code>}</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>// ReadSymbol will read a symbol string from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-497"><code>// will return false.</code></span>
<span class="codeline" id="line-498"><code>func ReadSymbol(src []byte) (symbol string, rem []byte, ok bool) { return readstring(src) }</code></span>
<span class="codeline" id="line-499"><code></code></span>
<span class="codeline" id="line-500"><code>// AppendCodeWithScope will append code and scope to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-501"><code>func AppendCodeWithScope(dst []byte, code string, scope []byte) []byte {</code></span>
<span class="codeline" id="line-502"><code>	length := int32(4 + 4 + len(code) + 1 + len(scope)) // length of cws, length of code, code, 0x00, scope</code></span>
<span class="codeline" id="line-503"><code>	dst = appendLength(dst, length)</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>	return append(appendstring(dst, code), scope...)</code></span>
<span class="codeline" id="line-506"><code>}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>// AppendCodeWithScopeElement will append a BSON code with scope element using</code></span>
<span class="codeline" id="line-509"><code>// key, code, and scope to dst</code></span>
<span class="codeline" id="line-510"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-511"><code>func AppendCodeWithScopeElement(dst []byte, key, code string, scope []byte) []byte {</code></span>
<span class="codeline" id="line-512"><code>	return AppendCodeWithScope(AppendHeader(dst, bsontype.CodeWithScope, key), code, scope)</code></span>
<span class="codeline" id="line-513"><code>}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>// ReadCodeWithScope will read code and scope from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-516"><code>// will return false.</code></span>
<span class="codeline" id="line-517"><code>func ReadCodeWithScope(src []byte) (code string, scope []byte, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-518"><code>	length, rem, ok := ReadLength(src)</code></span>
<span class="codeline" id="line-519"><code>	if !ok || len(src) &lt; int(length) {</code></span>
<span class="codeline" id="line-520"><code>		return "", nil, src, false</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	code, rem, ok = readstring(rem)</code></span>
<span class="codeline" id="line-524"><code>	if !ok {</code></span>
<span class="codeline" id="line-525"><code>		return "", nil, src, false</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>	scope, rem, ok = ReadDocument(rem)</code></span>
<span class="codeline" id="line-529"><code>	if !ok {</code></span>
<span class="codeline" id="line-530"><code>		return "", nil, src, false</code></span>
<span class="codeline" id="line-531"><code>	}</code></span>
<span class="codeline" id="line-532"><code>	return code, scope, rem, true</code></span>
<span class="codeline" id="line-533"><code>}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>// AppendInt32 will append i32 to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-536"><code>func AppendInt32(dst []byte, i32 int32) []byte { return appendi32(dst, i32) }</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>// AppendInt32Element will append a BSON int32 element using key and i32 to dst</code></span>
<span class="codeline" id="line-539"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-540"><code>func AppendInt32Element(dst []byte, key string, i32 int32) []byte {</code></span>
<span class="codeline" id="line-541"><code>	return AppendInt32(AppendHeader(dst, bsontype.Int32, key), i32)</code></span>
<span class="codeline" id="line-542"><code>}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>// ReadInt32 will read an int32 from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-545"><code>// will return false.</code></span>
<span class="codeline" id="line-546"><code>func ReadInt32(src []byte) (int32, []byte, bool) { return readi32(src) }</code></span>
<span class="codeline" id="line-547"><code></code></span>
<span class="codeline" id="line-548"><code>// AppendTimestamp will append t and i to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-549"><code>func AppendTimestamp(dst []byte, t, i uint32) []byte {</code></span>
<span class="codeline" id="line-550"><code>	return appendu32(appendu32(dst, i), t) // i is the lower 4 bytes, t is the higher 4 bytes</code></span>
<span class="codeline" id="line-551"><code>}</code></span>
<span class="codeline" id="line-552"><code></code></span>
<span class="codeline" id="line-553"><code>// AppendTimestampElement will append a BSON timestamp element using key, t, and</code></span>
<span class="codeline" id="line-554"><code>// i to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-555"><code>func AppendTimestampElement(dst []byte, key string, t, i uint32) []byte {</code></span>
<span class="codeline" id="line-556"><code>	return AppendTimestamp(AppendHeader(dst, bsontype.Timestamp, key), t, i)</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>// ReadTimestamp will read t and i from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-560"><code>// will return false.</code></span>
<span class="codeline" id="line-561"><code>func ReadTimestamp(src []byte) (t, i uint32, rem []byte, ok bool) {</code></span>
<span class="codeline" id="line-562"><code>	i, rem, ok = readu32(src)</code></span>
<span class="codeline" id="line-563"><code>	if !ok {</code></span>
<span class="codeline" id="line-564"><code>		return 0, 0, src, false</code></span>
<span class="codeline" id="line-565"><code>	}</code></span>
<span class="codeline" id="line-566"><code>	t, rem, ok = readu32(rem)</code></span>
<span class="codeline" id="line-567"><code>	if !ok {</code></span>
<span class="codeline" id="line-568"><code>		return 0, 0, src, false</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>	return t, i, rem, true</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// AppendInt64 will append i64 to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-574"><code>func AppendInt64(dst []byte, i64 int64) []byte { return appendi64(dst, i64) }</code></span>
<span class="codeline" id="line-575"><code></code></span>
<span class="codeline" id="line-576"><code>// AppendInt64Element will append a BSON int64 element using key and i64 to dst</code></span>
<span class="codeline" id="line-577"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-578"><code>func AppendInt64Element(dst []byte, key string, i64 int64) []byte {</code></span>
<span class="codeline" id="line-579"><code>	return AppendInt64(AppendHeader(dst, bsontype.Int64, key), i64)</code></span>
<span class="codeline" id="line-580"><code>}</code></span>
<span class="codeline" id="line-581"><code></code></span>
<span class="codeline" id="line-582"><code>// ReadInt64 will read an int64 from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-583"><code>// will return false.</code></span>
<span class="codeline" id="line-584"><code>func ReadInt64(src []byte) (int64, []byte, bool) { return readi64(src) }</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>// AppendDecimal128 will append d128 to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-587"><code>func AppendDecimal128(dst []byte, d128 primitive.Decimal128) []byte {</code></span>
<span class="codeline" id="line-588"><code>	high, low := d128.GetBytes()</code></span>
<span class="codeline" id="line-589"><code>	return appendu64(appendu64(dst, low), high)</code></span>
<span class="codeline" id="line-590"><code>}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>// AppendDecimal128Element will append a BSON primitive.28 element using key and</code></span>
<span class="codeline" id="line-593"><code>// d128 to dst and return the extended buffer.</code></span>
<span class="codeline" id="line-594"><code>func AppendDecimal128Element(dst []byte, key string, d128 primitive.Decimal128) []byte {</code></span>
<span class="codeline" id="line-595"><code>	return AppendDecimal128(AppendHeader(dst, bsontype.Decimal128, key), d128)</code></span>
<span class="codeline" id="line-596"><code>}</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>// ReadDecimal128 will read a primitive.Decimal128 from src. If there are not enough bytes it</code></span>
<span class="codeline" id="line-599"><code>// will return false.</code></span>
<span class="codeline" id="line-600"><code>func ReadDecimal128(src []byte) (primitive.Decimal128, []byte, bool) {</code></span>
<span class="codeline" id="line-601"><code>	l, rem, ok := readu64(src)</code></span>
<span class="codeline" id="line-602"><code>	if !ok {</code></span>
<span class="codeline" id="line-603"><code>		return primitive.Decimal128{}, src, false</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code></code></span>
<span class="codeline" id="line-606"><code>	h, rem, ok := readu64(rem)</code></span>
<span class="codeline" id="line-607"><code>	if !ok {</code></span>
<span class="codeline" id="line-608"><code>		return primitive.Decimal128{}, src, false</code></span>
<span class="codeline" id="line-609"><code>	}</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>	return primitive.NewDecimal128(h, l), rem, true</code></span>
<span class="codeline" id="line-612"><code>}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>// AppendMaxKeyElement will append a BSON max key element using key to dst</code></span>
<span class="codeline" id="line-615"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-616"><code>func AppendMaxKeyElement(dst []byte, key string) []byte {</code></span>
<span class="codeline" id="line-617"><code>	return AppendHeader(dst, bsontype.MaxKey, key)</code></span>
<span class="codeline" id="line-618"><code>}</code></span>
<span class="codeline" id="line-619"><code></code></span>
<span class="codeline" id="line-620"><code>// AppendMinKeyElement will append a BSON min key element using key to dst</code></span>
<span class="codeline" id="line-621"><code>// and return the extended buffer.</code></span>
<span class="codeline" id="line-622"><code>func AppendMinKeyElement(dst []byte, key string) []byte {</code></span>
<span class="codeline" id="line-623"><code>	return AppendHeader(dst, bsontype.MinKey, key)</code></span>
<span class="codeline" id="line-624"><code>}</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>// EqualValue will return true if the two values are equal.</code></span>
<span class="codeline" id="line-627"><code>func EqualValue(t1, t2 bsontype.Type, v1, v2 []byte) bool {</code></span>
<span class="codeline" id="line-628"><code>	if t1 != t2 {</code></span>
<span class="codeline" id="line-629"><code>		return false</code></span>
<span class="codeline" id="line-630"><code>	}</code></span>
<span class="codeline" id="line-631"><code>	v1, _, ok := readValue(v1, t1)</code></span>
<span class="codeline" id="line-632"><code>	if !ok {</code></span>
<span class="codeline" id="line-633"><code>		return false</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	v2, _, ok = readValue(v2, t2)</code></span>
<span class="codeline" id="line-636"><code>	if !ok {</code></span>
<span class="codeline" id="line-637"><code>		return false</code></span>
<span class="codeline" id="line-638"><code>	}</code></span>
<span class="codeline" id="line-639"><code>	return bytes.Equal(v1, v2)</code></span>
<span class="codeline" id="line-640"><code>}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>// valueLength will determine the length of the next value contained in src as if it</code></span>
<span class="codeline" id="line-643"><code>// is type t. The returned bool will be false if there are not enough bytes in src for</code></span>
<span class="codeline" id="line-644"><code>// a value of type t.</code></span>
<span class="codeline" id="line-645"><code>func valueLength(src []byte, t bsontype.Type) (int32, bool) {</code></span>
<span class="codeline" id="line-646"><code>	var length int32</code></span>
<span class="codeline" id="line-647"><code>	ok := true</code></span>
<span class="codeline" id="line-648"><code>	switch t {</code></span>
<span class="codeline" id="line-649"><code>	case bsontype.Array, bsontype.EmbeddedDocument, bsontype.CodeWithScope:</code></span>
<span class="codeline" id="line-650"><code>		length, _, ok = ReadLength(src)</code></span>
<span class="codeline" id="line-651"><code>	case bsontype.Binary:</code></span>
<span class="codeline" id="line-652"><code>		length, _, ok = ReadLength(src)</code></span>
<span class="codeline" id="line-653"><code>		length += 4 + 1 // binary length + subtype byte</code></span>
<span class="codeline" id="line-654"><code>	case bsontype.Boolean:</code></span>
<span class="codeline" id="line-655"><code>		length = 1</code></span>
<span class="codeline" id="line-656"><code>	case bsontype.DBPointer:</code></span>
<span class="codeline" id="line-657"><code>		length, _, ok = ReadLength(src)</code></span>
<span class="codeline" id="line-658"><code>		length += 4 + 12 // string length + ObjectID length</code></span>
<span class="codeline" id="line-659"><code>	case bsontype.DateTime, bsontype.Double, bsontype.Int64, bsontype.Timestamp:</code></span>
<span class="codeline" id="line-660"><code>		length = 8</code></span>
<span class="codeline" id="line-661"><code>	case bsontype.Decimal128:</code></span>
<span class="codeline" id="line-662"><code>		length = 16</code></span>
<span class="codeline" id="line-663"><code>	case bsontype.Int32:</code></span>
<span class="codeline" id="line-664"><code>		length = 4</code></span>
<span class="codeline" id="line-665"><code>	case bsontype.JavaScript, bsontype.String, bsontype.Symbol:</code></span>
<span class="codeline" id="line-666"><code>		length, _, ok = ReadLength(src)</code></span>
<span class="codeline" id="line-667"><code>		length += 4</code></span>
<span class="codeline" id="line-668"><code>	case bsontype.MaxKey, bsontype.MinKey, bsontype.Null, bsontype.Undefined:</code></span>
<span class="codeline" id="line-669"><code>		length = 0</code></span>
<span class="codeline" id="line-670"><code>	case bsontype.ObjectID:</code></span>
<span class="codeline" id="line-671"><code>		length = 12</code></span>
<span class="codeline" id="line-672"><code>	case bsontype.Regex:</code></span>
<span class="codeline" id="line-673"><code>		regex := bytes.IndexByte(src, 0x00)</code></span>
<span class="codeline" id="line-674"><code>		if regex &lt; 0 {</code></span>
<span class="codeline" id="line-675"><code>			ok = false</code></span>
<span class="codeline" id="line-676"><code>			break</code></span>
<span class="codeline" id="line-677"><code>		}</code></span>
<span class="codeline" id="line-678"><code>		pattern := bytes.IndexByte(src[regex+1:], 0x00)</code></span>
<span class="codeline" id="line-679"><code>		if pattern &lt; 0 {</code></span>
<span class="codeline" id="line-680"><code>			ok = false</code></span>
<span class="codeline" id="line-681"><code>			break</code></span>
<span class="codeline" id="line-682"><code>		}</code></span>
<span class="codeline" id="line-683"><code>		length = int32(int64(regex) + 1 + int64(pattern) + 1)</code></span>
<span class="codeline" id="line-684"><code>	default:</code></span>
<span class="codeline" id="line-685"><code>		ok = false</code></span>
<span class="codeline" id="line-686"><code>	}</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>	return length, ok</code></span>
<span class="codeline" id="line-689"><code>}</code></span>
<span class="codeline" id="line-690"><code></code></span>
<span class="codeline" id="line-691"><code>func readValue(src []byte, t bsontype.Type) ([]byte, []byte, bool) {</code></span>
<span class="codeline" id="line-692"><code>	length, ok := valueLength(src, t)</code></span>
<span class="codeline" id="line-693"><code>	if !ok || int(length) &gt; len(src) {</code></span>
<span class="codeline" id="line-694"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	return src[:length], src[length:], true</code></span>
<span class="codeline" id="line-698"><code>}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>// ReserveLength reserves the space required for length and returns the index where to write the length</code></span>
<span class="codeline" id="line-701"><code>// and the []byte with reserved space.</code></span>
<span class="codeline" id="line-702"><code>func ReserveLength(dst []byte) (int32, []byte) {</code></span>
<span class="codeline" id="line-703"><code>	index := len(dst)</code></span>
<span class="codeline" id="line-704"><code>	return int32(index), append(dst, 0x00, 0x00, 0x00, 0x00)</code></span>
<span class="codeline" id="line-705"><code>}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>// UpdateLength updates the length at index with length and returns the []byte.</code></span>
<span class="codeline" id="line-708"><code>func UpdateLength(dst []byte, index, length int32) []byte {</code></span>
<span class="codeline" id="line-709"><code>	dst[index] = byte(length)</code></span>
<span class="codeline" id="line-710"><code>	dst[index+1] = byte(length &gt;&gt; 8)</code></span>
<span class="codeline" id="line-711"><code>	dst[index+2] = byte(length &gt;&gt; 16)</code></span>
<span class="codeline" id="line-712"><code>	dst[index+3] = byte(length &gt;&gt; 24)</code></span>
<span class="codeline" id="line-713"><code>	return dst</code></span>
<span class="codeline" id="line-714"><code>}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>func appendLength(dst []byte, l int32) []byte { return appendi32(dst, l) }</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>func appendi32(dst []byte, i32 int32) []byte {</code></span>
<span class="codeline" id="line-719"><code>	return append(dst, byte(i32), byte(i32&gt;&gt;8), byte(i32&gt;&gt;16), byte(i32&gt;&gt;24))</code></span>
<span class="codeline" id="line-720"><code>}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>// ReadLength reads an int32 length from src and returns the length and the remaining bytes. If</code></span>
<span class="codeline" id="line-723"><code>// there aren't enough bytes to read a valid length, src is returned unomdified and the returned</code></span>
<span class="codeline" id="line-724"><code>// bool will be false.</code></span>
<span class="codeline" id="line-725"><code>func ReadLength(src []byte) (int32, []byte, bool) {</code></span>
<span class="codeline" id="line-726"><code>	ln, src, ok := readi32(src)</code></span>
<span class="codeline" id="line-727"><code>	if ln &lt; 0 {</code></span>
<span class="codeline" id="line-728"><code>		return ln, src, false</code></span>
<span class="codeline" id="line-729"><code>	}</code></span>
<span class="codeline" id="line-730"><code>	return ln, src, ok</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>func readi32(src []byte) (int32, []byte, bool) {</code></span>
<span class="codeline" id="line-734"><code>	if len(src) &lt; 4 {</code></span>
<span class="codeline" id="line-735"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-736"><code>	}</code></span>
<span class="codeline" id="line-737"><code>	return (int32(src[0]) | int32(src[1])&lt;&lt;8 | int32(src[2])&lt;&lt;16 | int32(src[3])&lt;&lt;24), src[4:], true</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>func appendi64(dst []byte, i64 int64) []byte {</code></span>
<span class="codeline" id="line-741"><code>	return append(dst,</code></span>
<span class="codeline" id="line-742"><code>		byte(i64), byte(i64&gt;&gt;8), byte(i64&gt;&gt;16), byte(i64&gt;&gt;24),</code></span>
<span class="codeline" id="line-743"><code>		byte(i64&gt;&gt;32), byte(i64&gt;&gt;40), byte(i64&gt;&gt;48), byte(i64&gt;&gt;56),</code></span>
<span class="codeline" id="line-744"><code>	)</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>func readi64(src []byte) (int64, []byte, bool) {</code></span>
<span class="codeline" id="line-748"><code>	if len(src) &lt; 8 {</code></span>
<span class="codeline" id="line-749"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-750"><code>	}</code></span>
<span class="codeline" id="line-751"><code>	i64 := (int64(src[0]) | int64(src[1])&lt;&lt;8 | int64(src[2])&lt;&lt;16 | int64(src[3])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-752"><code>		int64(src[4])&lt;&lt;32 | int64(src[5])&lt;&lt;40 | int64(src[6])&lt;&lt;48 | int64(src[7])&lt;&lt;56)</code></span>
<span class="codeline" id="line-753"><code>	return i64, src[8:], true</code></span>
<span class="codeline" id="line-754"><code>}</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>func appendu32(dst []byte, u32 uint32) []byte {</code></span>
<span class="codeline" id="line-757"><code>	return append(dst, byte(u32), byte(u32&gt;&gt;8), byte(u32&gt;&gt;16), byte(u32&gt;&gt;24))</code></span>
<span class="codeline" id="line-758"><code>}</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>func readu32(src []byte) (uint32, []byte, bool) {</code></span>
<span class="codeline" id="line-761"><code>	if len(src) &lt; 4 {</code></span>
<span class="codeline" id="line-762"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	return (uint32(src[0]) | uint32(src[1])&lt;&lt;8 | uint32(src[2])&lt;&lt;16 | uint32(src[3])&lt;&lt;24), src[4:], true</code></span>
<span class="codeline" id="line-766"><code>}</code></span>
<span class="codeline" id="line-767"><code></code></span>
<span class="codeline" id="line-768"><code>func appendu64(dst []byte, u64 uint64) []byte {</code></span>
<span class="codeline" id="line-769"><code>	return append(dst,</code></span>
<span class="codeline" id="line-770"><code>		byte(u64), byte(u64&gt;&gt;8), byte(u64&gt;&gt;16), byte(u64&gt;&gt;24),</code></span>
<span class="codeline" id="line-771"><code>		byte(u64&gt;&gt;32), byte(u64&gt;&gt;40), byte(u64&gt;&gt;48), byte(u64&gt;&gt;56),</code></span>
<span class="codeline" id="line-772"><code>	)</code></span>
<span class="codeline" id="line-773"><code>}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>func readu64(src []byte) (uint64, []byte, bool) {</code></span>
<span class="codeline" id="line-776"><code>	if len(src) &lt; 8 {</code></span>
<span class="codeline" id="line-777"><code>		return 0, src, false</code></span>
<span class="codeline" id="line-778"><code>	}</code></span>
<span class="codeline" id="line-779"><code>	u64 := (uint64(src[0]) | uint64(src[1])&lt;&lt;8 | uint64(src[2])&lt;&lt;16 | uint64(src[3])&lt;&lt;24 |</code></span>
<span class="codeline" id="line-780"><code>		uint64(src[4])&lt;&lt;32 | uint64(src[5])&lt;&lt;40 | uint64(src[6])&lt;&lt;48 | uint64(src[7])&lt;&lt;56)</code></span>
<span class="codeline" id="line-781"><code>	return u64, src[8:], true</code></span>
<span class="codeline" id="line-782"><code>}</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>// keep in sync with readcstringbytes</code></span>
<span class="codeline" id="line-785"><code>func readcstring(src []byte) (string, []byte, bool) {</code></span>
<span class="codeline" id="line-786"><code>	idx := bytes.IndexByte(src, 0x00)</code></span>
<span class="codeline" id="line-787"><code>	if idx &lt; 0 {</code></span>
<span class="codeline" id="line-788"><code>		return "", src, false</code></span>
<span class="codeline" id="line-789"><code>	}</code></span>
<span class="codeline" id="line-790"><code>	return string(src[:idx]), src[idx+1:], true</code></span>
<span class="codeline" id="line-791"><code>}</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>// keep in sync with readcstring</code></span>
<span class="codeline" id="line-794"><code>func readcstringbytes(src []byte) ([]byte, []byte, bool) {</code></span>
<span class="codeline" id="line-795"><code>	idx := bytes.IndexByte(src, 0x00)</code></span>
<span class="codeline" id="line-796"><code>	if idx &lt; 0 {</code></span>
<span class="codeline" id="line-797"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code>	return src[:idx], src[idx+1:], true</code></span>
<span class="codeline" id="line-800"><code>}</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>func appendstring(dst []byte, s string) []byte {</code></span>
<span class="codeline" id="line-803"><code>	l := int32(len(s) + 1)</code></span>
<span class="codeline" id="line-804"><code>	dst = appendLength(dst, l)</code></span>
<span class="codeline" id="line-805"><code>	dst = append(dst, s...)</code></span>
<span class="codeline" id="line-806"><code>	return append(dst, 0x00)</code></span>
<span class="codeline" id="line-807"><code>}</code></span>
<span class="codeline" id="line-808"><code></code></span>
<span class="codeline" id="line-809"><code>func readstring(src []byte) (string, []byte, bool) {</code></span>
<span class="codeline" id="line-810"><code>	l, rem, ok := ReadLength(src)</code></span>
<span class="codeline" id="line-811"><code>	if !ok {</code></span>
<span class="codeline" id="line-812"><code>		return "", src, false</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>	if len(src[4:]) &lt; int(l) || l == 0 {</code></span>
<span class="codeline" id="line-815"><code>		return "", src, false</code></span>
<span class="codeline" id="line-816"><code>	}</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>	return string(rem[:l-1]), rem[l:], true</code></span>
<span class="codeline" id="line-819"><code>}</code></span>
<span class="codeline" id="line-820"><code></code></span>
<span class="codeline" id="line-821"><code>// readLengthBytes attempts to read a length and that number of bytes. This</code></span>
<span class="codeline" id="line-822"><code>// function requires that the length include the four bytes for itself.</code></span>
<span class="codeline" id="line-823"><code>func readLengthBytes(src []byte) ([]byte, []byte, bool) {</code></span>
<span class="codeline" id="line-824"><code>	l, _, ok := ReadLength(src)</code></span>
<span class="codeline" id="line-825"><code>	if !ok {</code></span>
<span class="codeline" id="line-826"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-827"><code>	}</code></span>
<span class="codeline" id="line-828"><code>	if l &lt; 4 {</code></span>
<span class="codeline" id="line-829"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-830"><code>	}</code></span>
<span class="codeline" id="line-831"><code>	if len(src) &lt; int(l) {</code></span>
<span class="codeline" id="line-832"><code>		return nil, src, false</code></span>
<span class="codeline" id="line-833"><code>	}</code></span>
<span class="codeline" id="line-834"><code>	return src[:l], src[l:], true</code></span>
<span class="codeline" id="line-835"><code>}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>func appendBinarySubtype2(dst []byte, subtype byte, b []byte) []byte {</code></span>
<span class="codeline" id="line-838"><code>	dst = appendLength(dst, int32(len(b)+4)) // The bytes we'll encode need to be 4 larger for the length bytes</code></span>
<span class="codeline" id="line-839"><code>	dst = append(dst, subtype)</code></span>
<span class="codeline" id="line-840"><code>	dst = appendLength(dst, int32(len(b)))</code></span>
<span class="codeline" id="line-841"><code>	return append(dst, b...)</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>func isValidCString(cs string) bool {</code></span>
<span class="codeline" id="line-845"><code>	return !strings.ContainsRune(cs, '\x00')</code></span>
<span class="codeline" id="line-846"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>