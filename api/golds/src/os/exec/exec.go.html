<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: exec.go in package os/exec</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	exec.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/os/exec.html">os/exec</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package exec runs external commands. It wraps os.StartProcess to make it</code></span>
<span class="codeline" id="line-6"><code>// easier to remap stdin and stdout, connect I/O with pipes, and do other</code></span>
<span class="codeline" id="line-7"><code>// adjustments.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// Unlike the "system" library call from C and other languages, the</code></span>
<span class="codeline" id="line-10"><code>// os/exec package intentionally does not invoke the system shell and</code></span>
<span class="codeline" id="line-11"><code>// does not expand any glob patterns or handle other expansions,</code></span>
<span class="codeline" id="line-12"><code>// pipelines, or redirections typically done by shells. The package</code></span>
<span class="codeline" id="line-13"><code>// behaves more like C's "exec" family of functions. To expand glob</code></span>
<span class="codeline" id="line-14"><code>// patterns, either call the shell directly, taking care to escape any</code></span>
<span class="codeline" id="line-15"><code>// dangerous input, or use the path/filepath package's Glob function.</code></span>
<span class="codeline" id="line-16"><code>// To expand environment variables, use package os's ExpandEnv.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// Note that the examples in this package assume a Unix system.</code></span>
<span class="codeline" id="line-19"><code>// They may not run on Windows, and they do not run in the Go Playground</code></span>
<span class="codeline" id="line-20"><code>// used by golang.org and godoc.org.</code></span>
<span class="codeline" id="line-21"><code>//</code></span>
<span class="codeline" id="line-22"><code>// # Executables in the current directory</code></span>
<span class="codeline" id="line-23"><code>//</code></span>
<span class="codeline" id="line-24"><code>// The functions Command and LookPath look for a program</code></span>
<span class="codeline" id="line-25"><code>// in the directories listed in the current path, following the</code></span>
<span class="codeline" id="line-26"><code>// conventions of the host operating system.</code></span>
<span class="codeline" id="line-27"><code>// Operating systems have for decades included the current</code></span>
<span class="codeline" id="line-28"><code>// directory in this search, sometimes implicitly and sometimes</code></span>
<span class="codeline" id="line-29"><code>// configured explicitly that way by default.</code></span>
<span class="codeline" id="line-30"><code>// Modern practice is that including the current directory</code></span>
<span class="codeline" id="line-31"><code>// is usually unexpected and often leads to security problems.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// To avoid those security problems, as of Go 1.19, this package will not resolve a program</code></span>
<span class="codeline" id="line-34"><code>// using an implicit or explicit path entry relative to the current directory.</code></span>
<span class="codeline" id="line-35"><code>// That is, if you run exec.LookPath("go"), it will not successfully return</code></span>
<span class="codeline" id="line-36"><code>// ./go on Unix nor .\go.exe on Windows, no matter how the path is configured.</code></span>
<span class="codeline" id="line-37"><code>// Instead, if the usual path algorithms would result in that answer,</code></span>
<span class="codeline" id="line-38"><code>// these functions return an error err satisfying errors.Is(err, ErrDot).</code></span>
<span class="codeline" id="line-39"><code>//</code></span>
<span class="codeline" id="line-40"><code>// For example, consider these two program snippets:</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>//	path, err := exec.LookPath("prog")</code></span>
<span class="codeline" id="line-43"><code>//	if err != nil {</code></span>
<span class="codeline" id="line-44"><code>//		log.Fatal(err)</code></span>
<span class="codeline" id="line-45"><code>//	}</code></span>
<span class="codeline" id="line-46"><code>//	use(path)</code></span>
<span class="codeline" id="line-47"><code>//</code></span>
<span class="codeline" id="line-48"><code>// and</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>//	cmd := exec.Command("prog")</code></span>
<span class="codeline" id="line-51"><code>//	if err := cmd.Run(); err != nil {</code></span>
<span class="codeline" id="line-52"><code>//		log.Fatal(err)</code></span>
<span class="codeline" id="line-53"><code>//	}</code></span>
<span class="codeline" id="line-54"><code>//</code></span>
<span class="codeline" id="line-55"><code>// These will not find and run ./prog or .\prog.exe,</code></span>
<span class="codeline" id="line-56"><code>// no matter how the current path is configured.</code></span>
<span class="codeline" id="line-57"><code>//</code></span>
<span class="codeline" id="line-58"><code>// Code that always wants to run a program from the current directory</code></span>
<span class="codeline" id="line-59"><code>// can be rewritten to say "./prog" instead of "prog".</code></span>
<span class="codeline" id="line-60"><code>//</code></span>
<span class="codeline" id="line-61"><code>// Code that insists on including results from relative path entries</code></span>
<span class="codeline" id="line-62"><code>// can instead override the error using an errors.Is check:</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>//	path, err := exec.LookPath("prog")</code></span>
<span class="codeline" id="line-65"><code>//	if errors.Is(err, exec.ErrDot) {</code></span>
<span class="codeline" id="line-66"><code>//		err = nil</code></span>
<span class="codeline" id="line-67"><code>//	}</code></span>
<span class="codeline" id="line-68"><code>//	if err != nil {</code></span>
<span class="codeline" id="line-69"><code>//		log.Fatal(err)</code></span>
<span class="codeline" id="line-70"><code>//	}</code></span>
<span class="codeline" id="line-71"><code>//	use(path)</code></span>
<span class="codeline" id="line-72"><code>//</code></span>
<span class="codeline" id="line-73"><code>// and</code></span>
<span class="codeline" id="line-74"><code>//</code></span>
<span class="codeline" id="line-75"><code>//	cmd := exec.Command("prog")</code></span>
<span class="codeline" id="line-76"><code>//	if errors.Is(cmd.Err, exec.ErrDot) {</code></span>
<span class="codeline" id="line-77"><code>//		cmd.Err = nil</code></span>
<span class="codeline" id="line-78"><code>//	}</code></span>
<span class="codeline" id="line-79"><code>//	if err := cmd.Run(); err != nil {</code></span>
<span class="codeline" id="line-80"><code>//		log.Fatal(err)</code></span>
<span class="codeline" id="line-81"><code>//	}</code></span>
<span class="codeline" id="line-82"><code>//</code></span>
<span class="codeline" id="line-83"><code>// Setting the environment variable GODEBUG=execerrdot=0</code></span>
<span class="codeline" id="line-84"><code>// disables generation of ErrDot entirely, temporarily restoring the pre-Go 1.19</code></span>
<span class="codeline" id="line-85"><code>// behavior for programs that are unable to apply more targeted fixes.</code></span>
<span class="codeline" id="line-86"><code>// A future version of Go may remove support for this variable.</code></span>
<span class="codeline" id="line-87"><code>//</code></span>
<span class="codeline" id="line-88"><code>// Before adding such overrides, make sure you understand the</code></span>
<span class="codeline" id="line-89"><code>// security implications of doing so.</code></span>
<span class="codeline" id="line-90"><code>// See https://go.dev/blog/path-security for more information.</code></span></div><span class="codeline" id="line-91"><code>package exec</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>import (</code></span>
<span class="codeline" id="line-94"><code>	"bytes"</code></span>
<span class="codeline" id="line-95"><code>	"context"</code></span>
<span class="codeline" id="line-96"><code>	"errors"</code></span>
<span class="codeline" id="line-97"><code>	"internal/godebug"</code></span>
<span class="codeline" id="line-98"><code>	"internal/syscall/execenv"</code></span>
<span class="codeline" id="line-99"><code>	"io"</code></span>
<span class="codeline" id="line-100"><code>	"os"</code></span>
<span class="codeline" id="line-101"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-102"><code>	"runtime"</code></span>
<span class="codeline" id="line-103"><code>	"strconv"</code></span>
<span class="codeline" id="line-104"><code>	"strings"</code></span>
<span class="codeline" id="line-105"><code>	"syscall"</code></span>
<span class="codeline" id="line-106"><code>	"time"</code></span>
<span class="codeline" id="line-107"><code>)</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>// Error is returned by LookPath when it fails to classify a file as an</code></span>
<span class="codeline" id="line-110"><code>// executable.</code></span>
<span class="codeline" id="line-111"><code>type Error struct {</code></span>
<span class="codeline" id="line-112"><code>	// Name is the file name for which the error occurred.</code></span>
<span class="codeline" id="line-113"><code>	Name string</code></span>
<span class="codeline" id="line-114"><code>	// Err is the underlying error.</code></span>
<span class="codeline" id="line-115"><code>	Err error</code></span>
<span class="codeline" id="line-116"><code>}</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>func (e *Error) Error() string {</code></span>
<span class="codeline" id="line-119"><code>	return "exec: " + strconv.Quote(e.Name) + ": " + e.Err.Error()</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>func (e *Error) Unwrap() error { return e.Err }</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>// ErrWaitDelay is returned by (*Cmd).Wait if the process exits with a</code></span>
<span class="codeline" id="line-125"><code>// successful status code but its output pipes are not closed before the</code></span>
<span class="codeline" id="line-126"><code>// command's WaitDelay expires.</code></span>
<span class="codeline" id="line-127"><code>var ErrWaitDelay = errors.New("exec: WaitDelay expired before I/O complete")</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// wrappedError wraps an error without relying on fmt.Errorf.</code></span>
<span class="codeline" id="line-130"><code>type wrappedError struct {</code></span>
<span class="codeline" id="line-131"><code>	prefix string</code></span>
<span class="codeline" id="line-132"><code>	err    error</code></span>
<span class="codeline" id="line-133"><code>}</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>func (w wrappedError) Error() string {</code></span>
<span class="codeline" id="line-136"><code>	return w.prefix + ": " + w.err.Error()</code></span>
<span class="codeline" id="line-137"><code>}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>func (w wrappedError) Unwrap() error {</code></span>
<span class="codeline" id="line-140"><code>	return w.err</code></span>
<span class="codeline" id="line-141"><code>}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// Cmd represents an external command being prepared or run.</code></span>
<span class="codeline" id="line-144"><code>//</code></span>
<span class="codeline" id="line-145"><code>// A Cmd cannot be reused after calling its Run, Output or CombinedOutput</code></span>
<span class="codeline" id="line-146"><code>// methods.</code></span>
<span class="codeline" id="line-147"><code>type Cmd struct {</code></span>
<span class="codeline" id="line-148"><code>	// Path is the path of the command to run.</code></span>
<span class="codeline" id="line-149"><code>	//</code></span>
<span class="codeline" id="line-150"><code>	// This is the only field that must be set to a non-zero</code></span>
<span class="codeline" id="line-151"><code>	// value. If Path is relative, it is evaluated relative</code></span>
<span class="codeline" id="line-152"><code>	// to Dir.</code></span>
<span class="codeline" id="line-153"><code>	Path string</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// Args holds command line arguments, including the command as Args[0].</code></span>
<span class="codeline" id="line-156"><code>	// If the Args field is empty or nil, Run uses {Path}.</code></span>
<span class="codeline" id="line-157"><code>	//</code></span>
<span class="codeline" id="line-158"><code>	// In typical use, both Path and Args are set by calling Command.</code></span>
<span class="codeline" id="line-159"><code>	Args []string</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>	// Env specifies the environment of the process.</code></span>
<span class="codeline" id="line-162"><code>	// Each entry is of the form "key=value".</code></span>
<span class="codeline" id="line-163"><code>	// If Env is nil, the new process uses the current process's</code></span>
<span class="codeline" id="line-164"><code>	// environment.</code></span>
<span class="codeline" id="line-165"><code>	// If Env contains duplicate environment keys, only the last</code></span>
<span class="codeline" id="line-166"><code>	// value in the slice for each duplicate key is used.</code></span>
<span class="codeline" id="line-167"><code>	// As a special case on Windows, SYSTEMROOT is always added if</code></span>
<span class="codeline" id="line-168"><code>	// missing and not explicitly set to the empty string.</code></span>
<span class="codeline" id="line-169"><code>	Env []string</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>	// Dir specifies the working directory of the command.</code></span>
<span class="codeline" id="line-172"><code>	// If Dir is the empty string, Run runs the command in the</code></span>
<span class="codeline" id="line-173"><code>	// calling process's current directory.</code></span>
<span class="codeline" id="line-174"><code>	Dir string</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>	// Stdin specifies the process's standard input.</code></span>
<span class="codeline" id="line-177"><code>	//</code></span>
<span class="codeline" id="line-178"><code>	// If Stdin is nil, the process reads from the null device (os.DevNull).</code></span>
<span class="codeline" id="line-179"><code>	//</code></span>
<span class="codeline" id="line-180"><code>	// If Stdin is an *os.File, the process's standard input is connected</code></span>
<span class="codeline" id="line-181"><code>	// directly to that file.</code></span>
<span class="codeline" id="line-182"><code>	//</code></span>
<span class="codeline" id="line-183"><code>	// Otherwise, during the execution of the command a separate</code></span>
<span class="codeline" id="line-184"><code>	// goroutine reads from Stdin and delivers that data to the command</code></span>
<span class="codeline" id="line-185"><code>	// over a pipe. In this case, Wait does not complete until the goroutine</code></span>
<span class="codeline" id="line-186"><code>	// stops copying, either because it has reached the end of Stdin</code></span>
<span class="codeline" id="line-187"><code>	// (EOF or a read error), or because writing to the pipe returned an error,</code></span>
<span class="codeline" id="line-188"><code>	// or because a nonzero WaitDelay was set and expired.</code></span>
<span class="codeline" id="line-189"><code>	Stdin io.Reader</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>	// Stdout and Stderr specify the process's standard output and error.</code></span>
<span class="codeline" id="line-192"><code>	//</code></span>
<span class="codeline" id="line-193"><code>	// If either is nil, Run connects the corresponding file descriptor</code></span>
<span class="codeline" id="line-194"><code>	// to the null device (os.DevNull).</code></span>
<span class="codeline" id="line-195"><code>	//</code></span>
<span class="codeline" id="line-196"><code>	// If either is an *os.File, the corresponding output from the process</code></span>
<span class="codeline" id="line-197"><code>	// is connected directly to that file.</code></span>
<span class="codeline" id="line-198"><code>	//</code></span>
<span class="codeline" id="line-199"><code>	// Otherwise, during the execution of the command a separate goroutine</code></span>
<span class="codeline" id="line-200"><code>	// reads from the process over a pipe and delivers that data to the</code></span>
<span class="codeline" id="line-201"><code>	// corresponding Writer. In this case, Wait does not complete until the</code></span>
<span class="codeline" id="line-202"><code>	// goroutine reaches EOF or encounters an error or a nonzero WaitDelay</code></span>
<span class="codeline" id="line-203"><code>	// expires.</code></span>
<span class="codeline" id="line-204"><code>	//</code></span>
<span class="codeline" id="line-205"><code>	// If Stdout and Stderr are the same writer, and have a type that can</code></span>
<span class="codeline" id="line-206"><code>	// be compared with ==, at most one goroutine at a time will call Write.</code></span>
<span class="codeline" id="line-207"><code>	Stdout io.Writer</code></span>
<span class="codeline" id="line-208"><code>	Stderr io.Writer</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>	// ExtraFiles specifies additional open files to be inherited by the</code></span>
<span class="codeline" id="line-211"><code>	// new process. It does not include standard input, standard output, or</code></span>
<span class="codeline" id="line-212"><code>	// standard error. If non-nil, entry i becomes file descriptor 3+i.</code></span>
<span class="codeline" id="line-213"><code>	//</code></span>
<span class="codeline" id="line-214"><code>	// ExtraFiles is not supported on Windows.</code></span>
<span class="codeline" id="line-215"><code>	ExtraFiles []*os.File</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>	// SysProcAttr holds optional, operating system-specific attributes.</code></span>
<span class="codeline" id="line-218"><code>	// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.</code></span>
<span class="codeline" id="line-219"><code>	SysProcAttr *syscall.SysProcAttr</code></span>
<span class="codeline" id="line-220"><code></code></span>
<span class="codeline" id="line-221"><code>	// Process is the underlying process, once started.</code></span>
<span class="codeline" id="line-222"><code>	Process *os.Process</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>	// ProcessState contains information about an exited process.</code></span>
<span class="codeline" id="line-225"><code>	// If the process was started successfully, Wait or Run will</code></span>
<span class="codeline" id="line-226"><code>	// populate its ProcessState when the command completes.</code></span>
<span class="codeline" id="line-227"><code>	ProcessState *os.ProcessState</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>	// ctx is the context passed to CommandContext, if any.</code></span>
<span class="codeline" id="line-230"><code>	ctx context.Context</code></span>
<span class="codeline" id="line-231"><code></code></span>
<span class="codeline" id="line-232"><code>	Err error // LookPath error, if any.</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>	// If Cancel is non-nil, the command must have been created with</code></span>
<span class="codeline" id="line-235"><code>	// CommandContext and Cancel will be called when the command's</code></span>
<span class="codeline" id="line-236"><code>	// Context is done. By default, CommandContext sets Cancel to</code></span>
<span class="codeline" id="line-237"><code>	// call the Kill method on the command's Process.</code></span>
<span class="codeline" id="line-238"><code>	//</code></span>
<span class="codeline" id="line-239"><code>	// Typically a custom Cancel will send a signal to the command's</code></span>
<span class="codeline" id="line-240"><code>	// Process, but it may instead take other actions to initiate cancellation,</code></span>
<span class="codeline" id="line-241"><code>	// such as closing a stdin or stdout pipe or sending a shutdown request on a</code></span>
<span class="codeline" id="line-242"><code>	// network socket.</code></span>
<span class="codeline" id="line-243"><code>	//</code></span>
<span class="codeline" id="line-244"><code>	// If the command exits with a success status after Cancel is</code></span>
<span class="codeline" id="line-245"><code>	// called, and Cancel does not return an error equivalent to</code></span>
<span class="codeline" id="line-246"><code>	// os.ErrProcessDone, then Wait and similar methods will return a non-nil</code></span>
<span class="codeline" id="line-247"><code>	// error: either an error wrapping the one returned by Cancel,</code></span>
<span class="codeline" id="line-248"><code>	// or the error from the Context.</code></span>
<span class="codeline" id="line-249"><code>	// (If the command exits with a non-success status, or Cancel</code></span>
<span class="codeline" id="line-250"><code>	// returns an error that wraps os.ErrProcessDone, Wait and similar methods</code></span>
<span class="codeline" id="line-251"><code>	// continue to return the command's usual exit status.)</code></span>
<span class="codeline" id="line-252"><code>	//</code></span>
<span class="codeline" id="line-253"><code>	// If Cancel is set to nil, nothing will happen immediately when the command's</code></span>
<span class="codeline" id="line-254"><code>	// Context is done, but a nonzero WaitDelay will still take effect. That may</code></span>
<span class="codeline" id="line-255"><code>	// be useful, for example, to work around deadlocks in commands that do not</code></span>
<span class="codeline" id="line-256"><code>	// support shutdown signals but are expected to always finish quickly.</code></span>
<span class="codeline" id="line-257"><code>	//</code></span>
<span class="codeline" id="line-258"><code>	// Cancel will not be called if Start returns a non-nil error.</code></span>
<span class="codeline" id="line-259"><code>	Cancel func() error</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>	// If WaitDelay is non-zero, it bounds the time spent waiting on two sources</code></span>
<span class="codeline" id="line-262"><code>	// of unexpected delay in Wait: a child process that fails to exit after the</code></span>
<span class="codeline" id="line-263"><code>	// associated Context is canceled, and a child process that exits but leaves</code></span>
<span class="codeline" id="line-264"><code>	// its I/O pipes unclosed.</code></span>
<span class="codeline" id="line-265"><code>	//</code></span>
<span class="codeline" id="line-266"><code>	// The WaitDelay timer starts when either the associated Context is done or a</code></span>
<span class="codeline" id="line-267"><code>	// call to Wait observes that the child process has exited, whichever occurs</code></span>
<span class="codeline" id="line-268"><code>	// first. When the delay has elapsed, the command shuts down the child process</code></span>
<span class="codeline" id="line-269"><code>	// and/or its I/O pipes.</code></span>
<span class="codeline" id="line-270"><code>	//</code></span>
<span class="codeline" id="line-271"><code>	// If the child process has failed to exit — perhaps because it ignored or</code></span>
<span class="codeline" id="line-272"><code>	// failed to receive a shutdown signal from a Cancel function, or because no</code></span>
<span class="codeline" id="line-273"><code>	// Cancel function was set — then it will be terminated using os.Process.Kill.</code></span>
<span class="codeline" id="line-274"><code>	//</code></span>
<span class="codeline" id="line-275"><code>	// Then, if the I/O pipes communicating with the child process are still open,</code></span>
<span class="codeline" id="line-276"><code>	// those pipes are closed in order to unblock any goroutines currently blocked</code></span>
<span class="codeline" id="line-277"><code>	// on Read or Write calls.</code></span>
<span class="codeline" id="line-278"><code>	//</code></span>
<span class="codeline" id="line-279"><code>	// If pipes are closed due to WaitDelay, no Cancel call has occurred,</code></span>
<span class="codeline" id="line-280"><code>	// and the command has otherwise exited with a successful status, Wait and</code></span>
<span class="codeline" id="line-281"><code>	// similar methods will return ErrWaitDelay instead of nil.</code></span>
<span class="codeline" id="line-282"><code>	//</code></span>
<span class="codeline" id="line-283"><code>	// If WaitDelay is zero (the default), I/O pipes will be read until EOF,</code></span>
<span class="codeline" id="line-284"><code>	// which might not occur until orphaned subprocesses of the command have</code></span>
<span class="codeline" id="line-285"><code>	// also closed their descriptors for the pipes.</code></span>
<span class="codeline" id="line-286"><code>	WaitDelay time.Duration</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>	// childIOFiles holds closers for any of the child process's</code></span>
<span class="codeline" id="line-289"><code>	// stdin, stdout, and/or stderr files that were opened by the Cmd itself</code></span>
<span class="codeline" id="line-290"><code>	// (not supplied by the caller). These should be closed as soon as they</code></span>
<span class="codeline" id="line-291"><code>	// are inherited by the child process.</code></span>
<span class="codeline" id="line-292"><code>	childIOFiles []io.Closer</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>	// parentIOPipes holds closers for the parent's end of any pipes</code></span>
<span class="codeline" id="line-295"><code>	// connected to the child's stdin, stdout, and/or stderr streams</code></span>
<span class="codeline" id="line-296"><code>	// that were opened by the Cmd itself (not supplied by the caller).</code></span>
<span class="codeline" id="line-297"><code>	// These should be closed after Wait sees the command and copying</code></span>
<span class="codeline" id="line-298"><code>	// goroutines exit, or after WaitDelay has expired.</code></span>
<span class="codeline" id="line-299"><code>	parentIOPipes []io.Closer</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>	// goroutine holds a set of closures to execute to copy data</code></span>
<span class="codeline" id="line-302"><code>	// to and/or from the command's I/O pipes.</code></span>
<span class="codeline" id="line-303"><code>	goroutine []func() error</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>	// If goroutineErr is non-nil, it receives the first error from a copying</code></span>
<span class="codeline" id="line-306"><code>	// goroutine once all such goroutines have completed.</code></span>
<span class="codeline" id="line-307"><code>	// goroutineErr is set to nil once its error has been received.</code></span>
<span class="codeline" id="line-308"><code>	goroutineErr &lt;-chan error</code></span>
<span class="codeline" id="line-309"><code></code></span>
<span class="codeline" id="line-310"><code>	// If ctxResult is non-nil, it receives the result of watchCtx exactly once.</code></span>
<span class="codeline" id="line-311"><code>	ctxResult &lt;-chan ctxResult</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>	// The stack saved when the Command was created, if GODEBUG contains</code></span>
<span class="codeline" id="line-314"><code>	// execwait=2. Used for debugging leaks.</code></span>
<span class="codeline" id="line-315"><code>	createdByStack []byte</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>	// For a security release long ago, we created x/sys/execabs,</code></span>
<span class="codeline" id="line-318"><code>	// which manipulated the unexported lookPathErr error field</code></span>
<span class="codeline" id="line-319"><code>	// in this struct. For Go 1.19 we exported the field as Err error,</code></span>
<span class="codeline" id="line-320"><code>	// above, but we have to keep lookPathErr around for use by</code></span>
<span class="codeline" id="line-321"><code>	// old programs building against new toolchains.</code></span>
<span class="codeline" id="line-322"><code>	// The String and Start methods look for an error in lookPathErr</code></span>
<span class="codeline" id="line-323"><code>	// in preference to Err, to preserve the errors that execabs sets.</code></span>
<span class="codeline" id="line-324"><code>	//</code></span>
<span class="codeline" id="line-325"><code>	// In general we don't guarantee misuse of reflect like this,</code></span>
<span class="codeline" id="line-326"><code>	// but the misuse of reflect was by us, the best of various bad</code></span>
<span class="codeline" id="line-327"><code>	// options to fix the security problem, and people depend on</code></span>
<span class="codeline" id="line-328"><code>	// those old copies of execabs continuing to work.</code></span>
<span class="codeline" id="line-329"><code>	// The result is that we have to leave this variable around for the</code></span>
<span class="codeline" id="line-330"><code>	// rest of time, a compatibility scar.</code></span>
<span class="codeline" id="line-331"><code>	//</code></span>
<span class="codeline" id="line-332"><code>	// See https://go.dev/blog/path-security</code></span>
<span class="codeline" id="line-333"><code>	// and https://go.dev/issue/43724 for more context.</code></span>
<span class="codeline" id="line-334"><code>	lookPathErr error</code></span>
<span class="codeline" id="line-335"><code>}</code></span>
<span class="codeline" id="line-336"><code></code></span>
<span class="codeline" id="line-337"><code>// A ctxResult reports the result of watching the Context associated with a</code></span>
<span class="codeline" id="line-338"><code>// running command (and sending corresponding signals if needed).</code></span>
<span class="codeline" id="line-339"><code>type ctxResult struct {</code></span>
<span class="codeline" id="line-340"><code>	err error</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>	// If timer is non-nil, it expires after WaitDelay has elapsed after</code></span>
<span class="codeline" id="line-343"><code>	// the Context is done.</code></span>
<span class="codeline" id="line-344"><code>	//</code></span>
<span class="codeline" id="line-345"><code>	// (If timer is nil, that means that the Context was not done before the</code></span>
<span class="codeline" id="line-346"><code>	// command completed, or no WaitDelay was set, or the WaitDelay already</code></span>
<span class="codeline" id="line-347"><code>	// expired and its effect was already applied.)</code></span>
<span class="codeline" id="line-348"><code>	timer *time.Timer</code></span>
<span class="codeline" id="line-349"><code>}</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>var execwait = godebug.New("#execwait")</code></span>
<span class="codeline" id="line-352"><code>var execerrdot = godebug.New("execerrdot")</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>// Command returns the Cmd struct to execute the named program with</code></span>
<span class="codeline" id="line-355"><code>// the given arguments.</code></span>
<span class="codeline" id="line-356"><code>//</code></span>
<span class="codeline" id="line-357"><code>// It sets only the Path and Args in the returned structure.</code></span>
<span class="codeline" id="line-358"><code>//</code></span>
<span class="codeline" id="line-359"><code>// If name contains no path separators, Command uses LookPath to</code></span>
<span class="codeline" id="line-360"><code>// resolve name to a complete path if possible. Otherwise it uses name</code></span>
<span class="codeline" id="line-361"><code>// directly as Path.</code></span>
<span class="codeline" id="line-362"><code>//</code></span>
<span class="codeline" id="line-363"><code>// The returned Cmd's Args field is constructed from the command name</code></span>
<span class="codeline" id="line-364"><code>// followed by the elements of arg, so arg should not include the</code></span>
<span class="codeline" id="line-365"><code>// command name itself. For example, Command("echo", "hello").</code></span>
<span class="codeline" id="line-366"><code>// Args[0] is always name, not the possibly resolved Path.</code></span>
<span class="codeline" id="line-367"><code>//</code></span>
<span class="codeline" id="line-368"><code>// On Windows, processes receive the whole command line as a single string</code></span>
<span class="codeline" id="line-369"><code>// and do their own parsing. Command combines and quotes Args into a command</code></span>
<span class="codeline" id="line-370"><code>// line string with an algorithm compatible with applications using</code></span>
<span class="codeline" id="line-371"><code>// CommandLineToArgvW (which is the most common way). Notable exceptions are</code></span>
<span class="codeline" id="line-372"><code>// msiexec.exe and cmd.exe (and thus, all batch files), which have a different</code></span>
<span class="codeline" id="line-373"><code>// unquoting algorithm. In these or other similar cases, you can do the</code></span>
<span class="codeline" id="line-374"><code>// quoting yourself and provide the full command line in SysProcAttr.CmdLine,</code></span>
<span class="codeline" id="line-375"><code>// leaving Args empty.</code></span>
<span class="codeline" id="line-376"><code>func Command(name string, arg ...string) *Cmd {</code></span>
<span class="codeline" id="line-377"><code>	cmd := &amp;Cmd{</code></span>
<span class="codeline" id="line-378"><code>		Path: name,</code></span>
<span class="codeline" id="line-379"><code>		Args: append([]string{name}, arg...),</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>	if v := execwait.Value(); v != "" {</code></span>
<span class="codeline" id="line-383"><code>		if v == "2" {</code></span>
<span class="codeline" id="line-384"><code>			// Obtain the caller stack. (This is equivalent to runtime/debug.Stack,</code></span>
<span class="codeline" id="line-385"><code>			// copied to avoid importing the whole package.)</code></span>
<span class="codeline" id="line-386"><code>			stack := make([]byte, 1024)</code></span>
<span class="codeline" id="line-387"><code>			for {</code></span>
<span class="codeline" id="line-388"><code>				n := runtime.Stack(stack, false)</code></span>
<span class="codeline" id="line-389"><code>				if n &lt; len(stack) {</code></span>
<span class="codeline" id="line-390"><code>					stack = stack[:n]</code></span>
<span class="codeline" id="line-391"><code>					break</code></span>
<span class="codeline" id="line-392"><code>				}</code></span>
<span class="codeline" id="line-393"><code>				stack = make([]byte, 2*len(stack))</code></span>
<span class="codeline" id="line-394"><code>			}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>			if i := bytes.Index(stack, []byte("\nos/exec.Command(")); i &gt;= 0 {</code></span>
<span class="codeline" id="line-397"><code>				stack = stack[i+1:]</code></span>
<span class="codeline" id="line-398"><code>			}</code></span>
<span class="codeline" id="line-399"><code>			cmd.createdByStack = stack</code></span>
<span class="codeline" id="line-400"><code>		}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>		runtime.SetFinalizer(cmd, func(c *Cmd) {</code></span>
<span class="codeline" id="line-403"><code>			if c.Process != nil &amp;&amp; c.ProcessState == nil {</code></span>
<span class="codeline" id="line-404"><code>				debugHint := ""</code></span>
<span class="codeline" id="line-405"><code>				if c.createdByStack == nil {</code></span>
<span class="codeline" id="line-406"><code>					debugHint = " (set GODEBUG=execwait=2 to capture stacks for debugging)"</code></span>
<span class="codeline" id="line-407"><code>				} else {</code></span>
<span class="codeline" id="line-408"><code>					os.Stderr.WriteString("GODEBUG=execwait=2 detected a leaked exec.Cmd created by:\n")</code></span>
<span class="codeline" id="line-409"><code>					os.Stderr.Write(c.createdByStack)</code></span>
<span class="codeline" id="line-410"><code>					os.Stderr.WriteString("\n")</code></span>
<span class="codeline" id="line-411"><code>					debugHint = ""</code></span>
<span class="codeline" id="line-412"><code>				}</code></span>
<span class="codeline" id="line-413"><code>				panic("exec: Cmd started a Process but leaked without a call to Wait" + debugHint)</code></span>
<span class="codeline" id="line-414"><code>			}</code></span>
<span class="codeline" id="line-415"><code>		})</code></span>
<span class="codeline" id="line-416"><code>	}</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>	if filepath.Base(name) == name {</code></span>
<span class="codeline" id="line-419"><code>		lp, err := LookPath(name)</code></span>
<span class="codeline" id="line-420"><code>		if lp != "" {</code></span>
<span class="codeline" id="line-421"><code>			// Update cmd.Path even if err is non-nil.</code></span>
<span class="codeline" id="line-422"><code>			// If err is ErrDot (especially on Windows), lp may include a resolved</code></span>
<span class="codeline" id="line-423"><code>			// extension (like .exe or .bat) that should be preserved.</code></span>
<span class="codeline" id="line-424"><code>			cmd.Path = lp</code></span>
<span class="codeline" id="line-425"><code>		}</code></span>
<span class="codeline" id="line-426"><code>		if err != nil {</code></span>
<span class="codeline" id="line-427"><code>			cmd.Err = err</code></span>
<span class="codeline" id="line-428"><code>		}</code></span>
<span class="codeline" id="line-429"><code>	} else if runtime.GOOS == "windows" &amp;&amp; filepath.IsAbs(name) {</code></span>
<span class="codeline" id="line-430"><code>		// We may need to add a filename extension from PATHEXT</code></span>
<span class="codeline" id="line-431"><code>		// or verify an extension that is already present.</code></span>
<span class="codeline" id="line-432"><code>		// Since the path is absolute, its extension should be unambiguous</code></span>
<span class="codeline" id="line-433"><code>		// and independent of cmd.Dir, and we can go ahead and update cmd.Path to</code></span>
<span class="codeline" id="line-434"><code>		// reflect it.</code></span>
<span class="codeline" id="line-435"><code>		//</code></span>
<span class="codeline" id="line-436"><code>		// Note that we cannot add an extension here for relative paths, because</code></span>
<span class="codeline" id="line-437"><code>		// cmd.Dir may be set after we return from this function and that may cause</code></span>
<span class="codeline" id="line-438"><code>		// the command to resolve to a different extension.</code></span>
<span class="codeline" id="line-439"><code>		lp, err := lookExtensions(name, "")</code></span>
<span class="codeline" id="line-440"><code>		if lp != "" {</code></span>
<span class="codeline" id="line-441"><code>			cmd.Path = lp</code></span>
<span class="codeline" id="line-442"><code>		}</code></span>
<span class="codeline" id="line-443"><code>		if err != nil {</code></span>
<span class="codeline" id="line-444"><code>			cmd.Err = err</code></span>
<span class="codeline" id="line-445"><code>		}</code></span>
<span class="codeline" id="line-446"><code>	}</code></span>
<span class="codeline" id="line-447"><code>	return cmd</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>// CommandContext is like Command but includes a context.</code></span>
<span class="codeline" id="line-451"><code>//</code></span>
<span class="codeline" id="line-452"><code>// The provided context is used to interrupt the process</code></span>
<span class="codeline" id="line-453"><code>// (by calling cmd.Cancel or os.Process.Kill)</code></span>
<span class="codeline" id="line-454"><code>// if the context becomes done before the command completes on its own.</code></span>
<span class="codeline" id="line-455"><code>//</code></span>
<span class="codeline" id="line-456"><code>// CommandContext sets the command's Cancel function to invoke the Kill method</code></span>
<span class="codeline" id="line-457"><code>// on its Process, and leaves its WaitDelay unset. The caller may change the</code></span>
<span class="codeline" id="line-458"><code>// cancellation behavior by modifying those fields before starting the command.</code></span>
<span class="codeline" id="line-459"><code>func CommandContext(ctx context.Context, name string, arg ...string) *Cmd {</code></span>
<span class="codeline" id="line-460"><code>	if ctx == nil {</code></span>
<span class="codeline" id="line-461"><code>		panic("nil Context")</code></span>
<span class="codeline" id="line-462"><code>	}</code></span>
<span class="codeline" id="line-463"><code>	cmd := Command(name, arg...)</code></span>
<span class="codeline" id="line-464"><code>	cmd.ctx = ctx</code></span>
<span class="codeline" id="line-465"><code>	cmd.Cancel = func() error {</code></span>
<span class="codeline" id="line-466"><code>		return cmd.Process.Kill()</code></span>
<span class="codeline" id="line-467"><code>	}</code></span>
<span class="codeline" id="line-468"><code>	return cmd</code></span>
<span class="codeline" id="line-469"><code>}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>// String returns a human-readable description of c.</code></span>
<span class="codeline" id="line-472"><code>// It is intended only for debugging.</code></span>
<span class="codeline" id="line-473"><code>// In particular, it is not suitable for use as input to a shell.</code></span>
<span class="codeline" id="line-474"><code>// The output of String may vary across Go releases.</code></span>
<span class="codeline" id="line-475"><code>func (c *Cmd) String() string {</code></span>
<span class="codeline" id="line-476"><code>	if c.Err != nil || c.lookPathErr != nil {</code></span>
<span class="codeline" id="line-477"><code>		// failed to resolve path; report the original requested path (plus args)</code></span>
<span class="codeline" id="line-478"><code>		return strings.Join(c.Args, " ")</code></span>
<span class="codeline" id="line-479"><code>	}</code></span>
<span class="codeline" id="line-480"><code>	// report the exact executable path (plus args)</code></span>
<span class="codeline" id="line-481"><code>	b := new(strings.Builder)</code></span>
<span class="codeline" id="line-482"><code>	b.WriteString(c.Path)</code></span>
<span class="codeline" id="line-483"><code>	for _, a := range c.Args[1:] {</code></span>
<span class="codeline" id="line-484"><code>		b.WriteByte(' ')</code></span>
<span class="codeline" id="line-485"><code>		b.WriteString(a)</code></span>
<span class="codeline" id="line-486"><code>	}</code></span>
<span class="codeline" id="line-487"><code>	return b.String()</code></span>
<span class="codeline" id="line-488"><code>}</code></span>
<span class="codeline" id="line-489"><code></code></span>
<span class="codeline" id="line-490"><code>// interfaceEqual protects against panics from doing equality tests on</code></span>
<span class="codeline" id="line-491"><code>// two interfaces with non-comparable underlying types.</code></span>
<span class="codeline" id="line-492"><code>func interfaceEqual(a, b any) bool {</code></span>
<span class="codeline" id="line-493"><code>	defer func() {</code></span>
<span class="codeline" id="line-494"><code>		recover()</code></span>
<span class="codeline" id="line-495"><code>	}()</code></span>
<span class="codeline" id="line-496"><code>	return a == b</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>func (c *Cmd) argv() []string {</code></span>
<span class="codeline" id="line-500"><code>	if len(c.Args) &gt; 0 {</code></span>
<span class="codeline" id="line-501"><code>		return c.Args</code></span>
<span class="codeline" id="line-502"><code>	}</code></span>
<span class="codeline" id="line-503"><code>	return []string{c.Path}</code></span>
<span class="codeline" id="line-504"><code>}</code></span>
<span class="codeline" id="line-505"><code></code></span>
<span class="codeline" id="line-506"><code>func (c *Cmd) childStdin() (*os.File, error) {</code></span>
<span class="codeline" id="line-507"><code>	if c.Stdin == nil {</code></span>
<span class="codeline" id="line-508"><code>		f, err := os.Open(os.DevNull)</code></span>
<span class="codeline" id="line-509"><code>		if err != nil {</code></span>
<span class="codeline" id="line-510"><code>			return nil, err</code></span>
<span class="codeline" id="line-511"><code>		}</code></span>
<span class="codeline" id="line-512"><code>		c.childIOFiles = append(c.childIOFiles, f)</code></span>
<span class="codeline" id="line-513"><code>		return f, nil</code></span>
<span class="codeline" id="line-514"><code>	}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>	if f, ok := c.Stdin.(*os.File); ok {</code></span>
<span class="codeline" id="line-517"><code>		return f, nil</code></span>
<span class="codeline" id="line-518"><code>	}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-521"><code>	if err != nil {</code></span>
<span class="codeline" id="line-522"><code>		return nil, err</code></span>
<span class="codeline" id="line-523"><code>	}</code></span>
<span class="codeline" id="line-524"><code></code></span>
<span class="codeline" id="line-525"><code>	c.childIOFiles = append(c.childIOFiles, pr)</code></span>
<span class="codeline" id="line-526"><code>	c.parentIOPipes = append(c.parentIOPipes, pw)</code></span>
<span class="codeline" id="line-527"><code>	c.goroutine = append(c.goroutine, func() error {</code></span>
<span class="codeline" id="line-528"><code>		_, err := io.Copy(pw, c.Stdin)</code></span>
<span class="codeline" id="line-529"><code>		if skipStdinCopyError(err) {</code></span>
<span class="codeline" id="line-530"><code>			err = nil</code></span>
<span class="codeline" id="line-531"><code>		}</code></span>
<span class="codeline" id="line-532"><code>		if err1 := pw.Close(); err == nil {</code></span>
<span class="codeline" id="line-533"><code>			err = err1</code></span>
<span class="codeline" id="line-534"><code>		}</code></span>
<span class="codeline" id="line-535"><code>		return err</code></span>
<span class="codeline" id="line-536"><code>	})</code></span>
<span class="codeline" id="line-537"><code>	return pr, nil</code></span>
<span class="codeline" id="line-538"><code>}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>func (c *Cmd) childStdout() (*os.File, error) {</code></span>
<span class="codeline" id="line-541"><code>	return c.writerDescriptor(c.Stdout)</code></span>
<span class="codeline" id="line-542"><code>}</code></span>
<span class="codeline" id="line-543"><code></code></span>
<span class="codeline" id="line-544"><code>func (c *Cmd) childStderr(childStdout *os.File) (*os.File, error) {</code></span>
<span class="codeline" id="line-545"><code>	if c.Stderr != nil &amp;&amp; interfaceEqual(c.Stderr, c.Stdout) {</code></span>
<span class="codeline" id="line-546"><code>		return childStdout, nil</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code>	return c.writerDescriptor(c.Stderr)</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>// writerDescriptor returns an os.File to which the child process</code></span>
<span class="codeline" id="line-552"><code>// can write to send data to w.</code></span>
<span class="codeline" id="line-553"><code>//</code></span>
<span class="codeline" id="line-554"><code>// If w is nil, writerDescriptor returns a File that writes to os.DevNull.</code></span>
<span class="codeline" id="line-555"><code>func (c *Cmd) writerDescriptor(w io.Writer) (*os.File, error) {</code></span>
<span class="codeline" id="line-556"><code>	if w == nil {</code></span>
<span class="codeline" id="line-557"><code>		f, err := os.OpenFile(os.DevNull, os.O_WRONLY, 0)</code></span>
<span class="codeline" id="line-558"><code>		if err != nil {</code></span>
<span class="codeline" id="line-559"><code>			return nil, err</code></span>
<span class="codeline" id="line-560"><code>		}</code></span>
<span class="codeline" id="line-561"><code>		c.childIOFiles = append(c.childIOFiles, f)</code></span>
<span class="codeline" id="line-562"><code>		return f, nil</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code></code></span>
<span class="codeline" id="line-565"><code>	if f, ok := w.(*os.File); ok {</code></span>
<span class="codeline" id="line-566"><code>		return f, nil</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code></code></span>
<span class="codeline" id="line-569"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-570"><code>	if err != nil {</code></span>
<span class="codeline" id="line-571"><code>		return nil, err</code></span>
<span class="codeline" id="line-572"><code>	}</code></span>
<span class="codeline" id="line-573"><code></code></span>
<span class="codeline" id="line-574"><code>	c.childIOFiles = append(c.childIOFiles, pw)</code></span>
<span class="codeline" id="line-575"><code>	c.parentIOPipes = append(c.parentIOPipes, pr)</code></span>
<span class="codeline" id="line-576"><code>	c.goroutine = append(c.goroutine, func() error {</code></span>
<span class="codeline" id="line-577"><code>		_, err := io.Copy(w, pr)</code></span>
<span class="codeline" id="line-578"><code>		pr.Close() // in case io.Copy stopped due to write error</code></span>
<span class="codeline" id="line-579"><code>		return err</code></span>
<span class="codeline" id="line-580"><code>	})</code></span>
<span class="codeline" id="line-581"><code>	return pw, nil</code></span>
<span class="codeline" id="line-582"><code>}</code></span>
<span class="codeline" id="line-583"><code></code></span>
<span class="codeline" id="line-584"><code>func closeDescriptors(closers []io.Closer) {</code></span>
<span class="codeline" id="line-585"><code>	for _, fd := range closers {</code></span>
<span class="codeline" id="line-586"><code>		fd.Close()</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code>}</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>// Run starts the specified command and waits for it to complete.</code></span>
<span class="codeline" id="line-591"><code>//</code></span>
<span class="codeline" id="line-592"><code>// The returned error is nil if the command runs, has no problems</code></span>
<span class="codeline" id="line-593"><code>// copying stdin, stdout, and stderr, and exits with a zero exit</code></span>
<span class="codeline" id="line-594"><code>// status.</code></span>
<span class="codeline" id="line-595"><code>//</code></span>
<span class="codeline" id="line-596"><code>// If the command starts but does not complete successfully, the error is of</code></span>
<span class="codeline" id="line-597"><code>// type *ExitError. Other error types may be returned for other situations.</code></span>
<span class="codeline" id="line-598"><code>//</code></span>
<span class="codeline" id="line-599"><code>// If the calling goroutine has locked the operating system thread</code></span>
<span class="codeline" id="line-600"><code>// with runtime.LockOSThread and modified any inheritable OS-level</code></span>
<span class="codeline" id="line-601"><code>// thread state (for example, Linux or Plan 9 name spaces), the new</code></span>
<span class="codeline" id="line-602"><code>// process will inherit the caller's thread state.</code></span>
<span class="codeline" id="line-603"><code>func (c *Cmd) Run() error {</code></span>
<span class="codeline" id="line-604"><code>	if err := c.Start(); err != nil {</code></span>
<span class="codeline" id="line-605"><code>		return err</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	return c.Wait()</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// Start starts the specified command but does not wait for it to complete.</code></span>
<span class="codeline" id="line-611"><code>//</code></span>
<span class="codeline" id="line-612"><code>// If Start returns successfully, the c.Process field will be set.</code></span>
<span class="codeline" id="line-613"><code>//</code></span>
<span class="codeline" id="line-614"><code>// After a successful call to Start the Wait method must be called in</code></span>
<span class="codeline" id="line-615"><code>// order to release associated system resources.</code></span>
<span class="codeline" id="line-616"><code>func (c *Cmd) Start() error {</code></span>
<span class="codeline" id="line-617"><code>	// Check for doubled Start calls before we defer failure cleanup. If the prior</code></span>
<span class="codeline" id="line-618"><code>	// call to Start succeeded, we don't want to spuriously close its pipes.</code></span>
<span class="codeline" id="line-619"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-620"><code>		return errors.New("exec: already started")</code></span>
<span class="codeline" id="line-621"><code>	}</code></span>
<span class="codeline" id="line-622"><code></code></span>
<span class="codeline" id="line-623"><code>	started := false</code></span>
<span class="codeline" id="line-624"><code>	defer func() {</code></span>
<span class="codeline" id="line-625"><code>		closeDescriptors(c.childIOFiles)</code></span>
<span class="codeline" id="line-626"><code>		c.childIOFiles = nil</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>		if !started {</code></span>
<span class="codeline" id="line-629"><code>			closeDescriptors(c.parentIOPipes)</code></span>
<span class="codeline" id="line-630"><code>			c.parentIOPipes = nil</code></span>
<span class="codeline" id="line-631"><code>		}</code></span>
<span class="codeline" id="line-632"><code>	}()</code></span>
<span class="codeline" id="line-633"><code></code></span>
<span class="codeline" id="line-634"><code>	if c.Path == "" &amp;&amp; c.Err == nil &amp;&amp; c.lookPathErr == nil {</code></span>
<span class="codeline" id="line-635"><code>		c.Err = errors.New("exec: no command")</code></span>
<span class="codeline" id="line-636"><code>	}</code></span>
<span class="codeline" id="line-637"><code>	if c.Err != nil || c.lookPathErr != nil {</code></span>
<span class="codeline" id="line-638"><code>		if c.lookPathErr != nil {</code></span>
<span class="codeline" id="line-639"><code>			return c.lookPathErr</code></span>
<span class="codeline" id="line-640"><code>		}</code></span>
<span class="codeline" id="line-641"><code>		return c.Err</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code>	lp := c.Path</code></span>
<span class="codeline" id="line-644"><code>	if runtime.GOOS == "windows" &amp;&amp; !filepath.IsAbs(c.Path) {</code></span>
<span class="codeline" id="line-645"><code>		// If c.Path is relative, we had to wait until now</code></span>
<span class="codeline" id="line-646"><code>		// to resolve it in case c.Dir was changed.</code></span>
<span class="codeline" id="line-647"><code>		// (If it is absolute, we already resolved its extension in Command</code></span>
<span class="codeline" id="line-648"><code>		// and shouldn't need to do so again.)</code></span>
<span class="codeline" id="line-649"><code>		//</code></span>
<span class="codeline" id="line-650"><code>		// Unfortunately, we cannot write the result back to c.Path because programs</code></span>
<span class="codeline" id="line-651"><code>		// may assume that they can call Start concurrently with reading the path.</code></span>
<span class="codeline" id="line-652"><code>		// (It is safe and non-racy to do so on Unix platforms, and users might not</code></span>
<span class="codeline" id="line-653"><code>		// test with the race detector on all platforms;</code></span>
<span class="codeline" id="line-654"><code>		// see https://go.dev/issue/62596.)</code></span>
<span class="codeline" id="line-655"><code>		//</code></span>
<span class="codeline" id="line-656"><code>		// So we will pass the fully resolved path to os.StartProcess, but leave</code></span>
<span class="codeline" id="line-657"><code>		// c.Path as is: missing a bit of logging information seems less harmful</code></span>
<span class="codeline" id="line-658"><code>		// than triggering a surprising data race, and if the user really cares</code></span>
<span class="codeline" id="line-659"><code>		// about that bit of logging they can always use LookPath to resolve it.</code></span>
<span class="codeline" id="line-660"><code>		var err error</code></span>
<span class="codeline" id="line-661"><code>		lp, err = lookExtensions(c.Path, c.Dir)</code></span>
<span class="codeline" id="line-662"><code>		if err != nil {</code></span>
<span class="codeline" id="line-663"><code>			return err</code></span>
<span class="codeline" id="line-664"><code>		}</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>	if c.Cancel != nil &amp;&amp; c.ctx == nil {</code></span>
<span class="codeline" id="line-667"><code>		return errors.New("exec: command with a non-nil Cancel was not created with CommandContext")</code></span>
<span class="codeline" id="line-668"><code>	}</code></span>
<span class="codeline" id="line-669"><code>	if c.ctx != nil {</code></span>
<span class="codeline" id="line-670"><code>		select {</code></span>
<span class="codeline" id="line-671"><code>		case &lt;-c.ctx.Done():</code></span>
<span class="codeline" id="line-672"><code>			return c.ctx.Err()</code></span>
<span class="codeline" id="line-673"><code>		default:</code></span>
<span class="codeline" id="line-674"><code>		}</code></span>
<span class="codeline" id="line-675"><code>	}</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>	childFiles := make([]*os.File, 0, 3+len(c.ExtraFiles))</code></span>
<span class="codeline" id="line-678"><code>	stdin, err := c.childStdin()</code></span>
<span class="codeline" id="line-679"><code>	if err != nil {</code></span>
<span class="codeline" id="line-680"><code>		return err</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code>	childFiles = append(childFiles, stdin)</code></span>
<span class="codeline" id="line-683"><code>	stdout, err := c.childStdout()</code></span>
<span class="codeline" id="line-684"><code>	if err != nil {</code></span>
<span class="codeline" id="line-685"><code>		return err</code></span>
<span class="codeline" id="line-686"><code>	}</code></span>
<span class="codeline" id="line-687"><code>	childFiles = append(childFiles, stdout)</code></span>
<span class="codeline" id="line-688"><code>	stderr, err := c.childStderr(stdout)</code></span>
<span class="codeline" id="line-689"><code>	if err != nil {</code></span>
<span class="codeline" id="line-690"><code>		return err</code></span>
<span class="codeline" id="line-691"><code>	}</code></span>
<span class="codeline" id="line-692"><code>	childFiles = append(childFiles, stderr)</code></span>
<span class="codeline" id="line-693"><code>	childFiles = append(childFiles, c.ExtraFiles...)</code></span>
<span class="codeline" id="line-694"><code></code></span>
<span class="codeline" id="line-695"><code>	env, err := c.environ()</code></span>
<span class="codeline" id="line-696"><code>	if err != nil {</code></span>
<span class="codeline" id="line-697"><code>		return err</code></span>
<span class="codeline" id="line-698"><code>	}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>	c.Process, err = os.StartProcess(lp, c.argv(), &amp;os.ProcAttr{</code></span>
<span class="codeline" id="line-701"><code>		Dir:   c.Dir,</code></span>
<span class="codeline" id="line-702"><code>		Files: childFiles,</code></span>
<span class="codeline" id="line-703"><code>		Env:   env,</code></span>
<span class="codeline" id="line-704"><code>		Sys:   c.SysProcAttr,</code></span>
<span class="codeline" id="line-705"><code>	})</code></span>
<span class="codeline" id="line-706"><code>	if err != nil {</code></span>
<span class="codeline" id="line-707"><code>		return err</code></span>
<span class="codeline" id="line-708"><code>	}</code></span>
<span class="codeline" id="line-709"><code>	started = true</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>	// Don't allocate the goroutineErr channel unless there are goroutines to start.</code></span>
<span class="codeline" id="line-712"><code>	if len(c.goroutine) &gt; 0 {</code></span>
<span class="codeline" id="line-713"><code>		goroutineErr := make(chan error, 1)</code></span>
<span class="codeline" id="line-714"><code>		c.goroutineErr = goroutineErr</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>		type goroutineStatus struct {</code></span>
<span class="codeline" id="line-717"><code>			running  int</code></span>
<span class="codeline" id="line-718"><code>			firstErr error</code></span>
<span class="codeline" id="line-719"><code>		}</code></span>
<span class="codeline" id="line-720"><code>		statusc := make(chan goroutineStatus, 1)</code></span>
<span class="codeline" id="line-721"><code>		statusc &lt;- goroutineStatus{running: len(c.goroutine)}</code></span>
<span class="codeline" id="line-722"><code>		for _, fn := range c.goroutine {</code></span>
<span class="codeline" id="line-723"><code>			go func(fn func() error) {</code></span>
<span class="codeline" id="line-724"><code>				err := fn()</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>				status := &lt;-statusc</code></span>
<span class="codeline" id="line-727"><code>				if status.firstErr == nil {</code></span>
<span class="codeline" id="line-728"><code>					status.firstErr = err</code></span>
<span class="codeline" id="line-729"><code>				}</code></span>
<span class="codeline" id="line-730"><code>				status.running--</code></span>
<span class="codeline" id="line-731"><code>				if status.running == 0 {</code></span>
<span class="codeline" id="line-732"><code>					goroutineErr &lt;- status.firstErr</code></span>
<span class="codeline" id="line-733"><code>				} else {</code></span>
<span class="codeline" id="line-734"><code>					statusc &lt;- status</code></span>
<span class="codeline" id="line-735"><code>				}</code></span>
<span class="codeline" id="line-736"><code>			}(fn)</code></span>
<span class="codeline" id="line-737"><code>		}</code></span>
<span class="codeline" id="line-738"><code>		c.goroutine = nil // Allow the goroutines' closures to be GC'd when they complete.</code></span>
<span class="codeline" id="line-739"><code>	}</code></span>
<span class="codeline" id="line-740"><code></code></span>
<span class="codeline" id="line-741"><code>	// If we have anything to do when the command's Context expires,</code></span>
<span class="codeline" id="line-742"><code>	// start a goroutine to watch for cancellation.</code></span>
<span class="codeline" id="line-743"><code>	//</code></span>
<span class="codeline" id="line-744"><code>	// (Even if the command was created by CommandContext, a helper library may</code></span>
<span class="codeline" id="line-745"><code>	// have explicitly set its Cancel field back to nil, indicating that it should</code></span>
<span class="codeline" id="line-746"><code>	// be allowed to continue running after cancellation after all.)</code></span>
<span class="codeline" id="line-747"><code>	if (c.Cancel != nil || c.WaitDelay != 0) &amp;&amp; c.ctx != nil &amp;&amp; c.ctx.Done() != nil {</code></span>
<span class="codeline" id="line-748"><code>		resultc := make(chan ctxResult)</code></span>
<span class="codeline" id="line-749"><code>		c.ctxResult = resultc</code></span>
<span class="codeline" id="line-750"><code>		go c.watchCtx(resultc)</code></span>
<span class="codeline" id="line-751"><code>	}</code></span>
<span class="codeline" id="line-752"><code></code></span>
<span class="codeline" id="line-753"><code>	return nil</code></span>
<span class="codeline" id="line-754"><code>}</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>// watchCtx watches c.ctx until it is able to send a result to resultc.</code></span>
<span class="codeline" id="line-757"><code>//</code></span>
<span class="codeline" id="line-758"><code>// If c.ctx is done before a result can be sent, watchCtx calls c.Cancel,</code></span>
<span class="codeline" id="line-759"><code>// and/or kills cmd.Process it after c.WaitDelay has elapsed.</code></span>
<span class="codeline" id="line-760"><code>//</code></span>
<span class="codeline" id="line-761"><code>// watchCtx manipulates c.goroutineErr, so its result must be received before</code></span>
<span class="codeline" id="line-762"><code>// c.awaitGoroutines is called.</code></span>
<span class="codeline" id="line-763"><code>func (c *Cmd) watchCtx(resultc chan&lt;- ctxResult) {</code></span>
<span class="codeline" id="line-764"><code>	select {</code></span>
<span class="codeline" id="line-765"><code>	case resultc &lt;- ctxResult{}:</code></span>
<span class="codeline" id="line-766"><code>		return</code></span>
<span class="codeline" id="line-767"><code>	case &lt;-c.ctx.Done():</code></span>
<span class="codeline" id="line-768"><code>	}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	var err error</code></span>
<span class="codeline" id="line-771"><code>	if c.Cancel != nil {</code></span>
<span class="codeline" id="line-772"><code>		if interruptErr := c.Cancel(); interruptErr == nil {</code></span>
<span class="codeline" id="line-773"><code>			// We appear to have successfully interrupted the command, so any</code></span>
<span class="codeline" id="line-774"><code>			// program behavior from this point may be due to ctx even if the</code></span>
<span class="codeline" id="line-775"><code>			// command exits with code 0.</code></span>
<span class="codeline" id="line-776"><code>			err = c.ctx.Err()</code></span>
<span class="codeline" id="line-777"><code>		} else if errors.Is(interruptErr, os.ErrProcessDone) {</code></span>
<span class="codeline" id="line-778"><code>			// The process already finished: we just didn't notice it yet.</code></span>
<span class="codeline" id="line-779"><code>			// (Perhaps c.Wait hadn't been called, or perhaps it happened to race with</code></span>
<span class="codeline" id="line-780"><code>			// c.ctx being cancelled.) Don't inject a needless error.</code></span>
<span class="codeline" id="line-781"><code>		} else {</code></span>
<span class="codeline" id="line-782"><code>			err = wrappedError{</code></span>
<span class="codeline" id="line-783"><code>				prefix: "exec: canceling Cmd",</code></span>
<span class="codeline" id="line-784"><code>				err:    interruptErr,</code></span>
<span class="codeline" id="line-785"><code>			}</code></span>
<span class="codeline" id="line-786"><code>		}</code></span>
<span class="codeline" id="line-787"><code>	}</code></span>
<span class="codeline" id="line-788"><code>	if c.WaitDelay == 0 {</code></span>
<span class="codeline" id="line-789"><code>		resultc &lt;- ctxResult{err: err}</code></span>
<span class="codeline" id="line-790"><code>		return</code></span>
<span class="codeline" id="line-791"><code>	}</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>	timer := time.NewTimer(c.WaitDelay)</code></span>
<span class="codeline" id="line-794"><code>	select {</code></span>
<span class="codeline" id="line-795"><code>	case resultc &lt;- ctxResult{err: err, timer: timer}:</code></span>
<span class="codeline" id="line-796"><code>		// c.Process.Wait returned and we've handed the timer off to c.Wait.</code></span>
<span class="codeline" id="line-797"><code>		// It will take care of goroutine shutdown from here.</code></span>
<span class="codeline" id="line-798"><code>		return</code></span>
<span class="codeline" id="line-799"><code>	case &lt;-timer.C:</code></span>
<span class="codeline" id="line-800"><code>	}</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>	killed := false</code></span>
<span class="codeline" id="line-803"><code>	if killErr := c.Process.Kill(); killErr == nil {</code></span>
<span class="codeline" id="line-804"><code>		// We appear to have killed the process. c.Process.Wait should return a</code></span>
<span class="codeline" id="line-805"><code>		// non-nil error to c.Wait unless the Kill signal races with a successful</code></span>
<span class="codeline" id="line-806"><code>		// exit, and if that does happen we shouldn't report a spurious error,</code></span>
<span class="codeline" id="line-807"><code>		// so don't set err to anything here.</code></span>
<span class="codeline" id="line-808"><code>		killed = true</code></span>
<span class="codeline" id="line-809"><code>	} else if !errors.Is(killErr, os.ErrProcessDone) {</code></span>
<span class="codeline" id="line-810"><code>		err = wrappedError{</code></span>
<span class="codeline" id="line-811"><code>			prefix: "exec: killing Cmd",</code></span>
<span class="codeline" id="line-812"><code>			err:    killErr,</code></span>
<span class="codeline" id="line-813"><code>		}</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>	if c.goroutineErr != nil {</code></span>
<span class="codeline" id="line-817"><code>		select {</code></span>
<span class="codeline" id="line-818"><code>		case goroutineErr := &lt;-c.goroutineErr:</code></span>
<span class="codeline" id="line-819"><code>			// Forward goroutineErr only if we don't have reason to believe it was</code></span>
<span class="codeline" id="line-820"><code>			// caused by a call to Cancel or Kill above.</code></span>
<span class="codeline" id="line-821"><code>			if err == nil &amp;&amp; !killed {</code></span>
<span class="codeline" id="line-822"><code>				err = goroutineErr</code></span>
<span class="codeline" id="line-823"><code>			}</code></span>
<span class="codeline" id="line-824"><code>		default:</code></span>
<span class="codeline" id="line-825"><code>			// Close the child process's I/O pipes, in case it abandoned some</code></span>
<span class="codeline" id="line-826"><code>			// subprocess that inherited them and is still holding them open</code></span>
<span class="codeline" id="line-827"><code>			// (see https://go.dev/issue/23019).</code></span>
<span class="codeline" id="line-828"><code>			//</code></span>
<span class="codeline" id="line-829"><code>			// We close the goroutine pipes only after we have sent any signals we're</code></span>
<span class="codeline" id="line-830"><code>			// going to send to the process (via Signal or Kill above): if we send</code></span>
<span class="codeline" id="line-831"><code>			// SIGKILL to the process, we would prefer for it to die of SIGKILL, not</code></span>
<span class="codeline" id="line-832"><code>			// SIGPIPE. (However, this may still cause any orphaned subprocesses to</code></span>
<span class="codeline" id="line-833"><code>			// terminate with SIGPIPE.)</code></span>
<span class="codeline" id="line-834"><code>			closeDescriptors(c.parentIOPipes)</code></span>
<span class="codeline" id="line-835"><code>			// Wait for the copying goroutines to finish, but report ErrWaitDelay for</code></span>
<span class="codeline" id="line-836"><code>			// the error: any other error here could result from closing the pipes.</code></span>
<span class="codeline" id="line-837"><code>			_ = &lt;-c.goroutineErr</code></span>
<span class="codeline" id="line-838"><code>			if err == nil {</code></span>
<span class="codeline" id="line-839"><code>				err = ErrWaitDelay</code></span>
<span class="codeline" id="line-840"><code>			}</code></span>
<span class="codeline" id="line-841"><code>		}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>		// Since we have already received the only result from c.goroutineErr,</code></span>
<span class="codeline" id="line-844"><code>		// set it to nil to prevent awaitGoroutines from blocking on it.</code></span>
<span class="codeline" id="line-845"><code>		c.goroutineErr = nil</code></span>
<span class="codeline" id="line-846"><code>	}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>	resultc &lt;- ctxResult{err: err}</code></span>
<span class="codeline" id="line-849"><code>}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>// An ExitError reports an unsuccessful exit by a command.</code></span>
<span class="codeline" id="line-852"><code>type ExitError struct {</code></span>
<span class="codeline" id="line-853"><code>	*os.ProcessState</code></span>
<span class="codeline" id="line-854"><code></code></span>
<span class="codeline" id="line-855"><code>	// Stderr holds a subset of the standard error output from the</code></span>
<span class="codeline" id="line-856"><code>	// Cmd.Output method if standard error was not otherwise being</code></span>
<span class="codeline" id="line-857"><code>	// collected.</code></span>
<span class="codeline" id="line-858"><code>	//</code></span>
<span class="codeline" id="line-859"><code>	// If the error output is long, Stderr may contain only a prefix</code></span>
<span class="codeline" id="line-860"><code>	// and suffix of the output, with the middle replaced with</code></span>
<span class="codeline" id="line-861"><code>	// text about the number of omitted bytes.</code></span>
<span class="codeline" id="line-862"><code>	//</code></span>
<span class="codeline" id="line-863"><code>	// Stderr is provided for debugging, for inclusion in error messages.</code></span>
<span class="codeline" id="line-864"><code>	// Users with other needs should redirect Cmd.Stderr as needed.</code></span>
<span class="codeline" id="line-865"><code>	Stderr []byte</code></span>
<span class="codeline" id="line-866"><code>}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>func (e *ExitError) Error() string {</code></span>
<span class="codeline" id="line-869"><code>	return e.ProcessState.String()</code></span>
<span class="codeline" id="line-870"><code>}</code></span>
<span class="codeline" id="line-871"><code></code></span>
<span class="codeline" id="line-872"><code>// Wait waits for the command to exit and waits for any copying to</code></span>
<span class="codeline" id="line-873"><code>// stdin or copying from stdout or stderr to complete.</code></span>
<span class="codeline" id="line-874"><code>//</code></span>
<span class="codeline" id="line-875"><code>// The command must have been started by Start.</code></span>
<span class="codeline" id="line-876"><code>//</code></span>
<span class="codeline" id="line-877"><code>// The returned error is nil if the command runs, has no problems</code></span>
<span class="codeline" id="line-878"><code>// copying stdin, stdout, and stderr, and exits with a zero exit</code></span>
<span class="codeline" id="line-879"><code>// status.</code></span>
<span class="codeline" id="line-880"><code>//</code></span>
<span class="codeline" id="line-881"><code>// If the command fails to run or doesn't complete successfully, the</code></span>
<span class="codeline" id="line-882"><code>// error is of type *ExitError. Other error types may be</code></span>
<span class="codeline" id="line-883"><code>// returned for I/O problems.</code></span>
<span class="codeline" id="line-884"><code>//</code></span>
<span class="codeline" id="line-885"><code>// If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits</code></span>
<span class="codeline" id="line-886"><code>// for the respective I/O loop copying to or from the process to complete.</code></span>
<span class="codeline" id="line-887"><code>//</code></span>
<span class="codeline" id="line-888"><code>// Wait releases any resources associated with the Cmd.</code></span>
<span class="codeline" id="line-889"><code>func (c *Cmd) Wait() error {</code></span>
<span class="codeline" id="line-890"><code>	if c.Process == nil {</code></span>
<span class="codeline" id="line-891"><code>		return errors.New("exec: not started")</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code>	if c.ProcessState != nil {</code></span>
<span class="codeline" id="line-894"><code>		return errors.New("exec: Wait was already called")</code></span>
<span class="codeline" id="line-895"><code>	}</code></span>
<span class="codeline" id="line-896"><code></code></span>
<span class="codeline" id="line-897"><code>	state, err := c.Process.Wait()</code></span>
<span class="codeline" id="line-898"><code>	if err == nil &amp;&amp; !state.Success() {</code></span>
<span class="codeline" id="line-899"><code>		err = &amp;ExitError{ProcessState: state}</code></span>
<span class="codeline" id="line-900"><code>	}</code></span>
<span class="codeline" id="line-901"><code>	c.ProcessState = state</code></span>
<span class="codeline" id="line-902"><code></code></span>
<span class="codeline" id="line-903"><code>	var timer *time.Timer</code></span>
<span class="codeline" id="line-904"><code>	if c.ctxResult != nil {</code></span>
<span class="codeline" id="line-905"><code>		watch := &lt;-c.ctxResult</code></span>
<span class="codeline" id="line-906"><code>		timer = watch.timer</code></span>
<span class="codeline" id="line-907"><code>		// If c.Process.Wait returned an error, prefer that.</code></span>
<span class="codeline" id="line-908"><code>		// Otherwise, report any error from the watchCtx goroutine,</code></span>
<span class="codeline" id="line-909"><code>		// such as a Context cancellation or a WaitDelay overrun.</code></span>
<span class="codeline" id="line-910"><code>		if err == nil &amp;&amp; watch.err != nil {</code></span>
<span class="codeline" id="line-911"><code>			err = watch.err</code></span>
<span class="codeline" id="line-912"><code>		}</code></span>
<span class="codeline" id="line-913"><code>	}</code></span>
<span class="codeline" id="line-914"><code></code></span>
<span class="codeline" id="line-915"><code>	if goroutineErr := c.awaitGoroutines(timer); err == nil {</code></span>
<span class="codeline" id="line-916"><code>		// Report an error from the copying goroutines only if the program otherwise</code></span>
<span class="codeline" id="line-917"><code>		// exited normally on its own. Otherwise, the copying error may be due to the</code></span>
<span class="codeline" id="line-918"><code>		// abnormal termination.</code></span>
<span class="codeline" id="line-919"><code>		err = goroutineErr</code></span>
<span class="codeline" id="line-920"><code>	}</code></span>
<span class="codeline" id="line-921"><code>	closeDescriptors(c.parentIOPipes)</code></span>
<span class="codeline" id="line-922"><code>	c.parentIOPipes = nil</code></span>
<span class="codeline" id="line-923"><code></code></span>
<span class="codeline" id="line-924"><code>	return err</code></span>
<span class="codeline" id="line-925"><code>}</code></span>
<span class="codeline" id="line-926"><code></code></span>
<span class="codeline" id="line-927"><code>// awaitGoroutines waits for the results of the goroutines copying data to or</code></span>
<span class="codeline" id="line-928"><code>// from the command's I/O pipes.</code></span>
<span class="codeline" id="line-929"><code>//</code></span>
<span class="codeline" id="line-930"><code>// If c.WaitDelay elapses before the goroutines complete, awaitGoroutines</code></span>
<span class="codeline" id="line-931"><code>// forcibly closes their pipes and returns ErrWaitDelay.</code></span>
<span class="codeline" id="line-932"><code>//</code></span>
<span class="codeline" id="line-933"><code>// If timer is non-nil, it must send to timer.C at the end of c.WaitDelay.</code></span>
<span class="codeline" id="line-934"><code>func (c *Cmd) awaitGoroutines(timer *time.Timer) error {</code></span>
<span class="codeline" id="line-935"><code>	defer func() {</code></span>
<span class="codeline" id="line-936"><code>		if timer != nil {</code></span>
<span class="codeline" id="line-937"><code>			timer.Stop()</code></span>
<span class="codeline" id="line-938"><code>		}</code></span>
<span class="codeline" id="line-939"><code>		c.goroutineErr = nil</code></span>
<span class="codeline" id="line-940"><code>	}()</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>	if c.goroutineErr == nil {</code></span>
<span class="codeline" id="line-943"><code>		return nil // No running goroutines to await.</code></span>
<span class="codeline" id="line-944"><code>	}</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>	if timer == nil {</code></span>
<span class="codeline" id="line-947"><code>		if c.WaitDelay == 0 {</code></span>
<span class="codeline" id="line-948"><code>			return &lt;-c.goroutineErr</code></span>
<span class="codeline" id="line-949"><code>		}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>		select {</code></span>
<span class="codeline" id="line-952"><code>		case err := &lt;-c.goroutineErr:</code></span>
<span class="codeline" id="line-953"><code>			// Avoid the overhead of starting a timer.</code></span>
<span class="codeline" id="line-954"><code>			return err</code></span>
<span class="codeline" id="line-955"><code>		default:</code></span>
<span class="codeline" id="line-956"><code>		}</code></span>
<span class="codeline" id="line-957"><code></code></span>
<span class="codeline" id="line-958"><code>		// No existing timer was started: either there is no Context associated with</code></span>
<span class="codeline" id="line-959"><code>		// the command, or c.Process.Wait completed before the Context was done.</code></span>
<span class="codeline" id="line-960"><code>		timer = time.NewTimer(c.WaitDelay)</code></span>
<span class="codeline" id="line-961"><code>	}</code></span>
<span class="codeline" id="line-962"><code></code></span>
<span class="codeline" id="line-963"><code>	select {</code></span>
<span class="codeline" id="line-964"><code>	case &lt;-timer.C:</code></span>
<span class="codeline" id="line-965"><code>		closeDescriptors(c.parentIOPipes)</code></span>
<span class="codeline" id="line-966"><code>		// Wait for the copying goroutines to finish, but ignore any error</code></span>
<span class="codeline" id="line-967"><code>		// (since it was probably caused by closing the pipes).</code></span>
<span class="codeline" id="line-968"><code>		_ = &lt;-c.goroutineErr</code></span>
<span class="codeline" id="line-969"><code>		return ErrWaitDelay</code></span>
<span class="codeline" id="line-970"><code></code></span>
<span class="codeline" id="line-971"><code>	case err := &lt;-c.goroutineErr:</code></span>
<span class="codeline" id="line-972"><code>		return err</code></span>
<span class="codeline" id="line-973"><code>	}</code></span>
<span class="codeline" id="line-974"><code>}</code></span>
<span class="codeline" id="line-975"><code></code></span>
<span class="codeline" id="line-976"><code>// Output runs the command and returns its standard output.</code></span>
<span class="codeline" id="line-977"><code>// Any returned error will usually be of type *ExitError.</code></span>
<span class="codeline" id="line-978"><code>// If c.Stderr was nil, Output populates ExitError.Stderr.</code></span>
<span class="codeline" id="line-979"><code>func (c *Cmd) Output() ([]byte, error) {</code></span>
<span class="codeline" id="line-980"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-981"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>	var stdout bytes.Buffer</code></span>
<span class="codeline" id="line-984"><code>	c.Stdout = &amp;stdout</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>	captureErr := c.Stderr == nil</code></span>
<span class="codeline" id="line-987"><code>	if captureErr {</code></span>
<span class="codeline" id="line-988"><code>		c.Stderr = &amp;prefixSuffixSaver{N: 32 &lt;&lt; 10}</code></span>
<span class="codeline" id="line-989"><code>	}</code></span>
<span class="codeline" id="line-990"><code></code></span>
<span class="codeline" id="line-991"><code>	err := c.Run()</code></span>
<span class="codeline" id="line-992"><code>	if err != nil &amp;&amp; captureErr {</code></span>
<span class="codeline" id="line-993"><code>		if ee, ok := err.(*ExitError); ok {</code></span>
<span class="codeline" id="line-994"><code>			ee.Stderr = c.Stderr.(*prefixSuffixSaver).Bytes()</code></span>
<span class="codeline" id="line-995"><code>		}</code></span>
<span class="codeline" id="line-996"><code>	}</code></span>
<span class="codeline" id="line-997"><code>	return stdout.Bytes(), err</code></span>
<span class="codeline" id="line-998"><code>}</code></span>
<span class="codeline" id="line-999"><code></code></span>
<span class="codeline" id="line-1000"><code>// CombinedOutput runs the command and returns its combined standard</code></span>
<span class="codeline" id="line-1001"><code>// output and standard error.</code></span>
<span class="codeline" id="line-1002"><code>func (c *Cmd) CombinedOutput() ([]byte, error) {</code></span>
<span class="codeline" id="line-1003"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-1004"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-1005"><code>	}</code></span>
<span class="codeline" id="line-1006"><code>	if c.Stderr != nil {</code></span>
<span class="codeline" id="line-1007"><code>		return nil, errors.New("exec: Stderr already set")</code></span>
<span class="codeline" id="line-1008"><code>	}</code></span>
<span class="codeline" id="line-1009"><code>	var b bytes.Buffer</code></span>
<span class="codeline" id="line-1010"><code>	c.Stdout = &amp;b</code></span>
<span class="codeline" id="line-1011"><code>	c.Stderr = &amp;b</code></span>
<span class="codeline" id="line-1012"><code>	err := c.Run()</code></span>
<span class="codeline" id="line-1013"><code>	return b.Bytes(), err</code></span>
<span class="codeline" id="line-1014"><code>}</code></span>
<span class="codeline" id="line-1015"><code></code></span>
<span class="codeline" id="line-1016"><code>// StdinPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-1017"><code>// standard input when the command starts.</code></span>
<span class="codeline" id="line-1018"><code>// The pipe will be closed automatically after Wait sees the command exit.</code></span>
<span class="codeline" id="line-1019"><code>// A caller need only call Close to force the pipe to close sooner.</code></span>
<span class="codeline" id="line-1020"><code>// For example, if the command being run will not exit until standard input</code></span>
<span class="codeline" id="line-1021"><code>// is closed, the caller must close the pipe.</code></span>
<span class="codeline" id="line-1022"><code>func (c *Cmd) StdinPipe() (io.WriteCloser, error) {</code></span>
<span class="codeline" id="line-1023"><code>	if c.Stdin != nil {</code></span>
<span class="codeline" id="line-1024"><code>		return nil, errors.New("exec: Stdin already set")</code></span>
<span class="codeline" id="line-1025"><code>	}</code></span>
<span class="codeline" id="line-1026"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-1027"><code>		return nil, errors.New("exec: StdinPipe after process started")</code></span>
<span class="codeline" id="line-1028"><code>	}</code></span>
<span class="codeline" id="line-1029"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-1030"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1031"><code>		return nil, err</code></span>
<span class="codeline" id="line-1032"><code>	}</code></span>
<span class="codeline" id="line-1033"><code>	c.Stdin = pr</code></span>
<span class="codeline" id="line-1034"><code>	c.childIOFiles = append(c.childIOFiles, pr)</code></span>
<span class="codeline" id="line-1035"><code>	c.parentIOPipes = append(c.parentIOPipes, pw)</code></span>
<span class="codeline" id="line-1036"><code>	return pw, nil</code></span>
<span class="codeline" id="line-1037"><code>}</code></span>
<span class="codeline" id="line-1038"><code></code></span>
<span class="codeline" id="line-1039"><code>// StdoutPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-1040"><code>// standard output when the command starts.</code></span>
<span class="codeline" id="line-1041"><code>//</code></span>
<span class="codeline" id="line-1042"><code>// Wait will close the pipe after seeing the command exit, so most callers</code></span>
<span class="codeline" id="line-1043"><code>// need not close the pipe themselves. It is thus incorrect to call Wait</code></span>
<span class="codeline" id="line-1044"><code>// before all reads from the pipe have completed.</code></span>
<span class="codeline" id="line-1045"><code>// For the same reason, it is incorrect to call Run when using StdoutPipe.</code></span>
<span class="codeline" id="line-1046"><code>// See the example for idiomatic usage.</code></span>
<span class="codeline" id="line-1047"><code>func (c *Cmd) StdoutPipe() (io.ReadCloser, error) {</code></span>
<span class="codeline" id="line-1048"><code>	if c.Stdout != nil {</code></span>
<span class="codeline" id="line-1049"><code>		return nil, errors.New("exec: Stdout already set")</code></span>
<span class="codeline" id="line-1050"><code>	}</code></span>
<span class="codeline" id="line-1051"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-1052"><code>		return nil, errors.New("exec: StdoutPipe after process started")</code></span>
<span class="codeline" id="line-1053"><code>	}</code></span>
<span class="codeline" id="line-1054"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-1055"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1056"><code>		return nil, err</code></span>
<span class="codeline" id="line-1057"><code>	}</code></span>
<span class="codeline" id="line-1058"><code>	c.Stdout = pw</code></span>
<span class="codeline" id="line-1059"><code>	c.childIOFiles = append(c.childIOFiles, pw)</code></span>
<span class="codeline" id="line-1060"><code>	c.parentIOPipes = append(c.parentIOPipes, pr)</code></span>
<span class="codeline" id="line-1061"><code>	return pr, nil</code></span>
<span class="codeline" id="line-1062"><code>}</code></span>
<span class="codeline" id="line-1063"><code></code></span>
<span class="codeline" id="line-1064"><code>// StderrPipe returns a pipe that will be connected to the command's</code></span>
<span class="codeline" id="line-1065"><code>// standard error when the command starts.</code></span>
<span class="codeline" id="line-1066"><code>//</code></span>
<span class="codeline" id="line-1067"><code>// Wait will close the pipe after seeing the command exit, so most callers</code></span>
<span class="codeline" id="line-1068"><code>// need not close the pipe themselves. It is thus incorrect to call Wait</code></span>
<span class="codeline" id="line-1069"><code>// before all reads from the pipe have completed.</code></span>
<span class="codeline" id="line-1070"><code>// For the same reason, it is incorrect to use Run when using StderrPipe.</code></span>
<span class="codeline" id="line-1071"><code>// See the StdoutPipe example for idiomatic usage.</code></span>
<span class="codeline" id="line-1072"><code>func (c *Cmd) StderrPipe() (io.ReadCloser, error) {</code></span>
<span class="codeline" id="line-1073"><code>	if c.Stderr != nil {</code></span>
<span class="codeline" id="line-1074"><code>		return nil, errors.New("exec: Stderr already set")</code></span>
<span class="codeline" id="line-1075"><code>	}</code></span>
<span class="codeline" id="line-1076"><code>	if c.Process != nil {</code></span>
<span class="codeline" id="line-1077"><code>		return nil, errors.New("exec: StderrPipe after process started")</code></span>
<span class="codeline" id="line-1078"><code>	}</code></span>
<span class="codeline" id="line-1079"><code>	pr, pw, err := os.Pipe()</code></span>
<span class="codeline" id="line-1080"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1081"><code>		return nil, err</code></span>
<span class="codeline" id="line-1082"><code>	}</code></span>
<span class="codeline" id="line-1083"><code>	c.Stderr = pw</code></span>
<span class="codeline" id="line-1084"><code>	c.childIOFiles = append(c.childIOFiles, pw)</code></span>
<span class="codeline" id="line-1085"><code>	c.parentIOPipes = append(c.parentIOPipes, pr)</code></span>
<span class="codeline" id="line-1086"><code>	return pr, nil</code></span>
<span class="codeline" id="line-1087"><code>}</code></span>
<span class="codeline" id="line-1088"><code></code></span>
<span class="codeline" id="line-1089"><code>// prefixSuffixSaver is an io.Writer which retains the first N bytes</code></span>
<span class="codeline" id="line-1090"><code>// and the last N bytes written to it. The Bytes() methods reconstructs</code></span>
<span class="codeline" id="line-1091"><code>// it with a pretty error message.</code></span>
<span class="codeline" id="line-1092"><code>type prefixSuffixSaver struct {</code></span>
<span class="codeline" id="line-1093"><code>	N         int // max size of prefix or suffix</code></span>
<span class="codeline" id="line-1094"><code>	prefix    []byte</code></span>
<span class="codeline" id="line-1095"><code>	suffix    []byte // ring buffer once len(suffix) == N</code></span>
<span class="codeline" id="line-1096"><code>	suffixOff int    // offset to write into suffix</code></span>
<span class="codeline" id="line-1097"><code>	skipped   int64</code></span>
<span class="codeline" id="line-1098"><code></code></span>
<span class="codeline" id="line-1099"><code>	// TODO(bradfitz): we could keep one large []byte and use part of it for</code></span>
<span class="codeline" id="line-1100"><code>	// the prefix, reserve space for the '... Omitting N bytes ...' message,</code></span>
<span class="codeline" id="line-1101"><code>	// then the ring buffer suffix, and just rearrange the ring buffer</code></span>
<span class="codeline" id="line-1102"><code>	// suffix when Bytes() is called, but it doesn't seem worth it for</code></span>
<span class="codeline" id="line-1103"><code>	// now just for error messages. It's only ~64KB anyway.</code></span>
<span class="codeline" id="line-1104"><code>}</code></span>
<span class="codeline" id="line-1105"><code></code></span>
<span class="codeline" id="line-1106"><code>func (w *prefixSuffixSaver) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-1107"><code>	lenp := len(p)</code></span>
<span class="codeline" id="line-1108"><code>	p = w.fill(&amp;w.prefix, p)</code></span>
<span class="codeline" id="line-1109"><code></code></span>
<span class="codeline" id="line-1110"><code>	// Only keep the last w.N bytes of suffix data.</code></span>
<span class="codeline" id="line-1111"><code>	if overage := len(p) - w.N; overage &gt; 0 {</code></span>
<span class="codeline" id="line-1112"><code>		p = p[overage:]</code></span>
<span class="codeline" id="line-1113"><code>		w.skipped += int64(overage)</code></span>
<span class="codeline" id="line-1114"><code>	}</code></span>
<span class="codeline" id="line-1115"><code>	p = w.fill(&amp;w.suffix, p)</code></span>
<span class="codeline" id="line-1116"><code></code></span>
<span class="codeline" id="line-1117"><code>	// w.suffix is full now if p is non-empty. Overwrite it in a circle.</code></span>
<span class="codeline" id="line-1118"><code>	for len(p) &gt; 0 { // 0, 1, or 2 iterations.</code></span>
<span class="codeline" id="line-1119"><code>		n := copy(w.suffix[w.suffixOff:], p)</code></span>
<span class="codeline" id="line-1120"><code>		p = p[n:]</code></span>
<span class="codeline" id="line-1121"><code>		w.skipped += int64(n)</code></span>
<span class="codeline" id="line-1122"><code>		w.suffixOff += n</code></span>
<span class="codeline" id="line-1123"><code>		if w.suffixOff == w.N {</code></span>
<span class="codeline" id="line-1124"><code>			w.suffixOff = 0</code></span>
<span class="codeline" id="line-1125"><code>		}</code></span>
<span class="codeline" id="line-1126"><code>	}</code></span>
<span class="codeline" id="line-1127"><code>	return lenp, nil</code></span>
<span class="codeline" id="line-1128"><code>}</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>// fill appends up to len(p) bytes of p to *dst, such that *dst does not</code></span>
<span class="codeline" id="line-1131"><code>// grow larger than w.N. It returns the un-appended suffix of p.</code></span>
<span class="codeline" id="line-1132"><code>func (w *prefixSuffixSaver) fill(dst *[]byte, p []byte) (pRemain []byte) {</code></span>
<span class="codeline" id="line-1133"><code>	if remain := w.N - len(*dst); remain &gt; 0 {</code></span>
<span class="codeline" id="line-1134"><code>		add := min(len(p), remain)</code></span>
<span class="codeline" id="line-1135"><code>		*dst = append(*dst, p[:add]...)</code></span>
<span class="codeline" id="line-1136"><code>		p = p[add:]</code></span>
<span class="codeline" id="line-1137"><code>	}</code></span>
<span class="codeline" id="line-1138"><code>	return p</code></span>
<span class="codeline" id="line-1139"><code>}</code></span>
<span class="codeline" id="line-1140"><code></code></span>
<span class="codeline" id="line-1141"><code>func (w *prefixSuffixSaver) Bytes() []byte {</code></span>
<span class="codeline" id="line-1142"><code>	if w.suffix == nil {</code></span>
<span class="codeline" id="line-1143"><code>		return w.prefix</code></span>
<span class="codeline" id="line-1144"><code>	}</code></span>
<span class="codeline" id="line-1145"><code>	if w.skipped == 0 {</code></span>
<span class="codeline" id="line-1146"><code>		return append(w.prefix, w.suffix...)</code></span>
<span class="codeline" id="line-1147"><code>	}</code></span>
<span class="codeline" id="line-1148"><code>	var buf bytes.Buffer</code></span>
<span class="codeline" id="line-1149"><code>	buf.Grow(len(w.prefix) + len(w.suffix) + 50)</code></span>
<span class="codeline" id="line-1150"><code>	buf.Write(w.prefix)</code></span>
<span class="codeline" id="line-1151"><code>	buf.WriteString("\n... omitting ")</code></span>
<span class="codeline" id="line-1152"><code>	buf.WriteString(strconv.FormatInt(w.skipped, 10))</code></span>
<span class="codeline" id="line-1153"><code>	buf.WriteString(" bytes ...\n")</code></span>
<span class="codeline" id="line-1154"><code>	buf.Write(w.suffix[w.suffixOff:])</code></span>
<span class="codeline" id="line-1155"><code>	buf.Write(w.suffix[:w.suffixOff])</code></span>
<span class="codeline" id="line-1156"><code>	return buf.Bytes()</code></span>
<span class="codeline" id="line-1157"><code>}</code></span>
<span class="codeline" id="line-1158"><code></code></span>
<span class="codeline" id="line-1159"><code>// environ returns a best-effort copy of the environment in which the command</code></span>
<span class="codeline" id="line-1160"><code>// would be run as it is currently configured. If an error occurs in computing</code></span>
<span class="codeline" id="line-1161"><code>// the environment, it is returned alongside the best-effort copy.</code></span>
<span class="codeline" id="line-1162"><code>func (c *Cmd) environ() ([]string, error) {</code></span>
<span class="codeline" id="line-1163"><code>	var err error</code></span>
<span class="codeline" id="line-1164"><code></code></span>
<span class="codeline" id="line-1165"><code>	env := c.Env</code></span>
<span class="codeline" id="line-1166"><code>	if env == nil {</code></span>
<span class="codeline" id="line-1167"><code>		env, err = execenv.Default(c.SysProcAttr)</code></span>
<span class="codeline" id="line-1168"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1169"><code>			env = os.Environ()</code></span>
<span class="codeline" id="line-1170"><code>			// Note that the non-nil err is preserved despite env being overridden.</code></span>
<span class="codeline" id="line-1171"><code>		}</code></span>
<span class="codeline" id="line-1172"><code></code></span>
<span class="codeline" id="line-1173"><code>		if c.Dir != "" {</code></span>
<span class="codeline" id="line-1174"><code>			switch runtime.GOOS {</code></span>
<span class="codeline" id="line-1175"><code>			case "windows", "plan9":</code></span>
<span class="codeline" id="line-1176"><code>				// Windows and Plan 9 do not use the PWD variable, so we don't need to</code></span>
<span class="codeline" id="line-1177"><code>				// keep it accurate.</code></span>
<span class="codeline" id="line-1178"><code>			default:</code></span>
<span class="codeline" id="line-1179"><code>				// On POSIX platforms, PWD represents “an absolute pathname of the</code></span>
<span class="codeline" id="line-1180"><code>				// current working directory.” Since we are changing the working</code></span>
<span class="codeline" id="line-1181"><code>				// directory for the command, we should also update PWD to reflect that.</code></span>
<span class="codeline" id="line-1182"><code>				//</code></span>
<span class="codeline" id="line-1183"><code>				// Unfortunately, we didn't always do that, so (as proposed in</code></span>
<span class="codeline" id="line-1184"><code>				// https://go.dev/issue/50599) to avoid unintended collateral damage we</code></span>
<span class="codeline" id="line-1185"><code>				// only implicitly update PWD when Env is nil. That way, we're much</code></span>
<span class="codeline" id="line-1186"><code>				// less likely to override an intentional change to the variable.</code></span>
<span class="codeline" id="line-1187"><code>				if pwd, absErr := filepath.Abs(c.Dir); absErr == nil {</code></span>
<span class="codeline" id="line-1188"><code>					env = append(env, "PWD="+pwd)</code></span>
<span class="codeline" id="line-1189"><code>				} else if err == nil {</code></span>
<span class="codeline" id="line-1190"><code>					err = absErr</code></span>
<span class="codeline" id="line-1191"><code>				}</code></span>
<span class="codeline" id="line-1192"><code>			}</code></span>
<span class="codeline" id="line-1193"><code>		}</code></span>
<span class="codeline" id="line-1194"><code>	}</code></span>
<span class="codeline" id="line-1195"><code></code></span>
<span class="codeline" id="line-1196"><code>	env, dedupErr := dedupEnv(env)</code></span>
<span class="codeline" id="line-1197"><code>	if err == nil {</code></span>
<span class="codeline" id="line-1198"><code>		err = dedupErr</code></span>
<span class="codeline" id="line-1199"><code>	}</code></span>
<span class="codeline" id="line-1200"><code>	return addCriticalEnv(env), err</code></span>
<span class="codeline" id="line-1201"><code>}</code></span>
<span class="codeline" id="line-1202"><code></code></span>
<span class="codeline" id="line-1203"><code>// Environ returns a copy of the environment in which the command would be run</code></span>
<span class="codeline" id="line-1204"><code>// as it is currently configured.</code></span>
<span class="codeline" id="line-1205"><code>func (c *Cmd) Environ() []string {</code></span>
<span class="codeline" id="line-1206"><code>	//  Intentionally ignore errors: environ returns a best-effort environment no matter what.</code></span>
<span class="codeline" id="line-1207"><code>	env, _ := c.environ()</code></span>
<span class="codeline" id="line-1208"><code>	return env</code></span>
<span class="codeline" id="line-1209"><code>}</code></span>
<span class="codeline" id="line-1210"><code></code></span>
<span class="codeline" id="line-1211"><code>// dedupEnv returns a copy of env with any duplicates removed, in favor of</code></span>
<span class="codeline" id="line-1212"><code>// later values.</code></span>
<span class="codeline" id="line-1213"><code>// Items not of the normal environment "key=value" form are preserved unchanged.</code></span>
<span class="codeline" id="line-1214"><code>// Except on Plan 9, items containing NUL characters are removed, and</code></span>
<span class="codeline" id="line-1215"><code>// an error is returned along with the remaining values.</code></span>
<span class="codeline" id="line-1216"><code>func dedupEnv(env []string) ([]string, error) {</code></span>
<span class="codeline" id="line-1217"><code>	return dedupEnvCase(runtime.GOOS == "windows", runtime.GOOS == "plan9", env)</code></span>
<span class="codeline" id="line-1218"><code>}</code></span>
<span class="codeline" id="line-1219"><code></code></span>
<span class="codeline" id="line-1220"><code>// dedupEnvCase is dedupEnv with a case option for testing.</code></span>
<span class="codeline" id="line-1221"><code>// If caseInsensitive is true, the case of keys is ignored.</code></span>
<span class="codeline" id="line-1222"><code>// If nulOK is false, items containing NUL characters are allowed.</code></span>
<span class="codeline" id="line-1223"><code>func dedupEnvCase(caseInsensitive, nulOK bool, env []string) ([]string, error) {</code></span>
<span class="codeline" id="line-1224"><code>	// Construct the output in reverse order, to preserve the</code></span>
<span class="codeline" id="line-1225"><code>	// last occurrence of each key.</code></span>
<span class="codeline" id="line-1226"><code>	var err error</code></span>
<span class="codeline" id="line-1227"><code>	out := make([]string, 0, len(env))</code></span>
<span class="codeline" id="line-1228"><code>	saw := make(map[string]bool, len(env))</code></span>
<span class="codeline" id="line-1229"><code>	for n := len(env); n &gt; 0; n-- {</code></span>
<span class="codeline" id="line-1230"><code>		kv := env[n-1]</code></span>
<span class="codeline" id="line-1231"><code></code></span>
<span class="codeline" id="line-1232"><code>		// Reject NUL in environment variables to prevent security issues (#56284);</code></span>
<span class="codeline" id="line-1233"><code>		// except on Plan 9, which uses NUL as os.PathListSeparator (#56544).</code></span>
<span class="codeline" id="line-1234"><code>		if !nulOK &amp;&amp; strings.IndexByte(kv, 0) != -1 {</code></span>
<span class="codeline" id="line-1235"><code>			err = errors.New("exec: environment variable contains NUL")</code></span>
<span class="codeline" id="line-1236"><code>			continue</code></span>
<span class="codeline" id="line-1237"><code>		}</code></span>
<span class="codeline" id="line-1238"><code></code></span>
<span class="codeline" id="line-1239"><code>		i := strings.Index(kv, "=")</code></span>
<span class="codeline" id="line-1240"><code>		if i == 0 {</code></span>
<span class="codeline" id="line-1241"><code>			// We observe in practice keys with a single leading "=" on Windows.</code></span>
<span class="codeline" id="line-1242"><code>			// TODO(#49886): Should we consume only the first leading "=" as part</code></span>
<span class="codeline" id="line-1243"><code>			// of the key, or parse through arbitrarily many of them until a non-"="?</code></span>
<span class="codeline" id="line-1244"><code>			i = strings.Index(kv[1:], "=") + 1</code></span>
<span class="codeline" id="line-1245"><code>		}</code></span>
<span class="codeline" id="line-1246"><code>		if i &lt; 0 {</code></span>
<span class="codeline" id="line-1247"><code>			if kv != "" {</code></span>
<span class="codeline" id="line-1248"><code>				// The entry is not of the form "key=value" (as it is required to be).</code></span>
<span class="codeline" id="line-1249"><code>				// Leave it as-is for now.</code></span>
<span class="codeline" id="line-1250"><code>				// TODO(#52436): should we strip or reject these bogus entries?</code></span>
<span class="codeline" id="line-1251"><code>				out = append(out, kv)</code></span>
<span class="codeline" id="line-1252"><code>			}</code></span>
<span class="codeline" id="line-1253"><code>			continue</code></span>
<span class="codeline" id="line-1254"><code>		}</code></span>
<span class="codeline" id="line-1255"><code>		k := kv[:i]</code></span>
<span class="codeline" id="line-1256"><code>		if caseInsensitive {</code></span>
<span class="codeline" id="line-1257"><code>			k = strings.ToLower(k)</code></span>
<span class="codeline" id="line-1258"><code>		}</code></span>
<span class="codeline" id="line-1259"><code>		if saw[k] {</code></span>
<span class="codeline" id="line-1260"><code>			continue</code></span>
<span class="codeline" id="line-1261"><code>		}</code></span>
<span class="codeline" id="line-1262"><code></code></span>
<span class="codeline" id="line-1263"><code>		saw[k] = true</code></span>
<span class="codeline" id="line-1264"><code>		out = append(out, kv)</code></span>
<span class="codeline" id="line-1265"><code>	}</code></span>
<span class="codeline" id="line-1266"><code></code></span>
<span class="codeline" id="line-1267"><code>	// Now reverse the slice to restore the original order.</code></span>
<span class="codeline" id="line-1268"><code>	for i := 0; i &lt; len(out)/2; i++ {</code></span>
<span class="codeline" id="line-1269"><code>		j := len(out) - i - 1</code></span>
<span class="codeline" id="line-1270"><code>		out[i], out[j] = out[j], out[i]</code></span>
<span class="codeline" id="line-1271"><code>	}</code></span>
<span class="codeline" id="line-1272"><code></code></span>
<span class="codeline" id="line-1273"><code>	return out, err</code></span>
<span class="codeline" id="line-1274"><code>}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>// addCriticalEnv adds any critical environment variables that are required</code></span>
<span class="codeline" id="line-1277"><code>// (or at least almost always required) on the operating system.</code></span>
<span class="codeline" id="line-1278"><code>// Currently this is only used for Windows.</code></span>
<span class="codeline" id="line-1279"><code>func addCriticalEnv(env []string) []string {</code></span>
<span class="codeline" id="line-1280"><code>	if runtime.GOOS != "windows" {</code></span>
<span class="codeline" id="line-1281"><code>		return env</code></span>
<span class="codeline" id="line-1282"><code>	}</code></span>
<span class="codeline" id="line-1283"><code>	for _, kv := range env {</code></span>
<span class="codeline" id="line-1284"><code>		k, _, ok := strings.Cut(kv, "=")</code></span>
<span class="codeline" id="line-1285"><code>		if !ok {</code></span>
<span class="codeline" id="line-1286"><code>			continue</code></span>
<span class="codeline" id="line-1287"><code>		}</code></span>
<span class="codeline" id="line-1288"><code>		if strings.EqualFold(k, "SYSTEMROOT") {</code></span>
<span class="codeline" id="line-1289"><code>			// We already have it.</code></span>
<span class="codeline" id="line-1290"><code>			return env</code></span>
<span class="codeline" id="line-1291"><code>		}</code></span>
<span class="codeline" id="line-1292"><code>	}</code></span>
<span class="codeline" id="line-1293"><code>	return append(env, "SYSTEMROOT="+os.Getenv("SYSTEMROOT"))</code></span>
<span class="codeline" id="line-1294"><code>}</code></span>
<span class="codeline" id="line-1295"><code></code></span>
<span class="codeline" id="line-1296"><code>// ErrDot indicates that a path lookup resolved to an executable</code></span>
<span class="codeline" id="line-1297"><code>// in the current directory due to ‘.’ being in the path, either</code></span>
<span class="codeline" id="line-1298"><code>// implicitly or explicitly. See the package documentation for details.</code></span>
<span class="codeline" id="line-1299"><code>//</code></span>
<span class="codeline" id="line-1300"><code>// Note that functions in this package do not return ErrDot directly.</code></span>
<span class="codeline" id="line-1301"><code>// Code should use errors.Is(err, ErrDot), not err == ErrDot,</code></span>
<span class="codeline" id="line-1302"><code>// to test whether a returned error err is due to this condition.</code></span>
<span class="codeline" id="line-1303"><code>var ErrDot = errors.New("cannot run executable found relative to current directory")</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>