<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: regexp.go in package regexp</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	regexp.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/regexp.html">regexp</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package regexp implements regular expression search.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// The syntax of the regular expressions accepted is the same</code></span>
<span class="codeline" id="line-8"><code>// general syntax used by Perl, Python, and other languages.</code></span>
<span class="codeline" id="line-9"><code>// More precisely, it is the syntax accepted by RE2 and described at</code></span>
<span class="codeline" id="line-10"><code>// https://golang.org/s/re2syntax, except for \C.</code></span>
<span class="codeline" id="line-11"><code>// For an overview of the syntax, see the [regexp/syntax] package.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>// The regexp implementation provided by this package is</code></span>
<span class="codeline" id="line-14"><code>// guaranteed to run in time linear in the size of the input.</code></span>
<span class="codeline" id="line-15"><code>// (This is a property not guaranteed by most open source</code></span>
<span class="codeline" id="line-16"><code>// implementations of regular expressions.) For more information</code></span>
<span class="codeline" id="line-17"><code>// about this property, see</code></span>
<span class="codeline" id="line-18"><code>//</code></span>
<span class="codeline" id="line-19"><code>//	https://swtch.com/~rsc/regexp/regexp1.html</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>// or any book about automata theory.</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>// All characters are UTF-8-encoded code points.</code></span>
<span class="codeline" id="line-24"><code>// Following [utf8.DecodeRune], each byte of an invalid UTF-8 sequence</code></span>
<span class="codeline" id="line-25"><code>// is treated as if it encoded utf8.RuneError (U+FFFD).</code></span>
<span class="codeline" id="line-26"><code>//</code></span>
<span class="codeline" id="line-27"><code>// There are 16 methods of [Regexp] that match a regular expression and identify</code></span>
<span class="codeline" id="line-28"><code>// the matched text. Their names are matched by this regular expression:</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>//	Find(All)?(String)?(Submatch)?(Index)?</code></span>
<span class="codeline" id="line-31"><code>//</code></span>
<span class="codeline" id="line-32"><code>// If 'All' is present, the routine matches successive non-overlapping</code></span>
<span class="codeline" id="line-33"><code>// matches of the entire expression. Empty matches abutting a preceding</code></span>
<span class="codeline" id="line-34"><code>// match are ignored. The return value is a slice containing the successive</code></span>
<span class="codeline" id="line-35"><code>// return values of the corresponding non-'All' routine. These routines take</code></span>
<span class="codeline" id="line-36"><code>// an extra integer argument, n. If n &gt;= 0, the function returns at most n</code></span>
<span class="codeline" id="line-37"><code>// matches/submatches; otherwise, it returns all of them.</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>// If 'String' is present, the argument is a string; otherwise it is a slice</code></span>
<span class="codeline" id="line-40"><code>// of bytes; return values are adjusted as appropriate.</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// If 'Submatch' is present, the return value is a slice identifying the</code></span>
<span class="codeline" id="line-43"><code>// successive submatches of the expression. Submatches are matches of</code></span>
<span class="codeline" id="line-44"><code>// parenthesized subexpressions (also known as capturing groups) within the</code></span>
<span class="codeline" id="line-45"><code>// regular expression, numbered from left to right in order of opening</code></span>
<span class="codeline" id="line-46"><code>// parenthesis. Submatch 0 is the match of the entire expression, submatch 1 is</code></span>
<span class="codeline" id="line-47"><code>// the match of the first parenthesized subexpression, and so on.</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// If 'Index' is present, matches and submatches are identified by byte index</code></span>
<span class="codeline" id="line-50"><code>// pairs within the input string: result[2*n:2*n+2] identifies the indexes of</code></span>
<span class="codeline" id="line-51"><code>// the nth submatch. The pair for n==0 identifies the match of the entire</code></span>
<span class="codeline" id="line-52"><code>// expression. If 'Index' is not present, the match is identified by the text</code></span>
<span class="codeline" id="line-53"><code>// of the match/submatch. If an index is negative or text is nil, it means that</code></span>
<span class="codeline" id="line-54"><code>// subexpression did not match any string in the input. For 'String' versions</code></span>
<span class="codeline" id="line-55"><code>// an empty string means either no match or an empty match.</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>// There is also a subset of the methods that can be applied to text read</code></span>
<span class="codeline" id="line-58"><code>// from a RuneReader:</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>//	MatchReader, FindReaderIndex, FindReaderSubmatchIndex</code></span>
<span class="codeline" id="line-61"><code>//</code></span>
<span class="codeline" id="line-62"><code>// This set may grow. Note that regular expression matches may need to</code></span>
<span class="codeline" id="line-63"><code>// examine text beyond the text returned by a match, so the methods that</code></span>
<span class="codeline" id="line-64"><code>// match text from a RuneReader may read arbitrarily far into the input</code></span>
<span class="codeline" id="line-65"><code>// before returning.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// (There are a few other methods that do not match this pattern.)</code></span></div><span class="codeline" id="line-68"><code>package regexp</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>import (</code></span>
<span class="codeline" id="line-71"><code>	"bytes"</code></span>
<span class="codeline" id="line-72"><code>	"io"</code></span>
<span class="codeline" id="line-73"><code>	"regexp/syntax"</code></span>
<span class="codeline" id="line-74"><code>	"strconv"</code></span>
<span class="codeline" id="line-75"><code>	"strings"</code></span>
<span class="codeline" id="line-76"><code>	"sync"</code></span>
<span class="codeline" id="line-77"><code>	"unicode"</code></span>
<span class="codeline" id="line-78"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-79"><code>)</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>// Regexp is the representation of a compiled regular expression.</code></span>
<span class="codeline" id="line-82"><code>// A Regexp is safe for concurrent use by multiple goroutines,</code></span>
<span class="codeline" id="line-83"><code>// except for configuration methods, such as [Regexp.Longest].</code></span>
<span class="codeline" id="line-84"><code>type Regexp struct {</code></span>
<span class="codeline" id="line-85"><code>	expr           string       // as passed to Compile</code></span>
<span class="codeline" id="line-86"><code>	prog           *syntax.Prog // compiled program</code></span>
<span class="codeline" id="line-87"><code>	onepass        *onePassProg // onepass program or nil</code></span>
<span class="codeline" id="line-88"><code>	numSubexp      int</code></span>
<span class="codeline" id="line-89"><code>	maxBitStateLen int</code></span>
<span class="codeline" id="line-90"><code>	subexpNames    []string</code></span>
<span class="codeline" id="line-91"><code>	prefix         string         // required prefix in unanchored matches</code></span>
<span class="codeline" id="line-92"><code>	prefixBytes    []byte         // prefix, as a []byte</code></span>
<span class="codeline" id="line-93"><code>	prefixRune     rune           // first rune in prefix</code></span>
<span class="codeline" id="line-94"><code>	prefixEnd      uint32         // pc for last rune in prefix</code></span>
<span class="codeline" id="line-95"><code>	mpool          int            // pool for machines</code></span>
<span class="codeline" id="line-96"><code>	matchcap       int            // size of recorded match lengths</code></span>
<span class="codeline" id="line-97"><code>	prefixComplete bool           // prefix is the entire regexp</code></span>
<span class="codeline" id="line-98"><code>	cond           syntax.EmptyOp // empty-width conditions required at start of match</code></span>
<span class="codeline" id="line-99"><code>	minInputLen    int            // minimum length of the input in bytes</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>	// This field can be modified by the Longest method,</code></span>
<span class="codeline" id="line-102"><code>	// but it is otherwise read-only.</code></span>
<span class="codeline" id="line-103"><code>	longest bool // whether regexp prefers leftmost-longest match</code></span>
<span class="codeline" id="line-104"><code>}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>// String returns the source text used to compile the regular expression.</code></span>
<span class="codeline" id="line-107"><code>func (re *Regexp) String() string {</code></span>
<span class="codeline" id="line-108"><code>	return re.expr</code></span>
<span class="codeline" id="line-109"><code>}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>// Copy returns a new [Regexp] object copied from re.</code></span>
<span class="codeline" id="line-112"><code>// Calling [Regexp.Longest] on one copy does not affect another.</code></span>
<span class="codeline" id="line-113"><code>//</code></span>
<span class="codeline" id="line-114"><code>// Deprecated: In earlier releases, when using a [Regexp] in multiple goroutines,</code></span>
<span class="codeline" id="line-115"><code>// giving each goroutine its own copy helped to avoid lock contention.</code></span>
<span class="codeline" id="line-116"><code>// As of Go 1.12, using Copy is no longer necessary to avoid lock contention.</code></span>
<span class="codeline" id="line-117"><code>// Copy may still be appropriate if the reason for its use is to make</code></span>
<span class="codeline" id="line-118"><code>// two copies with different [Regexp.Longest] settings.</code></span>
<span class="codeline" id="line-119"><code>func (re *Regexp) Copy() *Regexp {</code></span>
<span class="codeline" id="line-120"><code>	re2 := *re</code></span>
<span class="codeline" id="line-121"><code>	return &amp;re2</code></span>
<span class="codeline" id="line-122"><code>}</code></span>
<span class="codeline" id="line-123"><code></code></span>
<span class="codeline" id="line-124"><code>// Compile parses a regular expression and returns, if successful,</code></span>
<span class="codeline" id="line-125"><code>// a [Regexp] object that can be used to match against text.</code></span>
<span class="codeline" id="line-126"><code>//</code></span>
<span class="codeline" id="line-127"><code>// When matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-128"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-129"><code>// it chooses the one that a backtracking search would have found first.</code></span>
<span class="codeline" id="line-130"><code>// This so-called leftmost-first matching is the same semantics</code></span>
<span class="codeline" id="line-131"><code>// that Perl, Python, and other implementations use, although this</code></span>
<span class="codeline" id="line-132"><code>// package implements it without the expense of backtracking.</code></span>
<span class="codeline" id="line-133"><code>// For POSIX leftmost-longest matching, see [CompilePOSIX].</code></span>
<span class="codeline" id="line-134"><code>func Compile(expr string) (*Regexp, error) {</code></span>
<span class="codeline" id="line-135"><code>	return compile(expr, syntax.Perl, false)</code></span>
<span class="codeline" id="line-136"><code>}</code></span>
<span class="codeline" id="line-137"><code></code></span>
<span class="codeline" id="line-138"><code>// CompilePOSIX is like [Compile] but restricts the regular expression</code></span>
<span class="codeline" id="line-139"><code>// to POSIX ERE (egrep) syntax and changes the match semantics to</code></span>
<span class="codeline" id="line-140"><code>// leftmost-longest.</code></span>
<span class="codeline" id="line-141"><code>//</code></span>
<span class="codeline" id="line-142"><code>// That is, when matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-143"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-144"><code>// it chooses a match that is as long as possible.</code></span>
<span class="codeline" id="line-145"><code>// This so-called leftmost-longest matching is the same semantics</code></span>
<span class="codeline" id="line-146"><code>// that early regular expression implementations used and that POSIX</code></span>
<span class="codeline" id="line-147"><code>// specifies.</code></span>
<span class="codeline" id="line-148"><code>//</code></span>
<span class="codeline" id="line-149"><code>// However, there can be multiple leftmost-longest matches, with different</code></span>
<span class="codeline" id="line-150"><code>// submatch choices, and here this package diverges from POSIX.</code></span>
<span class="codeline" id="line-151"><code>// Among the possible leftmost-longest matches, this package chooses</code></span>
<span class="codeline" id="line-152"><code>// the one that a backtracking search would have found first, while POSIX</code></span>
<span class="codeline" id="line-153"><code>// specifies that the match be chosen to maximize the length of the first</code></span>
<span class="codeline" id="line-154"><code>// subexpression, then the second, and so on from left to right.</code></span>
<span class="codeline" id="line-155"><code>// The POSIX rule is computationally prohibitive and not even well-defined.</code></span>
<span class="codeline" id="line-156"><code>// See https://swtch.com/~rsc/regexp/regexp2.html#posix for details.</code></span>
<span class="codeline" id="line-157"><code>func CompilePOSIX(expr string) (*Regexp, error) {</code></span>
<span class="codeline" id="line-158"><code>	return compile(expr, syntax.POSIX, true)</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>// Longest makes future searches prefer the leftmost-longest match.</code></span>
<span class="codeline" id="line-162"><code>// That is, when matching against text, the regexp returns a match that</code></span>
<span class="codeline" id="line-163"><code>// begins as early as possible in the input (leftmost), and among those</code></span>
<span class="codeline" id="line-164"><code>// it chooses a match that is as long as possible.</code></span>
<span class="codeline" id="line-165"><code>// This method modifies the [Regexp] and may not be called concurrently</code></span>
<span class="codeline" id="line-166"><code>// with any other methods.</code></span>
<span class="codeline" id="line-167"><code>func (re *Regexp) Longest() {</code></span>
<span class="codeline" id="line-168"><code>	re.longest = true</code></span>
<span class="codeline" id="line-169"><code>}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error) {</code></span>
<span class="codeline" id="line-172"><code>	re, err := syntax.Parse(expr, mode)</code></span>
<span class="codeline" id="line-173"><code>	if err != nil {</code></span>
<span class="codeline" id="line-174"><code>		return nil, err</code></span>
<span class="codeline" id="line-175"><code>	}</code></span>
<span class="codeline" id="line-176"><code>	maxCap := re.MaxCap()</code></span>
<span class="codeline" id="line-177"><code>	capNames := re.CapNames()</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>	re = re.Simplify()</code></span>
<span class="codeline" id="line-180"><code>	prog, err := syntax.Compile(re)</code></span>
<span class="codeline" id="line-181"><code>	if err != nil {</code></span>
<span class="codeline" id="line-182"><code>		return nil, err</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code>	matchcap := prog.NumCap</code></span>
<span class="codeline" id="line-185"><code>	if matchcap &lt; 2 {</code></span>
<span class="codeline" id="line-186"><code>		matchcap = 2</code></span>
<span class="codeline" id="line-187"><code>	}</code></span>
<span class="codeline" id="line-188"><code>	regexp := &amp;Regexp{</code></span>
<span class="codeline" id="line-189"><code>		expr:        expr,</code></span>
<span class="codeline" id="line-190"><code>		prog:        prog,</code></span>
<span class="codeline" id="line-191"><code>		onepass:     compileOnePass(prog),</code></span>
<span class="codeline" id="line-192"><code>		numSubexp:   maxCap,</code></span>
<span class="codeline" id="line-193"><code>		subexpNames: capNames,</code></span>
<span class="codeline" id="line-194"><code>		cond:        prog.StartCond(),</code></span>
<span class="codeline" id="line-195"><code>		longest:     longest,</code></span>
<span class="codeline" id="line-196"><code>		matchcap:    matchcap,</code></span>
<span class="codeline" id="line-197"><code>		minInputLen: minInputLen(re),</code></span>
<span class="codeline" id="line-198"><code>	}</code></span>
<span class="codeline" id="line-199"><code>	if regexp.onepass == nil {</code></span>
<span class="codeline" id="line-200"><code>		regexp.prefix, regexp.prefixComplete = prog.Prefix()</code></span>
<span class="codeline" id="line-201"><code>		regexp.maxBitStateLen = maxBitStateLen(prog)</code></span>
<span class="codeline" id="line-202"><code>	} else {</code></span>
<span class="codeline" id="line-203"><code>		regexp.prefix, regexp.prefixComplete, regexp.prefixEnd = onePassPrefix(prog)</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	if regexp.prefix != "" {</code></span>
<span class="codeline" id="line-206"><code>		// TODO(rsc): Remove this allocation by adding</code></span>
<span class="codeline" id="line-207"><code>		// IndexString to package bytes.</code></span>
<span class="codeline" id="line-208"><code>		regexp.prefixBytes = []byte(regexp.prefix)</code></span>
<span class="codeline" id="line-209"><code>		regexp.prefixRune, _ = utf8.DecodeRuneInString(regexp.prefix)</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	n := len(prog.Inst)</code></span>
<span class="codeline" id="line-213"><code>	i := 0</code></span>
<span class="codeline" id="line-214"><code>	for matchSize[i] != 0 &amp;&amp; matchSize[i] &lt; n {</code></span>
<span class="codeline" id="line-215"><code>		i++</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code>	regexp.mpool = i</code></span>
<span class="codeline" id="line-218"><code></code></span>
<span class="codeline" id="line-219"><code>	return regexp, nil</code></span>
<span class="codeline" id="line-220"><code>}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>// Pools of *machine for use during (*Regexp).doExecute,</code></span>
<span class="codeline" id="line-223"><code>// split up by the size of the execution queues.</code></span>
<span class="codeline" id="line-224"><code>// matchPool[i] machines have queue size matchSize[i].</code></span>
<span class="codeline" id="line-225"><code>// On a 64-bit system each queue entry is 16 bytes,</code></span>
<span class="codeline" id="line-226"><code>// so matchPool[0] has 16*2*128 = 4kB queues, etc.</code></span>
<span class="codeline" id="line-227"><code>// The final matchPool is a catch-all for very large queues.</code></span>
<span class="codeline" id="line-228"><code>var (</code></span>
<span class="codeline" id="line-229"><code>	matchSize = [...]int{128, 512, 2048, 16384, 0}</code></span>
<span class="codeline" id="line-230"><code>	matchPool [len(matchSize)]sync.Pool</code></span>
<span class="codeline" id="line-231"><code>)</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// get returns a machine to use for matching re.</code></span>
<span class="codeline" id="line-234"><code>// It uses the re's machine cache if possible, to avoid</code></span>
<span class="codeline" id="line-235"><code>// unnecessary allocation.</code></span>
<span class="codeline" id="line-236"><code>func (re *Regexp) get() *machine {</code></span>
<span class="codeline" id="line-237"><code>	m, ok := matchPool[re.mpool].Get().(*machine)</code></span>
<span class="codeline" id="line-238"><code>	if !ok {</code></span>
<span class="codeline" id="line-239"><code>		m = new(machine)</code></span>
<span class="codeline" id="line-240"><code>	}</code></span>
<span class="codeline" id="line-241"><code>	m.re = re</code></span>
<span class="codeline" id="line-242"><code>	m.p = re.prog</code></span>
<span class="codeline" id="line-243"><code>	if cap(m.matchcap) &lt; re.matchcap {</code></span>
<span class="codeline" id="line-244"><code>		m.matchcap = make([]int, re.matchcap)</code></span>
<span class="codeline" id="line-245"><code>		for _, t := range m.pool {</code></span>
<span class="codeline" id="line-246"><code>			t.cap = make([]int, re.matchcap)</code></span>
<span class="codeline" id="line-247"><code>		}</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	// Allocate queues if needed.</code></span>
<span class="codeline" id="line-251"><code>	// Or reallocate, for "large" match pool.</code></span>
<span class="codeline" id="line-252"><code>	n := matchSize[re.mpool]</code></span>
<span class="codeline" id="line-253"><code>	if n == 0 { // large pool</code></span>
<span class="codeline" id="line-254"><code>		n = len(re.prog.Inst)</code></span>
<span class="codeline" id="line-255"><code>	}</code></span>
<span class="codeline" id="line-256"><code>	if len(m.q0.sparse) &lt; n {</code></span>
<span class="codeline" id="line-257"><code>		m.q0 = queue{make([]uint32, n), make([]entry, 0, n)}</code></span>
<span class="codeline" id="line-258"><code>		m.q1 = queue{make([]uint32, n), make([]entry, 0, n)}</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code>	return m</code></span>
<span class="codeline" id="line-261"><code>}</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>// put returns a machine to the correct machine pool.</code></span>
<span class="codeline" id="line-264"><code>func (re *Regexp) put(m *machine) {</code></span>
<span class="codeline" id="line-265"><code>	m.re = nil</code></span>
<span class="codeline" id="line-266"><code>	m.p = nil</code></span>
<span class="codeline" id="line-267"><code>	m.inputs.clear()</code></span>
<span class="codeline" id="line-268"><code>	matchPool[re.mpool].Put(m)</code></span>
<span class="codeline" id="line-269"><code>}</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>// minInputLen walks the regexp to find the minimum length of any matchable input.</code></span>
<span class="codeline" id="line-272"><code>func minInputLen(re *syntax.Regexp) int {</code></span>
<span class="codeline" id="line-273"><code>	switch re.Op {</code></span>
<span class="codeline" id="line-274"><code>	default:</code></span>
<span class="codeline" id="line-275"><code>		return 0</code></span>
<span class="codeline" id="line-276"><code>	case syntax.OpAnyChar, syntax.OpAnyCharNotNL, syntax.OpCharClass:</code></span>
<span class="codeline" id="line-277"><code>		return 1</code></span>
<span class="codeline" id="line-278"><code>	case syntax.OpLiteral:</code></span>
<span class="codeline" id="line-279"><code>		l := 0</code></span>
<span class="codeline" id="line-280"><code>		for _, r := range re.Rune {</code></span>
<span class="codeline" id="line-281"><code>			if r == utf8.RuneError {</code></span>
<span class="codeline" id="line-282"><code>				l++</code></span>
<span class="codeline" id="line-283"><code>			} else {</code></span>
<span class="codeline" id="line-284"><code>				l += utf8.RuneLen(r)</code></span>
<span class="codeline" id="line-285"><code>			}</code></span>
<span class="codeline" id="line-286"><code>		}</code></span>
<span class="codeline" id="line-287"><code>		return l</code></span>
<span class="codeline" id="line-288"><code>	case syntax.OpCapture, syntax.OpPlus:</code></span>
<span class="codeline" id="line-289"><code>		return minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-290"><code>	case syntax.OpRepeat:</code></span>
<span class="codeline" id="line-291"><code>		return re.Min * minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-292"><code>	case syntax.OpConcat:</code></span>
<span class="codeline" id="line-293"><code>		l := 0</code></span>
<span class="codeline" id="line-294"><code>		for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-295"><code>			l += minInputLen(sub)</code></span>
<span class="codeline" id="line-296"><code>		}</code></span>
<span class="codeline" id="line-297"><code>		return l</code></span>
<span class="codeline" id="line-298"><code>	case syntax.OpAlternate:</code></span>
<span class="codeline" id="line-299"><code>		l := minInputLen(re.Sub[0])</code></span>
<span class="codeline" id="line-300"><code>		var lnext int</code></span>
<span class="codeline" id="line-301"><code>		for _, sub := range re.Sub[1:] {</code></span>
<span class="codeline" id="line-302"><code>			lnext = minInputLen(sub)</code></span>
<span class="codeline" id="line-303"><code>			if lnext &lt; l {</code></span>
<span class="codeline" id="line-304"><code>				l = lnext</code></span>
<span class="codeline" id="line-305"><code>			}</code></span>
<span class="codeline" id="line-306"><code>		}</code></span>
<span class="codeline" id="line-307"><code>		return l</code></span>
<span class="codeline" id="line-308"><code>	}</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>// MustCompile is like [Compile] but panics if the expression cannot be parsed.</code></span>
<span class="codeline" id="line-312"><code>// It simplifies safe initialization of global variables holding compiled regular</code></span>
<span class="codeline" id="line-313"><code>// expressions.</code></span>
<span class="codeline" id="line-314"><code>func MustCompile(str string) *Regexp {</code></span>
<span class="codeline" id="line-315"><code>	regexp, err := Compile(str)</code></span>
<span class="codeline" id="line-316"><code>	if err != nil {</code></span>
<span class="codeline" id="line-317"><code>		panic(`regexp: Compile(` + quote(str) + `): ` + err.Error())</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	return regexp</code></span>
<span class="codeline" id="line-320"><code>}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>// MustCompilePOSIX is like [CompilePOSIX] but panics if the expression cannot be parsed.</code></span>
<span class="codeline" id="line-323"><code>// It simplifies safe initialization of global variables holding compiled regular</code></span>
<span class="codeline" id="line-324"><code>// expressions.</code></span>
<span class="codeline" id="line-325"><code>func MustCompilePOSIX(str string) *Regexp {</code></span>
<span class="codeline" id="line-326"><code>	regexp, err := CompilePOSIX(str)</code></span>
<span class="codeline" id="line-327"><code>	if err != nil {</code></span>
<span class="codeline" id="line-328"><code>		panic(`regexp: CompilePOSIX(` + quote(str) + `): ` + err.Error())</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	return regexp</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>func quote(s string) string {</code></span>
<span class="codeline" id="line-334"><code>	if strconv.CanBackquote(s) {</code></span>
<span class="codeline" id="line-335"><code>		return "`" + s + "`"</code></span>
<span class="codeline" id="line-336"><code>	}</code></span>
<span class="codeline" id="line-337"><code>	return strconv.Quote(s)</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// NumSubexp returns the number of parenthesized subexpressions in this [Regexp].</code></span>
<span class="codeline" id="line-341"><code>func (re *Regexp) NumSubexp() int {</code></span>
<span class="codeline" id="line-342"><code>	return re.numSubexp</code></span>
<span class="codeline" id="line-343"><code>}</code></span>
<span class="codeline" id="line-344"><code></code></span>
<span class="codeline" id="line-345"><code>// SubexpNames returns the names of the parenthesized subexpressions</code></span>
<span class="codeline" id="line-346"><code>// in this [Regexp]. The name for the first sub-expression is names[1],</code></span>
<span class="codeline" id="line-347"><code>// so that if m is a match slice, the name for m[i] is SubexpNames()[i].</code></span>
<span class="codeline" id="line-348"><code>// Since the Regexp as a whole cannot be named, names[0] is always</code></span>
<span class="codeline" id="line-349"><code>// the empty string. The slice should not be modified.</code></span>
<span class="codeline" id="line-350"><code>func (re *Regexp) SubexpNames() []string {</code></span>
<span class="codeline" id="line-351"><code>	return re.subexpNames</code></span>
<span class="codeline" id="line-352"><code>}</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>// SubexpIndex returns the index of the first subexpression with the given name,</code></span>
<span class="codeline" id="line-355"><code>// or -1 if there is no subexpression with that name.</code></span>
<span class="codeline" id="line-356"><code>//</code></span>
<span class="codeline" id="line-357"><code>// Note that multiple subexpressions can be written using the same name, as in</code></span>
<span class="codeline" id="line-358"><code>// (?P&lt;bob&gt;a+)(?P&lt;bob&gt;b+), which declares two subexpressions named "bob".</code></span>
<span class="codeline" id="line-359"><code>// In this case, SubexpIndex returns the index of the leftmost such subexpression</code></span>
<span class="codeline" id="line-360"><code>// in the regular expression.</code></span>
<span class="codeline" id="line-361"><code>func (re *Regexp) SubexpIndex(name string) int {</code></span>
<span class="codeline" id="line-362"><code>	if name != "" {</code></span>
<span class="codeline" id="line-363"><code>		for i, s := range re.subexpNames {</code></span>
<span class="codeline" id="line-364"><code>			if name == s {</code></span>
<span class="codeline" id="line-365"><code>				return i</code></span>
<span class="codeline" id="line-366"><code>			}</code></span>
<span class="codeline" id="line-367"><code>		}</code></span>
<span class="codeline" id="line-368"><code>	}</code></span>
<span class="codeline" id="line-369"><code>	return -1</code></span>
<span class="codeline" id="line-370"><code>}</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>const endOfText rune = -1</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>// input abstracts different representations of the input text. It provides</code></span>
<span class="codeline" id="line-375"><code>// one-character lookahead.</code></span>
<span class="codeline" id="line-376"><code>type input interface {</code></span>
<span class="codeline" id="line-377"><code>	step(pos int) (r rune, width int) // advance one rune</code></span>
<span class="codeline" id="line-378"><code>	canCheckPrefix() bool             // can we look ahead without losing info?</code></span>
<span class="codeline" id="line-379"><code>	hasPrefix(re *Regexp) bool</code></span>
<span class="codeline" id="line-380"><code>	index(re *Regexp, pos int) int</code></span>
<span class="codeline" id="line-381"><code>	context(pos int) lazyFlag</code></span>
<span class="codeline" id="line-382"><code>}</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>// inputString scans a string.</code></span>
<span class="codeline" id="line-385"><code>type inputString struct {</code></span>
<span class="codeline" id="line-386"><code>	str string</code></span>
<span class="codeline" id="line-387"><code>}</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>func (i *inputString) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-390"><code>	if pos &lt; len(i.str) {</code></span>
<span class="codeline" id="line-391"><code>		c := i.str[pos]</code></span>
<span class="codeline" id="line-392"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-393"><code>			return rune(c), 1</code></span>
<span class="codeline" id="line-394"><code>		}</code></span>
<span class="codeline" id="line-395"><code>		return utf8.DecodeRuneInString(i.str[pos:])</code></span>
<span class="codeline" id="line-396"><code>	}</code></span>
<span class="codeline" id="line-397"><code>	return endOfText, 0</code></span>
<span class="codeline" id="line-398"><code>}</code></span>
<span class="codeline" id="line-399"><code></code></span>
<span class="codeline" id="line-400"><code>func (i *inputString) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-401"><code>	return true</code></span>
<span class="codeline" id="line-402"><code>}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>func (i *inputString) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-405"><code>	return strings.HasPrefix(i.str, re.prefix)</code></span>
<span class="codeline" id="line-406"><code>}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>func (i *inputString) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-409"><code>	return strings.Index(i.str[pos:], re.prefix)</code></span>
<span class="codeline" id="line-410"><code>}</code></span>
<span class="codeline" id="line-411"><code></code></span>
<span class="codeline" id="line-412"><code>func (i *inputString) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-413"><code>	r1, r2 := endOfText, endOfText</code></span>
<span class="codeline" id="line-414"><code>	// 0 &lt; pos &amp;&amp; pos &lt;= len(i.str)</code></span>
<span class="codeline" id="line-415"><code>	if uint(pos-1) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-416"><code>		r1 = rune(i.str[pos-1])</code></span>
<span class="codeline" id="line-417"><code>		if r1 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-418"><code>			r1, _ = utf8.DecodeLastRuneInString(i.str[:pos])</code></span>
<span class="codeline" id="line-419"><code>		}</code></span>
<span class="codeline" id="line-420"><code>	}</code></span>
<span class="codeline" id="line-421"><code>	// 0 &lt;= pos &amp;&amp; pos &lt; len(i.str)</code></span>
<span class="codeline" id="line-422"><code>	if uint(pos) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-423"><code>		r2 = rune(i.str[pos])</code></span>
<span class="codeline" id="line-424"><code>		if r2 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-425"><code>			r2, _ = utf8.DecodeRuneInString(i.str[pos:])</code></span>
<span class="codeline" id="line-426"><code>		}</code></span>
<span class="codeline" id="line-427"><code>	}</code></span>
<span class="codeline" id="line-428"><code>	return newLazyFlag(r1, r2)</code></span>
<span class="codeline" id="line-429"><code>}</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>// inputBytes scans a byte slice.</code></span>
<span class="codeline" id="line-432"><code>type inputBytes struct {</code></span>
<span class="codeline" id="line-433"><code>	str []byte</code></span>
<span class="codeline" id="line-434"><code>}</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>func (i *inputBytes) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-437"><code>	if pos &lt; len(i.str) {</code></span>
<span class="codeline" id="line-438"><code>		c := i.str[pos]</code></span>
<span class="codeline" id="line-439"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-440"><code>			return rune(c), 1</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>		return utf8.DecodeRune(i.str[pos:])</code></span>
<span class="codeline" id="line-443"><code>	}</code></span>
<span class="codeline" id="line-444"><code>	return endOfText, 0</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>func (i *inputBytes) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-448"><code>	return true</code></span>
<span class="codeline" id="line-449"><code>}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>func (i *inputBytes) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-452"><code>	return bytes.HasPrefix(i.str, re.prefixBytes)</code></span>
<span class="codeline" id="line-453"><code>}</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>func (i *inputBytes) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-456"><code>	return bytes.Index(i.str[pos:], re.prefixBytes)</code></span>
<span class="codeline" id="line-457"><code>}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>func (i *inputBytes) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-460"><code>	r1, r2 := endOfText, endOfText</code></span>
<span class="codeline" id="line-461"><code>	// 0 &lt; pos &amp;&amp; pos &lt;= len(i.str)</code></span>
<span class="codeline" id="line-462"><code>	if uint(pos-1) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-463"><code>		r1 = rune(i.str[pos-1])</code></span>
<span class="codeline" id="line-464"><code>		if r1 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-465"><code>			r1, _ = utf8.DecodeLastRune(i.str[:pos])</code></span>
<span class="codeline" id="line-466"><code>		}</code></span>
<span class="codeline" id="line-467"><code>	}</code></span>
<span class="codeline" id="line-468"><code>	// 0 &lt;= pos &amp;&amp; pos &lt; len(i.str)</code></span>
<span class="codeline" id="line-469"><code>	if uint(pos) &lt; uint(len(i.str)) {</code></span>
<span class="codeline" id="line-470"><code>		r2 = rune(i.str[pos])</code></span>
<span class="codeline" id="line-471"><code>		if r2 &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-472"><code>			r2, _ = utf8.DecodeRune(i.str[pos:])</code></span>
<span class="codeline" id="line-473"><code>		}</code></span>
<span class="codeline" id="line-474"><code>	}</code></span>
<span class="codeline" id="line-475"><code>	return newLazyFlag(r1, r2)</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>// inputReader scans a RuneReader.</code></span>
<span class="codeline" id="line-479"><code>type inputReader struct {</code></span>
<span class="codeline" id="line-480"><code>	r     io.RuneReader</code></span>
<span class="codeline" id="line-481"><code>	atEOT bool</code></span>
<span class="codeline" id="line-482"><code>	pos   int</code></span>
<span class="codeline" id="line-483"><code>}</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>func (i *inputReader) step(pos int) (rune, int) {</code></span>
<span class="codeline" id="line-486"><code>	if !i.atEOT &amp;&amp; pos != i.pos {</code></span>
<span class="codeline" id="line-487"><code>		return endOfText, 0</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>	}</code></span>
<span class="codeline" id="line-490"><code>	r, w, err := i.r.ReadRune()</code></span>
<span class="codeline" id="line-491"><code>	if err != nil {</code></span>
<span class="codeline" id="line-492"><code>		i.atEOT = true</code></span>
<span class="codeline" id="line-493"><code>		return endOfText, 0</code></span>
<span class="codeline" id="line-494"><code>	}</code></span>
<span class="codeline" id="line-495"><code>	i.pos += w</code></span>
<span class="codeline" id="line-496"><code>	return r, w</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>func (i *inputReader) canCheckPrefix() bool {</code></span>
<span class="codeline" id="line-500"><code>	return false</code></span>
<span class="codeline" id="line-501"><code>}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>func (i *inputReader) hasPrefix(re *Regexp) bool {</code></span>
<span class="codeline" id="line-504"><code>	return false</code></span>
<span class="codeline" id="line-505"><code>}</code></span>
<span class="codeline" id="line-506"><code></code></span>
<span class="codeline" id="line-507"><code>func (i *inputReader) index(re *Regexp, pos int) int {</code></span>
<span class="codeline" id="line-508"><code>	return -1</code></span>
<span class="codeline" id="line-509"><code>}</code></span>
<span class="codeline" id="line-510"><code></code></span>
<span class="codeline" id="line-511"><code>func (i *inputReader) context(pos int) lazyFlag {</code></span>
<span class="codeline" id="line-512"><code>	return 0 // not used</code></span>
<span class="codeline" id="line-513"><code>}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>// LiteralPrefix returns a literal string that must begin any match</code></span>
<span class="codeline" id="line-516"><code>// of the regular expression re. It returns the boolean true if the</code></span>
<span class="codeline" id="line-517"><code>// literal string comprises the entire regular expression.</code></span>
<span class="codeline" id="line-518"><code>func (re *Regexp) LiteralPrefix() (prefix string, complete bool) {</code></span>
<span class="codeline" id="line-519"><code>	return re.prefix, re.prefixComplete</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>// MatchReader reports whether the text returned by the [io.RuneReader]</code></span>
<span class="codeline" id="line-523"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-524"><code>func (re *Regexp) MatchReader(r io.RuneReader) bool {</code></span>
<span class="codeline" id="line-525"><code>	return re.doMatch(r, nil, "")</code></span>
<span class="codeline" id="line-526"><code>}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>// MatchString reports whether the string s</code></span>
<span class="codeline" id="line-529"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-530"><code>func (re *Regexp) MatchString(s string) bool {</code></span>
<span class="codeline" id="line-531"><code>	return re.doMatch(nil, nil, s)</code></span>
<span class="codeline" id="line-532"><code>}</code></span>
<span class="codeline" id="line-533"><code></code></span>
<span class="codeline" id="line-534"><code>// Match reports whether the byte slice b</code></span>
<span class="codeline" id="line-535"><code>// contains any match of the regular expression re.</code></span>
<span class="codeline" id="line-536"><code>func (re *Regexp) Match(b []byte) bool {</code></span>
<span class="codeline" id="line-537"><code>	return re.doMatch(nil, b, "")</code></span>
<span class="codeline" id="line-538"><code>}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>// MatchReader reports whether the text returned by the RuneReader</code></span>
<span class="codeline" id="line-541"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-542"><code>// More complicated queries need to use [Compile] and the full [Regexp] interface.</code></span>
<span class="codeline" id="line-543"><code>func MatchReader(pattern string, r io.RuneReader) (matched bool, err error) {</code></span>
<span class="codeline" id="line-544"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-545"><code>	if err != nil {</code></span>
<span class="codeline" id="line-546"><code>		return false, err</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code>	return re.MatchReader(r), nil</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>// MatchString reports whether the string s</code></span>
<span class="codeline" id="line-552"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-553"><code>// More complicated queries need to use [Compile] and the full [Regexp] interface.</code></span>
<span class="codeline" id="line-554"><code>func MatchString(pattern string, s string) (matched bool, err error) {</code></span>
<span class="codeline" id="line-555"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-556"><code>	if err != nil {</code></span>
<span class="codeline" id="line-557"><code>		return false, err</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code>	return re.MatchString(s), nil</code></span>
<span class="codeline" id="line-560"><code>}</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>// Match reports whether the byte slice b</code></span>
<span class="codeline" id="line-563"><code>// contains any match of the regular expression pattern.</code></span>
<span class="codeline" id="line-564"><code>// More complicated queries need to use [Compile] and the full [Regexp] interface.</code></span>
<span class="codeline" id="line-565"><code>func Match(pattern string, b []byte) (matched bool, err error) {</code></span>
<span class="codeline" id="line-566"><code>	re, err := Compile(pattern)</code></span>
<span class="codeline" id="line-567"><code>	if err != nil {</code></span>
<span class="codeline" id="line-568"><code>		return false, err</code></span>
<span class="codeline" id="line-569"><code>	}</code></span>
<span class="codeline" id="line-570"><code>	return re.Match(b), nil</code></span>
<span class="codeline" id="line-571"><code>}</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>// ReplaceAllString returns a copy of src, replacing matches of the [Regexp]</code></span>
<span class="codeline" id="line-574"><code>// with the replacement string repl.</code></span>
<span class="codeline" id="line-575"><code>// Inside repl, $ signs are interpreted as in [Regexp.Expand].</code></span>
<span class="codeline" id="line-576"><code>func (re *Regexp) ReplaceAllString(src, repl string) string {</code></span>
<span class="codeline" id="line-577"><code>	n := 2</code></span>
<span class="codeline" id="line-578"><code>	if strings.Contains(repl, "$") {</code></span>
<span class="codeline" id="line-579"><code>		n = 2 * (re.numSubexp + 1)</code></span>
<span class="codeline" id="line-580"><code>	}</code></span>
<span class="codeline" id="line-581"><code>	b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-582"><code>		return re.expand(dst, repl, nil, src, match)</code></span>
<span class="codeline" id="line-583"><code>	})</code></span>
<span class="codeline" id="line-584"><code>	return string(b)</code></span>
<span class="codeline" id="line-585"><code>}</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>// ReplaceAllLiteralString returns a copy of src, replacing matches of the [Regexp]</code></span>
<span class="codeline" id="line-588"><code>// with the replacement string repl. The replacement repl is substituted directly,</code></span>
<span class="codeline" id="line-589"><code>// without using [Regexp.Expand].</code></span>
<span class="codeline" id="line-590"><code>func (re *Regexp) ReplaceAllLiteralString(src, repl string) string {</code></span>
<span class="codeline" id="line-591"><code>	return string(re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-592"><code>		return append(dst, repl...)</code></span>
<span class="codeline" id="line-593"><code>	}))</code></span>
<span class="codeline" id="line-594"><code>}</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>// ReplaceAllStringFunc returns a copy of src in which all matches of the</code></span>
<span class="codeline" id="line-597"><code>// [Regexp] have been replaced by the return value of function repl applied</code></span>
<span class="codeline" id="line-598"><code>// to the matched substring. The replacement returned by repl is substituted</code></span>
<span class="codeline" id="line-599"><code>// directly, without using [Regexp.Expand].</code></span>
<span class="codeline" id="line-600"><code>func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {</code></span>
<span class="codeline" id="line-601"><code>	b := re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-602"><code>		return append(dst, repl(src[match[0]:match[1]])...)</code></span>
<span class="codeline" id="line-603"><code>	})</code></span>
<span class="codeline" id="line-604"><code>	return string(b)</code></span>
<span class="codeline" id="line-605"><code>}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte {</code></span>
<span class="codeline" id="line-608"><code>	lastMatchEnd := 0 // end position of the most recent match</code></span>
<span class="codeline" id="line-609"><code>	searchPos := 0    // position where we next look for a match</code></span>
<span class="codeline" id="line-610"><code>	var buf []byte</code></span>
<span class="codeline" id="line-611"><code>	var endPos int</code></span>
<span class="codeline" id="line-612"><code>	if bsrc != nil {</code></span>
<span class="codeline" id="line-613"><code>		endPos = len(bsrc)</code></span>
<span class="codeline" id="line-614"><code>	} else {</code></span>
<span class="codeline" id="line-615"><code>		endPos = len(src)</code></span>
<span class="codeline" id="line-616"><code>	}</code></span>
<span class="codeline" id="line-617"><code>	if nmatch &gt; re.prog.NumCap {</code></span>
<span class="codeline" id="line-618"><code>		nmatch = re.prog.NumCap</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-622"><code>	for searchPos &lt;= endPos {</code></span>
<span class="codeline" id="line-623"><code>		a := re.doExecute(nil, bsrc, src, searchPos, nmatch, dstCap[:0])</code></span>
<span class="codeline" id="line-624"><code>		if len(a) == 0 {</code></span>
<span class="codeline" id="line-625"><code>			break // no more matches</code></span>
<span class="codeline" id="line-626"><code>		}</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>		// Copy the unmatched characters before this match.</code></span>
<span class="codeline" id="line-629"><code>		if bsrc != nil {</code></span>
<span class="codeline" id="line-630"><code>			buf = append(buf, bsrc[lastMatchEnd:a[0]]...)</code></span>
<span class="codeline" id="line-631"><code>		} else {</code></span>
<span class="codeline" id="line-632"><code>			buf = append(buf, src[lastMatchEnd:a[0]]...)</code></span>
<span class="codeline" id="line-633"><code>		}</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>		// Now insert a copy of the replacement string, but not for a</code></span>
<span class="codeline" id="line-636"><code>		// match of the empty string immediately after another match.</code></span>
<span class="codeline" id="line-637"><code>		// (Otherwise, we get double replacement for patterns that</code></span>
<span class="codeline" id="line-638"><code>		// match both empty and nonempty strings.)</code></span>
<span class="codeline" id="line-639"><code>		if a[1] &gt; lastMatchEnd || a[0] == 0 {</code></span>
<span class="codeline" id="line-640"><code>			buf = repl(buf, a)</code></span>
<span class="codeline" id="line-641"><code>		}</code></span>
<span class="codeline" id="line-642"><code>		lastMatchEnd = a[1]</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>		// Advance past this match; always advance at least one character.</code></span>
<span class="codeline" id="line-645"><code>		var width int</code></span>
<span class="codeline" id="line-646"><code>		if bsrc != nil {</code></span>
<span class="codeline" id="line-647"><code>			_, width = utf8.DecodeRune(bsrc[searchPos:])</code></span>
<span class="codeline" id="line-648"><code>		} else {</code></span>
<span class="codeline" id="line-649"><code>			_, width = utf8.DecodeRuneInString(src[searchPos:])</code></span>
<span class="codeline" id="line-650"><code>		}</code></span>
<span class="codeline" id="line-651"><code>		if searchPos+width &gt; a[1] {</code></span>
<span class="codeline" id="line-652"><code>			searchPos += width</code></span>
<span class="codeline" id="line-653"><code>		} else if searchPos+1 &gt; a[1] {</code></span>
<span class="codeline" id="line-654"><code>			// This clause is only needed at the end of the input</code></span>
<span class="codeline" id="line-655"><code>			// string. In that case, DecodeRuneInString returns width=0.</code></span>
<span class="codeline" id="line-656"><code>			searchPos++</code></span>
<span class="codeline" id="line-657"><code>		} else {</code></span>
<span class="codeline" id="line-658"><code>			searchPos = a[1]</code></span>
<span class="codeline" id="line-659"><code>		}</code></span>
<span class="codeline" id="line-660"><code>	}</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>	// Copy the unmatched characters after the last match.</code></span>
<span class="codeline" id="line-663"><code>	if bsrc != nil {</code></span>
<span class="codeline" id="line-664"><code>		buf = append(buf, bsrc[lastMatchEnd:]...)</code></span>
<span class="codeline" id="line-665"><code>	} else {</code></span>
<span class="codeline" id="line-666"><code>		buf = append(buf, src[lastMatchEnd:]...)</code></span>
<span class="codeline" id="line-667"><code>	}</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>	return buf</code></span>
<span class="codeline" id="line-670"><code>}</code></span>
<span class="codeline" id="line-671"><code></code></span>
<span class="codeline" id="line-672"><code>// ReplaceAll returns a copy of src, replacing matches of the [Regexp]</code></span>
<span class="codeline" id="line-673"><code>// with the replacement text repl.</code></span>
<span class="codeline" id="line-674"><code>// Inside repl, $ signs are interpreted as in [Regexp.Expand].</code></span>
<span class="codeline" id="line-675"><code>func (re *Regexp) ReplaceAll(src, repl []byte) []byte {</code></span>
<span class="codeline" id="line-676"><code>	n := 2</code></span>
<span class="codeline" id="line-677"><code>	if bytes.IndexByte(repl, '$') &gt;= 0 {</code></span>
<span class="codeline" id="line-678"><code>		n = 2 * (re.numSubexp + 1)</code></span>
<span class="codeline" id="line-679"><code>	}</code></span>
<span class="codeline" id="line-680"><code>	srepl := ""</code></span>
<span class="codeline" id="line-681"><code>	b := re.replaceAll(src, "", n, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-682"><code>		if len(srepl) != len(repl) {</code></span>
<span class="codeline" id="line-683"><code>			srepl = string(repl)</code></span>
<span class="codeline" id="line-684"><code>		}</code></span>
<span class="codeline" id="line-685"><code>		return re.expand(dst, srepl, src, "", match)</code></span>
<span class="codeline" id="line-686"><code>	})</code></span>
<span class="codeline" id="line-687"><code>	return b</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// ReplaceAllLiteral returns a copy of src, replacing matches of the [Regexp]</code></span>
<span class="codeline" id="line-691"><code>// with the replacement bytes repl. The replacement repl is substituted directly,</code></span>
<span class="codeline" id="line-692"><code>// without using [Regexp.Expand].</code></span>
<span class="codeline" id="line-693"><code>func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte {</code></span>
<span class="codeline" id="line-694"><code>	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-695"><code>		return append(dst, repl...)</code></span>
<span class="codeline" id="line-696"><code>	})</code></span>
<span class="codeline" id="line-697"><code>}</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// ReplaceAllFunc returns a copy of src in which all matches of the</code></span>
<span class="codeline" id="line-700"><code>// [Regexp] have been replaced by the return value of function repl applied</code></span>
<span class="codeline" id="line-701"><code>// to the matched byte slice. The replacement returned by repl is substituted</code></span>
<span class="codeline" id="line-702"><code>// directly, without using [Regexp.Expand].</code></span>
<span class="codeline" id="line-703"><code>func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {</code></span>
<span class="codeline" id="line-704"><code>	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-705"><code>		return append(dst, repl(src[match[0]:match[1]])...)</code></span>
<span class="codeline" id="line-706"><code>	})</code></span>
<span class="codeline" id="line-707"><code>}</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>// Bitmap used by func special to check whether a character needs to be escaped.</code></span>
<span class="codeline" id="line-710"><code>var specialBytes [16]byte</code></span>
<span class="codeline" id="line-711"><code></code></span>
<span class="codeline" id="line-712"><code>// special reports whether byte b needs to be escaped by QuoteMeta.</code></span>
<span class="codeline" id="line-713"><code>func special(b byte) bool {</code></span>
<span class="codeline" id="line-714"><code>	return b &lt; utf8.RuneSelf &amp;&amp; specialBytes[b%16]&amp;(1&lt;&lt;(b/16)) != 0</code></span>
<span class="codeline" id="line-715"><code>}</code></span>
<span class="codeline" id="line-716"><code></code></span>
<span class="codeline" id="line-717"><code>func init() {</code></span>
<span class="codeline" id="line-718"><code>	for _, b := range []byte(`\.+*?()|[]{}^$`) {</code></span>
<span class="codeline" id="line-719"><code>		specialBytes[b%16] |= 1 &lt;&lt; (b / 16)</code></span>
<span class="codeline" id="line-720"><code>	}</code></span>
<span class="codeline" id="line-721"><code>}</code></span>
<span class="codeline" id="line-722"><code></code></span>
<span class="codeline" id="line-723"><code>// QuoteMeta returns a string that escapes all regular expression metacharacters</code></span>
<span class="codeline" id="line-724"><code>// inside the argument text; the returned string is a regular expression matching</code></span>
<span class="codeline" id="line-725"><code>// the literal text.</code></span>
<span class="codeline" id="line-726"><code>func QuoteMeta(s string) string {</code></span>
<span class="codeline" id="line-727"><code>	// A byte loop is correct because all metacharacters are ASCII.</code></span>
<span class="codeline" id="line-728"><code>	var i int</code></span>
<span class="codeline" id="line-729"><code>	for i = 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-730"><code>		if special(s[i]) {</code></span>
<span class="codeline" id="line-731"><code>			break</code></span>
<span class="codeline" id="line-732"><code>		}</code></span>
<span class="codeline" id="line-733"><code>	}</code></span>
<span class="codeline" id="line-734"><code>	// No meta characters found, so return original string.</code></span>
<span class="codeline" id="line-735"><code>	if i &gt;= len(s) {</code></span>
<span class="codeline" id="line-736"><code>		return s</code></span>
<span class="codeline" id="line-737"><code>	}</code></span>
<span class="codeline" id="line-738"><code></code></span>
<span class="codeline" id="line-739"><code>	b := make([]byte, 2*len(s)-i)</code></span>
<span class="codeline" id="line-740"><code>	copy(b, s[:i])</code></span>
<span class="codeline" id="line-741"><code>	j := i</code></span>
<span class="codeline" id="line-742"><code>	for ; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-743"><code>		if special(s[i]) {</code></span>
<span class="codeline" id="line-744"><code>			b[j] = '\\'</code></span>
<span class="codeline" id="line-745"><code>			j++</code></span>
<span class="codeline" id="line-746"><code>		}</code></span>
<span class="codeline" id="line-747"><code>		b[j] = s[i]</code></span>
<span class="codeline" id="line-748"><code>		j++</code></span>
<span class="codeline" id="line-749"><code>	}</code></span>
<span class="codeline" id="line-750"><code>	return string(b[:j])</code></span>
<span class="codeline" id="line-751"><code>}</code></span>
<span class="codeline" id="line-752"><code></code></span>
<span class="codeline" id="line-753"><code>// The number of capture values in the program may correspond</code></span>
<span class="codeline" id="line-754"><code>// to fewer capturing expressions than are in the regexp.</code></span>
<span class="codeline" id="line-755"><code>// For example, "(a){0}" turns into an empty program, so the</code></span>
<span class="codeline" id="line-756"><code>// maximum capture in the program is 0 but we need to return</code></span>
<span class="codeline" id="line-757"><code>// an expression for \1.  Pad appends -1s to the slice a as needed.</code></span>
<span class="codeline" id="line-758"><code>func (re *Regexp) pad(a []int) []int {</code></span>
<span class="codeline" id="line-759"><code>	if a == nil {</code></span>
<span class="codeline" id="line-760"><code>		// No match.</code></span>
<span class="codeline" id="line-761"><code>		return nil</code></span>
<span class="codeline" id="line-762"><code>	}</code></span>
<span class="codeline" id="line-763"><code>	n := (1 + re.numSubexp) * 2</code></span>
<span class="codeline" id="line-764"><code>	for len(a) &lt; n {</code></span>
<span class="codeline" id="line-765"><code>		a = append(a, -1)</code></span>
<span class="codeline" id="line-766"><code>	}</code></span>
<span class="codeline" id="line-767"><code>	return a</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>// allMatches calls deliver at most n times</code></span>
<span class="codeline" id="line-771"><code>// with the location of successive matches in the input text.</code></span>
<span class="codeline" id="line-772"><code>// The input text is b if non-nil, otherwise s.</code></span>
<span class="codeline" id="line-773"><code>func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int)) {</code></span>
<span class="codeline" id="line-774"><code>	var end int</code></span>
<span class="codeline" id="line-775"><code>	if b == nil {</code></span>
<span class="codeline" id="line-776"><code>		end = len(s)</code></span>
<span class="codeline" id="line-777"><code>	} else {</code></span>
<span class="codeline" id="line-778"><code>		end = len(b)</code></span>
<span class="codeline" id="line-779"><code>	}</code></span>
<span class="codeline" id="line-780"><code></code></span>
<span class="codeline" id="line-781"><code>	for pos, i, prevMatchEnd := 0, 0, -1; i &lt; n &amp;&amp; pos &lt;= end; {</code></span>
<span class="codeline" id="line-782"><code>		matches := re.doExecute(nil, b, s, pos, re.prog.NumCap, nil)</code></span>
<span class="codeline" id="line-783"><code>		if len(matches) == 0 {</code></span>
<span class="codeline" id="line-784"><code>			break</code></span>
<span class="codeline" id="line-785"><code>		}</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>		accept := true</code></span>
<span class="codeline" id="line-788"><code>		if matches[1] == pos {</code></span>
<span class="codeline" id="line-789"><code>			// We've found an empty match.</code></span>
<span class="codeline" id="line-790"><code>			if matches[0] == prevMatchEnd {</code></span>
<span class="codeline" id="line-791"><code>				// We don't allow an empty match right</code></span>
<span class="codeline" id="line-792"><code>				// after a previous match, so ignore it.</code></span>
<span class="codeline" id="line-793"><code>				accept = false</code></span>
<span class="codeline" id="line-794"><code>			}</code></span>
<span class="codeline" id="line-795"><code>			var width int</code></span>
<span class="codeline" id="line-796"><code>			if b == nil {</code></span>
<span class="codeline" id="line-797"><code>				is := inputString{str: s}</code></span>
<span class="codeline" id="line-798"><code>				_, width = is.step(pos)</code></span>
<span class="codeline" id="line-799"><code>			} else {</code></span>
<span class="codeline" id="line-800"><code>				ib := inputBytes{str: b}</code></span>
<span class="codeline" id="line-801"><code>				_, width = ib.step(pos)</code></span>
<span class="codeline" id="line-802"><code>			}</code></span>
<span class="codeline" id="line-803"><code>			if width &gt; 0 {</code></span>
<span class="codeline" id="line-804"><code>				pos += width</code></span>
<span class="codeline" id="line-805"><code>			} else {</code></span>
<span class="codeline" id="line-806"><code>				pos = end + 1</code></span>
<span class="codeline" id="line-807"><code>			}</code></span>
<span class="codeline" id="line-808"><code>		} else {</code></span>
<span class="codeline" id="line-809"><code>			pos = matches[1]</code></span>
<span class="codeline" id="line-810"><code>		}</code></span>
<span class="codeline" id="line-811"><code>		prevMatchEnd = matches[1]</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>		if accept {</code></span>
<span class="codeline" id="line-814"><code>			deliver(re.pad(matches))</code></span>
<span class="codeline" id="line-815"><code>			i++</code></span>
<span class="codeline" id="line-816"><code>		}</code></span>
<span class="codeline" id="line-817"><code>	}</code></span>
<span class="codeline" id="line-818"><code>}</code></span>
<span class="codeline" id="line-819"><code></code></span>
<span class="codeline" id="line-820"><code>// Find returns a slice holding the text of the leftmost match in b of the regular expression.</code></span>
<span class="codeline" id="line-821"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-822"><code>func (re *Regexp) Find(b []byte) []byte {</code></span>
<span class="codeline" id="line-823"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-824"><code>	a := re.doExecute(nil, b, "", 0, 2, dstCap[:0])</code></span>
<span class="codeline" id="line-825"><code>	if a == nil {</code></span>
<span class="codeline" id="line-826"><code>		return nil</code></span>
<span class="codeline" id="line-827"><code>	}</code></span>
<span class="codeline" id="line-828"><code>	return b[a[0]:a[1]:a[1]]</code></span>
<span class="codeline" id="line-829"><code>}</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>// FindIndex returns a two-element slice of integers defining the location of</code></span>
<span class="codeline" id="line-832"><code>// the leftmost match in b of the regular expression. The match itself is at</code></span>
<span class="codeline" id="line-833"><code>// b[loc[0]:loc[1]].</code></span>
<span class="codeline" id="line-834"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-835"><code>func (re *Regexp) FindIndex(b []byte) (loc []int) {</code></span>
<span class="codeline" id="line-836"><code>	a := re.doExecute(nil, b, "", 0, 2, nil)</code></span>
<span class="codeline" id="line-837"><code>	if a == nil {</code></span>
<span class="codeline" id="line-838"><code>		return nil</code></span>
<span class="codeline" id="line-839"><code>	}</code></span>
<span class="codeline" id="line-840"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-841"><code>}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>// FindString returns a string holding the text of the leftmost match in s of the regular</code></span>
<span class="codeline" id="line-844"><code>// expression. If there is no match, the return value is an empty string,</code></span>
<span class="codeline" id="line-845"><code>// but it will also be empty if the regular expression successfully matches</code></span>
<span class="codeline" id="line-846"><code>// an empty string. Use [Regexp.FindStringIndex] or [Regexp.FindStringSubmatch] if it is</code></span>
<span class="codeline" id="line-847"><code>// necessary to distinguish these cases.</code></span>
<span class="codeline" id="line-848"><code>func (re *Regexp) FindString(s string) string {</code></span>
<span class="codeline" id="line-849"><code>	var dstCap [2]int</code></span>
<span class="codeline" id="line-850"><code>	a := re.doExecute(nil, nil, s, 0, 2, dstCap[:0])</code></span>
<span class="codeline" id="line-851"><code>	if a == nil {</code></span>
<span class="codeline" id="line-852"><code>		return ""</code></span>
<span class="codeline" id="line-853"><code>	}</code></span>
<span class="codeline" id="line-854"><code>	return s[a[0]:a[1]]</code></span>
<span class="codeline" id="line-855"><code>}</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>// FindStringIndex returns a two-element slice of integers defining the</code></span>
<span class="codeline" id="line-858"><code>// location of the leftmost match in s of the regular expression. The match</code></span>
<span class="codeline" id="line-859"><code>// itself is at s[loc[0]:loc[1]].</code></span>
<span class="codeline" id="line-860"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-861"><code>func (re *Regexp) FindStringIndex(s string) (loc []int) {</code></span>
<span class="codeline" id="line-862"><code>	a := re.doExecute(nil, nil, s, 0, 2, nil)</code></span>
<span class="codeline" id="line-863"><code>	if a == nil {</code></span>
<span class="codeline" id="line-864"><code>		return nil</code></span>
<span class="codeline" id="line-865"><code>	}</code></span>
<span class="codeline" id="line-866"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-867"><code>}</code></span>
<span class="codeline" id="line-868"><code></code></span>
<span class="codeline" id="line-869"><code>// FindReaderIndex returns a two-element slice of integers defining the</code></span>
<span class="codeline" id="line-870"><code>// location of the leftmost match of the regular expression in text read from</code></span>
<span class="codeline" id="line-871"><code>// the [io.RuneReader]. The match text was found in the input stream at</code></span>
<span class="codeline" id="line-872"><code>// byte offset loc[0] through loc[1]-1.</code></span>
<span class="codeline" id="line-873"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-874"><code>func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) {</code></span>
<span class="codeline" id="line-875"><code>	a := re.doExecute(r, nil, "", 0, 2, nil)</code></span>
<span class="codeline" id="line-876"><code>	if a == nil {</code></span>
<span class="codeline" id="line-877"><code>		return nil</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code>	return a[0:2]</code></span>
<span class="codeline" id="line-880"><code>}</code></span>
<span class="codeline" id="line-881"><code></code></span>
<span class="codeline" id="line-882"><code>// FindSubmatch returns a slice of slices holding the text of the leftmost</code></span>
<span class="codeline" id="line-883"><code>// match of the regular expression in b and the matches, if any, of its</code></span>
<span class="codeline" id="line-884"><code>// subexpressions, as defined by the 'Submatch' descriptions in the package</code></span>
<span class="codeline" id="line-885"><code>// comment.</code></span>
<span class="codeline" id="line-886"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-887"><code>func (re *Regexp) FindSubmatch(b []byte) [][]byte {</code></span>
<span class="codeline" id="line-888"><code>	var dstCap [4]int</code></span>
<span class="codeline" id="line-889"><code>	a := re.doExecute(nil, b, "", 0, re.prog.NumCap, dstCap[:0])</code></span>
<span class="codeline" id="line-890"><code>	if a == nil {</code></span>
<span class="codeline" id="line-891"><code>		return nil</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code>	ret := make([][]byte, 1+re.numSubexp)</code></span>
<span class="codeline" id="line-894"><code>	for i := range ret {</code></span>
<span class="codeline" id="line-895"><code>		if 2*i &lt; len(a) &amp;&amp; a[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-896"><code>			ret[i] = b[a[2*i]:a[2*i+1]:a[2*i+1]]</code></span>
<span class="codeline" id="line-897"><code>		}</code></span>
<span class="codeline" id="line-898"><code>	}</code></span>
<span class="codeline" id="line-899"><code>	return ret</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// Expand appends template to dst and returns the result; during the</code></span>
<span class="codeline" id="line-903"><code>// append, Expand replaces variables in the template with corresponding</code></span>
<span class="codeline" id="line-904"><code>// matches drawn from src. The match slice should have been returned by</code></span>
<span class="codeline" id="line-905"><code>// [Regexp.FindSubmatchIndex].</code></span>
<span class="codeline" id="line-906"><code>//</code></span>
<span class="codeline" id="line-907"><code>// In the template, a variable is denoted by a substring of the form</code></span>
<span class="codeline" id="line-908"><code>// $name or ${name}, where name is a non-empty sequence of letters,</code></span>
<span class="codeline" id="line-909"><code>// digits, and underscores. A purely numeric name like $1 refers to</code></span>
<span class="codeline" id="line-910"><code>// the submatch with the corresponding index; other names refer to</code></span>
<span class="codeline" id="line-911"><code>// capturing parentheses named with the (?P&lt;name&gt;...) syntax. A</code></span>
<span class="codeline" id="line-912"><code>// reference to an out of range or unmatched index or a name that is not</code></span>
<span class="codeline" id="line-913"><code>// present in the regular expression is replaced with an empty slice.</code></span>
<span class="codeline" id="line-914"><code>//</code></span>
<span class="codeline" id="line-915"><code>// In the $name form, name is taken to be as long as possible: $1x is</code></span>
<span class="codeline" id="line-916"><code>// equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.</code></span>
<span class="codeline" id="line-917"><code>//</code></span>
<span class="codeline" id="line-918"><code>// To insert a literal $ in the output, use $$ in the template.</code></span>
<span class="codeline" id="line-919"><code>func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte {</code></span>
<span class="codeline" id="line-920"><code>	return re.expand(dst, string(template), src, "", match)</code></span>
<span class="codeline" id="line-921"><code>}</code></span>
<span class="codeline" id="line-922"><code></code></span>
<span class="codeline" id="line-923"><code>// ExpandString is like [Regexp.Expand] but the template and source are strings.</code></span>
<span class="codeline" id="line-924"><code>// It appends to and returns a byte slice in order to give the calling</code></span>
<span class="codeline" id="line-925"><code>// code control over allocation.</code></span>
<span class="codeline" id="line-926"><code>func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte {</code></span>
<span class="codeline" id="line-927"><code>	return re.expand(dst, template, nil, src, match)</code></span>
<span class="codeline" id="line-928"><code>}</code></span>
<span class="codeline" id="line-929"><code></code></span>
<span class="codeline" id="line-930"><code>func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {</code></span>
<span class="codeline" id="line-931"><code>	for len(template) &gt; 0 {</code></span>
<span class="codeline" id="line-932"><code>		before, after, ok := strings.Cut(template, "$")</code></span>
<span class="codeline" id="line-933"><code>		if !ok {</code></span>
<span class="codeline" id="line-934"><code>			break</code></span>
<span class="codeline" id="line-935"><code>		}</code></span>
<span class="codeline" id="line-936"><code>		dst = append(dst, before...)</code></span>
<span class="codeline" id="line-937"><code>		template = after</code></span>
<span class="codeline" id="line-938"><code>		if template != "" &amp;&amp; template[0] == '$' {</code></span>
<span class="codeline" id="line-939"><code>			// Treat $$ as $.</code></span>
<span class="codeline" id="line-940"><code>			dst = append(dst, '$')</code></span>
<span class="codeline" id="line-941"><code>			template = template[1:]</code></span>
<span class="codeline" id="line-942"><code>			continue</code></span>
<span class="codeline" id="line-943"><code>		}</code></span>
<span class="codeline" id="line-944"><code>		name, num, rest, ok := extract(template)</code></span>
<span class="codeline" id="line-945"><code>		if !ok {</code></span>
<span class="codeline" id="line-946"><code>			// Malformed; treat $ as raw text.</code></span>
<span class="codeline" id="line-947"><code>			dst = append(dst, '$')</code></span>
<span class="codeline" id="line-948"><code>			continue</code></span>
<span class="codeline" id="line-949"><code>		}</code></span>
<span class="codeline" id="line-950"><code>		template = rest</code></span>
<span class="codeline" id="line-951"><code>		if num &gt;= 0 {</code></span>
<span class="codeline" id="line-952"><code>			if 2*num+1 &lt; len(match) &amp;&amp; match[2*num] &gt;= 0 {</code></span>
<span class="codeline" id="line-953"><code>				if bsrc != nil {</code></span>
<span class="codeline" id="line-954"><code>					dst = append(dst, bsrc[match[2*num]:match[2*num+1]]...)</code></span>
<span class="codeline" id="line-955"><code>				} else {</code></span>
<span class="codeline" id="line-956"><code>					dst = append(dst, src[match[2*num]:match[2*num+1]]...)</code></span>
<span class="codeline" id="line-957"><code>				}</code></span>
<span class="codeline" id="line-958"><code>			}</code></span>
<span class="codeline" id="line-959"><code>		} else {</code></span>
<span class="codeline" id="line-960"><code>			for i, namei := range re.subexpNames {</code></span>
<span class="codeline" id="line-961"><code>				if name == namei &amp;&amp; 2*i+1 &lt; len(match) &amp;&amp; match[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-962"><code>					if bsrc != nil {</code></span>
<span class="codeline" id="line-963"><code>						dst = append(dst, bsrc[match[2*i]:match[2*i+1]]...)</code></span>
<span class="codeline" id="line-964"><code>					} else {</code></span>
<span class="codeline" id="line-965"><code>						dst = append(dst, src[match[2*i]:match[2*i+1]]...)</code></span>
<span class="codeline" id="line-966"><code>					}</code></span>
<span class="codeline" id="line-967"><code>					break</code></span>
<span class="codeline" id="line-968"><code>				}</code></span>
<span class="codeline" id="line-969"><code>			}</code></span>
<span class="codeline" id="line-970"><code>		}</code></span>
<span class="codeline" id="line-971"><code>	}</code></span>
<span class="codeline" id="line-972"><code>	dst = append(dst, template...)</code></span>
<span class="codeline" id="line-973"><code>	return dst</code></span>
<span class="codeline" id="line-974"><code>}</code></span>
<span class="codeline" id="line-975"><code></code></span>
<span class="codeline" id="line-976"><code>// extract returns the name from a leading "name" or "{name}" in str.</code></span>
<span class="codeline" id="line-977"><code>// (The $ has already been removed by the caller.)</code></span>
<span class="codeline" id="line-978"><code>// If it is a number, extract returns num set to that number; otherwise num = -1.</code></span>
<span class="codeline" id="line-979"><code>func extract(str string) (name string, num int, rest string, ok bool) {</code></span>
<span class="codeline" id="line-980"><code>	if str == "" {</code></span>
<span class="codeline" id="line-981"><code>		return</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>	brace := false</code></span>
<span class="codeline" id="line-984"><code>	if str[0] == '{' {</code></span>
<span class="codeline" id="line-985"><code>		brace = true</code></span>
<span class="codeline" id="line-986"><code>		str = str[1:]</code></span>
<span class="codeline" id="line-987"><code>	}</code></span>
<span class="codeline" id="line-988"><code>	i := 0</code></span>
<span class="codeline" id="line-989"><code>	for i &lt; len(str) {</code></span>
<span class="codeline" id="line-990"><code>		rune, size := utf8.DecodeRuneInString(str[i:])</code></span>
<span class="codeline" id="line-991"><code>		if !unicode.IsLetter(rune) &amp;&amp; !unicode.IsDigit(rune) &amp;&amp; rune != '_' {</code></span>
<span class="codeline" id="line-992"><code>			break</code></span>
<span class="codeline" id="line-993"><code>		}</code></span>
<span class="codeline" id="line-994"><code>		i += size</code></span>
<span class="codeline" id="line-995"><code>	}</code></span>
<span class="codeline" id="line-996"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-997"><code>		// empty name is not okay</code></span>
<span class="codeline" id="line-998"><code>		return</code></span>
<span class="codeline" id="line-999"><code>	}</code></span>
<span class="codeline" id="line-1000"><code>	name = str[:i]</code></span>
<span class="codeline" id="line-1001"><code>	if brace {</code></span>
<span class="codeline" id="line-1002"><code>		if i &gt;= len(str) || str[i] != '}' {</code></span>
<span class="codeline" id="line-1003"><code>			// missing closing brace</code></span>
<span class="codeline" id="line-1004"><code>			return</code></span>
<span class="codeline" id="line-1005"><code>		}</code></span>
<span class="codeline" id="line-1006"><code>		i++</code></span>
<span class="codeline" id="line-1007"><code>	}</code></span>
<span class="codeline" id="line-1008"><code></code></span>
<span class="codeline" id="line-1009"><code>	// Parse number.</code></span>
<span class="codeline" id="line-1010"><code>	num = 0</code></span>
<span class="codeline" id="line-1011"><code>	for i := 0; i &lt; len(name); i++ {</code></span>
<span class="codeline" id="line-1012"><code>		if name[i] &lt; '0' || '9' &lt; name[i] || num &gt;= 1e8 {</code></span>
<span class="codeline" id="line-1013"><code>			num = -1</code></span>
<span class="codeline" id="line-1014"><code>			break</code></span>
<span class="codeline" id="line-1015"><code>		}</code></span>
<span class="codeline" id="line-1016"><code>		num = num*10 + int(name[i]) - '0'</code></span>
<span class="codeline" id="line-1017"><code>	}</code></span>
<span class="codeline" id="line-1018"><code>	// Disallow leading zeros.</code></span>
<span class="codeline" id="line-1019"><code>	if name[0] == '0' &amp;&amp; len(name) &gt; 1 {</code></span>
<span class="codeline" id="line-1020"><code>		num = -1</code></span>
<span class="codeline" id="line-1021"><code>	}</code></span>
<span class="codeline" id="line-1022"><code></code></span>
<span class="codeline" id="line-1023"><code>	rest = str[i:]</code></span>
<span class="codeline" id="line-1024"><code>	ok = true</code></span>
<span class="codeline" id="line-1025"><code>	return</code></span>
<span class="codeline" id="line-1026"><code>}</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>// FindSubmatchIndex returns a slice holding the index pairs identifying the</code></span>
<span class="codeline" id="line-1029"><code>// leftmost match of the regular expression in b and the matches, if any, of</code></span>
<span class="codeline" id="line-1030"><code>// its subexpressions, as defined by the 'Submatch' and 'Index' descriptions</code></span>
<span class="codeline" id="line-1031"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1032"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1033"><code>func (re *Regexp) FindSubmatchIndex(b []byte) []int {</code></span>
<span class="codeline" id="line-1034"><code>	return re.pad(re.doExecute(nil, b, "", 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1035"><code>}</code></span>
<span class="codeline" id="line-1036"><code></code></span>
<span class="codeline" id="line-1037"><code>// FindStringSubmatch returns a slice of strings holding the text of the</code></span>
<span class="codeline" id="line-1038"><code>// leftmost match of the regular expression in s and the matches, if any, of</code></span>
<span class="codeline" id="line-1039"><code>// its subexpressions, as defined by the 'Submatch' description in the</code></span>
<span class="codeline" id="line-1040"><code>// package comment.</code></span>
<span class="codeline" id="line-1041"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1042"><code>func (re *Regexp) FindStringSubmatch(s string) []string {</code></span>
<span class="codeline" id="line-1043"><code>	var dstCap [4]int</code></span>
<span class="codeline" id="line-1044"><code>	a := re.doExecute(nil, nil, s, 0, re.prog.NumCap, dstCap[:0])</code></span>
<span class="codeline" id="line-1045"><code>	if a == nil {</code></span>
<span class="codeline" id="line-1046"><code>		return nil</code></span>
<span class="codeline" id="line-1047"><code>	}</code></span>
<span class="codeline" id="line-1048"><code>	ret := make([]string, 1+re.numSubexp)</code></span>
<span class="codeline" id="line-1049"><code>	for i := range ret {</code></span>
<span class="codeline" id="line-1050"><code>		if 2*i &lt; len(a) &amp;&amp; a[2*i] &gt;= 0 {</code></span>
<span class="codeline" id="line-1051"><code>			ret[i] = s[a[2*i]:a[2*i+1]]</code></span>
<span class="codeline" id="line-1052"><code>		}</code></span>
<span class="codeline" id="line-1053"><code>	}</code></span>
<span class="codeline" id="line-1054"><code>	return ret</code></span>
<span class="codeline" id="line-1055"><code>}</code></span>
<span class="codeline" id="line-1056"><code></code></span>
<span class="codeline" id="line-1057"><code>// FindStringSubmatchIndex returns a slice holding the index pairs</code></span>
<span class="codeline" id="line-1058"><code>// identifying the leftmost match of the regular expression in s and the</code></span>
<span class="codeline" id="line-1059"><code>// matches, if any, of its subexpressions, as defined by the 'Submatch' and</code></span>
<span class="codeline" id="line-1060"><code>// 'Index' descriptions in the package comment.</code></span>
<span class="codeline" id="line-1061"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1062"><code>func (re *Regexp) FindStringSubmatchIndex(s string) []int {</code></span>
<span class="codeline" id="line-1063"><code>	return re.pad(re.doExecute(nil, nil, s, 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1064"><code>}</code></span>
<span class="codeline" id="line-1065"><code></code></span>
<span class="codeline" id="line-1066"><code>// FindReaderSubmatchIndex returns a slice holding the index pairs</code></span>
<span class="codeline" id="line-1067"><code>// identifying the leftmost match of the regular expression of text read by</code></span>
<span class="codeline" id="line-1068"><code>// the [io.RuneReader], and the matches, if any, of its subexpressions, as defined</code></span>
<span class="codeline" id="line-1069"><code>// by the 'Submatch' and 'Index' descriptions in the package comment. A</code></span>
<span class="codeline" id="line-1070"><code>// return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1071"><code>func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int {</code></span>
<span class="codeline" id="line-1072"><code>	return re.pad(re.doExecute(r, nil, "", 0, re.prog.NumCap, nil))</code></span>
<span class="codeline" id="line-1073"><code>}</code></span>
<span class="codeline" id="line-1074"><code></code></span>
<span class="codeline" id="line-1075"><code>const startSize = 10 // The size at which to start a slice in the 'All' routines.</code></span>
<span class="codeline" id="line-1076"><code></code></span>
<span class="codeline" id="line-1077"><code>// FindAll is the 'All' version of Find; it returns a slice of all successive</code></span>
<span class="codeline" id="line-1078"><code>// matches of the expression, as defined by the 'All' description in the</code></span>
<span class="codeline" id="line-1079"><code>// package comment.</code></span>
<span class="codeline" id="line-1080"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1081"><code>func (re *Regexp) FindAll(b []byte, n int) [][]byte {</code></span>
<span class="codeline" id="line-1082"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1083"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1084"><code>	}</code></span>
<span class="codeline" id="line-1085"><code>	var result [][]byte</code></span>
<span class="codeline" id="line-1086"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1087"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1088"><code>			result = make([][]byte, 0, startSize)</code></span>
<span class="codeline" id="line-1089"><code>		}</code></span>
<span class="codeline" id="line-1090"><code>		result = append(result, b[match[0]:match[1]:match[1]])</code></span>
<span class="codeline" id="line-1091"><code>	})</code></span>
<span class="codeline" id="line-1092"><code>	return result</code></span>
<span class="codeline" id="line-1093"><code>}</code></span>
<span class="codeline" id="line-1094"><code></code></span>
<span class="codeline" id="line-1095"><code>// FindAllIndex is the 'All' version of [Regexp.FindIndex]; it returns a slice of all</code></span>
<span class="codeline" id="line-1096"><code>// successive matches of the expression, as defined by the 'All' description</code></span>
<span class="codeline" id="line-1097"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1098"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1099"><code>func (re *Regexp) FindAllIndex(b []byte, n int) [][]int {</code></span>
<span class="codeline" id="line-1100"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1101"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1102"><code>	}</code></span>
<span class="codeline" id="line-1103"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1104"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1105"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1106"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1107"><code>		}</code></span>
<span class="codeline" id="line-1108"><code>		result = append(result, match[0:2])</code></span>
<span class="codeline" id="line-1109"><code>	})</code></span>
<span class="codeline" id="line-1110"><code>	return result</code></span>
<span class="codeline" id="line-1111"><code>}</code></span>
<span class="codeline" id="line-1112"><code></code></span>
<span class="codeline" id="line-1113"><code>// FindAllString is the 'All' version of [Regexp.FindString]; it returns a slice of all</code></span>
<span class="codeline" id="line-1114"><code>// successive matches of the expression, as defined by the 'All' description</code></span>
<span class="codeline" id="line-1115"><code>// in the package comment.</code></span>
<span class="codeline" id="line-1116"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1117"><code>func (re *Regexp) FindAllString(s string, n int) []string {</code></span>
<span class="codeline" id="line-1118"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1119"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1120"><code>	}</code></span>
<span class="codeline" id="line-1121"><code>	var result []string</code></span>
<span class="codeline" id="line-1122"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1123"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1124"><code>			result = make([]string, 0, startSize)</code></span>
<span class="codeline" id="line-1125"><code>		}</code></span>
<span class="codeline" id="line-1126"><code>		result = append(result, s[match[0]:match[1]])</code></span>
<span class="codeline" id="line-1127"><code>	})</code></span>
<span class="codeline" id="line-1128"><code>	return result</code></span>
<span class="codeline" id="line-1129"><code>}</code></span>
<span class="codeline" id="line-1130"><code></code></span>
<span class="codeline" id="line-1131"><code>// FindAllStringIndex is the 'All' version of [Regexp.FindStringIndex]; it returns a</code></span>
<span class="codeline" id="line-1132"><code>// slice of all successive matches of the expression, as defined by the 'All'</code></span>
<span class="codeline" id="line-1133"><code>// description in the package comment.</code></span>
<span class="codeline" id="line-1134"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1135"><code>func (re *Regexp) FindAllStringIndex(s string, n int) [][]int {</code></span>
<span class="codeline" id="line-1136"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1137"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1138"><code>	}</code></span>
<span class="codeline" id="line-1139"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1140"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1141"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1142"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1143"><code>		}</code></span>
<span class="codeline" id="line-1144"><code>		result = append(result, match[0:2])</code></span>
<span class="codeline" id="line-1145"><code>	})</code></span>
<span class="codeline" id="line-1146"><code>	return result</code></span>
<span class="codeline" id="line-1147"><code>}</code></span>
<span class="codeline" id="line-1148"><code></code></span>
<span class="codeline" id="line-1149"><code>// FindAllSubmatch is the 'All' version of [Regexp.FindSubmatch]; it returns a slice</code></span>
<span class="codeline" id="line-1150"><code>// of all successive matches of the expression, as defined by the 'All'</code></span>
<span class="codeline" id="line-1151"><code>// description in the package comment.</code></span>
<span class="codeline" id="line-1152"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1153"><code>func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte {</code></span>
<span class="codeline" id="line-1154"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1155"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1156"><code>	}</code></span>
<span class="codeline" id="line-1157"><code>	var result [][][]byte</code></span>
<span class="codeline" id="line-1158"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1159"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1160"><code>			result = make([][][]byte, 0, startSize)</code></span>
<span class="codeline" id="line-1161"><code>		}</code></span>
<span class="codeline" id="line-1162"><code>		slice := make([][]byte, len(match)/2)</code></span>
<span class="codeline" id="line-1163"><code>		for j := range slice {</code></span>
<span class="codeline" id="line-1164"><code>			if match[2*j] &gt;= 0 {</code></span>
<span class="codeline" id="line-1165"><code>				slice[j] = b[match[2*j]:match[2*j+1]:match[2*j+1]]</code></span>
<span class="codeline" id="line-1166"><code>			}</code></span>
<span class="codeline" id="line-1167"><code>		}</code></span>
<span class="codeline" id="line-1168"><code>		result = append(result, slice)</code></span>
<span class="codeline" id="line-1169"><code>	})</code></span>
<span class="codeline" id="line-1170"><code>	return result</code></span>
<span class="codeline" id="line-1171"><code>}</code></span>
<span class="codeline" id="line-1172"><code></code></span>
<span class="codeline" id="line-1173"><code>// FindAllSubmatchIndex is the 'All' version of [Regexp.FindSubmatchIndex]; it returns</code></span>
<span class="codeline" id="line-1174"><code>// a slice of all successive matches of the expression, as defined by the</code></span>
<span class="codeline" id="line-1175"><code>// 'All' description in the package comment.</code></span>
<span class="codeline" id="line-1176"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1177"><code>func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int {</code></span>
<span class="codeline" id="line-1178"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1179"><code>		n = len(b) + 1</code></span>
<span class="codeline" id="line-1180"><code>	}</code></span>
<span class="codeline" id="line-1181"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1182"><code>	re.allMatches("", b, n, func(match []int) {</code></span>
<span class="codeline" id="line-1183"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1184"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1185"><code>		}</code></span>
<span class="codeline" id="line-1186"><code>		result = append(result, match)</code></span>
<span class="codeline" id="line-1187"><code>	})</code></span>
<span class="codeline" id="line-1188"><code>	return result</code></span>
<span class="codeline" id="line-1189"><code>}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>// FindAllStringSubmatch is the 'All' version of [Regexp.FindStringSubmatch]; it</code></span>
<span class="codeline" id="line-1192"><code>// returns a slice of all successive matches of the expression, as defined by</code></span>
<span class="codeline" id="line-1193"><code>// the 'All' description in the package comment.</code></span>
<span class="codeline" id="line-1194"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1195"><code>func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string {</code></span>
<span class="codeline" id="line-1196"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1197"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1198"><code>	}</code></span>
<span class="codeline" id="line-1199"><code>	var result [][]string</code></span>
<span class="codeline" id="line-1200"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1201"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1202"><code>			result = make([][]string, 0, startSize)</code></span>
<span class="codeline" id="line-1203"><code>		}</code></span>
<span class="codeline" id="line-1204"><code>		slice := make([]string, len(match)/2)</code></span>
<span class="codeline" id="line-1205"><code>		for j := range slice {</code></span>
<span class="codeline" id="line-1206"><code>			if match[2*j] &gt;= 0 {</code></span>
<span class="codeline" id="line-1207"><code>				slice[j] = s[match[2*j]:match[2*j+1]]</code></span>
<span class="codeline" id="line-1208"><code>			}</code></span>
<span class="codeline" id="line-1209"><code>		}</code></span>
<span class="codeline" id="line-1210"><code>		result = append(result, slice)</code></span>
<span class="codeline" id="line-1211"><code>	})</code></span>
<span class="codeline" id="line-1212"><code>	return result</code></span>
<span class="codeline" id="line-1213"><code>}</code></span>
<span class="codeline" id="line-1214"><code></code></span>
<span class="codeline" id="line-1215"><code>// FindAllStringSubmatchIndex is the 'All' version of</code></span>
<span class="codeline" id="line-1216"><code>// [Regexp.FindStringSubmatchIndex]; it returns a slice of all successive matches of</code></span>
<span class="codeline" id="line-1217"><code>// the expression, as defined by the 'All' description in the package</code></span>
<span class="codeline" id="line-1218"><code>// comment.</code></span>
<span class="codeline" id="line-1219"><code>// A return value of nil indicates no match.</code></span>
<span class="codeline" id="line-1220"><code>func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int {</code></span>
<span class="codeline" id="line-1221"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-1222"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-1223"><code>	}</code></span>
<span class="codeline" id="line-1224"><code>	var result [][]int</code></span>
<span class="codeline" id="line-1225"><code>	re.allMatches(s, nil, n, func(match []int) {</code></span>
<span class="codeline" id="line-1226"><code>		if result == nil {</code></span>
<span class="codeline" id="line-1227"><code>			result = make([][]int, 0, startSize)</code></span>
<span class="codeline" id="line-1228"><code>		}</code></span>
<span class="codeline" id="line-1229"><code>		result = append(result, match)</code></span>
<span class="codeline" id="line-1230"><code>	})</code></span>
<span class="codeline" id="line-1231"><code>	return result</code></span>
<span class="codeline" id="line-1232"><code>}</code></span>
<span class="codeline" id="line-1233"><code></code></span>
<span class="codeline" id="line-1234"><code>// Split slices s into substrings separated by the expression and returns a slice of</code></span>
<span class="codeline" id="line-1235"><code>// the substrings between those expression matches.</code></span>
<span class="codeline" id="line-1236"><code>//</code></span>
<span class="codeline" id="line-1237"><code>// The slice returned by this method consists of all the substrings of s</code></span>
<span class="codeline" id="line-1238"><code>// not contained in the slice returned by [Regexp.FindAllString]. When called on an expression</code></span>
<span class="codeline" id="line-1239"><code>// that contains no metacharacters, it is equivalent to [strings.SplitN].</code></span>
<span class="codeline" id="line-1240"><code>//</code></span>
<span class="codeline" id="line-1241"><code>// Example:</code></span>
<span class="codeline" id="line-1242"><code>//</code></span>
<span class="codeline" id="line-1243"><code>//	s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)</code></span>
<span class="codeline" id="line-1244"><code>//	// s: ["", "b", "b", "c", "cadaaae"]</code></span>
<span class="codeline" id="line-1245"><code>//</code></span>
<span class="codeline" id="line-1246"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-1247"><code>//</code></span>
<span class="codeline" id="line-1248"><code>//	n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-1249"><code>//	n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-1250"><code>//	n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-1251"><code>func (re *Regexp) Split(s string, n int) []string {</code></span>
<span class="codeline" id="line-1252"><code></code></span>
<span class="codeline" id="line-1253"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1254"><code>		return nil</code></span>
<span class="codeline" id="line-1255"><code>	}</code></span>
<span class="codeline" id="line-1256"><code></code></span>
<span class="codeline" id="line-1257"><code>	if len(re.expr) &gt; 0 &amp;&amp; len(s) == 0 {</code></span>
<span class="codeline" id="line-1258"><code>		return []string{""}</code></span>
<span class="codeline" id="line-1259"><code>	}</code></span>
<span class="codeline" id="line-1260"><code></code></span>
<span class="codeline" id="line-1261"><code>	matches := re.FindAllStringIndex(s, n)</code></span>
<span class="codeline" id="line-1262"><code>	strings := make([]string, 0, len(matches))</code></span>
<span class="codeline" id="line-1263"><code></code></span>
<span class="codeline" id="line-1264"><code>	beg := 0</code></span>
<span class="codeline" id="line-1265"><code>	end := 0</code></span>
<span class="codeline" id="line-1266"><code>	for _, match := range matches {</code></span>
<span class="codeline" id="line-1267"><code>		if n &gt; 0 &amp;&amp; len(strings) &gt;= n-1 {</code></span>
<span class="codeline" id="line-1268"><code>			break</code></span>
<span class="codeline" id="line-1269"><code>		}</code></span>
<span class="codeline" id="line-1270"><code></code></span>
<span class="codeline" id="line-1271"><code>		end = match[0]</code></span>
<span class="codeline" id="line-1272"><code>		if match[1] != 0 {</code></span>
<span class="codeline" id="line-1273"><code>			strings = append(strings, s[beg:end])</code></span>
<span class="codeline" id="line-1274"><code>		}</code></span>
<span class="codeline" id="line-1275"><code>		beg = match[1]</code></span>
<span class="codeline" id="line-1276"><code>	}</code></span>
<span class="codeline" id="line-1277"><code></code></span>
<span class="codeline" id="line-1278"><code>	if end != len(s) {</code></span>
<span class="codeline" id="line-1279"><code>		strings = append(strings, s[beg:])</code></span>
<span class="codeline" id="line-1280"><code>	}</code></span>
<span class="codeline" id="line-1281"><code></code></span>
<span class="codeline" id="line-1282"><code>	return strings</code></span>
<span class="codeline" id="line-1283"><code>}</code></span>
<span class="codeline" id="line-1284"><code></code></span>
<span class="codeline" id="line-1285"><code>// MarshalText implements [encoding.TextMarshaler]. The output</code></span>
<span class="codeline" id="line-1286"><code>// matches that of calling the [Regexp.String] method.</code></span>
<span class="codeline" id="line-1287"><code>//</code></span>
<span class="codeline" id="line-1288"><code>// Note that the output is lossy in some cases: This method does not indicate</code></span>
<span class="codeline" id="line-1289"><code>// POSIX regular expressions (i.e. those compiled by calling [CompilePOSIX]), or</code></span>
<span class="codeline" id="line-1290"><code>// those for which the [Regexp.Longest] method has been called.</code></span>
<span class="codeline" id="line-1291"><code>func (re *Regexp) MarshalText() ([]byte, error) {</code></span>
<span class="codeline" id="line-1292"><code>	return []byte(re.String()), nil</code></span>
<span class="codeline" id="line-1293"><code>}</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>// UnmarshalText implements [encoding.TextUnmarshaler] by calling</code></span>
<span class="codeline" id="line-1296"><code>// [Compile] on the encoded value.</code></span>
<span class="codeline" id="line-1297"><code>func (re *Regexp) UnmarshalText(text []byte) error {</code></span>
<span class="codeline" id="line-1298"><code>	newRE, err := Compile(string(text))</code></span>
<span class="codeline" id="line-1299"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1300"><code>		return err</code></span>
<span class="codeline" id="line-1301"><code>	}</code></span>
<span class="codeline" id="line-1302"><code>	*re = *newRE</code></span>
<span class="codeline" id="line-1303"><code>	return nil</code></span>
<span class="codeline" id="line-1304"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>