<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: regexp.go in package regexp/syntax</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	regexp.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/regexp/syntax.html">regexp/syntax</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package syntax</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>// Note to implementers:</code></span>
<span class="codeline" id="line-8"><code>// In this package, re is always a *Regexp and r is always a rune.</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"strconv"</code></span>
<span class="codeline" id="line-12"><code>	"strings"</code></span>
<span class="codeline" id="line-13"><code>	"unicode"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// A Regexp is a node in a regular expression syntax tree.</code></span>
<span class="codeline" id="line-17"><code>type Regexp struct {</code></span>
<span class="codeline" id="line-18"><code>	Op       Op // operator</code></span>
<span class="codeline" id="line-19"><code>	Flags    Flags</code></span>
<span class="codeline" id="line-20"><code>	Sub      []*Regexp  // subexpressions, if any</code></span>
<span class="codeline" id="line-21"><code>	Sub0     [1]*Regexp // storage for short Sub</code></span>
<span class="codeline" id="line-22"><code>	Rune     []rune     // matched runes, for OpLiteral, OpCharClass</code></span>
<span class="codeline" id="line-23"><code>	Rune0    [2]rune    // storage for short Rune</code></span>
<span class="codeline" id="line-24"><code>	Min, Max int        // min, max for OpRepeat</code></span>
<span class="codeline" id="line-25"><code>	Cap      int        // capturing index, for OpCapture</code></span>
<span class="codeline" id="line-26"><code>	Name     string     // capturing name, for OpCapture</code></span>
<span class="codeline" id="line-27"><code>}</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>//go:generate stringer -type Op -trimprefix Op</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// An Op is a single regular expression operator.</code></span>
<span class="codeline" id="line-32"><code>type Op uint8</code></span>
<span class="codeline" id="line-33"><code></code></span>
<span class="codeline" id="line-34"><code>// Operators are listed in precedence order, tightest binding to weakest.</code></span>
<span class="codeline" id="line-35"><code>// Character class operators are listed simplest to most complex</code></span>
<span class="codeline" id="line-36"><code>// (OpLiteral, OpCharClass, OpAnyCharNotNL, OpAnyChar).</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>const (</code></span>
<span class="codeline" id="line-39"><code>	OpNoMatch        Op = 1 + iota // matches no strings</code></span>
<span class="codeline" id="line-40"><code>	OpEmptyMatch                   // matches empty string</code></span>
<span class="codeline" id="line-41"><code>	OpLiteral                      // matches Runes sequence</code></span>
<span class="codeline" id="line-42"><code>	OpCharClass                    // matches Runes interpreted as range pair list</code></span>
<span class="codeline" id="line-43"><code>	OpAnyCharNotNL                 // matches any character except newline</code></span>
<span class="codeline" id="line-44"><code>	OpAnyChar                      // matches any character</code></span>
<span class="codeline" id="line-45"><code>	OpBeginLine                    // matches empty string at beginning of line</code></span>
<span class="codeline" id="line-46"><code>	OpEndLine                      // matches empty string at end of line</code></span>
<span class="codeline" id="line-47"><code>	OpBeginText                    // matches empty string at beginning of text</code></span>
<span class="codeline" id="line-48"><code>	OpEndText                      // matches empty string at end of text</code></span>
<span class="codeline" id="line-49"><code>	OpWordBoundary                 // matches word boundary `\b`</code></span>
<span class="codeline" id="line-50"><code>	OpNoWordBoundary               // matches word non-boundary `\B`</code></span>
<span class="codeline" id="line-51"><code>	OpCapture                      // capturing subexpression with index Cap, optional name Name</code></span>
<span class="codeline" id="line-52"><code>	OpStar                         // matches Sub[0] zero or more times</code></span>
<span class="codeline" id="line-53"><code>	OpPlus                         // matches Sub[0] one or more times</code></span>
<span class="codeline" id="line-54"><code>	OpQuest                        // matches Sub[0] zero or one times</code></span>
<span class="codeline" id="line-55"><code>	OpRepeat                       // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)</code></span>
<span class="codeline" id="line-56"><code>	OpConcat                       // matches concatenation of Subs</code></span>
<span class="codeline" id="line-57"><code>	OpAlternate                    // matches alternation of Subs</code></span>
<span class="codeline" id="line-58"><code>)</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>const opPseudo Op = 128 // where pseudo-ops start</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// Equal reports whether x and y have identical structure.</code></span>
<span class="codeline" id="line-63"><code>func (x *Regexp) Equal(y *Regexp) bool {</code></span>
<span class="codeline" id="line-64"><code>	if x == nil || y == nil {</code></span>
<span class="codeline" id="line-65"><code>		return x == y</code></span>
<span class="codeline" id="line-66"><code>	}</code></span>
<span class="codeline" id="line-67"><code>	if x.Op != y.Op {</code></span>
<span class="codeline" id="line-68"><code>		return false</code></span>
<span class="codeline" id="line-69"><code>	}</code></span>
<span class="codeline" id="line-70"><code>	switch x.Op {</code></span>
<span class="codeline" id="line-71"><code>	case OpEndText:</code></span>
<span class="codeline" id="line-72"><code>		// The parse flags remember whether this is \z or \Z.</code></span>
<span class="codeline" id="line-73"><code>		if x.Flags&amp;WasDollar != y.Flags&amp;WasDollar {</code></span>
<span class="codeline" id="line-74"><code>			return false</code></span>
<span class="codeline" id="line-75"><code>		}</code></span>
<span class="codeline" id="line-76"><code></code></span>
<span class="codeline" id="line-77"><code>	case OpLiteral, OpCharClass:</code></span>
<span class="codeline" id="line-78"><code>		if len(x.Rune) != len(y.Rune) {</code></span>
<span class="codeline" id="line-79"><code>			return false</code></span>
<span class="codeline" id="line-80"><code>		}</code></span>
<span class="codeline" id="line-81"><code>		for i, r := range x.Rune {</code></span>
<span class="codeline" id="line-82"><code>			if r != y.Rune[i] {</code></span>
<span class="codeline" id="line-83"><code>				return false</code></span>
<span class="codeline" id="line-84"><code>			}</code></span>
<span class="codeline" id="line-85"><code>		}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>	case OpAlternate, OpConcat:</code></span>
<span class="codeline" id="line-88"><code>		if len(x.Sub) != len(y.Sub) {</code></span>
<span class="codeline" id="line-89"><code>			return false</code></span>
<span class="codeline" id="line-90"><code>		}</code></span>
<span class="codeline" id="line-91"><code>		for i, sub := range x.Sub {</code></span>
<span class="codeline" id="line-92"><code>			if !sub.Equal(y.Sub[i]) {</code></span>
<span class="codeline" id="line-93"><code>				return false</code></span>
<span class="codeline" id="line-94"><code>			}</code></span>
<span class="codeline" id="line-95"><code>		}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>	case OpStar, OpPlus, OpQuest:</code></span>
<span class="codeline" id="line-98"><code>		if x.Flags&amp;NonGreedy != y.Flags&amp;NonGreedy || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-99"><code>			return false</code></span>
<span class="codeline" id="line-100"><code>		}</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code>	case OpRepeat:</code></span>
<span class="codeline" id="line-103"><code>		if x.Flags&amp;NonGreedy != y.Flags&amp;NonGreedy || x.Min != y.Min || x.Max != y.Max || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-104"><code>			return false</code></span>
<span class="codeline" id="line-105"><code>		}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	case OpCapture:</code></span>
<span class="codeline" id="line-108"><code>		if x.Cap != y.Cap || x.Name != y.Name || !x.Sub[0].Equal(y.Sub[0]) {</code></span>
<span class="codeline" id="line-109"><code>			return false</code></span>
<span class="codeline" id="line-110"><code>		}</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code>	return true</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>// printFlags is a bit set indicating which flags (including non-capturing parens) to print around a regexp.</code></span>
<span class="codeline" id="line-116"><code>type printFlags uint8</code></span>
<span class="codeline" id="line-117"><code></code></span>
<span class="codeline" id="line-118"><code>const (</code></span>
<span class="codeline" id="line-119"><code>	flagI    printFlags = 1 &lt;&lt; iota // (?i:</code></span>
<span class="codeline" id="line-120"><code>	flagM                           // (?m:</code></span>
<span class="codeline" id="line-121"><code>	flagS                           // (?s:</code></span>
<span class="codeline" id="line-122"><code>	flagOff                         // )</code></span>
<span class="codeline" id="line-123"><code>	flagPrec                        // (?: )</code></span>
<span class="codeline" id="line-124"><code>	negShift = 5                    // flagI&lt;&lt;negShift is (?-i:</code></span>
<span class="codeline" id="line-125"><code>)</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// addSpan enables the flags f around start..last,</code></span>
<span class="codeline" id="line-128"><code>// by setting flags[start] = f and flags[last] = flagOff.</code></span>
<span class="codeline" id="line-129"><code>func addSpan(start, last *Regexp, f printFlags, flags *map[*Regexp]printFlags) {</code></span>
<span class="codeline" id="line-130"><code>	if *flags == nil {</code></span>
<span class="codeline" id="line-131"><code>		*flags = make(map[*Regexp]printFlags)</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	(*flags)[start] = f</code></span>
<span class="codeline" id="line-134"><code>	(*flags)[last] |= flagOff // maybe start==last</code></span>
<span class="codeline" id="line-135"><code>}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>// calcFlags calculates the flags to print around each subexpression in re,</code></span>
<span class="codeline" id="line-138"><code>// storing that information in (*flags)[sub] for each affected subexpression.</code></span>
<span class="codeline" id="line-139"><code>// The first time an entry needs to be written to *flags, calcFlags allocates the map.</code></span>
<span class="codeline" id="line-140"><code>// calcFlags also calculates the flags that must be active or can't be active</code></span>
<span class="codeline" id="line-141"><code>// around re and returns those flags.</code></span>
<span class="codeline" id="line-142"><code>func calcFlags(re *Regexp, flags *map[*Regexp]printFlags) (must, cant printFlags) {</code></span>
<span class="codeline" id="line-143"><code>	switch re.Op {</code></span>
<span class="codeline" id="line-144"><code>	default:</code></span>
<span class="codeline" id="line-145"><code>		return 0, 0</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	case OpLiteral:</code></span>
<span class="codeline" id="line-148"><code>		// If literal is fold-sensitive, return (flagI, 0) or (0, flagI)</code></span>
<span class="codeline" id="line-149"><code>		// according to whether (?i) is active.</code></span>
<span class="codeline" id="line-150"><code>		// If literal is not fold-sensitive, return 0, 0.</code></span>
<span class="codeline" id="line-151"><code>		for _, r := range re.Rune {</code></span>
<span class="codeline" id="line-152"><code>			if minFold &lt;= r &amp;&amp; r &lt;= maxFold &amp;&amp; unicode.SimpleFold(r) != r {</code></span>
<span class="codeline" id="line-153"><code>				if re.Flags&amp;FoldCase != 0 {</code></span>
<span class="codeline" id="line-154"><code>					return flagI, 0</code></span>
<span class="codeline" id="line-155"><code>				} else {</code></span>
<span class="codeline" id="line-156"><code>					return 0, flagI</code></span>
<span class="codeline" id="line-157"><code>				}</code></span>
<span class="codeline" id="line-158"><code>			}</code></span>
<span class="codeline" id="line-159"><code>		}</code></span>
<span class="codeline" id="line-160"><code>		return 0, 0</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>	case OpCharClass:</code></span>
<span class="codeline" id="line-163"><code>		// If literal is fold-sensitive, return 0, flagI - (?i) has been compiled out.</code></span>
<span class="codeline" id="line-164"><code>		// If literal is not fold-sensitive, return 0, 0.</code></span>
<span class="codeline" id="line-165"><code>		for i := 0; i &lt; len(re.Rune); i += 2 {</code></span>
<span class="codeline" id="line-166"><code>			lo := max(minFold, re.Rune[i])</code></span>
<span class="codeline" id="line-167"><code>			hi := min(maxFold, re.Rune[i+1])</code></span>
<span class="codeline" id="line-168"><code>			for r := lo; r &lt;= hi; r++ {</code></span>
<span class="codeline" id="line-169"><code>				for f := unicode.SimpleFold(r); f != r; f = unicode.SimpleFold(f) {</code></span>
<span class="codeline" id="line-170"><code>					if !(lo &lt;= f &amp;&amp; f &lt;= hi) &amp;&amp; !inCharClass(f, re.Rune) {</code></span>
<span class="codeline" id="line-171"><code>						return 0, flagI</code></span>
<span class="codeline" id="line-172"><code>					}</code></span>
<span class="codeline" id="line-173"><code>				}</code></span>
<span class="codeline" id="line-174"><code>			}</code></span>
<span class="codeline" id="line-175"><code>		}</code></span>
<span class="codeline" id="line-176"><code>		return 0, 0</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>	case OpAnyCharNotNL: // (?-s).</code></span>
<span class="codeline" id="line-179"><code>		return 0, flagS</code></span>
<span class="codeline" id="line-180"><code></code></span>
<span class="codeline" id="line-181"><code>	case OpAnyChar: // (?s).</code></span>
<span class="codeline" id="line-182"><code>		return flagS, 0</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>	case OpBeginLine, OpEndLine: // (?m)^ (?m)$</code></span>
<span class="codeline" id="line-185"><code>		return flagM, 0</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>	case OpEndText:</code></span>
<span class="codeline" id="line-188"><code>		if re.Flags&amp;WasDollar != 0 { // (?-m)$</code></span>
<span class="codeline" id="line-189"><code>			return 0, flagM</code></span>
<span class="codeline" id="line-190"><code>		}</code></span>
<span class="codeline" id="line-191"><code>		return 0, 0</code></span>
<span class="codeline" id="line-192"><code></code></span>
<span class="codeline" id="line-193"><code>	case OpCapture, OpStar, OpPlus, OpQuest, OpRepeat:</code></span>
<span class="codeline" id="line-194"><code>		return calcFlags(re.Sub[0], flags)</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>	case OpConcat, OpAlternate:</code></span>
<span class="codeline" id="line-197"><code>		// Gather the must and cant for each subexpression.</code></span>
<span class="codeline" id="line-198"><code>		// When we find a conflicting subexpression, insert the necessary</code></span>
<span class="codeline" id="line-199"><code>		// flags around the previously identified span and start over.</code></span>
<span class="codeline" id="line-200"><code>		var must, cant, allCant printFlags</code></span>
<span class="codeline" id="line-201"><code>		start := 0</code></span>
<span class="codeline" id="line-202"><code>		last := 0</code></span>
<span class="codeline" id="line-203"><code>		did := false</code></span>
<span class="codeline" id="line-204"><code>		for i, sub := range re.Sub {</code></span>
<span class="codeline" id="line-205"><code>			subMust, subCant := calcFlags(sub, flags)</code></span>
<span class="codeline" id="line-206"><code>			if must&amp;subCant != 0 || subMust&amp;cant != 0 {</code></span>
<span class="codeline" id="line-207"><code>				if must != 0 {</code></span>
<span class="codeline" id="line-208"><code>					addSpan(re.Sub[start], re.Sub[last], must, flags)</code></span>
<span class="codeline" id="line-209"><code>				}</code></span>
<span class="codeline" id="line-210"><code>				must = 0</code></span>
<span class="codeline" id="line-211"><code>				cant = 0</code></span>
<span class="codeline" id="line-212"><code>				start = i</code></span>
<span class="codeline" id="line-213"><code>				did = true</code></span>
<span class="codeline" id="line-214"><code>			}</code></span>
<span class="codeline" id="line-215"><code>			must |= subMust</code></span>
<span class="codeline" id="line-216"><code>			cant |= subCant</code></span>
<span class="codeline" id="line-217"><code>			allCant |= subCant</code></span>
<span class="codeline" id="line-218"><code>			if subMust != 0 {</code></span>
<span class="codeline" id="line-219"><code>				last = i</code></span>
<span class="codeline" id="line-220"><code>			}</code></span>
<span class="codeline" id="line-221"><code>			if must == 0 &amp;&amp; start == i {</code></span>
<span class="codeline" id="line-222"><code>				start++</code></span>
<span class="codeline" id="line-223"><code>			}</code></span>
<span class="codeline" id="line-224"><code>		}</code></span>
<span class="codeline" id="line-225"><code>		if !did {</code></span>
<span class="codeline" id="line-226"><code>			// No conflicts: pass the accumulated must and cant upward.</code></span>
<span class="codeline" id="line-227"><code>			return must, cant</code></span>
<span class="codeline" id="line-228"><code>		}</code></span>
<span class="codeline" id="line-229"><code>		if must != 0 {</code></span>
<span class="codeline" id="line-230"><code>			// Conflicts found; need to finish final span.</code></span>
<span class="codeline" id="line-231"><code>			addSpan(re.Sub[start], re.Sub[last], must, flags)</code></span>
<span class="codeline" id="line-232"><code>		}</code></span>
<span class="codeline" id="line-233"><code>		return 0, allCant</code></span>
<span class="codeline" id="line-234"><code>	}</code></span>
<span class="codeline" id="line-235"><code>}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>// writeRegexp writes the Perl syntax for the regular expression re to b.</code></span>
<span class="codeline" id="line-238"><code>func writeRegexp(b *strings.Builder, re *Regexp, f printFlags, flags map[*Regexp]printFlags) {</code></span>
<span class="codeline" id="line-239"><code>	f |= flags[re]</code></span>
<span class="codeline" id="line-240"><code>	if f&amp;flagPrec != 0 &amp;&amp; f&amp;^(flagOff|flagPrec) != 0 &amp;&amp; f&amp;flagOff != 0 {</code></span>
<span class="codeline" id="line-241"><code>		// flagPrec is redundant with other flags being added and terminated</code></span>
<span class="codeline" id="line-242"><code>		f &amp;^= flagPrec</code></span>
<span class="codeline" id="line-243"><code>	}</code></span>
<span class="codeline" id="line-244"><code>	if f&amp;^(flagOff|flagPrec) != 0 {</code></span>
<span class="codeline" id="line-245"><code>		b.WriteString(`(?`)</code></span>
<span class="codeline" id="line-246"><code>		if f&amp;flagI != 0 {</code></span>
<span class="codeline" id="line-247"><code>			b.WriteString(`i`)</code></span>
<span class="codeline" id="line-248"><code>		}</code></span>
<span class="codeline" id="line-249"><code>		if f&amp;flagM != 0 {</code></span>
<span class="codeline" id="line-250"><code>			b.WriteString(`m`)</code></span>
<span class="codeline" id="line-251"><code>		}</code></span>
<span class="codeline" id="line-252"><code>		if f&amp;flagS != 0 {</code></span>
<span class="codeline" id="line-253"><code>			b.WriteString(`s`)</code></span>
<span class="codeline" id="line-254"><code>		}</code></span>
<span class="codeline" id="line-255"><code>		if f&amp;((flagM|flagS)&lt;&lt;negShift) != 0 {</code></span>
<span class="codeline" id="line-256"><code>			b.WriteString(`-`)</code></span>
<span class="codeline" id="line-257"><code>			if f&amp;(flagM&lt;&lt;negShift) != 0 {</code></span>
<span class="codeline" id="line-258"><code>				b.WriteString(`m`)</code></span>
<span class="codeline" id="line-259"><code>			}</code></span>
<span class="codeline" id="line-260"><code>			if f&amp;(flagS&lt;&lt;negShift) != 0 {</code></span>
<span class="codeline" id="line-261"><code>				b.WriteString(`s`)</code></span>
<span class="codeline" id="line-262"><code>			}</code></span>
<span class="codeline" id="line-263"><code>		}</code></span>
<span class="codeline" id="line-264"><code>		b.WriteString(`:`)</code></span>
<span class="codeline" id="line-265"><code>	}</code></span>
<span class="codeline" id="line-266"><code>	if f&amp;flagOff != 0 {</code></span>
<span class="codeline" id="line-267"><code>		defer b.WriteString(`)`)</code></span>
<span class="codeline" id="line-268"><code>	}</code></span>
<span class="codeline" id="line-269"><code>	if f&amp;flagPrec != 0 {</code></span>
<span class="codeline" id="line-270"><code>		b.WriteString(`(?:`)</code></span>
<span class="codeline" id="line-271"><code>		defer b.WriteString(`)`)</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>	switch re.Op {</code></span>
<span class="codeline" id="line-275"><code>	default:</code></span>
<span class="codeline" id="line-276"><code>		b.WriteString("&lt;invalid op" + strconv.Itoa(int(re.Op)) + "&gt;")</code></span>
<span class="codeline" id="line-277"><code>	case OpNoMatch:</code></span>
<span class="codeline" id="line-278"><code>		b.WriteString(`[^\x00-\x{10FFFF}]`)</code></span>
<span class="codeline" id="line-279"><code>	case OpEmptyMatch:</code></span>
<span class="codeline" id="line-280"><code>		b.WriteString(`(?:)`)</code></span>
<span class="codeline" id="line-281"><code>	case OpLiteral:</code></span>
<span class="codeline" id="line-282"><code>		for _, r := range re.Rune {</code></span>
<span class="codeline" id="line-283"><code>			escape(b, r, false)</code></span>
<span class="codeline" id="line-284"><code>		}</code></span>
<span class="codeline" id="line-285"><code>	case OpCharClass:</code></span>
<span class="codeline" id="line-286"><code>		if len(re.Rune)%2 != 0 {</code></span>
<span class="codeline" id="line-287"><code>			b.WriteString(`[invalid char class]`)</code></span>
<span class="codeline" id="line-288"><code>			break</code></span>
<span class="codeline" id="line-289"><code>		}</code></span>
<span class="codeline" id="line-290"><code>		b.WriteRune('[')</code></span>
<span class="codeline" id="line-291"><code>		if len(re.Rune) == 0 {</code></span>
<span class="codeline" id="line-292"><code>			b.WriteString(`^\x00-\x{10FFFF}`)</code></span>
<span class="codeline" id="line-293"><code>		} else if re.Rune[0] == 0 &amp;&amp; re.Rune[len(re.Rune)-1] == unicode.MaxRune &amp;&amp; len(re.Rune) &gt; 2 {</code></span>
<span class="codeline" id="line-294"><code>			// Contains 0 and MaxRune. Probably a negated class.</code></span>
<span class="codeline" id="line-295"><code>			// Print the gaps.</code></span>
<span class="codeline" id="line-296"><code>			b.WriteRune('^')</code></span>
<span class="codeline" id="line-297"><code>			for i := 1; i &lt; len(re.Rune)-1; i += 2 {</code></span>
<span class="codeline" id="line-298"><code>				lo, hi := re.Rune[i]+1, re.Rune[i+1]-1</code></span>
<span class="codeline" id="line-299"><code>				escape(b, lo, lo == '-')</code></span>
<span class="codeline" id="line-300"><code>				if lo != hi {</code></span>
<span class="codeline" id="line-301"><code>					if hi != lo+1 {</code></span>
<span class="codeline" id="line-302"><code>						b.WriteRune('-')</code></span>
<span class="codeline" id="line-303"><code>					}</code></span>
<span class="codeline" id="line-304"><code>					escape(b, hi, hi == '-')</code></span>
<span class="codeline" id="line-305"><code>				}</code></span>
<span class="codeline" id="line-306"><code>			}</code></span>
<span class="codeline" id="line-307"><code>		} else {</code></span>
<span class="codeline" id="line-308"><code>			for i := 0; i &lt; len(re.Rune); i += 2 {</code></span>
<span class="codeline" id="line-309"><code>				lo, hi := re.Rune[i], re.Rune[i+1]</code></span>
<span class="codeline" id="line-310"><code>				escape(b, lo, lo == '-')</code></span>
<span class="codeline" id="line-311"><code>				if lo != hi {</code></span>
<span class="codeline" id="line-312"><code>					if hi != lo+1 {</code></span>
<span class="codeline" id="line-313"><code>						b.WriteRune('-')</code></span>
<span class="codeline" id="line-314"><code>					}</code></span>
<span class="codeline" id="line-315"><code>					escape(b, hi, hi == '-')</code></span>
<span class="codeline" id="line-316"><code>				}</code></span>
<span class="codeline" id="line-317"><code>			}</code></span>
<span class="codeline" id="line-318"><code>		}</code></span>
<span class="codeline" id="line-319"><code>		b.WriteRune(']')</code></span>
<span class="codeline" id="line-320"><code>	case OpAnyCharNotNL, OpAnyChar:</code></span>
<span class="codeline" id="line-321"><code>		b.WriteString(`.`)</code></span>
<span class="codeline" id="line-322"><code>	case OpBeginLine:</code></span>
<span class="codeline" id="line-323"><code>		b.WriteString(`^`)</code></span>
<span class="codeline" id="line-324"><code>	case OpEndLine:</code></span>
<span class="codeline" id="line-325"><code>		b.WriteString(`$`)</code></span>
<span class="codeline" id="line-326"><code>	case OpBeginText:</code></span>
<span class="codeline" id="line-327"><code>		b.WriteString(`\A`)</code></span>
<span class="codeline" id="line-328"><code>	case OpEndText:</code></span>
<span class="codeline" id="line-329"><code>		if re.Flags&amp;WasDollar != 0 {</code></span>
<span class="codeline" id="line-330"><code>			b.WriteString(`$`)</code></span>
<span class="codeline" id="line-331"><code>		} else {</code></span>
<span class="codeline" id="line-332"><code>			b.WriteString(`\z`)</code></span>
<span class="codeline" id="line-333"><code>		}</code></span>
<span class="codeline" id="line-334"><code>	case OpWordBoundary:</code></span>
<span class="codeline" id="line-335"><code>		b.WriteString(`\b`)</code></span>
<span class="codeline" id="line-336"><code>	case OpNoWordBoundary:</code></span>
<span class="codeline" id="line-337"><code>		b.WriteString(`\B`)</code></span>
<span class="codeline" id="line-338"><code>	case OpCapture:</code></span>
<span class="codeline" id="line-339"><code>		if re.Name != "" {</code></span>
<span class="codeline" id="line-340"><code>			b.WriteString(`(?P&lt;`)</code></span>
<span class="codeline" id="line-341"><code>			b.WriteString(re.Name)</code></span>
<span class="codeline" id="line-342"><code>			b.WriteRune('&gt;')</code></span>
<span class="codeline" id="line-343"><code>		} else {</code></span>
<span class="codeline" id="line-344"><code>			b.WriteRune('(')</code></span>
<span class="codeline" id="line-345"><code>		}</code></span>
<span class="codeline" id="line-346"><code>		if re.Sub[0].Op != OpEmptyMatch {</code></span>
<span class="codeline" id="line-347"><code>			writeRegexp(b, re.Sub[0], flags[re.Sub[0]], flags)</code></span>
<span class="codeline" id="line-348"><code>		}</code></span>
<span class="codeline" id="line-349"><code>		b.WriteRune(')')</code></span>
<span class="codeline" id="line-350"><code>	case OpStar, OpPlus, OpQuest, OpRepeat:</code></span>
<span class="codeline" id="line-351"><code>		p := printFlags(0)</code></span>
<span class="codeline" id="line-352"><code>		sub := re.Sub[0]</code></span>
<span class="codeline" id="line-353"><code>		if sub.Op &gt; OpCapture || sub.Op == OpLiteral &amp;&amp; len(sub.Rune) &gt; 1 {</code></span>
<span class="codeline" id="line-354"><code>			p = flagPrec</code></span>
<span class="codeline" id="line-355"><code>		}</code></span>
<span class="codeline" id="line-356"><code>		writeRegexp(b, sub, p, flags)</code></span>
<span class="codeline" id="line-357"><code></code></span>
<span class="codeline" id="line-358"><code>		switch re.Op {</code></span>
<span class="codeline" id="line-359"><code>		case OpStar:</code></span>
<span class="codeline" id="line-360"><code>			b.WriteRune('*')</code></span>
<span class="codeline" id="line-361"><code>		case OpPlus:</code></span>
<span class="codeline" id="line-362"><code>			b.WriteRune('+')</code></span>
<span class="codeline" id="line-363"><code>		case OpQuest:</code></span>
<span class="codeline" id="line-364"><code>			b.WriteRune('?')</code></span>
<span class="codeline" id="line-365"><code>		case OpRepeat:</code></span>
<span class="codeline" id="line-366"><code>			b.WriteRune('{')</code></span>
<span class="codeline" id="line-367"><code>			b.WriteString(strconv.Itoa(re.Min))</code></span>
<span class="codeline" id="line-368"><code>			if re.Max != re.Min {</code></span>
<span class="codeline" id="line-369"><code>				b.WriteRune(',')</code></span>
<span class="codeline" id="line-370"><code>				if re.Max &gt;= 0 {</code></span>
<span class="codeline" id="line-371"><code>					b.WriteString(strconv.Itoa(re.Max))</code></span>
<span class="codeline" id="line-372"><code>				}</code></span>
<span class="codeline" id="line-373"><code>			}</code></span>
<span class="codeline" id="line-374"><code>			b.WriteRune('}')</code></span>
<span class="codeline" id="line-375"><code>		}</code></span>
<span class="codeline" id="line-376"><code>		if re.Flags&amp;NonGreedy != 0 {</code></span>
<span class="codeline" id="line-377"><code>			b.WriteRune('?')</code></span>
<span class="codeline" id="line-378"><code>		}</code></span>
<span class="codeline" id="line-379"><code>	case OpConcat:</code></span>
<span class="codeline" id="line-380"><code>		for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-381"><code>			p := printFlags(0)</code></span>
<span class="codeline" id="line-382"><code>			if sub.Op == OpAlternate {</code></span>
<span class="codeline" id="line-383"><code>				p = flagPrec</code></span>
<span class="codeline" id="line-384"><code>			}</code></span>
<span class="codeline" id="line-385"><code>			writeRegexp(b, sub, p, flags)</code></span>
<span class="codeline" id="line-386"><code>		}</code></span>
<span class="codeline" id="line-387"><code>	case OpAlternate:</code></span>
<span class="codeline" id="line-388"><code>		for i, sub := range re.Sub {</code></span>
<span class="codeline" id="line-389"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-390"><code>				b.WriteRune('|')</code></span>
<span class="codeline" id="line-391"><code>			}</code></span>
<span class="codeline" id="line-392"><code>			writeRegexp(b, sub, 0, flags)</code></span>
<span class="codeline" id="line-393"><code>		}</code></span>
<span class="codeline" id="line-394"><code>	}</code></span>
<span class="codeline" id="line-395"><code>}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>func (re *Regexp) String() string {</code></span>
<span class="codeline" id="line-398"><code>	var b strings.Builder</code></span>
<span class="codeline" id="line-399"><code>	var flags map[*Regexp]printFlags</code></span>
<span class="codeline" id="line-400"><code>	must, cant := calcFlags(re, &amp;flags)</code></span>
<span class="codeline" id="line-401"><code>	must |= (cant &amp;^ flagI) &lt;&lt; negShift</code></span>
<span class="codeline" id="line-402"><code>	if must != 0 {</code></span>
<span class="codeline" id="line-403"><code>		must |= flagOff</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code>	writeRegexp(&amp;b, re, must, flags)</code></span>
<span class="codeline" id="line-406"><code>	return b.String()</code></span>
<span class="codeline" id="line-407"><code>}</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>const meta = `\.+*?()|[]{}^$`</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>func escape(b *strings.Builder, r rune, force bool) {</code></span>
<span class="codeline" id="line-412"><code>	if unicode.IsPrint(r) {</code></span>
<span class="codeline" id="line-413"><code>		if strings.ContainsRune(meta, r) || force {</code></span>
<span class="codeline" id="line-414"><code>			b.WriteRune('\\')</code></span>
<span class="codeline" id="line-415"><code>		}</code></span>
<span class="codeline" id="line-416"><code>		b.WriteRune(r)</code></span>
<span class="codeline" id="line-417"><code>		return</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code></code></span>
<span class="codeline" id="line-420"><code>	switch r {</code></span>
<span class="codeline" id="line-421"><code>	case '\a':</code></span>
<span class="codeline" id="line-422"><code>		b.WriteString(`\a`)</code></span>
<span class="codeline" id="line-423"><code>	case '\f':</code></span>
<span class="codeline" id="line-424"><code>		b.WriteString(`\f`)</code></span>
<span class="codeline" id="line-425"><code>	case '\n':</code></span>
<span class="codeline" id="line-426"><code>		b.WriteString(`\n`)</code></span>
<span class="codeline" id="line-427"><code>	case '\r':</code></span>
<span class="codeline" id="line-428"><code>		b.WriteString(`\r`)</code></span>
<span class="codeline" id="line-429"><code>	case '\t':</code></span>
<span class="codeline" id="line-430"><code>		b.WriteString(`\t`)</code></span>
<span class="codeline" id="line-431"><code>	case '\v':</code></span>
<span class="codeline" id="line-432"><code>		b.WriteString(`\v`)</code></span>
<span class="codeline" id="line-433"><code>	default:</code></span>
<span class="codeline" id="line-434"><code>		if r &lt; 0x100 {</code></span>
<span class="codeline" id="line-435"><code>			b.WriteString(`\x`)</code></span>
<span class="codeline" id="line-436"><code>			s := strconv.FormatInt(int64(r), 16)</code></span>
<span class="codeline" id="line-437"><code>			if len(s) == 1 {</code></span>
<span class="codeline" id="line-438"><code>				b.WriteRune('0')</code></span>
<span class="codeline" id="line-439"><code>			}</code></span>
<span class="codeline" id="line-440"><code>			b.WriteString(s)</code></span>
<span class="codeline" id="line-441"><code>			break</code></span>
<span class="codeline" id="line-442"><code>		}</code></span>
<span class="codeline" id="line-443"><code>		b.WriteString(`\x{`)</code></span>
<span class="codeline" id="line-444"><code>		b.WriteString(strconv.FormatInt(int64(r), 16))</code></span>
<span class="codeline" id="line-445"><code>		b.WriteString(`}`)</code></span>
<span class="codeline" id="line-446"><code>	}</code></span>
<span class="codeline" id="line-447"><code>}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>// MaxCap walks the regexp to find the maximum capture index.</code></span>
<span class="codeline" id="line-450"><code>func (re *Regexp) MaxCap() int {</code></span>
<span class="codeline" id="line-451"><code>	m := 0</code></span>
<span class="codeline" id="line-452"><code>	if re.Op == OpCapture {</code></span>
<span class="codeline" id="line-453"><code>		m = re.Cap</code></span>
<span class="codeline" id="line-454"><code>	}</code></span>
<span class="codeline" id="line-455"><code>	for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-456"><code>		if n := sub.MaxCap(); m &lt; n {</code></span>
<span class="codeline" id="line-457"><code>			m = n</code></span>
<span class="codeline" id="line-458"><code>		}</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code>	return m</code></span>
<span class="codeline" id="line-461"><code>}</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>// CapNames walks the regexp to find the names of capturing groups.</code></span>
<span class="codeline" id="line-464"><code>func (re *Regexp) CapNames() []string {</code></span>
<span class="codeline" id="line-465"><code>	names := make([]string, re.MaxCap()+1)</code></span>
<span class="codeline" id="line-466"><code>	re.capNames(names)</code></span>
<span class="codeline" id="line-467"><code>	return names</code></span>
<span class="codeline" id="line-468"><code>}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>func (re *Regexp) capNames(names []string) {</code></span>
<span class="codeline" id="line-471"><code>	if re.Op == OpCapture {</code></span>
<span class="codeline" id="line-472"><code>		names[re.Cap] = re.Name</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code>	for _, sub := range re.Sub {</code></span>
<span class="codeline" id="line-475"><code>		sub.capNames(names)</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>