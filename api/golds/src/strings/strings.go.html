<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: strings.go in package strings</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	strings.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/strings.html">strings</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package strings implements simple functions to manipulate UTF-8 encoded strings.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// For information about UTF-8 strings in Go, see https://blog.golang.org/strings.</code></span></div><span class="codeline" id="line-8"><code>package strings</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"internal/bytealg"</code></span>
<span class="codeline" id="line-12"><code>	"unicode"</code></span>
<span class="codeline" id="line-13"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>const maxInt = int(^uint(0) &gt;&gt; 1)</code></span>
<span class="codeline" id="line-17"><code></code></span>
<span class="codeline" id="line-18"><code>// explode splits s into a slice of UTF-8 strings,</code></span>
<span class="codeline" id="line-19"><code>// one string per Unicode character up to a maximum of n (n &lt; 0 means no limit).</code></span>
<span class="codeline" id="line-20"><code>// Invalid UTF-8 bytes are sliced individually.</code></span>
<span class="codeline" id="line-21"><code>func explode(s string, n int) []string {</code></span>
<span class="codeline" id="line-22"><code>	l := utf8.RuneCountInString(s)</code></span>
<span class="codeline" id="line-23"><code>	if n &lt; 0 || n &gt; l {</code></span>
<span class="codeline" id="line-24"><code>		n = l</code></span>
<span class="codeline" id="line-25"><code>	}</code></span>
<span class="codeline" id="line-26"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-27"><code>	for i := 0; i &lt; n-1; i++ {</code></span>
<span class="codeline" id="line-28"><code>		_, size := utf8.DecodeRuneInString(s)</code></span>
<span class="codeline" id="line-29"><code>		a[i] = s[:size]</code></span>
<span class="codeline" id="line-30"><code>		s = s[size:]</code></span>
<span class="codeline" id="line-31"><code>	}</code></span>
<span class="codeline" id="line-32"><code>	if n &gt; 0 {</code></span>
<span class="codeline" id="line-33"><code>		a[n-1] = s</code></span>
<span class="codeline" id="line-34"><code>	}</code></span>
<span class="codeline" id="line-35"><code>	return a</code></span>
<span class="codeline" id="line-36"><code>}</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>// Count counts the number of non-overlapping instances of substr in s.</code></span>
<span class="codeline" id="line-39"><code>// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.</code></span>
<span class="codeline" id="line-40"><code>func Count(s, substr string) int {</code></span>
<span class="codeline" id="line-41"><code>	// special case</code></span>
<span class="codeline" id="line-42"><code>	if len(substr) == 0 {</code></span>
<span class="codeline" id="line-43"><code>		return utf8.RuneCountInString(s) + 1</code></span>
<span class="codeline" id="line-44"><code>	}</code></span>
<span class="codeline" id="line-45"><code>	if len(substr) == 1 {</code></span>
<span class="codeline" id="line-46"><code>		return bytealg.CountString(s, substr[0])</code></span>
<span class="codeline" id="line-47"><code>	}</code></span>
<span class="codeline" id="line-48"><code>	n := 0</code></span>
<span class="codeline" id="line-49"><code>	for {</code></span>
<span class="codeline" id="line-50"><code>		i := Index(s, substr)</code></span>
<span class="codeline" id="line-51"><code>		if i == -1 {</code></span>
<span class="codeline" id="line-52"><code>			return n</code></span>
<span class="codeline" id="line-53"><code>		}</code></span>
<span class="codeline" id="line-54"><code>		n++</code></span>
<span class="codeline" id="line-55"><code>		s = s[i+len(substr):]</code></span>
<span class="codeline" id="line-56"><code>	}</code></span>
<span class="codeline" id="line-57"><code>}</code></span>
<span class="codeline" id="line-58"><code></code></span>
<span class="codeline" id="line-59"><code>// Contains reports whether substr is within s.</code></span>
<span class="codeline" id="line-60"><code>func Contains(s, substr string) bool {</code></span>
<span class="codeline" id="line-61"><code>	return Index(s, substr) &gt;= 0</code></span>
<span class="codeline" id="line-62"><code>}</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// ContainsAny reports whether any Unicode code points in chars are within s.</code></span>
<span class="codeline" id="line-65"><code>func ContainsAny(s, chars string) bool {</code></span>
<span class="codeline" id="line-66"><code>	return IndexAny(s, chars) &gt;= 0</code></span>
<span class="codeline" id="line-67"><code>}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>// ContainsRune reports whether the Unicode code point r is within s.</code></span>
<span class="codeline" id="line-70"><code>func ContainsRune(s string, r rune) bool {</code></span>
<span class="codeline" id="line-71"><code>	return IndexRune(s, r) &gt;= 0</code></span>
<span class="codeline" id="line-72"><code>}</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>// ContainsFunc reports whether any Unicode code points r within s satisfy f(r).</code></span>
<span class="codeline" id="line-75"><code>func ContainsFunc(s string, f func(rune) bool) bool {</code></span>
<span class="codeline" id="line-76"><code>	return IndexFunc(s, f) &gt;= 0</code></span>
<span class="codeline" id="line-77"><code>}</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>// LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</code></span>
<span class="codeline" id="line-80"><code>func LastIndex(s, substr string) int {</code></span>
<span class="codeline" id="line-81"><code>	n := len(substr)</code></span>
<span class="codeline" id="line-82"><code>	switch {</code></span>
<span class="codeline" id="line-83"><code>	case n == 0:</code></span>
<span class="codeline" id="line-84"><code>		return len(s)</code></span>
<span class="codeline" id="line-85"><code>	case n == 1:</code></span>
<span class="codeline" id="line-86"><code>		return bytealg.LastIndexByteString(s, substr[0])</code></span>
<span class="codeline" id="line-87"><code>	case n == len(s):</code></span>
<span class="codeline" id="line-88"><code>		if substr == s {</code></span>
<span class="codeline" id="line-89"><code>			return 0</code></span>
<span class="codeline" id="line-90"><code>		}</code></span>
<span class="codeline" id="line-91"><code>		return -1</code></span>
<span class="codeline" id="line-92"><code>	case n &gt; len(s):</code></span>
<span class="codeline" id="line-93"><code>		return -1</code></span>
<span class="codeline" id="line-94"><code>	}</code></span>
<span class="codeline" id="line-95"><code>	// Rabin-Karp search from the end of the string</code></span>
<span class="codeline" id="line-96"><code>	hashss, pow := bytealg.HashStrRev(substr)</code></span>
<span class="codeline" id="line-97"><code>	last := len(s) - n</code></span>
<span class="codeline" id="line-98"><code>	var h uint32</code></span>
<span class="codeline" id="line-99"><code>	for i := len(s) - 1; i &gt;= last; i-- {</code></span>
<span class="codeline" id="line-100"><code>		h = h*bytealg.PrimeRK + uint32(s[i])</code></span>
<span class="codeline" id="line-101"><code>	}</code></span>
<span class="codeline" id="line-102"><code>	if h == hashss &amp;&amp; s[last:] == substr {</code></span>
<span class="codeline" id="line-103"><code>		return last</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code>	for i := last - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-106"><code>		h *= bytealg.PrimeRK</code></span>
<span class="codeline" id="line-107"><code>		h += uint32(s[i])</code></span>
<span class="codeline" id="line-108"><code>		h -= pow * uint32(s[i+n])</code></span>
<span class="codeline" id="line-109"><code>		if h == hashss &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-110"><code>			return i</code></span>
<span class="codeline" id="line-111"><code>		}</code></span>
<span class="codeline" id="line-112"><code>	}</code></span>
<span class="codeline" id="line-113"><code>	return -1</code></span>
<span class="codeline" id="line-114"><code>}</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>// IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.</code></span>
<span class="codeline" id="line-117"><code>func IndexByte(s string, c byte) int {</code></span>
<span class="codeline" id="line-118"><code>	return bytealg.IndexByteString(s, c)</code></span>
<span class="codeline" id="line-119"><code>}</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>// IndexRune returns the index of the first instance of the Unicode code point</code></span>
<span class="codeline" id="line-122"><code>// r, or -1 if rune is not present in s.</code></span>
<span class="codeline" id="line-123"><code>// If r is utf8.RuneError, it returns the first instance of any</code></span>
<span class="codeline" id="line-124"><code>// invalid UTF-8 byte sequence.</code></span>
<span class="codeline" id="line-125"><code>func IndexRune(s string, r rune) int {</code></span>
<span class="codeline" id="line-126"><code>	switch {</code></span>
<span class="codeline" id="line-127"><code>	case 0 &lt;= r &amp;&amp; r &lt; utf8.RuneSelf:</code></span>
<span class="codeline" id="line-128"><code>		return IndexByte(s, byte(r))</code></span>
<span class="codeline" id="line-129"><code>	case r == utf8.RuneError:</code></span>
<span class="codeline" id="line-130"><code>		for i, r := range s {</code></span>
<span class="codeline" id="line-131"><code>			if r == utf8.RuneError {</code></span>
<span class="codeline" id="line-132"><code>				return i</code></span>
<span class="codeline" id="line-133"><code>			}</code></span>
<span class="codeline" id="line-134"><code>		}</code></span>
<span class="codeline" id="line-135"><code>		return -1</code></span>
<span class="codeline" id="line-136"><code>	case !utf8.ValidRune(r):</code></span>
<span class="codeline" id="line-137"><code>		return -1</code></span>
<span class="codeline" id="line-138"><code>	default:</code></span>
<span class="codeline" id="line-139"><code>		return Index(s, string(r))</code></span>
<span class="codeline" id="line-140"><code>	}</code></span>
<span class="codeline" id="line-141"><code>}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// IndexAny returns the index of the first instance of any Unicode code point</code></span>
<span class="codeline" id="line-144"><code>// from chars in s, or -1 if no Unicode code point from chars is present in s.</code></span>
<span class="codeline" id="line-145"><code>func IndexAny(s, chars string) int {</code></span>
<span class="codeline" id="line-146"><code>	if chars == "" {</code></span>
<span class="codeline" id="line-147"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-148"><code>		return -1</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code>	if len(chars) == 1 {</code></span>
<span class="codeline" id="line-151"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-152"><code>		r := rune(chars[0])</code></span>
<span class="codeline" id="line-153"><code>		if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-154"><code>			r = utf8.RuneError</code></span>
<span class="codeline" id="line-155"><code>		}</code></span>
<span class="codeline" id="line-156"><code>		return IndexRune(s, r)</code></span>
<span class="codeline" id="line-157"><code>	}</code></span>
<span class="codeline" id="line-158"><code>	if len(s) &gt; 8 {</code></span>
<span class="codeline" id="line-159"><code>		if as, isASCII := makeASCIISet(chars); isASCII {</code></span>
<span class="codeline" id="line-160"><code>			for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-161"><code>				if as.contains(s[i]) {</code></span>
<span class="codeline" id="line-162"><code>					return i</code></span>
<span class="codeline" id="line-163"><code>				}</code></span>
<span class="codeline" id="line-164"><code>			}</code></span>
<span class="codeline" id="line-165"><code>			return -1</code></span>
<span class="codeline" id="line-166"><code>		}</code></span>
<span class="codeline" id="line-167"><code>	}</code></span>
<span class="codeline" id="line-168"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-169"><code>		if IndexRune(chars, c) &gt;= 0 {</code></span>
<span class="codeline" id="line-170"><code>			return i</code></span>
<span class="codeline" id="line-171"><code>		}</code></span>
<span class="codeline" id="line-172"><code>	}</code></span>
<span class="codeline" id="line-173"><code>	return -1</code></span>
<span class="codeline" id="line-174"><code>}</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>// LastIndexAny returns the index of the last instance of any Unicode code</code></span>
<span class="codeline" id="line-177"><code>// point from chars in s, or -1 if no Unicode code point from chars is</code></span>
<span class="codeline" id="line-178"><code>// present in s.</code></span>
<span class="codeline" id="line-179"><code>func LastIndexAny(s, chars string) int {</code></span>
<span class="codeline" id="line-180"><code>	if chars == "" {</code></span>
<span class="codeline" id="line-181"><code>		// Avoid scanning all of s.</code></span>
<span class="codeline" id="line-182"><code>		return -1</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code>	if len(s) == 1 {</code></span>
<span class="codeline" id="line-185"><code>		rc := rune(s[0])</code></span>
<span class="codeline" id="line-186"><code>		if rc &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-187"><code>			rc = utf8.RuneError</code></span>
<span class="codeline" id="line-188"><code>		}</code></span>
<span class="codeline" id="line-189"><code>		if IndexRune(chars, rc) &gt;= 0 {</code></span>
<span class="codeline" id="line-190"><code>			return 0</code></span>
<span class="codeline" id="line-191"><code>		}</code></span>
<span class="codeline" id="line-192"><code>		return -1</code></span>
<span class="codeline" id="line-193"><code>	}</code></span>
<span class="codeline" id="line-194"><code>	if len(s) &gt; 8 {</code></span>
<span class="codeline" id="line-195"><code>		if as, isASCII := makeASCIISet(chars); isASCII {</code></span>
<span class="codeline" id="line-196"><code>			for i := len(s) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-197"><code>				if as.contains(s[i]) {</code></span>
<span class="codeline" id="line-198"><code>					return i</code></span>
<span class="codeline" id="line-199"><code>				}</code></span>
<span class="codeline" id="line-200"><code>			}</code></span>
<span class="codeline" id="line-201"><code>			return -1</code></span>
<span class="codeline" id="line-202"><code>		}</code></span>
<span class="codeline" id="line-203"><code>	}</code></span>
<span class="codeline" id="line-204"><code>	if len(chars) == 1 {</code></span>
<span class="codeline" id="line-205"><code>		rc := rune(chars[0])</code></span>
<span class="codeline" id="line-206"><code>		if rc &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-207"><code>			rc = utf8.RuneError</code></span>
<span class="codeline" id="line-208"><code>		}</code></span>
<span class="codeline" id="line-209"><code>		for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-210"><code>			r, size := utf8.DecodeLastRuneInString(s[:i])</code></span>
<span class="codeline" id="line-211"><code>			i -= size</code></span>
<span class="codeline" id="line-212"><code>			if rc == r {</code></span>
<span class="codeline" id="line-213"><code>				return i</code></span>
<span class="codeline" id="line-214"><code>			}</code></span>
<span class="codeline" id="line-215"><code>		}</code></span>
<span class="codeline" id="line-216"><code>		return -1</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-219"><code>		r, size := utf8.DecodeLastRuneInString(s[:i])</code></span>
<span class="codeline" id="line-220"><code>		i -= size</code></span>
<span class="codeline" id="line-221"><code>		if IndexRune(chars, r) &gt;= 0 {</code></span>
<span class="codeline" id="line-222"><code>			return i</code></span>
<span class="codeline" id="line-223"><code>		}</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code>	return -1</code></span>
<span class="codeline" id="line-226"><code>}</code></span>
<span class="codeline" id="line-227"><code></code></span>
<span class="codeline" id="line-228"><code>// LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</code></span>
<span class="codeline" id="line-229"><code>func LastIndexByte(s string, c byte) int {</code></span>
<span class="codeline" id="line-230"><code>	return bytealg.LastIndexByteString(s, c)</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>// Generic split: splits after each instance of sep,</code></span>
<span class="codeline" id="line-234"><code>// including sepSave bytes of sep in the subarrays.</code></span>
<span class="codeline" id="line-235"><code>func genSplit(s, sep string, sepSave, n int) []string {</code></span>
<span class="codeline" id="line-236"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-237"><code>		return nil</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code>	if sep == "" {</code></span>
<span class="codeline" id="line-240"><code>		return explode(s, n)</code></span>
<span class="codeline" id="line-241"><code>	}</code></span>
<span class="codeline" id="line-242"><code>	if n &lt; 0 {</code></span>
<span class="codeline" id="line-243"><code>		n = Count(s, sep) + 1</code></span>
<span class="codeline" id="line-244"><code>	}</code></span>
<span class="codeline" id="line-245"><code></code></span>
<span class="codeline" id="line-246"><code>	if n &gt; len(s)+1 {</code></span>
<span class="codeline" id="line-247"><code>		n = len(s) + 1</code></span>
<span class="codeline" id="line-248"><code>	}</code></span>
<span class="codeline" id="line-249"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-250"><code>	n--</code></span>
<span class="codeline" id="line-251"><code>	i := 0</code></span>
<span class="codeline" id="line-252"><code>	for i &lt; n {</code></span>
<span class="codeline" id="line-253"><code>		m := Index(s, sep)</code></span>
<span class="codeline" id="line-254"><code>		if m &lt; 0 {</code></span>
<span class="codeline" id="line-255"><code>			break</code></span>
<span class="codeline" id="line-256"><code>		}</code></span>
<span class="codeline" id="line-257"><code>		a[i] = s[:m+sepSave]</code></span>
<span class="codeline" id="line-258"><code>		s = s[m+len(sep):]</code></span>
<span class="codeline" id="line-259"><code>		i++</code></span>
<span class="codeline" id="line-260"><code>	}</code></span>
<span class="codeline" id="line-261"><code>	a[i] = s</code></span>
<span class="codeline" id="line-262"><code>	return a[:i+1]</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// SplitN slices s into substrings separated by sep and returns a slice of</code></span>
<span class="codeline" id="line-266"><code>// the substrings between those separators.</code></span>
<span class="codeline" id="line-267"><code>//</code></span>
<span class="codeline" id="line-268"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-269"><code>//</code></span>
<span class="codeline" id="line-270"><code>//	n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-271"><code>//	n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-272"><code>//	n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-273"><code>//</code></span>
<span class="codeline" id="line-274"><code>// Edge cases for s and sep (for example, empty strings) are handled</code></span>
<span class="codeline" id="line-275"><code>// as described in the documentation for [Split].</code></span>
<span class="codeline" id="line-276"><code>//</code></span>
<span class="codeline" id="line-277"><code>// To split around the first instance of a separator, see Cut.</code></span>
<span class="codeline" id="line-278"><code>func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>// SplitAfterN slices s into substrings after each instance of sep and</code></span>
<span class="codeline" id="line-281"><code>// returns a slice of those substrings.</code></span>
<span class="codeline" id="line-282"><code>//</code></span>
<span class="codeline" id="line-283"><code>// The count determines the number of substrings to return:</code></span>
<span class="codeline" id="line-284"><code>//</code></span>
<span class="codeline" id="line-285"><code>//	n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.</code></span>
<span class="codeline" id="line-286"><code>//	n == 0: the result is nil (zero substrings)</code></span>
<span class="codeline" id="line-287"><code>//	n &lt; 0: all substrings</code></span>
<span class="codeline" id="line-288"><code>//</code></span>
<span class="codeline" id="line-289"><code>// Edge cases for s and sep (for example, empty strings) are handled</code></span>
<span class="codeline" id="line-290"><code>// as described in the documentation for SplitAfter.</code></span>
<span class="codeline" id="line-291"><code>func SplitAfterN(s, sep string, n int) []string {</code></span>
<span class="codeline" id="line-292"><code>	return genSplit(s, sep, len(sep), n)</code></span>
<span class="codeline" id="line-293"><code>}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>// Split slices s into all substrings separated by sep and returns a slice of</code></span>
<span class="codeline" id="line-296"><code>// the substrings between those separators.</code></span>
<span class="codeline" id="line-297"><code>//</code></span>
<span class="codeline" id="line-298"><code>// If s does not contain sep and sep is not empty, Split returns a</code></span>
<span class="codeline" id="line-299"><code>// slice of length 1 whose only element is s.</code></span>
<span class="codeline" id="line-300"><code>//</code></span>
<span class="codeline" id="line-301"><code>// If sep is empty, Split splits after each UTF-8 sequence. If both s</code></span>
<span class="codeline" id="line-302"><code>// and sep are empty, Split returns an empty slice.</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>// It is equivalent to [SplitN] with a count of -1.</code></span>
<span class="codeline" id="line-305"><code>//</code></span>
<span class="codeline" id="line-306"><code>// To split around the first instance of a separator, see Cut.</code></span>
<span class="codeline" id="line-307"><code>func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>// SplitAfter slices s into all substrings after each instance of sep and</code></span>
<span class="codeline" id="line-310"><code>// returns a slice of those substrings.</code></span>
<span class="codeline" id="line-311"><code>//</code></span>
<span class="codeline" id="line-312"><code>// If s does not contain sep and sep is not empty, SplitAfter returns</code></span>
<span class="codeline" id="line-313"><code>// a slice of length 1 whose only element is s.</code></span>
<span class="codeline" id="line-314"><code>//</code></span>
<span class="codeline" id="line-315"><code>// If sep is empty, SplitAfter splits after each UTF-8 sequence. If</code></span>
<span class="codeline" id="line-316"><code>// both s and sep are empty, SplitAfter returns an empty slice.</code></span>
<span class="codeline" id="line-317"><code>//</code></span>
<span class="codeline" id="line-318"><code>// It is equivalent to [SplitAfterN] with a count of -1.</code></span>
<span class="codeline" id="line-319"><code>func SplitAfter(s, sep string) []string {</code></span>
<span class="codeline" id="line-320"><code>	return genSplit(s, sep, len(sep), -1)</code></span>
<span class="codeline" id="line-321"><code>}</code></span>
<span class="codeline" id="line-322"><code></code></span>
<span class="codeline" id="line-323"><code>var asciiSpace = [256]uint8{'\t': 1, '\n': 1, '\v': 1, '\f': 1, '\r': 1, ' ': 1}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>// Fields splits the string s around each instance of one or more consecutive white space</code></span>
<span class="codeline" id="line-326"><code>// characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an</code></span>
<span class="codeline" id="line-327"><code>// empty slice if s contains only white space.</code></span>
<span class="codeline" id="line-328"><code>func Fields(s string) []string {</code></span>
<span class="codeline" id="line-329"><code>	// First count the fields.</code></span>
<span class="codeline" id="line-330"><code>	// This is an exact count if s is ASCII, otherwise it is an approximation.</code></span>
<span class="codeline" id="line-331"><code>	n := 0</code></span>
<span class="codeline" id="line-332"><code>	wasSpace := 1</code></span>
<span class="codeline" id="line-333"><code>	// setBits is used to track which bits are set in the bytes of s.</code></span>
<span class="codeline" id="line-334"><code>	setBits := uint8(0)</code></span>
<span class="codeline" id="line-335"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-336"><code>		r := s[i]</code></span>
<span class="codeline" id="line-337"><code>		setBits |= r</code></span>
<span class="codeline" id="line-338"><code>		isSpace := int(asciiSpace[r])</code></span>
<span class="codeline" id="line-339"><code>		n += wasSpace &amp; ^isSpace</code></span>
<span class="codeline" id="line-340"><code>		wasSpace = isSpace</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>	if setBits &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-344"><code>		// Some runes in the input string are not ASCII.</code></span>
<span class="codeline" id="line-345"><code>		return FieldsFunc(s, unicode.IsSpace)</code></span>
<span class="codeline" id="line-346"><code>	}</code></span>
<span class="codeline" id="line-347"><code>	// ASCII fast path</code></span>
<span class="codeline" id="line-348"><code>	a := make([]string, n)</code></span>
<span class="codeline" id="line-349"><code>	na := 0</code></span>
<span class="codeline" id="line-350"><code>	fieldStart := 0</code></span>
<span class="codeline" id="line-351"><code>	i := 0</code></span>
<span class="codeline" id="line-352"><code>	// Skip spaces in the front of the input.</code></span>
<span class="codeline" id="line-353"><code>	for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 {</code></span>
<span class="codeline" id="line-354"><code>		i++</code></span>
<span class="codeline" id="line-355"><code>	}</code></span>
<span class="codeline" id="line-356"><code>	fieldStart = i</code></span>
<span class="codeline" id="line-357"><code>	for i &lt; len(s) {</code></span>
<span class="codeline" id="line-358"><code>		if asciiSpace[s[i]] == 0 {</code></span>
<span class="codeline" id="line-359"><code>			i++</code></span>
<span class="codeline" id="line-360"><code>			continue</code></span>
<span class="codeline" id="line-361"><code>		}</code></span>
<span class="codeline" id="line-362"><code>		a[na] = s[fieldStart:i]</code></span>
<span class="codeline" id="line-363"><code>		na++</code></span>
<span class="codeline" id="line-364"><code>		i++</code></span>
<span class="codeline" id="line-365"><code>		// Skip spaces in between fields.</code></span>
<span class="codeline" id="line-366"><code>		for i &lt; len(s) &amp;&amp; asciiSpace[s[i]] != 0 {</code></span>
<span class="codeline" id="line-367"><code>			i++</code></span>
<span class="codeline" id="line-368"><code>		}</code></span>
<span class="codeline" id="line-369"><code>		fieldStart = i</code></span>
<span class="codeline" id="line-370"><code>	}</code></span>
<span class="codeline" id="line-371"><code>	if fieldStart &lt; len(s) { // Last field might end at EOF.</code></span>
<span class="codeline" id="line-372"><code>		a[na] = s[fieldStart:]</code></span>
<span class="codeline" id="line-373"><code>	}</code></span>
<span class="codeline" id="line-374"><code>	return a</code></span>
<span class="codeline" id="line-375"><code>}</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>// FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)</code></span>
<span class="codeline" id="line-378"><code>// and returns an array of slices of s. If all code points in s satisfy f(c) or the</code></span>
<span class="codeline" id="line-379"><code>// string is empty, an empty slice is returned.</code></span>
<span class="codeline" id="line-380"><code>//</code></span>
<span class="codeline" id="line-381"><code>// FieldsFunc makes no guarantees about the order in which it calls f(c)</code></span>
<span class="codeline" id="line-382"><code>// and assumes that f always returns the same value for a given c.</code></span>
<span class="codeline" id="line-383"><code>func FieldsFunc(s string, f func(rune) bool) []string {</code></span>
<span class="codeline" id="line-384"><code>	// A span is used to record a slice of s of the form s[start:end].</code></span>
<span class="codeline" id="line-385"><code>	// The start index is inclusive and the end index is exclusive.</code></span>
<span class="codeline" id="line-386"><code>	type span struct {</code></span>
<span class="codeline" id="line-387"><code>		start int</code></span>
<span class="codeline" id="line-388"><code>		end   int</code></span>
<span class="codeline" id="line-389"><code>	}</code></span>
<span class="codeline" id="line-390"><code>	spans := make([]span, 0, 32)</code></span>
<span class="codeline" id="line-391"><code></code></span>
<span class="codeline" id="line-392"><code>	// Find the field start and end indices.</code></span>
<span class="codeline" id="line-393"><code>	// Doing this in a separate pass (rather than slicing the string s</code></span>
<span class="codeline" id="line-394"><code>	// and collecting the result substrings right away) is significantly</code></span>
<span class="codeline" id="line-395"><code>	// more efficient, possibly due to cache effects.</code></span>
<span class="codeline" id="line-396"><code>	start := -1 // valid span start if &gt;= 0</code></span>
<span class="codeline" id="line-397"><code>	for end, rune := range s {</code></span>
<span class="codeline" id="line-398"><code>		if f(rune) {</code></span>
<span class="codeline" id="line-399"><code>			if start &gt;= 0 {</code></span>
<span class="codeline" id="line-400"><code>				spans = append(spans, span{start, end})</code></span>
<span class="codeline" id="line-401"><code>				// Set start to a negative value.</code></span>
<span class="codeline" id="line-402"><code>				// Note: using -1 here consistently and reproducibly</code></span>
<span class="codeline" id="line-403"><code>				// slows down this code by a several percent on amd64.</code></span>
<span class="codeline" id="line-404"><code>				start = ^start</code></span>
<span class="codeline" id="line-405"><code>			}</code></span>
<span class="codeline" id="line-406"><code>		} else {</code></span>
<span class="codeline" id="line-407"><code>			if start &lt; 0 {</code></span>
<span class="codeline" id="line-408"><code>				start = end</code></span>
<span class="codeline" id="line-409"><code>			}</code></span>
<span class="codeline" id="line-410"><code>		}</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	// Last field might end at EOF.</code></span>
<span class="codeline" id="line-414"><code>	if start &gt;= 0 {</code></span>
<span class="codeline" id="line-415"><code>		spans = append(spans, span{start, len(s)})</code></span>
<span class="codeline" id="line-416"><code>	}</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>	// Create strings from recorded field indices.</code></span>
<span class="codeline" id="line-419"><code>	a := make([]string, len(spans))</code></span>
<span class="codeline" id="line-420"><code>	for i, span := range spans {</code></span>
<span class="codeline" id="line-421"><code>		a[i] = s[span.start:span.end]</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>	return a</code></span>
<span class="codeline" id="line-425"><code>}</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>// Join concatenates the elements of its first argument to create a single string. The separator</code></span>
<span class="codeline" id="line-428"><code>// string sep is placed between elements in the resulting string.</code></span>
<span class="codeline" id="line-429"><code>func Join(elems []string, sep string) string {</code></span>
<span class="codeline" id="line-430"><code>	switch len(elems) {</code></span>
<span class="codeline" id="line-431"><code>	case 0:</code></span>
<span class="codeline" id="line-432"><code>		return ""</code></span>
<span class="codeline" id="line-433"><code>	case 1:</code></span>
<span class="codeline" id="line-434"><code>		return elems[0]</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	var n int</code></span>
<span class="codeline" id="line-438"><code>	if len(sep) &gt; 0 {</code></span>
<span class="codeline" id="line-439"><code>		if len(sep) &gt;= maxInt/(len(elems)-1) {</code></span>
<span class="codeline" id="line-440"><code>			panic("strings: Join output length overflow")</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>		n += len(sep) * (len(elems) - 1)</code></span>
<span class="codeline" id="line-443"><code>	}</code></span>
<span class="codeline" id="line-444"><code>	for _, elem := range elems {</code></span>
<span class="codeline" id="line-445"><code>		if len(elem) &gt; maxInt-n {</code></span>
<span class="codeline" id="line-446"><code>			panic("strings: Join output length overflow")</code></span>
<span class="codeline" id="line-447"><code>		}</code></span>
<span class="codeline" id="line-448"><code>		n += len(elem)</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code></code></span>
<span class="codeline" id="line-451"><code>	var b Builder</code></span>
<span class="codeline" id="line-452"><code>	b.Grow(n)</code></span>
<span class="codeline" id="line-453"><code>	b.WriteString(elems[0])</code></span>
<span class="codeline" id="line-454"><code>	for _, s := range elems[1:] {</code></span>
<span class="codeline" id="line-455"><code>		b.WriteString(sep)</code></span>
<span class="codeline" id="line-456"><code>		b.WriteString(s)</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code>	return b.String()</code></span>
<span class="codeline" id="line-459"><code>}</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>// HasPrefix reports whether the string s begins with prefix.</code></span>
<span class="codeline" id="line-462"><code>func HasPrefix(s, prefix string) bool {</code></span>
<span class="codeline" id="line-463"><code>	return len(s) &gt;= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix</code></span>
<span class="codeline" id="line-464"><code>}</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>// HasSuffix reports whether the string s ends with suffix.</code></span>
<span class="codeline" id="line-467"><code>func HasSuffix(s, suffix string) bool {</code></span>
<span class="codeline" id="line-468"><code>	return len(s) &gt;= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix</code></span>
<span class="codeline" id="line-469"><code>}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>// Map returns a copy of the string s with all its characters modified</code></span>
<span class="codeline" id="line-472"><code>// according to the mapping function. If mapping returns a negative value, the character is</code></span>
<span class="codeline" id="line-473"><code>// dropped from the string with no replacement.</code></span>
<span class="codeline" id="line-474"><code>func Map(mapping func(rune) rune, s string) string {</code></span>
<span class="codeline" id="line-475"><code>	// In the worst case, the string can grow when mapped, making</code></span>
<span class="codeline" id="line-476"><code>	// things unpleasant. But it's so rare we barge in assuming it's</code></span>
<span class="codeline" id="line-477"><code>	// fine. It could also shrink but that falls out naturally.</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>	// The output buffer b is initialized on demand, the first</code></span>
<span class="codeline" id="line-480"><code>	// time a character differs.</code></span>
<span class="codeline" id="line-481"><code>	var b Builder</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-484"><code>		r := mapping(c)</code></span>
<span class="codeline" id="line-485"><code>		if r == c &amp;&amp; c != utf8.RuneError {</code></span>
<span class="codeline" id="line-486"><code>			continue</code></span>
<span class="codeline" id="line-487"><code>		}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>		var width int</code></span>
<span class="codeline" id="line-490"><code>		if c == utf8.RuneError {</code></span>
<span class="codeline" id="line-491"><code>			c, width = utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-492"><code>			if width != 1 &amp;&amp; r == c {</code></span>
<span class="codeline" id="line-493"><code>				continue</code></span>
<span class="codeline" id="line-494"><code>			}</code></span>
<span class="codeline" id="line-495"><code>		} else {</code></span>
<span class="codeline" id="line-496"><code>			width = utf8.RuneLen(c)</code></span>
<span class="codeline" id="line-497"><code>		}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>		b.Grow(len(s) + utf8.UTFMax)</code></span>
<span class="codeline" id="line-500"><code>		b.WriteString(s[:i])</code></span>
<span class="codeline" id="line-501"><code>		if r &gt;= 0 {</code></span>
<span class="codeline" id="line-502"><code>			b.WriteRune(r)</code></span>
<span class="codeline" id="line-503"><code>		}</code></span>
<span class="codeline" id="line-504"><code></code></span>
<span class="codeline" id="line-505"><code>		s = s[i+width:]</code></span>
<span class="codeline" id="line-506"><code>		break</code></span>
<span class="codeline" id="line-507"><code>	}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	// Fast path for unchanged input</code></span>
<span class="codeline" id="line-510"><code>	if b.Cap() == 0 { // didn't call b.Grow above</code></span>
<span class="codeline" id="line-511"><code>		return s</code></span>
<span class="codeline" id="line-512"><code>	}</code></span>
<span class="codeline" id="line-513"><code></code></span>
<span class="codeline" id="line-514"><code>	for _, c := range s {</code></span>
<span class="codeline" id="line-515"><code>		r := mapping(c)</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>		if r &gt;= 0 {</code></span>
<span class="codeline" id="line-518"><code>			// common case</code></span>
<span class="codeline" id="line-519"><code>			// Due to inlining, it is more performant to determine if WriteByte should be</code></span>
<span class="codeline" id="line-520"><code>			// invoked rather than always call WriteRune</code></span>
<span class="codeline" id="line-521"><code>			if r &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-522"><code>				b.WriteByte(byte(r))</code></span>
<span class="codeline" id="line-523"><code>			} else {</code></span>
<span class="codeline" id="line-524"><code>				// r is not an ASCII rune.</code></span>
<span class="codeline" id="line-525"><code>				b.WriteRune(r)</code></span>
<span class="codeline" id="line-526"><code>			}</code></span>
<span class="codeline" id="line-527"><code>		}</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>	return b.String()</code></span>
<span class="codeline" id="line-531"><code>}</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>// Repeat returns a new string consisting of count copies of the string s.</code></span>
<span class="codeline" id="line-534"><code>//</code></span>
<span class="codeline" id="line-535"><code>// It panics if count is negative or if the result of (len(s) * count)</code></span>
<span class="codeline" id="line-536"><code>// overflows.</code></span>
<span class="codeline" id="line-537"><code>func Repeat(s string, count int) string {</code></span>
<span class="codeline" id="line-538"><code>	switch count {</code></span>
<span class="codeline" id="line-539"><code>	case 0:</code></span>
<span class="codeline" id="line-540"><code>		return ""</code></span>
<span class="codeline" id="line-541"><code>	case 1:</code></span>
<span class="codeline" id="line-542"><code>		return s</code></span>
<span class="codeline" id="line-543"><code>	}</code></span>
<span class="codeline" id="line-544"><code></code></span>
<span class="codeline" id="line-545"><code>	// Since we cannot return an error on overflow,</code></span>
<span class="codeline" id="line-546"><code>	// we should panic if the repeat will generate an overflow.</code></span>
<span class="codeline" id="line-547"><code>	// See golang.org/issue/16237.</code></span>
<span class="codeline" id="line-548"><code>	if count &lt; 0 {</code></span>
<span class="codeline" id="line-549"><code>		panic("strings: negative Repeat count")</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code>	if len(s) &gt;= maxInt/count {</code></span>
<span class="codeline" id="line-552"><code>		panic("strings: Repeat output length overflow")</code></span>
<span class="codeline" id="line-553"><code>	}</code></span>
<span class="codeline" id="line-554"><code>	n := len(s) * count</code></span>
<span class="codeline" id="line-555"><code></code></span>
<span class="codeline" id="line-556"><code>	if len(s) == 0 {</code></span>
<span class="codeline" id="line-557"><code>		return ""</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>	// Past a certain chunk size it is counterproductive to use</code></span>
<span class="codeline" id="line-561"><code>	// larger chunks as the source of the write, as when the source</code></span>
<span class="codeline" id="line-562"><code>	// is too large we are basically just thrashing the CPU D-cache.</code></span>
<span class="codeline" id="line-563"><code>	// So if the result length is larger than an empirically-found</code></span>
<span class="codeline" id="line-564"><code>	// limit (8KB), we stop growing the source string once the limit</code></span>
<span class="codeline" id="line-565"><code>	// is reached and keep reusing the same source string - that</code></span>
<span class="codeline" id="line-566"><code>	// should therefore be always resident in the L1 cache - until we</code></span>
<span class="codeline" id="line-567"><code>	// have completed the construction of the result.</code></span>
<span class="codeline" id="line-568"><code>	// This yields significant speedups (up to +100%) in cases where</code></span>
<span class="codeline" id="line-569"><code>	// the result length is large (roughly, over L2 cache size).</code></span>
<span class="codeline" id="line-570"><code>	const chunkLimit = 8 * 1024</code></span>
<span class="codeline" id="line-571"><code>	chunkMax := n</code></span>
<span class="codeline" id="line-572"><code>	if n &gt; chunkLimit {</code></span>
<span class="codeline" id="line-573"><code>		chunkMax = chunkLimit / len(s) * len(s)</code></span>
<span class="codeline" id="line-574"><code>		if chunkMax == 0 {</code></span>
<span class="codeline" id="line-575"><code>			chunkMax = len(s)</code></span>
<span class="codeline" id="line-576"><code>		}</code></span>
<span class="codeline" id="line-577"><code>	}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>	var b Builder</code></span>
<span class="codeline" id="line-580"><code>	b.Grow(n)</code></span>
<span class="codeline" id="line-581"><code>	b.WriteString(s)</code></span>
<span class="codeline" id="line-582"><code>	for b.Len() &lt; n {</code></span>
<span class="codeline" id="line-583"><code>		chunk := n - b.Len()</code></span>
<span class="codeline" id="line-584"><code>		if chunk &gt; b.Len() {</code></span>
<span class="codeline" id="line-585"><code>			chunk = b.Len()</code></span>
<span class="codeline" id="line-586"><code>		}</code></span>
<span class="codeline" id="line-587"><code>		if chunk &gt; chunkMax {</code></span>
<span class="codeline" id="line-588"><code>			chunk = chunkMax</code></span>
<span class="codeline" id="line-589"><code>		}</code></span>
<span class="codeline" id="line-590"><code>		b.WriteString(b.String()[:chunk])</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>	return b.String()</code></span>
<span class="codeline" id="line-593"><code>}</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>// ToUpper returns s with all Unicode letters mapped to their upper case.</code></span>
<span class="codeline" id="line-596"><code>func ToUpper(s string) string {</code></span>
<span class="codeline" id="line-597"><code>	isASCII, hasLower := true, false</code></span>
<span class="codeline" id="line-598"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-599"><code>		c := s[i]</code></span>
<span class="codeline" id="line-600"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-601"><code>			isASCII = false</code></span>
<span class="codeline" id="line-602"><code>			break</code></span>
<span class="codeline" id="line-603"><code>		}</code></span>
<span class="codeline" id="line-604"><code>		hasLower = hasLower || ('a' &lt;= c &amp;&amp; c &lt;= 'z')</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	if isASCII { // optimize for ASCII-only strings.</code></span>
<span class="codeline" id="line-608"><code>		if !hasLower {</code></span>
<span class="codeline" id="line-609"><code>			return s</code></span>
<span class="codeline" id="line-610"><code>		}</code></span>
<span class="codeline" id="line-611"><code>		var (</code></span>
<span class="codeline" id="line-612"><code>			b   Builder</code></span>
<span class="codeline" id="line-613"><code>			pos int</code></span>
<span class="codeline" id="line-614"><code>		)</code></span>
<span class="codeline" id="line-615"><code>		b.Grow(len(s))</code></span>
<span class="codeline" id="line-616"><code>		for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-617"><code>			c := s[i]</code></span>
<span class="codeline" id="line-618"><code>			if 'a' &lt;= c &amp;&amp; c &lt;= 'z' {</code></span>
<span class="codeline" id="line-619"><code>				c -= 'a' - 'A'</code></span>
<span class="codeline" id="line-620"><code>				if pos &lt; i {</code></span>
<span class="codeline" id="line-621"><code>					b.WriteString(s[pos:i])</code></span>
<span class="codeline" id="line-622"><code>				}</code></span>
<span class="codeline" id="line-623"><code>				b.WriteByte(c)</code></span>
<span class="codeline" id="line-624"><code>				pos = i + 1</code></span>
<span class="codeline" id="line-625"><code>			}</code></span>
<span class="codeline" id="line-626"><code>		}</code></span>
<span class="codeline" id="line-627"><code>		if pos &lt; len(s) {</code></span>
<span class="codeline" id="line-628"><code>			b.WriteString(s[pos:])</code></span>
<span class="codeline" id="line-629"><code>		}</code></span>
<span class="codeline" id="line-630"><code>		return b.String()</code></span>
<span class="codeline" id="line-631"><code>	}</code></span>
<span class="codeline" id="line-632"><code>	return Map(unicode.ToUpper, s)</code></span>
<span class="codeline" id="line-633"><code>}</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>// ToLower returns s with all Unicode letters mapped to their lower case.</code></span>
<span class="codeline" id="line-636"><code>func ToLower(s string) string {</code></span>
<span class="codeline" id="line-637"><code>	isASCII, hasUpper := true, false</code></span>
<span class="codeline" id="line-638"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-639"><code>		c := s[i]</code></span>
<span class="codeline" id="line-640"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-641"><code>			isASCII = false</code></span>
<span class="codeline" id="line-642"><code>			break</code></span>
<span class="codeline" id="line-643"><code>		}</code></span>
<span class="codeline" id="line-644"><code>		hasUpper = hasUpper || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')</code></span>
<span class="codeline" id="line-645"><code>	}</code></span>
<span class="codeline" id="line-646"><code></code></span>
<span class="codeline" id="line-647"><code>	if isASCII { // optimize for ASCII-only strings.</code></span>
<span class="codeline" id="line-648"><code>		if !hasUpper {</code></span>
<span class="codeline" id="line-649"><code>			return s</code></span>
<span class="codeline" id="line-650"><code>		}</code></span>
<span class="codeline" id="line-651"><code>		var (</code></span>
<span class="codeline" id="line-652"><code>			b   Builder</code></span>
<span class="codeline" id="line-653"><code>			pos int</code></span>
<span class="codeline" id="line-654"><code>		)</code></span>
<span class="codeline" id="line-655"><code>		b.Grow(len(s))</code></span>
<span class="codeline" id="line-656"><code>		for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-657"><code>			c := s[i]</code></span>
<span class="codeline" id="line-658"><code>			if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-659"><code>				c += 'a' - 'A'</code></span>
<span class="codeline" id="line-660"><code>				if pos &lt; i {</code></span>
<span class="codeline" id="line-661"><code>					b.WriteString(s[pos:i])</code></span>
<span class="codeline" id="line-662"><code>				}</code></span>
<span class="codeline" id="line-663"><code>				b.WriteByte(c)</code></span>
<span class="codeline" id="line-664"><code>				pos = i + 1</code></span>
<span class="codeline" id="line-665"><code>			}</code></span>
<span class="codeline" id="line-666"><code>		}</code></span>
<span class="codeline" id="line-667"><code>		if pos &lt; len(s) {</code></span>
<span class="codeline" id="line-668"><code>			b.WriteString(s[pos:])</code></span>
<span class="codeline" id="line-669"><code>		}</code></span>
<span class="codeline" id="line-670"><code>		return b.String()</code></span>
<span class="codeline" id="line-671"><code>	}</code></span>
<span class="codeline" id="line-672"><code>	return Map(unicode.ToLower, s)</code></span>
<span class="codeline" id="line-673"><code>}</code></span>
<span class="codeline" id="line-674"><code></code></span>
<span class="codeline" id="line-675"><code>// ToTitle returns a copy of the string s with all Unicode letters mapped to</code></span>
<span class="codeline" id="line-676"><code>// their Unicode title case.</code></span>
<span class="codeline" id="line-677"><code>func ToTitle(s string) string { return Map(unicode.ToTitle, s) }</code></span>
<span class="codeline" id="line-678"><code></code></span>
<span class="codeline" id="line-679"><code>// ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-680"><code>// upper case using the case mapping specified by c.</code></span>
<span class="codeline" id="line-681"><code>func ToUpperSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-682"><code>	return Map(c.ToUpper, s)</code></span>
<span class="codeline" id="line-683"><code>}</code></span>
<span class="codeline" id="line-684"><code></code></span>
<span class="codeline" id="line-685"><code>// ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-686"><code>// lower case using the case mapping specified by c.</code></span>
<span class="codeline" id="line-687"><code>func ToLowerSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-688"><code>	return Map(c.ToLower, s)</code></span>
<span class="codeline" id="line-689"><code>}</code></span>
<span class="codeline" id="line-690"><code></code></span>
<span class="codeline" id="line-691"><code>// ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their</code></span>
<span class="codeline" id="line-692"><code>// Unicode title case, giving priority to the special casing rules.</code></span>
<span class="codeline" id="line-693"><code>func ToTitleSpecial(c unicode.SpecialCase, s string) string {</code></span>
<span class="codeline" id="line-694"><code>	return Map(c.ToTitle, s)</code></span>
<span class="codeline" id="line-695"><code>}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>// ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8 byte sequences</code></span>
<span class="codeline" id="line-698"><code>// replaced by the replacement string, which may be empty.</code></span>
<span class="codeline" id="line-699"><code>func ToValidUTF8(s, replacement string) string {</code></span>
<span class="codeline" id="line-700"><code>	var b Builder</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>	for i, c := range s {</code></span>
<span class="codeline" id="line-703"><code>		if c != utf8.RuneError {</code></span>
<span class="codeline" id="line-704"><code>			continue</code></span>
<span class="codeline" id="line-705"><code>		}</code></span>
<span class="codeline" id="line-706"><code></code></span>
<span class="codeline" id="line-707"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-708"><code>		if wid == 1 {</code></span>
<span class="codeline" id="line-709"><code>			b.Grow(len(s) + len(replacement))</code></span>
<span class="codeline" id="line-710"><code>			b.WriteString(s[:i])</code></span>
<span class="codeline" id="line-711"><code>			s = s[i:]</code></span>
<span class="codeline" id="line-712"><code>			break</code></span>
<span class="codeline" id="line-713"><code>		}</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>	// Fast path for unchanged input</code></span>
<span class="codeline" id="line-717"><code>	if b.Cap() == 0 { // didn't call b.Grow above</code></span>
<span class="codeline" id="line-718"><code>		return s</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>	invalid := false // previous byte was from an invalid UTF-8 sequence</code></span>
<span class="codeline" id="line-722"><code>	for i := 0; i &lt; len(s); {</code></span>
<span class="codeline" id="line-723"><code>		c := s[i]</code></span>
<span class="codeline" id="line-724"><code>		if c &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-725"><code>			i++</code></span>
<span class="codeline" id="line-726"><code>			invalid = false</code></span>
<span class="codeline" id="line-727"><code>			b.WriteByte(c)</code></span>
<span class="codeline" id="line-728"><code>			continue</code></span>
<span class="codeline" id="line-729"><code>		}</code></span>
<span class="codeline" id="line-730"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-731"><code>		if wid == 1 {</code></span>
<span class="codeline" id="line-732"><code>			i++</code></span>
<span class="codeline" id="line-733"><code>			if !invalid {</code></span>
<span class="codeline" id="line-734"><code>				invalid = true</code></span>
<span class="codeline" id="line-735"><code>				b.WriteString(replacement)</code></span>
<span class="codeline" id="line-736"><code>			}</code></span>
<span class="codeline" id="line-737"><code>			continue</code></span>
<span class="codeline" id="line-738"><code>		}</code></span>
<span class="codeline" id="line-739"><code>		invalid = false</code></span>
<span class="codeline" id="line-740"><code>		b.WriteString(s[i : i+wid])</code></span>
<span class="codeline" id="line-741"><code>		i += wid</code></span>
<span class="codeline" id="line-742"><code>	}</code></span>
<span class="codeline" id="line-743"><code></code></span>
<span class="codeline" id="line-744"><code>	return b.String()</code></span>
<span class="codeline" id="line-745"><code>}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>// isSeparator reports whether the rune could mark a word boundary.</code></span>
<span class="codeline" id="line-748"><code>// TODO: update when package unicode captures more of the properties.</code></span>
<span class="codeline" id="line-749"><code>func isSeparator(r rune) bool {</code></span>
<span class="codeline" id="line-750"><code>	// ASCII alphanumerics and underscore are not separators</code></span>
<span class="codeline" id="line-751"><code>	if r &lt;= 0x7F {</code></span>
<span class="codeline" id="line-752"><code>		switch {</code></span>
<span class="codeline" id="line-753"><code>		case '0' &lt;= r &amp;&amp; r &lt;= '9':</code></span>
<span class="codeline" id="line-754"><code>			return false</code></span>
<span class="codeline" id="line-755"><code>		case 'a' &lt;= r &amp;&amp; r &lt;= 'z':</code></span>
<span class="codeline" id="line-756"><code>			return false</code></span>
<span class="codeline" id="line-757"><code>		case 'A' &lt;= r &amp;&amp; r &lt;= 'Z':</code></span>
<span class="codeline" id="line-758"><code>			return false</code></span>
<span class="codeline" id="line-759"><code>		case r == '_':</code></span>
<span class="codeline" id="line-760"><code>			return false</code></span>
<span class="codeline" id="line-761"><code>		}</code></span>
<span class="codeline" id="line-762"><code>		return true</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code>	// Letters and digits are not separators</code></span>
<span class="codeline" id="line-765"><code>	if unicode.IsLetter(r) || unicode.IsDigit(r) {</code></span>
<span class="codeline" id="line-766"><code>		return false</code></span>
<span class="codeline" id="line-767"><code>	}</code></span>
<span class="codeline" id="line-768"><code>	// Otherwise, all we can do for now is treat spaces as separators.</code></span>
<span class="codeline" id="line-769"><code>	return unicode.IsSpace(r)</code></span>
<span class="codeline" id="line-770"><code>}</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>// Title returns a copy of the string s with all Unicode letters that begin words</code></span>
<span class="codeline" id="line-773"><code>// mapped to their Unicode title case.</code></span>
<span class="codeline" id="line-774"><code>//</code></span>
<span class="codeline" id="line-775"><code>// Deprecated: The rule Title uses for word boundaries does not handle Unicode</code></span>
<span class="codeline" id="line-776"><code>// punctuation properly. Use golang.org/x/text/cases instead.</code></span>
<span class="codeline" id="line-777"><code>func Title(s string) string {</code></span>
<span class="codeline" id="line-778"><code>	// Use a closure here to remember state.</code></span>
<span class="codeline" id="line-779"><code>	// Hackish but effective. Depends on Map scanning in order and calling</code></span>
<span class="codeline" id="line-780"><code>	// the closure once per rune.</code></span>
<span class="codeline" id="line-781"><code>	prev := ' '</code></span>
<span class="codeline" id="line-782"><code>	return Map(</code></span>
<span class="codeline" id="line-783"><code>		func(r rune) rune {</code></span>
<span class="codeline" id="line-784"><code>			if isSeparator(prev) {</code></span>
<span class="codeline" id="line-785"><code>				prev = r</code></span>
<span class="codeline" id="line-786"><code>				return unicode.ToTitle(r)</code></span>
<span class="codeline" id="line-787"><code>			}</code></span>
<span class="codeline" id="line-788"><code>			prev = r</code></span>
<span class="codeline" id="line-789"><code>			return r</code></span>
<span class="codeline" id="line-790"><code>		},</code></span>
<span class="codeline" id="line-791"><code>		s)</code></span>
<span class="codeline" id="line-792"><code>}</code></span>
<span class="codeline" id="line-793"><code></code></span>
<span class="codeline" id="line-794"><code>// TrimLeftFunc returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-795"><code>// Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-796"><code>func TrimLeftFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-797"><code>	i := indexFunc(s, f, false)</code></span>
<span class="codeline" id="line-798"><code>	if i == -1 {</code></span>
<span class="codeline" id="line-799"><code>		return ""</code></span>
<span class="codeline" id="line-800"><code>	}</code></span>
<span class="codeline" id="line-801"><code>	return s[i:]</code></span>
<span class="codeline" id="line-802"><code>}</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>// TrimRightFunc returns a slice of the string s with all trailing</code></span>
<span class="codeline" id="line-805"><code>// Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-806"><code>func TrimRightFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-807"><code>	i := lastIndexFunc(s, f, false)</code></span>
<span class="codeline" id="line-808"><code>	if i &gt;= 0 &amp;&amp; s[i] &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-809"><code>		_, wid := utf8.DecodeRuneInString(s[i:])</code></span>
<span class="codeline" id="line-810"><code>		i += wid</code></span>
<span class="codeline" id="line-811"><code>	} else {</code></span>
<span class="codeline" id="line-812"><code>		i++</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>	return s[0:i]</code></span>
<span class="codeline" id="line-815"><code>}</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>// TrimFunc returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-818"><code>// and trailing Unicode code points c satisfying f(c) removed.</code></span>
<span class="codeline" id="line-819"><code>func TrimFunc(s string, f func(rune) bool) string {</code></span>
<span class="codeline" id="line-820"><code>	return TrimRightFunc(TrimLeftFunc(s, f), f)</code></span>
<span class="codeline" id="line-821"><code>}</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>// IndexFunc returns the index into s of the first Unicode</code></span>
<span class="codeline" id="line-824"><code>// code point satisfying f(c), or -1 if none do.</code></span>
<span class="codeline" id="line-825"><code>func IndexFunc(s string, f func(rune) bool) int {</code></span>
<span class="codeline" id="line-826"><code>	return indexFunc(s, f, true)</code></span>
<span class="codeline" id="line-827"><code>}</code></span>
<span class="codeline" id="line-828"><code></code></span>
<span class="codeline" id="line-829"><code>// LastIndexFunc returns the index into s of the last</code></span>
<span class="codeline" id="line-830"><code>// Unicode code point satisfying f(c), or -1 if none do.</code></span>
<span class="codeline" id="line-831"><code>func LastIndexFunc(s string, f func(rune) bool) int {</code></span>
<span class="codeline" id="line-832"><code>	return lastIndexFunc(s, f, true)</code></span>
<span class="codeline" id="line-833"><code>}</code></span>
<span class="codeline" id="line-834"><code></code></span>
<span class="codeline" id="line-835"><code>// indexFunc is the same as IndexFunc except that if</code></span>
<span class="codeline" id="line-836"><code>// truth==false, the sense of the predicate function is</code></span>
<span class="codeline" id="line-837"><code>// inverted.</code></span>
<span class="codeline" id="line-838"><code>func indexFunc(s string, f func(rune) bool, truth bool) int {</code></span>
<span class="codeline" id="line-839"><code>	for i, r := range s {</code></span>
<span class="codeline" id="line-840"><code>		if f(r) == truth {</code></span>
<span class="codeline" id="line-841"><code>			return i</code></span>
<span class="codeline" id="line-842"><code>		}</code></span>
<span class="codeline" id="line-843"><code>	}</code></span>
<span class="codeline" id="line-844"><code>	return -1</code></span>
<span class="codeline" id="line-845"><code>}</code></span>
<span class="codeline" id="line-846"><code></code></span>
<span class="codeline" id="line-847"><code>// lastIndexFunc is the same as LastIndexFunc except that if</code></span>
<span class="codeline" id="line-848"><code>// truth==false, the sense of the predicate function is</code></span>
<span class="codeline" id="line-849"><code>// inverted.</code></span>
<span class="codeline" id="line-850"><code>func lastIndexFunc(s string, f func(rune) bool, truth bool) int {</code></span>
<span class="codeline" id="line-851"><code>	for i := len(s); i &gt; 0; {</code></span>
<span class="codeline" id="line-852"><code>		r, size := utf8.DecodeLastRuneInString(s[0:i])</code></span>
<span class="codeline" id="line-853"><code>		i -= size</code></span>
<span class="codeline" id="line-854"><code>		if f(r) == truth {</code></span>
<span class="codeline" id="line-855"><code>			return i</code></span>
<span class="codeline" id="line-856"><code>		}</code></span>
<span class="codeline" id="line-857"><code>	}</code></span>
<span class="codeline" id="line-858"><code>	return -1</code></span>
<span class="codeline" id="line-859"><code>}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>// asciiSet is a 32-byte value, where each bit represents the presence of a</code></span>
<span class="codeline" id="line-862"><code>// given ASCII character in the set. The 128-bits of the lower 16 bytes,</code></span>
<span class="codeline" id="line-863"><code>// starting with the least-significant bit of the lowest word to the</code></span>
<span class="codeline" id="line-864"><code>// most-significant bit of the highest word, map to the full range of all</code></span>
<span class="codeline" id="line-865"><code>// 128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,</code></span>
<span class="codeline" id="line-866"><code>// ensuring that any non-ASCII character will be reported as not in the set.</code></span>
<span class="codeline" id="line-867"><code>// This allocates a total of 32 bytes even though the upper half</code></span>
<span class="codeline" id="line-868"><code>// is unused to avoid bounds checks in asciiSet.contains.</code></span>
<span class="codeline" id="line-869"><code>type asciiSet [8]uint32</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>// makeASCIISet creates a set of ASCII characters and reports whether all</code></span>
<span class="codeline" id="line-872"><code>// characters in chars are ASCII.</code></span>
<span class="codeline" id="line-873"><code>func makeASCIISet(chars string) (as asciiSet, ok bool) {</code></span>
<span class="codeline" id="line-874"><code>	for i := 0; i &lt; len(chars); i++ {</code></span>
<span class="codeline" id="line-875"><code>		c := chars[i]</code></span>
<span class="codeline" id="line-876"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-877"><code>			return as, false</code></span>
<span class="codeline" id="line-878"><code>		}</code></span>
<span class="codeline" id="line-879"><code>		as[c/32] |= 1 &lt;&lt; (c % 32)</code></span>
<span class="codeline" id="line-880"><code>	}</code></span>
<span class="codeline" id="line-881"><code>	return as, true</code></span>
<span class="codeline" id="line-882"><code>}</code></span>
<span class="codeline" id="line-883"><code></code></span>
<span class="codeline" id="line-884"><code>// contains reports whether c is inside the set.</code></span>
<span class="codeline" id="line-885"><code>func (as *asciiSet) contains(c byte) bool {</code></span>
<span class="codeline" id="line-886"><code>	return (as[c/32] &amp; (1 &lt;&lt; (c % 32))) != 0</code></span>
<span class="codeline" id="line-887"><code>}</code></span>
<span class="codeline" id="line-888"><code></code></span>
<span class="codeline" id="line-889"><code>// Trim returns a slice of the string s with all leading and</code></span>
<span class="codeline" id="line-890"><code>// trailing Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-891"><code>func Trim(s, cutset string) string {</code></span>
<span class="codeline" id="line-892"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-893"><code>		return s</code></span>
<span class="codeline" id="line-894"><code>	}</code></span>
<span class="codeline" id="line-895"><code>	if len(cutset) == 1 &amp;&amp; cutset[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-896"><code>		return trimLeftByte(trimRightByte(s, cutset[0]), cutset[0])</code></span>
<span class="codeline" id="line-897"><code>	}</code></span>
<span class="codeline" id="line-898"><code>	if as, ok := makeASCIISet(cutset); ok {</code></span>
<span class="codeline" id="line-899"><code>		return trimLeftASCII(trimRightASCII(s, &amp;as), &amp;as)</code></span>
<span class="codeline" id="line-900"><code>	}</code></span>
<span class="codeline" id="line-901"><code>	return trimLeftUnicode(trimRightUnicode(s, cutset), cutset)</code></span>
<span class="codeline" id="line-902"><code>}</code></span>
<span class="codeline" id="line-903"><code></code></span>
<span class="codeline" id="line-904"><code>// TrimLeft returns a slice of the string s with all leading</code></span>
<span class="codeline" id="line-905"><code>// Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-906"><code>//</code></span>
<span class="codeline" id="line-907"><code>// To remove a prefix, use [TrimPrefix] instead.</code></span>
<span class="codeline" id="line-908"><code>func TrimLeft(s, cutset string) string {</code></span>
<span class="codeline" id="line-909"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-910"><code>		return s</code></span>
<span class="codeline" id="line-911"><code>	}</code></span>
<span class="codeline" id="line-912"><code>	if len(cutset) == 1 &amp;&amp; cutset[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-913"><code>		return trimLeftByte(s, cutset[0])</code></span>
<span class="codeline" id="line-914"><code>	}</code></span>
<span class="codeline" id="line-915"><code>	if as, ok := makeASCIISet(cutset); ok {</code></span>
<span class="codeline" id="line-916"><code>		return trimLeftASCII(s, &amp;as)</code></span>
<span class="codeline" id="line-917"><code>	}</code></span>
<span class="codeline" id="line-918"><code>	return trimLeftUnicode(s, cutset)</code></span>
<span class="codeline" id="line-919"><code>}</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>func trimLeftByte(s string, c byte) string {</code></span>
<span class="codeline" id="line-922"><code>	for len(s) &gt; 0 &amp;&amp; s[0] == c {</code></span>
<span class="codeline" id="line-923"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-924"><code>	}</code></span>
<span class="codeline" id="line-925"><code>	return s</code></span>
<span class="codeline" id="line-926"><code>}</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>func trimLeftASCII(s string, as *asciiSet) string {</code></span>
<span class="codeline" id="line-929"><code>	for len(s) &gt; 0 {</code></span>
<span class="codeline" id="line-930"><code>		if !as.contains(s[0]) {</code></span>
<span class="codeline" id="line-931"><code>			break</code></span>
<span class="codeline" id="line-932"><code>		}</code></span>
<span class="codeline" id="line-933"><code>		s = s[1:]</code></span>
<span class="codeline" id="line-934"><code>	}</code></span>
<span class="codeline" id="line-935"><code>	return s</code></span>
<span class="codeline" id="line-936"><code>}</code></span>
<span class="codeline" id="line-937"><code></code></span>
<span class="codeline" id="line-938"><code>func trimLeftUnicode(s, cutset string) string {</code></span>
<span class="codeline" id="line-939"><code>	for len(s) &gt; 0 {</code></span>
<span class="codeline" id="line-940"><code>		r, n := rune(s[0]), 1</code></span>
<span class="codeline" id="line-941"><code>		if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-942"><code>			r, n = utf8.DecodeRuneInString(s)</code></span>
<span class="codeline" id="line-943"><code>		}</code></span>
<span class="codeline" id="line-944"><code>		if !ContainsRune(cutset, r) {</code></span>
<span class="codeline" id="line-945"><code>			break</code></span>
<span class="codeline" id="line-946"><code>		}</code></span>
<span class="codeline" id="line-947"><code>		s = s[n:]</code></span>
<span class="codeline" id="line-948"><code>	}</code></span>
<span class="codeline" id="line-949"><code>	return s</code></span>
<span class="codeline" id="line-950"><code>}</code></span>
<span class="codeline" id="line-951"><code></code></span>
<span class="codeline" id="line-952"><code>// TrimRight returns a slice of the string s, with all trailing</code></span>
<span class="codeline" id="line-953"><code>// Unicode code points contained in cutset removed.</code></span>
<span class="codeline" id="line-954"><code>//</code></span>
<span class="codeline" id="line-955"><code>// To remove a suffix, use [TrimSuffix] instead.</code></span>
<span class="codeline" id="line-956"><code>func TrimRight(s, cutset string) string {</code></span>
<span class="codeline" id="line-957"><code>	if s == "" || cutset == "" {</code></span>
<span class="codeline" id="line-958"><code>		return s</code></span>
<span class="codeline" id="line-959"><code>	}</code></span>
<span class="codeline" id="line-960"><code>	if len(cutset) == 1 &amp;&amp; cutset[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-961"><code>		return trimRightByte(s, cutset[0])</code></span>
<span class="codeline" id="line-962"><code>	}</code></span>
<span class="codeline" id="line-963"><code>	if as, ok := makeASCIISet(cutset); ok {</code></span>
<span class="codeline" id="line-964"><code>		return trimRightASCII(s, &amp;as)</code></span>
<span class="codeline" id="line-965"><code>	}</code></span>
<span class="codeline" id="line-966"><code>	return trimRightUnicode(s, cutset)</code></span>
<span class="codeline" id="line-967"><code>}</code></span>
<span class="codeline" id="line-968"><code></code></span>
<span class="codeline" id="line-969"><code>func trimRightByte(s string, c byte) string {</code></span>
<span class="codeline" id="line-970"><code>	for len(s) &gt; 0 &amp;&amp; s[len(s)-1] == c {</code></span>
<span class="codeline" id="line-971"><code>		s = s[:len(s)-1]</code></span>
<span class="codeline" id="line-972"><code>	}</code></span>
<span class="codeline" id="line-973"><code>	return s</code></span>
<span class="codeline" id="line-974"><code>}</code></span>
<span class="codeline" id="line-975"><code></code></span>
<span class="codeline" id="line-976"><code>func trimRightASCII(s string, as *asciiSet) string {</code></span>
<span class="codeline" id="line-977"><code>	for len(s) &gt; 0 {</code></span>
<span class="codeline" id="line-978"><code>		if !as.contains(s[len(s)-1]) {</code></span>
<span class="codeline" id="line-979"><code>			break</code></span>
<span class="codeline" id="line-980"><code>		}</code></span>
<span class="codeline" id="line-981"><code>		s = s[:len(s)-1]</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>	return s</code></span>
<span class="codeline" id="line-984"><code>}</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>func trimRightUnicode(s, cutset string) string {</code></span>
<span class="codeline" id="line-987"><code>	for len(s) &gt; 0 {</code></span>
<span class="codeline" id="line-988"><code>		r, n := rune(s[len(s)-1]), 1</code></span>
<span class="codeline" id="line-989"><code>		if r &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-990"><code>			r, n = utf8.DecodeLastRuneInString(s)</code></span>
<span class="codeline" id="line-991"><code>		}</code></span>
<span class="codeline" id="line-992"><code>		if !ContainsRune(cutset, r) {</code></span>
<span class="codeline" id="line-993"><code>			break</code></span>
<span class="codeline" id="line-994"><code>		}</code></span>
<span class="codeline" id="line-995"><code>		s = s[:len(s)-n]</code></span>
<span class="codeline" id="line-996"><code>	}</code></span>
<span class="codeline" id="line-997"><code>	return s</code></span>
<span class="codeline" id="line-998"><code>}</code></span>
<span class="codeline" id="line-999"><code></code></span>
<span class="codeline" id="line-1000"><code>// TrimSpace returns a slice of the string s, with all leading</code></span>
<span class="codeline" id="line-1001"><code>// and trailing white space removed, as defined by Unicode.</code></span>
<span class="codeline" id="line-1002"><code>func TrimSpace(s string) string {</code></span>
<span class="codeline" id="line-1003"><code>	// Fast path for ASCII: look for the first ASCII non-space byte</code></span>
<span class="codeline" id="line-1004"><code>	start := 0</code></span>
<span class="codeline" id="line-1005"><code>	for ; start &lt; len(s); start++ {</code></span>
<span class="codeline" id="line-1006"><code>		c := s[start]</code></span>
<span class="codeline" id="line-1007"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1008"><code>			// If we run into a non-ASCII byte, fall back to the</code></span>
<span class="codeline" id="line-1009"><code>			// slower unicode-aware method on the remaining bytes</code></span>
<span class="codeline" id="line-1010"><code>			return TrimFunc(s[start:], unicode.IsSpace)</code></span>
<span class="codeline" id="line-1011"><code>		}</code></span>
<span class="codeline" id="line-1012"><code>		if asciiSpace[c] == 0 {</code></span>
<span class="codeline" id="line-1013"><code>			break</code></span>
<span class="codeline" id="line-1014"><code>		}</code></span>
<span class="codeline" id="line-1015"><code>	}</code></span>
<span class="codeline" id="line-1016"><code></code></span>
<span class="codeline" id="line-1017"><code>	// Now look for the first ASCII non-space byte from the end</code></span>
<span class="codeline" id="line-1018"><code>	stop := len(s)</code></span>
<span class="codeline" id="line-1019"><code>	for ; stop &gt; start; stop-- {</code></span>
<span class="codeline" id="line-1020"><code>		c := s[stop-1]</code></span>
<span class="codeline" id="line-1021"><code>		if c &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1022"><code>			// start has been already trimmed above, should trim end only</code></span>
<span class="codeline" id="line-1023"><code>			return TrimRightFunc(s[start:stop], unicode.IsSpace)</code></span>
<span class="codeline" id="line-1024"><code>		}</code></span>
<span class="codeline" id="line-1025"><code>		if asciiSpace[c] == 0 {</code></span>
<span class="codeline" id="line-1026"><code>			break</code></span>
<span class="codeline" id="line-1027"><code>		}</code></span>
<span class="codeline" id="line-1028"><code>	}</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>	// At this point s[start:stop] starts and ends with an ASCII</code></span>
<span class="codeline" id="line-1031"><code>	// non-space bytes, so we're done. Non-ASCII cases have already</code></span>
<span class="codeline" id="line-1032"><code>	// been handled above.</code></span>
<span class="codeline" id="line-1033"><code>	return s[start:stop]</code></span>
<span class="codeline" id="line-1034"><code>}</code></span>
<span class="codeline" id="line-1035"><code></code></span>
<span class="codeline" id="line-1036"><code>// TrimPrefix returns s without the provided leading prefix string.</code></span>
<span class="codeline" id="line-1037"><code>// If s doesn't start with prefix, s is returned unchanged.</code></span>
<span class="codeline" id="line-1038"><code>func TrimPrefix(s, prefix string) string {</code></span>
<span class="codeline" id="line-1039"><code>	if HasPrefix(s, prefix) {</code></span>
<span class="codeline" id="line-1040"><code>		return s[len(prefix):]</code></span>
<span class="codeline" id="line-1041"><code>	}</code></span>
<span class="codeline" id="line-1042"><code>	return s</code></span>
<span class="codeline" id="line-1043"><code>}</code></span>
<span class="codeline" id="line-1044"><code></code></span>
<span class="codeline" id="line-1045"><code>// TrimSuffix returns s without the provided trailing suffix string.</code></span>
<span class="codeline" id="line-1046"><code>// If s doesn't end with suffix, s is returned unchanged.</code></span>
<span class="codeline" id="line-1047"><code>func TrimSuffix(s, suffix string) string {</code></span>
<span class="codeline" id="line-1048"><code>	if HasSuffix(s, suffix) {</code></span>
<span class="codeline" id="line-1049"><code>		return s[:len(s)-len(suffix)]</code></span>
<span class="codeline" id="line-1050"><code>	}</code></span>
<span class="codeline" id="line-1051"><code>	return s</code></span>
<span class="codeline" id="line-1052"><code>}</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>// Replace returns a copy of the string s with the first n</code></span>
<span class="codeline" id="line-1055"><code>// non-overlapping instances of old replaced by new.</code></span>
<span class="codeline" id="line-1056"><code>// If old is empty, it matches at the beginning of the string</code></span>
<span class="codeline" id="line-1057"><code>// and after each UTF-8 sequence, yielding up to k+1 replacements</code></span>
<span class="codeline" id="line-1058"><code>// for a k-rune string.</code></span>
<span class="codeline" id="line-1059"><code>// If n &lt; 0, there is no limit on the number of replacements.</code></span>
<span class="codeline" id="line-1060"><code>func Replace(s, old, new string, n int) string {</code></span>
<span class="codeline" id="line-1061"><code>	if old == new || n == 0 {</code></span>
<span class="codeline" id="line-1062"><code>		return s // avoid allocation</code></span>
<span class="codeline" id="line-1063"><code>	}</code></span>
<span class="codeline" id="line-1064"><code></code></span>
<span class="codeline" id="line-1065"><code>	// Compute number of replacements.</code></span>
<span class="codeline" id="line-1066"><code>	if m := Count(s, old); m == 0 {</code></span>
<span class="codeline" id="line-1067"><code>		return s // avoid allocation</code></span>
<span class="codeline" id="line-1068"><code>	} else if n &lt; 0 || m &lt; n {</code></span>
<span class="codeline" id="line-1069"><code>		n = m</code></span>
<span class="codeline" id="line-1070"><code>	}</code></span>
<span class="codeline" id="line-1071"><code></code></span>
<span class="codeline" id="line-1072"><code>	// Apply replacements to buffer.</code></span>
<span class="codeline" id="line-1073"><code>	var b Builder</code></span>
<span class="codeline" id="line-1074"><code>	b.Grow(len(s) + n*(len(new)-len(old)))</code></span>
<span class="codeline" id="line-1075"><code>	start := 0</code></span>
<span class="codeline" id="line-1076"><code>	for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-1077"><code>		j := start</code></span>
<span class="codeline" id="line-1078"><code>		if len(old) == 0 {</code></span>
<span class="codeline" id="line-1079"><code>			if i &gt; 0 {</code></span>
<span class="codeline" id="line-1080"><code>				_, wid := utf8.DecodeRuneInString(s[start:])</code></span>
<span class="codeline" id="line-1081"><code>				j += wid</code></span>
<span class="codeline" id="line-1082"><code>			}</code></span>
<span class="codeline" id="line-1083"><code>		} else {</code></span>
<span class="codeline" id="line-1084"><code>			j += Index(s[start:], old)</code></span>
<span class="codeline" id="line-1085"><code>		}</code></span>
<span class="codeline" id="line-1086"><code>		b.WriteString(s[start:j])</code></span>
<span class="codeline" id="line-1087"><code>		b.WriteString(new)</code></span>
<span class="codeline" id="line-1088"><code>		start = j + len(old)</code></span>
<span class="codeline" id="line-1089"><code>	}</code></span>
<span class="codeline" id="line-1090"><code>	b.WriteString(s[start:])</code></span>
<span class="codeline" id="line-1091"><code>	return b.String()</code></span>
<span class="codeline" id="line-1092"><code>}</code></span>
<span class="codeline" id="line-1093"><code></code></span>
<span class="codeline" id="line-1094"><code>// ReplaceAll returns a copy of the string s with all</code></span>
<span class="codeline" id="line-1095"><code>// non-overlapping instances of old replaced by new.</code></span>
<span class="codeline" id="line-1096"><code>// If old is empty, it matches at the beginning of the string</code></span>
<span class="codeline" id="line-1097"><code>// and after each UTF-8 sequence, yielding up to k+1 replacements</code></span>
<span class="codeline" id="line-1098"><code>// for a k-rune string.</code></span>
<span class="codeline" id="line-1099"><code>func ReplaceAll(s, old, new string) string {</code></span>
<span class="codeline" id="line-1100"><code>	return Replace(s, old, new, -1)</code></span>
<span class="codeline" id="line-1101"><code>}</code></span>
<span class="codeline" id="line-1102"><code></code></span>
<span class="codeline" id="line-1103"><code>// EqualFold reports whether s and t, interpreted as UTF-8 strings,</code></span>
<span class="codeline" id="line-1104"><code>// are equal under simple Unicode case-folding, which is a more general</code></span>
<span class="codeline" id="line-1105"><code>// form of case-insensitivity.</code></span>
<span class="codeline" id="line-1106"><code>func EqualFold(s, t string) bool {</code></span>
<span class="codeline" id="line-1107"><code>	// ASCII fast path</code></span>
<span class="codeline" id="line-1108"><code>	i := 0</code></span>
<span class="codeline" id="line-1109"><code>	for ; i &lt; len(s) &amp;&amp; i &lt; len(t); i++ {</code></span>
<span class="codeline" id="line-1110"><code>		sr := s[i]</code></span>
<span class="codeline" id="line-1111"><code>		tr := t[i]</code></span>
<span class="codeline" id="line-1112"><code>		if sr|tr &gt;= utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1113"><code>			goto hasUnicode</code></span>
<span class="codeline" id="line-1114"><code>		}</code></span>
<span class="codeline" id="line-1115"><code></code></span>
<span class="codeline" id="line-1116"><code>		// Easy case.</code></span>
<span class="codeline" id="line-1117"><code>		if tr == sr {</code></span>
<span class="codeline" id="line-1118"><code>			continue</code></span>
<span class="codeline" id="line-1119"><code>		}</code></span>
<span class="codeline" id="line-1120"><code></code></span>
<span class="codeline" id="line-1121"><code>		// Make sr &lt; tr to simplify what follows.</code></span>
<span class="codeline" id="line-1122"><code>		if tr &lt; sr {</code></span>
<span class="codeline" id="line-1123"><code>			tr, sr = sr, tr</code></span>
<span class="codeline" id="line-1124"><code>		}</code></span>
<span class="codeline" id="line-1125"><code>		// ASCII only, sr/tr must be upper/lower case</code></span>
<span class="codeline" id="line-1126"><code>		if 'A' &lt;= sr &amp;&amp; sr &lt;= 'Z' &amp;&amp; tr == sr+'a'-'A' {</code></span>
<span class="codeline" id="line-1127"><code>			continue</code></span>
<span class="codeline" id="line-1128"><code>		}</code></span>
<span class="codeline" id="line-1129"><code>		return false</code></span>
<span class="codeline" id="line-1130"><code>	}</code></span>
<span class="codeline" id="line-1131"><code>	// Check if we've exhausted both strings.</code></span>
<span class="codeline" id="line-1132"><code>	return len(s) == len(t)</code></span>
<span class="codeline" id="line-1133"><code></code></span>
<span class="codeline" id="line-1134"><code>hasUnicode:</code></span>
<span class="codeline" id="line-1135"><code>	s = s[i:]</code></span>
<span class="codeline" id="line-1136"><code>	t = t[i:]</code></span>
<span class="codeline" id="line-1137"><code>	for _, sr := range s {</code></span>
<span class="codeline" id="line-1138"><code>		// If t is exhausted the strings are not equal.</code></span>
<span class="codeline" id="line-1139"><code>		if len(t) == 0 {</code></span>
<span class="codeline" id="line-1140"><code>			return false</code></span>
<span class="codeline" id="line-1141"><code>		}</code></span>
<span class="codeline" id="line-1142"><code></code></span>
<span class="codeline" id="line-1143"><code>		// Extract first rune from second string.</code></span>
<span class="codeline" id="line-1144"><code>		var tr rune</code></span>
<span class="codeline" id="line-1145"><code>		if t[0] &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1146"><code>			tr, t = rune(t[0]), t[1:]</code></span>
<span class="codeline" id="line-1147"><code>		} else {</code></span>
<span class="codeline" id="line-1148"><code>			r, size := utf8.DecodeRuneInString(t)</code></span>
<span class="codeline" id="line-1149"><code>			tr, t = r, t[size:]</code></span>
<span class="codeline" id="line-1150"><code>		}</code></span>
<span class="codeline" id="line-1151"><code></code></span>
<span class="codeline" id="line-1152"><code>		// If they match, keep going; if not, return false.</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>		// Easy case.</code></span>
<span class="codeline" id="line-1155"><code>		if tr == sr {</code></span>
<span class="codeline" id="line-1156"><code>			continue</code></span>
<span class="codeline" id="line-1157"><code>		}</code></span>
<span class="codeline" id="line-1158"><code></code></span>
<span class="codeline" id="line-1159"><code>		// Make sr &lt; tr to simplify what follows.</code></span>
<span class="codeline" id="line-1160"><code>		if tr &lt; sr {</code></span>
<span class="codeline" id="line-1161"><code>			tr, sr = sr, tr</code></span>
<span class="codeline" id="line-1162"><code>		}</code></span>
<span class="codeline" id="line-1163"><code>		// Fast check for ASCII.</code></span>
<span class="codeline" id="line-1164"><code>		if tr &lt; utf8.RuneSelf {</code></span>
<span class="codeline" id="line-1165"><code>			// ASCII only, sr/tr must be upper/lower case</code></span>
<span class="codeline" id="line-1166"><code>			if 'A' &lt;= sr &amp;&amp; sr &lt;= 'Z' &amp;&amp; tr == sr+'a'-'A' {</code></span>
<span class="codeline" id="line-1167"><code>				continue</code></span>
<span class="codeline" id="line-1168"><code>			}</code></span>
<span class="codeline" id="line-1169"><code>			return false</code></span>
<span class="codeline" id="line-1170"><code>		}</code></span>
<span class="codeline" id="line-1171"><code></code></span>
<span class="codeline" id="line-1172"><code>		// General case. SimpleFold(x) returns the next equivalent rune &gt; x</code></span>
<span class="codeline" id="line-1173"><code>		// or wraps around to smaller values.</code></span>
<span class="codeline" id="line-1174"><code>		r := unicode.SimpleFold(sr)</code></span>
<span class="codeline" id="line-1175"><code>		for r != sr &amp;&amp; r &lt; tr {</code></span>
<span class="codeline" id="line-1176"><code>			r = unicode.SimpleFold(r)</code></span>
<span class="codeline" id="line-1177"><code>		}</code></span>
<span class="codeline" id="line-1178"><code>		if r == tr {</code></span>
<span class="codeline" id="line-1179"><code>			continue</code></span>
<span class="codeline" id="line-1180"><code>		}</code></span>
<span class="codeline" id="line-1181"><code>		return false</code></span>
<span class="codeline" id="line-1182"><code>	}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>	// First string is empty, so check if the second one is also empty.</code></span>
<span class="codeline" id="line-1185"><code>	return len(t) == 0</code></span>
<span class="codeline" id="line-1186"><code>}</code></span>
<span class="codeline" id="line-1187"><code></code></span>
<span class="codeline" id="line-1188"><code>// Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.</code></span>
<span class="codeline" id="line-1189"><code>func Index(s, substr string) int {</code></span>
<span class="codeline" id="line-1190"><code>	n := len(substr)</code></span>
<span class="codeline" id="line-1191"><code>	switch {</code></span>
<span class="codeline" id="line-1192"><code>	case n == 0:</code></span>
<span class="codeline" id="line-1193"><code>		return 0</code></span>
<span class="codeline" id="line-1194"><code>	case n == 1:</code></span>
<span class="codeline" id="line-1195"><code>		return IndexByte(s, substr[0])</code></span>
<span class="codeline" id="line-1196"><code>	case n == len(s):</code></span>
<span class="codeline" id="line-1197"><code>		if substr == s {</code></span>
<span class="codeline" id="line-1198"><code>			return 0</code></span>
<span class="codeline" id="line-1199"><code>		}</code></span>
<span class="codeline" id="line-1200"><code>		return -1</code></span>
<span class="codeline" id="line-1201"><code>	case n &gt; len(s):</code></span>
<span class="codeline" id="line-1202"><code>		return -1</code></span>
<span class="codeline" id="line-1203"><code>	case n &lt;= bytealg.MaxLen:</code></span>
<span class="codeline" id="line-1204"><code>		// Use brute force when s and substr both are small</code></span>
<span class="codeline" id="line-1205"><code>		if len(s) &lt;= bytealg.MaxBruteForce {</code></span>
<span class="codeline" id="line-1206"><code>			return bytealg.IndexString(s, substr)</code></span>
<span class="codeline" id="line-1207"><code>		}</code></span>
<span class="codeline" id="line-1208"><code>		c0 := substr[0]</code></span>
<span class="codeline" id="line-1209"><code>		c1 := substr[1]</code></span>
<span class="codeline" id="line-1210"><code>		i := 0</code></span>
<span class="codeline" id="line-1211"><code>		t := len(s) - n + 1</code></span>
<span class="codeline" id="line-1212"><code>		fails := 0</code></span>
<span class="codeline" id="line-1213"><code>		for i &lt; t {</code></span>
<span class="codeline" id="line-1214"><code>			if s[i] != c0 {</code></span>
<span class="codeline" id="line-1215"><code>				// IndexByte is faster than bytealg.IndexString, so use it as long as</code></span>
<span class="codeline" id="line-1216"><code>				// we're not getting lots of false positives.</code></span>
<span class="codeline" id="line-1217"><code>				o := IndexByte(s[i+1:t], c0)</code></span>
<span class="codeline" id="line-1218"><code>				if o &lt; 0 {</code></span>
<span class="codeline" id="line-1219"><code>					return -1</code></span>
<span class="codeline" id="line-1220"><code>				}</code></span>
<span class="codeline" id="line-1221"><code>				i += o + 1</code></span>
<span class="codeline" id="line-1222"><code>			}</code></span>
<span class="codeline" id="line-1223"><code>			if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-1224"><code>				return i</code></span>
<span class="codeline" id="line-1225"><code>			}</code></span>
<span class="codeline" id="line-1226"><code>			fails++</code></span>
<span class="codeline" id="line-1227"><code>			i++</code></span>
<span class="codeline" id="line-1228"><code>			// Switch to bytealg.IndexString when IndexByte produces too many false positives.</code></span>
<span class="codeline" id="line-1229"><code>			if fails &gt; bytealg.Cutover(i) {</code></span>
<span class="codeline" id="line-1230"><code>				r := bytealg.IndexString(s[i:], substr)</code></span>
<span class="codeline" id="line-1231"><code>				if r &gt;= 0 {</code></span>
<span class="codeline" id="line-1232"><code>					return r + i</code></span>
<span class="codeline" id="line-1233"><code>				}</code></span>
<span class="codeline" id="line-1234"><code>				return -1</code></span>
<span class="codeline" id="line-1235"><code>			}</code></span>
<span class="codeline" id="line-1236"><code>		}</code></span>
<span class="codeline" id="line-1237"><code>		return -1</code></span>
<span class="codeline" id="line-1238"><code>	}</code></span>
<span class="codeline" id="line-1239"><code>	c0 := substr[0]</code></span>
<span class="codeline" id="line-1240"><code>	c1 := substr[1]</code></span>
<span class="codeline" id="line-1241"><code>	i := 0</code></span>
<span class="codeline" id="line-1242"><code>	t := len(s) - n + 1</code></span>
<span class="codeline" id="line-1243"><code>	fails := 0</code></span>
<span class="codeline" id="line-1244"><code>	for i &lt; t {</code></span>
<span class="codeline" id="line-1245"><code>		if s[i] != c0 {</code></span>
<span class="codeline" id="line-1246"><code>			o := IndexByte(s[i+1:t], c0)</code></span>
<span class="codeline" id="line-1247"><code>			if o &lt; 0 {</code></span>
<span class="codeline" id="line-1248"><code>				return -1</code></span>
<span class="codeline" id="line-1249"><code>			}</code></span>
<span class="codeline" id="line-1250"><code>			i += o + 1</code></span>
<span class="codeline" id="line-1251"><code>		}</code></span>
<span class="codeline" id="line-1252"><code>		if s[i+1] == c1 &amp;&amp; s[i:i+n] == substr {</code></span>
<span class="codeline" id="line-1253"><code>			return i</code></span>
<span class="codeline" id="line-1254"><code>		}</code></span>
<span class="codeline" id="line-1255"><code>		i++</code></span>
<span class="codeline" id="line-1256"><code>		fails++</code></span>
<span class="codeline" id="line-1257"><code>		if fails &gt;= 4+i&gt;&gt;4 &amp;&amp; i &lt; t {</code></span>
<span class="codeline" id="line-1258"><code>			// See comment in ../bytes/bytes.go.</code></span>
<span class="codeline" id="line-1259"><code>			j := bytealg.IndexRabinKarp(s[i:], substr)</code></span>
<span class="codeline" id="line-1260"><code>			if j &lt; 0 {</code></span>
<span class="codeline" id="line-1261"><code>				return -1</code></span>
<span class="codeline" id="line-1262"><code>			}</code></span>
<span class="codeline" id="line-1263"><code>			return i + j</code></span>
<span class="codeline" id="line-1264"><code>		}</code></span>
<span class="codeline" id="line-1265"><code>	}</code></span>
<span class="codeline" id="line-1266"><code>	return -1</code></span>
<span class="codeline" id="line-1267"><code>}</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>// Cut slices s around the first instance of sep,</code></span>
<span class="codeline" id="line-1270"><code>// returning the text before and after sep.</code></span>
<span class="codeline" id="line-1271"><code>// The found result reports whether sep appears in s.</code></span>
<span class="codeline" id="line-1272"><code>// If sep does not appear in s, cut returns s, "", false.</code></span>
<span class="codeline" id="line-1273"><code>func Cut(s, sep string) (before, after string, found bool) {</code></span>
<span class="codeline" id="line-1274"><code>	if i := Index(s, sep); i &gt;= 0 {</code></span>
<span class="codeline" id="line-1275"><code>		return s[:i], s[i+len(sep):], true</code></span>
<span class="codeline" id="line-1276"><code>	}</code></span>
<span class="codeline" id="line-1277"><code>	return s, "", false</code></span>
<span class="codeline" id="line-1278"><code>}</code></span>
<span class="codeline" id="line-1279"><code></code></span>
<span class="codeline" id="line-1280"><code>// CutPrefix returns s without the provided leading prefix string</code></span>
<span class="codeline" id="line-1281"><code>// and reports whether it found the prefix.</code></span>
<span class="codeline" id="line-1282"><code>// If s doesn't start with prefix, CutPrefix returns s, false.</code></span>
<span class="codeline" id="line-1283"><code>// If prefix is the empty string, CutPrefix returns s, true.</code></span>
<span class="codeline" id="line-1284"><code>func CutPrefix(s, prefix string) (after string, found bool) {</code></span>
<span class="codeline" id="line-1285"><code>	if !HasPrefix(s, prefix) {</code></span>
<span class="codeline" id="line-1286"><code>		return s, false</code></span>
<span class="codeline" id="line-1287"><code>	}</code></span>
<span class="codeline" id="line-1288"><code>	return s[len(prefix):], true</code></span>
<span class="codeline" id="line-1289"><code>}</code></span>
<span class="codeline" id="line-1290"><code></code></span>
<span class="codeline" id="line-1291"><code>// CutSuffix returns s without the provided ending suffix string</code></span>
<span class="codeline" id="line-1292"><code>// and reports whether it found the suffix.</code></span>
<span class="codeline" id="line-1293"><code>// If s doesn't end with suffix, CutSuffix returns s, false.</code></span>
<span class="codeline" id="line-1294"><code>// If suffix is the empty string, CutSuffix returns s, true.</code></span>
<span class="codeline" id="line-1295"><code>func CutSuffix(s, suffix string) (before string, found bool) {</code></span>
<span class="codeline" id="line-1296"><code>	if !HasSuffix(s, suffix) {</code></span>
<span class="codeline" id="line-1297"><code>		return s, false</code></span>
<span class="codeline" id="line-1298"><code>	}</code></span>
<span class="codeline" id="line-1299"><code>	return s[:len(s)-len(suffix)], true</code></span>
<span class="codeline" id="line-1300"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>