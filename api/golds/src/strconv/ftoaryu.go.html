<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: ftoaryu.go in package strconv</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	ftoaryu.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/strconv.html">strconv</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2021 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package strconv</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"math/bits"</code></span>
<span class="codeline" id="line-9"><code>)</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>// binary to decimal conversion using the Ryū algorithm.</code></span>
<span class="codeline" id="line-12"><code>//</code></span>
<span class="codeline" id="line-13"><code>// See Ulf Adams, "Ryū: Fast Float-to-String Conversion" (doi:10.1145/3192366.3192369)</code></span>
<span class="codeline" id="line-14"><code>//</code></span>
<span class="codeline" id="line-15"><code>// Fixed precision formatting is a variant of the original paper's</code></span>
<span class="codeline" id="line-16"><code>// algorithm, where a single multiplication by 10^k is required,</code></span>
<span class="codeline" id="line-17"><code>// sharing the same rounding guarantees.</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// ryuFtoaFixed32 formats mant*(2^exp) with prec decimal digits.</code></span>
<span class="codeline" id="line-20"><code>func ryuFtoaFixed32(d *decimalSlice, mant uint32, exp int, prec int) {</code></span>
<span class="codeline" id="line-21"><code>	if prec &lt; 0 {</code></span>
<span class="codeline" id="line-22"><code>		panic("ryuFtoaFixed32 called with negative prec")</code></span>
<span class="codeline" id="line-23"><code>	}</code></span>
<span class="codeline" id="line-24"><code>	if prec &gt; 9 {</code></span>
<span class="codeline" id="line-25"><code>		panic("ryuFtoaFixed32 called with prec &gt; 9")</code></span>
<span class="codeline" id="line-26"><code>	}</code></span>
<span class="codeline" id="line-27"><code>	// Zero input.</code></span>
<span class="codeline" id="line-28"><code>	if mant == 0 {</code></span>
<span class="codeline" id="line-29"><code>		d.nd, d.dp = 0, 0</code></span>
<span class="codeline" id="line-30"><code>		return</code></span>
<span class="codeline" id="line-31"><code>	}</code></span>
<span class="codeline" id="line-32"><code>	// Renormalize to a 25-bit mantissa.</code></span>
<span class="codeline" id="line-33"><code>	e2 := exp</code></span>
<span class="codeline" id="line-34"><code>	if b := bits.Len32(mant); b &lt; 25 {</code></span>
<span class="codeline" id="line-35"><code>		mant &lt;&lt;= uint(25 - b)</code></span>
<span class="codeline" id="line-36"><code>		e2 += b - 25</code></span>
<span class="codeline" id="line-37"><code>	}</code></span>
<span class="codeline" id="line-38"><code>	// Choose an exponent such that rounded mant*(2^e2)*(10^q) has</code></span>
<span class="codeline" id="line-39"><code>	// at least prec decimal digits, i.e</code></span>
<span class="codeline" id="line-40"><code>	//     mant*(2^e2)*(10^q) &gt;= 10^(prec-1)</code></span>
<span class="codeline" id="line-41"><code>	// Because mant &gt;= 2^24, it is enough to choose:</code></span>
<span class="codeline" id="line-42"><code>	//     2^(e2+24) &gt;= 10^(-q+prec-1)</code></span>
<span class="codeline" id="line-43"><code>	// or q = -mulByLog2Log10(e2+24) + prec - 1</code></span>
<span class="codeline" id="line-44"><code>	q := -mulByLog2Log10(e2+24) + prec - 1</code></span>
<span class="codeline" id="line-45"><code></code></span>
<span class="codeline" id="line-46"><code>	// Now compute mant*(2^e2)*(10^q).</code></span>
<span class="codeline" id="line-47"><code>	// Is it an exact computation?</code></span>
<span class="codeline" id="line-48"><code>	// Only small positive powers of 10 are exact (5^28 has 66 bits).</code></span>
<span class="codeline" id="line-49"><code>	exact := q &lt;= 27 &amp;&amp; q &gt;= 0</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>	di, dexp2, d0 := mult64bitPow10(mant, e2, q)</code></span>
<span class="codeline" id="line-52"><code>	if dexp2 &gt;= 0 {</code></span>
<span class="codeline" id="line-53"><code>		panic("not enough significant bits after mult64bitPow10")</code></span>
<span class="codeline" id="line-54"><code>	}</code></span>
<span class="codeline" id="line-55"><code>	// As a special case, computation might still be exact, if exponent</code></span>
<span class="codeline" id="line-56"><code>	// was negative and if it amounts to computing an exact division.</code></span>
<span class="codeline" id="line-57"><code>	// In that case, we ignore all lower bits.</code></span>
<span class="codeline" id="line-58"><code>	// Note that division by 10^11 cannot be exact as 5^11 has 26 bits.</code></span>
<span class="codeline" id="line-59"><code>	if q &lt; 0 &amp;&amp; q &gt;= -10 &amp;&amp; divisibleByPower5(uint64(mant), -q) {</code></span>
<span class="codeline" id="line-60"><code>		exact = true</code></span>
<span class="codeline" id="line-61"><code>		d0 = true</code></span>
<span class="codeline" id="line-62"><code>	}</code></span>
<span class="codeline" id="line-63"><code>	// Remove extra lower bits and keep rounding info.</code></span>
<span class="codeline" id="line-64"><code>	extra := uint(-dexp2)</code></span>
<span class="codeline" id="line-65"><code>	extraMask := uint32(1&lt;&lt;extra - 1)</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>	di, dfrac := di&gt;&gt;extra, di&amp;extraMask</code></span>
<span class="codeline" id="line-68"><code>	roundUp := false</code></span>
<span class="codeline" id="line-69"><code>	if exact {</code></span>
<span class="codeline" id="line-70"><code>		// If we computed an exact product, d + 1/2</code></span>
<span class="codeline" id="line-71"><code>		// should round to d+1 if 'd' is odd.</code></span>
<span class="codeline" id="line-72"><code>		roundUp = dfrac &gt; 1&lt;&lt;(extra-1) ||</code></span>
<span class="codeline" id="line-73"><code>			(dfrac == 1&lt;&lt;(extra-1) &amp;&amp; !d0) ||</code></span>
<span class="codeline" id="line-74"><code>			(dfrac == 1&lt;&lt;(extra-1) &amp;&amp; d0 &amp;&amp; di&amp;1 == 1)</code></span>
<span class="codeline" id="line-75"><code>	} else {</code></span>
<span class="codeline" id="line-76"><code>		// otherwise, d+1/2 always rounds up because</code></span>
<span class="codeline" id="line-77"><code>		// we truncated below.</code></span>
<span class="codeline" id="line-78"><code>		roundUp = dfrac&gt;&gt;(extra-1) == 1</code></span>
<span class="codeline" id="line-79"><code>	}</code></span>
<span class="codeline" id="line-80"><code>	if dfrac != 0 {</code></span>
<span class="codeline" id="line-81"><code>		d0 = false</code></span>
<span class="codeline" id="line-82"><code>	}</code></span>
<span class="codeline" id="line-83"><code>	// Proceed to the requested number of digits</code></span>
<span class="codeline" id="line-84"><code>	formatDecimal(d, uint64(di), !d0, roundUp, prec)</code></span>
<span class="codeline" id="line-85"><code>	// Adjust exponent</code></span>
<span class="codeline" id="line-86"><code>	d.dp -= q</code></span>
<span class="codeline" id="line-87"><code>}</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code>// ryuFtoaFixed64 formats mant*(2^exp) with prec decimal digits.</code></span>
<span class="codeline" id="line-90"><code>func ryuFtoaFixed64(d *decimalSlice, mant uint64, exp int, prec int) {</code></span>
<span class="codeline" id="line-91"><code>	if prec &gt; 18 {</code></span>
<span class="codeline" id="line-92"><code>		panic("ryuFtoaFixed64 called with prec &gt; 18")</code></span>
<span class="codeline" id="line-93"><code>	}</code></span>
<span class="codeline" id="line-94"><code>	// Zero input.</code></span>
<span class="codeline" id="line-95"><code>	if mant == 0 {</code></span>
<span class="codeline" id="line-96"><code>		d.nd, d.dp = 0, 0</code></span>
<span class="codeline" id="line-97"><code>		return</code></span>
<span class="codeline" id="line-98"><code>	}</code></span>
<span class="codeline" id="line-99"><code>	// Renormalize to a 55-bit mantissa.</code></span>
<span class="codeline" id="line-100"><code>	e2 := exp</code></span>
<span class="codeline" id="line-101"><code>	if b := bits.Len64(mant); b &lt; 55 {</code></span>
<span class="codeline" id="line-102"><code>		mant = mant &lt;&lt; uint(55-b)</code></span>
<span class="codeline" id="line-103"><code>		e2 += b - 55</code></span>
<span class="codeline" id="line-104"><code>	}</code></span>
<span class="codeline" id="line-105"><code>	// Choose an exponent such that rounded mant*(2^e2)*(10^q) has</code></span>
<span class="codeline" id="line-106"><code>	// at least prec decimal digits, i.e</code></span>
<span class="codeline" id="line-107"><code>	//     mant*(2^e2)*(10^q) &gt;= 10^(prec-1)</code></span>
<span class="codeline" id="line-108"><code>	// Because mant &gt;= 2^54, it is enough to choose:</code></span>
<span class="codeline" id="line-109"><code>	//     2^(e2+54) &gt;= 10^(-q+prec-1)</code></span>
<span class="codeline" id="line-110"><code>	// or q = -mulByLog2Log10(e2+54) + prec - 1</code></span>
<span class="codeline" id="line-111"><code>	//</code></span>
<span class="codeline" id="line-112"><code>	// The minimal required exponent is -mulByLog2Log10(1025)+18 = -291</code></span>
<span class="codeline" id="line-113"><code>	// The maximal required exponent is mulByLog2Log10(1074)+18 = 342</code></span>
<span class="codeline" id="line-114"><code>	q := -mulByLog2Log10(e2+54) + prec - 1</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>	// Now compute mant*(2^e2)*(10^q).</code></span>
<span class="codeline" id="line-117"><code>	// Is it an exact computation?</code></span>
<span class="codeline" id="line-118"><code>	// Only small positive powers of 10 are exact (5^55 has 128 bits).</code></span>
<span class="codeline" id="line-119"><code>	exact := q &lt;= 55 &amp;&amp; q &gt;= 0</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	di, dexp2, d0 := mult128bitPow10(mant, e2, q)</code></span>
<span class="codeline" id="line-122"><code>	if dexp2 &gt;= 0 {</code></span>
<span class="codeline" id="line-123"><code>		panic("not enough significant bits after mult128bitPow10")</code></span>
<span class="codeline" id="line-124"><code>	}</code></span>
<span class="codeline" id="line-125"><code>	// As a special case, computation might still be exact, if exponent</code></span>
<span class="codeline" id="line-126"><code>	// was negative and if it amounts to computing an exact division.</code></span>
<span class="codeline" id="line-127"><code>	// In that case, we ignore all lower bits.</code></span>
<span class="codeline" id="line-128"><code>	// Note that division by 10^23 cannot be exact as 5^23 has 54 bits.</code></span>
<span class="codeline" id="line-129"><code>	if q &lt; 0 &amp;&amp; q &gt;= -22 &amp;&amp; divisibleByPower5(mant, -q) {</code></span>
<span class="codeline" id="line-130"><code>		exact = true</code></span>
<span class="codeline" id="line-131"><code>		d0 = true</code></span>
<span class="codeline" id="line-132"><code>	}</code></span>
<span class="codeline" id="line-133"><code>	// Remove extra lower bits and keep rounding info.</code></span>
<span class="codeline" id="line-134"><code>	extra := uint(-dexp2)</code></span>
<span class="codeline" id="line-135"><code>	extraMask := uint64(1&lt;&lt;extra - 1)</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	di, dfrac := di&gt;&gt;extra, di&amp;extraMask</code></span>
<span class="codeline" id="line-138"><code>	roundUp := false</code></span>
<span class="codeline" id="line-139"><code>	if exact {</code></span>
<span class="codeline" id="line-140"><code>		// If we computed an exact product, d + 1/2</code></span>
<span class="codeline" id="line-141"><code>		// should round to d+1 if 'd' is odd.</code></span>
<span class="codeline" id="line-142"><code>		roundUp = dfrac &gt; 1&lt;&lt;(extra-1) ||</code></span>
<span class="codeline" id="line-143"><code>			(dfrac == 1&lt;&lt;(extra-1) &amp;&amp; !d0) ||</code></span>
<span class="codeline" id="line-144"><code>			(dfrac == 1&lt;&lt;(extra-1) &amp;&amp; d0 &amp;&amp; di&amp;1 == 1)</code></span>
<span class="codeline" id="line-145"><code>	} else {</code></span>
<span class="codeline" id="line-146"><code>		// otherwise, d+1/2 always rounds up because</code></span>
<span class="codeline" id="line-147"><code>		// we truncated below.</code></span>
<span class="codeline" id="line-148"><code>		roundUp = dfrac&gt;&gt;(extra-1) == 1</code></span>
<span class="codeline" id="line-149"><code>	}</code></span>
<span class="codeline" id="line-150"><code>	if dfrac != 0 {</code></span>
<span class="codeline" id="line-151"><code>		d0 = false</code></span>
<span class="codeline" id="line-152"><code>	}</code></span>
<span class="codeline" id="line-153"><code>	// Proceed to the requested number of digits</code></span>
<span class="codeline" id="line-154"><code>	formatDecimal(d, di, !d0, roundUp, prec)</code></span>
<span class="codeline" id="line-155"><code>	// Adjust exponent</code></span>
<span class="codeline" id="line-156"><code>	d.dp -= q</code></span>
<span class="codeline" id="line-157"><code>}</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>var uint64pow10 = [...]uint64{</code></span>
<span class="codeline" id="line-160"><code>	1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,</code></span>
<span class="codeline" id="line-161"><code>	1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,</code></span>
<span class="codeline" id="line-162"><code>}</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>// formatDecimal fills d with at most prec decimal digits</code></span>
<span class="codeline" id="line-165"><code>// of mantissa m. The boolean trunc indicates whether m</code></span>
<span class="codeline" id="line-166"><code>// is truncated compared to the original number being formatted.</code></span>
<span class="codeline" id="line-167"><code>func formatDecimal(d *decimalSlice, m uint64, trunc bool, roundUp bool, prec int) {</code></span>
<span class="codeline" id="line-168"><code>	max := uint64pow10[prec]</code></span>
<span class="codeline" id="line-169"><code>	trimmed := 0</code></span>
<span class="codeline" id="line-170"><code>	for m &gt;= max {</code></span>
<span class="codeline" id="line-171"><code>		a, b := m/10, m%10</code></span>
<span class="codeline" id="line-172"><code>		m = a</code></span>
<span class="codeline" id="line-173"><code>		trimmed++</code></span>
<span class="codeline" id="line-174"><code>		if b &gt; 5 {</code></span>
<span class="codeline" id="line-175"><code>			roundUp = true</code></span>
<span class="codeline" id="line-176"><code>		} else if b &lt; 5 {</code></span>
<span class="codeline" id="line-177"><code>			roundUp = false</code></span>
<span class="codeline" id="line-178"><code>		} else { // b == 5</code></span>
<span class="codeline" id="line-179"><code>			// round up if there are trailing digits,</code></span>
<span class="codeline" id="line-180"><code>			// or if the new value of m is odd (round-to-even convention)</code></span>
<span class="codeline" id="line-181"><code>			roundUp = trunc || m&amp;1 == 1</code></span>
<span class="codeline" id="line-182"><code>		}</code></span>
<span class="codeline" id="line-183"><code>		if b != 0 {</code></span>
<span class="codeline" id="line-184"><code>			trunc = true</code></span>
<span class="codeline" id="line-185"><code>		}</code></span>
<span class="codeline" id="line-186"><code>	}</code></span>
<span class="codeline" id="line-187"><code>	if roundUp {</code></span>
<span class="codeline" id="line-188"><code>		m++</code></span>
<span class="codeline" id="line-189"><code>	}</code></span>
<span class="codeline" id="line-190"><code>	if m &gt;= max {</code></span>
<span class="codeline" id="line-191"><code>		// Happens if di was originally 99999....xx</code></span>
<span class="codeline" id="line-192"><code>		m /= 10</code></span>
<span class="codeline" id="line-193"><code>		trimmed++</code></span>
<span class="codeline" id="line-194"><code>	}</code></span>
<span class="codeline" id="line-195"><code>	// render digits (similar to formatBits)</code></span>
<span class="codeline" id="line-196"><code>	n := uint(prec)</code></span>
<span class="codeline" id="line-197"><code>	d.nd = prec</code></span>
<span class="codeline" id="line-198"><code>	v := m</code></span>
<span class="codeline" id="line-199"><code>	for v &gt;= 100 {</code></span>
<span class="codeline" id="line-200"><code>		var v1, v2 uint64</code></span>
<span class="codeline" id="line-201"><code>		if v&gt;&gt;32 == 0 {</code></span>
<span class="codeline" id="line-202"><code>			v1, v2 = uint64(uint32(v)/100), uint64(uint32(v)%100)</code></span>
<span class="codeline" id="line-203"><code>		} else {</code></span>
<span class="codeline" id="line-204"><code>			v1, v2 = v/100, v%100</code></span>
<span class="codeline" id="line-205"><code>		}</code></span>
<span class="codeline" id="line-206"><code>		n -= 2</code></span>
<span class="codeline" id="line-207"><code>		d.d[n+1] = smallsString[2*v2+1]</code></span>
<span class="codeline" id="line-208"><code>		d.d[n+0] = smallsString[2*v2+0]</code></span>
<span class="codeline" id="line-209"><code>		v = v1</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>	if v &gt; 0 {</code></span>
<span class="codeline" id="line-212"><code>		n--</code></span>
<span class="codeline" id="line-213"><code>		d.d[n] = smallsString[2*v+1]</code></span>
<span class="codeline" id="line-214"><code>	}</code></span>
<span class="codeline" id="line-215"><code>	if v &gt;= 10 {</code></span>
<span class="codeline" id="line-216"><code>		n--</code></span>
<span class="codeline" id="line-217"><code>		d.d[n] = smallsString[2*v]</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code>	for d.d[d.nd-1] == '0' {</code></span>
<span class="codeline" id="line-220"><code>		d.nd--</code></span>
<span class="codeline" id="line-221"><code>		trimmed++</code></span>
<span class="codeline" id="line-222"><code>	}</code></span>
<span class="codeline" id="line-223"><code>	d.dp = d.nd + trimmed</code></span>
<span class="codeline" id="line-224"><code>}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>// ryuFtoaShortest formats mant*2^exp with prec decimal digits.</code></span>
<span class="codeline" id="line-227"><code>func ryuFtoaShortest(d *decimalSlice, mant uint64, exp int, flt *floatInfo) {</code></span>
<span class="codeline" id="line-228"><code>	if mant == 0 {</code></span>
<span class="codeline" id="line-229"><code>		d.nd, d.dp = 0, 0</code></span>
<span class="codeline" id="line-230"><code>		return</code></span>
<span class="codeline" id="line-231"><code>	}</code></span>
<span class="codeline" id="line-232"><code>	// If input is an exact integer with fewer bits than the mantissa,</code></span>
<span class="codeline" id="line-233"><code>	// the previous and next integer are not admissible representations.</code></span>
<span class="codeline" id="line-234"><code>	if exp &lt;= 0 &amp;&amp; bits.TrailingZeros64(mant) &gt;= -exp {</code></span>
<span class="codeline" id="line-235"><code>		mant &gt;&gt;= uint(-exp)</code></span>
<span class="codeline" id="line-236"><code>		ryuDigits(d, mant, mant, mant, true, false)</code></span>
<span class="codeline" id="line-237"><code>		return</code></span>
<span class="codeline" id="line-238"><code>	}</code></span>
<span class="codeline" id="line-239"><code>	ml, mc, mu, e2 := computeBounds(mant, exp, flt)</code></span>
<span class="codeline" id="line-240"><code>	if e2 == 0 {</code></span>
<span class="codeline" id="line-241"><code>		ryuDigits(d, ml, mc, mu, true, false)</code></span>
<span class="codeline" id="line-242"><code>		return</code></span>
<span class="codeline" id="line-243"><code>	}</code></span>
<span class="codeline" id="line-244"><code>	// Find 10^q *larger* than 2^-e2</code></span>
<span class="codeline" id="line-245"><code>	q := mulByLog2Log10(-e2) + 1</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>	// We are going to multiply by 10^q using 128-bit arithmetic.</code></span>
<span class="codeline" id="line-248"><code>	// The exponent is the same for all 3 numbers.</code></span>
<span class="codeline" id="line-249"><code>	var dl, dc, du uint64</code></span>
<span class="codeline" id="line-250"><code>	var dl0, dc0, du0 bool</code></span>
<span class="codeline" id="line-251"><code>	if flt == &amp;float32info {</code></span>
<span class="codeline" id="line-252"><code>		var dl32, dc32, du32 uint32</code></span>
<span class="codeline" id="line-253"><code>		dl32, _, dl0 = mult64bitPow10(uint32(ml), e2, q)</code></span>
<span class="codeline" id="line-254"><code>		dc32, _, dc0 = mult64bitPow10(uint32(mc), e2, q)</code></span>
<span class="codeline" id="line-255"><code>		du32, e2, du0 = mult64bitPow10(uint32(mu), e2, q)</code></span>
<span class="codeline" id="line-256"><code>		dl, dc, du = uint64(dl32), uint64(dc32), uint64(du32)</code></span>
<span class="codeline" id="line-257"><code>	} else {</code></span>
<span class="codeline" id="line-258"><code>		dl, _, dl0 = mult128bitPow10(ml, e2, q)</code></span>
<span class="codeline" id="line-259"><code>		dc, _, dc0 = mult128bitPow10(mc, e2, q)</code></span>
<span class="codeline" id="line-260"><code>		du, e2, du0 = mult128bitPow10(mu, e2, q)</code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>	if e2 &gt;= 0 {</code></span>
<span class="codeline" id="line-263"><code>		panic("not enough significant bits after mult128bitPow10")</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>	// Is it an exact computation?</code></span>
<span class="codeline" id="line-266"><code>	if q &gt; 55 {</code></span>
<span class="codeline" id="line-267"><code>		// Large positive powers of ten are not exact</code></span>
<span class="codeline" id="line-268"><code>		dl0, dc0, du0 = false, false, false</code></span>
<span class="codeline" id="line-269"><code>	}</code></span>
<span class="codeline" id="line-270"><code>	if q &lt; 0 &amp;&amp; q &gt;= -24 {</code></span>
<span class="codeline" id="line-271"><code>		// Division by a power of ten may be exact.</code></span>
<span class="codeline" id="line-272"><code>		// (note that 5^25 is a 59-bit number so division by 5^25 is never exact).</code></span>
<span class="codeline" id="line-273"><code>		if divisibleByPower5(ml, -q) {</code></span>
<span class="codeline" id="line-274"><code>			dl0 = true</code></span>
<span class="codeline" id="line-275"><code>		}</code></span>
<span class="codeline" id="line-276"><code>		if divisibleByPower5(mc, -q) {</code></span>
<span class="codeline" id="line-277"><code>			dc0 = true</code></span>
<span class="codeline" id="line-278"><code>		}</code></span>
<span class="codeline" id="line-279"><code>		if divisibleByPower5(mu, -q) {</code></span>
<span class="codeline" id="line-280"><code>			du0 = true</code></span>
<span class="codeline" id="line-281"><code>		}</code></span>
<span class="codeline" id="line-282"><code>	}</code></span>
<span class="codeline" id="line-283"><code>	// Express the results (dl, dc, du)*2^e2 as integers.</code></span>
<span class="codeline" id="line-284"><code>	// Extra bits must be removed and rounding hints computed.</code></span>
<span class="codeline" id="line-285"><code>	extra := uint(-e2)</code></span>
<span class="codeline" id="line-286"><code>	extraMask := uint64(1&lt;&lt;extra - 1)</code></span>
<span class="codeline" id="line-287"><code>	// Now compute the floored, integral base 10 mantissas.</code></span>
<span class="codeline" id="line-288"><code>	dl, fracl := dl&gt;&gt;extra, dl&amp;extraMask</code></span>
<span class="codeline" id="line-289"><code>	dc, fracc := dc&gt;&gt;extra, dc&amp;extraMask</code></span>
<span class="codeline" id="line-290"><code>	du, fracu := du&gt;&gt;extra, du&amp;extraMask</code></span>
<span class="codeline" id="line-291"><code>	// Is it allowed to use 'du' as a result?</code></span>
<span class="codeline" id="line-292"><code>	// It is always allowed when it is truncated, but also</code></span>
<span class="codeline" id="line-293"><code>	// if it is exact and the original binary mantissa is even</code></span>
<span class="codeline" id="line-294"><code>	// When disallowed, we can subtract 1.</code></span>
<span class="codeline" id="line-295"><code>	uok := !du0 || fracu &gt; 0</code></span>
<span class="codeline" id="line-296"><code>	if du0 &amp;&amp; fracu == 0 {</code></span>
<span class="codeline" id="line-297"><code>		uok = mant&amp;1 == 0</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>	if !uok {</code></span>
<span class="codeline" id="line-300"><code>		du--</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code>	// Is 'dc' the correctly rounded base 10 mantissa?</code></span>
<span class="codeline" id="line-303"><code>	// The correct rounding might be dc+1</code></span>
<span class="codeline" id="line-304"><code>	cup := false // don't round up.</code></span>
<span class="codeline" id="line-305"><code>	if dc0 {</code></span>
<span class="codeline" id="line-306"><code>		// If we computed an exact product, the half integer</code></span>
<span class="codeline" id="line-307"><code>		// should round to next (even) integer if 'dc' is odd.</code></span>
<span class="codeline" id="line-308"><code>		cup = fracc &gt; 1&lt;&lt;(extra-1) ||</code></span>
<span class="codeline" id="line-309"><code>			(fracc == 1&lt;&lt;(extra-1) &amp;&amp; dc&amp;1 == 1)</code></span>
<span class="codeline" id="line-310"><code>	} else {</code></span>
<span class="codeline" id="line-311"><code>		// otherwise, the result is a lower truncation of the ideal</code></span>
<span class="codeline" id="line-312"><code>		// result.</code></span>
<span class="codeline" id="line-313"><code>		cup = fracc&gt;&gt;(extra-1) == 1</code></span>
<span class="codeline" id="line-314"><code>	}</code></span>
<span class="codeline" id="line-315"><code>	// Is 'dl' an allowed representation?</code></span>
<span class="codeline" id="line-316"><code>	// Only if it is an exact value, and if the original binary mantissa</code></span>
<span class="codeline" id="line-317"><code>	// was even.</code></span>
<span class="codeline" id="line-318"><code>	lok := dl0 &amp;&amp; fracl == 0 &amp;&amp; (mant&amp;1 == 0)</code></span>
<span class="codeline" id="line-319"><code>	if !lok {</code></span>
<span class="codeline" id="line-320"><code>		dl++</code></span>
<span class="codeline" id="line-321"><code>	}</code></span>
<span class="codeline" id="line-322"><code>	// We need to remember whether the trimmed digits of 'dc' are zero.</code></span>
<span class="codeline" id="line-323"><code>	c0 := dc0 &amp;&amp; fracc == 0</code></span>
<span class="codeline" id="line-324"><code>	// render digits</code></span>
<span class="codeline" id="line-325"><code>	ryuDigits(d, dl, dc, du, c0, cup)</code></span>
<span class="codeline" id="line-326"><code>	d.dp -= q</code></span>
<span class="codeline" id="line-327"><code>}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>// mulByLog2Log10 returns math.Floor(x * log(2)/log(10)) for an integer x in</code></span>
<span class="codeline" id="line-330"><code>// the range -1600 &lt;= x &amp;&amp; x &lt;= +1600.</code></span>
<span class="codeline" id="line-331"><code>//</code></span>
<span class="codeline" id="line-332"><code>// The range restriction lets us work in faster integer arithmetic instead of</code></span>
<span class="codeline" id="line-333"><code>// slower floating point arithmetic. Correctness is verified by unit tests.</code></span>
<span class="codeline" id="line-334"><code>func mulByLog2Log10(x int) int {</code></span>
<span class="codeline" id="line-335"><code>	// log(2)/log(10) ≈ 0.30102999566 ≈ 78913 / 2^18</code></span>
<span class="codeline" id="line-336"><code>	return (x * 78913) &gt;&gt; 18</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// mulByLog10Log2 returns math.Floor(x * log(10)/log(2)) for an integer x in</code></span>
<span class="codeline" id="line-340"><code>// the range -500 &lt;= x &amp;&amp; x &lt;= +500.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// The range restriction lets us work in faster integer arithmetic instead of</code></span>
<span class="codeline" id="line-343"><code>// slower floating point arithmetic. Correctness is verified by unit tests.</code></span>
<span class="codeline" id="line-344"><code>func mulByLog10Log2(x int) int {</code></span>
<span class="codeline" id="line-345"><code>	// log(10)/log(2) ≈ 3.32192809489 ≈ 108853 / 2^15</code></span>
<span class="codeline" id="line-346"><code>	return (x * 108853) &gt;&gt; 15</code></span>
<span class="codeline" id="line-347"><code>}</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>// computeBounds returns a floating-point vector (l, c, u)×2^e2</code></span>
<span class="codeline" id="line-350"><code>// where the mantissas are 55-bit (or 26-bit) integers, describing the interval</code></span>
<span class="codeline" id="line-351"><code>// represented by the input float64 or float32.</code></span>
<span class="codeline" id="line-352"><code>func computeBounds(mant uint64, exp int, flt *floatInfo) (lower, central, upper uint64, e2 int) {</code></span>
<span class="codeline" id="line-353"><code>	if mant != 1&lt;&lt;flt.mantbits || exp == flt.bias+1-int(flt.mantbits) {</code></span>
<span class="codeline" id="line-354"><code>		// regular case (or denormals)</code></span>
<span class="codeline" id="line-355"><code>		lower, central, upper = 2*mant-1, 2*mant, 2*mant+1</code></span>
<span class="codeline" id="line-356"><code>		e2 = exp - 1</code></span>
<span class="codeline" id="line-357"><code>		return</code></span>
<span class="codeline" id="line-358"><code>	} else {</code></span>
<span class="codeline" id="line-359"><code>		// border of an exponent</code></span>
<span class="codeline" id="line-360"><code>		lower, central, upper = 4*mant-1, 4*mant, 4*mant+2</code></span>
<span class="codeline" id="line-361"><code>		e2 = exp - 2</code></span>
<span class="codeline" id="line-362"><code>		return</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>func ryuDigits(d *decimalSlice, lower, central, upper uint64,</code></span>
<span class="codeline" id="line-367"><code>	c0, cup bool) {</code></span>
<span class="codeline" id="line-368"><code>	lhi, llo := divmod1e9(lower)</code></span>
<span class="codeline" id="line-369"><code>	chi, clo := divmod1e9(central)</code></span>
<span class="codeline" id="line-370"><code>	uhi, ulo := divmod1e9(upper)</code></span>
<span class="codeline" id="line-371"><code>	if uhi == 0 {</code></span>
<span class="codeline" id="line-372"><code>		// only low digits (for denormals)</code></span>
<span class="codeline" id="line-373"><code>		ryuDigits32(d, llo, clo, ulo, c0, cup, 8)</code></span>
<span class="codeline" id="line-374"><code>	} else if lhi &lt; uhi {</code></span>
<span class="codeline" id="line-375"><code>		// truncate 9 digits at once.</code></span>
<span class="codeline" id="line-376"><code>		if llo != 0 {</code></span>
<span class="codeline" id="line-377"><code>			lhi++</code></span>
<span class="codeline" id="line-378"><code>		}</code></span>
<span class="codeline" id="line-379"><code>		c0 = c0 &amp;&amp; clo == 0</code></span>
<span class="codeline" id="line-380"><code>		cup = (clo &gt; 5e8) || (clo == 5e8 &amp;&amp; cup)</code></span>
<span class="codeline" id="line-381"><code>		ryuDigits32(d, lhi, chi, uhi, c0, cup, 8)</code></span>
<span class="codeline" id="line-382"><code>		d.dp += 9</code></span>
<span class="codeline" id="line-383"><code>	} else {</code></span>
<span class="codeline" id="line-384"><code>		d.nd = 0</code></span>
<span class="codeline" id="line-385"><code>		// emit high part</code></span>
<span class="codeline" id="line-386"><code>		n := uint(9)</code></span>
<span class="codeline" id="line-387"><code>		for v := chi; v &gt; 0; {</code></span>
<span class="codeline" id="line-388"><code>			v1, v2 := v/10, v%10</code></span>
<span class="codeline" id="line-389"><code>			v = v1</code></span>
<span class="codeline" id="line-390"><code>			n--</code></span>
<span class="codeline" id="line-391"><code>			d.d[n] = byte(v2 + '0')</code></span>
<span class="codeline" id="line-392"><code>		}</code></span>
<span class="codeline" id="line-393"><code>		d.d = d.d[n:]</code></span>
<span class="codeline" id="line-394"><code>		d.nd = int(9 - n)</code></span>
<span class="codeline" id="line-395"><code>		// emit low part</code></span>
<span class="codeline" id="line-396"><code>		ryuDigits32(d, llo, clo, ulo,</code></span>
<span class="codeline" id="line-397"><code>			c0, cup, d.nd+8)</code></span>
<span class="codeline" id="line-398"><code>	}</code></span>
<span class="codeline" id="line-399"><code>	// trim trailing zeros</code></span>
<span class="codeline" id="line-400"><code>	for d.nd &gt; 0 &amp;&amp; d.d[d.nd-1] == '0' {</code></span>
<span class="codeline" id="line-401"><code>		d.nd--</code></span>
<span class="codeline" id="line-402"><code>	}</code></span>
<span class="codeline" id="line-403"><code>	// trim initial zeros</code></span>
<span class="codeline" id="line-404"><code>	for d.nd &gt; 0 &amp;&amp; d.d[0] == '0' {</code></span>
<span class="codeline" id="line-405"><code>		d.nd--</code></span>
<span class="codeline" id="line-406"><code>		d.dp--</code></span>
<span class="codeline" id="line-407"><code>		d.d = d.d[1:]</code></span>
<span class="codeline" id="line-408"><code>	}</code></span>
<span class="codeline" id="line-409"><code>}</code></span>
<span class="codeline" id="line-410"><code></code></span>
<span class="codeline" id="line-411"><code>// ryuDigits32 emits decimal digits for a number less than 1e9.</code></span>
<span class="codeline" id="line-412"><code>func ryuDigits32(d *decimalSlice, lower, central, upper uint32,</code></span>
<span class="codeline" id="line-413"><code>	c0, cup bool, endindex int) {</code></span>
<span class="codeline" id="line-414"><code>	if upper == 0 {</code></span>
<span class="codeline" id="line-415"><code>		d.dp = endindex + 1</code></span>
<span class="codeline" id="line-416"><code>		return</code></span>
<span class="codeline" id="line-417"><code>	}</code></span>
<span class="codeline" id="line-418"><code>	trimmed := 0</code></span>
<span class="codeline" id="line-419"><code>	// Remember last trimmed digit to check for round-up.</code></span>
<span class="codeline" id="line-420"><code>	// c0 will be used to remember zeroness of following digits.</code></span>
<span class="codeline" id="line-421"><code>	cNextDigit := 0</code></span>
<span class="codeline" id="line-422"><code>	for upper &gt; 0 {</code></span>
<span class="codeline" id="line-423"><code>		// Repeatedly compute:</code></span>
<span class="codeline" id="line-424"><code>		// l = Ceil(lower / 10^k)</code></span>
<span class="codeline" id="line-425"><code>		// c = Round(central / 10^k)</code></span>
<span class="codeline" id="line-426"><code>		// u = Floor(upper / 10^k)</code></span>
<span class="codeline" id="line-427"><code>		// and stop when c goes out of the (l, u) interval.</code></span>
<span class="codeline" id="line-428"><code>		l := (lower + 9) / 10</code></span>
<span class="codeline" id="line-429"><code>		c, cdigit := central/10, central%10</code></span>
<span class="codeline" id="line-430"><code>		u := upper / 10</code></span>
<span class="codeline" id="line-431"><code>		if l &gt; u {</code></span>
<span class="codeline" id="line-432"><code>			// don't trim the last digit as it is forbidden to go below l</code></span>
<span class="codeline" id="line-433"><code>			// other, trim and exit now.</code></span>
<span class="codeline" id="line-434"><code>			break</code></span>
<span class="codeline" id="line-435"><code>		}</code></span>
<span class="codeline" id="line-436"><code>		// Check that we didn't cross the lower boundary.</code></span>
<span class="codeline" id="line-437"><code>		// The case where l &lt; u but c == l-1 is essentially impossible,</code></span>
<span class="codeline" id="line-438"><code>		// but may happen if:</code></span>
<span class="codeline" id="line-439"><code>		//    lower   = ..11</code></span>
<span class="codeline" id="line-440"><code>		//    central = ..19</code></span>
<span class="codeline" id="line-441"><code>		//    upper   = ..31</code></span>
<span class="codeline" id="line-442"><code>		// and means that 'central' is very close but less than</code></span>
<span class="codeline" id="line-443"><code>		// an integer ending with many zeros, and usually</code></span>
<span class="codeline" id="line-444"><code>		// the "round-up" logic hides the problem.</code></span>
<span class="codeline" id="line-445"><code>		if l == c+1 &amp;&amp; c &lt; u {</code></span>
<span class="codeline" id="line-446"><code>			c++</code></span>
<span class="codeline" id="line-447"><code>			cdigit = 0</code></span>
<span class="codeline" id="line-448"><code>			cup = false</code></span>
<span class="codeline" id="line-449"><code>		}</code></span>
<span class="codeline" id="line-450"><code>		trimmed++</code></span>
<span class="codeline" id="line-451"><code>		// Remember trimmed digits of c</code></span>
<span class="codeline" id="line-452"><code>		c0 = c0 &amp;&amp; cNextDigit == 0</code></span>
<span class="codeline" id="line-453"><code>		cNextDigit = int(cdigit)</code></span>
<span class="codeline" id="line-454"><code>		lower, central, upper = l, c, u</code></span>
<span class="codeline" id="line-455"><code>	}</code></span>
<span class="codeline" id="line-456"><code>	// should we round up?</code></span>
<span class="codeline" id="line-457"><code>	if trimmed &gt; 0 {</code></span>
<span class="codeline" id="line-458"><code>		cup = cNextDigit &gt; 5 ||</code></span>
<span class="codeline" id="line-459"><code>			(cNextDigit == 5 &amp;&amp; !c0) ||</code></span>
<span class="codeline" id="line-460"><code>			(cNextDigit == 5 &amp;&amp; c0 &amp;&amp; central&amp;1 == 1)</code></span>
<span class="codeline" id="line-461"><code>	}</code></span>
<span class="codeline" id="line-462"><code>	if central &lt; upper &amp;&amp; cup {</code></span>
<span class="codeline" id="line-463"><code>		central++</code></span>
<span class="codeline" id="line-464"><code>	}</code></span>
<span class="codeline" id="line-465"><code>	// We know where the number ends, fill directly</code></span>
<span class="codeline" id="line-466"><code>	endindex -= trimmed</code></span>
<span class="codeline" id="line-467"><code>	v := central</code></span>
<span class="codeline" id="line-468"><code>	n := endindex</code></span>
<span class="codeline" id="line-469"><code>	for n &gt; d.nd {</code></span>
<span class="codeline" id="line-470"><code>		v1, v2 := v/100, v%100</code></span>
<span class="codeline" id="line-471"><code>		d.d[n] = smallsString[2*v2+1]</code></span>
<span class="codeline" id="line-472"><code>		d.d[n-1] = smallsString[2*v2+0]</code></span>
<span class="codeline" id="line-473"><code>		n -= 2</code></span>
<span class="codeline" id="line-474"><code>		v = v1</code></span>
<span class="codeline" id="line-475"><code>	}</code></span>
<span class="codeline" id="line-476"><code>	if n == d.nd {</code></span>
<span class="codeline" id="line-477"><code>		d.d[n] = byte(v + '0')</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code>	d.nd = endindex + 1</code></span>
<span class="codeline" id="line-480"><code>	d.dp = d.nd + trimmed</code></span>
<span class="codeline" id="line-481"><code>}</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>// mult64bitPow10 takes a floating-point input with a 25-bit</code></span>
<span class="codeline" id="line-484"><code>// mantissa and multiplies it with 10^q. The resulting mantissa</code></span>
<span class="codeline" id="line-485"><code>// is m*P &gt;&gt; 57 where P is a 64-bit element of the detailedPowersOfTen tables.</code></span>
<span class="codeline" id="line-486"><code>// It is typically 31 or 32-bit wide.</code></span>
<span class="codeline" id="line-487"><code>// The returned boolean is true if all trimmed bits were zero.</code></span>
<span class="codeline" id="line-488"><code>//</code></span>
<span class="codeline" id="line-489"><code>// That is:</code></span>
<span class="codeline" id="line-490"><code>//</code></span>
<span class="codeline" id="line-491"><code>//	m*2^e2 * round(10^q) = resM * 2^resE + ε</code></span>
<span class="codeline" id="line-492"><code>//	exact = ε == 0</code></span>
<span class="codeline" id="line-493"><code>func mult64bitPow10(m uint32, e2, q int) (resM uint32, resE int, exact bool) {</code></span>
<span class="codeline" id="line-494"><code>	if q == 0 {</code></span>
<span class="codeline" id="line-495"><code>		// P == 1&lt;&lt;63</code></span>
<span class="codeline" id="line-496"><code>		return m &lt;&lt; 6, e2 - 6, true</code></span>
<span class="codeline" id="line-497"><code>	}</code></span>
<span class="codeline" id="line-498"><code>	if q &lt; detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 &lt; q {</code></span>
<span class="codeline" id="line-499"><code>		// This never happens due to the range of float32/float64 exponent</code></span>
<span class="codeline" id="line-500"><code>		panic("mult64bitPow10: power of 10 is out of range")</code></span>
<span class="codeline" id="line-501"><code>	}</code></span>
<span class="codeline" id="line-502"><code>	pow := detailedPowersOfTen[q-detailedPowersOfTenMinExp10][1]</code></span>
<span class="codeline" id="line-503"><code>	if q &lt; 0 {</code></span>
<span class="codeline" id="line-504"><code>		// Inverse powers of ten must be rounded up.</code></span>
<span class="codeline" id="line-505"><code>		pow += 1</code></span>
<span class="codeline" id="line-506"><code>	}</code></span>
<span class="codeline" id="line-507"><code>	hi, lo := bits.Mul64(uint64(m), pow)</code></span>
<span class="codeline" id="line-508"><code>	e2 += mulByLog10Log2(q) - 63 + 57</code></span>
<span class="codeline" id="line-509"><code>	return uint32(hi&lt;&lt;7 | lo&gt;&gt;57), e2, lo&lt;&lt;7 == 0</code></span>
<span class="codeline" id="line-510"><code>}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>// mult128bitPow10 takes a floating-point input with a 55-bit</code></span>
<span class="codeline" id="line-513"><code>// mantissa and multiplies it with 10^q. The resulting mantissa</code></span>
<span class="codeline" id="line-514"><code>// is m*P &gt;&gt; 119 where P is a 128-bit element of the detailedPowersOfTen tables.</code></span>
<span class="codeline" id="line-515"><code>// It is typically 63 or 64-bit wide.</code></span>
<span class="codeline" id="line-516"><code>// The returned boolean is true is all trimmed bits were zero.</code></span>
<span class="codeline" id="line-517"><code>//</code></span>
<span class="codeline" id="line-518"><code>// That is:</code></span>
<span class="codeline" id="line-519"><code>//</code></span>
<span class="codeline" id="line-520"><code>//	m*2^e2 * round(10^q) = resM * 2^resE + ε</code></span>
<span class="codeline" id="line-521"><code>//	exact = ε == 0</code></span>
<span class="codeline" id="line-522"><code>func mult128bitPow10(m uint64, e2, q int) (resM uint64, resE int, exact bool) {</code></span>
<span class="codeline" id="line-523"><code>	if q == 0 {</code></span>
<span class="codeline" id="line-524"><code>		// P == 1&lt;&lt;127</code></span>
<span class="codeline" id="line-525"><code>		return m &lt;&lt; 8, e2 - 8, true</code></span>
<span class="codeline" id="line-526"><code>	}</code></span>
<span class="codeline" id="line-527"><code>	if q &lt; detailedPowersOfTenMinExp10 || detailedPowersOfTenMaxExp10 &lt; q {</code></span>
<span class="codeline" id="line-528"><code>		// This never happens due to the range of float32/float64 exponent</code></span>
<span class="codeline" id="line-529"><code>		panic("mult128bitPow10: power of 10 is out of range")</code></span>
<span class="codeline" id="line-530"><code>	}</code></span>
<span class="codeline" id="line-531"><code>	pow := detailedPowersOfTen[q-detailedPowersOfTenMinExp10]</code></span>
<span class="codeline" id="line-532"><code>	if q &lt; 0 {</code></span>
<span class="codeline" id="line-533"><code>		// Inverse powers of ten must be rounded up.</code></span>
<span class="codeline" id="line-534"><code>		pow[0] += 1</code></span>
<span class="codeline" id="line-535"><code>	}</code></span>
<span class="codeline" id="line-536"><code>	e2 += mulByLog10Log2(q) - 127 + 119</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>	// long multiplication</code></span>
<span class="codeline" id="line-539"><code>	l1, l0 := bits.Mul64(m, pow[0])</code></span>
<span class="codeline" id="line-540"><code>	h1, h0 := bits.Mul64(m, pow[1])</code></span>
<span class="codeline" id="line-541"><code>	mid, carry := bits.Add64(l1, h0, 0)</code></span>
<span class="codeline" id="line-542"><code>	h1 += carry</code></span>
<span class="codeline" id="line-543"><code>	return h1&lt;&lt;9 | mid&gt;&gt;55, e2, mid&lt;&lt;9 == 0 &amp;&amp; l0 == 0</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>func divisibleByPower5(m uint64, k int) bool {</code></span>
<span class="codeline" id="line-547"><code>	if m == 0 {</code></span>
<span class="codeline" id="line-548"><code>		return true</code></span>
<span class="codeline" id="line-549"><code>	}</code></span>
<span class="codeline" id="line-550"><code>	for i := 0; i &lt; k; i++ {</code></span>
<span class="codeline" id="line-551"><code>		if m%5 != 0 {</code></span>
<span class="codeline" id="line-552"><code>			return false</code></span>
<span class="codeline" id="line-553"><code>		}</code></span>
<span class="codeline" id="line-554"><code>		m /= 5</code></span>
<span class="codeline" id="line-555"><code>	}</code></span>
<span class="codeline" id="line-556"><code>	return true</code></span>
<span class="codeline" id="line-557"><code>}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>// divmod1e9 computes quotient and remainder of division by 1e9,</code></span>
<span class="codeline" id="line-560"><code>// avoiding runtime uint64 division on 32-bit platforms.</code></span>
<span class="codeline" id="line-561"><code>func divmod1e9(x uint64) (uint32, uint32) {</code></span>
<span class="codeline" id="line-562"><code>	if !host32bit {</code></span>
<span class="codeline" id="line-563"><code>		return uint32(x / 1e9), uint32(x % 1e9)</code></span>
<span class="codeline" id="line-564"><code>	}</code></span>
<span class="codeline" id="line-565"><code>	// Use the same sequence of operations as the amd64 compiler.</code></span>
<span class="codeline" id="line-566"><code>	hi, _ := bits.Mul64(x&gt;&gt;1, 0x89705f4136b4a598) // binary digits of 1e-9</code></span>
<span class="codeline" id="line-567"><code>	q := hi &gt;&gt; 28</code></span>
<span class="codeline" id="line-568"><code>	return uint32(q), uint32(x - q*1e9)</code></span>
<span class="codeline" id="line-569"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>