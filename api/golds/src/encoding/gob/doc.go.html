<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package encoding/gob</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/gob.html">encoding/gob</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>Package gob manages streams of gobs - binary values exchanged between an</code></span>
<span class="codeline" id="line-7"><code>[Encoder] (transmitter) and a [Decoder] (receiver). A typical use is transporting</code></span>
<span class="codeline" id="line-8"><code>arguments and results of remote procedure calls (RPCs) such as those provided by</code></span>
<span class="codeline" id="line-9"><code>[net/rpc].</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>The implementation compiles a custom codec for each data type in the stream and</code></span>
<span class="codeline" id="line-12"><code>is most efficient when a single [Encoder] is used to transmit a stream of values,</code></span>
<span class="codeline" id="line-13"><code>amortizing the cost of compilation.</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code># Basics</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>A stream of gobs is self-describing. Each data item in the stream is preceded by</code></span>
<span class="codeline" id="line-18"><code>a specification of its type, expressed in terms of a small set of predefined</code></span>
<span class="codeline" id="line-19"><code>types. Pointers are not transmitted, but the things they point to are</code></span>
<span class="codeline" id="line-20"><code>transmitted; that is, the values are flattened. Nil pointers are not permitted,</code></span>
<span class="codeline" id="line-21"><code>as they have no value. Recursive types work fine, but</code></span>
<span class="codeline" id="line-22"><code>recursive values (data with cycles) are problematic. This may change.</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>To use gobs, create an [Encoder] and present it with a series of data items as</code></span>
<span class="codeline" id="line-25"><code>values or addresses that can be dereferenced to values. The [Encoder] makes sure</code></span>
<span class="codeline" id="line-26"><code>all type information is sent before it is needed. At the receive side, a</code></span>
<span class="codeline" id="line-27"><code>[Decoder] retrieves values from the encoded stream and unpacks them into local</code></span>
<span class="codeline" id="line-28"><code>variables.</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code># Types and Values</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>The source and destination values/types need not correspond exactly. For structs,</code></span>
<span class="codeline" id="line-33"><code>fields (identified by name) that are in the source but absent from the receiving</code></span>
<span class="codeline" id="line-34"><code>variable will be ignored. Fields that are in the receiving variable but missing</code></span>
<span class="codeline" id="line-35"><code>from the transmitted type or value will be ignored in the destination. If a field</code></span>
<span class="codeline" id="line-36"><code>with the same name is present in both, their types must be compatible. Both the</code></span>
<span class="codeline" id="line-37"><code>receiver and transmitter will do all necessary indirection and dereferencing to</code></span>
<span class="codeline" id="line-38"><code>convert between gobs and actual Go values. For instance, a gob type that is</code></span>
<span class="codeline" id="line-39"><code>schematically,</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>	struct { A, B int }</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>can be sent from or received into any of these Go types:</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>	struct { A, B int }	// the same</code></span>
<span class="codeline" id="line-46"><code>	*struct { A, B int }	// extra indirection of the struct</code></span>
<span class="codeline" id="line-47"><code>	struct { *A, **B int }	// extra indirection of the fields</code></span>
<span class="codeline" id="line-48"><code>	struct { A, B int64 }	// different concrete value type; see below</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>It may also be received into any of these:</code></span>
<span class="codeline" id="line-51"><code></code></span>
<span class="codeline" id="line-52"><code>	struct { A, B int }	// the same</code></span>
<span class="codeline" id="line-53"><code>	struct { B, A int }	// ordering doesn't matter; matching is by name</code></span>
<span class="codeline" id="line-54"><code>	struct { A, B, C int }	// extra field (C) ignored</code></span>
<span class="codeline" id="line-55"><code>	struct { B int }	// missing field (A) ignored; data will be dropped</code></span>
<span class="codeline" id="line-56"><code>	struct { B, C int }	// missing field (A) ignored; extra field (C) ignored.</code></span>
<span class="codeline" id="line-57"><code></code></span>
<span class="codeline" id="line-58"><code>Attempting to receive into these types will draw a decode error:</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	struct { A int; B uint }	// change of signedness for B</code></span>
<span class="codeline" id="line-61"><code>	struct { A int; B float }	// change of type for B</code></span>
<span class="codeline" id="line-62"><code>	struct { }			// no field names in common</code></span>
<span class="codeline" id="line-63"><code>	struct { C, D int }		// no field names in common</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>Integers are transmitted two ways: arbitrary precision signed integers or</code></span>
<span class="codeline" id="line-66"><code>arbitrary precision unsigned integers. There is no int8, int16 etc.</code></span>
<span class="codeline" id="line-67"><code>discrimination in the gob format; there are only signed and unsigned integers. As</code></span>
<span class="codeline" id="line-68"><code>described below, the transmitter sends the value in a variable-length encoding;</code></span>
<span class="codeline" id="line-69"><code>the receiver accepts the value and stores it in the destination variable.</code></span>
<span class="codeline" id="line-70"><code>Floating-point numbers are always sent using IEEE-754 64-bit precision (see</code></span>
<span class="codeline" id="line-71"><code>below).</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>Signed integers may be received into any signed integer variable: int, int16, etc.;</code></span>
<span class="codeline" id="line-74"><code>unsigned integers may be received into any unsigned integer variable; and floating</code></span>
<span class="codeline" id="line-75"><code>point values may be received into any floating point variable. However,</code></span>
<span class="codeline" id="line-76"><code>the destination variable must be able to represent the value or the decode</code></span>
<span class="codeline" id="line-77"><code>operation will fail.</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>Structs, arrays and slices are also supported. Structs encode and decode only</code></span>
<span class="codeline" id="line-80"><code>exported fields. Strings and arrays of bytes are supported with a special,</code></span>
<span class="codeline" id="line-81"><code>efficient representation (see below). When a slice is decoded, if the existing</code></span>
<span class="codeline" id="line-82"><code>slice has capacity the slice will be extended in place; if not, a new array is</code></span>
<span class="codeline" id="line-83"><code>allocated. Regardless, the length of the resulting slice reports the number of</code></span>
<span class="codeline" id="line-84"><code>elements decoded.</code></span>
<span class="codeline" id="line-85"><code></code></span>
<span class="codeline" id="line-86"><code>In general, if allocation is required, the decoder will allocate memory. If not,</code></span>
<span class="codeline" id="line-87"><code>it will update the destination variables with values read from the stream. It does</code></span>
<span class="codeline" id="line-88"><code>not initialize them first, so if the destination is a compound value such as a</code></span>
<span class="codeline" id="line-89"><code>map, struct, or slice, the decoded values will be merged elementwise into the</code></span>
<span class="codeline" id="line-90"><code>existing variables.</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>Functions and channels will not be sent in a gob. Attempting to encode such a value</code></span>
<span class="codeline" id="line-93"><code>at the top level will fail. A struct field of chan or func type is treated exactly</code></span>
<span class="codeline" id="line-94"><code>like an unexported field and is ignored.</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>Gob can encode a value of any type implementing the [GobEncoder] or</code></span>
<span class="codeline" id="line-97"><code>[encoding.BinaryMarshaler] interfaces by calling the corresponding method,</code></span>
<span class="codeline" id="line-98"><code>in that order of preference.</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>Gob can decode a value of any type implementing the [GobDecoder] or</code></span>
<span class="codeline" id="line-101"><code>[encoding.BinaryUnmarshaler] interfaces by calling the corresponding method,</code></span>
<span class="codeline" id="line-102"><code>again in that order of preference.</code></span>
<span class="codeline" id="line-103"><code></code></span>
<span class="codeline" id="line-104"><code># Encoding Details</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>This section documents the encoding, details that are not important for most</code></span>
<span class="codeline" id="line-107"><code>users. Details are presented bottom-up.</code></span>
<span class="codeline" id="line-108"><code></code></span>
<span class="codeline" id="line-109"><code>An unsigned integer is sent one of two ways. If it is less than 128, it is sent</code></span>
<span class="codeline" id="line-110"><code>as a byte with that value. Otherwise it is sent as a minimal-length big-endian</code></span>
<span class="codeline" id="line-111"><code>(high byte first) byte stream holding the value, preceded by one byte holding the</code></span>
<span class="codeline" id="line-112"><code>byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and</code></span>
<span class="codeline" id="line-113"><code>256 is transmitted as (FE 01 00).</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>A boolean is encoded within an unsigned integer: 0 for false, 1 for true.</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>A signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1</code></span>
<span class="codeline" id="line-118"><code>upward contain the value; bit 0 says whether they should be complemented upon</code></span>
<span class="codeline" id="line-119"><code>receipt. The encode algorithm looks like this:</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>	var u uint</code></span>
<span class="codeline" id="line-122"><code>	if i &lt; 0 {</code></span>
<span class="codeline" id="line-123"><code>		u = (^uint(i) &lt;&lt; 1) | 1 // complement i, bit 0 is 1</code></span>
<span class="codeline" id="line-124"><code>	} else {</code></span>
<span class="codeline" id="line-125"><code>		u = (uint(i) &lt;&lt; 1) // do not complement i, bit 0 is 0</code></span>
<span class="codeline" id="line-126"><code>	}</code></span>
<span class="codeline" id="line-127"><code>	encodeUnsigned(u)</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>The low bit is therefore analogous to a sign bit, but making it the complement bit</code></span>
<span class="codeline" id="line-130"><code>instead guarantees that the largest negative integer is not a special case. For</code></span>
<span class="codeline" id="line-131"><code>example, -129=^128=(^256&gt;&gt;1) encodes as (FE 01 01).</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>Floating-point numbers are always sent as a representation of a float64 value.</code></span>
<span class="codeline" id="line-134"><code>That value is converted to a uint64 using [math.Float64bits]. The uint64 is then</code></span>
<span class="codeline" id="line-135"><code>byte-reversed and sent as a regular unsigned integer. The byte-reversal means the</code></span>
<span class="codeline" id="line-136"><code>exponent and high-precision part of the mantissa go first. Since the low bits are</code></span>
<span class="codeline" id="line-137"><code>often zero, this can save encoding bytes. For instance, 17.0 is encoded in only</code></span>
<span class="codeline" id="line-138"><code>three bytes (FE 31 40).</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>Strings and slices of bytes are sent as an unsigned count followed by that many</code></span>
<span class="codeline" id="line-141"><code>uninterpreted bytes of the value.</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>All other slices and arrays are sent as an unsigned count followed by that many</code></span>
<span class="codeline" id="line-144"><code>elements using the standard gob encoding for their type, recursively.</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>Maps are sent as an unsigned count followed by that many key, element</code></span>
<span class="codeline" id="line-147"><code>pairs. Empty but non-nil maps are sent, so if the receiver has not allocated</code></span>
<span class="codeline" id="line-148"><code>one already, one will always be allocated on receipt unless the transmitted map</code></span>
<span class="codeline" id="line-149"><code>is nil and not at the top level.</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>In slices and arrays, as well as maps, all elements, even zero-valued elements,</code></span>
<span class="codeline" id="line-152"><code>are transmitted, even if all the elements are zero.</code></span>
<span class="codeline" id="line-153"><code></code></span>
<span class="codeline" id="line-154"><code>Structs are sent as a sequence of (field number, field value) pairs. The field</code></span>
<span class="codeline" id="line-155"><code>value is sent using the standard gob encoding for its type, recursively. If a</code></span>
<span class="codeline" id="line-156"><code>field has the zero value for its type (except for arrays; see above), it is omitted</code></span>
<span class="codeline" id="line-157"><code>from the transmission. The field number is defined by the type of the encoded</code></span>
<span class="codeline" id="line-158"><code>struct: the first field of the encoded type is field 0, the second is field 1,</code></span>
<span class="codeline" id="line-159"><code>etc. When encoding a value, the field numbers are delta encoded for efficiency</code></span>
<span class="codeline" id="line-160"><code>and the fields are always sent in order of increasing field number; the deltas are</code></span>
<span class="codeline" id="line-161"><code>therefore unsigned. The initialization for the delta encoding sets the field</code></span>
<span class="codeline" id="line-162"><code>number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned</code></span>
<span class="codeline" id="line-163"><code>delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been</code></span>
<span class="codeline" id="line-164"><code>sent a terminating mark denotes the end of the struct. That mark is a delta=0</code></span>
<span class="codeline" id="line-165"><code>value, which has representation (00).</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>Interface types are not checked for compatibility; all interface types are</code></span>
<span class="codeline" id="line-168"><code>treated, for transmission, as members of a single "interface" type, analogous to</code></span>
<span class="codeline" id="line-169"><code>int or []byte - in effect they're all treated as interface{}. Interface values</code></span>
<span class="codeline" id="line-170"><code>are transmitted as a string identifying the concrete type being sent (a name</code></span>
<span class="codeline" id="line-171"><code>that must be pre-defined by calling [Register]), followed by a byte count of the</code></span>
<span class="codeline" id="line-172"><code>length of the following data (so the value can be skipped if it cannot be</code></span>
<span class="codeline" id="line-173"><code>stored), followed by the usual encoding of concrete (dynamic) value stored in</code></span>
<span class="codeline" id="line-174"><code>the interface value. (A nil interface value is identified by the empty string</code></span>
<span class="codeline" id="line-175"><code>and transmits no value.) Upon receipt, the decoder verifies that the unpacked</code></span>
<span class="codeline" id="line-176"><code>concrete item satisfies the interface of the receiving variable.</code></span>
<span class="codeline" id="line-177"><code></code></span>
<span class="codeline" id="line-178"><code>If a value is passed to [Encoder.Encode] and the type is not a struct (or pointer to struct,</code></span>
<span class="codeline" id="line-179"><code>etc.), for simplicity of processing it is represented as a struct of one field.</code></span>
<span class="codeline" id="line-180"><code>The only visible effect of this is to encode a zero byte after the value, just as</code></span>
<span class="codeline" id="line-181"><code>after the last field of an encoded struct, so that the decode algorithm knows when</code></span>
<span class="codeline" id="line-182"><code>the top-level value is complete.</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>The representation of types is described below. When a type is defined on a given</code></span>
<span class="codeline" id="line-185"><code>connection between an [Encoder] and [Decoder], it is assigned a signed integer type</code></span>
<span class="codeline" id="line-186"><code>id. When [Encoder.Encode](v) is called, it makes sure there is an id assigned for</code></span>
<span class="codeline" id="line-187"><code>the type of v and all its elements and then it sends the pair (typeid, encoded-v)</code></span>
<span class="codeline" id="line-188"><code>where typeid is the type id of the encoded type of v and encoded-v is the gob</code></span>
<span class="codeline" id="line-189"><code>encoding of the value v.</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>To define a type, the encoder chooses an unused, positive type id and sends the</code></span>
<span class="codeline" id="line-192"><code>pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType</code></span>
<span class="codeline" id="line-193"><code>description, constructed from these types:</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	type wireType struct {</code></span>
<span class="codeline" id="line-196"><code>		ArrayT           *ArrayType</code></span>
<span class="codeline" id="line-197"><code>		SliceT           *SliceType</code></span>
<span class="codeline" id="line-198"><code>		StructT          *StructType</code></span>
<span class="codeline" id="line-199"><code>		MapT             *MapType</code></span>
<span class="codeline" id="line-200"><code>		GobEncoderT      *gobEncoderType</code></span>
<span class="codeline" id="line-201"><code>		BinaryMarshalerT *gobEncoderType</code></span>
<span class="codeline" id="line-202"><code>		TextMarshalerT   *gobEncoderType</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	type arrayType struct {</code></span>
<span class="codeline" id="line-206"><code>		CommonType</code></span>
<span class="codeline" id="line-207"><code>		Elem typeId</code></span>
<span class="codeline" id="line-208"><code>		Len  int</code></span>
<span class="codeline" id="line-209"><code>	}</code></span>
<span class="codeline" id="line-210"><code>	type CommonType struct {</code></span>
<span class="codeline" id="line-211"><code>		Name string // the name of the struct type</code></span>
<span class="codeline" id="line-212"><code>		Id  int    // the id of the type, repeated so it's inside the type</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code>	type sliceType struct {</code></span>
<span class="codeline" id="line-215"><code>		CommonType</code></span>
<span class="codeline" id="line-216"><code>		Elem typeId</code></span>
<span class="codeline" id="line-217"><code>	}</code></span>
<span class="codeline" id="line-218"><code>	type structType struct {</code></span>
<span class="codeline" id="line-219"><code>		CommonType</code></span>
<span class="codeline" id="line-220"><code>		Field []*fieldType // the fields of the struct.</code></span>
<span class="codeline" id="line-221"><code>	}</code></span>
<span class="codeline" id="line-222"><code>	type fieldType struct {</code></span>
<span class="codeline" id="line-223"><code>		Name string // the name of the field.</code></span>
<span class="codeline" id="line-224"><code>		Id   int    // the type id of the field, which must be already defined</code></span>
<span class="codeline" id="line-225"><code>	}</code></span>
<span class="codeline" id="line-226"><code>	type mapType struct {</code></span>
<span class="codeline" id="line-227"><code>		CommonType</code></span>
<span class="codeline" id="line-228"><code>		Key  typeId</code></span>
<span class="codeline" id="line-229"><code>		Elem typeId</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	type gobEncoderType struct {</code></span>
<span class="codeline" id="line-232"><code>		CommonType</code></span>
<span class="codeline" id="line-233"><code>	}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>If there are nested type ids, the types for all inner type ids must be defined</code></span>
<span class="codeline" id="line-236"><code>before the top-level type id is used to describe an encoded-v.</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>For simplicity in setup, the connection is defined to understand these types a</code></span>
<span class="codeline" id="line-239"><code>priori, as well as the basic gob types int, uint, etc. Their ids are:</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	bool        1</code></span>
<span class="codeline" id="line-242"><code>	int         2</code></span>
<span class="codeline" id="line-243"><code>	uint        3</code></span>
<span class="codeline" id="line-244"><code>	float       4</code></span>
<span class="codeline" id="line-245"><code>	[]byte      5</code></span>
<span class="codeline" id="line-246"><code>	string      6</code></span>
<span class="codeline" id="line-247"><code>	complex     7</code></span>
<span class="codeline" id="line-248"><code>	interface   8</code></span>
<span class="codeline" id="line-249"><code>	// gap for reserved ids.</code></span>
<span class="codeline" id="line-250"><code>	WireType    16</code></span>
<span class="codeline" id="line-251"><code>	ArrayType   17</code></span>
<span class="codeline" id="line-252"><code>	CommonType  18</code></span>
<span class="codeline" id="line-253"><code>	SliceType   19</code></span>
<span class="codeline" id="line-254"><code>	StructType  20</code></span>
<span class="codeline" id="line-255"><code>	FieldType   21</code></span>
<span class="codeline" id="line-256"><code>	// 22 is slice of fieldType.</code></span>
<span class="codeline" id="line-257"><code>	MapType     23</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>Finally, each message created by a call to Encode is preceded by an encoded</code></span>
<span class="codeline" id="line-260"><code>unsigned integer count of the number of bytes remaining in the message. After</code></span>
<span class="codeline" id="line-261"><code>the initial type name, interface values are wrapped the same way; in effect, the</code></span>
<span class="codeline" id="line-262"><code>interface value acts like a recursive invocation of Encode.</code></span>
<span class="codeline" id="line-263"><code></code></span>
<span class="codeline" id="line-264"><code>In summary, a gob stream looks like</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>	(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>where * signifies zero or more repetitions and the type id of a value must</code></span>
<span class="codeline" id="line-269"><code>be predefined or be defined before the value in the stream.</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>Compatibility: Any future changes to the package will endeavor to maintain</code></span>
<span class="codeline" id="line-272"><code>compatibility with streams encoded using previous versions. That is, any released</code></span>
<span class="codeline" id="line-273"><code>version of this package should be able to decode data written with any previously</code></span>
<span class="codeline" id="line-274"><code>released version, subject to issues such as security fixes. See the Go compatibility</code></span>
<span class="codeline" id="line-275"><code>document for background: https://golang.org/doc/go1compat</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>See "Gobs of data" for a design discussion of the gob wire format:</code></span>
<span class="codeline" id="line-278"><code>https://blog.golang.org/gobs-of-data</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code># Security</code></span>
<span class="codeline" id="line-281"><code></code></span>
<span class="codeline" id="line-282"><code>This package is not designed to be hardened against adversarial inputs, and is</code></span>
<span class="codeline" id="line-283"><code>outside the scope of https://go.dev/security/policy. In particular, the [Decoder]</code></span>
<span class="codeline" id="line-284"><code>does only basic sanity checking on decoded input sizes, and its limits are not</code></span>
<span class="codeline" id="line-285"><code>configurable. Care should be taken when decoding gob data from untrusted</code></span>
<span class="codeline" id="line-286"><code>sources, which may consume significant resources.</code></span>
<span class="codeline" id="line-287"><code>*/</code></span></div><span class="codeline" id="line-288"><code>package gob</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>/*</code></span>
<span class="codeline" id="line-291"><code>Grammar:</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>Tokens starting with a lower case letter are terminals; int(n)</code></span>
<span class="codeline" id="line-294"><code>and uint(n) represent the signed/unsigned encodings of the value n.</code></span>
<span class="codeline" id="line-295"><code></code></span>
<span class="codeline" id="line-296"><code>GobStream:</code></span>
<span class="codeline" id="line-297"><code>	DelimitedMessage*</code></span>
<span class="codeline" id="line-298"><code>DelimitedMessage:</code></span>
<span class="codeline" id="line-299"><code>	uint(lengthOfMessage) Message</code></span>
<span class="codeline" id="line-300"><code>Message:</code></span>
<span class="codeline" id="line-301"><code>	TypeSequence TypedValue</code></span>
<span class="codeline" id="line-302"><code>TypeSequence</code></span>
<span class="codeline" id="line-303"><code>	(TypeDefinition DelimitedTypeDefinition*)?</code></span>
<span class="codeline" id="line-304"><code>DelimitedTypeDefinition:</code></span>
<span class="codeline" id="line-305"><code>	uint(lengthOfTypeDefinition) TypeDefinition</code></span>
<span class="codeline" id="line-306"><code>TypedValue:</code></span>
<span class="codeline" id="line-307"><code>	int(typeId) Value</code></span>
<span class="codeline" id="line-308"><code>TypeDefinition:</code></span>
<span class="codeline" id="line-309"><code>	int(-typeId) encodingOfWireType</code></span>
<span class="codeline" id="line-310"><code>Value:</code></span>
<span class="codeline" id="line-311"><code>	SingletonValue | StructValue</code></span>
<span class="codeline" id="line-312"><code>SingletonValue:</code></span>
<span class="codeline" id="line-313"><code>	uint(0) FieldValue</code></span>
<span class="codeline" id="line-314"><code>FieldValue:</code></span>
<span class="codeline" id="line-315"><code>	builtinValue | ArrayValue | MapValue | SliceValue | StructValue | InterfaceValue</code></span>
<span class="codeline" id="line-316"><code>InterfaceValue:</code></span>
<span class="codeline" id="line-317"><code>	NilInterfaceValue | NonNilInterfaceValue</code></span>
<span class="codeline" id="line-318"><code>NilInterfaceValue:</code></span>
<span class="codeline" id="line-319"><code>	uint(0)</code></span>
<span class="codeline" id="line-320"><code>NonNilInterfaceValue:</code></span>
<span class="codeline" id="line-321"><code>	ConcreteTypeName TypeSequence InterfaceContents</code></span>
<span class="codeline" id="line-322"><code>ConcreteTypeName:</code></span>
<span class="codeline" id="line-323"><code>	uint(lengthOfName) [already read=n] name</code></span>
<span class="codeline" id="line-324"><code>InterfaceContents:</code></span>
<span class="codeline" id="line-325"><code>	int(concreteTypeId) DelimitedValue</code></span>
<span class="codeline" id="line-326"><code>DelimitedValue:</code></span>
<span class="codeline" id="line-327"><code>	uint(length) Value</code></span>
<span class="codeline" id="line-328"><code>ArrayValue:</code></span>
<span class="codeline" id="line-329"><code>	uint(n) FieldValue*n [n elements]</code></span>
<span class="codeline" id="line-330"><code>MapValue:</code></span>
<span class="codeline" id="line-331"><code>	uint(n) (FieldValue FieldValue)*n  [n (key, value) pairs]</code></span>
<span class="codeline" id="line-332"><code>SliceValue:</code></span>
<span class="codeline" id="line-333"><code>	uint(n) FieldValue*n [n elements]</code></span>
<span class="codeline" id="line-334"><code>StructValue:</code></span>
<span class="codeline" id="line-335"><code>	(uint(fieldDelta) FieldValue)*</code></span>
<span class="codeline" id="line-336"><code>*/</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>/*</code></span>
<span class="codeline" id="line-339"><code>For implementers and the curious, here is an encoded example. Given</code></span>
<span class="codeline" id="line-340"><code>	type Point struct {X, Y int}</code></span>
<span class="codeline" id="line-341"><code>and the value</code></span>
<span class="codeline" id="line-342"><code>	p := Point{22, 33}</code></span>
<span class="codeline" id="line-343"><code>the bytes transmitted that encode p will be:</code></span>
<span class="codeline" id="line-344"><code>	1f ff 81 03 01 01 05 50 6f 69 6e 74 01 ff 82 00</code></span>
<span class="codeline" id="line-345"><code>	01 02 01 01 58 01 04 00 01 01 59 01 04 00 00 00</code></span>
<span class="codeline" id="line-346"><code>	07 ff 82 01 2c 01 42 00</code></span>
<span class="codeline" id="line-347"><code>They are determined as follows.</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>Since this is the first transmission of type Point, the type descriptor</code></span>
<span class="codeline" id="line-350"><code>for Point itself must be sent before the value. This is the first type</code></span>
<span class="codeline" id="line-351"><code>we've sent on this Encoder, so it has type id 65 (0 through 64 are</code></span>
<span class="codeline" id="line-352"><code>reserved).</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>	1f	// This item (a type descriptor) is 31 bytes long.</code></span>
<span class="codeline" id="line-355"><code>	ff 81	// The negative of the id for the type we're defining, -65.</code></span>
<span class="codeline" id="line-356"><code>		// This is one byte (indicated by FF = -1) followed by</code></span>
<span class="codeline" id="line-357"><code>		// ^-65&lt;&lt;1 | 1. The low 1 bit signals to complement the</code></span>
<span class="codeline" id="line-358"><code>		// rest upon receipt.</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>	// Now we send a type descriptor, which is itself a struct (wireType).</code></span>
<span class="codeline" id="line-361"><code>	// The type of wireType itself is known (it's built in, as is the type of</code></span>
<span class="codeline" id="line-362"><code>	// all its components), so we just need to send a *value* of type wireType</code></span>
<span class="codeline" id="line-363"><code>	// that represents type "Point".</code></span>
<span class="codeline" id="line-364"><code>	// Here starts the encoding of that value.</code></span>
<span class="codeline" id="line-365"><code>	// Set the field number implicitly to -1; this is done at the beginning</code></span>
<span class="codeline" id="line-366"><code>	// of every struct, including nested structs.</code></span>
<span class="codeline" id="line-367"><code>	03	// Add 3 to field number; now 2 (wireType.structType; this is a struct).</code></span>
<span class="codeline" id="line-368"><code>		// structType starts with an embedded CommonType, which appears</code></span>
<span class="codeline" id="line-369"><code>		// as a regular structure here too.</code></span>
<span class="codeline" id="line-370"><code>	01	// add 1 to field number (now 0); start of embedded CommonType.</code></span>
<span class="codeline" id="line-371"><code>	01	// add 1 to field number (now 0, the name of the type)</code></span>
<span class="codeline" id="line-372"><code>	05	// string is (unsigned) 5 bytes long</code></span>
<span class="codeline" id="line-373"><code>	50 6f 69 6e 74	// wireType.structType.CommonType.name = "Point"</code></span>
<span class="codeline" id="line-374"><code>	01	// add 1 to field number (now 1, the id of the type)</code></span>
<span class="codeline" id="line-375"><code>	ff 82	// wireType.structType.CommonType._id = 65</code></span>
<span class="codeline" id="line-376"><code>	00	// end of embedded wiretype.structType.CommonType struct</code></span>
<span class="codeline" id="line-377"><code>	01	// add 1 to field number (now 1, the field array in wireType.structType)</code></span>
<span class="codeline" id="line-378"><code>	02	// There are two fields in the type (len(structType.field))</code></span>
<span class="codeline" id="line-379"><code>	01	// Start of first field structure; add 1 to get field number 0: field[0].name</code></span>
<span class="codeline" id="line-380"><code>	01	// 1 byte</code></span>
<span class="codeline" id="line-381"><code>	58	// structType.field[0].name = "X"</code></span>
<span class="codeline" id="line-382"><code>	01	// Add 1 to get field number 1: field[0].id</code></span>
<span class="codeline" id="line-383"><code>	04	// structType.field[0].typeId is 2 (signed int).</code></span>
<span class="codeline" id="line-384"><code>	00	// End of structType.field[0]; start structType.field[1]; set field number to -1.</code></span>
<span class="codeline" id="line-385"><code>	01	// Add 1 to get field number 0: field[1].name</code></span>
<span class="codeline" id="line-386"><code>	01	// 1 byte</code></span>
<span class="codeline" id="line-387"><code>	59	// structType.field[1].name = "Y"</code></span>
<span class="codeline" id="line-388"><code>	01	// Add 1 to get field number 1: field[1].id</code></span>
<span class="codeline" id="line-389"><code>	04	// struct.Type.field[1].typeId is 2 (signed int).</code></span>
<span class="codeline" id="line-390"><code>	00	// End of structType.field[1]; end of structType.field.</code></span>
<span class="codeline" id="line-391"><code>	00	// end of wireType.structType structure</code></span>
<span class="codeline" id="line-392"><code>	00	// end of wireType structure</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>Now we can send the Point value. Again the field number resets to -1:</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>	07	// this value is 7 bytes long</code></span>
<span class="codeline" id="line-397"><code>	ff 82	// the type number, 65 (1 byte (-FF) followed by 65&lt;&lt;1)</code></span>
<span class="codeline" id="line-398"><code>	01	// add one to field number, yielding field 0</code></span>
<span class="codeline" id="line-399"><code>	2c	// encoding of signed "22" (0x2c = 44 = 22&lt;&lt;1); Point.x = 22</code></span>
<span class="codeline" id="line-400"><code>	01	// add one to field number, yielding field 1</code></span>
<span class="codeline" id="line-401"><code>	42	// encoding of signed "33" (0x42 = 66 = 33&lt;&lt;1); Point.y = 33</code></span>
<span class="codeline" id="line-402"><code>	00	// end of structure</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>The type encoding is long and fairly intricate but we send it only once.</code></span>
<span class="codeline" id="line-405"><code>If p is transmitted a second time, the type is already known so the</code></span>
<span class="codeline" id="line-406"><code>output will be just:</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>	07 ff 82 01 2c 01 42 00</code></span>
<span class="codeline" id="line-409"><code></code></span>
<span class="codeline" id="line-410"><code>A single non-struct value at top level is transmitted like a field with</code></span>
<span class="codeline" id="line-411"><code>delta tag 0. For instance, a signed integer with value 3 presented as</code></span>
<span class="codeline" id="line-412"><code>the argument to Encode will emit:</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>	03 04 00 06</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>Which represents:</code></span>
<span class="codeline" id="line-417"><code></code></span>
<span class="codeline" id="line-418"><code>	03	// this value is 3 bytes long</code></span>
<span class="codeline" id="line-419"><code>	04	// the type number, 2, represents an integer</code></span>
<span class="codeline" id="line-420"><code>	00	// tag delta 0</code></span>
<span class="codeline" id="line-421"><code>	06	// value 3</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>*/</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>