<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: marshal.go in package encoding/xml</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	marshal.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/encoding/xml.html">encoding/xml</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package xml</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"bufio"</code></span>
<span class="codeline" id="line-9"><code>	"bytes"</code></span>
<span class="codeline" id="line-10"><code>	"encoding"</code></span>
<span class="codeline" id="line-11"><code>	"errors"</code></span>
<span class="codeline" id="line-12"><code>	"fmt"</code></span>
<span class="codeline" id="line-13"><code>	"io"</code></span>
<span class="codeline" id="line-14"><code>	"reflect"</code></span>
<span class="codeline" id="line-15"><code>	"strconv"</code></span>
<span class="codeline" id="line-16"><code>	"strings"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>const (</code></span>
<span class="codeline" id="line-20"><code>	// Header is a generic XML header suitable for use with the output of [Marshal].</code></span>
<span class="codeline" id="line-21"><code>	// This is not automatically added to any output of this package,</code></span>
<span class="codeline" id="line-22"><code>	// it is provided as a convenience.</code></span>
<span class="codeline" id="line-23"><code>	Header = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;` + "\n"</code></span>
<span class="codeline" id="line-24"><code>)</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>// Marshal returns the XML encoding of v.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>// Marshal handles an array or slice by marshaling each of the elements.</code></span>
<span class="codeline" id="line-29"><code>// Marshal handles a pointer by marshaling the value it points at or, if the</code></span>
<span class="codeline" id="line-30"><code>// pointer is nil, by writing nothing. Marshal handles an interface value by</code></span>
<span class="codeline" id="line-31"><code>// marshaling the value it contains or, if the interface value is nil, by</code></span>
<span class="codeline" id="line-32"><code>// writing nothing. Marshal handles all other data by writing one or more XML</code></span>
<span class="codeline" id="line-33"><code>// elements containing the data.</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// The name for the XML elements is taken from, in order of preference:</code></span>
<span class="codeline" id="line-36"><code>//   - the tag on the XMLName field, if the data is a struct</code></span>
<span class="codeline" id="line-37"><code>//   - the value of the XMLName field of type [Name]</code></span>
<span class="codeline" id="line-38"><code>//   - the tag of the struct field used to obtain the data</code></span>
<span class="codeline" id="line-39"><code>//   - the name of the struct field used to obtain the data</code></span>
<span class="codeline" id="line-40"><code>//   - the name of the marshaled type</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// The XML element for a struct contains marshaled elements for each of the</code></span>
<span class="codeline" id="line-43"><code>// exported fields of the struct, with these exceptions:</code></span>
<span class="codeline" id="line-44"><code>//   - the XMLName field, described above, is omitted.</code></span>
<span class="codeline" id="line-45"><code>//   - a field with tag "-" is omitted.</code></span>
<span class="codeline" id="line-46"><code>//   - a field with tag "name,attr" becomes an attribute with</code></span>
<span class="codeline" id="line-47"><code>//     the given name in the XML element.</code></span>
<span class="codeline" id="line-48"><code>//   - a field with tag ",attr" becomes an attribute with the</code></span>
<span class="codeline" id="line-49"><code>//     field name in the XML element.</code></span>
<span class="codeline" id="line-50"><code>//   - a field with tag ",chardata" is written as character data,</code></span>
<span class="codeline" id="line-51"><code>//     not as an XML element.</code></span>
<span class="codeline" id="line-52"><code>//   - a field with tag ",cdata" is written as character data</code></span>
<span class="codeline" id="line-53"><code>//     wrapped in one or more &lt;![CDATA[ ... ]]&gt; tags, not as an XML element.</code></span>
<span class="codeline" id="line-54"><code>//   - a field with tag ",innerxml" is written verbatim, not subject</code></span>
<span class="codeline" id="line-55"><code>//     to the usual marshaling procedure.</code></span>
<span class="codeline" id="line-56"><code>//   - a field with tag ",comment" is written as an XML comment, not</code></span>
<span class="codeline" id="line-57"><code>//     subject to the usual marshaling procedure. It must not contain</code></span>
<span class="codeline" id="line-58"><code>//     the "--" string within it.</code></span>
<span class="codeline" id="line-59"><code>//   - a field with a tag including the "omitempty" option is omitted</code></span>
<span class="codeline" id="line-60"><code>//     if the field value is empty. The empty values are false, 0, any</code></span>
<span class="codeline" id="line-61"><code>//     nil pointer or interface value, and any array, slice, map, or</code></span>
<span class="codeline" id="line-62"><code>//     string of length zero.</code></span>
<span class="codeline" id="line-63"><code>//   - an anonymous struct field is handled as if the fields of its</code></span>
<span class="codeline" id="line-64"><code>//     value were part of the outer struct.</code></span>
<span class="codeline" id="line-65"><code>//   - a field implementing [Marshaler] is written by calling its MarshalXML</code></span>
<span class="codeline" id="line-66"><code>//     method.</code></span>
<span class="codeline" id="line-67"><code>//   - a field implementing [encoding.TextMarshaler] is written by encoding the</code></span>
<span class="codeline" id="line-68"><code>//     result of its MarshalText method as text.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// If a field uses a tag "a&gt;b&gt;c", then the element c will be nested inside</code></span>
<span class="codeline" id="line-71"><code>// parent elements a and b. Fields that appear next to each other that name</code></span>
<span class="codeline" id="line-72"><code>// the same parent will be enclosed in one XML element.</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>// If the XML name for a struct field is defined by both the field tag and the</code></span>
<span class="codeline" id="line-75"><code>// struct's XMLName field, the names must match.</code></span>
<span class="codeline" id="line-76"><code>//</code></span>
<span class="codeline" id="line-77"><code>// See [MarshalIndent] for an example.</code></span>
<span class="codeline" id="line-78"><code>//</code></span>
<span class="codeline" id="line-79"><code>// Marshal will return an error if asked to marshal a channel, function, or map.</code></span>
<span class="codeline" id="line-80"><code>func Marshal(v any) ([]byte, error) {</code></span>
<span class="codeline" id="line-81"><code>	var b bytes.Buffer</code></span>
<span class="codeline" id="line-82"><code>	enc := NewEncoder(&amp;b)</code></span>
<span class="codeline" id="line-83"><code>	if err := enc.Encode(v); err != nil {</code></span>
<span class="codeline" id="line-84"><code>		return nil, err</code></span>
<span class="codeline" id="line-85"><code>	}</code></span>
<span class="codeline" id="line-86"><code>	if err := enc.Close(); err != nil {</code></span>
<span class="codeline" id="line-87"><code>		return nil, err</code></span>
<span class="codeline" id="line-88"><code>	}</code></span>
<span class="codeline" id="line-89"><code>	return b.Bytes(), nil</code></span>
<span class="codeline" id="line-90"><code>}</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>// Marshaler is the interface implemented by objects that can marshal</code></span>
<span class="codeline" id="line-93"><code>// themselves into valid XML elements.</code></span>
<span class="codeline" id="line-94"><code>//</code></span>
<span class="codeline" id="line-95"><code>// MarshalXML encodes the receiver as zero or more XML elements.</code></span>
<span class="codeline" id="line-96"><code>// By convention, arrays or slices are typically encoded as a sequence</code></span>
<span class="codeline" id="line-97"><code>// of elements, one per entry.</code></span>
<span class="codeline" id="line-98"><code>// Using start as the element tag is not required, but doing so</code></span>
<span class="codeline" id="line-99"><code>// will enable [Unmarshal] to match the XML elements to the correct</code></span>
<span class="codeline" id="line-100"><code>// struct field.</code></span>
<span class="codeline" id="line-101"><code>// One common implementation strategy is to construct a separate</code></span>
<span class="codeline" id="line-102"><code>// value with a layout corresponding to the desired XML and then</code></span>
<span class="codeline" id="line-103"><code>// to encode it using e.EncodeElement.</code></span>
<span class="codeline" id="line-104"><code>// Another common strategy is to use repeated calls to e.EncodeToken</code></span>
<span class="codeline" id="line-105"><code>// to generate the XML output one token at a time.</code></span>
<span class="codeline" id="line-106"><code>// The sequence of encoded tokens must make up zero or more valid</code></span>
<span class="codeline" id="line-107"><code>// XML elements.</code></span>
<span class="codeline" id="line-108"><code>type Marshaler interface {</code></span>
<span class="codeline" id="line-109"><code>	MarshalXML(e *Encoder, start StartElement) error</code></span>
<span class="codeline" id="line-110"><code>}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>// MarshalerAttr is the interface implemented by objects that can marshal</code></span>
<span class="codeline" id="line-113"><code>// themselves into valid XML attributes.</code></span>
<span class="codeline" id="line-114"><code>//</code></span>
<span class="codeline" id="line-115"><code>// MarshalXMLAttr returns an XML attribute with the encoded value of the receiver.</code></span>
<span class="codeline" id="line-116"><code>// Using name as the attribute name is not required, but doing so</code></span>
<span class="codeline" id="line-117"><code>// will enable [Unmarshal] to match the attribute to the correct</code></span>
<span class="codeline" id="line-118"><code>// struct field.</code></span>
<span class="codeline" id="line-119"><code>// If MarshalXMLAttr returns the zero attribute [Attr]{}, no attribute</code></span>
<span class="codeline" id="line-120"><code>// will be generated in the output.</code></span>
<span class="codeline" id="line-121"><code>// MarshalXMLAttr is used only for struct fields with the</code></span>
<span class="codeline" id="line-122"><code>// "attr" option in the field tag.</code></span>
<span class="codeline" id="line-123"><code>type MarshalerAttr interface {</code></span>
<span class="codeline" id="line-124"><code>	MarshalXMLAttr(name Name) (Attr, error)</code></span>
<span class="codeline" id="line-125"><code>}</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// MarshalIndent works like [Marshal], but each XML element begins on a new</code></span>
<span class="codeline" id="line-128"><code>// indented line that starts with prefix and is followed by one or more</code></span>
<span class="codeline" id="line-129"><code>// copies of indent according to the nesting depth.</code></span>
<span class="codeline" id="line-130"><code>func MarshalIndent(v any, prefix, indent string) ([]byte, error) {</code></span>
<span class="codeline" id="line-131"><code>	var b bytes.Buffer</code></span>
<span class="codeline" id="line-132"><code>	enc := NewEncoder(&amp;b)</code></span>
<span class="codeline" id="line-133"><code>	enc.Indent(prefix, indent)</code></span>
<span class="codeline" id="line-134"><code>	if err := enc.Encode(v); err != nil {</code></span>
<span class="codeline" id="line-135"><code>		return nil, err</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	if err := enc.Close(); err != nil {</code></span>
<span class="codeline" id="line-138"><code>		return nil, err</code></span>
<span class="codeline" id="line-139"><code>	}</code></span>
<span class="codeline" id="line-140"><code>	return b.Bytes(), nil</code></span>
<span class="codeline" id="line-141"><code>}</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>// An Encoder writes XML data to an output stream.</code></span>
<span class="codeline" id="line-144"><code>type Encoder struct {</code></span>
<span class="codeline" id="line-145"><code>	p printer</code></span>
<span class="codeline" id="line-146"><code>}</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>// NewEncoder returns a new encoder that writes to w.</code></span>
<span class="codeline" id="line-149"><code>func NewEncoder(w io.Writer) *Encoder {</code></span>
<span class="codeline" id="line-150"><code>	e := &amp;Encoder{printer{w: bufio.NewWriter(w)}}</code></span>
<span class="codeline" id="line-151"><code>	e.p.encoder = e</code></span>
<span class="codeline" id="line-152"><code>	return e</code></span>
<span class="codeline" id="line-153"><code>}</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>// Indent sets the encoder to generate XML in which each element</code></span>
<span class="codeline" id="line-156"><code>// begins on a new indented line that starts with prefix and is followed by</code></span>
<span class="codeline" id="line-157"><code>// one or more copies of indent according to the nesting depth.</code></span>
<span class="codeline" id="line-158"><code>func (enc *Encoder) Indent(prefix, indent string) {</code></span>
<span class="codeline" id="line-159"><code>	enc.p.prefix = prefix</code></span>
<span class="codeline" id="line-160"><code>	enc.p.indent = indent</code></span>
<span class="codeline" id="line-161"><code>}</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>// Encode writes the XML encoding of v to the stream.</code></span>
<span class="codeline" id="line-164"><code>//</code></span>
<span class="codeline" id="line-165"><code>// See the documentation for [Marshal] for details about the conversion</code></span>
<span class="codeline" id="line-166"><code>// of Go values to XML.</code></span>
<span class="codeline" id="line-167"><code>//</code></span>
<span class="codeline" id="line-168"><code>// Encode calls [Encoder.Flush] before returning.</code></span>
<span class="codeline" id="line-169"><code>func (enc *Encoder) Encode(v any) error {</code></span>
<span class="codeline" id="line-170"><code>	err := enc.p.marshalValue(reflect.ValueOf(v), nil, nil)</code></span>
<span class="codeline" id="line-171"><code>	if err != nil {</code></span>
<span class="codeline" id="line-172"><code>		return err</code></span>
<span class="codeline" id="line-173"><code>	}</code></span>
<span class="codeline" id="line-174"><code>	return enc.p.w.Flush()</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// EncodeElement writes the XML encoding of v to the stream,</code></span>
<span class="codeline" id="line-178"><code>// using start as the outermost tag in the encoding.</code></span>
<span class="codeline" id="line-179"><code>//</code></span>
<span class="codeline" id="line-180"><code>// See the documentation for [Marshal] for details about the conversion</code></span>
<span class="codeline" id="line-181"><code>// of Go values to XML.</code></span>
<span class="codeline" id="line-182"><code>//</code></span>
<span class="codeline" id="line-183"><code>// EncodeElement calls [Encoder.Flush] before returning.</code></span>
<span class="codeline" id="line-184"><code>func (enc *Encoder) EncodeElement(v any, start StartElement) error {</code></span>
<span class="codeline" id="line-185"><code>	err := enc.p.marshalValue(reflect.ValueOf(v), nil, &amp;start)</code></span>
<span class="codeline" id="line-186"><code>	if err != nil {</code></span>
<span class="codeline" id="line-187"><code>		return err</code></span>
<span class="codeline" id="line-188"><code>	}</code></span>
<span class="codeline" id="line-189"><code>	return enc.p.w.Flush()</code></span>
<span class="codeline" id="line-190"><code>}</code></span>
<span class="codeline" id="line-191"><code></code></span>
<span class="codeline" id="line-192"><code>var (</code></span>
<span class="codeline" id="line-193"><code>	begComment  = []byte("&lt;!--")</code></span>
<span class="codeline" id="line-194"><code>	endComment  = []byte("--&gt;")</code></span>
<span class="codeline" id="line-195"><code>	endProcInst = []byte("?&gt;")</code></span>
<span class="codeline" id="line-196"><code>)</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>// EncodeToken writes the given XML token to the stream.</code></span>
<span class="codeline" id="line-199"><code>// It returns an error if [StartElement] and [EndElement] tokens are not properly matched.</code></span>
<span class="codeline" id="line-200"><code>//</code></span>
<span class="codeline" id="line-201"><code>// EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation</code></span>
<span class="codeline" id="line-202"><code>// such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked</code></span>
<span class="codeline" id="line-203"><code>// during those), and those will call Flush when finished.</code></span>
<span class="codeline" id="line-204"><code>// Callers that create an Encoder and then invoke EncodeToken directly, without</code></span>
<span class="codeline" id="line-205"><code>// using Encode or EncodeElement, need to call Flush when finished to ensure</code></span>
<span class="codeline" id="line-206"><code>// that the XML is written to the underlying writer.</code></span>
<span class="codeline" id="line-207"><code>//</code></span>
<span class="codeline" id="line-208"><code>// EncodeToken allows writing a [ProcInst] with Target set to "xml" only as the first token</code></span>
<span class="codeline" id="line-209"><code>// in the stream.</code></span>
<span class="codeline" id="line-210"><code>func (enc *Encoder) EncodeToken(t Token) error {</code></span>
<span class="codeline" id="line-211"><code></code></span>
<span class="codeline" id="line-212"><code>	p := &amp;enc.p</code></span>
<span class="codeline" id="line-213"><code>	switch t := t.(type) {</code></span>
<span class="codeline" id="line-214"><code>	case StartElement:</code></span>
<span class="codeline" id="line-215"><code>		if err := p.writeStart(&amp;t); err != nil {</code></span>
<span class="codeline" id="line-216"><code>			return err</code></span>
<span class="codeline" id="line-217"><code>		}</code></span>
<span class="codeline" id="line-218"><code>	case EndElement:</code></span>
<span class="codeline" id="line-219"><code>		if err := p.writeEnd(t.Name); err != nil {</code></span>
<span class="codeline" id="line-220"><code>			return err</code></span>
<span class="codeline" id="line-221"><code>		}</code></span>
<span class="codeline" id="line-222"><code>	case CharData:</code></span>
<span class="codeline" id="line-223"><code>		escapeText(p, t, false)</code></span>
<span class="codeline" id="line-224"><code>	case Comment:</code></span>
<span class="codeline" id="line-225"><code>		if bytes.Contains(t, endComment) {</code></span>
<span class="codeline" id="line-226"><code>			return fmt.Errorf("xml: EncodeToken of Comment containing --&gt; marker")</code></span>
<span class="codeline" id="line-227"><code>		}</code></span>
<span class="codeline" id="line-228"><code>		p.WriteString("&lt;!--")</code></span>
<span class="codeline" id="line-229"><code>		p.Write(t)</code></span>
<span class="codeline" id="line-230"><code>		p.WriteString("--&gt;")</code></span>
<span class="codeline" id="line-231"><code>		return p.cachedWriteError()</code></span>
<span class="codeline" id="line-232"><code>	case ProcInst:</code></span>
<span class="codeline" id="line-233"><code>		// First token to be encoded which is also a ProcInst with target of xml</code></span>
<span class="codeline" id="line-234"><code>		// is the xml declaration. The only ProcInst where target of xml is allowed.</code></span>
<span class="codeline" id="line-235"><code>		if t.Target == "xml" &amp;&amp; p.w.Buffered() != 0 {</code></span>
<span class="codeline" id="line-236"><code>			return fmt.Errorf("xml: EncodeToken of ProcInst xml target only valid for xml declaration, first token encoded")</code></span>
<span class="codeline" id="line-237"><code>		}</code></span>
<span class="codeline" id="line-238"><code>		if !isNameString(t.Target) {</code></span>
<span class="codeline" id="line-239"><code>			return fmt.Errorf("xml: EncodeToken of ProcInst with invalid Target")</code></span>
<span class="codeline" id="line-240"><code>		}</code></span>
<span class="codeline" id="line-241"><code>		if bytes.Contains(t.Inst, endProcInst) {</code></span>
<span class="codeline" id="line-242"><code>			return fmt.Errorf("xml: EncodeToken of ProcInst containing ?&gt; marker")</code></span>
<span class="codeline" id="line-243"><code>		}</code></span>
<span class="codeline" id="line-244"><code>		p.WriteString("&lt;?")</code></span>
<span class="codeline" id="line-245"><code>		p.WriteString(t.Target)</code></span>
<span class="codeline" id="line-246"><code>		if len(t.Inst) &gt; 0 {</code></span>
<span class="codeline" id="line-247"><code>			p.WriteByte(' ')</code></span>
<span class="codeline" id="line-248"><code>			p.Write(t.Inst)</code></span>
<span class="codeline" id="line-249"><code>		}</code></span>
<span class="codeline" id="line-250"><code>		p.WriteString("?&gt;")</code></span>
<span class="codeline" id="line-251"><code>	case Directive:</code></span>
<span class="codeline" id="line-252"><code>		if !isValidDirective(t) {</code></span>
<span class="codeline" id="line-253"><code>			return fmt.Errorf("xml: EncodeToken of Directive containing wrong &lt; or &gt; markers")</code></span>
<span class="codeline" id="line-254"><code>		}</code></span>
<span class="codeline" id="line-255"><code>		p.WriteString("&lt;!")</code></span>
<span class="codeline" id="line-256"><code>		p.Write(t)</code></span>
<span class="codeline" id="line-257"><code>		p.WriteString("&gt;")</code></span>
<span class="codeline" id="line-258"><code>	default:</code></span>
<span class="codeline" id="line-259"><code>		return fmt.Errorf("xml: EncodeToken of invalid token type")</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>	}</code></span>
<span class="codeline" id="line-262"><code>	return p.cachedWriteError()</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// isValidDirective reports whether dir is a valid directive text,</code></span>
<span class="codeline" id="line-266"><code>// meaning angle brackets are matched, ignoring comments and strings.</code></span>
<span class="codeline" id="line-267"><code>func isValidDirective(dir Directive) bool {</code></span>
<span class="codeline" id="line-268"><code>	var (</code></span>
<span class="codeline" id="line-269"><code>		depth     int</code></span>
<span class="codeline" id="line-270"><code>		inquote   uint8</code></span>
<span class="codeline" id="line-271"><code>		incomment bool</code></span>
<span class="codeline" id="line-272"><code>	)</code></span>
<span class="codeline" id="line-273"><code>	for i, c := range dir {</code></span>
<span class="codeline" id="line-274"><code>		switch {</code></span>
<span class="codeline" id="line-275"><code>		case incomment:</code></span>
<span class="codeline" id="line-276"><code>			if c == '&gt;' {</code></span>
<span class="codeline" id="line-277"><code>				if n := 1 + i - len(endComment); n &gt;= 0 &amp;&amp; bytes.Equal(dir[n:i+1], endComment) {</code></span>
<span class="codeline" id="line-278"><code>					incomment = false</code></span>
<span class="codeline" id="line-279"><code>				}</code></span>
<span class="codeline" id="line-280"><code>			}</code></span>
<span class="codeline" id="line-281"><code>			// Just ignore anything in comment</code></span>
<span class="codeline" id="line-282"><code>		case inquote != 0:</code></span>
<span class="codeline" id="line-283"><code>			if c == inquote {</code></span>
<span class="codeline" id="line-284"><code>				inquote = 0</code></span>
<span class="codeline" id="line-285"><code>			}</code></span>
<span class="codeline" id="line-286"><code>			// Just ignore anything within quotes</code></span>
<span class="codeline" id="line-287"><code>		case c == '\'' || c == '"':</code></span>
<span class="codeline" id="line-288"><code>			inquote = c</code></span>
<span class="codeline" id="line-289"><code>		case c == '&lt;':</code></span>
<span class="codeline" id="line-290"><code>			if i+len(begComment) &lt; len(dir) &amp;&amp; bytes.Equal(dir[i:i+len(begComment)], begComment) {</code></span>
<span class="codeline" id="line-291"><code>				incomment = true</code></span>
<span class="codeline" id="line-292"><code>			} else {</code></span>
<span class="codeline" id="line-293"><code>				depth++</code></span>
<span class="codeline" id="line-294"><code>			}</code></span>
<span class="codeline" id="line-295"><code>		case c == '&gt;':</code></span>
<span class="codeline" id="line-296"><code>			if depth == 0 {</code></span>
<span class="codeline" id="line-297"><code>				return false</code></span>
<span class="codeline" id="line-298"><code>			}</code></span>
<span class="codeline" id="line-299"><code>			depth--</code></span>
<span class="codeline" id="line-300"><code>		}</code></span>
<span class="codeline" id="line-301"><code>	}</code></span>
<span class="codeline" id="line-302"><code>	return depth == 0 &amp;&amp; inquote == 0 &amp;&amp; !incomment</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
<span class="codeline" id="line-304"><code></code></span>
<span class="codeline" id="line-305"><code>// Flush flushes any buffered XML to the underlying writer.</code></span>
<span class="codeline" id="line-306"><code>// See the [Encoder.EncodeToken] documentation for details about when it is necessary.</code></span>
<span class="codeline" id="line-307"><code>func (enc *Encoder) Flush() error {</code></span>
<span class="codeline" id="line-308"><code>	return enc.p.w.Flush()</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>// Close the Encoder, indicating that no more data will be written. It flushes</code></span>
<span class="codeline" id="line-312"><code>// any buffered XML to the underlying writer and returns an error if the</code></span>
<span class="codeline" id="line-313"><code>// written XML is invalid (e.g. by containing unclosed elements).</code></span>
<span class="codeline" id="line-314"><code>func (enc *Encoder) Close() error {</code></span>
<span class="codeline" id="line-315"><code>	return enc.p.Close()</code></span>
<span class="codeline" id="line-316"><code>}</code></span>
<span class="codeline" id="line-317"><code></code></span>
<span class="codeline" id="line-318"><code>type printer struct {</code></span>
<span class="codeline" id="line-319"><code>	w          *bufio.Writer</code></span>
<span class="codeline" id="line-320"><code>	encoder    *Encoder</code></span>
<span class="codeline" id="line-321"><code>	seq        int</code></span>
<span class="codeline" id="line-322"><code>	indent     string</code></span>
<span class="codeline" id="line-323"><code>	prefix     string</code></span>
<span class="codeline" id="line-324"><code>	depth      int</code></span>
<span class="codeline" id="line-325"><code>	indentedIn bool</code></span>
<span class="codeline" id="line-326"><code>	putNewline bool</code></span>
<span class="codeline" id="line-327"><code>	attrNS     map[string]string // map prefix -&gt; name space</code></span>
<span class="codeline" id="line-328"><code>	attrPrefix map[string]string // map name space -&gt; prefix</code></span>
<span class="codeline" id="line-329"><code>	prefixes   []string</code></span>
<span class="codeline" id="line-330"><code>	tags       []Name</code></span>
<span class="codeline" id="line-331"><code>	closed     bool</code></span>
<span class="codeline" id="line-332"><code>	err        error</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// createAttrPrefix finds the name space prefix attribute to use for the given name space,</code></span>
<span class="codeline" id="line-336"><code>// defining a new prefix if necessary. It returns the prefix.</code></span>
<span class="codeline" id="line-337"><code>func (p *printer) createAttrPrefix(url string) string {</code></span>
<span class="codeline" id="line-338"><code>	if prefix := p.attrPrefix[url]; prefix != "" {</code></span>
<span class="codeline" id="line-339"><code>		return prefix</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>	// The "http://www.w3.org/XML/1998/namespace" name space is predefined as "xml"</code></span>
<span class="codeline" id="line-343"><code>	// and must be referred to that way.</code></span>
<span class="codeline" id="line-344"><code>	// (The "http://www.w3.org/2000/xmlns/" name space is also predefined as "xmlns",</code></span>
<span class="codeline" id="line-345"><code>	// but users should not be trying to use that one directly - that's our job.)</code></span>
<span class="codeline" id="line-346"><code>	if url == xmlURL {</code></span>
<span class="codeline" id="line-347"><code>		return xmlPrefix</code></span>
<span class="codeline" id="line-348"><code>	}</code></span>
<span class="codeline" id="line-349"><code></code></span>
<span class="codeline" id="line-350"><code>	// Need to define a new name space.</code></span>
<span class="codeline" id="line-351"><code>	if p.attrPrefix == nil {</code></span>
<span class="codeline" id="line-352"><code>		p.attrPrefix = make(map[string]string)</code></span>
<span class="codeline" id="line-353"><code>		p.attrNS = make(map[string]string)</code></span>
<span class="codeline" id="line-354"><code>	}</code></span>
<span class="codeline" id="line-355"><code></code></span>
<span class="codeline" id="line-356"><code>	// Pick a name. We try to use the final element of the path</code></span>
<span class="codeline" id="line-357"><code>	// but fall back to _.</code></span>
<span class="codeline" id="line-358"><code>	prefix := strings.TrimRight(url, "/")</code></span>
<span class="codeline" id="line-359"><code>	if i := strings.LastIndex(prefix, "/"); i &gt;= 0 {</code></span>
<span class="codeline" id="line-360"><code>		prefix = prefix[i+1:]</code></span>
<span class="codeline" id="line-361"><code>	}</code></span>
<span class="codeline" id="line-362"><code>	if prefix == "" || !isName([]byte(prefix)) || strings.Contains(prefix, ":") {</code></span>
<span class="codeline" id="line-363"><code>		prefix = "_"</code></span>
<span class="codeline" id="line-364"><code>	}</code></span>
<span class="codeline" id="line-365"><code>	// xmlanything is reserved and any variant of it regardless of</code></span>
<span class="codeline" id="line-366"><code>	// case should be matched, so:</code></span>
<span class="codeline" id="line-367"><code>	//    (('X'|'x') ('M'|'m') ('L'|'l'))</code></span>
<span class="codeline" id="line-368"><code>	// See Section 2.3 of https://www.w3.org/TR/REC-xml/</code></span>
<span class="codeline" id="line-369"><code>	if len(prefix) &gt;= 3 &amp;&amp; strings.EqualFold(prefix[:3], "xml") {</code></span>
<span class="codeline" id="line-370"><code>		prefix = "_" + prefix</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code>	if p.attrNS[prefix] != "" {</code></span>
<span class="codeline" id="line-373"><code>		// Name is taken. Find a better one.</code></span>
<span class="codeline" id="line-374"><code>		for p.seq++; ; p.seq++ {</code></span>
<span class="codeline" id="line-375"><code>			if id := prefix + "_" + strconv.Itoa(p.seq); p.attrNS[id] == "" {</code></span>
<span class="codeline" id="line-376"><code>				prefix = id</code></span>
<span class="codeline" id="line-377"><code>				break</code></span>
<span class="codeline" id="line-378"><code>			}</code></span>
<span class="codeline" id="line-379"><code>		}</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code></code></span>
<span class="codeline" id="line-382"><code>	p.attrPrefix[url] = prefix</code></span>
<span class="codeline" id="line-383"><code>	p.attrNS[prefix] = url</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	p.WriteString(`xmlns:`)</code></span>
<span class="codeline" id="line-386"><code>	p.WriteString(prefix)</code></span>
<span class="codeline" id="line-387"><code>	p.WriteString(`="`)</code></span>
<span class="codeline" id="line-388"><code>	EscapeText(p, []byte(url))</code></span>
<span class="codeline" id="line-389"><code>	p.WriteString(`" `)</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>	p.prefixes = append(p.prefixes, prefix)</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>	return prefix</code></span>
<span class="codeline" id="line-394"><code>}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>// deleteAttrPrefix removes an attribute name space prefix.</code></span>
<span class="codeline" id="line-397"><code>func (p *printer) deleteAttrPrefix(prefix string) {</code></span>
<span class="codeline" id="line-398"><code>	delete(p.attrPrefix, p.attrNS[prefix])</code></span>
<span class="codeline" id="line-399"><code>	delete(p.attrNS, prefix)</code></span>
<span class="codeline" id="line-400"><code>}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>func (p *printer) markPrefix() {</code></span>
<span class="codeline" id="line-403"><code>	p.prefixes = append(p.prefixes, "")</code></span>
<span class="codeline" id="line-404"><code>}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>func (p *printer) popPrefix() {</code></span>
<span class="codeline" id="line-407"><code>	for len(p.prefixes) &gt; 0 {</code></span>
<span class="codeline" id="line-408"><code>		prefix := p.prefixes[len(p.prefixes)-1]</code></span>
<span class="codeline" id="line-409"><code>		p.prefixes = p.prefixes[:len(p.prefixes)-1]</code></span>
<span class="codeline" id="line-410"><code>		if prefix == "" {</code></span>
<span class="codeline" id="line-411"><code>			break</code></span>
<span class="codeline" id="line-412"><code>		}</code></span>
<span class="codeline" id="line-413"><code>		p.deleteAttrPrefix(prefix)</code></span>
<span class="codeline" id="line-414"><code>	}</code></span>
<span class="codeline" id="line-415"><code>}</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>var (</code></span>
<span class="codeline" id="line-418"><code>	marshalerType     = reflect.TypeFor[Marshaler]()</code></span>
<span class="codeline" id="line-419"><code>	marshalerAttrType = reflect.TypeFor[MarshalerAttr]()</code></span>
<span class="codeline" id="line-420"><code>	textMarshalerType = reflect.TypeFor[encoding.TextMarshaler]()</code></span>
<span class="codeline" id="line-421"><code>)</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>// marshalValue writes one or more XML elements representing val.</code></span>
<span class="codeline" id="line-424"><code>// If val was obtained from a struct field, finfo must have its details.</code></span>
<span class="codeline" id="line-425"><code>func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error {</code></span>
<span class="codeline" id="line-426"><code>	if startTemplate != nil &amp;&amp; startTemplate.Name.Local == "" {</code></span>
<span class="codeline" id="line-427"><code>		return fmt.Errorf("xml: EncodeElement of StartElement with missing name")</code></span>
<span class="codeline" id="line-428"><code>	}</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>	if !val.IsValid() {</code></span>
<span class="codeline" id="line-431"><code>		return nil</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code>	if finfo != nil &amp;&amp; finfo.flags&amp;fOmitEmpty != 0 &amp;&amp; isEmptyValue(val) {</code></span>
<span class="codeline" id="line-434"><code>		return nil</code></span>
<span class="codeline" id="line-435"><code>	}</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	// Drill into interfaces and pointers.</code></span>
<span class="codeline" id="line-438"><code>	// This can turn into an infinite loop given a cyclic chain,</code></span>
<span class="codeline" id="line-439"><code>	// but it matches the Go 1 behavior.</code></span>
<span class="codeline" id="line-440"><code>	for val.Kind() == reflect.Interface || val.Kind() == reflect.Pointer {</code></span>
<span class="codeline" id="line-441"><code>		if val.IsNil() {</code></span>
<span class="codeline" id="line-442"><code>			return nil</code></span>
<span class="codeline" id="line-443"><code>		}</code></span>
<span class="codeline" id="line-444"><code>		val = val.Elem()</code></span>
<span class="codeline" id="line-445"><code>	}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	kind := val.Kind()</code></span>
<span class="codeline" id="line-448"><code>	typ := val.Type()</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>	// Check for marshaler.</code></span>
<span class="codeline" id="line-451"><code>	if val.CanInterface() &amp;&amp; typ.Implements(marshalerType) {</code></span>
<span class="codeline" id="line-452"><code>		return p.marshalInterface(val.Interface().(Marshaler), defaultStart(typ, finfo, startTemplate))</code></span>
<span class="codeline" id="line-453"><code>	}</code></span>
<span class="codeline" id="line-454"><code>	if val.CanAddr() {</code></span>
<span class="codeline" id="line-455"><code>		pv := val.Addr()</code></span>
<span class="codeline" id="line-456"><code>		if pv.CanInterface() &amp;&amp; pv.Type().Implements(marshalerType) {</code></span>
<span class="codeline" id="line-457"><code>			return p.marshalInterface(pv.Interface().(Marshaler), defaultStart(pv.Type(), finfo, startTemplate))</code></span>
<span class="codeline" id="line-458"><code>		}</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>	// Check for text marshaler.</code></span>
<span class="codeline" id="line-462"><code>	if val.CanInterface() &amp;&amp; typ.Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-463"><code>		return p.marshalTextInterface(val.Interface().(encoding.TextMarshaler), defaultStart(typ, finfo, startTemplate))</code></span>
<span class="codeline" id="line-464"><code>	}</code></span>
<span class="codeline" id="line-465"><code>	if val.CanAddr() {</code></span>
<span class="codeline" id="line-466"><code>		pv := val.Addr()</code></span>
<span class="codeline" id="line-467"><code>		if pv.CanInterface() &amp;&amp; pv.Type().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-468"><code>			return p.marshalTextInterface(pv.Interface().(encoding.TextMarshaler), defaultStart(pv.Type(), finfo, startTemplate))</code></span>
<span class="codeline" id="line-469"><code>		}</code></span>
<span class="codeline" id="line-470"><code>	}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>	// Slices and arrays iterate over the elements. They do not have an enclosing tag.</code></span>
<span class="codeline" id="line-473"><code>	if (kind == reflect.Slice || kind == reflect.Array) &amp;&amp; typ.Elem().Kind() != reflect.Uint8 {</code></span>
<span class="codeline" id="line-474"><code>		for i, n := 0, val.Len(); i &lt; n; i++ {</code></span>
<span class="codeline" id="line-475"><code>			if err := p.marshalValue(val.Index(i), finfo, startTemplate); err != nil {</code></span>
<span class="codeline" id="line-476"><code>				return err</code></span>
<span class="codeline" id="line-477"><code>			}</code></span>
<span class="codeline" id="line-478"><code>		}</code></span>
<span class="codeline" id="line-479"><code>		return nil</code></span>
<span class="codeline" id="line-480"><code>	}</code></span>
<span class="codeline" id="line-481"><code></code></span>
<span class="codeline" id="line-482"><code>	tinfo, err := getTypeInfo(typ)</code></span>
<span class="codeline" id="line-483"><code>	if err != nil {</code></span>
<span class="codeline" id="line-484"><code>		return err</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>	// Create start element.</code></span>
<span class="codeline" id="line-488"><code>	// Precedence for the XML element name is:</code></span>
<span class="codeline" id="line-489"><code>	// 0. startTemplate</code></span>
<span class="codeline" id="line-490"><code>	// 1. XMLName field in underlying struct;</code></span>
<span class="codeline" id="line-491"><code>	// 2. field name/tag in the struct field; and</code></span>
<span class="codeline" id="line-492"><code>	// 3. type name</code></span>
<span class="codeline" id="line-493"><code>	var start StartElement</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>	if startTemplate != nil {</code></span>
<span class="codeline" id="line-496"><code>		start.Name = startTemplate.Name</code></span>
<span class="codeline" id="line-497"><code>		start.Attr = append(start.Attr, startTemplate.Attr...)</code></span>
<span class="codeline" id="line-498"><code>	} else if tinfo.xmlname != nil {</code></span>
<span class="codeline" id="line-499"><code>		xmlname := tinfo.xmlname</code></span>
<span class="codeline" id="line-500"><code>		if xmlname.name != "" {</code></span>
<span class="codeline" id="line-501"><code>			start.Name.Space, start.Name.Local = xmlname.xmlns, xmlname.name</code></span>
<span class="codeline" id="line-502"><code>		} else {</code></span>
<span class="codeline" id="line-503"><code>			fv := xmlname.value(val, dontInitNilPointers)</code></span>
<span class="codeline" id="line-504"><code>			if v, ok := fv.Interface().(Name); ok &amp;&amp; v.Local != "" {</code></span>
<span class="codeline" id="line-505"><code>				start.Name = v</code></span>
<span class="codeline" id="line-506"><code>			}</code></span>
<span class="codeline" id="line-507"><code>		}</code></span>
<span class="codeline" id="line-508"><code>	}</code></span>
<span class="codeline" id="line-509"><code>	if start.Name.Local == "" &amp;&amp; finfo != nil {</code></span>
<span class="codeline" id="line-510"><code>		start.Name.Space, start.Name.Local = finfo.xmlns, finfo.name</code></span>
<span class="codeline" id="line-511"><code>	}</code></span>
<span class="codeline" id="line-512"><code>	if start.Name.Local == "" {</code></span>
<span class="codeline" id="line-513"><code>		name := typ.Name()</code></span>
<span class="codeline" id="line-514"><code>		if i := strings.IndexByte(name, '['); i &gt;= 0 {</code></span>
<span class="codeline" id="line-515"><code>			// Truncate generic instantiation name. See issue 48318.</code></span>
<span class="codeline" id="line-516"><code>			name = name[:i]</code></span>
<span class="codeline" id="line-517"><code>		}</code></span>
<span class="codeline" id="line-518"><code>		if name == "" {</code></span>
<span class="codeline" id="line-519"><code>			return &amp;UnsupportedTypeError{typ}</code></span>
<span class="codeline" id="line-520"><code>		}</code></span>
<span class="codeline" id="line-521"><code>		start.Name.Local = name</code></span>
<span class="codeline" id="line-522"><code>	}</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	// Attributes</code></span>
<span class="codeline" id="line-525"><code>	for i := range tinfo.fields {</code></span>
<span class="codeline" id="line-526"><code>		finfo := &amp;tinfo.fields[i]</code></span>
<span class="codeline" id="line-527"><code>		if finfo.flags&amp;fAttr == 0 {</code></span>
<span class="codeline" id="line-528"><code>			continue</code></span>
<span class="codeline" id="line-529"><code>		}</code></span>
<span class="codeline" id="line-530"><code>		fv := finfo.value(val, dontInitNilPointers)</code></span>
<span class="codeline" id="line-531"><code></code></span>
<span class="codeline" id="line-532"><code>		if finfo.flags&amp;fOmitEmpty != 0 &amp;&amp; (!fv.IsValid() || isEmptyValue(fv)) {</code></span>
<span class="codeline" id="line-533"><code>			continue</code></span>
<span class="codeline" id="line-534"><code>		}</code></span>
<span class="codeline" id="line-535"><code></code></span>
<span class="codeline" id="line-536"><code>		if fv.Kind() == reflect.Interface &amp;&amp; fv.IsNil() {</code></span>
<span class="codeline" id="line-537"><code>			continue</code></span>
<span class="codeline" id="line-538"><code>		}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>		name := Name{Space: finfo.xmlns, Local: finfo.name}</code></span>
<span class="codeline" id="line-541"><code>		if err := p.marshalAttr(&amp;start, name, fv); err != nil {</code></span>
<span class="codeline" id="line-542"><code>			return err</code></span>
<span class="codeline" id="line-543"><code>		}</code></span>
<span class="codeline" id="line-544"><code>	}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>	// If an empty name was found, namespace is overridden with an empty space</code></span>
<span class="codeline" id="line-547"><code>	if tinfo.xmlname != nil &amp;&amp; start.Name.Space == "" &amp;&amp;</code></span>
<span class="codeline" id="line-548"><code>		tinfo.xmlname.xmlns == "" &amp;&amp; tinfo.xmlname.name == "" &amp;&amp;</code></span>
<span class="codeline" id="line-549"><code>		len(p.tags) != 0 &amp;&amp; p.tags[len(p.tags)-1].Space != "" {</code></span>
<span class="codeline" id="line-550"><code>		start.Attr = append(start.Attr, Attr{Name{"", xmlnsPrefix}, ""})</code></span>
<span class="codeline" id="line-551"><code>	}</code></span>
<span class="codeline" id="line-552"><code>	if err := p.writeStart(&amp;start); err != nil {</code></span>
<span class="codeline" id="line-553"><code>		return err</code></span>
<span class="codeline" id="line-554"><code>	}</code></span>
<span class="codeline" id="line-555"><code></code></span>
<span class="codeline" id="line-556"><code>	if val.Kind() == reflect.Struct {</code></span>
<span class="codeline" id="line-557"><code>		err = p.marshalStruct(tinfo, val)</code></span>
<span class="codeline" id="line-558"><code>	} else {</code></span>
<span class="codeline" id="line-559"><code>		s, b, err1 := p.marshalSimple(typ, val)</code></span>
<span class="codeline" id="line-560"><code>		if err1 != nil {</code></span>
<span class="codeline" id="line-561"><code>			err = err1</code></span>
<span class="codeline" id="line-562"><code>		} else if b != nil {</code></span>
<span class="codeline" id="line-563"><code>			EscapeText(p, b)</code></span>
<span class="codeline" id="line-564"><code>		} else {</code></span>
<span class="codeline" id="line-565"><code>			p.EscapeString(s)</code></span>
<span class="codeline" id="line-566"><code>		}</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code>	if err != nil {</code></span>
<span class="codeline" id="line-569"><code>		return err</code></span>
<span class="codeline" id="line-570"><code>	}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>	if err := p.writeEnd(start.Name); err != nil {</code></span>
<span class="codeline" id="line-573"><code>		return err</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code></code></span>
<span class="codeline" id="line-576"><code>	return p.cachedWriteError()</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// marshalAttr marshals an attribute with the given name and value, adding to start.Attr.</code></span>
<span class="codeline" id="line-580"><code>func (p *printer) marshalAttr(start *StartElement, name Name, val reflect.Value) error {</code></span>
<span class="codeline" id="line-581"><code>	if val.CanInterface() &amp;&amp; val.Type().Implements(marshalerAttrType) {</code></span>
<span class="codeline" id="line-582"><code>		attr, err := val.Interface().(MarshalerAttr).MarshalXMLAttr(name)</code></span>
<span class="codeline" id="line-583"><code>		if err != nil {</code></span>
<span class="codeline" id="line-584"><code>			return err</code></span>
<span class="codeline" id="line-585"><code>		}</code></span>
<span class="codeline" id="line-586"><code>		if attr.Name.Local != "" {</code></span>
<span class="codeline" id="line-587"><code>			start.Attr = append(start.Attr, attr)</code></span>
<span class="codeline" id="line-588"><code>		}</code></span>
<span class="codeline" id="line-589"><code>		return nil</code></span>
<span class="codeline" id="line-590"><code>	}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>	if val.CanAddr() {</code></span>
<span class="codeline" id="line-593"><code>		pv := val.Addr()</code></span>
<span class="codeline" id="line-594"><code>		if pv.CanInterface() &amp;&amp; pv.Type().Implements(marshalerAttrType) {</code></span>
<span class="codeline" id="line-595"><code>			attr, err := pv.Interface().(MarshalerAttr).MarshalXMLAttr(name)</code></span>
<span class="codeline" id="line-596"><code>			if err != nil {</code></span>
<span class="codeline" id="line-597"><code>				return err</code></span>
<span class="codeline" id="line-598"><code>			}</code></span>
<span class="codeline" id="line-599"><code>			if attr.Name.Local != "" {</code></span>
<span class="codeline" id="line-600"><code>				start.Attr = append(start.Attr, attr)</code></span>
<span class="codeline" id="line-601"><code>			}</code></span>
<span class="codeline" id="line-602"><code>			return nil</code></span>
<span class="codeline" id="line-603"><code>		}</code></span>
<span class="codeline" id="line-604"><code>	}</code></span>
<span class="codeline" id="line-605"><code></code></span>
<span class="codeline" id="line-606"><code>	if val.CanInterface() &amp;&amp; val.Type().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-607"><code>		text, err := val.Interface().(encoding.TextMarshaler).MarshalText()</code></span>
<span class="codeline" id="line-608"><code>		if err != nil {</code></span>
<span class="codeline" id="line-609"><code>			return err</code></span>
<span class="codeline" id="line-610"><code>		}</code></span>
<span class="codeline" id="line-611"><code>		start.Attr = append(start.Attr, Attr{name, string(text)})</code></span>
<span class="codeline" id="line-612"><code>		return nil</code></span>
<span class="codeline" id="line-613"><code>	}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>	if val.CanAddr() {</code></span>
<span class="codeline" id="line-616"><code>		pv := val.Addr()</code></span>
<span class="codeline" id="line-617"><code>		if pv.CanInterface() &amp;&amp; pv.Type().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-618"><code>			text, err := pv.Interface().(encoding.TextMarshaler).MarshalText()</code></span>
<span class="codeline" id="line-619"><code>			if err != nil {</code></span>
<span class="codeline" id="line-620"><code>				return err</code></span>
<span class="codeline" id="line-621"><code>			}</code></span>
<span class="codeline" id="line-622"><code>			start.Attr = append(start.Attr, Attr{name, string(text)})</code></span>
<span class="codeline" id="line-623"><code>			return nil</code></span>
<span class="codeline" id="line-624"><code>		}</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>	// Dereference or skip nil pointer, interface values.</code></span>
<span class="codeline" id="line-628"><code>	switch val.Kind() {</code></span>
<span class="codeline" id="line-629"><code>	case reflect.Pointer, reflect.Interface:</code></span>
<span class="codeline" id="line-630"><code>		if val.IsNil() {</code></span>
<span class="codeline" id="line-631"><code>			return nil</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>		val = val.Elem()</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>	// Walk slices.</code></span>
<span class="codeline" id="line-637"><code>	if val.Kind() == reflect.Slice &amp;&amp; val.Type().Elem().Kind() != reflect.Uint8 {</code></span>
<span class="codeline" id="line-638"><code>		n := val.Len()</code></span>
<span class="codeline" id="line-639"><code>		for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-640"><code>			if err := p.marshalAttr(start, name, val.Index(i)); err != nil {</code></span>
<span class="codeline" id="line-641"><code>				return err</code></span>
<span class="codeline" id="line-642"><code>			}</code></span>
<span class="codeline" id="line-643"><code>		}</code></span>
<span class="codeline" id="line-644"><code>		return nil</code></span>
<span class="codeline" id="line-645"><code>	}</code></span>
<span class="codeline" id="line-646"><code></code></span>
<span class="codeline" id="line-647"><code>	if val.Type() == attrType {</code></span>
<span class="codeline" id="line-648"><code>		start.Attr = append(start.Attr, val.Interface().(Attr))</code></span>
<span class="codeline" id="line-649"><code>		return nil</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>	s, b, err := p.marshalSimple(val.Type(), val)</code></span>
<span class="codeline" id="line-653"><code>	if err != nil {</code></span>
<span class="codeline" id="line-654"><code>		return err</code></span>
<span class="codeline" id="line-655"><code>	}</code></span>
<span class="codeline" id="line-656"><code>	if b != nil {</code></span>
<span class="codeline" id="line-657"><code>		s = string(b)</code></span>
<span class="codeline" id="line-658"><code>	}</code></span>
<span class="codeline" id="line-659"><code>	start.Attr = append(start.Attr, Attr{name, s})</code></span>
<span class="codeline" id="line-660"><code>	return nil</code></span>
<span class="codeline" id="line-661"><code>}</code></span>
<span class="codeline" id="line-662"><code></code></span>
<span class="codeline" id="line-663"><code>// defaultStart returns the default start element to use,</code></span>
<span class="codeline" id="line-664"><code>// given the reflect type, field info, and start template.</code></span>
<span class="codeline" id="line-665"><code>func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement {</code></span>
<span class="codeline" id="line-666"><code>	var start StartElement</code></span>
<span class="codeline" id="line-667"><code>	// Precedence for the XML element name is as above,</code></span>
<span class="codeline" id="line-668"><code>	// except that we do not look inside structs for the first field.</code></span>
<span class="codeline" id="line-669"><code>	if startTemplate != nil {</code></span>
<span class="codeline" id="line-670"><code>		start.Name = startTemplate.Name</code></span>
<span class="codeline" id="line-671"><code>		start.Attr = append(start.Attr, startTemplate.Attr...)</code></span>
<span class="codeline" id="line-672"><code>	} else if finfo != nil &amp;&amp; finfo.name != "" {</code></span>
<span class="codeline" id="line-673"><code>		start.Name.Local = finfo.name</code></span>
<span class="codeline" id="line-674"><code>		start.Name.Space = finfo.xmlns</code></span>
<span class="codeline" id="line-675"><code>	} else if typ.Name() != "" {</code></span>
<span class="codeline" id="line-676"><code>		start.Name.Local = typ.Name()</code></span>
<span class="codeline" id="line-677"><code>	} else {</code></span>
<span class="codeline" id="line-678"><code>		// Must be a pointer to a named type,</code></span>
<span class="codeline" id="line-679"><code>		// since it has the Marshaler methods.</code></span>
<span class="codeline" id="line-680"><code>		start.Name.Local = typ.Elem().Name()</code></span>
<span class="codeline" id="line-681"><code>	}</code></span>
<span class="codeline" id="line-682"><code>	return start</code></span>
<span class="codeline" id="line-683"><code>}</code></span>
<span class="codeline" id="line-684"><code></code></span>
<span class="codeline" id="line-685"><code>// marshalInterface marshals a Marshaler interface value.</code></span>
<span class="codeline" id="line-686"><code>func (p *printer) marshalInterface(val Marshaler, start StartElement) error {</code></span>
<span class="codeline" id="line-687"><code>	// Push a marker onto the tag stack so that MarshalXML</code></span>
<span class="codeline" id="line-688"><code>	// cannot close the XML tags that it did not open.</code></span>
<span class="codeline" id="line-689"><code>	p.tags = append(p.tags, Name{})</code></span>
<span class="codeline" id="line-690"><code>	n := len(p.tags)</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>	err := val.MarshalXML(p.encoder, start)</code></span>
<span class="codeline" id="line-693"><code>	if err != nil {</code></span>
<span class="codeline" id="line-694"><code>		return err</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>	// Make sure MarshalXML closed all its tags. p.tags[n-1] is the mark.</code></span>
<span class="codeline" id="line-698"><code>	if len(p.tags) &gt; n {</code></span>
<span class="codeline" id="line-699"><code>		return fmt.Errorf("xml: %s.MarshalXML wrote invalid XML: &lt;%s&gt; not closed", receiverType(val), p.tags[len(p.tags)-1].Local)</code></span>
<span class="codeline" id="line-700"><code>	}</code></span>
<span class="codeline" id="line-701"><code>	p.tags = p.tags[:n-1]</code></span>
<span class="codeline" id="line-702"><code>	return nil</code></span>
<span class="codeline" id="line-703"><code>}</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>// marshalTextInterface marshals a TextMarshaler interface value.</code></span>
<span class="codeline" id="line-706"><code>func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error {</code></span>
<span class="codeline" id="line-707"><code>	if err := p.writeStart(&amp;start); err != nil {</code></span>
<span class="codeline" id="line-708"><code>		return err</code></span>
<span class="codeline" id="line-709"><code>	}</code></span>
<span class="codeline" id="line-710"><code>	text, err := val.MarshalText()</code></span>
<span class="codeline" id="line-711"><code>	if err != nil {</code></span>
<span class="codeline" id="line-712"><code>		return err</code></span>
<span class="codeline" id="line-713"><code>	}</code></span>
<span class="codeline" id="line-714"><code>	EscapeText(p, text)</code></span>
<span class="codeline" id="line-715"><code>	return p.writeEnd(start.Name)</code></span>
<span class="codeline" id="line-716"><code>}</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>// writeStart writes the given start element.</code></span>
<span class="codeline" id="line-719"><code>func (p *printer) writeStart(start *StartElement) error {</code></span>
<span class="codeline" id="line-720"><code>	if start.Name.Local == "" {</code></span>
<span class="codeline" id="line-721"><code>		return fmt.Errorf("xml: start tag with no name")</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>	p.tags = append(p.tags, start.Name)</code></span>
<span class="codeline" id="line-725"><code>	p.markPrefix()</code></span>
<span class="codeline" id="line-726"><code></code></span>
<span class="codeline" id="line-727"><code>	p.writeIndent(1)</code></span>
<span class="codeline" id="line-728"><code>	p.WriteByte('&lt;')</code></span>
<span class="codeline" id="line-729"><code>	p.WriteString(start.Name.Local)</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>	if start.Name.Space != "" {</code></span>
<span class="codeline" id="line-732"><code>		p.WriteString(` xmlns="`)</code></span>
<span class="codeline" id="line-733"><code>		p.EscapeString(start.Name.Space)</code></span>
<span class="codeline" id="line-734"><code>		p.WriteByte('"')</code></span>
<span class="codeline" id="line-735"><code>	}</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>	// Attributes</code></span>
<span class="codeline" id="line-738"><code>	for _, attr := range start.Attr {</code></span>
<span class="codeline" id="line-739"><code>		name := attr.Name</code></span>
<span class="codeline" id="line-740"><code>		if name.Local == "" {</code></span>
<span class="codeline" id="line-741"><code>			continue</code></span>
<span class="codeline" id="line-742"><code>		}</code></span>
<span class="codeline" id="line-743"><code>		p.WriteByte(' ')</code></span>
<span class="codeline" id="line-744"><code>		if name.Space != "" {</code></span>
<span class="codeline" id="line-745"><code>			p.WriteString(p.createAttrPrefix(name.Space))</code></span>
<span class="codeline" id="line-746"><code>			p.WriteByte(':')</code></span>
<span class="codeline" id="line-747"><code>		}</code></span>
<span class="codeline" id="line-748"><code>		p.WriteString(name.Local)</code></span>
<span class="codeline" id="line-749"><code>		p.WriteString(`="`)</code></span>
<span class="codeline" id="line-750"><code>		p.EscapeString(attr.Value)</code></span>
<span class="codeline" id="line-751"><code>		p.WriteByte('"')</code></span>
<span class="codeline" id="line-752"><code>	}</code></span>
<span class="codeline" id="line-753"><code>	p.WriteByte('&gt;')</code></span>
<span class="codeline" id="line-754"><code>	return nil</code></span>
<span class="codeline" id="line-755"><code>}</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>func (p *printer) writeEnd(name Name) error {</code></span>
<span class="codeline" id="line-758"><code>	if name.Local == "" {</code></span>
<span class="codeline" id="line-759"><code>		return fmt.Errorf("xml: end tag with no name")</code></span>
<span class="codeline" id="line-760"><code>	}</code></span>
<span class="codeline" id="line-761"><code>	if len(p.tags) == 0 || p.tags[len(p.tags)-1].Local == "" {</code></span>
<span class="codeline" id="line-762"><code>		return fmt.Errorf("xml: end tag &lt;/%s&gt; without start tag", name.Local)</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code>	if top := p.tags[len(p.tags)-1]; top != name {</code></span>
<span class="codeline" id="line-765"><code>		if top.Local != name.Local {</code></span>
<span class="codeline" id="line-766"><code>			return fmt.Errorf("xml: end tag &lt;/%s&gt; does not match start tag &lt;%s&gt;", name.Local, top.Local)</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code>		return fmt.Errorf("xml: end tag &lt;/%s&gt; in namespace %s does not match start tag &lt;%s&gt; in namespace %s", name.Local, name.Space, top.Local, top.Space)</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code>	p.tags = p.tags[:len(p.tags)-1]</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>	p.writeIndent(-1)</code></span>
<span class="codeline" id="line-773"><code>	p.WriteByte('&lt;')</code></span>
<span class="codeline" id="line-774"><code>	p.WriteByte('/')</code></span>
<span class="codeline" id="line-775"><code>	p.WriteString(name.Local)</code></span>
<span class="codeline" id="line-776"><code>	p.WriteByte('&gt;')</code></span>
<span class="codeline" id="line-777"><code>	p.popPrefix()</code></span>
<span class="codeline" id="line-778"><code>	return nil</code></span>
<span class="codeline" id="line-779"><code>}</code></span>
<span class="codeline" id="line-780"><code></code></span>
<span class="codeline" id="line-781"><code>func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error) {</code></span>
<span class="codeline" id="line-782"><code>	switch val.Kind() {</code></span>
<span class="codeline" id="line-783"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-784"><code>		return strconv.FormatInt(val.Int(), 10), nil, nil</code></span>
<span class="codeline" id="line-785"><code>	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-786"><code>		return strconv.FormatUint(val.Uint(), 10), nil, nil</code></span>
<span class="codeline" id="line-787"><code>	case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-788"><code>		return strconv.FormatFloat(val.Float(), 'g', -1, val.Type().Bits()), nil, nil</code></span>
<span class="codeline" id="line-789"><code>	case reflect.String:</code></span>
<span class="codeline" id="line-790"><code>		return val.String(), nil, nil</code></span>
<span class="codeline" id="line-791"><code>	case reflect.Bool:</code></span>
<span class="codeline" id="line-792"><code>		return strconv.FormatBool(val.Bool()), nil, nil</code></span>
<span class="codeline" id="line-793"><code>	case reflect.Array:</code></span>
<span class="codeline" id="line-794"><code>		if typ.Elem().Kind() != reflect.Uint8 {</code></span>
<span class="codeline" id="line-795"><code>			break</code></span>
<span class="codeline" id="line-796"><code>		}</code></span>
<span class="codeline" id="line-797"><code>		// [...]byte</code></span>
<span class="codeline" id="line-798"><code>		var bytes []byte</code></span>
<span class="codeline" id="line-799"><code>		if val.CanAddr() {</code></span>
<span class="codeline" id="line-800"><code>			bytes = val.Bytes()</code></span>
<span class="codeline" id="line-801"><code>		} else {</code></span>
<span class="codeline" id="line-802"><code>			bytes = make([]byte, val.Len())</code></span>
<span class="codeline" id="line-803"><code>			reflect.Copy(reflect.ValueOf(bytes), val)</code></span>
<span class="codeline" id="line-804"><code>		}</code></span>
<span class="codeline" id="line-805"><code>		return "", bytes, nil</code></span>
<span class="codeline" id="line-806"><code>	case reflect.Slice:</code></span>
<span class="codeline" id="line-807"><code>		if typ.Elem().Kind() != reflect.Uint8 {</code></span>
<span class="codeline" id="line-808"><code>			break</code></span>
<span class="codeline" id="line-809"><code>		}</code></span>
<span class="codeline" id="line-810"><code>		// []byte</code></span>
<span class="codeline" id="line-811"><code>		return "", val.Bytes(), nil</code></span>
<span class="codeline" id="line-812"><code>	}</code></span>
<span class="codeline" id="line-813"><code>	return "", nil, &amp;UnsupportedTypeError{typ}</code></span>
<span class="codeline" id="line-814"><code>}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>var ddBytes = []byte("--")</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>// indirect drills into interfaces and pointers, returning the pointed-at value.</code></span>
<span class="codeline" id="line-819"><code>// If it encounters a nil interface or pointer, indirect returns that nil value.</code></span>
<span class="codeline" id="line-820"><code>// This can turn into an infinite loop given a cyclic chain,</code></span>
<span class="codeline" id="line-821"><code>// but it matches the Go 1 behavior.</code></span>
<span class="codeline" id="line-822"><code>func indirect(vf reflect.Value) reflect.Value {</code></span>
<span class="codeline" id="line-823"><code>	for vf.Kind() == reflect.Interface || vf.Kind() == reflect.Pointer {</code></span>
<span class="codeline" id="line-824"><code>		if vf.IsNil() {</code></span>
<span class="codeline" id="line-825"><code>			return vf</code></span>
<span class="codeline" id="line-826"><code>		}</code></span>
<span class="codeline" id="line-827"><code>		vf = vf.Elem()</code></span>
<span class="codeline" id="line-828"><code>	}</code></span>
<span class="codeline" id="line-829"><code>	return vf</code></span>
<span class="codeline" id="line-830"><code>}</code></span>
<span class="codeline" id="line-831"><code></code></span>
<span class="codeline" id="line-832"><code>func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {</code></span>
<span class="codeline" id="line-833"><code>	s := parentStack{p: p}</code></span>
<span class="codeline" id="line-834"><code>	for i := range tinfo.fields {</code></span>
<span class="codeline" id="line-835"><code>		finfo := &amp;tinfo.fields[i]</code></span>
<span class="codeline" id="line-836"><code>		if finfo.flags&amp;fAttr != 0 {</code></span>
<span class="codeline" id="line-837"><code>			continue</code></span>
<span class="codeline" id="line-838"><code>		}</code></span>
<span class="codeline" id="line-839"><code>		vf := finfo.value(val, dontInitNilPointers)</code></span>
<span class="codeline" id="line-840"><code>		if !vf.IsValid() {</code></span>
<span class="codeline" id="line-841"><code>			// The field is behind an anonymous struct field that's</code></span>
<span class="codeline" id="line-842"><code>			// nil. Skip it.</code></span>
<span class="codeline" id="line-843"><code>			continue</code></span>
<span class="codeline" id="line-844"><code>		}</code></span>
<span class="codeline" id="line-845"><code></code></span>
<span class="codeline" id="line-846"><code>		switch finfo.flags &amp; fMode {</code></span>
<span class="codeline" id="line-847"><code>		case fCDATA, fCharData:</code></span>
<span class="codeline" id="line-848"><code>			emit := EscapeText</code></span>
<span class="codeline" id="line-849"><code>			if finfo.flags&amp;fMode == fCDATA {</code></span>
<span class="codeline" id="line-850"><code>				emit = emitCDATA</code></span>
<span class="codeline" id="line-851"><code>			}</code></span>
<span class="codeline" id="line-852"><code>			if err := s.trim(finfo.parents); err != nil {</code></span>
<span class="codeline" id="line-853"><code>				return err</code></span>
<span class="codeline" id="line-854"><code>			}</code></span>
<span class="codeline" id="line-855"><code>			if vf.CanInterface() &amp;&amp; vf.Type().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-856"><code>				data, err := vf.Interface().(encoding.TextMarshaler).MarshalText()</code></span>
<span class="codeline" id="line-857"><code>				if err != nil {</code></span>
<span class="codeline" id="line-858"><code>					return err</code></span>
<span class="codeline" id="line-859"><code>				}</code></span>
<span class="codeline" id="line-860"><code>				if err := emit(p, data); err != nil {</code></span>
<span class="codeline" id="line-861"><code>					return err</code></span>
<span class="codeline" id="line-862"><code>				}</code></span>
<span class="codeline" id="line-863"><code>				continue</code></span>
<span class="codeline" id="line-864"><code>			}</code></span>
<span class="codeline" id="line-865"><code>			if vf.CanAddr() {</code></span>
<span class="codeline" id="line-866"><code>				pv := vf.Addr()</code></span>
<span class="codeline" id="line-867"><code>				if pv.CanInterface() &amp;&amp; pv.Type().Implements(textMarshalerType) {</code></span>
<span class="codeline" id="line-868"><code>					data, err := pv.Interface().(encoding.TextMarshaler).MarshalText()</code></span>
<span class="codeline" id="line-869"><code>					if err != nil {</code></span>
<span class="codeline" id="line-870"><code>						return err</code></span>
<span class="codeline" id="line-871"><code>					}</code></span>
<span class="codeline" id="line-872"><code>					if err := emit(p, data); err != nil {</code></span>
<span class="codeline" id="line-873"><code>						return err</code></span>
<span class="codeline" id="line-874"><code>					}</code></span>
<span class="codeline" id="line-875"><code>					continue</code></span>
<span class="codeline" id="line-876"><code>				}</code></span>
<span class="codeline" id="line-877"><code>			}</code></span>
<span class="codeline" id="line-878"><code></code></span>
<span class="codeline" id="line-879"><code>			var scratch [64]byte</code></span>
<span class="codeline" id="line-880"><code>			vf = indirect(vf)</code></span>
<span class="codeline" id="line-881"><code>			switch vf.Kind() {</code></span>
<span class="codeline" id="line-882"><code>			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:</code></span>
<span class="codeline" id="line-883"><code>				if err := emit(p, strconv.AppendInt(scratch[:0], vf.Int(), 10)); err != nil {</code></span>
<span class="codeline" id="line-884"><code>					return err</code></span>
<span class="codeline" id="line-885"><code>				}</code></span>
<span class="codeline" id="line-886"><code>			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:</code></span>
<span class="codeline" id="line-887"><code>				if err := emit(p, strconv.AppendUint(scratch[:0], vf.Uint(), 10)); err != nil {</code></span>
<span class="codeline" id="line-888"><code>					return err</code></span>
<span class="codeline" id="line-889"><code>				}</code></span>
<span class="codeline" id="line-890"><code>			case reflect.Float32, reflect.Float64:</code></span>
<span class="codeline" id="line-891"><code>				if err := emit(p, strconv.AppendFloat(scratch[:0], vf.Float(), 'g', -1, vf.Type().Bits())); err != nil {</code></span>
<span class="codeline" id="line-892"><code>					return err</code></span>
<span class="codeline" id="line-893"><code>				}</code></span>
<span class="codeline" id="line-894"><code>			case reflect.Bool:</code></span>
<span class="codeline" id="line-895"><code>				if err := emit(p, strconv.AppendBool(scratch[:0], vf.Bool())); err != nil {</code></span>
<span class="codeline" id="line-896"><code>					return err</code></span>
<span class="codeline" id="line-897"><code>				}</code></span>
<span class="codeline" id="line-898"><code>			case reflect.String:</code></span>
<span class="codeline" id="line-899"><code>				if err := emit(p, []byte(vf.String())); err != nil {</code></span>
<span class="codeline" id="line-900"><code>					return err</code></span>
<span class="codeline" id="line-901"><code>				}</code></span>
<span class="codeline" id="line-902"><code>			case reflect.Slice:</code></span>
<span class="codeline" id="line-903"><code>				if elem, ok := vf.Interface().([]byte); ok {</code></span>
<span class="codeline" id="line-904"><code>					if err := emit(p, elem); err != nil {</code></span>
<span class="codeline" id="line-905"><code>						return err</code></span>
<span class="codeline" id="line-906"><code>					}</code></span>
<span class="codeline" id="line-907"><code>				}</code></span>
<span class="codeline" id="line-908"><code>			}</code></span>
<span class="codeline" id="line-909"><code>			continue</code></span>
<span class="codeline" id="line-910"><code></code></span>
<span class="codeline" id="line-911"><code>		case fComment:</code></span>
<span class="codeline" id="line-912"><code>			if err := s.trim(finfo.parents); err != nil {</code></span>
<span class="codeline" id="line-913"><code>				return err</code></span>
<span class="codeline" id="line-914"><code>			}</code></span>
<span class="codeline" id="line-915"><code>			vf = indirect(vf)</code></span>
<span class="codeline" id="line-916"><code>			k := vf.Kind()</code></span>
<span class="codeline" id="line-917"><code>			if !(k == reflect.String || k == reflect.Slice &amp;&amp; vf.Type().Elem().Kind() == reflect.Uint8) {</code></span>
<span class="codeline" id="line-918"><code>				return fmt.Errorf("xml: bad type for comment field of %s", val.Type())</code></span>
<span class="codeline" id="line-919"><code>			}</code></span>
<span class="codeline" id="line-920"><code>			if vf.Len() == 0 {</code></span>
<span class="codeline" id="line-921"><code>				continue</code></span>
<span class="codeline" id="line-922"><code>			}</code></span>
<span class="codeline" id="line-923"><code>			p.writeIndent(0)</code></span>
<span class="codeline" id="line-924"><code>			p.WriteString("&lt;!--")</code></span>
<span class="codeline" id="line-925"><code>			dashDash := false</code></span>
<span class="codeline" id="line-926"><code>			dashLast := false</code></span>
<span class="codeline" id="line-927"><code>			switch k {</code></span>
<span class="codeline" id="line-928"><code>			case reflect.String:</code></span>
<span class="codeline" id="line-929"><code>				s := vf.String()</code></span>
<span class="codeline" id="line-930"><code>				dashDash = strings.Contains(s, "--")</code></span>
<span class="codeline" id="line-931"><code>				dashLast = s[len(s)-1] == '-'</code></span>
<span class="codeline" id="line-932"><code>				if !dashDash {</code></span>
<span class="codeline" id="line-933"><code>					p.WriteString(s)</code></span>
<span class="codeline" id="line-934"><code>				}</code></span>
<span class="codeline" id="line-935"><code>			case reflect.Slice:</code></span>
<span class="codeline" id="line-936"><code>				b := vf.Bytes()</code></span>
<span class="codeline" id="line-937"><code>				dashDash = bytes.Contains(b, ddBytes)</code></span>
<span class="codeline" id="line-938"><code>				dashLast = b[len(b)-1] == '-'</code></span>
<span class="codeline" id="line-939"><code>				if !dashDash {</code></span>
<span class="codeline" id="line-940"><code>					p.Write(b)</code></span>
<span class="codeline" id="line-941"><code>				}</code></span>
<span class="codeline" id="line-942"><code>			default:</code></span>
<span class="codeline" id="line-943"><code>				panic("can't happen")</code></span>
<span class="codeline" id="line-944"><code>			}</code></span>
<span class="codeline" id="line-945"><code>			if dashDash {</code></span>
<span class="codeline" id="line-946"><code>				return fmt.Errorf(`xml: comments must not contain "--"`)</code></span>
<span class="codeline" id="line-947"><code>			}</code></span>
<span class="codeline" id="line-948"><code>			if dashLast {</code></span>
<span class="codeline" id="line-949"><code>				// "---&gt;" is invalid grammar. Make it "- --&gt;"</code></span>
<span class="codeline" id="line-950"><code>				p.WriteByte(' ')</code></span>
<span class="codeline" id="line-951"><code>			}</code></span>
<span class="codeline" id="line-952"><code>			p.WriteString("--&gt;")</code></span>
<span class="codeline" id="line-953"><code>			continue</code></span>
<span class="codeline" id="line-954"><code></code></span>
<span class="codeline" id="line-955"><code>		case fInnerXML:</code></span>
<span class="codeline" id="line-956"><code>			vf = indirect(vf)</code></span>
<span class="codeline" id="line-957"><code>			iface := vf.Interface()</code></span>
<span class="codeline" id="line-958"><code>			switch raw := iface.(type) {</code></span>
<span class="codeline" id="line-959"><code>			case []byte:</code></span>
<span class="codeline" id="line-960"><code>				p.Write(raw)</code></span>
<span class="codeline" id="line-961"><code>				continue</code></span>
<span class="codeline" id="line-962"><code>			case string:</code></span>
<span class="codeline" id="line-963"><code>				p.WriteString(raw)</code></span>
<span class="codeline" id="line-964"><code>				continue</code></span>
<span class="codeline" id="line-965"><code>			}</code></span>
<span class="codeline" id="line-966"><code></code></span>
<span class="codeline" id="line-967"><code>		case fElement, fElement | fAny:</code></span>
<span class="codeline" id="line-968"><code>			if err := s.trim(finfo.parents); err != nil {</code></span>
<span class="codeline" id="line-969"><code>				return err</code></span>
<span class="codeline" id="line-970"><code>			}</code></span>
<span class="codeline" id="line-971"><code>			if len(finfo.parents) &gt; len(s.stack) {</code></span>
<span class="codeline" id="line-972"><code>				if vf.Kind() != reflect.Pointer &amp;&amp; vf.Kind() != reflect.Interface || !vf.IsNil() {</code></span>
<span class="codeline" id="line-973"><code>					if err := s.push(finfo.parents[len(s.stack):]); err != nil {</code></span>
<span class="codeline" id="line-974"><code>						return err</code></span>
<span class="codeline" id="line-975"><code>					}</code></span>
<span class="codeline" id="line-976"><code>				}</code></span>
<span class="codeline" id="line-977"><code>			}</code></span>
<span class="codeline" id="line-978"><code>		}</code></span>
<span class="codeline" id="line-979"><code>		if err := p.marshalValue(vf, finfo, nil); err != nil {</code></span>
<span class="codeline" id="line-980"><code>			return err</code></span>
<span class="codeline" id="line-981"><code>		}</code></span>
<span class="codeline" id="line-982"><code>	}</code></span>
<span class="codeline" id="line-983"><code>	s.trim(nil)</code></span>
<span class="codeline" id="line-984"><code>	return p.cachedWriteError()</code></span>
<span class="codeline" id="line-985"><code>}</code></span>
<span class="codeline" id="line-986"><code></code></span>
<span class="codeline" id="line-987"><code>// Write implements io.Writer</code></span>
<span class="codeline" id="line-988"><code>func (p *printer) Write(b []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-989"><code>	if p.closed &amp;&amp; p.err == nil {</code></span>
<span class="codeline" id="line-990"><code>		p.err = errors.New("use of closed Encoder")</code></span>
<span class="codeline" id="line-991"><code>	}</code></span>
<span class="codeline" id="line-992"><code>	if p.err == nil {</code></span>
<span class="codeline" id="line-993"><code>		n, p.err = p.w.Write(b)</code></span>
<span class="codeline" id="line-994"><code>	}</code></span>
<span class="codeline" id="line-995"><code>	return n, p.err</code></span>
<span class="codeline" id="line-996"><code>}</code></span>
<span class="codeline" id="line-997"><code></code></span>
<span class="codeline" id="line-998"><code>// WriteString implements io.StringWriter</code></span>
<span class="codeline" id="line-999"><code>func (p *printer) WriteString(s string) (n int, err error) {</code></span>
<span class="codeline" id="line-1000"><code>	if p.closed &amp;&amp; p.err == nil {</code></span>
<span class="codeline" id="line-1001"><code>		p.err = errors.New("use of closed Encoder")</code></span>
<span class="codeline" id="line-1002"><code>	}</code></span>
<span class="codeline" id="line-1003"><code>	if p.err == nil {</code></span>
<span class="codeline" id="line-1004"><code>		n, p.err = p.w.WriteString(s)</code></span>
<span class="codeline" id="line-1005"><code>	}</code></span>
<span class="codeline" id="line-1006"><code>	return n, p.err</code></span>
<span class="codeline" id="line-1007"><code>}</code></span>
<span class="codeline" id="line-1008"><code></code></span>
<span class="codeline" id="line-1009"><code>// WriteByte implements io.ByteWriter</code></span>
<span class="codeline" id="line-1010"><code>func (p *printer) WriteByte(c byte) error {</code></span>
<span class="codeline" id="line-1011"><code>	if p.closed &amp;&amp; p.err == nil {</code></span>
<span class="codeline" id="line-1012"><code>		p.err = errors.New("use of closed Encoder")</code></span>
<span class="codeline" id="line-1013"><code>	}</code></span>
<span class="codeline" id="line-1014"><code>	if p.err == nil {</code></span>
<span class="codeline" id="line-1015"><code>		p.err = p.w.WriteByte(c)</code></span>
<span class="codeline" id="line-1016"><code>	}</code></span>
<span class="codeline" id="line-1017"><code>	return p.err</code></span>
<span class="codeline" id="line-1018"><code>}</code></span>
<span class="codeline" id="line-1019"><code></code></span>
<span class="codeline" id="line-1020"><code>// Close the Encoder, indicating that no more data will be written. It flushes</code></span>
<span class="codeline" id="line-1021"><code>// any buffered XML to the underlying writer and returns an error if the</code></span>
<span class="codeline" id="line-1022"><code>// written XML is invalid (e.g. by containing unclosed elements).</code></span>
<span class="codeline" id="line-1023"><code>func (p *printer) Close() error {</code></span>
<span class="codeline" id="line-1024"><code>	if p.closed {</code></span>
<span class="codeline" id="line-1025"><code>		return nil</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code>	p.closed = true</code></span>
<span class="codeline" id="line-1028"><code>	if err := p.w.Flush(); err != nil {</code></span>
<span class="codeline" id="line-1029"><code>		return err</code></span>
<span class="codeline" id="line-1030"><code>	}</code></span>
<span class="codeline" id="line-1031"><code>	if len(p.tags) &gt; 0 {</code></span>
<span class="codeline" id="line-1032"><code>		return fmt.Errorf("unclosed tag &lt;%s&gt;", p.tags[len(p.tags)-1].Local)</code></span>
<span class="codeline" id="line-1033"><code>	}</code></span>
<span class="codeline" id="line-1034"><code>	return nil</code></span>
<span class="codeline" id="line-1035"><code>}</code></span>
<span class="codeline" id="line-1036"><code></code></span>
<span class="codeline" id="line-1037"><code>// return the bufio Writer's cached write error</code></span>
<span class="codeline" id="line-1038"><code>func (p *printer) cachedWriteError() error {</code></span>
<span class="codeline" id="line-1039"><code>	_, err := p.Write(nil)</code></span>
<span class="codeline" id="line-1040"><code>	return err</code></span>
<span class="codeline" id="line-1041"><code>}</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>func (p *printer) writeIndent(depthDelta int) {</code></span>
<span class="codeline" id="line-1044"><code>	if len(p.prefix) == 0 &amp;&amp; len(p.indent) == 0 {</code></span>
<span class="codeline" id="line-1045"><code>		return</code></span>
<span class="codeline" id="line-1046"><code>	}</code></span>
<span class="codeline" id="line-1047"><code>	if depthDelta &lt; 0 {</code></span>
<span class="codeline" id="line-1048"><code>		p.depth--</code></span>
<span class="codeline" id="line-1049"><code>		if p.indentedIn {</code></span>
<span class="codeline" id="line-1050"><code>			p.indentedIn = false</code></span>
<span class="codeline" id="line-1051"><code>			return</code></span>
<span class="codeline" id="line-1052"><code>		}</code></span>
<span class="codeline" id="line-1053"><code>		p.indentedIn = false</code></span>
<span class="codeline" id="line-1054"><code>	}</code></span>
<span class="codeline" id="line-1055"><code>	if p.putNewline {</code></span>
<span class="codeline" id="line-1056"><code>		p.WriteByte('\n')</code></span>
<span class="codeline" id="line-1057"><code>	} else {</code></span>
<span class="codeline" id="line-1058"><code>		p.putNewline = true</code></span>
<span class="codeline" id="line-1059"><code>	}</code></span>
<span class="codeline" id="line-1060"><code>	if len(p.prefix) &gt; 0 {</code></span>
<span class="codeline" id="line-1061"><code>		p.WriteString(p.prefix)</code></span>
<span class="codeline" id="line-1062"><code>	}</code></span>
<span class="codeline" id="line-1063"><code>	if len(p.indent) &gt; 0 {</code></span>
<span class="codeline" id="line-1064"><code>		for i := 0; i &lt; p.depth; i++ {</code></span>
<span class="codeline" id="line-1065"><code>			p.WriteString(p.indent)</code></span>
<span class="codeline" id="line-1066"><code>		}</code></span>
<span class="codeline" id="line-1067"><code>	}</code></span>
<span class="codeline" id="line-1068"><code>	if depthDelta &gt; 0 {</code></span>
<span class="codeline" id="line-1069"><code>		p.depth++</code></span>
<span class="codeline" id="line-1070"><code>		p.indentedIn = true</code></span>
<span class="codeline" id="line-1071"><code>	}</code></span>
<span class="codeline" id="line-1072"><code>}</code></span>
<span class="codeline" id="line-1073"><code></code></span>
<span class="codeline" id="line-1074"><code>type parentStack struct {</code></span>
<span class="codeline" id="line-1075"><code>	p     *printer</code></span>
<span class="codeline" id="line-1076"><code>	stack []string</code></span>
<span class="codeline" id="line-1077"><code>}</code></span>
<span class="codeline" id="line-1078"><code></code></span>
<span class="codeline" id="line-1079"><code>// trim updates the XML context to match the longest common prefix of the stack</code></span>
<span class="codeline" id="line-1080"><code>// and the given parents. A closing tag will be written for every parent</code></span>
<span class="codeline" id="line-1081"><code>// popped. Passing a zero slice or nil will close all the elements.</code></span>
<span class="codeline" id="line-1082"><code>func (s *parentStack) trim(parents []string) error {</code></span>
<span class="codeline" id="line-1083"><code>	split := 0</code></span>
<span class="codeline" id="line-1084"><code>	for ; split &lt; len(parents) &amp;&amp; split &lt; len(s.stack); split++ {</code></span>
<span class="codeline" id="line-1085"><code>		if parents[split] != s.stack[split] {</code></span>
<span class="codeline" id="line-1086"><code>			break</code></span>
<span class="codeline" id="line-1087"><code>		}</code></span>
<span class="codeline" id="line-1088"><code>	}</code></span>
<span class="codeline" id="line-1089"><code>	for i := len(s.stack) - 1; i &gt;= split; i-- {</code></span>
<span class="codeline" id="line-1090"><code>		if err := s.p.writeEnd(Name{Local: s.stack[i]}); err != nil {</code></span>
<span class="codeline" id="line-1091"><code>			return err</code></span>
<span class="codeline" id="line-1092"><code>		}</code></span>
<span class="codeline" id="line-1093"><code>	}</code></span>
<span class="codeline" id="line-1094"><code>	s.stack = s.stack[:split]</code></span>
<span class="codeline" id="line-1095"><code>	return nil</code></span>
<span class="codeline" id="line-1096"><code>}</code></span>
<span class="codeline" id="line-1097"><code></code></span>
<span class="codeline" id="line-1098"><code>// push adds parent elements to the stack and writes open tags.</code></span>
<span class="codeline" id="line-1099"><code>func (s *parentStack) push(parents []string) error {</code></span>
<span class="codeline" id="line-1100"><code>	for i := 0; i &lt; len(parents); i++ {</code></span>
<span class="codeline" id="line-1101"><code>		if err := s.p.writeStart(&amp;StartElement{Name: Name{Local: parents[i]}}); err != nil {</code></span>
<span class="codeline" id="line-1102"><code>			return err</code></span>
<span class="codeline" id="line-1103"><code>		}</code></span>
<span class="codeline" id="line-1104"><code>	}</code></span>
<span class="codeline" id="line-1105"><code>	s.stack = append(s.stack, parents...)</code></span>
<span class="codeline" id="line-1106"><code>	return nil</code></span>
<span class="codeline" id="line-1107"><code>}</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>// UnsupportedTypeError is returned when [Marshal] encounters a type</code></span>
<span class="codeline" id="line-1110"><code>// that cannot be converted into XML.</code></span>
<span class="codeline" id="line-1111"><code>type UnsupportedTypeError struct {</code></span>
<span class="codeline" id="line-1112"><code>	Type reflect.Type</code></span>
<span class="codeline" id="line-1113"><code>}</code></span>
<span class="codeline" id="line-1114"><code></code></span>
<span class="codeline" id="line-1115"><code>func (e *UnsupportedTypeError) Error() string {</code></span>
<span class="codeline" id="line-1116"><code>	return "xml: unsupported type: " + e.Type.String()</code></span>
<span class="codeline" id="line-1117"><code>}</code></span>
<span class="codeline" id="line-1118"><code></code></span>
<span class="codeline" id="line-1119"><code>func isEmptyValue(v reflect.Value) bool {</code></span>
<span class="codeline" id="line-1120"><code>	switch v.Kind() {</code></span>
<span class="codeline" id="line-1121"><code>	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:</code></span>
<span class="codeline" id="line-1122"><code>		return v.Len() == 0</code></span>
<span class="codeline" id="line-1123"><code>	case reflect.Bool,</code></span>
<span class="codeline" id="line-1124"><code>		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,</code></span>
<span class="codeline" id="line-1125"><code>		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,</code></span>
<span class="codeline" id="line-1126"><code>		reflect.Float32, reflect.Float64,</code></span>
<span class="codeline" id="line-1127"><code>		reflect.Interface, reflect.Pointer:</code></span>
<span class="codeline" id="line-1128"><code>		return v.IsZero()</code></span>
<span class="codeline" id="line-1129"><code>	}</code></span>
<span class="codeline" id="line-1130"><code>	return false</code></span>
<span class="codeline" id="line-1131"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>