<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: sqlite3.go in package github.com/mattn/go-sqlite3</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	sqlite3.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/mattn/go-sqlite3.html">github.com/mattn/go-sqlite3</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Code generated by cmd/cgo; DO NOT EDIT.</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>//line /home/joseph/go/pkg/mod/github.com/mattn/go-sqlite3@v1.14.22/sqlite3.go:1:1</code></span>
<span class="codeline" id="line-4"><code>// Copyright (C) 2019 Yasuhiro Matsumoto &lt;mattn.jp@gmail.com&gt;.</code></span>
<span class="codeline" id="line-5"><code>// Copyright (C) 2018 G.J.R. Timmer &lt;gjr.timmer@gmail.com&gt;.</code></span>
<span class="codeline" id="line-6"><code>//</code></span>
<span class="codeline" id="line-7"><code>// Use of this source code is governed by an MIT-style</code></span>
<span class="codeline" id="line-8"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>//go:build cgo</code></span>
<span class="codeline" id="line-11"><code>// +build cgo</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>package sqlite3; import _cgo_unsafe "unsafe"</code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>/*</code></span>
<span class="codeline" id="line-16"><code>#cgo CFLAGS: -std=gnu99</code></span>
<span class="codeline" id="line-17"><code>#cgo CFLAGS: -DSQLITE_ENABLE_RTREE</code></span>
<span class="codeline" id="line-18"><code>#cgo CFLAGS: -DSQLITE_THREADSAFE=1</code></span>
<span class="codeline" id="line-19"><code>#cgo CFLAGS: -DHAVE_USLEEP=1</code></span>
<span class="codeline" id="line-20"><code>#cgo CFLAGS: -DSQLITE_ENABLE_FTS3</code></span>
<span class="codeline" id="line-21"><code>#cgo CFLAGS: -DSQLITE_ENABLE_FTS3_PARENTHESIS</code></span>
<span class="codeline" id="line-22"><code>#cgo CFLAGS: -DSQLITE_TRACE_SIZE_LIMIT=15</code></span>
<span class="codeline" id="line-23"><code>#cgo CFLAGS: -DSQLITE_OMIT_DEPRECATED</code></span>
<span class="codeline" id="line-24"><code>#cgo CFLAGS: -DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1</code></span>
<span class="codeline" id="line-25"><code>#cgo CFLAGS: -DSQLITE_ENABLE_UPDATE_DELETE_LIMIT</code></span>
<span class="codeline" id="line-26"><code>#cgo CFLAGS: -Wno-deprecated-declarations</code></span>
<span class="codeline" id="line-27"><code>#cgo openbsd CFLAGS: -I/usr/local/include</code></span>
<span class="codeline" id="line-28"><code>#cgo openbsd LDFLAGS: -L/usr/local/lib</code></span>
<span class="codeline" id="line-29"><code>#ifndef USE_LIBSQLITE3</code></span>
<span class="codeline" id="line-30"><code>#include "sqlite3-binding.h"</code></span>
<span class="codeline" id="line-31"><code>#else</code></span>
<span class="codeline" id="line-32"><code>#include &lt;sqlite3.h&gt;</code></span>
<span class="codeline" id="line-33"><code>#endif</code></span>
<span class="codeline" id="line-34"><code>#include &lt;stdlib.h&gt;</code></span>
<span class="codeline" id="line-35"><code>#include &lt;string.h&gt;</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>#ifdef __CYGWIN__</code></span>
<span class="codeline" id="line-38"><code># include &lt;errno.h&gt;</code></span>
<span class="codeline" id="line-39"><code>#endif</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>#ifndef SQLITE_OPEN_READWRITE</code></span>
<span class="codeline" id="line-42"><code># define SQLITE_OPEN_READWRITE 0</code></span>
<span class="codeline" id="line-43"><code>#endif</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>#ifndef SQLITE_OPEN_FULLMUTEX</code></span>
<span class="codeline" id="line-46"><code># define SQLITE_OPEN_FULLMUTEX 0</code></span>
<span class="codeline" id="line-47"><code>#endif</code></span>
<span class="codeline" id="line-48"><code></code></span>
<span class="codeline" id="line-49"><code>#ifndef SQLITE_DETERMINISTIC</code></span>
<span class="codeline" id="line-50"><code># define SQLITE_DETERMINISTIC 0</code></span>
<span class="codeline" id="line-51"><code>#endif</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>#if defined(HAVE_PREAD64) &amp;&amp; defined(HAVE_PWRITE64)</code></span>
<span class="codeline" id="line-54"><code># undef USE_PREAD</code></span>
<span class="codeline" id="line-55"><code># undef USE_PWRITE</code></span>
<span class="codeline" id="line-56"><code># define USE_PREAD64 1</code></span>
<span class="codeline" id="line-57"><code># define USE_PWRITE64 1</code></span>
<span class="codeline" id="line-58"><code>#elif defined(HAVE_PREAD) &amp;&amp; defined(HAVE_PWRITE)</code></span>
<span class="codeline" id="line-59"><code># undef USE_PREAD</code></span>
<span class="codeline" id="line-60"><code># undef USE_PWRITE</code></span>
<span class="codeline" id="line-61"><code># define USE_PREAD64 1</code></span>
<span class="codeline" id="line-62"><code># define USE_PWRITE64 1</code></span>
<span class="codeline" id="line-63"><code>#endif</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>static int</code></span>
<span class="codeline" id="line-66"><code>_sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs) {</code></span>
<span class="codeline" id="line-67"><code>#ifdef SQLITE_OPEN_URI</code></span>
<span class="codeline" id="line-68"><code>  return sqlite3_open_v2(filename, ppDb, flags | SQLITE_OPEN_URI, zVfs);</code></span>
<span class="codeline" id="line-69"><code>#else</code></span>
<span class="codeline" id="line-70"><code>  return sqlite3_open_v2(filename, ppDb, flags, zVfs);</code></span>
<span class="codeline" id="line-71"><code>#endif</code></span>
<span class="codeline" id="line-72"><code>}</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>static int</code></span>
<span class="codeline" id="line-75"><code>_sqlite3_bind_text(sqlite3_stmt *stmt, int n, char *p, int np) {</code></span>
<span class="codeline" id="line-76"><code>  return sqlite3_bind_text(stmt, n, p, np, SQLITE_TRANSIENT);</code></span>
<span class="codeline" id="line-77"><code>}</code></span>
<span class="codeline" id="line-78"><code></code></span>
<span class="codeline" id="line-79"><code>static int</code></span>
<span class="codeline" id="line-80"><code>_sqlite3_bind_blob(sqlite3_stmt *stmt, int n, void *p, int np) {</code></span>
<span class="codeline" id="line-81"><code>  return sqlite3_bind_blob(stmt, n, p, np, SQLITE_TRANSIENT);</code></span>
<span class="codeline" id="line-82"><code>}</code></span>
<span class="codeline" id="line-83"><code></code></span>
<span class="codeline" id="line-84"><code>#include &lt;stdio.h&gt;</code></span>
<span class="codeline" id="line-85"><code>#include &lt;stdint.h&gt;</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>static int</code></span>
<span class="codeline" id="line-88"><code>_sqlite3_exec(sqlite3* db, const char* pcmd, long long* rowid, long long* changes)</code></span>
<span class="codeline" id="line-89"><code>{</code></span>
<span class="codeline" id="line-90"><code>  int rv = sqlite3_exec(db, pcmd, 0, 0, 0);</code></span>
<span class="codeline" id="line-91"><code>  *rowid = (long long) sqlite3_last_insert_rowid(db);</code></span>
<span class="codeline" id="line-92"><code>  *changes = (long long) sqlite3_changes(db);</code></span>
<span class="codeline" id="line-93"><code>  return rv;</code></span>
<span class="codeline" id="line-94"><code>}</code></span>
<span class="codeline" id="line-95"><code></code></span>
<span class="codeline" id="line-96"><code>#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY</code></span>
<span class="codeline" id="line-97"><code>extern int _sqlite3_step_blocking(sqlite3_stmt *stmt);</code></span>
<span class="codeline" id="line-98"><code>extern int _sqlite3_step_row_blocking(sqlite3_stmt* stmt, long long* rowid, long long* changes);</code></span>
<span class="codeline" id="line-99"><code>extern int _sqlite3_prepare_v2_blocking(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail);</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>static int</code></span>
<span class="codeline" id="line-102"><code>_sqlite3_step_internal(sqlite3_stmt *stmt)</code></span>
<span class="codeline" id="line-103"><code>{</code></span>
<span class="codeline" id="line-104"><code>  return _sqlite3_step_blocking(stmt);</code></span>
<span class="codeline" id="line-105"><code>}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>static int</code></span>
<span class="codeline" id="line-108"><code>_sqlite3_step_row_internal(sqlite3_stmt* stmt, long long* rowid, long long* changes)</code></span>
<span class="codeline" id="line-109"><code>{</code></span>
<span class="codeline" id="line-110"><code>  return _sqlite3_step_row_blocking(stmt, rowid, changes);</code></span>
<span class="codeline" id="line-111"><code>}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>static int</code></span>
<span class="codeline" id="line-114"><code>_sqlite3_prepare_v2_internal(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail)</code></span>
<span class="codeline" id="line-115"><code>{</code></span>
<span class="codeline" id="line-116"><code>  return _sqlite3_prepare_v2_blocking(db, zSql, nBytes, ppStmt, pzTail);</code></span>
<span class="codeline" id="line-117"><code>}</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>#else</code></span>
<span class="codeline" id="line-120"><code>static int</code></span>
<span class="codeline" id="line-121"><code>_sqlite3_step_internal(sqlite3_stmt *stmt)</code></span>
<span class="codeline" id="line-122"><code>{</code></span>
<span class="codeline" id="line-123"><code>  return sqlite3_step(stmt);</code></span>
<span class="codeline" id="line-124"><code>}</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>static int</code></span>
<span class="codeline" id="line-127"><code>_sqlite3_step_row_internal(sqlite3_stmt* stmt, long long* rowid, long long* changes)</code></span>
<span class="codeline" id="line-128"><code>{</code></span>
<span class="codeline" id="line-129"><code>  int rv = sqlite3_step(stmt);</code></span>
<span class="codeline" id="line-130"><code>  sqlite3* db = sqlite3_db_handle(stmt);</code></span>
<span class="codeline" id="line-131"><code>  *rowid = (long long) sqlite3_last_insert_rowid(db);</code></span>
<span class="codeline" id="line-132"><code>  *changes = (long long) sqlite3_changes(db);</code></span>
<span class="codeline" id="line-133"><code>  return rv;</code></span>
<span class="codeline" id="line-134"><code>}</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>static int</code></span>
<span class="codeline" id="line-137"><code>_sqlite3_prepare_v2_internal(sqlite3 *db, const char *zSql, int nBytes, sqlite3_stmt **ppStmt, const char **pzTail)</code></span>
<span class="codeline" id="line-138"><code>{</code></span>
<span class="codeline" id="line-139"><code>  return sqlite3_prepare_v2(db, zSql, nBytes, ppStmt, pzTail);</code></span>
<span class="codeline" id="line-140"><code>}</code></span>
<span class="codeline" id="line-141"><code>#endif</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>void _sqlite3_result_text(sqlite3_context* ctx, const char* s) {</code></span>
<span class="codeline" id="line-144"><code>  sqlite3_result_text(ctx, s, -1, &amp;free);</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>void _sqlite3_result_blob(sqlite3_context* ctx, const void* b, int l) {</code></span>
<span class="codeline" id="line-148"><code>  sqlite3_result_blob(ctx, b, l, SQLITE_TRANSIENT);</code></span>
<span class="codeline" id="line-149"><code>}</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>int _sqlite3_create_function(</code></span>
<span class="codeline" id="line-153"><code>  sqlite3 *db,</code></span>
<span class="codeline" id="line-154"><code>  const char *zFunctionName,</code></span>
<span class="codeline" id="line-155"><code>  int nArg,</code></span>
<span class="codeline" id="line-156"><code>  int eTextRep,</code></span>
<span class="codeline" id="line-157"><code>  uintptr_t pApp,</code></span>
<span class="codeline" id="line-158"><code>  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),</code></span>
<span class="codeline" id="line-159"><code>  void (*xStep)(sqlite3_context*,int,sqlite3_value**),</code></span>
<span class="codeline" id="line-160"><code>  void (*xFinal)(sqlite3_context*)</code></span>
<span class="codeline" id="line-161"><code>) {</code></span>
<span class="codeline" id="line-162"><code>  return sqlite3_create_function(db, zFunctionName, nArg, eTextRep, (void*) pApp, xFunc, xStep, xFinal);</code></span>
<span class="codeline" id="line-163"><code>}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>void callbackTrampoline(sqlite3_context*, int, sqlite3_value**);</code></span>
<span class="codeline" id="line-166"><code>void stepTrampoline(sqlite3_context*, int, sqlite3_value**);</code></span>
<span class="codeline" id="line-167"><code>void doneTrampoline(sqlite3_context*);</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>int compareTrampoline(void*, int, char*, int, char*);</code></span>
<span class="codeline" id="line-170"><code>int commitHookTrampoline(void*);</code></span>
<span class="codeline" id="line-171"><code>void rollbackHookTrampoline(void*);</code></span>
<span class="codeline" id="line-172"><code>void updateHookTrampoline(void*, int, char*, char*, sqlite3_int64);</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>int authorizerTrampoline(void*, int, char*, char*, char*, char*);</code></span>
<span class="codeline" id="line-175"><code></code></span>
<span class="codeline" id="line-176"><code>#ifdef SQLITE_LIMIT_WORKER_THREADS</code></span>
<span class="codeline" id="line-177"><code># define _SQLITE_HAS_LIMIT</code></span>
<span class="codeline" id="line-178"><code># define SQLITE_LIMIT_LENGTH                    0</code></span>
<span class="codeline" id="line-179"><code># define SQLITE_LIMIT_SQL_LENGTH                1</code></span>
<span class="codeline" id="line-180"><code># define SQLITE_LIMIT_COLUMN                    2</code></span>
<span class="codeline" id="line-181"><code># define SQLITE_LIMIT_EXPR_DEPTH                3</code></span>
<span class="codeline" id="line-182"><code># define SQLITE_LIMIT_COMPOUND_SELECT           4</code></span>
<span class="codeline" id="line-183"><code># define SQLITE_LIMIT_VDBE_OP                   5</code></span>
<span class="codeline" id="line-184"><code># define SQLITE_LIMIT_FUNCTION_ARG              6</code></span>
<span class="codeline" id="line-185"><code># define SQLITE_LIMIT_ATTACHED                  7</code></span>
<span class="codeline" id="line-186"><code># define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8</code></span>
<span class="codeline" id="line-187"><code># define SQLITE_LIMIT_VARIABLE_NUMBER           9</code></span>
<span class="codeline" id="line-188"><code># define SQLITE_LIMIT_TRIGGER_DEPTH            10</code></span>
<span class="codeline" id="line-189"><code># define SQLITE_LIMIT_WORKER_THREADS           11</code></span>
<span class="codeline" id="line-190"><code># else</code></span>
<span class="codeline" id="line-191"><code># define SQLITE_LIMIT_WORKER_THREADS           11</code></span>
<span class="codeline" id="line-192"><code>#endif</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>static int _sqlite3_limit(sqlite3* db, int limitId, int newLimit) {</code></span>
<span class="codeline" id="line-195"><code>#ifndef _SQLITE_HAS_LIMIT</code></span>
<span class="codeline" id="line-196"><code>  return -1;</code></span>
<span class="codeline" id="line-197"><code>#else</code></span>
<span class="codeline" id="line-198"><code>  return sqlite3_limit(db, limitId, newLimit);</code></span>
<span class="codeline" id="line-199"><code>#endif</code></span>
<span class="codeline" id="line-200"><code>}</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>#if SQLITE_VERSION_NUMBER &lt; 3012000</code></span>
<span class="codeline" id="line-203"><code>static int sqlite3_system_errno(sqlite3 *db) {</code></span>
<span class="codeline" id="line-204"><code>  return 0;</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code>#endif</code></span>
<span class="codeline" id="line-207"><code>*/</code></span>
<span class="codeline" id="line-208"><code>import _ "unsafe"</code></span>
<span class="codeline" id="line-209"><code>import (</code></span>
<span class="codeline" id="line-210"><code>	"context"</code></span>
<span class="codeline" id="line-211"><code>	"database/sql"</code></span>
<span class="codeline" id="line-212"><code>	"database/sql/driver"</code></span>
<span class="codeline" id="line-213"><code>	"errors"</code></span>
<span class="codeline" id="line-214"><code>	"fmt"</code></span>
<span class="codeline" id="line-215"><code>	"io"</code></span>
<span class="codeline" id="line-216"><code>	"net/url"</code></span>
<span class="codeline" id="line-217"><code>	"reflect"</code></span>
<span class="codeline" id="line-218"><code>	"runtime"</code></span>
<span class="codeline" id="line-219"><code>	"strconv"</code></span>
<span class="codeline" id="line-220"><code>	"strings"</code></span>
<span class="codeline" id="line-221"><code>	"sync"</code></span>
<span class="codeline" id="line-222"><code>	"syscall"</code></span>
<span class="codeline" id="line-223"><code>	"time"</code></span>
<span class="codeline" id="line-224"><code>	"unsafe"</code></span>
<span class="codeline" id="line-225"><code>)</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>// SQLiteTimestampFormats is timestamp formats understood by both this module</code></span>
<span class="codeline" id="line-228"><code>// and SQLite.  The first format in the slice will be used when saving time</code></span>
<span class="codeline" id="line-229"><code>// values into the database. When parsing a string from a timestamp or datetime</code></span>
<span class="codeline" id="line-230"><code>// column, the formats are tried in order.</code></span>
<span class="codeline" id="line-231"><code>var SQLiteTimestampFormats = []string{</code></span>
<span class="codeline" id="line-232"><code>	// By default, store timestamps with whatever timezone they come with.</code></span>
<span class="codeline" id="line-233"><code>	// When parsed, they will be returned with the same timezone.</code></span>
<span class="codeline" id="line-234"><code>	"2006-01-02 15:04:05.999999999-07:00",</code></span>
<span class="codeline" id="line-235"><code>	"2006-01-02T15:04:05.999999999-07:00",</code></span>
<span class="codeline" id="line-236"><code>	"2006-01-02 15:04:05.999999999",</code></span>
<span class="codeline" id="line-237"><code>	"2006-01-02T15:04:05.999999999",</code></span>
<span class="codeline" id="line-238"><code>	"2006-01-02 15:04:05",</code></span>
<span class="codeline" id="line-239"><code>	"2006-01-02T15:04:05",</code></span>
<span class="codeline" id="line-240"><code>	"2006-01-02 15:04",</code></span>
<span class="codeline" id="line-241"><code>	"2006-01-02T15:04",</code></span>
<span class="codeline" id="line-242"><code>	"2006-01-02",</code></span>
<span class="codeline" id="line-243"><code>}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>const (</code></span>
<span class="codeline" id="line-246"><code>	columnDate      string = "date"</code></span>
<span class="codeline" id="line-247"><code>	columnDatetime  string = "datetime"</code></span>
<span class="codeline" id="line-248"><code>	columnTimestamp string = "timestamp"</code></span>
<span class="codeline" id="line-249"><code>)</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>// This variable can be replaced with -ldflags like below:</code></span>
<span class="codeline" id="line-252"><code>// go build -ldflags="-X 'github.com/mattn/go-sqlite3.driverName=my-sqlite3'"</code></span>
<span class="codeline" id="line-253"><code>var driverName = "sqlite3"</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>func init() {</code></span>
<span class="codeline" id="line-256"><code>	if driverName != "" {</code></span>
<span class="codeline" id="line-257"><code>		sql.Register(driverName, &amp;SQLiteDriver{})</code></span>
<span class="codeline" id="line-258"><code>	}</code></span>
<span class="codeline" id="line-259"><code>}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>// Version returns SQLite library version information.</code></span>
<span class="codeline" id="line-262"><code>func Version() (libVersion string, libVersionNumber int, sourceID string) {</code></span>
<span class="codeline" id="line-263"><code>	libVersion = ( /*line :260:15*/_Cfunc_GoString /*line :260:24*/)(( /*line :260:26*/_Cfunc_sqlite3_libversion /*line :260:45*/)())</code></span>
<span class="codeline" id="line-264"><code>	libVersionNumber = int(( /*line :261:25*/_Cfunc_sqlite3_libversion_number /*line :261:51*/)())</code></span>
<span class="codeline" id="line-265"><code>	sourceID = ( /*line :262:13*/_Cfunc_GoString /*line :262:22*/)(( /*line :262:24*/_Cfunc_sqlite3_sourceid /*line :262:41*/)())</code></span>
<span class="codeline" id="line-266"><code>	return libVersion, libVersionNumber, sourceID</code></span>
<span class="codeline" id="line-267"><code>}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>const (</code></span>
<span class="codeline" id="line-270"><code>	// used by authorizer and pre_update_hook</code></span>
<span class="codeline" id="line-271"><code>	SQLITE_DELETE = ( /*line :268:18*/_Ciconst_SQLITE_DELETE /*line :268:32*/)</code></span>
<span class="codeline" id="line-272"><code>	SQLITE_INSERT = ( /*line :269:18*/_Ciconst_SQLITE_INSERT /*line :269:32*/)</code></span>
<span class="codeline" id="line-273"><code>	SQLITE_UPDATE = ( /*line :270:18*/_Ciconst_SQLITE_UPDATE /*line :270:32*/)</code></span>
<span class="codeline" id="line-274"><code></code></span>
<span class="codeline" id="line-275"><code>	// used by authorzier - as return value</code></span>
<span class="codeline" id="line-276"><code>	SQLITE_OK     = ( /*line :273:18*/_Ciconst_SQLITE_OK /*line :273:28*/)</code></span>
<span class="codeline" id="line-277"><code>	SQLITE_IGNORE = ( /*line :274:18*/_Ciconst_SQLITE_IGNORE /*line :274:32*/)</code></span>
<span class="codeline" id="line-278"><code>	SQLITE_DENY   = ( /*line :275:18*/_Ciconst_SQLITE_DENY /*line :275:30*/)</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	// different actions query tries to do - passed as argument to authorizer</code></span>
<span class="codeline" id="line-281"><code>	SQLITE_CREATE_INDEX        = ( /*line :278:31*/_Ciconst_SQLITE_CREATE_INDEX /*line :278:51*/)</code></span>
<span class="codeline" id="line-282"><code>	SQLITE_CREATE_TABLE        = ( /*line :279:31*/_Ciconst_SQLITE_CREATE_TABLE /*line :279:51*/)</code></span>
<span class="codeline" id="line-283"><code>	SQLITE_CREATE_TEMP_INDEX   = ( /*line :280:31*/_Ciconst_SQLITE_CREATE_TEMP_INDEX /*line :280:56*/)</code></span>
<span class="codeline" id="line-284"><code>	SQLITE_CREATE_TEMP_TABLE   = ( /*line :281:31*/_Ciconst_SQLITE_CREATE_TEMP_TABLE /*line :281:56*/)</code></span>
<span class="codeline" id="line-285"><code>	SQLITE_CREATE_TEMP_TRIGGER = ( /*line :282:31*/_Ciconst_SQLITE_CREATE_TEMP_TRIGGER /*line :282:58*/)</code></span>
<span class="codeline" id="line-286"><code>	SQLITE_CREATE_TEMP_VIEW    = ( /*line :283:31*/_Ciconst_SQLITE_CREATE_TEMP_VIEW /*line :283:55*/)</code></span>
<span class="codeline" id="line-287"><code>	SQLITE_CREATE_TRIGGER      = ( /*line :284:31*/_Ciconst_SQLITE_CREATE_TRIGGER /*line :284:53*/)</code></span>
<span class="codeline" id="line-288"><code>	SQLITE_CREATE_VIEW         = ( /*line :285:31*/_Ciconst_SQLITE_CREATE_VIEW /*line :285:50*/)</code></span>
<span class="codeline" id="line-289"><code>	SQLITE_CREATE_VTABLE       = ( /*line :286:31*/_Ciconst_SQLITE_CREATE_VTABLE /*line :286:52*/)</code></span>
<span class="codeline" id="line-290"><code>	SQLITE_DROP_INDEX          = ( /*line :287:31*/_Ciconst_SQLITE_DROP_INDEX /*line :287:49*/)</code></span>
<span class="codeline" id="line-291"><code>	SQLITE_DROP_TABLE          = ( /*line :288:31*/_Ciconst_SQLITE_DROP_TABLE /*line :288:49*/)</code></span>
<span class="codeline" id="line-292"><code>	SQLITE_DROP_TEMP_INDEX     = ( /*line :289:31*/_Ciconst_SQLITE_DROP_TEMP_INDEX /*line :289:54*/)</code></span>
<span class="codeline" id="line-293"><code>	SQLITE_DROP_TEMP_TABLE     = ( /*line :290:31*/_Ciconst_SQLITE_DROP_TEMP_TABLE /*line :290:54*/)</code></span>
<span class="codeline" id="line-294"><code>	SQLITE_DROP_TEMP_TRIGGER   = ( /*line :291:31*/_Ciconst_SQLITE_DROP_TEMP_TRIGGER /*line :291:56*/)</code></span>
<span class="codeline" id="line-295"><code>	SQLITE_DROP_TEMP_VIEW      = ( /*line :292:31*/_Ciconst_SQLITE_DROP_TEMP_VIEW /*line :292:53*/)</code></span>
<span class="codeline" id="line-296"><code>	SQLITE_DROP_TRIGGER        = ( /*line :293:31*/_Ciconst_SQLITE_DROP_TRIGGER /*line :293:51*/)</code></span>
<span class="codeline" id="line-297"><code>	SQLITE_DROP_VIEW           = ( /*line :294:31*/_Ciconst_SQLITE_DROP_VIEW /*line :294:48*/)</code></span>
<span class="codeline" id="line-298"><code>	SQLITE_DROP_VTABLE         = ( /*line :295:31*/_Ciconst_SQLITE_DROP_VTABLE /*line :295:50*/)</code></span>
<span class="codeline" id="line-299"><code>	SQLITE_PRAGMA              = ( /*line :296:31*/_Ciconst_SQLITE_PRAGMA /*line :296:45*/)</code></span>
<span class="codeline" id="line-300"><code>	SQLITE_READ                = ( /*line :297:31*/_Ciconst_SQLITE_READ /*line :297:43*/)</code></span>
<span class="codeline" id="line-301"><code>	SQLITE_SELECT              = ( /*line :298:31*/_Ciconst_SQLITE_SELECT /*line :298:45*/)</code></span>
<span class="codeline" id="line-302"><code>	SQLITE_TRANSACTION         = ( /*line :299:31*/_Ciconst_SQLITE_TRANSACTION /*line :299:50*/)</code></span>
<span class="codeline" id="line-303"><code>	SQLITE_ATTACH              = ( /*line :300:31*/_Ciconst_SQLITE_ATTACH /*line :300:45*/)</code></span>
<span class="codeline" id="line-304"><code>	SQLITE_DETACH              = ( /*line :301:31*/_Ciconst_SQLITE_DETACH /*line :301:45*/)</code></span>
<span class="codeline" id="line-305"><code>	SQLITE_ALTER_TABLE         = ( /*line :302:31*/_Ciconst_SQLITE_ALTER_TABLE /*line :302:50*/)</code></span>
<span class="codeline" id="line-306"><code>	SQLITE_REINDEX             = ( /*line :303:31*/_Ciconst_SQLITE_REINDEX /*line :303:46*/)</code></span>
<span class="codeline" id="line-307"><code>	SQLITE_ANALYZE             = ( /*line :304:31*/_Ciconst_SQLITE_ANALYZE /*line :304:46*/)</code></span>
<span class="codeline" id="line-308"><code>	SQLITE_FUNCTION            = ( /*line :305:31*/_Ciconst_SQLITE_FUNCTION /*line :305:47*/)</code></span>
<span class="codeline" id="line-309"><code>	SQLITE_SAVEPOINT           = ( /*line :306:31*/_Ciconst_SQLITE_SAVEPOINT /*line :306:48*/)</code></span>
<span class="codeline" id="line-310"><code>	SQLITE_COPY                = ( /*line :307:31*/_Ciconst_SQLITE_COPY /*line :307:43*/)</code></span>
<span class="codeline" id="line-311"><code>	/*SQLITE_RECURSIVE           = C.SQLITE_RECURSIVE*/</code></span>
<span class="codeline" id="line-312"><code>)</code></span>
<span class="codeline" id="line-313"><code></code></span>
<span class="codeline" id="line-314"><code>// Standard File Control Opcodes</code></span>
<span class="codeline" id="line-315"><code>// See: https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html</code></span>
<span class="codeline" id="line-316"><code>const (</code></span>
<span class="codeline" id="line-317"><code>	SQLITE_FCNTL_LOCKSTATE             = int(1)</code></span>
<span class="codeline" id="line-318"><code>	SQLITE_FCNTL_GET_LOCKPROXYFILE     = int(2)</code></span>
<span class="codeline" id="line-319"><code>	SQLITE_FCNTL_SET_LOCKPROXYFILE     = int(3)</code></span>
<span class="codeline" id="line-320"><code>	SQLITE_FCNTL_LAST_ERRNO            = int(4)</code></span>
<span class="codeline" id="line-321"><code>	SQLITE_FCNTL_SIZE_HINT             = int(5)</code></span>
<span class="codeline" id="line-322"><code>	SQLITE_FCNTL_CHUNK_SIZE            = int(6)</code></span>
<span class="codeline" id="line-323"><code>	SQLITE_FCNTL_FILE_POINTER          = int(7)</code></span>
<span class="codeline" id="line-324"><code>	SQLITE_FCNTL_SYNC_OMITTED          = int(8)</code></span>
<span class="codeline" id="line-325"><code>	SQLITE_FCNTL_WIN32_AV_RETRY        = int(9)</code></span>
<span class="codeline" id="line-326"><code>	SQLITE_FCNTL_PERSIST_WAL           = int(10)</code></span>
<span class="codeline" id="line-327"><code>	SQLITE_FCNTL_OVERWRITE             = int(11)</code></span>
<span class="codeline" id="line-328"><code>	SQLITE_FCNTL_VFSNAME               = int(12)</code></span>
<span class="codeline" id="line-329"><code>	SQLITE_FCNTL_POWERSAFE_OVERWRITE   = int(13)</code></span>
<span class="codeline" id="line-330"><code>	SQLITE_FCNTL_PRAGMA                = int(14)</code></span>
<span class="codeline" id="line-331"><code>	SQLITE_FCNTL_BUSYHANDLER           = int(15)</code></span>
<span class="codeline" id="line-332"><code>	SQLITE_FCNTL_TEMPFILENAME          = int(16)</code></span>
<span class="codeline" id="line-333"><code>	SQLITE_FCNTL_MMAP_SIZE             = int(18)</code></span>
<span class="codeline" id="line-334"><code>	SQLITE_FCNTL_TRACE                 = int(19)</code></span>
<span class="codeline" id="line-335"><code>	SQLITE_FCNTL_HAS_MOVED             = int(20)</code></span>
<span class="codeline" id="line-336"><code>	SQLITE_FCNTL_SYNC                  = int(21)</code></span>
<span class="codeline" id="line-337"><code>	SQLITE_FCNTL_COMMIT_PHASETWO       = int(22)</code></span>
<span class="codeline" id="line-338"><code>	SQLITE_FCNTL_WIN32_SET_HANDLE      = int(23)</code></span>
<span class="codeline" id="line-339"><code>	SQLITE_FCNTL_WAL_BLOCK             = int(24)</code></span>
<span class="codeline" id="line-340"><code>	SQLITE_FCNTL_ZIPVFS                = int(25)</code></span>
<span class="codeline" id="line-341"><code>	SQLITE_FCNTL_RBU                   = int(26)</code></span>
<span class="codeline" id="line-342"><code>	SQLITE_FCNTL_VFS_POINTER           = int(27)</code></span>
<span class="codeline" id="line-343"><code>	SQLITE_FCNTL_JOURNAL_POINTER       = int(28)</code></span>
<span class="codeline" id="line-344"><code>	SQLITE_FCNTL_WIN32_GET_HANDLE      = int(29)</code></span>
<span class="codeline" id="line-345"><code>	SQLITE_FCNTL_PDB                   = int(30)</code></span>
<span class="codeline" id="line-346"><code>	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE    = int(31)</code></span>
<span class="codeline" id="line-347"><code>	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE   = int(32)</code></span>
<span class="codeline" id="line-348"><code>	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = int(33)</code></span>
<span class="codeline" id="line-349"><code>	SQLITE_FCNTL_LOCK_TIMEOUT          = int(34)</code></span>
<span class="codeline" id="line-350"><code>	SQLITE_FCNTL_DATA_VERSION          = int(35)</code></span>
<span class="codeline" id="line-351"><code>	SQLITE_FCNTL_SIZE_LIMIT            = int(36)</code></span>
<span class="codeline" id="line-352"><code>	SQLITE_FCNTL_CKPT_DONE             = int(37)</code></span>
<span class="codeline" id="line-353"><code>	SQLITE_FCNTL_RESERVE_BYTES         = int(38)</code></span>
<span class="codeline" id="line-354"><code>	SQLITE_FCNTL_CKPT_START            = int(39)</code></span>
<span class="codeline" id="line-355"><code>	SQLITE_FCNTL_EXTERNAL_READER       = int(40)</code></span>
<span class="codeline" id="line-356"><code>	SQLITE_FCNTL_CKSM_FILE             = int(41)</code></span>
<span class="codeline" id="line-357"><code>)</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>// SQLiteDriver implements driver.Driver.</code></span>
<span class="codeline" id="line-360"><code>type SQLiteDriver struct {</code></span>
<span class="codeline" id="line-361"><code>	Extensions  []string</code></span>
<span class="codeline" id="line-362"><code>	ConnectHook func(*SQLiteConn) error</code></span>
<span class="codeline" id="line-363"><code>}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>// SQLiteConn implements driver.Conn.</code></span>
<span class="codeline" id="line-366"><code>type SQLiteConn struct {</code></span>
<span class="codeline" id="line-367"><code>	mu          sync.Mutex</code></span>
<span class="codeline" id="line-368"><code>	db          * /*line :365:15*/_Ctype_sqlite3 /*line :365:24*/</code></span>
<span class="codeline" id="line-369"><code>	loc         *time.Location</code></span>
<span class="codeline" id="line-370"><code>	txlock      string</code></span>
<span class="codeline" id="line-371"><code>	funcs       []*functionInfo</code></span>
<span class="codeline" id="line-372"><code>	aggregators []*aggInfo</code></span>
<span class="codeline" id="line-373"><code>}</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>// SQLiteTx implements driver.Tx.</code></span>
<span class="codeline" id="line-376"><code>type SQLiteTx struct {</code></span>
<span class="codeline" id="line-377"><code>	c *SQLiteConn</code></span>
<span class="codeline" id="line-378"><code>}</code></span>
<span class="codeline" id="line-379"><code></code></span>
<span class="codeline" id="line-380"><code>// SQLiteStmt implements driver.Stmt.</code></span>
<span class="codeline" id="line-381"><code>type SQLiteStmt struct {</code></span>
<span class="codeline" id="line-382"><code>	mu     sync.Mutex</code></span>
<span class="codeline" id="line-383"><code>	c      *SQLiteConn</code></span>
<span class="codeline" id="line-384"><code>	s      * /*line :381:10*/_Ctype_sqlite3_stmt /*line :381:24*/</code></span>
<span class="codeline" id="line-385"><code>	t      string</code></span>
<span class="codeline" id="line-386"><code>	closed bool</code></span>
<span class="codeline" id="line-387"><code>	cls    bool</code></span>
<span class="codeline" id="line-388"><code>}</code></span>
<span class="codeline" id="line-389"><code></code></span>
<span class="codeline" id="line-390"><code>// SQLiteResult implements sql.Result.</code></span>
<span class="codeline" id="line-391"><code>type SQLiteResult struct {</code></span>
<span class="codeline" id="line-392"><code>	id      int64</code></span>
<span class="codeline" id="line-393"><code>	changes int64</code></span>
<span class="codeline" id="line-394"><code>}</code></span>
<span class="codeline" id="line-395"><code></code></span>
<span class="codeline" id="line-396"><code>// SQLiteRows implements driver.Rows.</code></span>
<span class="codeline" id="line-397"><code>type SQLiteRows struct {</code></span>
<span class="codeline" id="line-398"><code>	s        *SQLiteStmt</code></span>
<span class="codeline" id="line-399"><code>	nc       int</code></span>
<span class="codeline" id="line-400"><code>	cols     []string</code></span>
<span class="codeline" id="line-401"><code>	decltype []string</code></span>
<span class="codeline" id="line-402"><code>	cls      bool</code></span>
<span class="codeline" id="line-403"><code>	closed   bool</code></span>
<span class="codeline" id="line-404"><code>	ctx      context.Context // no better alternative to pass context into Next() method</code></span>
<span class="codeline" id="line-405"><code>}</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>type functionInfo struct {</code></span>
<span class="codeline" id="line-408"><code>	f                 reflect.Value</code></span>
<span class="codeline" id="line-409"><code>	argConverters     []callbackArgConverter</code></span>
<span class="codeline" id="line-410"><code>	variadicConverter callbackArgConverter</code></span>
<span class="codeline" id="line-411"><code>	retConverter      callbackRetConverter</code></span>
<span class="codeline" id="line-412"><code>}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>func (fi *functionInfo) Call(ctx * /*line :411:35*/_Ctype_sqlite3_context /*line :411:52*/, argv []* /*line :411:62*/_Ctype_sqlite3_value /*line :411:77*/) {</code></span>
<span class="codeline" id="line-415"><code>	args, err := callbackConvertArgs(argv, fi.argConverters, fi.variadicConverter)</code></span>
<span class="codeline" id="line-416"><code>	if err != nil {</code></span>
<span class="codeline" id="line-417"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-418"><code>		return</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	ret := fi.f.Call(args)</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>	if len(ret) == 2 &amp;&amp; ret[1].Interface() != nil {</code></span>
<span class="codeline" id="line-424"><code>		callbackError(ctx, ret[1].Interface().(error))</code></span>
<span class="codeline" id="line-425"><code>		return</code></span>
<span class="codeline" id="line-426"><code>	}</code></span>
<span class="codeline" id="line-427"><code></code></span>
<span class="codeline" id="line-428"><code>	err = fi.retConverter(ctx, ret[0])</code></span>
<span class="codeline" id="line-429"><code>	if err != nil {</code></span>
<span class="codeline" id="line-430"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-431"><code>		return</code></span>
<span class="codeline" id="line-432"><code>	}</code></span>
<span class="codeline" id="line-433"><code>}</code></span>
<span class="codeline" id="line-434"><code></code></span>
<span class="codeline" id="line-435"><code>type aggInfo struct {</code></span>
<span class="codeline" id="line-436"><code>	constructor reflect.Value</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>	// Active aggregator objects for aggregations in flight. The</code></span>
<span class="codeline" id="line-439"><code>	// aggregators are indexed by a counter stored in the aggregation</code></span>
<span class="codeline" id="line-440"><code>	// user data space provided by sqlite.</code></span>
<span class="codeline" id="line-441"><code>	active map[int64]reflect.Value</code></span>
<span class="codeline" id="line-442"><code>	next   int64</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>	stepArgConverters     []callbackArgConverter</code></span>
<span class="codeline" id="line-445"><code>	stepVariadicConverter callbackArgConverter</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>	doneRetConverter callbackRetConverter</code></span>
<span class="codeline" id="line-448"><code>}</code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>func (ai *aggInfo) agg(ctx * /*line :447:29*/_Ctype_sqlite3_context /*line :447:46*/) (int64, reflect.Value, error) {</code></span>
<span class="codeline" id="line-451"><code>	aggIdx := (*int64)(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :448:49*/ctx; var _cgo1 _Ctype_int = _Ctype_int /*line :448:59*/(8); _cgoCheckPointer(_cgo0, nil); return /*line :448:63*/_Cfunc_sqlite3_aggregate_context(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-452"><code>	if *aggIdx == 0 {</code></span>
<span class="codeline" id="line-453"><code>		*aggIdx = ai.next</code></span>
<span class="codeline" id="line-454"><code>		ret := ai.constructor.Call(nil)</code></span>
<span class="codeline" id="line-455"><code>		if len(ret) == 2 &amp;&amp; ret[1].Interface() != nil {</code></span>
<span class="codeline" id="line-456"><code>			return 0, reflect.Value{}, ret[1].Interface().(error)</code></span>
<span class="codeline" id="line-457"><code>		}</code></span>
<span class="codeline" id="line-458"><code>		if ret[0].IsNil() {</code></span>
<span class="codeline" id="line-459"><code>			return 0, reflect.Value{}, errors.New("aggregator constructor returned nil state")</code></span>
<span class="codeline" id="line-460"><code>		}</code></span>
<span class="codeline" id="line-461"><code>		ai.next++</code></span>
<span class="codeline" id="line-462"><code>		ai.active[*aggIdx] = ret[0]</code></span>
<span class="codeline" id="line-463"><code>	}</code></span>
<span class="codeline" id="line-464"><code>	return *aggIdx, ai.active[*aggIdx], nil</code></span>
<span class="codeline" id="line-465"><code>}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>func (ai *aggInfo) Step(ctx * /*line :464:30*/_Ctype_sqlite3_context /*line :464:47*/, argv []* /*line :464:57*/_Ctype_sqlite3_value /*line :464:72*/) {</code></span>
<span class="codeline" id="line-468"><code>	_, agg, err := ai.agg(ctx)</code></span>
<span class="codeline" id="line-469"><code>	if err != nil {</code></span>
<span class="codeline" id="line-470"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-471"><code>		return</code></span>
<span class="codeline" id="line-472"><code>	}</code></span>
<span class="codeline" id="line-473"><code></code></span>
<span class="codeline" id="line-474"><code>	args, err := callbackConvertArgs(argv, ai.stepArgConverters, ai.stepVariadicConverter)</code></span>
<span class="codeline" id="line-475"><code>	if err != nil {</code></span>
<span class="codeline" id="line-476"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-477"><code>		return</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	ret := agg.MethodByName("Step").Call(args)</code></span>
<span class="codeline" id="line-481"><code>	if len(ret) == 1 &amp;&amp; ret[0].Interface() != nil {</code></span>
<span class="codeline" id="line-482"><code>		callbackError(ctx, ret[0].Interface().(error))</code></span>
<span class="codeline" id="line-483"><code>		return</code></span>
<span class="codeline" id="line-484"><code>	}</code></span>
<span class="codeline" id="line-485"><code>}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>func (ai *aggInfo) Done(ctx * /*line :484:30*/_Ctype_sqlite3_context /*line :484:47*/) {</code></span>
<span class="codeline" id="line-488"><code>	idx, agg, err := ai.agg(ctx)</code></span>
<span class="codeline" id="line-489"><code>	if err != nil {</code></span>
<span class="codeline" id="line-490"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-491"><code>		return</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code>	defer func() { delete(ai.active, idx) }()</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>	ret := agg.MethodByName("Done").Call(nil)</code></span>
<span class="codeline" id="line-496"><code>	if len(ret) == 2 &amp;&amp; ret[1].Interface() != nil {</code></span>
<span class="codeline" id="line-497"><code>		callbackError(ctx, ret[1].Interface().(error))</code></span>
<span class="codeline" id="line-498"><code>		return</code></span>
<span class="codeline" id="line-499"><code>	}</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>	err = ai.doneRetConverter(ctx, ret[0])</code></span>
<span class="codeline" id="line-502"><code>	if err != nil {</code></span>
<span class="codeline" id="line-503"><code>		callbackError(ctx, err)</code></span>
<span class="codeline" id="line-504"><code>		return</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>// Commit transaction.</code></span>
<span class="codeline" id="line-509"><code>func (tx *SQLiteTx) Commit() error {</code></span>
<span class="codeline" id="line-510"><code>	_, err := tx.c.exec(context.Background(), "COMMIT", nil)</code></span>
<span class="codeline" id="line-511"><code>	if err != nil {</code></span>
<span class="codeline" id="line-512"><code>		// sqlite3 may leave the transaction open in this scenario.</code></span>
<span class="codeline" id="line-513"><code>		// However, database/sql considers the transaction complete once we</code></span>
<span class="codeline" id="line-514"><code>		// return from Commit() - we must clean up to honour its semantics.</code></span>
<span class="codeline" id="line-515"><code>		// We don't know if the ROLLBACK is strictly necessary, but according</code></span>
<span class="codeline" id="line-516"><code>		// to sqlite's docs, there is no harm in calling ROLLBACK unnecessarily.</code></span>
<span class="codeline" id="line-517"><code>		tx.c.exec(context.Background(), "ROLLBACK", nil)</code></span>
<span class="codeline" id="line-518"><code>	}</code></span>
<span class="codeline" id="line-519"><code>	return err</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>// Rollback transaction.</code></span>
<span class="codeline" id="line-523"><code>func (tx *SQLiteTx) Rollback() error {</code></span>
<span class="codeline" id="line-524"><code>	_, err := tx.c.exec(context.Background(), "ROLLBACK", nil)</code></span>
<span class="codeline" id="line-525"><code>	return err</code></span>
<span class="codeline" id="line-526"><code>}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>// RegisterCollation makes a Go function available as a collation.</code></span>
<span class="codeline" id="line-529"><code>//</code></span>
<span class="codeline" id="line-530"><code>// cmp receives two UTF-8 strings, a and b. The result should be 0 if</code></span>
<span class="codeline" id="line-531"><code>// a==b, -1 if a &lt; b, and +1 if a &gt; b.</code></span>
<span class="codeline" id="line-532"><code>//</code></span>
<span class="codeline" id="line-533"><code>// cmp must always return the same result given the same</code></span>
<span class="codeline" id="line-534"><code>// inputs. Additionally, it must have the following properties for all</code></span>
<span class="codeline" id="line-535"><code>// strings A, B and C: if A==B then B==A; if A==B and B==C then A==C;</code></span>
<span class="codeline" id="line-536"><code>// if A&lt;B then B&gt;A; if A&lt;B and B&lt;C then A&lt;C.</code></span>
<span class="codeline" id="line-537"><code>//</code></span>
<span class="codeline" id="line-538"><code>// If cmp does not obey these constraints, sqlite3's behavior is</code></span>
<span class="codeline" id="line-539"><code>// undefined when the collation is used.</code></span>
<span class="codeline" id="line-540"><code>func (c *SQLiteConn) RegisterCollation(name string, cmp func(string, string) int) error {</code></span>
<span class="codeline" id="line-541"><code>	handle := newHandle(c, cmp)</code></span>
<span class="codeline" id="line-542"><code>	cname := ( /*line :539:11*/_Cfunc_CString /*line :539:19*/)(name)</code></span>
<span class="codeline" id="line-543"><code>	defer func() func() { _cgo0 := /*line :540:15*/unsafe.Pointer(cname); return func() { _cgoCheckPointer(_cgo0, nil); /*line :540:37*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-544"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :541:35*/c.db; var _cgo1 *_Ctype_char = /*line :541:41*/cname; var _cgo2 _Ctype_int = /*line :541:48*/_Ciconst_SQLITE_UTF8 /*line :541:61*/; _cgo3 := /*line :541:63*/handle; var _cgo4 *[0]byte = /*line :541:71*/(*[0]byte)(unsafe.Pointer(_Cgo_ptr(_Cfpvar_fp_compareTrampoline /*line :541:116*/))); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return /*line :541:119*/_Cfunc_sqlite3_create_collation(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()</code></span>
<span class="codeline" id="line-545"><code>	if rv != ( /*line :542:11*/_Ciconst_SQLITE_OK /*line :542:21*/) {</code></span>
<span class="codeline" id="line-546"><code>		return c.lastError()</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code>	return nil</code></span>
<span class="codeline" id="line-549"><code>}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>// RegisterCommitHook sets the commit hook for a connection.</code></span>
<span class="codeline" id="line-552"><code>//</code></span>
<span class="codeline" id="line-553"><code>// If the callback returns non-zero the transaction will become a rollback.</code></span>
<span class="codeline" id="line-554"><code>//</code></span>
<span class="codeline" id="line-555"><code>// If there is an existing commit hook for this connection, it will be</code></span>
<span class="codeline" id="line-556"><code>// removed. If callback is nil the existing hook (if any) will be removed</code></span>
<span class="codeline" id="line-557"><code>// without creating a new one.</code></span>
<span class="codeline" id="line-558"><code>func (c *SQLiteConn) RegisterCommitHook(callback func() int) {</code></span>
<span class="codeline" id="line-559"><code>	if callback == nil {</code></span>
<span class="codeline" id="line-560"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :557:25*/c.db; var _cgo1 *[0]byte = /*line :557:31*/nil; var _cgo2 _cgo_unsafe.Pointer = /*line :557:36*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :557:40*/_Cfunc_sqlite3_commit_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-561"><code>	} else {</code></span>
<span class="codeline" id="line-562"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :559:25*/c.db; var _cgo1 *[0]byte = /*line :559:31*/(*[0]byte)(_Cgo_ptr(_Cfpvar_fp_commitHookTrampoline /*line :559:64*/)); _cgo2 := /*line :559:67*/newHandle(c, callback); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :559:90*/_Cfunc_sqlite3_commit_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-563"><code>	}</code></span>
<span class="codeline" id="line-564"><code>}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>// RegisterRollbackHook sets the rollback hook for a connection.</code></span>
<span class="codeline" id="line-567"><code>//</code></span>
<span class="codeline" id="line-568"><code>// If there is an existing rollback hook for this connection, it will be</code></span>
<span class="codeline" id="line-569"><code>// removed. If callback is nil the existing hook (if any) will be removed</code></span>
<span class="codeline" id="line-570"><code>// without creating a new one.</code></span>
<span class="codeline" id="line-571"><code>func (c *SQLiteConn) RegisterRollbackHook(callback func()) {</code></span>
<span class="codeline" id="line-572"><code>	if callback == nil {</code></span>
<span class="codeline" id="line-573"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :570:27*/c.db; var _cgo1 *[0]byte = /*line :570:33*/nil; var _cgo2 _cgo_unsafe.Pointer = /*line :570:38*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :570:42*/_Cfunc_sqlite3_rollback_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-574"><code>	} else {</code></span>
<span class="codeline" id="line-575"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :572:27*/c.db; var _cgo1 *[0]byte = /*line :572:33*/(*[0]byte)(_Cgo_ptr(_Cfpvar_fp_rollbackHookTrampoline /*line :572:68*/)); _cgo2 := /*line :572:71*/newHandle(c, callback); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :572:94*/_Cfunc_sqlite3_rollback_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-576"><code>	}</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>// RegisterUpdateHook sets the update hook for a connection.</code></span>
<span class="codeline" id="line-580"><code>//</code></span>
<span class="codeline" id="line-581"><code>// The parameters to the callback are the operation (one of the constants</code></span>
<span class="codeline" id="line-582"><code>// SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE), the database name, the</code></span>
<span class="codeline" id="line-583"><code>// table name, and the rowid.</code></span>
<span class="codeline" id="line-584"><code>//</code></span>
<span class="codeline" id="line-585"><code>// If there is an existing update hook for this connection, it will be</code></span>
<span class="codeline" id="line-586"><code>// removed. If callback is nil the existing hook (if any) will be removed</code></span>
<span class="codeline" id="line-587"><code>// without creating a new one.</code></span>
<span class="codeline" id="line-588"><code>func (c *SQLiteConn) RegisterUpdateHook(callback func(int, string, string, int64)) {</code></span>
<span class="codeline" id="line-589"><code>	if callback == nil {</code></span>
<span class="codeline" id="line-590"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :587:25*/c.db; var _cgo1 *[0]byte = /*line :587:31*/nil; var _cgo2 _cgo_unsafe.Pointer = /*line :587:36*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :587:40*/_Cfunc_sqlite3_update_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-591"><code>	} else {</code></span>
<span class="codeline" id="line-592"><code>		func() _cgo_unsafe.Pointer{ _cgo0 := /*line :589:25*/c.db; var _cgo1 *[0]byte = /*line :589:31*/(*[0]byte)(_Cgo_ptr(_Cfpvar_fp_updateHookTrampoline /*line :589:64*/)); _cgo2 := /*line :589:67*/newHandle(c, callback); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :589:90*/_Cfunc_sqlite3_update_hook(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-593"><code>	}</code></span>
<span class="codeline" id="line-594"><code>}</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>// RegisterAuthorizer sets the authorizer for connection.</code></span>
<span class="codeline" id="line-597"><code>//</code></span>
<span class="codeline" id="line-598"><code>// The parameters to the callback are the operation (one of the constants</code></span>
<span class="codeline" id="line-599"><code>// SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE), and 1 to 3 arguments,</code></span>
<span class="codeline" id="line-600"><code>// depending on operation. More details see:</code></span>
<span class="codeline" id="line-601"><code>// https://www.sqlite.org/c3ref/c_alter_table.html</code></span>
<span class="codeline" id="line-602"><code>func (c *SQLiteConn) RegisterAuthorizer(callback func(int, string, string, string) int) {</code></span>
<span class="codeline" id="line-603"><code>	if callback == nil {</code></span>
<span class="codeline" id="line-604"><code>		func() _Ctype_int{ _cgo0 := /*line :601:28*/c.db; var _cgo1 *[0]byte = /*line :601:34*/nil; var _cgo2 _cgo_unsafe.Pointer = /*line :601:39*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :601:43*/_Cfunc_sqlite3_set_authorizer(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-605"><code>	} else {</code></span>
<span class="codeline" id="line-606"><code>		func() _Ctype_int{ _cgo0 := /*line :603:28*/c.db; var _cgo1 *[0]byte = /*line :603:34*/(*[0]byte)(_Cgo_ptr(_Cfpvar_fp_authorizerTrampoline /*line :603:67*/)); _cgo2 := /*line :603:70*/newHandle(c, callback); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :603:93*/_Cfunc_sqlite3_set_authorizer(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-607"><code>	}</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// RegisterFunc makes a Go function available as a SQLite function.</code></span>
<span class="codeline" id="line-611"><code>//</code></span>
<span class="codeline" id="line-612"><code>// The Go function can have arguments of the following types: any</code></span>
<span class="codeline" id="line-613"><code>// numeric type except complex, bool, []byte, string and any.</code></span>
<span class="codeline" id="line-614"><code>// any arguments are given the direct translation of the SQLite data type:</code></span>
<span class="codeline" id="line-615"><code>// int64 for INTEGER, float64 for FLOAT, []byte for BLOB, string for TEXT.</code></span>
<span class="codeline" id="line-616"><code>//</code></span>
<span class="codeline" id="line-617"><code>// The function can additionally be variadic, as long as the type of</code></span>
<span class="codeline" id="line-618"><code>// the variadic argument is one of the above.</code></span>
<span class="codeline" id="line-619"><code>//</code></span>
<span class="codeline" id="line-620"><code>// If pure is true. SQLite will assume that the function's return</code></span>
<span class="codeline" id="line-621"><code>// value depends only on its inputs, and make more aggressive</code></span>
<span class="codeline" id="line-622"><code>// optimizations in its queries.</code></span>
<span class="codeline" id="line-623"><code>//</code></span>
<span class="codeline" id="line-624"><code>// See _example/go_custom_funcs for a detailed example.</code></span>
<span class="codeline" id="line-625"><code>func (c *SQLiteConn) RegisterFunc(name string, impl any, pure bool) error {</code></span>
<span class="codeline" id="line-626"><code>	var fi functionInfo</code></span>
<span class="codeline" id="line-627"><code>	fi.f = reflect.ValueOf(impl)</code></span>
<span class="codeline" id="line-628"><code>	t := fi.f.Type()</code></span>
<span class="codeline" id="line-629"><code>	if t.Kind() != reflect.Func {</code></span>
<span class="codeline" id="line-630"><code>		return errors.New("Non-function passed to RegisterFunc")</code></span>
<span class="codeline" id="line-631"><code>	}</code></span>
<span class="codeline" id="line-632"><code>	if t.NumOut() != 1 &amp;&amp; t.NumOut() != 2 {</code></span>
<span class="codeline" id="line-633"><code>		return errors.New("SQLite functions must return 1 or 2 values")</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	if t.NumOut() == 2 &amp;&amp; !t.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {</code></span>
<span class="codeline" id="line-636"><code>		return errors.New("Second return value of SQLite function must be error")</code></span>
<span class="codeline" id="line-637"><code>	}</code></span>
<span class="codeline" id="line-638"><code></code></span>
<span class="codeline" id="line-639"><code>	numArgs := t.NumIn()</code></span>
<span class="codeline" id="line-640"><code>	if t.IsVariadic() {</code></span>
<span class="codeline" id="line-641"><code>		numArgs--</code></span>
<span class="codeline" id="line-642"><code>	}</code></span>
<span class="codeline" id="line-643"><code></code></span>
<span class="codeline" id="line-644"><code>	for i := 0; i &lt; numArgs; i++ {</code></span>
<span class="codeline" id="line-645"><code>		conv, err := callbackArg(t.In(i))</code></span>
<span class="codeline" id="line-646"><code>		if err != nil {</code></span>
<span class="codeline" id="line-647"><code>			return err</code></span>
<span class="codeline" id="line-648"><code>		}</code></span>
<span class="codeline" id="line-649"><code>		fi.argConverters = append(fi.argConverters, conv)</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>	if t.IsVariadic() {</code></span>
<span class="codeline" id="line-653"><code>		conv, err := callbackArg(t.In(numArgs).Elem())</code></span>
<span class="codeline" id="line-654"><code>		if err != nil {</code></span>
<span class="codeline" id="line-655"><code>			return err</code></span>
<span class="codeline" id="line-656"><code>		}</code></span>
<span class="codeline" id="line-657"><code>		fi.variadicConverter = conv</code></span>
<span class="codeline" id="line-658"><code>		// Pass -1 to sqlite so that it allows any number of</code></span>
<span class="codeline" id="line-659"><code>		// arguments. The call helper verifies that the minimum number</code></span>
<span class="codeline" id="line-660"><code>		// of arguments is present for variadic functions.</code></span>
<span class="codeline" id="line-661"><code>		numArgs = -1</code></span>
<span class="codeline" id="line-662"><code>	}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>	conv, err := callbackRet(t.Out(0))</code></span>
<span class="codeline" id="line-665"><code>	if err != nil {</code></span>
<span class="codeline" id="line-666"><code>		return err</code></span>
<span class="codeline" id="line-667"><code>	}</code></span>
<span class="codeline" id="line-668"><code>	fi.retConverter = conv</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>	// fi must outlast the database connection, or we'll have dangling pointers.</code></span>
<span class="codeline" id="line-671"><code>	c.funcs = append(c.funcs, &amp;fi)</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>	cname := ( /*line :670:11*/_Cfunc_CString /*line :670:19*/)(name)</code></span>
<span class="codeline" id="line-674"><code>	defer func() func() { _cgo0 := /*line :671:15*/unsafe.Pointer(cname); return func() { _cgoCheckPointer(_cgo0, nil); /*line :671:37*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-675"><code>	opts := ( /*line :672:10*/_Ciconst_SQLITE_UTF8 /*line :672:22*/)</code></span>
<span class="codeline" id="line-676"><code>	if pure {</code></span>
<span class="codeline" id="line-677"><code>		opts |= ( /*line :674:11*/_Ciconst_SQLITE_DETERMINISTIC /*line :674:32*/)</code></span>
<span class="codeline" id="line-678"><code>	}</code></span>
<span class="codeline" id="line-679"><code>	rv := sqlite3CreateFunction(c.db, cname,  /*line :676:43*/_Ctype_int /*line :676:48*/(numArgs),  /*line :676:59*/_Ctype_int /*line :676:64*/(opts), newHandle(c, &amp;fi), ( /*line :676:91*/_Cgo_ptr(_Cfpvar_fp_callbackTrampoline) /*line :676:110*/), nil, nil)</code></span>
<span class="codeline" id="line-680"><code>	if rv != ( /*line :677:11*/_Ciconst_SQLITE_OK /*line :677:21*/) {</code></span>
<span class="codeline" id="line-681"><code>		return c.lastError()</code></span>
<span class="codeline" id="line-682"><code>	}</code></span>
<span class="codeline" id="line-683"><code>	return nil</code></span>
<span class="codeline" id="line-684"><code>}</code></span>
<span class="codeline" id="line-685"><code></code></span>
<span class="codeline" id="line-686"><code>func sqlite3CreateFunction(db * /*line :683:32*/_Ctype_sqlite3 /*line :683:41*/, zFunctionName * /*line :683:58*/_Ctype_char /*line :683:64*/, nArg  /*line :683:71*/_Ctype_int /*line :683:76*/, eTextRep  /*line :683:87*/_Ctype_int /*line :683:92*/, pApp unsafe.Pointer, xFunc unsafe.Pointer, xStep unsafe.Pointer, xFinal unsafe.Pointer)  /*line :683:182*/_Ctype_int /*line :683:187*/ {</code></span>
<span class="codeline" id="line-687"><code>	return func() _Ctype_int{ _cgo0 := /*line :684:36*/db; var _cgo1 *_Ctype_char = /*line :684:40*/zFunctionName; var _cgo2 _Ctype_int = /*line :684:55*/nArg; var _cgo3 _Ctype_int = /*line :684:61*/eTextRep; var _cgo4 _Ctype_uintptr_t = _Ctype_uintptr_t /*line :684:82*/(uintptr(pApp)); var _cgo5 *[0]byte = /*line :684:99*/(*[0]byte)(xFunc); var _cgo6 *[0]byte = /*line :684:118*/(*[0]byte)(xStep); var _cgo7 *[0]byte = /*line :684:137*/(*[0]byte)(xFinal); _cgoCheckPointer(_cgo0, nil); return /*line :684:156*/_Cfunc__sqlite3_create_function(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7); }()</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>// RegisterAggregator makes a Go type available as a SQLite aggregation function.</code></span>
<span class="codeline" id="line-691"><code>//</code></span>
<span class="codeline" id="line-692"><code>// Because aggregation is incremental, it's implemented in Go with a</code></span>
<span class="codeline" id="line-693"><code>// type that has 2 methods: func Step(values) accumulates one row of</code></span>
<span class="codeline" id="line-694"><code>// data into the accumulator, and func Done() ret finalizes and</code></span>
<span class="codeline" id="line-695"><code>// returns the aggregate value. "values" and "ret" may be any type</code></span>
<span class="codeline" id="line-696"><code>// supported by RegisterFunc.</code></span>
<span class="codeline" id="line-697"><code>//</code></span>
<span class="codeline" id="line-698"><code>// RegisterAggregator takes as implementation a constructor function</code></span>
<span class="codeline" id="line-699"><code>// that constructs an instance of the aggregator type each time an</code></span>
<span class="codeline" id="line-700"><code>// aggregation begins. The constructor must return a pointer to a</code></span>
<span class="codeline" id="line-701"><code>// type, or an interface that implements Step() and Done().</code></span>
<span class="codeline" id="line-702"><code>//</code></span>
<span class="codeline" id="line-703"><code>// The constructor function and the Step/Done methods may optionally</code></span>
<span class="codeline" id="line-704"><code>// return an error in addition to their other return values.</code></span>
<span class="codeline" id="line-705"><code>//</code></span>
<span class="codeline" id="line-706"><code>// See _example/go_custom_funcs for a detailed example.</code></span>
<span class="codeline" id="line-707"><code>func (c *SQLiteConn) RegisterAggregator(name string, impl any, pure bool) error {</code></span>
<span class="codeline" id="line-708"><code>	var ai aggInfo</code></span>
<span class="codeline" id="line-709"><code>	ai.constructor = reflect.ValueOf(impl)</code></span>
<span class="codeline" id="line-710"><code>	t := ai.constructor.Type()</code></span>
<span class="codeline" id="line-711"><code>	if t.Kind() != reflect.Func {</code></span>
<span class="codeline" id="line-712"><code>		return errors.New("non-function passed to RegisterAggregator")</code></span>
<span class="codeline" id="line-713"><code>	}</code></span>
<span class="codeline" id="line-714"><code>	if t.NumOut() != 1 &amp;&amp; t.NumOut() != 2 {</code></span>
<span class="codeline" id="line-715"><code>		return errors.New("SQLite aggregator constructors must return 1 or 2 values")</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code>	if t.NumOut() == 2 &amp;&amp; !t.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {</code></span>
<span class="codeline" id="line-718"><code>		return errors.New("Second return value of SQLite function must be error")</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code>	if t.NumIn() != 0 {</code></span>
<span class="codeline" id="line-721"><code>		return errors.New("SQLite aggregator constructors must not have arguments")</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>	agg := t.Out(0)</code></span>
<span class="codeline" id="line-725"><code>	switch agg.Kind() {</code></span>
<span class="codeline" id="line-726"><code>	case reflect.Ptr, reflect.Interface:</code></span>
<span class="codeline" id="line-727"><code>	default:</code></span>
<span class="codeline" id="line-728"><code>		return errors.New("SQlite aggregator constructor must return a pointer object")</code></span>
<span class="codeline" id="line-729"><code>	}</code></span>
<span class="codeline" id="line-730"><code>	stepFn, found := agg.MethodByName("Step")</code></span>
<span class="codeline" id="line-731"><code>	if !found {</code></span>
<span class="codeline" id="line-732"><code>		return errors.New("SQlite aggregator doesn't have a Step() function")</code></span>
<span class="codeline" id="line-733"><code>	}</code></span>
<span class="codeline" id="line-734"><code>	step := stepFn.Type</code></span>
<span class="codeline" id="line-735"><code>	if step.NumOut() != 0 &amp;&amp; step.NumOut() != 1 {</code></span>
<span class="codeline" id="line-736"><code>		return errors.New("SQlite aggregator Step() function must return 0 or 1 values")</code></span>
<span class="codeline" id="line-737"><code>	}</code></span>
<span class="codeline" id="line-738"><code>	if step.NumOut() == 1 &amp;&amp; !step.Out(0).Implements(reflect.TypeOf((*error)(nil)).Elem()) {</code></span>
<span class="codeline" id="line-739"><code>		return errors.New("type of SQlite aggregator Step() return value must be error")</code></span>
<span class="codeline" id="line-740"><code>	}</code></span>
<span class="codeline" id="line-741"><code></code></span>
<span class="codeline" id="line-742"><code>	stepNArgs := step.NumIn()</code></span>
<span class="codeline" id="line-743"><code>	start := 0</code></span>
<span class="codeline" id="line-744"><code>	if agg.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-745"><code>		// Skip over the method receiver</code></span>
<span class="codeline" id="line-746"><code>		stepNArgs--</code></span>
<span class="codeline" id="line-747"><code>		start++</code></span>
<span class="codeline" id="line-748"><code>	}</code></span>
<span class="codeline" id="line-749"><code>	if step.IsVariadic() {</code></span>
<span class="codeline" id="line-750"><code>		stepNArgs--</code></span>
<span class="codeline" id="line-751"><code>	}</code></span>
<span class="codeline" id="line-752"><code>	for i := start; i &lt; start+stepNArgs; i++ {</code></span>
<span class="codeline" id="line-753"><code>		conv, err := callbackArg(step.In(i))</code></span>
<span class="codeline" id="line-754"><code>		if err != nil {</code></span>
<span class="codeline" id="line-755"><code>			return err</code></span>
<span class="codeline" id="line-756"><code>		}</code></span>
<span class="codeline" id="line-757"><code>		ai.stepArgConverters = append(ai.stepArgConverters, conv)</code></span>
<span class="codeline" id="line-758"><code>	}</code></span>
<span class="codeline" id="line-759"><code>	if step.IsVariadic() {</code></span>
<span class="codeline" id="line-760"><code>		conv, err := callbackArg(step.In(start + stepNArgs).Elem())</code></span>
<span class="codeline" id="line-761"><code>		if err != nil {</code></span>
<span class="codeline" id="line-762"><code>			return err</code></span>
<span class="codeline" id="line-763"><code>		}</code></span>
<span class="codeline" id="line-764"><code>		ai.stepVariadicConverter = conv</code></span>
<span class="codeline" id="line-765"><code>		// Pass -1 to sqlite so that it allows any number of</code></span>
<span class="codeline" id="line-766"><code>		// arguments. The call helper verifies that the minimum number</code></span>
<span class="codeline" id="line-767"><code>		// of arguments is present for variadic functions.</code></span>
<span class="codeline" id="line-768"><code>		stepNArgs = -1</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code></code></span>
<span class="codeline" id="line-771"><code>	doneFn, found := agg.MethodByName("Done")</code></span>
<span class="codeline" id="line-772"><code>	if !found {</code></span>
<span class="codeline" id="line-773"><code>		return errors.New("SQlite aggregator doesn't have a Done() function")</code></span>
<span class="codeline" id="line-774"><code>	}</code></span>
<span class="codeline" id="line-775"><code>	done := doneFn.Type</code></span>
<span class="codeline" id="line-776"><code>	doneNArgs := done.NumIn()</code></span>
<span class="codeline" id="line-777"><code>	if agg.Kind() == reflect.Ptr {</code></span>
<span class="codeline" id="line-778"><code>		// Skip over the method receiver</code></span>
<span class="codeline" id="line-779"><code>		doneNArgs--</code></span>
<span class="codeline" id="line-780"><code>	}</code></span>
<span class="codeline" id="line-781"><code>	if doneNArgs != 0 {</code></span>
<span class="codeline" id="line-782"><code>		return errors.New("SQlite aggregator Done() function must have no arguments")</code></span>
<span class="codeline" id="line-783"><code>	}</code></span>
<span class="codeline" id="line-784"><code>	if done.NumOut() != 1 &amp;&amp; done.NumOut() != 2 {</code></span>
<span class="codeline" id="line-785"><code>		return errors.New("SQLite aggregator Done() function must return 1 or 2 values")</code></span>
<span class="codeline" id="line-786"><code>	}</code></span>
<span class="codeline" id="line-787"><code>	if done.NumOut() == 2 &amp;&amp; !done.Out(1).Implements(reflect.TypeOf((*error)(nil)).Elem()) {</code></span>
<span class="codeline" id="line-788"><code>		return errors.New("second return value of SQLite aggregator Done() function must be error")</code></span>
<span class="codeline" id="line-789"><code>	}</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>	conv, err := callbackRet(done.Out(0))</code></span>
<span class="codeline" id="line-792"><code>	if err != nil {</code></span>
<span class="codeline" id="line-793"><code>		return err</code></span>
<span class="codeline" id="line-794"><code>	}</code></span>
<span class="codeline" id="line-795"><code>	ai.doneRetConverter = conv</code></span>
<span class="codeline" id="line-796"><code>	ai.active = make(map[int64]reflect.Value)</code></span>
<span class="codeline" id="line-797"><code>	ai.next = 1</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>	// ai must outlast the database connection, or we'll have dangling pointers.</code></span>
<span class="codeline" id="line-800"><code>	c.aggregators = append(c.aggregators, &amp;ai)</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>	cname := ( /*line :799:11*/_Cfunc_CString /*line :799:19*/)(name)</code></span>
<span class="codeline" id="line-803"><code>	defer func() func() { _cgo0 := /*line :800:15*/unsafe.Pointer(cname); return func() { _cgoCheckPointer(_cgo0, nil); /*line :800:37*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-804"><code>	opts := ( /*line :801:10*/_Ciconst_SQLITE_UTF8 /*line :801:22*/)</code></span>
<span class="codeline" id="line-805"><code>	if pure {</code></span>
<span class="codeline" id="line-806"><code>		opts |= ( /*line :803:11*/_Ciconst_SQLITE_DETERMINISTIC /*line :803:32*/)</code></span>
<span class="codeline" id="line-807"><code>	}</code></span>
<span class="codeline" id="line-808"><code>	rv := sqlite3CreateFunction(c.db, cname,  /*line :805:43*/_Ctype_int /*line :805:48*/(stepNArgs),  /*line :805:61*/_Ctype_int /*line :805:66*/(opts), newHandle(c, &amp;ai), nil, ( /*line :805:98*/_Cgo_ptr(_Cfpvar_fp_stepTrampoline) /*line :805:113*/), ( /*line :805:116*/_Cgo_ptr(_Cfpvar_fp_doneTrampoline) /*line :805:131*/))</code></span>
<span class="codeline" id="line-809"><code>	if rv != ( /*line :806:11*/_Ciconst_SQLITE_OK /*line :806:21*/) {</code></span>
<span class="codeline" id="line-810"><code>		return c.lastError()</code></span>
<span class="codeline" id="line-811"><code>	}</code></span>
<span class="codeline" id="line-812"><code>	return nil</code></span>
<span class="codeline" id="line-813"><code>}</code></span>
<span class="codeline" id="line-814"><code></code></span>
<span class="codeline" id="line-815"><code>// AutoCommit return which currently auto commit or not.</code></span>
<span class="codeline" id="line-816"><code>func (c *SQLiteConn) AutoCommit() bool {</code></span>
<span class="codeline" id="line-817"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-818"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-819"><code>	return int(func() _Ctype_int{ _cgo0 := /*line :816:38*/c.db; _cgoCheckPointer(_cgo0, nil); return /*line :816:43*/_Cfunc_sqlite3_get_autocommit(_cgo0); }()) != 0</code></span>
<span class="codeline" id="line-820"><code>}</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>func (c *SQLiteConn) lastError() error {</code></span>
<span class="codeline" id="line-823"><code>	return lastError(c.db)</code></span>
<span class="codeline" id="line-824"><code>}</code></span>
<span class="codeline" id="line-825"><code></code></span>
<span class="codeline" id="line-826"><code>// Note: may be called with db == nil</code></span>
<span class="codeline" id="line-827"><code>func lastError(db * /*line :824:20*/_Ctype_sqlite3 /*line :824:29*/) error {</code></span>
<span class="codeline" id="line-828"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :825:26*/db; _cgoCheckPointer(_cgo0, nil); return /*line :825:29*/_Cfunc_sqlite3_errcode(_cgo0); }() // returns SQLITE_NOMEM if db == nil</code></span>
<span class="codeline" id="line-829"><code>	if rv == ( /*line :826:11*/_Ciconst_SQLITE_OK /*line :826:21*/) {</code></span>
<span class="codeline" id="line-830"><code>		return nil</code></span>
<span class="codeline" id="line-831"><code>	}</code></span>
<span class="codeline" id="line-832"><code>	extrv := func() _Ctype_int{ _cgo0 := /*line :829:38*/db; _cgoCheckPointer(_cgo0, nil); return /*line :829:41*/_Cfunc_sqlite3_extended_errcode(_cgo0); }()    // returns SQLITE_NOMEM if db == nil</code></span>
<span class="codeline" id="line-833"><code>	errStr := ( /*line :830:12*/_Cfunc_GoString /*line :830:21*/)(func() *_Ctype_char{ _cgo0 := /*line :830:40*/db; _cgoCheckPointer(_cgo0, nil); return /*line :830:43*/_Cfunc_sqlite3_errmsg(_cgo0); }()) // returns "out of memory" if db == nil</code></span>
<span class="codeline" id="line-834"><code></code></span>
<span class="codeline" id="line-835"><code>	// https://www.sqlite.org/c3ref/system_errno.html</code></span>
<span class="codeline" id="line-836"><code>	// sqlite3_system_errno is only meaningful if the error code was SQLITE_CANTOPEN,</code></span>
<span class="codeline" id="line-837"><code>	// or it was SQLITE_IOERR and the extended code was not SQLITE_IOERR_NOMEM</code></span>
<span class="codeline" id="line-838"><code>	var systemErrno syscall.Errno</code></span>
<span class="codeline" id="line-839"><code>	if rv == ( /*line :836:11*/_Ciconst_SQLITE_CANTOPEN /*line :836:27*/) || (rv == ( /*line :836:39*/_Ciconst_SQLITE_IOERR /*line :836:52*/) &amp;&amp; extrv != ( /*line :836:66*/_Ciconst_SQLITE_IOERR_NOMEM /*line :836:85*/)) {</code></span>
<span class="codeline" id="line-840"><code>		systemErrno = syscall.Errno(func() _Ctype_int{ _cgo0 := /*line :837:54*/db; _cgoCheckPointer(_cgo0, nil); return /*line :837:57*/_Cfunc_sqlite3_system_errno(_cgo0); }())</code></span>
<span class="codeline" id="line-841"><code>	}</code></span>
<span class="codeline" id="line-842"><code></code></span>
<span class="codeline" id="line-843"><code>	return Error{</code></span>
<span class="codeline" id="line-844"><code>		Code:         ErrNo(rv),</code></span>
<span class="codeline" id="line-845"><code>		ExtendedCode: ErrNoExtended(extrv),</code></span>
<span class="codeline" id="line-846"><code>		SystemErrno:  systemErrno,</code></span>
<span class="codeline" id="line-847"><code>		err:          errStr,</code></span>
<span class="codeline" id="line-848"><code>	}</code></span>
<span class="codeline" id="line-849"><code>}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>// Exec implements Execer.</code></span>
<span class="codeline" id="line-852"><code>func (c *SQLiteConn) Exec(query string, args []driver.Value) (driver.Result, error) {</code></span>
<span class="codeline" id="line-853"><code>	list := make([]driver.NamedValue, len(args))</code></span>
<span class="codeline" id="line-854"><code>	for i, v := range args {</code></span>
<span class="codeline" id="line-855"><code>		list[i] = driver.NamedValue{</code></span>
<span class="codeline" id="line-856"><code>			Ordinal: i + 1,</code></span>
<span class="codeline" id="line-857"><code>			Value:   v,</code></span>
<span class="codeline" id="line-858"><code>		}</code></span>
<span class="codeline" id="line-859"><code>	}</code></span>
<span class="codeline" id="line-860"><code>	return c.exec(context.Background(), query, list)</code></span>
<span class="codeline" id="line-861"><code>}</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>func (c *SQLiteConn) exec(ctx context.Context, query string, args []driver.NamedValue) (driver.Result, error) {</code></span>
<span class="codeline" id="line-864"><code>	start := 0</code></span>
<span class="codeline" id="line-865"><code>	for {</code></span>
<span class="codeline" id="line-866"><code>		s, err := c.prepare(ctx, query)</code></span>
<span class="codeline" id="line-867"><code>		if err != nil {</code></span>
<span class="codeline" id="line-868"><code>			return nil, err</code></span>
<span class="codeline" id="line-869"><code>		}</code></span>
<span class="codeline" id="line-870"><code>		var res driver.Result</code></span>
<span class="codeline" id="line-871"><code>		if s.(*SQLiteStmt).s != nil {</code></span>
<span class="codeline" id="line-872"><code>			stmtArgs := make([]driver.NamedValue, 0, len(args))</code></span>
<span class="codeline" id="line-873"><code>			na := s.NumInput()</code></span>
<span class="codeline" id="line-874"><code>			if len(args)-start &lt; na {</code></span>
<span class="codeline" id="line-875"><code>				s.Close()</code></span>
<span class="codeline" id="line-876"><code>				return nil, fmt.Errorf("not enough args to execute query: want %d got %d", na, len(args))</code></span>
<span class="codeline" id="line-877"><code>			}</code></span>
<span class="codeline" id="line-878"><code>			// consume the number of arguments used in the current</code></span>
<span class="codeline" id="line-879"><code>			// statement and append all named arguments not</code></span>
<span class="codeline" id="line-880"><code>			// contained therein</code></span>
<span class="codeline" id="line-881"><code>			if len(args[start:start+na]) &gt; 0 {</code></span>
<span class="codeline" id="line-882"><code>				stmtArgs = append(stmtArgs, args[start:start+na]...)</code></span>
<span class="codeline" id="line-883"><code>				for i := range args {</code></span>
<span class="codeline" id="line-884"><code>					if (i &lt; start || i &gt;= na) &amp;&amp; args[i].Name != "" {</code></span>
<span class="codeline" id="line-885"><code>						stmtArgs = append(stmtArgs, args[i])</code></span>
<span class="codeline" id="line-886"><code>					}</code></span>
<span class="codeline" id="line-887"><code>				}</code></span>
<span class="codeline" id="line-888"><code>				for i := range stmtArgs {</code></span>
<span class="codeline" id="line-889"><code>					stmtArgs[i].Ordinal = i + 1</code></span>
<span class="codeline" id="line-890"><code>				}</code></span>
<span class="codeline" id="line-891"><code>			}</code></span>
<span class="codeline" id="line-892"><code>			res, err = s.(*SQLiteStmt).exec(ctx, stmtArgs)</code></span>
<span class="codeline" id="line-893"><code>			if err != nil &amp;&amp; err != driver.ErrSkip {</code></span>
<span class="codeline" id="line-894"><code>				s.Close()</code></span>
<span class="codeline" id="line-895"><code>				return nil, err</code></span>
<span class="codeline" id="line-896"><code>			}</code></span>
<span class="codeline" id="line-897"><code>			start += na</code></span>
<span class="codeline" id="line-898"><code>		}</code></span>
<span class="codeline" id="line-899"><code>		tail := s.(*SQLiteStmt).t</code></span>
<span class="codeline" id="line-900"><code>		s.Close()</code></span>
<span class="codeline" id="line-901"><code>		if tail == "" {</code></span>
<span class="codeline" id="line-902"><code>			if res == nil {</code></span>
<span class="codeline" id="line-903"><code>				// https://github.com/mattn/go-sqlite3/issues/963</code></span>
<span class="codeline" id="line-904"><code>				res = &amp;SQLiteResult{0, 0}</code></span>
<span class="codeline" id="line-905"><code>			}</code></span>
<span class="codeline" id="line-906"><code>			return res, nil</code></span>
<span class="codeline" id="line-907"><code>		}</code></span>
<span class="codeline" id="line-908"><code>		query = tail</code></span>
<span class="codeline" id="line-909"><code>	}</code></span>
<span class="codeline" id="line-910"><code>}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>// Query implements Queryer.</code></span>
<span class="codeline" id="line-913"><code>func (c *SQLiteConn) Query(query string, args []driver.Value) (driver.Rows, error) {</code></span>
<span class="codeline" id="line-914"><code>	list := make([]driver.NamedValue, len(args))</code></span>
<span class="codeline" id="line-915"><code>	for i, v := range args {</code></span>
<span class="codeline" id="line-916"><code>		list[i] = driver.NamedValue{</code></span>
<span class="codeline" id="line-917"><code>			Ordinal: i + 1,</code></span>
<span class="codeline" id="line-918"><code>			Value:   v,</code></span>
<span class="codeline" id="line-919"><code>		}</code></span>
<span class="codeline" id="line-920"><code>	}</code></span>
<span class="codeline" id="line-921"><code>	return c.query(context.Background(), query, list)</code></span>
<span class="codeline" id="line-922"><code>}</code></span>
<span class="codeline" id="line-923"><code></code></span>
<span class="codeline" id="line-924"><code>func (c *SQLiteConn) query(ctx context.Context, query string, args []driver.NamedValue) (driver.Rows, error) {</code></span>
<span class="codeline" id="line-925"><code>	start := 0</code></span>
<span class="codeline" id="line-926"><code>	for {</code></span>
<span class="codeline" id="line-927"><code>		stmtArgs := make([]driver.NamedValue, 0, len(args))</code></span>
<span class="codeline" id="line-928"><code>		s, err := c.prepare(ctx, query)</code></span>
<span class="codeline" id="line-929"><code>		if err != nil {</code></span>
<span class="codeline" id="line-930"><code>			return nil, err</code></span>
<span class="codeline" id="line-931"><code>		}</code></span>
<span class="codeline" id="line-932"><code>		s.(*SQLiteStmt).cls = true</code></span>
<span class="codeline" id="line-933"><code>		na := s.NumInput()</code></span>
<span class="codeline" id="line-934"><code>		if len(args)-start &lt; na {</code></span>
<span class="codeline" id="line-935"><code>			return nil, fmt.Errorf("not enough args to execute query: want %d got %d", na, len(args)-start)</code></span>
<span class="codeline" id="line-936"><code>		}</code></span>
<span class="codeline" id="line-937"><code>		// consume the number of arguments used in the current</code></span>
<span class="codeline" id="line-938"><code>		// statement and append all named arguments not contained</code></span>
<span class="codeline" id="line-939"><code>		// therein</code></span>
<span class="codeline" id="line-940"><code>		stmtArgs = append(stmtArgs, args[start:start+na]...)</code></span>
<span class="codeline" id="line-941"><code>		for i := range args {</code></span>
<span class="codeline" id="line-942"><code>			if (i &lt; start || i &gt;= na) &amp;&amp; args[i].Name != "" {</code></span>
<span class="codeline" id="line-943"><code>				stmtArgs = append(stmtArgs, args[i])</code></span>
<span class="codeline" id="line-944"><code>			}</code></span>
<span class="codeline" id="line-945"><code>		}</code></span>
<span class="codeline" id="line-946"><code>		for i := range stmtArgs {</code></span>
<span class="codeline" id="line-947"><code>			stmtArgs[i].Ordinal = i + 1</code></span>
<span class="codeline" id="line-948"><code>		}</code></span>
<span class="codeline" id="line-949"><code>		rows, err := s.(*SQLiteStmt).query(ctx, stmtArgs)</code></span>
<span class="codeline" id="line-950"><code>		if err != nil &amp;&amp; err != driver.ErrSkip {</code></span>
<span class="codeline" id="line-951"><code>			s.Close()</code></span>
<span class="codeline" id="line-952"><code>			return rows, err</code></span>
<span class="codeline" id="line-953"><code>		}</code></span>
<span class="codeline" id="line-954"><code>		start += na</code></span>
<span class="codeline" id="line-955"><code>		tail := s.(*SQLiteStmt).t</code></span>
<span class="codeline" id="line-956"><code>		if tail == "" {</code></span>
<span class="codeline" id="line-957"><code>			return rows, nil</code></span>
<span class="codeline" id="line-958"><code>		}</code></span>
<span class="codeline" id="line-959"><code>		rows.Close()</code></span>
<span class="codeline" id="line-960"><code>		s.Close()</code></span>
<span class="codeline" id="line-961"><code>		query = tail</code></span>
<span class="codeline" id="line-962"><code>	}</code></span>
<span class="codeline" id="line-963"><code>}</code></span>
<span class="codeline" id="line-964"><code></code></span>
<span class="codeline" id="line-965"><code>// Begin transaction.</code></span>
<span class="codeline" id="line-966"><code>func (c *SQLiteConn) Begin() (driver.Tx, error) {</code></span>
<span class="codeline" id="line-967"><code>	return c.begin(context.Background())</code></span>
<span class="codeline" id="line-968"><code>}</code></span>
<span class="codeline" id="line-969"><code></code></span>
<span class="codeline" id="line-970"><code>func (c *SQLiteConn) begin(ctx context.Context) (driver.Tx, error) {</code></span>
<span class="codeline" id="line-971"><code>	if _, err := c.exec(ctx, c.txlock, nil); err != nil {</code></span>
<span class="codeline" id="line-972"><code>		return nil, err</code></span>
<span class="codeline" id="line-973"><code>	}</code></span>
<span class="codeline" id="line-974"><code>	return &amp;SQLiteTx{c}, nil</code></span>
<span class="codeline" id="line-975"><code>}</code></span>
<span class="codeline" id="line-976"><code></code></span>
<span class="codeline" id="line-977"><code>// Open database and return a new connection.</code></span>
<span class="codeline" id="line-978"><code>//</code></span>
<span class="codeline" id="line-979"><code>// A pragma can take either zero or one argument.</code></span>
<span class="codeline" id="line-980"><code>// The argument is may be either in parentheses or it may be separated from</code></span>
<span class="codeline" id="line-981"><code>// the pragma name by an equal sign. The two syntaxes yield identical results.</code></span>
<span class="codeline" id="line-982"><code>// In many pragmas, the argument is a boolean. The boolean can be one of:</code></span>
<span class="codeline" id="line-983"><code>//</code></span>
<span class="codeline" id="line-984"><code>//	1 yes true on</code></span>
<span class="codeline" id="line-985"><code>//	0 no false off</code></span>
<span class="codeline" id="line-986"><code>//</code></span>
<span class="codeline" id="line-987"><code>// You can specify a DSN string using a URI as the filename.</code></span>
<span class="codeline" id="line-988"><code>//</code></span>
<span class="codeline" id="line-989"><code>//	test.db</code></span>
<span class="codeline" id="line-990"><code>//	file:test.db?cache=shared&amp;mode=memory</code></span>
<span class="codeline" id="line-991"><code>//	:memory:</code></span>
<span class="codeline" id="line-992"><code>//	file::memory:</code></span>
<span class="codeline" id="line-993"><code>//</code></span>
<span class="codeline" id="line-994"><code>//	mode</code></span>
<span class="codeline" id="line-995"><code>//	  Access mode of the database.</code></span>
<span class="codeline" id="line-996"><code>//	  https://www.sqlite.org/c3ref/open.html</code></span>
<span class="codeline" id="line-997"><code>//	  Values:</code></span>
<span class="codeline" id="line-998"><code>//	   - ro</code></span>
<span class="codeline" id="line-999"><code>//	   - rw</code></span>
<span class="codeline" id="line-1000"><code>//	   - rwc</code></span>
<span class="codeline" id="line-1001"><code>//	   - memory</code></span>
<span class="codeline" id="line-1002"><code>//</code></span>
<span class="codeline" id="line-1003"><code>//	cache</code></span>
<span class="codeline" id="line-1004"><code>//	  SQLite Shared-Cache Mode</code></span>
<span class="codeline" id="line-1005"><code>//	  https://www.sqlite.org/sharedcache.html</code></span>
<span class="codeline" id="line-1006"><code>//	  Values:</code></span>
<span class="codeline" id="line-1007"><code>//	    - shared</code></span>
<span class="codeline" id="line-1008"><code>//	    - private</code></span>
<span class="codeline" id="line-1009"><code>//</code></span>
<span class="codeline" id="line-1010"><code>//	immutable=Boolean</code></span>
<span class="codeline" id="line-1011"><code>//	  The immutable parameter is a boolean query parameter that indicates</code></span>
<span class="codeline" id="line-1012"><code>//	  that the database file is stored on read-only media. When immutable is set,</code></span>
<span class="codeline" id="line-1013"><code>//	  SQLite assumes that the database file cannot be changed,</code></span>
<span class="codeline" id="line-1014"><code>//	  even by a process with higher privilege,</code></span>
<span class="codeline" id="line-1015"><code>//	  and so the database is opened read-only and all locking and change detection is disabled.</code></span>
<span class="codeline" id="line-1016"><code>//	  Caution: Setting the immutable property on a database file that</code></span>
<span class="codeline" id="line-1017"><code>//	  does in fact change can result in incorrect query results and/or SQLITE_CORRUPT errors.</code></span>
<span class="codeline" id="line-1018"><code>//</code></span>
<span class="codeline" id="line-1019"><code>// go-sqlite3 adds the following query parameters to those used by SQLite:</code></span>
<span class="codeline" id="line-1020"><code>//</code></span>
<span class="codeline" id="line-1021"><code>//	_loc=XXX</code></span>
<span class="codeline" id="line-1022"><code>//	  Specify location of time format. It's possible to specify "auto".</code></span>
<span class="codeline" id="line-1023"><code>//</code></span>
<span class="codeline" id="line-1024"><code>//	_mutex=XXX</code></span>
<span class="codeline" id="line-1025"><code>//	  Specify mutex mode. XXX can be "no", "full".</code></span>
<span class="codeline" id="line-1026"><code>//</code></span>
<span class="codeline" id="line-1027"><code>//	_txlock=XXX</code></span>
<span class="codeline" id="line-1028"><code>//	  Specify locking behavior for transactions.  XXX can be "immediate",</code></span>
<span class="codeline" id="line-1029"><code>//	  "deferred", "exclusive".</code></span>
<span class="codeline" id="line-1030"><code>//</code></span>
<span class="codeline" id="line-1031"><code>//	_auto_vacuum=X | _vacuum=X</code></span>
<span class="codeline" id="line-1032"><code>//	  0 | none - Auto Vacuum disabled</code></span>
<span class="codeline" id="line-1033"><code>//	  1 | full - Auto Vacuum FULL</code></span>
<span class="codeline" id="line-1034"><code>//	  2 | incremental - Auto Vacuum Incremental</code></span>
<span class="codeline" id="line-1035"><code>//</code></span>
<span class="codeline" id="line-1036"><code>//	_busy_timeout=XXX"| _timeout=XXX</code></span>
<span class="codeline" id="line-1037"><code>//	  Specify value for sqlite3_busy_timeout.</code></span>
<span class="codeline" id="line-1038"><code>//</code></span>
<span class="codeline" id="line-1039"><code>//	_case_sensitive_like=Boolean | _cslike=Boolean</code></span>
<span class="codeline" id="line-1040"><code>//	  https://www.sqlite.org/pragma.html#pragma_case_sensitive_like</code></span>
<span class="codeline" id="line-1041"><code>//	  Default or disabled the LIKE operation is case-insensitive.</code></span>
<span class="codeline" id="line-1042"><code>//	  When enabling this options behaviour of LIKE will become case-sensitive.</code></span>
<span class="codeline" id="line-1043"><code>//</code></span>
<span class="codeline" id="line-1044"><code>//	_defer_foreign_keys=Boolean | _defer_fk=Boolean</code></span>
<span class="codeline" id="line-1045"><code>//	  Defer Foreign Keys until outermost transaction is committed.</code></span>
<span class="codeline" id="line-1046"><code>//</code></span>
<span class="codeline" id="line-1047"><code>//	_foreign_keys=Boolean | _fk=Boolean</code></span>
<span class="codeline" id="line-1048"><code>//	  Enable or disable enforcement of foreign keys.</code></span>
<span class="codeline" id="line-1049"><code>//</code></span>
<span class="codeline" id="line-1050"><code>//	_ignore_check_constraints=Boolean</code></span>
<span class="codeline" id="line-1051"><code>//	  This pragma enables or disables the enforcement of CHECK constraints.</code></span>
<span class="codeline" id="line-1052"><code>//	  The default setting is off, meaning that CHECK constraints are enforced by default.</code></span>
<span class="codeline" id="line-1053"><code>//</code></span>
<span class="codeline" id="line-1054"><code>//	_journal_mode=MODE | _journal=MODE</code></span>
<span class="codeline" id="line-1055"><code>//	  Set journal mode for the databases associated with the current connection.</code></span>
<span class="codeline" id="line-1056"><code>//	  https://www.sqlite.org/pragma.html#pragma_journal_mode</code></span>
<span class="codeline" id="line-1057"><code>//</code></span>
<span class="codeline" id="line-1058"><code>//	_locking_mode=X | _locking=X</code></span>
<span class="codeline" id="line-1059"><code>//	  Sets the database connection locking-mode.</code></span>
<span class="codeline" id="line-1060"><code>//	  The locking-mode is either NORMAL or EXCLUSIVE.</code></span>
<span class="codeline" id="line-1061"><code>//	  https://www.sqlite.org/pragma.html#pragma_locking_mode</code></span>
<span class="codeline" id="line-1062"><code>//</code></span>
<span class="codeline" id="line-1063"><code>//	_query_only=Boolean</code></span>
<span class="codeline" id="line-1064"><code>//	  The query_only pragma prevents all changes to database files when enabled.</code></span>
<span class="codeline" id="line-1065"><code>//</code></span>
<span class="codeline" id="line-1066"><code>//	_recursive_triggers=Boolean | _rt=Boolean</code></span>
<span class="codeline" id="line-1067"><code>//	  Enable or disable recursive triggers.</code></span>
<span class="codeline" id="line-1068"><code>//</code></span>
<span class="codeline" id="line-1069"><code>//	_secure_delete=Boolean|FAST</code></span>
<span class="codeline" id="line-1070"><code>//	  When secure_delete is on, SQLite overwrites deleted content with zeros.</code></span>
<span class="codeline" id="line-1071"><code>//	  https://www.sqlite.org/pragma.html#pragma_secure_delete</code></span>
<span class="codeline" id="line-1072"><code>//</code></span>
<span class="codeline" id="line-1073"><code>//	_synchronous=X | _sync=X</code></span>
<span class="codeline" id="line-1074"><code>//	  Change the setting of the "synchronous" flag.</code></span>
<span class="codeline" id="line-1075"><code>//	  https://www.sqlite.org/pragma.html#pragma_synchronous</code></span>
<span class="codeline" id="line-1076"><code>//</code></span>
<span class="codeline" id="line-1077"><code>//	_writable_schema=Boolean</code></span>
<span class="codeline" id="line-1078"><code>//	  When this pragma is on, the SQLITE_MASTER tables in which database</code></span>
<span class="codeline" id="line-1079"><code>//	  can be changed using ordinary UPDATE, INSERT, and DELETE statements.</code></span>
<span class="codeline" id="line-1080"><code>//	  Warning: misuse of this pragma can easily result in a corrupt database file.</code></span>
<span class="codeline" id="line-1081"><code>func (d *SQLiteDriver) Open(dsn string) (driver.Conn, error) {</code></span>
<span class="codeline" id="line-1082"><code>	if ( /*line :1079:5*/_Cfunc_sqlite3_threadsafe /*line :1079:24*/)() == 0 {</code></span>
<span class="codeline" id="line-1083"><code>		return nil, errors.New("sqlite library was not compiled for thread-safe operation")</code></span>
<span class="codeline" id="line-1084"><code>	}</code></span>
<span class="codeline" id="line-1085"><code></code></span>
<span class="codeline" id="line-1086"><code>	var pkey string</code></span>
<span class="codeline" id="line-1087"><code></code></span>
<span class="codeline" id="line-1088"><code>	// Options</code></span>
<span class="codeline" id="line-1089"><code>	var loc *time.Location</code></span>
<span class="codeline" id="line-1090"><code>	authCreate := false</code></span>
<span class="codeline" id="line-1091"><code>	authUser := ""</code></span>
<span class="codeline" id="line-1092"><code>	authPass := ""</code></span>
<span class="codeline" id="line-1093"><code>	authCrypt := ""</code></span>
<span class="codeline" id="line-1094"><code>	authSalt := ""</code></span>
<span class="codeline" id="line-1095"><code>	mutex :=  /*line :1092:11*/_Ctype_int /*line :1092:16*/(( /*line :1092:17*/_Ciconst_SQLITE_OPEN_FULLMUTEX /*line :1092:39*/))</code></span>
<span class="codeline" id="line-1096"><code>	txlock := "BEGIN"</code></span>
<span class="codeline" id="line-1097"><code></code></span>
<span class="codeline" id="line-1098"><code>	// PRAGMA's</code></span>
<span class="codeline" id="line-1099"><code>	autoVacuum := -1</code></span>
<span class="codeline" id="line-1100"><code>	busyTimeout := 5000</code></span>
<span class="codeline" id="line-1101"><code>	caseSensitiveLike := -1</code></span>
<span class="codeline" id="line-1102"><code>	deferForeignKeys := -1</code></span>
<span class="codeline" id="line-1103"><code>	foreignKeys := -1</code></span>
<span class="codeline" id="line-1104"><code>	ignoreCheckConstraints := -1</code></span>
<span class="codeline" id="line-1105"><code>	var journalMode string</code></span>
<span class="codeline" id="line-1106"><code>	lockingMode := "NORMAL"</code></span>
<span class="codeline" id="line-1107"><code>	queryOnly := -1</code></span>
<span class="codeline" id="line-1108"><code>	recursiveTriggers := -1</code></span>
<span class="codeline" id="line-1109"><code>	secureDelete := "DEFAULT"</code></span>
<span class="codeline" id="line-1110"><code>	synchronousMode := "NORMAL"</code></span>
<span class="codeline" id="line-1111"><code>	writableSchema := -1</code></span>
<span class="codeline" id="line-1112"><code>	vfsName := ""</code></span>
<span class="codeline" id="line-1113"><code>	var cacheSize *int64</code></span>
<span class="codeline" id="line-1114"><code></code></span>
<span class="codeline" id="line-1115"><code>	pos := strings.IndexRune(dsn, '?')</code></span>
<span class="codeline" id="line-1116"><code>	if pos &gt;= 1 {</code></span>
<span class="codeline" id="line-1117"><code>		params, err := url.ParseQuery(dsn[pos+1:])</code></span>
<span class="codeline" id="line-1118"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1119"><code>			return nil, err</code></span>
<span class="codeline" id="line-1120"><code>		}</code></span>
<span class="codeline" id="line-1121"><code></code></span>
<span class="codeline" id="line-1122"><code>		// Authentication</code></span>
<span class="codeline" id="line-1123"><code>		if _, ok := params["_auth"]; ok {</code></span>
<span class="codeline" id="line-1124"><code>			authCreate = true</code></span>
<span class="codeline" id="line-1125"><code>		}</code></span>
<span class="codeline" id="line-1126"><code>		if val := params.Get("_auth_user"); val != "" {</code></span>
<span class="codeline" id="line-1127"><code>			authUser = val</code></span>
<span class="codeline" id="line-1128"><code>		}</code></span>
<span class="codeline" id="line-1129"><code>		if val := params.Get("_auth_pass"); val != "" {</code></span>
<span class="codeline" id="line-1130"><code>			authPass = val</code></span>
<span class="codeline" id="line-1131"><code>		}</code></span>
<span class="codeline" id="line-1132"><code>		if val := params.Get("_auth_crypt"); val != "" {</code></span>
<span class="codeline" id="line-1133"><code>			authCrypt = val</code></span>
<span class="codeline" id="line-1134"><code>		}</code></span>
<span class="codeline" id="line-1135"><code>		if val := params.Get("_auth_salt"); val != "" {</code></span>
<span class="codeline" id="line-1136"><code>			authSalt = val</code></span>
<span class="codeline" id="line-1137"><code>		}</code></span>
<span class="codeline" id="line-1138"><code></code></span>
<span class="codeline" id="line-1139"><code>		// _loc</code></span>
<span class="codeline" id="line-1140"><code>		if val := params.Get("_loc"); val != "" {</code></span>
<span class="codeline" id="line-1141"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1142"><code>			case "auto":</code></span>
<span class="codeline" id="line-1143"><code>				loc = time.Local</code></span>
<span class="codeline" id="line-1144"><code>			default:</code></span>
<span class="codeline" id="line-1145"><code>				loc, err = time.LoadLocation(val)</code></span>
<span class="codeline" id="line-1146"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1147"><code>					return nil, fmt.Errorf("Invalid _loc: %v: %v", val, err)</code></span>
<span class="codeline" id="line-1148"><code>				}</code></span>
<span class="codeline" id="line-1149"><code>			}</code></span>
<span class="codeline" id="line-1150"><code>		}</code></span>
<span class="codeline" id="line-1151"><code></code></span>
<span class="codeline" id="line-1152"><code>		// _mutex</code></span>
<span class="codeline" id="line-1153"><code>		if val := params.Get("_mutex"); val != "" {</code></span>
<span class="codeline" id="line-1154"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1155"><code>			case "no":</code></span>
<span class="codeline" id="line-1156"><code>				mutex = ( /*line :1153:13*/_Ciconst_SQLITE_OPEN_NOMUTEX /*line :1153:33*/)</code></span>
<span class="codeline" id="line-1157"><code>			case "full":</code></span>
<span class="codeline" id="line-1158"><code>				mutex = ( /*line :1155:13*/_Ciconst_SQLITE_OPEN_FULLMUTEX /*line :1155:35*/)</code></span>
<span class="codeline" id="line-1159"><code>			default:</code></span>
<span class="codeline" id="line-1160"><code>				return nil, fmt.Errorf("Invalid _mutex: %v", val)</code></span>
<span class="codeline" id="line-1161"><code>			}</code></span>
<span class="codeline" id="line-1162"><code>		}</code></span>
<span class="codeline" id="line-1163"><code></code></span>
<span class="codeline" id="line-1164"><code>		// _txlock</code></span>
<span class="codeline" id="line-1165"><code>		if val := params.Get("_txlock"); val != "" {</code></span>
<span class="codeline" id="line-1166"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1167"><code>			case "immediate":</code></span>
<span class="codeline" id="line-1168"><code>				txlock = "BEGIN IMMEDIATE"</code></span>
<span class="codeline" id="line-1169"><code>			case "exclusive":</code></span>
<span class="codeline" id="line-1170"><code>				txlock = "BEGIN EXCLUSIVE"</code></span>
<span class="codeline" id="line-1171"><code>			case "deferred":</code></span>
<span class="codeline" id="line-1172"><code>				txlock = "BEGIN"</code></span>
<span class="codeline" id="line-1173"><code>			default:</code></span>
<span class="codeline" id="line-1174"><code>				return nil, fmt.Errorf("Invalid _txlock: %v", val)</code></span>
<span class="codeline" id="line-1175"><code>			}</code></span>
<span class="codeline" id="line-1176"><code>		}</code></span>
<span class="codeline" id="line-1177"><code></code></span>
<span class="codeline" id="line-1178"><code>		// Auto Vacuum (_vacuum)</code></span>
<span class="codeline" id="line-1179"><code>		//</code></span>
<span class="codeline" id="line-1180"><code>		// https://www.sqlite.org/pragma.html#pragma_auto_vacuum</code></span>
<span class="codeline" id="line-1181"><code>		//</code></span>
<span class="codeline" id="line-1182"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1183"><code>		if _, ok := params["_auto_vacuum"]; ok {</code></span>
<span class="codeline" id="line-1184"><code>			pkey = "_auto_vacuum"</code></span>
<span class="codeline" id="line-1185"><code>		}</code></span>
<span class="codeline" id="line-1186"><code>		if _, ok := params["_vacuum"]; ok {</code></span>
<span class="codeline" id="line-1187"><code>			pkey = "_vacuum"</code></span>
<span class="codeline" id="line-1188"><code>		}</code></span>
<span class="codeline" id="line-1189"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1190"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1191"><code>			case "0", "none":</code></span>
<span class="codeline" id="line-1192"><code>				autoVacuum = 0</code></span>
<span class="codeline" id="line-1193"><code>			case "1", "full":</code></span>
<span class="codeline" id="line-1194"><code>				autoVacuum = 1</code></span>
<span class="codeline" id="line-1195"><code>			case "2", "incremental":</code></span>
<span class="codeline" id="line-1196"><code>				autoVacuum = 2</code></span>
<span class="codeline" id="line-1197"><code>			default:</code></span>
<span class="codeline" id="line-1198"><code>				return nil, fmt.Errorf("Invalid _auto_vacuum: %v, expecting value of '0 NONE 1 FULL 2 INCREMENTAL'", val)</code></span>
<span class="codeline" id="line-1199"><code>			}</code></span>
<span class="codeline" id="line-1200"><code>		}</code></span>
<span class="codeline" id="line-1201"><code></code></span>
<span class="codeline" id="line-1202"><code>		// Busy Timeout (_busy_timeout)</code></span>
<span class="codeline" id="line-1203"><code>		//</code></span>
<span class="codeline" id="line-1204"><code>		// https://www.sqlite.org/pragma.html#pragma_busy_timeout</code></span>
<span class="codeline" id="line-1205"><code>		//</code></span>
<span class="codeline" id="line-1206"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1207"><code>		if _, ok := params["_busy_timeout"]; ok {</code></span>
<span class="codeline" id="line-1208"><code>			pkey = "_busy_timeout"</code></span>
<span class="codeline" id="line-1209"><code>		}</code></span>
<span class="codeline" id="line-1210"><code>		if _, ok := params["_timeout"]; ok {</code></span>
<span class="codeline" id="line-1211"><code>			pkey = "_timeout"</code></span>
<span class="codeline" id="line-1212"><code>		}</code></span>
<span class="codeline" id="line-1213"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1214"><code>			iv, err := strconv.ParseInt(val, 10, 64)</code></span>
<span class="codeline" id="line-1215"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1216"><code>				return nil, fmt.Errorf("Invalid _busy_timeout: %v: %v", val, err)</code></span>
<span class="codeline" id="line-1217"><code>			}</code></span>
<span class="codeline" id="line-1218"><code>			busyTimeout = int(iv)</code></span>
<span class="codeline" id="line-1219"><code>		}</code></span>
<span class="codeline" id="line-1220"><code></code></span>
<span class="codeline" id="line-1221"><code>		// Case Sensitive Like (_cslike)</code></span>
<span class="codeline" id="line-1222"><code>		//</code></span>
<span class="codeline" id="line-1223"><code>		// https://www.sqlite.org/pragma.html#pragma_case_sensitive_like</code></span>
<span class="codeline" id="line-1224"><code>		//</code></span>
<span class="codeline" id="line-1225"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1226"><code>		if _, ok := params["_case_sensitive_like"]; ok {</code></span>
<span class="codeline" id="line-1227"><code>			pkey = "_case_sensitive_like"</code></span>
<span class="codeline" id="line-1228"><code>		}</code></span>
<span class="codeline" id="line-1229"><code>		if _, ok := params["_cslike"]; ok {</code></span>
<span class="codeline" id="line-1230"><code>			pkey = "_cslike"</code></span>
<span class="codeline" id="line-1231"><code>		}</code></span>
<span class="codeline" id="line-1232"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1233"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1234"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1235"><code>				caseSensitiveLike = 0</code></span>
<span class="codeline" id="line-1236"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1237"><code>				caseSensitiveLike = 1</code></span>
<span class="codeline" id="line-1238"><code>			default:</code></span>
<span class="codeline" id="line-1239"><code>				return nil, fmt.Errorf("Invalid _case_sensitive_like: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1240"><code>			}</code></span>
<span class="codeline" id="line-1241"><code>		}</code></span>
<span class="codeline" id="line-1242"><code></code></span>
<span class="codeline" id="line-1243"><code>		// Defer Foreign Keys (_defer_foreign_keys | _defer_fk)</code></span>
<span class="codeline" id="line-1244"><code>		//</code></span>
<span class="codeline" id="line-1245"><code>		// https://www.sqlite.org/pragma.html#pragma_defer_foreign_keys</code></span>
<span class="codeline" id="line-1246"><code>		//</code></span>
<span class="codeline" id="line-1247"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1248"><code>		if _, ok := params["_defer_foreign_keys"]; ok {</code></span>
<span class="codeline" id="line-1249"><code>			pkey = "_defer_foreign_keys"</code></span>
<span class="codeline" id="line-1250"><code>		}</code></span>
<span class="codeline" id="line-1251"><code>		if _, ok := params["_defer_fk"]; ok {</code></span>
<span class="codeline" id="line-1252"><code>			pkey = "_defer_fk"</code></span>
<span class="codeline" id="line-1253"><code>		}</code></span>
<span class="codeline" id="line-1254"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1255"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1256"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1257"><code>				deferForeignKeys = 0</code></span>
<span class="codeline" id="line-1258"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1259"><code>				deferForeignKeys = 1</code></span>
<span class="codeline" id="line-1260"><code>			default:</code></span>
<span class="codeline" id="line-1261"><code>				return nil, fmt.Errorf("Invalid _defer_foreign_keys: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1262"><code>			}</code></span>
<span class="codeline" id="line-1263"><code>		}</code></span>
<span class="codeline" id="line-1264"><code></code></span>
<span class="codeline" id="line-1265"><code>		// Foreign Keys (_foreign_keys | _fk)</code></span>
<span class="codeline" id="line-1266"><code>		//</code></span>
<span class="codeline" id="line-1267"><code>		// https://www.sqlite.org/pragma.html#pragma_foreign_keys</code></span>
<span class="codeline" id="line-1268"><code>		//</code></span>
<span class="codeline" id="line-1269"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1270"><code>		if _, ok := params["_foreign_keys"]; ok {</code></span>
<span class="codeline" id="line-1271"><code>			pkey = "_foreign_keys"</code></span>
<span class="codeline" id="line-1272"><code>		}</code></span>
<span class="codeline" id="line-1273"><code>		if _, ok := params["_fk"]; ok {</code></span>
<span class="codeline" id="line-1274"><code>			pkey = "_fk"</code></span>
<span class="codeline" id="line-1275"><code>		}</code></span>
<span class="codeline" id="line-1276"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1277"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1278"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1279"><code>				foreignKeys = 0</code></span>
<span class="codeline" id="line-1280"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1281"><code>				foreignKeys = 1</code></span>
<span class="codeline" id="line-1282"><code>			default:</code></span>
<span class="codeline" id="line-1283"><code>				return nil, fmt.Errorf("Invalid _foreign_keys: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1284"><code>			}</code></span>
<span class="codeline" id="line-1285"><code>		}</code></span>
<span class="codeline" id="line-1286"><code></code></span>
<span class="codeline" id="line-1287"><code>		// Ignore CHECK Constrains (_ignore_check_constraints)</code></span>
<span class="codeline" id="line-1288"><code>		//</code></span>
<span class="codeline" id="line-1289"><code>		// https://www.sqlite.org/pragma.html#pragma_ignore_check_constraints</code></span>
<span class="codeline" id="line-1290"><code>		//</code></span>
<span class="codeline" id="line-1291"><code>		if val := params.Get("_ignore_check_constraints"); val != "" {</code></span>
<span class="codeline" id="line-1292"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1293"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1294"><code>				ignoreCheckConstraints = 0</code></span>
<span class="codeline" id="line-1295"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1296"><code>				ignoreCheckConstraints = 1</code></span>
<span class="codeline" id="line-1297"><code>			default:</code></span>
<span class="codeline" id="line-1298"><code>				return nil, fmt.Errorf("Invalid _ignore_check_constraints: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1299"><code>			}</code></span>
<span class="codeline" id="line-1300"><code>		}</code></span>
<span class="codeline" id="line-1301"><code></code></span>
<span class="codeline" id="line-1302"><code>		// Journal Mode (_journal_mode | _journal)</code></span>
<span class="codeline" id="line-1303"><code>		//</code></span>
<span class="codeline" id="line-1304"><code>		// https://www.sqlite.org/pragma.html#pragma_journal_mode</code></span>
<span class="codeline" id="line-1305"><code>		//</code></span>
<span class="codeline" id="line-1306"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1307"><code>		if _, ok := params["_journal_mode"]; ok {</code></span>
<span class="codeline" id="line-1308"><code>			pkey = "_journal_mode"</code></span>
<span class="codeline" id="line-1309"><code>		}</code></span>
<span class="codeline" id="line-1310"><code>		if _, ok := params["_journal"]; ok {</code></span>
<span class="codeline" id="line-1311"><code>			pkey = "_journal"</code></span>
<span class="codeline" id="line-1312"><code>		}</code></span>
<span class="codeline" id="line-1313"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1314"><code>			switch strings.ToUpper(val) {</code></span>
<span class="codeline" id="line-1315"><code>			case "DELETE", "TRUNCATE", "PERSIST", "MEMORY", "OFF":</code></span>
<span class="codeline" id="line-1316"><code>				journalMode = strings.ToUpper(val)</code></span>
<span class="codeline" id="line-1317"><code>			case "WAL":</code></span>
<span class="codeline" id="line-1318"><code>				journalMode = strings.ToUpper(val)</code></span>
<span class="codeline" id="line-1319"><code></code></span>
<span class="codeline" id="line-1320"><code>				// For WAL Mode set Synchronous Mode to 'NORMAL'</code></span>
<span class="codeline" id="line-1321"><code>				// See https://www.sqlite.org/pragma.html#pragma_synchronous</code></span>
<span class="codeline" id="line-1322"><code>				synchronousMode = "NORMAL"</code></span>
<span class="codeline" id="line-1323"><code>			default:</code></span>
<span class="codeline" id="line-1324"><code>				return nil, fmt.Errorf("Invalid _journal: %v, expecting value of 'DELETE TRUNCATE PERSIST MEMORY WAL OFF'", val)</code></span>
<span class="codeline" id="line-1325"><code>			}</code></span>
<span class="codeline" id="line-1326"><code>		}</code></span>
<span class="codeline" id="line-1327"><code></code></span>
<span class="codeline" id="line-1328"><code>		// Locking Mode (_locking)</code></span>
<span class="codeline" id="line-1329"><code>		//</code></span>
<span class="codeline" id="line-1330"><code>		// https://www.sqlite.org/pragma.html#pragma_locking_mode</code></span>
<span class="codeline" id="line-1331"><code>		//</code></span>
<span class="codeline" id="line-1332"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1333"><code>		if _, ok := params["_locking_mode"]; ok {</code></span>
<span class="codeline" id="line-1334"><code>			pkey = "_locking_mode"</code></span>
<span class="codeline" id="line-1335"><code>		}</code></span>
<span class="codeline" id="line-1336"><code>		if _, ok := params["_locking"]; ok {</code></span>
<span class="codeline" id="line-1337"><code>			pkey = "_locking"</code></span>
<span class="codeline" id="line-1338"><code>		}</code></span>
<span class="codeline" id="line-1339"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1340"><code>			switch strings.ToUpper(val) {</code></span>
<span class="codeline" id="line-1341"><code>			case "NORMAL", "EXCLUSIVE":</code></span>
<span class="codeline" id="line-1342"><code>				lockingMode = strings.ToUpper(val)</code></span>
<span class="codeline" id="line-1343"><code>			default:</code></span>
<span class="codeline" id="line-1344"><code>				return nil, fmt.Errorf("Invalid _locking_mode: %v, expecting value of 'NORMAL EXCLUSIVE", val)</code></span>
<span class="codeline" id="line-1345"><code>			}</code></span>
<span class="codeline" id="line-1346"><code>		}</code></span>
<span class="codeline" id="line-1347"><code></code></span>
<span class="codeline" id="line-1348"><code>		// Query Only (_query_only)</code></span>
<span class="codeline" id="line-1349"><code>		//</code></span>
<span class="codeline" id="line-1350"><code>		// https://www.sqlite.org/pragma.html#pragma_query_only</code></span>
<span class="codeline" id="line-1351"><code>		//</code></span>
<span class="codeline" id="line-1352"><code>		if val := params.Get("_query_only"); val != "" {</code></span>
<span class="codeline" id="line-1353"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1354"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1355"><code>				queryOnly = 0</code></span>
<span class="codeline" id="line-1356"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1357"><code>				queryOnly = 1</code></span>
<span class="codeline" id="line-1358"><code>			default:</code></span>
<span class="codeline" id="line-1359"><code>				return nil, fmt.Errorf("Invalid _query_only: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1360"><code>			}</code></span>
<span class="codeline" id="line-1361"><code>		}</code></span>
<span class="codeline" id="line-1362"><code></code></span>
<span class="codeline" id="line-1363"><code>		// Recursive Triggers (_recursive_triggers)</code></span>
<span class="codeline" id="line-1364"><code>		//</code></span>
<span class="codeline" id="line-1365"><code>		// https://www.sqlite.org/pragma.html#pragma_recursive_triggers</code></span>
<span class="codeline" id="line-1366"><code>		//</code></span>
<span class="codeline" id="line-1367"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1368"><code>		if _, ok := params["_recursive_triggers"]; ok {</code></span>
<span class="codeline" id="line-1369"><code>			pkey = "_recursive_triggers"</code></span>
<span class="codeline" id="line-1370"><code>		}</code></span>
<span class="codeline" id="line-1371"><code>		if _, ok := params["_rt"]; ok {</code></span>
<span class="codeline" id="line-1372"><code>			pkey = "_rt"</code></span>
<span class="codeline" id="line-1373"><code>		}</code></span>
<span class="codeline" id="line-1374"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1375"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1376"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1377"><code>				recursiveTriggers = 0</code></span>
<span class="codeline" id="line-1378"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1379"><code>				recursiveTriggers = 1</code></span>
<span class="codeline" id="line-1380"><code>			default:</code></span>
<span class="codeline" id="line-1381"><code>				return nil, fmt.Errorf("Invalid _recursive_triggers: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1382"><code>			}</code></span>
<span class="codeline" id="line-1383"><code>		}</code></span>
<span class="codeline" id="line-1384"><code></code></span>
<span class="codeline" id="line-1385"><code>		// Secure Delete (_secure_delete)</code></span>
<span class="codeline" id="line-1386"><code>		//</code></span>
<span class="codeline" id="line-1387"><code>		// https://www.sqlite.org/pragma.html#pragma_secure_delete</code></span>
<span class="codeline" id="line-1388"><code>		//</code></span>
<span class="codeline" id="line-1389"><code>		if val := params.Get("_secure_delete"); val != "" {</code></span>
<span class="codeline" id="line-1390"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1391"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1392"><code>				secureDelete = "OFF"</code></span>
<span class="codeline" id="line-1393"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1394"><code>				secureDelete = "ON"</code></span>
<span class="codeline" id="line-1395"><code>			case "fast":</code></span>
<span class="codeline" id="line-1396"><code>				secureDelete = "FAST"</code></span>
<span class="codeline" id="line-1397"><code>			default:</code></span>
<span class="codeline" id="line-1398"><code>				return nil, fmt.Errorf("Invalid _secure_delete: %v, expecting boolean value of '0 1 false true no yes off on fast'", val)</code></span>
<span class="codeline" id="line-1399"><code>			}</code></span>
<span class="codeline" id="line-1400"><code>		}</code></span>
<span class="codeline" id="line-1401"><code></code></span>
<span class="codeline" id="line-1402"><code>		// Synchronous Mode (_synchronous | _sync)</code></span>
<span class="codeline" id="line-1403"><code>		//</code></span>
<span class="codeline" id="line-1404"><code>		// https://www.sqlite.org/pragma.html#pragma_synchronous</code></span>
<span class="codeline" id="line-1405"><code>		//</code></span>
<span class="codeline" id="line-1406"><code>		pkey = "" // Reset pkey</code></span>
<span class="codeline" id="line-1407"><code>		if _, ok := params["_synchronous"]; ok {</code></span>
<span class="codeline" id="line-1408"><code>			pkey = "_synchronous"</code></span>
<span class="codeline" id="line-1409"><code>		}</code></span>
<span class="codeline" id="line-1410"><code>		if _, ok := params["_sync"]; ok {</code></span>
<span class="codeline" id="line-1411"><code>			pkey = "_sync"</code></span>
<span class="codeline" id="line-1412"><code>		}</code></span>
<span class="codeline" id="line-1413"><code>		if val := params.Get(pkey); val != "" {</code></span>
<span class="codeline" id="line-1414"><code>			switch strings.ToUpper(val) {</code></span>
<span class="codeline" id="line-1415"><code>			case "0", "OFF", "1", "NORMAL", "2", "FULL", "3", "EXTRA":</code></span>
<span class="codeline" id="line-1416"><code>				synchronousMode = strings.ToUpper(val)</code></span>
<span class="codeline" id="line-1417"><code>			default:</code></span>
<span class="codeline" id="line-1418"><code>				return nil, fmt.Errorf("Invalid _synchronous: %v, expecting value of '0 OFF 1 NORMAL 2 FULL 3 EXTRA'", val)</code></span>
<span class="codeline" id="line-1419"><code>			}</code></span>
<span class="codeline" id="line-1420"><code>		}</code></span>
<span class="codeline" id="line-1421"><code></code></span>
<span class="codeline" id="line-1422"><code>		// Writable Schema (_writeable_schema)</code></span>
<span class="codeline" id="line-1423"><code>		//</code></span>
<span class="codeline" id="line-1424"><code>		// https://www.sqlite.org/pragma.html#pragma_writeable_schema</code></span>
<span class="codeline" id="line-1425"><code>		//</code></span>
<span class="codeline" id="line-1426"><code>		if val := params.Get("_writable_schema"); val != "" {</code></span>
<span class="codeline" id="line-1427"><code>			switch strings.ToLower(val) {</code></span>
<span class="codeline" id="line-1428"><code>			case "0", "no", "false", "off":</code></span>
<span class="codeline" id="line-1429"><code>				writableSchema = 0</code></span>
<span class="codeline" id="line-1430"><code>			case "1", "yes", "true", "on":</code></span>
<span class="codeline" id="line-1431"><code>				writableSchema = 1</code></span>
<span class="codeline" id="line-1432"><code>			default:</code></span>
<span class="codeline" id="line-1433"><code>				return nil, fmt.Errorf("Invalid _writable_schema: %v, expecting boolean value of '0 1 false true no yes off on'", val)</code></span>
<span class="codeline" id="line-1434"><code>			}</code></span>
<span class="codeline" id="line-1435"><code>		}</code></span>
<span class="codeline" id="line-1436"><code></code></span>
<span class="codeline" id="line-1437"><code>		// Cache size (_cache_size)</code></span>
<span class="codeline" id="line-1438"><code>		//</code></span>
<span class="codeline" id="line-1439"><code>		// https://sqlite.org/pragma.html#pragma_cache_size</code></span>
<span class="codeline" id="line-1440"><code>		//</code></span>
<span class="codeline" id="line-1441"><code>		if val := params.Get("_cache_size"); val != "" {</code></span>
<span class="codeline" id="line-1442"><code>			iv, err := strconv.ParseInt(val, 10, 64)</code></span>
<span class="codeline" id="line-1443"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1444"><code>				return nil, fmt.Errorf("Invalid _cache_size: %v: %v", val, err)</code></span>
<span class="codeline" id="line-1445"><code>			}</code></span>
<span class="codeline" id="line-1446"><code>			cacheSize = &amp;iv</code></span>
<span class="codeline" id="line-1447"><code>		}</code></span>
<span class="codeline" id="line-1448"><code></code></span>
<span class="codeline" id="line-1449"><code>		if val := params.Get("vfs"); val != "" {</code></span>
<span class="codeline" id="line-1450"><code>			vfsName = val</code></span>
<span class="codeline" id="line-1451"><code>		}</code></span>
<span class="codeline" id="line-1452"><code></code></span>
<span class="codeline" id="line-1453"><code>		if !strings.HasPrefix(dsn, "file:") {</code></span>
<span class="codeline" id="line-1454"><code>			dsn = dsn[:pos]</code></span>
<span class="codeline" id="line-1455"><code>		}</code></span>
<span class="codeline" id="line-1456"><code>	}</code></span>
<span class="codeline" id="line-1457"><code></code></span>
<span class="codeline" id="line-1458"><code>	var db * /*line :1455:10*/_Ctype_sqlite3 /*line :1455:19*/</code></span>
<span class="codeline" id="line-1459"><code>	name := ( /*line :1456:10*/_Cfunc_CString /*line :1456:18*/)(dsn)</code></span>
<span class="codeline" id="line-1460"><code>	defer func() func() { _cgo0 := /*line :1457:15*/unsafe.Pointer(name); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1457:36*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-1461"><code>	var vfs * /*line :1458:11*/_Ctype_char /*line :1458:17*/</code></span>
<span class="codeline" id="line-1462"><code>	if vfsName != "" {</code></span>
<span class="codeline" id="line-1463"><code>		vfs = ( /*line :1460:9*/_Cfunc_CString /*line :1460:17*/)(vfsName)</code></span>
<span class="codeline" id="line-1464"><code>		defer func() func() { _cgo0 := /*line :1461:16*/unsafe.Pointer(vfs); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1461:36*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-1465"><code>	}</code></span>
<span class="codeline" id="line-1466"><code>	rv := func() _Ctype_int{ var _cgo0 *_Ctype_char = /*line :1463:27*/name; _cgoBase1 := /*line :1463:33*/&amp;db; _cgo1 := _cgoBase1; var _cgo2 _Ctype_int = /*line :1464:3*/mutex | _Ciconst_SQLITE_OPEN_READWRITE /*line :1464:32*/ | _Ciconst_SQLITE_OPEN_CREATE /*line :1464:53*/; var _cgo3 *_Ctype_char = /*line :1465:3*/vfs; _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :1465:7*/_Cfunc__sqlite3_open_v2(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1467"><code>	if rv != 0 {</code></span>
<span class="codeline" id="line-1468"><code>		// Save off the error _before_ closing the database.</code></span>
<span class="codeline" id="line-1469"><code>		// This is safe even if db is nil.</code></span>
<span class="codeline" id="line-1470"><code>		err := lastError(db)</code></span>
<span class="codeline" id="line-1471"><code>		if db != nil {</code></span>
<span class="codeline" id="line-1472"><code>			func() _Ctype_int{ _cgo0 := /*line :1471:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1471:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1473"><code>		}</code></span>
<span class="codeline" id="line-1474"><code>		return nil, err</code></span>
<span class="codeline" id="line-1475"><code>	}</code></span>
<span class="codeline" id="line-1476"><code>	if db == nil {</code></span>
<span class="codeline" id="line-1477"><code>		return nil, errors.New("sqlite succeeded without returning a database")</code></span>
<span class="codeline" id="line-1478"><code>	}</code></span>
<span class="codeline" id="line-1479"><code></code></span>
<span class="codeline" id="line-1480"><code>	exec := func(s string) error {</code></span>
<span class="codeline" id="line-1481"><code>		cs := ( /*line :1480:9*/_Cfunc_CString /*line :1480:17*/)(s)</code></span>
<span class="codeline" id="line-1482"><code>		rv := func() _Ctype_int{ _cgo0 := /*line :1481:24*/db; var _cgo1 *_Ctype_char = /*line :1481:28*/cs; var _cgo2 *[0]byte = /*line :1481:32*/nil; var _cgo3 _cgo_unsafe.Pointer = /*line :1481:37*/nil; var _cgo4 **_Ctype_char = /*line :1481:42*/nil; _cgoCheckPointer(_cgo0, nil); return /*line :1481:46*/_Cfunc_sqlite3_exec(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()</code></span>
<span class="codeline" id="line-1483"><code>		func() { _cgo0 := /*line :1482:10*/unsafe.Pointer(cs); _cgoCheckPointer(_cgo0, nil); /*line :1482:29*/_Cfunc_free(_cgo0); }()</code></span>
<span class="codeline" id="line-1484"><code>		if rv != ( /*line :1483:12*/_Ciconst_SQLITE_OK /*line :1483:22*/) {</code></span>
<span class="codeline" id="line-1485"><code>			return lastError(db)</code></span>
<span class="codeline" id="line-1486"><code>		}</code></span>
<span class="codeline" id="line-1487"><code>		return nil</code></span>
<span class="codeline" id="line-1488"><code>	}</code></span>
<span class="codeline" id="line-1489"><code></code></span>
<span class="codeline" id="line-1490"><code>	// Busy timeout</code></span>
<span class="codeline" id="line-1491"><code>	if err := exec(fmt.Sprintf("PRAGMA busy_timeout = %d;", busyTimeout)); err != nil {</code></span>
<span class="codeline" id="line-1492"><code>		func() _Ctype_int{ _cgo0 := /*line :1491:22*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1491:25*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1493"><code>		return nil, err</code></span>
<span class="codeline" id="line-1494"><code>	}</code></span>
<span class="codeline" id="line-1495"><code></code></span>
<span class="codeline" id="line-1496"><code>	// USER AUTHENTICATION</code></span>
<span class="codeline" id="line-1497"><code>	//</code></span>
<span class="codeline" id="line-1498"><code>	// User Authentication is always performed even when</code></span>
<span class="codeline" id="line-1499"><code>	// sqlite_userauth is not compiled in, because without user authentication</code></span>
<span class="codeline" id="line-1500"><code>	// the authentication is a no-op.</code></span>
<span class="codeline" id="line-1501"><code>	//</code></span>
<span class="codeline" id="line-1502"><code>	// Workflow</code></span>
<span class="codeline" id="line-1503"><code>	//	- Authenticate</code></span>
<span class="codeline" id="line-1504"><code>	//		ON::SUCCESS		=&gt; Continue</code></span>
<span class="codeline" id="line-1505"><code>	//		ON::SQLITE_AUTH =&gt; Return error and exit Open(...)</code></span>
<span class="codeline" id="line-1506"><code>	//</code></span>
<span class="codeline" id="line-1507"><code>	//  - Activate User Authentication</code></span>
<span class="codeline" id="line-1508"><code>	//		Check if the user wants to activate User Authentication.</code></span>
<span class="codeline" id="line-1509"><code>	//		If so then first create a temporary AuthConn to the database</code></span>
<span class="codeline" id="line-1510"><code>	//		This is possible because we are already successfully authenticated.</code></span>
<span class="codeline" id="line-1511"><code>	//</code></span>
<span class="codeline" id="line-1512"><code>	//	- Check if `sqlite_user`` table exists</code></span>
<span class="codeline" id="line-1513"><code>	//		YES				=&gt; Add the provided user from DSN as Admin User and</code></span>
<span class="codeline" id="line-1514"><code>	//						   activate user authentication.</code></span>
<span class="codeline" id="line-1515"><code>	//		NO				=&gt; Continue</code></span>
<span class="codeline" id="line-1516"><code>	//</code></span>
<span class="codeline" id="line-1517"><code></code></span>
<span class="codeline" id="line-1518"><code>	// Create connection to SQLite</code></span>
<span class="codeline" id="line-1519"><code>	conn := &amp;SQLiteConn{db: db, loc: loc, txlock: txlock}</code></span>
<span class="codeline" id="line-1520"><code></code></span>
<span class="codeline" id="line-1521"><code>	// Password Cipher has to be registered before authentication</code></span>
<span class="codeline" id="line-1522"><code>	if len(authCrypt) &gt; 0 {</code></span>
<span class="codeline" id="line-1523"><code>		switch strings.ToUpper(authCrypt) {</code></span>
<span class="codeline" id="line-1524"><code>		case "SHA1":</code></span>
<span class="codeline" id="line-1525"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSHA1, true); err != nil {</code></span>
<span class="codeline" id="line-1526"><code>				return nil, fmt.Errorf("CryptEncoderSHA1: %s", err)</code></span>
<span class="codeline" id="line-1527"><code>			}</code></span>
<span class="codeline" id="line-1528"><code>		case "SSHA1":</code></span>
<span class="codeline" id="line-1529"><code>			if len(authSalt) == 0 {</code></span>
<span class="codeline" id="line-1530"><code>				return nil, fmt.Errorf("_auth_crypt=ssha1, requires _auth_salt")</code></span>
<span class="codeline" id="line-1531"><code>			}</code></span>
<span class="codeline" id="line-1532"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSSHA1(authSalt), true); err != nil {</code></span>
<span class="codeline" id="line-1533"><code>				return nil, fmt.Errorf("CryptEncoderSSHA1: %s", err)</code></span>
<span class="codeline" id="line-1534"><code>			}</code></span>
<span class="codeline" id="line-1535"><code>		case "SHA256":</code></span>
<span class="codeline" id="line-1536"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSHA256, true); err != nil {</code></span>
<span class="codeline" id="line-1537"><code>				return nil, fmt.Errorf("CryptEncoderSHA256: %s", err)</code></span>
<span class="codeline" id="line-1538"><code>			}</code></span>
<span class="codeline" id="line-1539"><code>		case "SSHA256":</code></span>
<span class="codeline" id="line-1540"><code>			if len(authSalt) == 0 {</code></span>
<span class="codeline" id="line-1541"><code>				return nil, fmt.Errorf("_auth_crypt=ssha256, requires _auth_salt")</code></span>
<span class="codeline" id="line-1542"><code>			}</code></span>
<span class="codeline" id="line-1543"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSSHA256(authSalt), true); err != nil {</code></span>
<span class="codeline" id="line-1544"><code>				return nil, fmt.Errorf("CryptEncoderSSHA256: %s", err)</code></span>
<span class="codeline" id="line-1545"><code>			}</code></span>
<span class="codeline" id="line-1546"><code>		case "SHA384":</code></span>
<span class="codeline" id="line-1547"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSHA384, true); err != nil {</code></span>
<span class="codeline" id="line-1548"><code>				return nil, fmt.Errorf("CryptEncoderSHA384: %s", err)</code></span>
<span class="codeline" id="line-1549"><code>			}</code></span>
<span class="codeline" id="line-1550"><code>		case "SSHA384":</code></span>
<span class="codeline" id="line-1551"><code>			if len(authSalt) == 0 {</code></span>
<span class="codeline" id="line-1552"><code>				return nil, fmt.Errorf("_auth_crypt=ssha384, requires _auth_salt")</code></span>
<span class="codeline" id="line-1553"><code>			}</code></span>
<span class="codeline" id="line-1554"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSSHA384(authSalt), true); err != nil {</code></span>
<span class="codeline" id="line-1555"><code>				return nil, fmt.Errorf("CryptEncoderSSHA384: %s", err)</code></span>
<span class="codeline" id="line-1556"><code>			}</code></span>
<span class="codeline" id="line-1557"><code>		case "SHA512":</code></span>
<span class="codeline" id="line-1558"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSHA512, true); err != nil {</code></span>
<span class="codeline" id="line-1559"><code>				return nil, fmt.Errorf("CryptEncoderSHA512: %s", err)</code></span>
<span class="codeline" id="line-1560"><code>			}</code></span>
<span class="codeline" id="line-1561"><code>		case "SSHA512":</code></span>
<span class="codeline" id="line-1562"><code>			if len(authSalt) == 0 {</code></span>
<span class="codeline" id="line-1563"><code>				return nil, fmt.Errorf("_auth_crypt=ssha512, requires _auth_salt")</code></span>
<span class="codeline" id="line-1564"><code>			}</code></span>
<span class="codeline" id="line-1565"><code>			if err := conn.RegisterFunc("sqlite_crypt", CryptEncoderSSHA512(authSalt), true); err != nil {</code></span>
<span class="codeline" id="line-1566"><code>				return nil, fmt.Errorf("CryptEncoderSSHA512: %s", err)</code></span>
<span class="codeline" id="line-1567"><code>			}</code></span>
<span class="codeline" id="line-1568"><code>		}</code></span>
<span class="codeline" id="line-1569"><code>	}</code></span>
<span class="codeline" id="line-1570"><code></code></span>
<span class="codeline" id="line-1571"><code>	// Preform Authentication</code></span>
<span class="codeline" id="line-1572"><code>	if err := conn.Authenticate(authUser, authPass); err != nil {</code></span>
<span class="codeline" id="line-1573"><code>		return nil, err</code></span>
<span class="codeline" id="line-1574"><code>	}</code></span>
<span class="codeline" id="line-1575"><code></code></span>
<span class="codeline" id="line-1576"><code>	// Register: authenticate</code></span>
<span class="codeline" id="line-1577"><code>	// Authenticate will perform an authentication of the provided username</code></span>
<span class="codeline" id="line-1578"><code>	// and password against the database.</code></span>
<span class="codeline" id="line-1579"><code>	//</code></span>
<span class="codeline" id="line-1580"><code>	// If a database contains the SQLITE_USER table, then the</code></span>
<span class="codeline" id="line-1581"><code>	// call to Authenticate must be invoked with an</code></span>
<span class="codeline" id="line-1582"><code>	// appropriate username and password prior to enable read and write</code></span>
<span class="codeline" id="line-1583"><code>	//access to the database.</code></span>
<span class="codeline" id="line-1584"><code>	//</code></span>
<span class="codeline" id="line-1585"><code>	// Return SQLITE_OK on success or SQLITE_ERROR if the username/password</code></span>
<span class="codeline" id="line-1586"><code>	// combination is incorrect or unknown.</code></span>
<span class="codeline" id="line-1587"><code>	//</code></span>
<span class="codeline" id="line-1588"><code>	// If the SQLITE_USER table is not present in the database file, then</code></span>
<span class="codeline" id="line-1589"><code>	// this interface is a harmless no-op returnning SQLITE_OK.</code></span>
<span class="codeline" id="line-1590"><code>	if err := conn.RegisterFunc("authenticate", conn.authenticate, true); err != nil {</code></span>
<span class="codeline" id="line-1591"><code>		return nil, err</code></span>
<span class="codeline" id="line-1592"><code>	}</code></span>
<span class="codeline" id="line-1593"><code>	//</code></span>
<span class="codeline" id="line-1594"><code>	// Register: auth_user_add</code></span>
<span class="codeline" id="line-1595"><code>	// auth_user_add can be used (by an admin user only)</code></span>
<span class="codeline" id="line-1596"><code>	// to create a new user. When called on a no-authentication-required</code></span>
<span class="codeline" id="line-1597"><code>	// database, this routine converts the database into an authentication-</code></span>
<span class="codeline" id="line-1598"><code>	// required database, automatically makes the added user an</code></span>
<span class="codeline" id="line-1599"><code>	// administrator, and logs in the current connection as that user.</code></span>
<span class="codeline" id="line-1600"><code>	// The AuthUserAdd only works for the "main" database, not</code></span>
<span class="codeline" id="line-1601"><code>	// for any ATTACH-ed databases. Any call to AuthUserAdd by a</code></span>
<span class="codeline" id="line-1602"><code>	// non-admin user results in an error.</code></span>
<span class="codeline" id="line-1603"><code>	if err := conn.RegisterFunc("auth_user_add", conn.authUserAdd, true); err != nil {</code></span>
<span class="codeline" id="line-1604"><code>		return nil, err</code></span>
<span class="codeline" id="line-1605"><code>	}</code></span>
<span class="codeline" id="line-1606"><code>	//</code></span>
<span class="codeline" id="line-1607"><code>	// Register: auth_user_change</code></span>
<span class="codeline" id="line-1608"><code>	// auth_user_change can be used to change a users</code></span>
<span class="codeline" id="line-1609"><code>	// login credentials or admin privilege.  Any user can change their own</code></span>
<span class="codeline" id="line-1610"><code>	// login credentials. Only an admin user can change another users login</code></span>
<span class="codeline" id="line-1611"><code>	// credentials or admin privilege setting. No user may change their own</code></span>
<span class="codeline" id="line-1612"><code>	// admin privilege setting.</code></span>
<span class="codeline" id="line-1613"><code>	if err := conn.RegisterFunc("auth_user_change", conn.authUserChange, true); err != nil {</code></span>
<span class="codeline" id="line-1614"><code>		return nil, err</code></span>
<span class="codeline" id="line-1615"><code>	}</code></span>
<span class="codeline" id="line-1616"><code>	//</code></span>
<span class="codeline" id="line-1617"><code>	// Register: auth_user_delete</code></span>
<span class="codeline" id="line-1618"><code>	// auth_user_delete can be used (by an admin user only)</code></span>
<span class="codeline" id="line-1619"><code>	// to delete a user. The currently logged-in user cannot be deleted,</code></span>
<span class="codeline" id="line-1620"><code>	// which guarantees that there is always an admin user and hence that</code></span>
<span class="codeline" id="line-1621"><code>	// the database cannot be converted into a no-authentication-required</code></span>
<span class="codeline" id="line-1622"><code>	// database.</code></span>
<span class="codeline" id="line-1623"><code>	if err := conn.RegisterFunc("auth_user_delete", conn.authUserDelete, true); err != nil {</code></span>
<span class="codeline" id="line-1624"><code>		return nil, err</code></span>
<span class="codeline" id="line-1625"><code>	}</code></span>
<span class="codeline" id="line-1626"><code></code></span>
<span class="codeline" id="line-1627"><code>	// Register: auth_enabled</code></span>
<span class="codeline" id="line-1628"><code>	// auth_enabled can be used to check if user authentication is enabled</code></span>
<span class="codeline" id="line-1629"><code>	if err := conn.RegisterFunc("auth_enabled", conn.authEnabled, true); err != nil {</code></span>
<span class="codeline" id="line-1630"><code>		return nil, err</code></span>
<span class="codeline" id="line-1631"><code>	}</code></span>
<span class="codeline" id="line-1632"><code></code></span>
<span class="codeline" id="line-1633"><code>	// Auto Vacuum</code></span>
<span class="codeline" id="line-1634"><code>	// Moved auto_vacuum command, the user preference for auto_vacuum needs to be implemented directly after</code></span>
<span class="codeline" id="line-1635"><code>	// the authentication and before the sqlite_user table gets created if the user</code></span>
<span class="codeline" id="line-1636"><code>	// decides to activate User Authentication because</code></span>
<span class="codeline" id="line-1637"><code>	// auto_vacuum needs to be set before any tables are created</code></span>
<span class="codeline" id="line-1638"><code>	// and activating user authentication creates the internal table `sqlite_user`.</code></span>
<span class="codeline" id="line-1639"><code>	if autoVacuum &gt; -1 {</code></span>
<span class="codeline" id="line-1640"><code>		if err := exec(fmt.Sprintf("PRAGMA auto_vacuum = %d;", autoVacuum)); err != nil {</code></span>
<span class="codeline" id="line-1641"><code>			func() _Ctype_int{ _cgo0 := /*line :1640:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1640:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1642"><code>			return nil, err</code></span>
<span class="codeline" id="line-1643"><code>		}</code></span>
<span class="codeline" id="line-1644"><code>	}</code></span>
<span class="codeline" id="line-1645"><code></code></span>
<span class="codeline" id="line-1646"><code>	// Check if user wants to activate User Authentication</code></span>
<span class="codeline" id="line-1647"><code>	if authCreate {</code></span>
<span class="codeline" id="line-1648"><code>		// Before going any further, we need to check that the user</code></span>
<span class="codeline" id="line-1649"><code>		// has provided an username and password within the DSN.</code></span>
<span class="codeline" id="line-1650"><code>		// We are not allowed to continue.</code></span>
<span class="codeline" id="line-1651"><code>		if len(authUser) == 0 {</code></span>
<span class="codeline" id="line-1652"><code>			return nil, fmt.Errorf("Missing '_auth_user' while user authentication was requested with '_auth'")</code></span>
<span class="codeline" id="line-1653"><code>		}</code></span>
<span class="codeline" id="line-1654"><code>		if len(authPass) == 0 {</code></span>
<span class="codeline" id="line-1655"><code>			return nil, fmt.Errorf("Missing '_auth_pass' while user authentication was requested with '_auth'")</code></span>
<span class="codeline" id="line-1656"><code>		}</code></span>
<span class="codeline" id="line-1657"><code></code></span>
<span class="codeline" id="line-1658"><code>		// Check if User Authentication is Enabled</code></span>
<span class="codeline" id="line-1659"><code>		authExists := conn.AuthEnabled()</code></span>
<span class="codeline" id="line-1660"><code>		if !authExists {</code></span>
<span class="codeline" id="line-1661"><code>			if err := conn.AuthUserAdd(authUser, authPass, true); err != nil {</code></span>
<span class="codeline" id="line-1662"><code>				return nil, err</code></span>
<span class="codeline" id="line-1663"><code>			}</code></span>
<span class="codeline" id="line-1664"><code>		}</code></span>
<span class="codeline" id="line-1665"><code>	}</code></span>
<span class="codeline" id="line-1666"><code></code></span>
<span class="codeline" id="line-1667"><code>	// Case Sensitive LIKE</code></span>
<span class="codeline" id="line-1668"><code>	if caseSensitiveLike &gt; -1 {</code></span>
<span class="codeline" id="line-1669"><code>		if err := exec(fmt.Sprintf("PRAGMA case_sensitive_like = %d;", caseSensitiveLike)); err != nil {</code></span>
<span class="codeline" id="line-1670"><code>			func() _Ctype_int{ _cgo0 := /*line :1669:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1669:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1671"><code>			return nil, err</code></span>
<span class="codeline" id="line-1672"><code>		}</code></span>
<span class="codeline" id="line-1673"><code>	}</code></span>
<span class="codeline" id="line-1674"><code></code></span>
<span class="codeline" id="line-1675"><code>	// Defer Foreign Keys</code></span>
<span class="codeline" id="line-1676"><code>	if deferForeignKeys &gt; -1 {</code></span>
<span class="codeline" id="line-1677"><code>		if err := exec(fmt.Sprintf("PRAGMA defer_foreign_keys = %d;", deferForeignKeys)); err != nil {</code></span>
<span class="codeline" id="line-1678"><code>			func() _Ctype_int{ _cgo0 := /*line :1677:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1677:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1679"><code>			return nil, err</code></span>
<span class="codeline" id="line-1680"><code>		}</code></span>
<span class="codeline" id="line-1681"><code>	}</code></span>
<span class="codeline" id="line-1682"><code></code></span>
<span class="codeline" id="line-1683"><code>	// Forgein Keys</code></span>
<span class="codeline" id="line-1684"><code>	if foreignKeys &gt; -1 {</code></span>
<span class="codeline" id="line-1685"><code>		if err := exec(fmt.Sprintf("PRAGMA foreign_keys = %d;", foreignKeys)); err != nil {</code></span>
<span class="codeline" id="line-1686"><code>			func() _Ctype_int{ _cgo0 := /*line :1685:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1685:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1687"><code>			return nil, err</code></span>
<span class="codeline" id="line-1688"><code>		}</code></span>
<span class="codeline" id="line-1689"><code>	}</code></span>
<span class="codeline" id="line-1690"><code></code></span>
<span class="codeline" id="line-1691"><code>	// Ignore CHECK Constraints</code></span>
<span class="codeline" id="line-1692"><code>	if ignoreCheckConstraints &gt; -1 {</code></span>
<span class="codeline" id="line-1693"><code>		if err := exec(fmt.Sprintf("PRAGMA ignore_check_constraints = %d;", ignoreCheckConstraints)); err != nil {</code></span>
<span class="codeline" id="line-1694"><code>			func() _Ctype_int{ _cgo0 := /*line :1693:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1693:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1695"><code>			return nil, err</code></span>
<span class="codeline" id="line-1696"><code>		}</code></span>
<span class="codeline" id="line-1697"><code>	}</code></span>
<span class="codeline" id="line-1698"><code></code></span>
<span class="codeline" id="line-1699"><code>	// Journal Mode</code></span>
<span class="codeline" id="line-1700"><code>	if journalMode != "" {</code></span>
<span class="codeline" id="line-1701"><code>		if err := exec(fmt.Sprintf("PRAGMA journal_mode = %s;", journalMode)); err != nil {</code></span>
<span class="codeline" id="line-1702"><code>			func() _Ctype_int{ _cgo0 := /*line :1701:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1701:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1703"><code>			return nil, err</code></span>
<span class="codeline" id="line-1704"><code>		}</code></span>
<span class="codeline" id="line-1705"><code>	}</code></span>
<span class="codeline" id="line-1706"><code></code></span>
<span class="codeline" id="line-1707"><code>	// Locking Mode</code></span>
<span class="codeline" id="line-1708"><code>	// Because the default is NORMAL and this is not changed in this package</code></span>
<span class="codeline" id="line-1709"><code>	// by using the compile time SQLITE_DEFAULT_LOCKING_MODE this PRAGMA can always be executed</code></span>
<span class="codeline" id="line-1710"><code>	if err := exec(fmt.Sprintf("PRAGMA locking_mode = %s;", lockingMode)); err != nil {</code></span>
<span class="codeline" id="line-1711"><code>		func() _Ctype_int{ _cgo0 := /*line :1710:22*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1710:25*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1712"><code>		return nil, err</code></span>
<span class="codeline" id="line-1713"><code>	}</code></span>
<span class="codeline" id="line-1714"><code></code></span>
<span class="codeline" id="line-1715"><code>	// Query Only</code></span>
<span class="codeline" id="line-1716"><code>	if queryOnly &gt; -1 {</code></span>
<span class="codeline" id="line-1717"><code>		if err := exec(fmt.Sprintf("PRAGMA query_only = %d;", queryOnly)); err != nil {</code></span>
<span class="codeline" id="line-1718"><code>			func() _Ctype_int{ _cgo0 := /*line :1717:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1717:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1719"><code>			return nil, err</code></span>
<span class="codeline" id="line-1720"><code>		}</code></span>
<span class="codeline" id="line-1721"><code>	}</code></span>
<span class="codeline" id="line-1722"><code></code></span>
<span class="codeline" id="line-1723"><code>	// Recursive Triggers</code></span>
<span class="codeline" id="line-1724"><code>	if recursiveTriggers &gt; -1 {</code></span>
<span class="codeline" id="line-1725"><code>		if err := exec(fmt.Sprintf("PRAGMA recursive_triggers = %d;", recursiveTriggers)); err != nil {</code></span>
<span class="codeline" id="line-1726"><code>			func() _Ctype_int{ _cgo0 := /*line :1725:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1725:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1727"><code>			return nil, err</code></span>
<span class="codeline" id="line-1728"><code>		}</code></span>
<span class="codeline" id="line-1729"><code>	}</code></span>
<span class="codeline" id="line-1730"><code></code></span>
<span class="codeline" id="line-1731"><code>	// Secure Delete</code></span>
<span class="codeline" id="line-1732"><code>	//</code></span>
<span class="codeline" id="line-1733"><code>	// Because this package can set the compile time flag SQLITE_SECURE_DELETE with a build tag</code></span>
<span class="codeline" id="line-1734"><code>	// the default value for secureDelete var is 'DEFAULT' this way</code></span>
<span class="codeline" id="line-1735"><code>	// you can compile with secure_delete 'ON' and disable it for a specific database connection.</code></span>
<span class="codeline" id="line-1736"><code>	if secureDelete != "DEFAULT" {</code></span>
<span class="codeline" id="line-1737"><code>		if err := exec(fmt.Sprintf("PRAGMA secure_delete = %s;", secureDelete)); err != nil {</code></span>
<span class="codeline" id="line-1738"><code>			func() _Ctype_int{ _cgo0 := /*line :1737:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1737:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1739"><code>			return nil, err</code></span>
<span class="codeline" id="line-1740"><code>		}</code></span>
<span class="codeline" id="line-1741"><code>	}</code></span>
<span class="codeline" id="line-1742"><code></code></span>
<span class="codeline" id="line-1743"><code>	// Synchronous Mode</code></span>
<span class="codeline" id="line-1744"><code>	//</code></span>
<span class="codeline" id="line-1745"><code>	// Because default is NORMAL this statement is always executed</code></span>
<span class="codeline" id="line-1746"><code>	if err := exec(fmt.Sprintf("PRAGMA synchronous = %s;", synchronousMode)); err != nil {</code></span>
<span class="codeline" id="line-1747"><code>		conn.Close()</code></span>
<span class="codeline" id="line-1748"><code>		return nil, err</code></span>
<span class="codeline" id="line-1749"><code>	}</code></span>
<span class="codeline" id="line-1750"><code></code></span>
<span class="codeline" id="line-1751"><code>	// Writable Schema</code></span>
<span class="codeline" id="line-1752"><code>	if writableSchema &gt; -1 {</code></span>
<span class="codeline" id="line-1753"><code>		if err := exec(fmt.Sprintf("PRAGMA writable_schema = %d;", writableSchema)); err != nil {</code></span>
<span class="codeline" id="line-1754"><code>			func() _Ctype_int{ _cgo0 := /*line :1753:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1753:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1755"><code>			return nil, err</code></span>
<span class="codeline" id="line-1756"><code>		}</code></span>
<span class="codeline" id="line-1757"><code>	}</code></span>
<span class="codeline" id="line-1758"><code></code></span>
<span class="codeline" id="line-1759"><code>	// Cache Size</code></span>
<span class="codeline" id="line-1760"><code>	if cacheSize != nil {</code></span>
<span class="codeline" id="line-1761"><code>		if err := exec(fmt.Sprintf("PRAGMA cache_size = %d;", *cacheSize)); err != nil {</code></span>
<span class="codeline" id="line-1762"><code>			func() _Ctype_int{ _cgo0 := /*line :1761:23*/db; _cgoCheckPointer(_cgo0, nil); return /*line :1761:26*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1763"><code>			return nil, err</code></span>
<span class="codeline" id="line-1764"><code>		}</code></span>
<span class="codeline" id="line-1765"><code>	}</code></span>
<span class="codeline" id="line-1766"><code></code></span>
<span class="codeline" id="line-1767"><code>	if len(d.Extensions) &gt; 0 {</code></span>
<span class="codeline" id="line-1768"><code>		if err := conn.loadExtensions(d.Extensions); err != nil {</code></span>
<span class="codeline" id="line-1769"><code>			conn.Close()</code></span>
<span class="codeline" id="line-1770"><code>			return nil, err</code></span>
<span class="codeline" id="line-1771"><code>		}</code></span>
<span class="codeline" id="line-1772"><code>	}</code></span>
<span class="codeline" id="line-1773"><code></code></span>
<span class="codeline" id="line-1774"><code>	if d.ConnectHook != nil {</code></span>
<span class="codeline" id="line-1775"><code>		if err := d.ConnectHook(conn); err != nil {</code></span>
<span class="codeline" id="line-1776"><code>			conn.Close()</code></span>
<span class="codeline" id="line-1777"><code>			return nil, err</code></span>
<span class="codeline" id="line-1778"><code>		}</code></span>
<span class="codeline" id="line-1779"><code>	}</code></span>
<span class="codeline" id="line-1780"><code>	runtime.SetFinalizer(conn, (*SQLiteConn).Close)</code></span>
<span class="codeline" id="line-1781"><code>	return conn, nil</code></span>
<span class="codeline" id="line-1782"><code>}</code></span>
<span class="codeline" id="line-1783"><code></code></span>
<span class="codeline" id="line-1784"><code>// Close the connection.</code></span>
<span class="codeline" id="line-1785"><code>func (c *SQLiteConn) Close() error {</code></span>
<span class="codeline" id="line-1786"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :1785:27*/c.db; _cgoCheckPointer(_cgo0, nil); return /*line :1785:32*/_Cfunc_sqlite3_close_v2(_cgo0); }()</code></span>
<span class="codeline" id="line-1787"><code>	if rv != ( /*line :1786:11*/_Ciconst_SQLITE_OK /*line :1786:21*/) {</code></span>
<span class="codeline" id="line-1788"><code>		return c.lastError()</code></span>
<span class="codeline" id="line-1789"><code>	}</code></span>
<span class="codeline" id="line-1790"><code>	deleteHandles(c)</code></span>
<span class="codeline" id="line-1791"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1792"><code>	c.db = nil</code></span>
<span class="codeline" id="line-1793"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-1794"><code>	runtime.SetFinalizer(c, nil)</code></span>
<span class="codeline" id="line-1795"><code>	return nil</code></span>
<span class="codeline" id="line-1796"><code>}</code></span>
<span class="codeline" id="line-1797"><code></code></span>
<span class="codeline" id="line-1798"><code>func (c *SQLiteConn) dbConnOpen() bool {</code></span>
<span class="codeline" id="line-1799"><code>	if c == nil {</code></span>
<span class="codeline" id="line-1800"><code>		return false</code></span>
<span class="codeline" id="line-1801"><code>	}</code></span>
<span class="codeline" id="line-1802"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-1803"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-1804"><code>	return c.db != nil</code></span>
<span class="codeline" id="line-1805"><code>}</code></span>
<span class="codeline" id="line-1806"><code></code></span>
<span class="codeline" id="line-1807"><code>// Prepare the query string. Return a new statement.</code></span>
<span class="codeline" id="line-1808"><code>func (c *SQLiteConn) Prepare(query string) (driver.Stmt, error) {</code></span>
<span class="codeline" id="line-1809"><code>	return c.prepare(context.Background(), query)</code></span>
<span class="codeline" id="line-1810"><code>}</code></span>
<span class="codeline" id="line-1811"><code></code></span>
<span class="codeline" id="line-1812"><code>func (c *SQLiteConn) prepare(ctx context.Context, query string) (driver.Stmt, error) {</code></span>
<span class="codeline" id="line-1813"><code>	pquery := ( /*line :1812:12*/_Cfunc_CString /*line :1812:20*/)(query)</code></span>
<span class="codeline" id="line-1814"><code>	defer func() func() { _cgo0 := /*line :1813:15*/unsafe.Pointer(pquery); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1813:38*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-1815"><code>	var s * /*line :1814:9*/_Ctype_sqlite3_stmt /*line :1814:23*/</code></span>
<span class="codeline" id="line-1816"><code>	var tail * /*line :1815:12*/_Ctype_char /*line :1815:18*/</code></span>
<span class="codeline" id="line-1817"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :1816:39*/c.db; var _cgo1 *_Ctype_char = /*line :1816:45*/pquery; var _cgo2 _Ctype_int = _Ctype_int /*line :1816:58*/(-1); _cgoBase3 := /*line :1816:64*/&amp;s; _cgo3 := _cgoBase3; _cgoBase4 := /*line :1816:68*/&amp;tail; _cgo4 := _cgoBase4; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1816:74*/_Cfunc__sqlite3_prepare_v2_internal(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()</code></span>
<span class="codeline" id="line-1818"><code>	if rv != ( /*line :1817:11*/_Ciconst_SQLITE_OK /*line :1817:21*/) {</code></span>
<span class="codeline" id="line-1819"><code>		return nil, c.lastError()</code></span>
<span class="codeline" id="line-1820"><code>	}</code></span>
<span class="codeline" id="line-1821"><code>	var t string</code></span>
<span class="codeline" id="line-1822"><code>	if tail != nil &amp;&amp; *tail != '\000' {</code></span>
<span class="codeline" id="line-1823"><code>		t = strings.TrimSpace(( /*line :1822:25*/_Cfunc_GoString /*line :1822:34*/)(tail))</code></span>
<span class="codeline" id="line-1824"><code>	}</code></span>
<span class="codeline" id="line-1825"><code>	ss := &amp;SQLiteStmt{c: c, s: s, t: t}</code></span>
<span class="codeline" id="line-1826"><code>	runtime.SetFinalizer(ss, (*SQLiteStmt).Close)</code></span>
<span class="codeline" id="line-1827"><code>	return ss, nil</code></span>
<span class="codeline" id="line-1828"><code>}</code></span>
<span class="codeline" id="line-1829"><code></code></span>
<span class="codeline" id="line-1830"><code>// Run-Time Limit Categories.</code></span>
<span class="codeline" id="line-1831"><code>// See: http://www.sqlite.org/c3ref/c_limit_attached.html</code></span>
<span class="codeline" id="line-1832"><code>const (</code></span>
<span class="codeline" id="line-1833"><code>	SQLITE_LIMIT_LENGTH              = ( /*line :1832:37*/_Ciconst_SQLITE_LIMIT_LENGTH /*line :1832:57*/)</code></span>
<span class="codeline" id="line-1834"><code>	SQLITE_LIMIT_SQL_LENGTH          = ( /*line :1833:37*/_Ciconst_SQLITE_LIMIT_SQL_LENGTH /*line :1833:61*/)</code></span>
<span class="codeline" id="line-1835"><code>	SQLITE_LIMIT_COLUMN              = ( /*line :1834:37*/_Ciconst_SQLITE_LIMIT_COLUMN /*line :1834:57*/)</code></span>
<span class="codeline" id="line-1836"><code>	SQLITE_LIMIT_EXPR_DEPTH          = ( /*line :1835:37*/_Ciconst_SQLITE_LIMIT_EXPR_DEPTH /*line :1835:61*/)</code></span>
<span class="codeline" id="line-1837"><code>	SQLITE_LIMIT_COMPOUND_SELECT     = ( /*line :1836:37*/_Ciconst_SQLITE_LIMIT_COMPOUND_SELECT /*line :1836:66*/)</code></span>
<span class="codeline" id="line-1838"><code>	SQLITE_LIMIT_VDBE_OP             = ( /*line :1837:37*/_Ciconst_SQLITE_LIMIT_VDBE_OP /*line :1837:58*/)</code></span>
<span class="codeline" id="line-1839"><code>	SQLITE_LIMIT_FUNCTION_ARG        = ( /*line :1838:37*/_Ciconst_SQLITE_LIMIT_FUNCTION_ARG /*line :1838:63*/)</code></span>
<span class="codeline" id="line-1840"><code>	SQLITE_LIMIT_ATTACHED            = ( /*line :1839:37*/_Ciconst_SQLITE_LIMIT_ATTACHED /*line :1839:59*/)</code></span>
<span class="codeline" id="line-1841"><code>	SQLITE_LIMIT_LIKE_PATTERN_LENGTH = ( /*line :1840:37*/_Ciconst_SQLITE_LIMIT_LIKE_PATTERN_LENGTH /*line :1840:70*/)</code></span>
<span class="codeline" id="line-1842"><code>	SQLITE_LIMIT_VARIABLE_NUMBER     = ( /*line :1841:37*/_Ciconst_SQLITE_LIMIT_VARIABLE_NUMBER /*line :1841:66*/)</code></span>
<span class="codeline" id="line-1843"><code>	SQLITE_LIMIT_TRIGGER_DEPTH       = ( /*line :1842:37*/_Ciconst_SQLITE_LIMIT_TRIGGER_DEPTH /*line :1842:64*/)</code></span>
<span class="codeline" id="line-1844"><code>	SQLITE_LIMIT_WORKER_THREADS      = ( /*line :1843:37*/_Ciconst_SQLITE_LIMIT_WORKER_THREADS /*line :1843:65*/)</code></span>
<span class="codeline" id="line-1845"><code>)</code></span>
<span class="codeline" id="line-1846"><code></code></span>
<span class="codeline" id="line-1847"><code>// GetFilename returns the absolute path to the file containing</code></span>
<span class="codeline" id="line-1848"><code>// the requested schema. When passed an empty string, it will</code></span>
<span class="codeline" id="line-1849"><code>// instead use the database's default schema: "main".</code></span>
<span class="codeline" id="line-1850"><code>// See: sqlite3_db_filename, https://www.sqlite.org/c3ref/db_filename.html</code></span>
<span class="codeline" id="line-1851"><code>func (c *SQLiteConn) GetFilename(schemaName string) string {</code></span>
<span class="codeline" id="line-1852"><code>	if schemaName == "" {</code></span>
<span class="codeline" id="line-1853"><code>		schemaName = "main"</code></span>
<span class="codeline" id="line-1854"><code>	}</code></span>
<span class="codeline" id="line-1855"><code>	return ( /*line :1854:9*/_Cfunc_GoString /*line :1854:18*/)(func() _Ctype_sqlite3_filename{ _cgo0 := /*line :1854:42*/c.db; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :1854:57*/(schemaName); _cgoCheckPointer(_cgo0, nil); return /*line :1854:70*/_Cfunc_sqlite3_db_filename(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-1856"><code>}</code></span>
<span class="codeline" id="line-1857"><code></code></span>
<span class="codeline" id="line-1858"><code>// GetLimit returns the current value of a run-time limit.</code></span>
<span class="codeline" id="line-1859"><code>// See: sqlite3_limit, http://www.sqlite.org/c3ref/limit.html</code></span>
<span class="codeline" id="line-1860"><code>func (c *SQLiteConn) GetLimit(id int) int {</code></span>
<span class="codeline" id="line-1861"><code>	return int(func() _Ctype_int{ _cgo0 := /*line :1860:30*/c.db; var _cgo1 _Ctype_int = _Ctype_int /*line :1860:41*/(id); var _cgo2 _Ctype_int = _Ctype_int /*line :1860:52*/(-1); _cgoCheckPointer(_cgo0, nil); return /*line :1860:57*/_Cfunc__sqlite3_limit(_cgo0, _cgo1, _cgo2); }())</code></span>
<span class="codeline" id="line-1862"><code>}</code></span>
<span class="codeline" id="line-1863"><code></code></span>
<span class="codeline" id="line-1864"><code>// SetLimit changes the value of a run-time limits.</code></span>
<span class="codeline" id="line-1865"><code>// Then this method returns the prior value of the limit.</code></span>
<span class="codeline" id="line-1866"><code>// See: sqlite3_limit, http://www.sqlite.org/c3ref/limit.html</code></span>
<span class="codeline" id="line-1867"><code>func (c *SQLiteConn) SetLimit(id int, newVal int) int {</code></span>
<span class="codeline" id="line-1868"><code>	return int(func() _Ctype_int{ _cgo0 := /*line :1867:30*/c.db; var _cgo1 _Ctype_int = _Ctype_int /*line :1867:41*/(id); var _cgo2 _Ctype_int = _Ctype_int /*line :1867:52*/(newVal); _cgoCheckPointer(_cgo0, nil); return /*line :1867:61*/_Cfunc__sqlite3_limit(_cgo0, _cgo1, _cgo2); }())</code></span>
<span class="codeline" id="line-1869"><code>}</code></span>
<span class="codeline" id="line-1870"><code></code></span>
<span class="codeline" id="line-1871"><code>// SetFileControlInt invokes the xFileControl method on a given database. The</code></span>
<span class="codeline" id="line-1872"><code>// dbName is the name of the database. It will default to "main" if left blank.</code></span>
<span class="codeline" id="line-1873"><code>// The op is one of the opcodes prefixed by "SQLITE_FCNTL_". The arg argument</code></span>
<span class="codeline" id="line-1874"><code>// and return code are both opcode-specific. Please see the SQLite documentation.</code></span>
<span class="codeline" id="line-1875"><code>//</code></span>
<span class="codeline" id="line-1876"><code>// This method is not thread-safe as the returned error code can be changed by</code></span>
<span class="codeline" id="line-1877"><code>// another call if invoked concurrently.</code></span>
<span class="codeline" id="line-1878"><code>//</code></span>
<span class="codeline" id="line-1879"><code>// See: sqlite3_file_control, https://www.sqlite.org/c3ref/file_control.html</code></span>
<span class="codeline" id="line-1880"><code>func (c *SQLiteConn) SetFileControlInt(dbName string, op int, arg int) error {</code></span>
<span class="codeline" id="line-1881"><code>	if dbName == "" {</code></span>
<span class="codeline" id="line-1882"><code>		dbName = "main"</code></span>
<span class="codeline" id="line-1883"><code>	}</code></span>
<span class="codeline" id="line-1884"><code></code></span>
<span class="codeline" id="line-1885"><code>	cDBName := ( /*line :1884:13*/_Cfunc_CString /*line :1884:21*/)(dbName)</code></span>
<span class="codeline" id="line-1886"><code>	defer func() func() { _cgo0 := /*line :1885:15*/unsafe.Pointer(cDBName); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1885:39*/_Cfunc_free(_cgo0); }}()()</code></span>
<span class="codeline" id="line-1887"><code></code></span>
<span class="codeline" id="line-1888"><code>	cArg :=  /*line :1887:10*/_Ctype_int /*line :1887:15*/(arg)</code></span>
<span class="codeline" id="line-1889"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :1888:31*/c.db; var _cgo1 *_Ctype_char = /*line :1888:37*/cDBName; var _cgo2 _Ctype_int = _Ctype_int /*line :1888:51*/(op); _cgoBase3 := /*line :1888:72*/&amp;cArg; _cgo3 := /*line :1888:57*/unsafe.Pointer(_cgoBase3); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return /*line :1888:79*/_Cfunc_sqlite3_file_control(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1890"><code>	if rv != ( /*line :1889:11*/_Ciconst_SQLITE_OK /*line :1889:21*/) {</code></span>
<span class="codeline" id="line-1891"><code>		return c.lastError()</code></span>
<span class="codeline" id="line-1892"><code>	}</code></span>
<span class="codeline" id="line-1893"><code>	return nil</code></span>
<span class="codeline" id="line-1894"><code>}</code></span>
<span class="codeline" id="line-1895"><code></code></span>
<span class="codeline" id="line-1896"><code>// Close the statement.</code></span>
<span class="codeline" id="line-1897"><code>func (s *SQLiteStmt) Close() error {</code></span>
<span class="codeline" id="line-1898"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-1899"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-1900"><code>	if s.closed {</code></span>
<span class="codeline" id="line-1901"><code>		return nil</code></span>
<span class="codeline" id="line-1902"><code>	}</code></span>
<span class="codeline" id="line-1903"><code>	s.closed = true</code></span>
<span class="codeline" id="line-1904"><code>	if !s.c.dbConnOpen() {</code></span>
<span class="codeline" id="line-1905"><code>		return errors.New("sqlite statement with already closed database connection")</code></span>
<span class="codeline" id="line-1906"><code>	}</code></span>
<span class="codeline" id="line-1907"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :1906:27*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :1906:31*/_Cfunc_sqlite3_finalize(_cgo0); }()</code></span>
<span class="codeline" id="line-1908"><code>	s.s = nil</code></span>
<span class="codeline" id="line-1909"><code>	if rv != ( /*line :1908:11*/_Ciconst_SQLITE_OK /*line :1908:21*/) {</code></span>
<span class="codeline" id="line-1910"><code>		return s.c.lastError()</code></span>
<span class="codeline" id="line-1911"><code>	}</code></span>
<span class="codeline" id="line-1912"><code>	s.c = nil</code></span>
<span class="codeline" id="line-1913"><code>	runtime.SetFinalizer(s, nil)</code></span>
<span class="codeline" id="line-1914"><code>	return nil</code></span>
<span class="codeline" id="line-1915"><code>}</code></span>
<span class="codeline" id="line-1916"><code></code></span>
<span class="codeline" id="line-1917"><code>// NumInput return a number of parameters.</code></span>
<span class="codeline" id="line-1918"><code>func (s *SQLiteStmt) NumInput() int {</code></span>
<span class="codeline" id="line-1919"><code>	return int(func() _Ctype_int{ _cgo0 := /*line :1918:44*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :1918:48*/_Cfunc_sqlite3_bind_parameter_count(_cgo0); }())</code></span>
<span class="codeline" id="line-1920"><code>}</code></span>
<span class="codeline" id="line-1921"><code></code></span>
<span class="codeline" id="line-1922"><code>var placeHolder = []byte{0}</code></span>
<span class="codeline" id="line-1923"><code></code></span>
<span class="codeline" id="line-1924"><code>func (s *SQLiteStmt) bind(args []driver.NamedValue) error {</code></span>
<span class="codeline" id="line-1925"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :1924:24*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :1924:28*/_Cfunc_sqlite3_reset(_cgo0); }()</code></span>
<span class="codeline" id="line-1926"><code>	if rv != ( /*line :1925:11*/_Ciconst_SQLITE_ROW /*line :1925:22*/) &amp;&amp; rv != ( /*line :1925:33*/_Ciconst_SQLITE_OK /*line :1925:43*/) &amp;&amp; rv != ( /*line :1925:54*/_Ciconst_SQLITE_DONE /*line :1925:66*/) {</code></span>
<span class="codeline" id="line-1927"><code>		return s.c.lastError()</code></span>
<span class="codeline" id="line-1928"><code>	}</code></span>
<span class="codeline" id="line-1929"><code></code></span>
<span class="codeline" id="line-1930"><code>	bindIndices := make([][3]int, len(args))</code></span>
<span class="codeline" id="line-1931"><code>	prefixes := []string{":", "@", "$"}</code></span>
<span class="codeline" id="line-1932"><code>	for i, v := range args {</code></span>
<span class="codeline" id="line-1933"><code>		bindIndices[i][0] = args[i].Ordinal</code></span>
<span class="codeline" id="line-1934"><code>		if v.Name != "" {</code></span>
<span class="codeline" id="line-1935"><code>			for j := range prefixes {</code></span>
<span class="codeline" id="line-1936"><code>				cname := ( /*line :1935:14*/_Cfunc_CString /*line :1935:22*/)(prefixes[j] + v.Name)</code></span>
<span class="codeline" id="line-1937"><code>				bindIndices[i][j] = int(func() _Ctype_int{ _cgo0 := /*line :1936:60*/s.s; var _cgo1 *_Ctype_char = /*line :1936:65*/cname; _cgoCheckPointer(_cgo0, nil); return /*line :1936:71*/_Cfunc_sqlite3_bind_parameter_index(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-1938"><code>				func() { _cgo0 := /*line :1937:12*/unsafe.Pointer(cname); _cgoCheckPointer(_cgo0, nil); /*line :1937:34*/_Cfunc_free(_cgo0); }()</code></span>
<span class="codeline" id="line-1939"><code>			}</code></span>
<span class="codeline" id="line-1940"><code>			args[i].Ordinal = bindIndices[i][0]</code></span>
<span class="codeline" id="line-1941"><code>		}</code></span>
<span class="codeline" id="line-1942"><code>	}</code></span>
<span class="codeline" id="line-1943"><code></code></span>
<span class="codeline" id="line-1944"><code>	for i, arg := range args {</code></span>
<span class="codeline" id="line-1945"><code>		for j := range bindIndices[i] {</code></span>
<span class="codeline" id="line-1946"><code>			if bindIndices[i][j] == 0 {</code></span>
<span class="codeline" id="line-1947"><code>				continue</code></span>
<span class="codeline" id="line-1948"><code>			}</code></span>
<span class="codeline" id="line-1949"><code>			n :=  /*line :1948:9*/_Ctype_int /*line :1948:14*/(bindIndices[i][j])</code></span>
<span class="codeline" id="line-1950"><code>			switch v := arg.Value.(type) {</code></span>
<span class="codeline" id="line-1951"><code>			case nil:</code></span>
<span class="codeline" id="line-1952"><code>				rv = func() _Ctype_int{ _cgo0 := /*line :1951:30*/s.s; var _cgo1 _Ctype_int = /*line :1951:35*/n; _cgoCheckPointer(_cgo0, nil); return /*line :1951:37*/_Cfunc_sqlite3_bind_null(_cgo0, _cgo1); }()</code></span>
<span class="codeline" id="line-1953"><code>			case string:</code></span>
<span class="codeline" id="line-1954"><code>				if len(v) == 0 {</code></span>
<span class="codeline" id="line-1955"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1954:32*/s.s; var _cgo1 _Ctype_int = /*line :1954:37*/n; var _cgo2 *_Ctype_char = /*line :1954:40*/(*_Ctype_char /*line :1954:48*/)(unsafe.Pointer(&amp;placeHolder[0])); var _cgo3 _Ctype_int = _Ctype_int /*line :1954:89*/(0); _cgoCheckPointer(_cgo0, nil); return /*line :1954:93*/_Cfunc__sqlite3_bind_text(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1956"><code>				} else {</code></span>
<span class="codeline" id="line-1957"><code>					b := []byte(v)</code></span>
<span class="codeline" id="line-1958"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1957:32*/s.s; var _cgo1 _Ctype_int = /*line :1957:37*/n; var _cgo2 *_Ctype_char = /*line :1957:40*/(*_Ctype_char /*line :1957:48*/)(unsafe.Pointer(&amp;b[0])); var _cgo3 _Ctype_int = _Ctype_int /*line :1957:79*/(len(b)); _cgoCheckPointer(_cgo0, nil); return /*line :1957:88*/_Cfunc__sqlite3_bind_text(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1959"><code>				}</code></span>
<span class="codeline" id="line-1960"><code>			case int64:</code></span>
<span class="codeline" id="line-1961"><code>				rv = func() _Ctype_int{ _cgo0 := /*line :1960:31*/s.s; var _cgo1 _Ctype_int = /*line :1960:36*/n; var _cgo2 _Ctype_sqlite3_int64 = _Ctype_sqlite3_int64 /*line :1960:54*/(v); _cgoCheckPointer(_cgo0, nil); return /*line :1960:58*/_Cfunc_sqlite3_bind_int64(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-1962"><code>			case bool:</code></span>
<span class="codeline" id="line-1963"><code>				if v {</code></span>
<span class="codeline" id="line-1964"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1963:30*/s.s; var _cgo1 _Ctype_int = /*line :1963:35*/n; var _cgo2 _Ctype_int = /*line :1963:38*/1; _cgoCheckPointer(_cgo0, nil); return /*line :1963:40*/_Cfunc_sqlite3_bind_int(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-1965"><code>				} else {</code></span>
<span class="codeline" id="line-1966"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1965:30*/s.s; var _cgo1 _Ctype_int = /*line :1965:35*/n; var _cgo2 _Ctype_int = /*line :1965:38*/0; _cgoCheckPointer(_cgo0, nil); return /*line :1965:40*/_Cfunc_sqlite3_bind_int(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-1967"><code>				}</code></span>
<span class="codeline" id="line-1968"><code>			case float64:</code></span>
<span class="codeline" id="line-1969"><code>				rv = func() _Ctype_int{ _cgo0 := /*line :1968:32*/s.s; var _cgo1 _Ctype_int = /*line :1968:37*/n; var _cgo2 _Ctype_double = _Ctype_double /*line :1968:48*/(v); _cgoCheckPointer(_cgo0, nil); return /*line :1968:52*/_Cfunc_sqlite3_bind_double(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-1970"><code>			case []byte:</code></span>
<span class="codeline" id="line-1971"><code>				if v == nil {</code></span>
<span class="codeline" id="line-1972"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1971:31*/s.s; var _cgo1 _Ctype_int = /*line :1971:36*/n; _cgoCheckPointer(_cgo0, nil); return /*line :1971:38*/_Cfunc_sqlite3_bind_null(_cgo0, _cgo1); }()</code></span>
<span class="codeline" id="line-1973"><code>				} else {</code></span>
<span class="codeline" id="line-1974"><code>					ln := len(v)</code></span>
<span class="codeline" id="line-1975"><code>					if ln == 0 {</code></span>
<span class="codeline" id="line-1976"><code>						v = placeHolder</code></span>
<span class="codeline" id="line-1977"><code>					}</code></span>
<span class="codeline" id="line-1978"><code>					rv = func() _Ctype_int{ _cgo0 := /*line :1977:32*/s.s; var _cgo1 _Ctype_int = /*line :1977:37*/n; _cgoIndex2 := &amp;/*line :1977:56*/v; _cgo2 := /*line :1977:40*/unsafe.Pointer(&amp;(*_cgoIndex2)[0]); var _cgo3 _Ctype_int = _Ctype_int /*line :1977:68*/(ln); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return /*line :1977:73*/_Cfunc__sqlite3_bind_blob(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1979"><code>				}</code></span>
<span class="codeline" id="line-1980"><code>			case time.Time:</code></span>
<span class="codeline" id="line-1981"><code>				b := []byte(v.Format(SQLiteTimestampFormats[0]))</code></span>
<span class="codeline" id="line-1982"><code>				rv = func() _Ctype_int{ _cgo0 := /*line :1981:31*/s.s; var _cgo1 _Ctype_int = /*line :1981:36*/n; var _cgo2 *_Ctype_char = /*line :1981:39*/(*_Ctype_char /*line :1981:47*/)(unsafe.Pointer(&amp;b[0])); var _cgo3 _Ctype_int = _Ctype_int /*line :1981:78*/(len(b)); _cgoCheckPointer(_cgo0, nil); return /*line :1981:87*/_Cfunc__sqlite3_bind_text(_cgo0, _cgo1, _cgo2, _cgo3); }()</code></span>
<span class="codeline" id="line-1983"><code>			}</code></span>
<span class="codeline" id="line-1984"><code>			if rv != ( /*line :1983:13*/_Ciconst_SQLITE_OK /*line :1983:23*/) {</code></span>
<span class="codeline" id="line-1985"><code>				return s.c.lastError()</code></span>
<span class="codeline" id="line-1986"><code>			}</code></span>
<span class="codeline" id="line-1987"><code>		}</code></span>
<span class="codeline" id="line-1988"><code>	}</code></span>
<span class="codeline" id="line-1989"><code>	return nil</code></span>
<span class="codeline" id="line-1990"><code>}</code></span>
<span class="codeline" id="line-1991"><code></code></span>
<span class="codeline" id="line-1992"><code>// Query the statement with arguments. Return records.</code></span>
<span class="codeline" id="line-1993"><code>func (s *SQLiteStmt) Query(args []driver.Value) (driver.Rows, error) {</code></span>
<span class="codeline" id="line-1994"><code>	list := make([]driver.NamedValue, len(args))</code></span>
<span class="codeline" id="line-1995"><code>	for i, v := range args {</code></span>
<span class="codeline" id="line-1996"><code>		list[i] = driver.NamedValue{</code></span>
<span class="codeline" id="line-1997"><code>			Ordinal: i + 1,</code></span>
<span class="codeline" id="line-1998"><code>			Value:   v,</code></span>
<span class="codeline" id="line-1999"><code>		}</code></span>
<span class="codeline" id="line-2000"><code>	}</code></span>
<span class="codeline" id="line-2001"><code>	return s.query(context.Background(), list)</code></span>
<span class="codeline" id="line-2002"><code>}</code></span>
<span class="codeline" id="line-2003"><code></code></span>
<span class="codeline" id="line-2004"><code>func (s *SQLiteStmt) query(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {</code></span>
<span class="codeline" id="line-2005"><code>	if err := s.bind(args); err != nil {</code></span>
<span class="codeline" id="line-2006"><code>		return nil, err</code></span>
<span class="codeline" id="line-2007"><code>	}</code></span>
<span class="codeline" id="line-2008"><code></code></span>
<span class="codeline" id="line-2009"><code>	rows := &amp;SQLiteRows{</code></span>
<span class="codeline" id="line-2010"><code>		s:        s,</code></span>
<span class="codeline" id="line-2011"><code>		nc:       int(func() _Ctype_int{ _cgo0 := /*line :2010:40*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2010:44*/_Cfunc_sqlite3_column_count(_cgo0); }()),</code></span>
<span class="codeline" id="line-2012"><code>		cols:     nil,</code></span>
<span class="codeline" id="line-2013"><code>		decltype: nil,</code></span>
<span class="codeline" id="line-2014"><code>		cls:      s.cls,</code></span>
<span class="codeline" id="line-2015"><code>		closed:   false,</code></span>
<span class="codeline" id="line-2016"><code>		ctx:      ctx,</code></span>
<span class="codeline" id="line-2017"><code>	}</code></span>
<span class="codeline" id="line-2018"><code>	runtime.SetFinalizer(rows, (*SQLiteRows).Close)</code></span>
<span class="codeline" id="line-2019"><code></code></span>
<span class="codeline" id="line-2020"><code>	return rows, nil</code></span>
<span class="codeline" id="line-2021"><code>}</code></span>
<span class="codeline" id="line-2022"><code></code></span>
<span class="codeline" id="line-2023"><code>// LastInsertId return last inserted ID.</code></span>
<span class="codeline" id="line-2024"><code>func (r *SQLiteResult) LastInsertId() (int64, error) {</code></span>
<span class="codeline" id="line-2025"><code>	return r.id, nil</code></span>
<span class="codeline" id="line-2026"><code>}</code></span>
<span class="codeline" id="line-2027"><code></code></span>
<span class="codeline" id="line-2028"><code>// RowsAffected return how many rows affected.</code></span>
<span class="codeline" id="line-2029"><code>func (r *SQLiteResult) RowsAffected() (int64, error) {</code></span>
<span class="codeline" id="line-2030"><code>	return r.changes, nil</code></span>
<span class="codeline" id="line-2031"><code>}</code></span>
<span class="codeline" id="line-2032"><code></code></span>
<span class="codeline" id="line-2033"><code>// Exec execute the statement with arguments. Return result object.</code></span>
<span class="codeline" id="line-2034"><code>func (s *SQLiteStmt) Exec(args []driver.Value) (driver.Result, error) {</code></span>
<span class="codeline" id="line-2035"><code>	list := make([]driver.NamedValue, len(args))</code></span>
<span class="codeline" id="line-2036"><code>	for i, v := range args {</code></span>
<span class="codeline" id="line-2037"><code>		list[i] = driver.NamedValue{</code></span>
<span class="codeline" id="line-2038"><code>			Ordinal: i + 1,</code></span>
<span class="codeline" id="line-2039"><code>			Value:   v,</code></span>
<span class="codeline" id="line-2040"><code>		}</code></span>
<span class="codeline" id="line-2041"><code>	}</code></span>
<span class="codeline" id="line-2042"><code>	return s.exec(context.Background(), list)</code></span>
<span class="codeline" id="line-2043"><code>}</code></span>
<span class="codeline" id="line-2044"><code></code></span>
<span class="codeline" id="line-2045"><code>func isInterruptErr(err error) bool {</code></span>
<span class="codeline" id="line-2046"><code>	sqliteErr, ok := err.(Error)</code></span>
<span class="codeline" id="line-2047"><code>	if ok {</code></span>
<span class="codeline" id="line-2048"><code>		return sqliteErr.Code == ErrInterrupt</code></span>
<span class="codeline" id="line-2049"><code>	}</code></span>
<span class="codeline" id="line-2050"><code>	return false</code></span>
<span class="codeline" id="line-2051"><code>}</code></span>
<span class="codeline" id="line-2052"><code></code></span>
<span class="codeline" id="line-2053"><code>// exec executes a query that doesn't return rows. Attempts to honor context timeout.</code></span>
<span class="codeline" id="line-2054"><code>func (s *SQLiteStmt) exec(ctx context.Context, args []driver.NamedValue) (driver.Result, error) {</code></span>
<span class="codeline" id="line-2055"><code>	if ctx.Done() == nil {</code></span>
<span class="codeline" id="line-2056"><code>		return s.execSync(args)</code></span>
<span class="codeline" id="line-2057"><code>	}</code></span>
<span class="codeline" id="line-2058"><code></code></span>
<span class="codeline" id="line-2059"><code>	type result struct {</code></span>
<span class="codeline" id="line-2060"><code>		r   driver.Result</code></span>
<span class="codeline" id="line-2061"><code>		err error</code></span>
<span class="codeline" id="line-2062"><code>	}</code></span>
<span class="codeline" id="line-2063"><code>	resultCh := make(chan result)</code></span>
<span class="codeline" id="line-2064"><code>	defer close(resultCh)</code></span>
<span class="codeline" id="line-2065"><code>	go func() {</code></span>
<span class="codeline" id="line-2066"><code>		r, err := s.execSync(args)</code></span>
<span class="codeline" id="line-2067"><code>		resultCh &lt;- result{r, err}</code></span>
<span class="codeline" id="line-2068"><code>	}()</code></span>
<span class="codeline" id="line-2069"><code>	var rv result</code></span>
<span class="codeline" id="line-2070"><code>	select {</code></span>
<span class="codeline" id="line-2071"><code>	case rv = &lt;-resultCh:</code></span>
<span class="codeline" id="line-2072"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-2073"><code>		select {</code></span>
<span class="codeline" id="line-2074"><code>		case rv = &lt;-resultCh: // no need to interrupt, operation completed in db</code></span>
<span class="codeline" id="line-2075"><code>		default:</code></span>
<span class="codeline" id="line-2076"><code>			// this is still racy and can be no-op if executed between sqlite3_* calls in execSync.</code></span>
<span class="codeline" id="line-2077"><code>			func() { _cgo0 := /*line :2076:24*/s.c.db; _cgoCheckPointer(_cgo0, nil); /*line :2076:31*/_Cfunc_sqlite3_interrupt(_cgo0); }()</code></span>
<span class="codeline" id="line-2078"><code>			rv = &lt;-resultCh // wait for goroutine completed</code></span>
<span class="codeline" id="line-2079"><code>			if isInterruptErr(rv.err) {</code></span>
<span class="codeline" id="line-2080"><code>				return nil, ctx.Err()</code></span>
<span class="codeline" id="line-2081"><code>			}</code></span>
<span class="codeline" id="line-2082"><code>		}</code></span>
<span class="codeline" id="line-2083"><code>	}</code></span>
<span class="codeline" id="line-2084"><code>	return rv.r, rv.err</code></span>
<span class="codeline" id="line-2085"><code>}</code></span>
<span class="codeline" id="line-2086"><code></code></span>
<span class="codeline" id="line-2087"><code>func (s *SQLiteStmt) execSync(args []driver.NamedValue) (driver.Result, error) {</code></span>
<span class="codeline" id="line-2088"><code>	if err := s.bind(args); err != nil {</code></span>
<span class="codeline" id="line-2089"><code>		func() _Ctype_int{ _cgo0 := /*line :2088:19*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2088:23*/_Cfunc_sqlite3_reset(_cgo0); }()</code></span>
<span class="codeline" id="line-2090"><code>		func() _Ctype_int{ _cgo0 := /*line :2089:28*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2089:32*/_Cfunc_sqlite3_clear_bindings(_cgo0); }()</code></span>
<span class="codeline" id="line-2091"><code>		return nil, err</code></span>
<span class="codeline" id="line-2092"><code>	}</code></span>
<span class="codeline" id="line-2093"><code></code></span>
<span class="codeline" id="line-2094"><code>	var rowid, changes  /*line :2093:21*/_Ctype_longlong /*line :2093:31*/</code></span>
<span class="codeline" id="line-2095"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :2094:37*/s.s; var _cgo1 *_Ctype_longlong = /*line :2094:42*/&amp;rowid; var _cgo2 *_Ctype_longlong = /*line :2094:50*/&amp;changes; _cgoCheckPointer(_cgo0, nil); return /*line :2094:59*/_Cfunc__sqlite3_step_row_internal(_cgo0, _cgo1, _cgo2); }()</code></span>
<span class="codeline" id="line-2096"><code>	if rv != ( /*line :2095:11*/_Ciconst_SQLITE_ROW /*line :2095:22*/) &amp;&amp; rv != ( /*line :2095:33*/_Ciconst_SQLITE_OK /*line :2095:43*/) &amp;&amp; rv != ( /*line :2095:54*/_Ciconst_SQLITE_DONE /*line :2095:66*/) {</code></span>
<span class="codeline" id="line-2097"><code>		err := s.c.lastError()</code></span>
<span class="codeline" id="line-2098"><code>		func() _Ctype_int{ _cgo0 := /*line :2097:19*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2097:23*/_Cfunc_sqlite3_reset(_cgo0); }()</code></span>
<span class="codeline" id="line-2099"><code>		func() _Ctype_int{ _cgo0 := /*line :2098:28*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2098:32*/_Cfunc_sqlite3_clear_bindings(_cgo0); }()</code></span>
<span class="codeline" id="line-2100"><code>		return nil, err</code></span>
<span class="codeline" id="line-2101"><code>	}</code></span>
<span class="codeline" id="line-2102"><code></code></span>
<span class="codeline" id="line-2103"><code>	return &amp;SQLiteResult{id: int64(rowid), changes: int64(changes)}, nil</code></span>
<span class="codeline" id="line-2104"><code>}</code></span>
<span class="codeline" id="line-2105"><code></code></span>
<span class="codeline" id="line-2106"><code>// Readonly reports if this statement is considered readonly by SQLite.</code></span>
<span class="codeline" id="line-2107"><code>//</code></span>
<span class="codeline" id="line-2108"><code>// See: https://sqlite.org/c3ref/stmt_readonly.html</code></span>
<span class="codeline" id="line-2109"><code>func (s *SQLiteStmt) Readonly() bool {</code></span>
<span class="codeline" id="line-2110"><code>	return func() _Ctype_int{ _cgo0 := /*line :2109:33*/s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2109:37*/_Cfunc_sqlite3_stmt_readonly(_cgo0); }() == 1</code></span>
<span class="codeline" id="line-2111"><code>}</code></span>
<span class="codeline" id="line-2112"><code></code></span>
<span class="codeline" id="line-2113"><code>// Close the rows.</code></span>
<span class="codeline" id="line-2114"><code>func (rc *SQLiteRows) Close() error {</code></span>
<span class="codeline" id="line-2115"><code>	rc.s.mu.Lock()</code></span>
<span class="codeline" id="line-2116"><code>	if rc.s.closed || rc.closed {</code></span>
<span class="codeline" id="line-2117"><code>		rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2118"><code>		return nil</code></span>
<span class="codeline" id="line-2119"><code>	}</code></span>
<span class="codeline" id="line-2120"><code>	rc.closed = true</code></span>
<span class="codeline" id="line-2121"><code>	if rc.cls {</code></span>
<span class="codeline" id="line-2122"><code>		rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2123"><code>		return rc.s.Close()</code></span>
<span class="codeline" id="line-2124"><code>	}</code></span>
<span class="codeline" id="line-2125"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :2124:24*/rc.s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2124:31*/_Cfunc_sqlite3_reset(_cgo0); }()</code></span>
<span class="codeline" id="line-2126"><code>	if rv != ( /*line :2125:11*/_Ciconst_SQLITE_OK /*line :2125:21*/) {</code></span>
<span class="codeline" id="line-2127"><code>		rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2128"><code>		return rc.s.c.lastError()</code></span>
<span class="codeline" id="line-2129"><code>	}</code></span>
<span class="codeline" id="line-2130"><code>	rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2131"><code>	rc.s = nil</code></span>
<span class="codeline" id="line-2132"><code>	runtime.SetFinalizer(rc, nil)</code></span>
<span class="codeline" id="line-2133"><code>	return nil</code></span>
<span class="codeline" id="line-2134"><code>}</code></span>
<span class="codeline" id="line-2135"><code></code></span>
<span class="codeline" id="line-2136"><code>// Columns return column names.</code></span>
<span class="codeline" id="line-2137"><code>func (rc *SQLiteRows) Columns() []string {</code></span>
<span class="codeline" id="line-2138"><code>	rc.s.mu.Lock()</code></span>
<span class="codeline" id="line-2139"><code>	defer rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2140"><code>	if rc.s.s != nil &amp;&amp; rc.nc != len(rc.cols) {</code></span>
<span class="codeline" id="line-2141"><code>		rc.cols = make([]string, rc.nc)</code></span>
<span class="codeline" id="line-2142"><code>		for i := 0; i &lt; rc.nc; i++ {</code></span>
<span class="codeline" id="line-2143"><code>			rc.cols[i] = ( /*line :2142:17*/_Cfunc_GoString /*line :2142:26*/)(func() *_Ctype_char{ _cgo0 := /*line :2142:50*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2142:63*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2142:67*/_Cfunc_sqlite3_column_name(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-2144"><code>		}</code></span>
<span class="codeline" id="line-2145"><code>	}</code></span>
<span class="codeline" id="line-2146"><code>	return rc.cols</code></span>
<span class="codeline" id="line-2147"><code>}</code></span>
<span class="codeline" id="line-2148"><code></code></span>
<span class="codeline" id="line-2149"><code>func (rc *SQLiteRows) declTypes() []string {</code></span>
<span class="codeline" id="line-2150"><code>	if rc.s.s != nil &amp;&amp; rc.decltype == nil {</code></span>
<span class="codeline" id="line-2151"><code>		rc.decltype = make([]string, rc.nc)</code></span>
<span class="codeline" id="line-2152"><code>		for i := 0; i &lt; rc.nc; i++ {</code></span>
<span class="codeline" id="line-2153"><code>			rc.decltype[i] = strings.ToLower(( /*line :2152:37*/_Cfunc_GoString /*line :2152:46*/)(func() *_Ctype_char{ _cgo0 := /*line :2152:74*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2152:87*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2152:91*/_Cfunc_sqlite3_column_decltype(_cgo0, _cgo1); }()))</code></span>
<span class="codeline" id="line-2154"><code>		}</code></span>
<span class="codeline" id="line-2155"><code>	}</code></span>
<span class="codeline" id="line-2156"><code>	return rc.decltype</code></span>
<span class="codeline" id="line-2157"><code>}</code></span>
<span class="codeline" id="line-2158"><code></code></span>
<span class="codeline" id="line-2159"><code>// DeclTypes return column types.</code></span>
<span class="codeline" id="line-2160"><code>func (rc *SQLiteRows) DeclTypes() []string {</code></span>
<span class="codeline" id="line-2161"><code>	rc.s.mu.Lock()</code></span>
<span class="codeline" id="line-2162"><code>	defer rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2163"><code>	return rc.declTypes()</code></span>
<span class="codeline" id="line-2164"><code>}</code></span>
<span class="codeline" id="line-2165"><code></code></span>
<span class="codeline" id="line-2166"><code>// Next move cursor to next. Attempts to honor context timeout from QueryContext call.</code></span>
<span class="codeline" id="line-2167"><code>func (rc *SQLiteRows) Next(dest []driver.Value) error {</code></span>
<span class="codeline" id="line-2168"><code>	rc.s.mu.Lock()</code></span>
<span class="codeline" id="line-2169"><code>	defer rc.s.mu.Unlock()</code></span>
<span class="codeline" id="line-2170"><code></code></span>
<span class="codeline" id="line-2171"><code>	if rc.s.closed {</code></span>
<span class="codeline" id="line-2172"><code>		return io.EOF</code></span>
<span class="codeline" id="line-2173"><code>	}</code></span>
<span class="codeline" id="line-2174"><code></code></span>
<span class="codeline" id="line-2175"><code>	if rc.ctx.Done() == nil {</code></span>
<span class="codeline" id="line-2176"><code>		return rc.nextSyncLocked(dest)</code></span>
<span class="codeline" id="line-2177"><code>	}</code></span>
<span class="codeline" id="line-2178"><code>	resultCh := make(chan error)</code></span>
<span class="codeline" id="line-2179"><code>	defer close(resultCh)</code></span>
<span class="codeline" id="line-2180"><code>	go func() {</code></span>
<span class="codeline" id="line-2181"><code>		resultCh &lt;- rc.nextSyncLocked(dest)</code></span>
<span class="codeline" id="line-2182"><code>	}()</code></span>
<span class="codeline" id="line-2183"><code>	select {</code></span>
<span class="codeline" id="line-2184"><code>	case err := &lt;-resultCh:</code></span>
<span class="codeline" id="line-2185"><code>		return err</code></span>
<span class="codeline" id="line-2186"><code>	case &lt;-rc.ctx.Done():</code></span>
<span class="codeline" id="line-2187"><code>		select {</code></span>
<span class="codeline" id="line-2188"><code>		case &lt;-resultCh: // no need to interrupt</code></span>
<span class="codeline" id="line-2189"><code>		default:</code></span>
<span class="codeline" id="line-2190"><code>			// this is still racy and can be no-op if executed between sqlite3_* calls in nextSyncLocked.</code></span>
<span class="codeline" id="line-2191"><code>			func() { _cgo0 := /*line :2190:24*/rc.s.c.db; _cgoCheckPointer(_cgo0, nil); /*line :2190:34*/_Cfunc_sqlite3_interrupt(_cgo0); }()</code></span>
<span class="codeline" id="line-2192"><code>			&lt;-resultCh // ensure goroutine completed</code></span>
<span class="codeline" id="line-2193"><code>		}</code></span>
<span class="codeline" id="line-2194"><code>		return rc.ctx.Err()</code></span>
<span class="codeline" id="line-2195"><code>	}</code></span>
<span class="codeline" id="line-2196"><code>}</code></span>
<span class="codeline" id="line-2197"><code></code></span>
<span class="codeline" id="line-2198"><code>// nextSyncLocked moves cursor to next; must be called with locked mutex.</code></span>
<span class="codeline" id="line-2199"><code>func (rc *SQLiteRows) nextSyncLocked(dest []driver.Value) error {</code></span>
<span class="codeline" id="line-2200"><code>	rv := func() _Ctype_int{ _cgo0 := /*line :2199:33*/rc.s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2199:40*/_Cfunc__sqlite3_step_internal(_cgo0); }()</code></span>
<span class="codeline" id="line-2201"><code>	if rv == ( /*line :2200:11*/_Ciconst_SQLITE_DONE /*line :2200:23*/) {</code></span>
<span class="codeline" id="line-2202"><code>		return io.EOF</code></span>
<span class="codeline" id="line-2203"><code>	}</code></span>
<span class="codeline" id="line-2204"><code>	if rv != ( /*line :2203:11*/_Ciconst_SQLITE_ROW /*line :2203:22*/) {</code></span>
<span class="codeline" id="line-2205"><code>		rv = func() _Ctype_int{ _cgo0 := /*line :2204:24*/rc.s.s; _cgoCheckPointer(_cgo0, nil); return /*line :2204:31*/_Cfunc_sqlite3_reset(_cgo0); }()</code></span>
<span class="codeline" id="line-2206"><code>		if rv != ( /*line :2205:12*/_Ciconst_SQLITE_OK /*line :2205:22*/) {</code></span>
<span class="codeline" id="line-2207"><code>			return rc.s.c.lastError()</code></span>
<span class="codeline" id="line-2208"><code>		}</code></span>
<span class="codeline" id="line-2209"><code>		return nil</code></span>
<span class="codeline" id="line-2210"><code>	}</code></span>
<span class="codeline" id="line-2211"><code></code></span>
<span class="codeline" id="line-2212"><code>	rc.declTypes()</code></span>
<span class="codeline" id="line-2213"><code></code></span>
<span class="codeline" id="line-2214"><code>	for i := range dest {</code></span>
<span class="codeline" id="line-2215"><code>		switch func() _Ctype_int{ _cgo0 := /*line :2214:32*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2214:45*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2214:49*/_Cfunc_sqlite3_column_type(_cgo0, _cgo1); }() {</code></span>
<span class="codeline" id="line-2216"><code>		case ( /*line :2215:8*/_Ciconst_SQLITE_INTEGER /*line :2215:23*/):</code></span>
<span class="codeline" id="line-2217"><code>			val := int64(func() _Ctype_sqlite3_int64{ _cgo0 := /*line :2216:40*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2216:53*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2216:57*/_Cfunc_sqlite3_column_int64(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-2218"><code>			switch rc.decltype[i] {</code></span>
<span class="codeline" id="line-2219"><code>			case columnTimestamp, columnDatetime, columnDate:</code></span>
<span class="codeline" id="line-2220"><code>				var t time.Time</code></span>
<span class="codeline" id="line-2221"><code>				// Assume a millisecond unix timestamp if it's 13 digits -- too</code></span>
<span class="codeline" id="line-2222"><code>				// large to be a reasonable timestamp in seconds.</code></span>
<span class="codeline" id="line-2223"><code>				if val &gt; 1e12 || val &lt; -1e12 {</code></span>
<span class="codeline" id="line-2224"><code>					val *= int64(time.Millisecond) // convert ms to nsec</code></span>
<span class="codeline" id="line-2225"><code>					t = time.Unix(0, val)</code></span>
<span class="codeline" id="line-2226"><code>				} else {</code></span>
<span class="codeline" id="line-2227"><code>					t = time.Unix(val, 0)</code></span>
<span class="codeline" id="line-2228"><code>				}</code></span>
<span class="codeline" id="line-2229"><code>				t = t.UTC()</code></span>
<span class="codeline" id="line-2230"><code>				if rc.s.c.loc != nil {</code></span>
<span class="codeline" id="line-2231"><code>					t = t.In(rc.s.c.loc)</code></span>
<span class="codeline" id="line-2232"><code>				}</code></span>
<span class="codeline" id="line-2233"><code>				dest[i] = t</code></span>
<span class="codeline" id="line-2234"><code>			case "boolean":</code></span>
<span class="codeline" id="line-2235"><code>				dest[i] = val &gt; 0</code></span>
<span class="codeline" id="line-2236"><code>			default:</code></span>
<span class="codeline" id="line-2237"><code>				dest[i] = val</code></span>
<span class="codeline" id="line-2238"><code>			}</code></span>
<span class="codeline" id="line-2239"><code>		case ( /*line :2238:8*/_Ciconst_SQLITE_FLOAT /*line :2238:21*/):</code></span>
<span class="codeline" id="line-2240"><code>			dest[i] = float64(func() _Ctype_double{ _cgo0 := /*line :2239:46*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2239:59*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2239:63*/_Cfunc_sqlite3_column_double(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-2241"><code>		case ( /*line :2240:8*/_Ciconst_SQLITE_BLOB /*line :2240:20*/):</code></span>
<span class="codeline" id="line-2242"><code>			p := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :2241:31*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2241:44*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2241:48*/_Cfunc_sqlite3_column_blob(_cgo0, _cgo1); }()</code></span>
<span class="codeline" id="line-2243"><code>			if p == nil {</code></span>
<span class="codeline" id="line-2244"><code>				dest[i] = []byte{}</code></span>
<span class="codeline" id="line-2245"><code>				continue</code></span>
<span class="codeline" id="line-2246"><code>			}</code></span>
<span class="codeline" id="line-2247"><code>			n := func() _Ctype_int{ _cgo0 := /*line :2246:32*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2246:45*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2246:49*/_Cfunc_sqlite3_column_bytes(_cgo0, _cgo1); }()</code></span>
<span class="codeline" id="line-2248"><code>			dest[i] = func() []byte{ _cgo0 := /*line :2247:24*/p; var _cgo1 _Ctype_int = /*line :2247:27*/n; _cgoCheckPointer(_cgo0, nil); return /*line :2247:29*/_Cfunc_GoBytes(_cgo0, _cgo1); }()</code></span>
<span class="codeline" id="line-2249"><code>		case ( /*line :2248:8*/_Ciconst_SQLITE_NULL /*line :2248:20*/):</code></span>
<span class="codeline" id="line-2250"><code>			dest[i] = nil</code></span>
<span class="codeline" id="line-2251"><code>		case ( /*line :2250:8*/_Ciconst_SQLITE_TEXT /*line :2250:20*/):</code></span>
<span class="codeline" id="line-2252"><code>			var err error</code></span>
<span class="codeline" id="line-2253"><code>			var timeVal time.Time</code></span>
<span class="codeline" id="line-2254"><code></code></span>
<span class="codeline" id="line-2255"><code>			n := int(func() _Ctype_int{ _cgo0 := /*line :2254:36*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2254:49*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2254:53*/_Cfunc_sqlite3_column_bytes(_cgo0, _cgo1); }())</code></span>
<span class="codeline" id="line-2256"><code>			s := ( /*line :2255:9*/_Cfunc_GoStringN /*line :2255:19*/)((* /*line :2255:23*/_Ctype_char /*line :2255:29*/)(unsafe.Pointer(func() *_Ctype_uchar{ _cgo0 := /*line :2255:68*/rc.s.s; var _cgo1 _Ctype_int = _Ctype_int /*line :2255:81*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :2255:85*/_Cfunc_sqlite3_column_text(_cgo0, _cgo1); }())),  /*line :2255:89*/_Ctype_int /*line :2255:94*/(n))</code></span>
<span class="codeline" id="line-2257"><code></code></span>
<span class="codeline" id="line-2258"><code>			switch rc.decltype[i] {</code></span>
<span class="codeline" id="line-2259"><code>			case columnTimestamp, columnDatetime, columnDate:</code></span>
<span class="codeline" id="line-2260"><code>				var t time.Time</code></span>
<span class="codeline" id="line-2261"><code>				s = strings.TrimSuffix(s, "Z")</code></span>
<span class="codeline" id="line-2262"><code>				for _, format := range SQLiteTimestampFormats {</code></span>
<span class="codeline" id="line-2263"><code>					if timeVal, err = time.ParseInLocation(format, s, time.UTC); err == nil {</code></span>
<span class="codeline" id="line-2264"><code>						t = timeVal</code></span>
<span class="codeline" id="line-2265"><code>						break</code></span>
<span class="codeline" id="line-2266"><code>					}</code></span>
<span class="codeline" id="line-2267"><code>				}</code></span>
<span class="codeline" id="line-2268"><code>				if err != nil {</code></span>
<span class="codeline" id="line-2269"><code>					// The column is a time value, so return the zero time on parse failure.</code></span>
<span class="codeline" id="line-2270"><code>					t = time.Time{}</code></span>
<span class="codeline" id="line-2271"><code>				}</code></span>
<span class="codeline" id="line-2272"><code>				if rc.s.c.loc != nil {</code></span>
<span class="codeline" id="line-2273"><code>					t = t.In(rc.s.c.loc)</code></span>
<span class="codeline" id="line-2274"><code>				}</code></span>
<span class="codeline" id="line-2275"><code>				dest[i] = t</code></span>
<span class="codeline" id="line-2276"><code>			default:</code></span>
<span class="codeline" id="line-2277"><code>				dest[i] = s</code></span>
<span class="codeline" id="line-2278"><code>			}</code></span>
<span class="codeline" id="line-2279"><code>		}</code></span>
<span class="codeline" id="line-2280"><code>	}</code></span>
<span class="codeline" id="line-2281"><code>	return nil</code></span>
<span class="codeline" id="line-2282"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>