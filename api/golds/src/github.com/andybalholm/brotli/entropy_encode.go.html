<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: entropy_encode.go in package github.com/andybalholm/brotli</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	entropy_encode.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/andybalholm/brotli.html">github.com/andybalholm/brotli</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package brotli</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import "math"</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>/* Copyright 2010 Google Inc. All Rights Reserved.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>   Distributed under MIT license.</code></span>
<span class="codeline" id="line-8"><code>   See file LICENSE for detail or copy at https://opensource.org/licenses/MIT</code></span>
<span class="codeline" id="line-9"><code>*/</code></span>
<span class="codeline" id="line-10"><code></code></span>
<span class="codeline" id="line-11"><code>/* Entropy encoding (Huffman) utilities. */</code></span>
<span class="codeline" id="line-12"><code></code></span>
<span class="codeline" id="line-13"><code>/* A node of a Huffman tree. */</code></span>
<span class="codeline" id="line-14"><code>type huffmanTree struct {</code></span>
<span class="codeline" id="line-15"><code>	total_count_          uint32</code></span>
<span class="codeline" id="line-16"><code>	index_left_           int16</code></span>
<span class="codeline" id="line-17"><code>	index_right_or_value_ int16</code></span>
<span class="codeline" id="line-18"><code>}</code></span>
<span class="codeline" id="line-19"><code></code></span>
<span class="codeline" id="line-20"><code>func initHuffmanTree(self *huffmanTree, count uint32, left int16, right int16) {</code></span>
<span class="codeline" id="line-21"><code>	self.total_count_ = count</code></span>
<span class="codeline" id="line-22"><code>	self.index_left_ = left</code></span>
<span class="codeline" id="line-23"><code>	self.index_right_or_value_ = right</code></span>
<span class="codeline" id="line-24"><code>}</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>/* Input size optimized Shell sort. */</code></span>
<span class="codeline" id="line-27"><code>type huffmanTreeComparator func(huffmanTree, huffmanTree) bool</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>var sortHuffmanTreeItems_gaps = []uint{132, 57, 23, 10, 4, 1}</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>func sortHuffmanTreeItems(items []huffmanTree, n uint, comparator huffmanTreeComparator) {</code></span>
<span class="codeline" id="line-32"><code>	if n &lt; 13 {</code></span>
<span class="codeline" id="line-33"><code>		/* Insertion sort. */</code></span>
<span class="codeline" id="line-34"><code>		var i uint</code></span>
<span class="codeline" id="line-35"><code>		for i = 1; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-36"><code>			var tmp huffmanTree = items[i]</code></span>
<span class="codeline" id="line-37"><code>			var k uint = i</code></span>
<span class="codeline" id="line-38"><code>			var j uint = i - 1</code></span>
<span class="codeline" id="line-39"><code>			for comparator(tmp, items[j]) {</code></span>
<span class="codeline" id="line-40"><code>				items[k] = items[j]</code></span>
<span class="codeline" id="line-41"><code>				k = j</code></span>
<span class="codeline" id="line-42"><code>				if j == 0 {</code></span>
<span class="codeline" id="line-43"><code>					break</code></span>
<span class="codeline" id="line-44"><code>				}</code></span>
<span class="codeline" id="line-45"><code>				j--</code></span>
<span class="codeline" id="line-46"><code>			}</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>			items[k] = tmp</code></span>
<span class="codeline" id="line-49"><code>		}</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>		return</code></span>
<span class="codeline" id="line-52"><code>	} else {</code></span>
<span class="codeline" id="line-53"><code>		var g int</code></span>
<span class="codeline" id="line-54"><code>		if n &lt; 57 {</code></span>
<span class="codeline" id="line-55"><code>			g = 2</code></span>
<span class="codeline" id="line-56"><code>		} else {</code></span>
<span class="codeline" id="line-57"><code>			g = 0</code></span>
<span class="codeline" id="line-58"><code>		}</code></span>
<span class="codeline" id="line-59"><code>		for ; g &lt; 6; g++ {</code></span>
<span class="codeline" id="line-60"><code>			var gap uint = sortHuffmanTreeItems_gaps[g]</code></span>
<span class="codeline" id="line-61"><code>			var i uint</code></span>
<span class="codeline" id="line-62"><code>			for i = gap; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-63"><code>				var j uint = i</code></span>
<span class="codeline" id="line-64"><code>				var tmp huffmanTree = items[i]</code></span>
<span class="codeline" id="line-65"><code>				for ; j &gt;= gap &amp;&amp; comparator(tmp, items[j-gap]); j -= gap {</code></span>
<span class="codeline" id="line-66"><code>					items[j] = items[j-gap]</code></span>
<span class="codeline" id="line-67"><code>				}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>				items[j] = tmp</code></span>
<span class="codeline" id="line-70"><code>			}</code></span>
<span class="codeline" id="line-71"><code>		}</code></span>
<span class="codeline" id="line-72"><code>	}</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>/* Returns 1 if assignment of depths succeeded, otherwise 0. */</code></span>
<span class="codeline" id="line-76"><code>func setDepth(p0 int, pool []huffmanTree, depth []byte, max_depth int) bool {</code></span>
<span class="codeline" id="line-77"><code>	var stack [16]int</code></span>
<span class="codeline" id="line-78"><code>	var level int = 0</code></span>
<span class="codeline" id="line-79"><code>	var p int = p0</code></span>
<span class="codeline" id="line-80"><code>	assert(max_depth &lt;= 15)</code></span>
<span class="codeline" id="line-81"><code>	stack[0] = -1</code></span>
<span class="codeline" id="line-82"><code>	for {</code></span>
<span class="codeline" id="line-83"><code>		if pool[p].index_left_ &gt;= 0 {</code></span>
<span class="codeline" id="line-84"><code>			level++</code></span>
<span class="codeline" id="line-85"><code>			if level &gt; max_depth {</code></span>
<span class="codeline" id="line-86"><code>				return false</code></span>
<span class="codeline" id="line-87"><code>			}</code></span>
<span class="codeline" id="line-88"><code>			stack[level] = int(pool[p].index_right_or_value_)</code></span>
<span class="codeline" id="line-89"><code>			p = int(pool[p].index_left_)</code></span>
<span class="codeline" id="line-90"><code>			continue</code></span>
<span class="codeline" id="line-91"><code>		} else {</code></span>
<span class="codeline" id="line-92"><code>			depth[pool[p].index_right_or_value_] = byte(level)</code></span>
<span class="codeline" id="line-93"><code>		}</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>		for level &gt;= 0 &amp;&amp; stack[level] == -1 {</code></span>
<span class="codeline" id="line-96"><code>			level--</code></span>
<span class="codeline" id="line-97"><code>		}</code></span>
<span class="codeline" id="line-98"><code>		if level &lt; 0 {</code></span>
<span class="codeline" id="line-99"><code>			return true</code></span>
<span class="codeline" id="line-100"><code>		}</code></span>
<span class="codeline" id="line-101"><code>		p = stack[level]</code></span>
<span class="codeline" id="line-102"><code>		stack[level] = -1</code></span>
<span class="codeline" id="line-103"><code>	}</code></span>
<span class="codeline" id="line-104"><code>}</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>/* Sort the root nodes, least popular first. */</code></span>
<span class="codeline" id="line-107"><code>func sortHuffmanTree(v0 huffmanTree, v1 huffmanTree) bool {</code></span>
<span class="codeline" id="line-108"><code>	if v0.total_count_ != v1.total_count_ {</code></span>
<span class="codeline" id="line-109"><code>		return v0.total_count_ &lt; v1.total_count_</code></span>
<span class="codeline" id="line-110"><code>	}</code></span>
<span class="codeline" id="line-111"><code></code></span>
<span class="codeline" id="line-112"><code>	return v0.index_right_or_value_ &gt; v1.index_right_or_value_</code></span>
<span class="codeline" id="line-113"><code>}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>/* This function will create a Huffman tree.</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>   The catch here is that the tree cannot be arbitrarily deep.</code></span>
<span class="codeline" id="line-118"><code>   Brotli specifies a maximum depth of 15 bits for "code trees"</code></span>
<span class="codeline" id="line-119"><code>   and 7 bits for "code length code trees."</code></span>
<span class="codeline" id="line-120"><code></code></span>
<span class="codeline" id="line-121"><code>   count_limit is the value that is to be faked as the minimum value</code></span>
<span class="codeline" id="line-122"><code>   and this minimum value is raised until the tree matches the</code></span>
<span class="codeline" id="line-123"><code>   maximum length requirement.</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>   This algorithm is not of excellent performance for very long data blocks,</code></span>
<span class="codeline" id="line-126"><code>   especially when population counts are longer than 2**tree_limit, but</code></span>
<span class="codeline" id="line-127"><code>   we are not planning to use this with extremely long blocks.</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>   See http://en.wikipedia.org/wiki/Huffman_coding */</code></span>
<span class="codeline" id="line-130"><code>func createHuffmanTree(data []uint32, length uint, tree_limit int, tree []huffmanTree, depth []byte) {</code></span>
<span class="codeline" id="line-131"><code>	var count_limit uint32</code></span>
<span class="codeline" id="line-132"><code>	var sentinel huffmanTree</code></span>
<span class="codeline" id="line-133"><code>	initHuffmanTree(&amp;sentinel, math.MaxUint32, -1, -1)</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>	/* For block sizes below 64 kB, we never need to do a second iteration</code></span>
<span class="codeline" id="line-136"><code>	   of this loop. Probably all of our block sizes will be smaller than</code></span>
<span class="codeline" id="line-137"><code>	   that, so this loop is mostly of academic interest. If we actually</code></span>
<span class="codeline" id="line-138"><code>	   would need this, we would be better off with the Katajainen algorithm. */</code></span>
<span class="codeline" id="line-139"><code>	for count_limit = 1; ; count_limit *= 2 {</code></span>
<span class="codeline" id="line-140"><code>		var n uint = 0</code></span>
<span class="codeline" id="line-141"><code>		var i uint</code></span>
<span class="codeline" id="line-142"><code>		var j uint</code></span>
<span class="codeline" id="line-143"><code>		var k uint</code></span>
<span class="codeline" id="line-144"><code>		for i = length; i != 0; {</code></span>
<span class="codeline" id="line-145"><code>			i--</code></span>
<span class="codeline" id="line-146"><code>			if data[i] != 0 {</code></span>
<span class="codeline" id="line-147"><code>				var count uint32 = brotli_max_uint32_t(data[i], count_limit)</code></span>
<span class="codeline" id="line-148"><code>				initHuffmanTree(&amp;tree[n], count, -1, int16(i))</code></span>
<span class="codeline" id="line-149"><code>				n++</code></span>
<span class="codeline" id="line-150"><code>			}</code></span>
<span class="codeline" id="line-151"><code>		}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>		if n == 1 {</code></span>
<span class="codeline" id="line-154"><code>			depth[tree[0].index_right_or_value_] = 1 /* Only one element. */</code></span>
<span class="codeline" id="line-155"><code>			break</code></span>
<span class="codeline" id="line-156"><code>		}</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>		sortHuffmanTreeItems(tree, n, huffmanTreeComparator(sortHuffmanTree))</code></span>
<span class="codeline" id="line-159"><code></code></span>
<span class="codeline" id="line-160"><code>		/* The nodes are:</code></span>
<span class="codeline" id="line-161"><code>		   [0, n): the sorted leaf nodes that we start with.</code></span>
<span class="codeline" id="line-162"><code>		   [n]: we add a sentinel here.</code></span>
<span class="codeline" id="line-163"><code>		   [n + 1, 2n): new parent nodes are added here, starting from</code></span>
<span class="codeline" id="line-164"><code>		                (n+1). These are naturally in ascending order.</code></span>
<span class="codeline" id="line-165"><code>		   [2n]: we add a sentinel at the end as well.</code></span>
<span class="codeline" id="line-166"><code>		   There will be (2n+1) elements at the end. */</code></span>
<span class="codeline" id="line-167"><code>		tree[n] = sentinel</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>		tree[n+1] = sentinel</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>		i = 0     /* Points to the next leaf node. */</code></span>
<span class="codeline" id="line-172"><code>		j = n + 1 /* Points to the next non-leaf node. */</code></span>
<span class="codeline" id="line-173"><code>		for k = n - 1; k != 0; k-- {</code></span>
<span class="codeline" id="line-174"><code>			var left uint</code></span>
<span class="codeline" id="line-175"><code>			var right uint</code></span>
<span class="codeline" id="line-176"><code>			if tree[i].total_count_ &lt;= tree[j].total_count_ {</code></span>
<span class="codeline" id="line-177"><code>				left = i</code></span>
<span class="codeline" id="line-178"><code>				i++</code></span>
<span class="codeline" id="line-179"><code>			} else {</code></span>
<span class="codeline" id="line-180"><code>				left = j</code></span>
<span class="codeline" id="line-181"><code>				j++</code></span>
<span class="codeline" id="line-182"><code>			}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>			if tree[i].total_count_ &lt;= tree[j].total_count_ {</code></span>
<span class="codeline" id="line-185"><code>				right = i</code></span>
<span class="codeline" id="line-186"><code>				i++</code></span>
<span class="codeline" id="line-187"><code>			} else {</code></span>
<span class="codeline" id="line-188"><code>				right = j</code></span>
<span class="codeline" id="line-189"><code>				j++</code></span>
<span class="codeline" id="line-190"><code>			}</code></span>
<span class="codeline" id="line-191"><code>			{</code></span>
<span class="codeline" id="line-192"><code>				/* The sentinel node becomes the parent node. */</code></span>
<span class="codeline" id="line-193"><code>				var j_end uint = 2*n - k</code></span>
<span class="codeline" id="line-194"><code>				tree[j_end].total_count_ = tree[left].total_count_ + tree[right].total_count_</code></span>
<span class="codeline" id="line-195"><code>				tree[j_end].index_left_ = int16(left)</code></span>
<span class="codeline" id="line-196"><code>				tree[j_end].index_right_or_value_ = int16(right)</code></span>
<span class="codeline" id="line-197"><code></code></span>
<span class="codeline" id="line-198"><code>				/* Add back the last sentinel node. */</code></span>
<span class="codeline" id="line-199"><code>				tree[j_end+1] = sentinel</code></span>
<span class="codeline" id="line-200"><code>			}</code></span>
<span class="codeline" id="line-201"><code>		}</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>		if setDepth(int(2*n-1), tree[0:], depth, tree_limit) {</code></span>
<span class="codeline" id="line-204"><code>			/* We need to pack the Huffman tree in tree_limit bits. If this was not</code></span>
<span class="codeline" id="line-205"><code>			   successful, add fake entities to the lowest values and retry. */</code></span>
<span class="codeline" id="line-206"><code>			break</code></span>
<span class="codeline" id="line-207"><code>		}</code></span>
<span class="codeline" id="line-208"><code>	}</code></span>
<span class="codeline" id="line-209"><code>}</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>func reverse(v []byte, start uint, end uint) {</code></span>
<span class="codeline" id="line-212"><code>	end--</code></span>
<span class="codeline" id="line-213"><code>	for start &lt; end {</code></span>
<span class="codeline" id="line-214"><code>		var tmp byte = v[start]</code></span>
<span class="codeline" id="line-215"><code>		v[start] = v[end]</code></span>
<span class="codeline" id="line-216"><code>		v[end] = tmp</code></span>
<span class="codeline" id="line-217"><code>		start++</code></span>
<span class="codeline" id="line-218"><code>		end--</code></span>
<span class="codeline" id="line-219"><code>	}</code></span>
<span class="codeline" id="line-220"><code>}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>func writeHuffmanTreeRepetitions(previous_value byte, value byte, repetitions uint, tree_size *uint, tree []byte, extra_bits_data []byte) {</code></span>
<span class="codeline" id="line-223"><code>	assert(repetitions &gt; 0)</code></span>
<span class="codeline" id="line-224"><code>	if previous_value != value {</code></span>
<span class="codeline" id="line-225"><code>		tree[*tree_size] = value</code></span>
<span class="codeline" id="line-226"><code>		extra_bits_data[*tree_size] = 0</code></span>
<span class="codeline" id="line-227"><code>		(*tree_size)++</code></span>
<span class="codeline" id="line-228"><code>		repetitions--</code></span>
<span class="codeline" id="line-229"><code>	}</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>	if repetitions == 7 {</code></span>
<span class="codeline" id="line-232"><code>		tree[*tree_size] = value</code></span>
<span class="codeline" id="line-233"><code>		extra_bits_data[*tree_size] = 0</code></span>
<span class="codeline" id="line-234"><code>		(*tree_size)++</code></span>
<span class="codeline" id="line-235"><code>		repetitions--</code></span>
<span class="codeline" id="line-236"><code>	}</code></span>
<span class="codeline" id="line-237"><code></code></span>
<span class="codeline" id="line-238"><code>	if repetitions &lt; 3 {</code></span>
<span class="codeline" id="line-239"><code>		var i uint</code></span>
<span class="codeline" id="line-240"><code>		for i = 0; i &lt; repetitions; i++ {</code></span>
<span class="codeline" id="line-241"><code>			tree[*tree_size] = value</code></span>
<span class="codeline" id="line-242"><code>			extra_bits_data[*tree_size] = 0</code></span>
<span class="codeline" id="line-243"><code>			(*tree_size)++</code></span>
<span class="codeline" id="line-244"><code>		}</code></span>
<span class="codeline" id="line-245"><code>	} else {</code></span>
<span class="codeline" id="line-246"><code>		var start uint = *tree_size</code></span>
<span class="codeline" id="line-247"><code>		repetitions -= 3</code></span>
<span class="codeline" id="line-248"><code>		for {</code></span>
<span class="codeline" id="line-249"><code>			tree[*tree_size] = repeatPreviousCodeLength</code></span>
<span class="codeline" id="line-250"><code>			extra_bits_data[*tree_size] = byte(repetitions &amp; 0x3)</code></span>
<span class="codeline" id="line-251"><code>			(*tree_size)++</code></span>
<span class="codeline" id="line-252"><code>			repetitions &gt;&gt;= 2</code></span>
<span class="codeline" id="line-253"><code>			if repetitions == 0 {</code></span>
<span class="codeline" id="line-254"><code>				break</code></span>
<span class="codeline" id="line-255"><code>			}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>			repetitions--</code></span>
<span class="codeline" id="line-258"><code>		}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>		reverse(tree, start, *tree_size)</code></span>
<span class="codeline" id="line-261"><code>		reverse(extra_bits_data, start, *tree_size)</code></span>
<span class="codeline" id="line-262"><code>	}</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>func writeHuffmanTreeRepetitionsZeros(repetitions uint, tree_size *uint, tree []byte, extra_bits_data []byte) {</code></span>
<span class="codeline" id="line-266"><code>	if repetitions == 11 {</code></span>
<span class="codeline" id="line-267"><code>		tree[*tree_size] = 0</code></span>
<span class="codeline" id="line-268"><code>		extra_bits_data[*tree_size] = 0</code></span>
<span class="codeline" id="line-269"><code>		(*tree_size)++</code></span>
<span class="codeline" id="line-270"><code>		repetitions--</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code></code></span>
<span class="codeline" id="line-273"><code>	if repetitions &lt; 3 {</code></span>
<span class="codeline" id="line-274"><code>		var i uint</code></span>
<span class="codeline" id="line-275"><code>		for i = 0; i &lt; repetitions; i++ {</code></span>
<span class="codeline" id="line-276"><code>			tree[*tree_size] = 0</code></span>
<span class="codeline" id="line-277"><code>			extra_bits_data[*tree_size] = 0</code></span>
<span class="codeline" id="line-278"><code>			(*tree_size)++</code></span>
<span class="codeline" id="line-279"><code>		}</code></span>
<span class="codeline" id="line-280"><code>	} else {</code></span>
<span class="codeline" id="line-281"><code>		var start uint = *tree_size</code></span>
<span class="codeline" id="line-282"><code>		repetitions -= 3</code></span>
<span class="codeline" id="line-283"><code>		for {</code></span>
<span class="codeline" id="line-284"><code>			tree[*tree_size] = repeatZeroCodeLength</code></span>
<span class="codeline" id="line-285"><code>			extra_bits_data[*tree_size] = byte(repetitions &amp; 0x7)</code></span>
<span class="codeline" id="line-286"><code>			(*tree_size)++</code></span>
<span class="codeline" id="line-287"><code>			repetitions &gt;&gt;= 3</code></span>
<span class="codeline" id="line-288"><code>			if repetitions == 0 {</code></span>
<span class="codeline" id="line-289"><code>				break</code></span>
<span class="codeline" id="line-290"><code>			}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code>			repetitions--</code></span>
<span class="codeline" id="line-293"><code>		}</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>		reverse(tree, start, *tree_size)</code></span>
<span class="codeline" id="line-296"><code>		reverse(extra_bits_data, start, *tree_size)</code></span>
<span class="codeline" id="line-297"><code>	}</code></span>
<span class="codeline" id="line-298"><code>}</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>/* Change the population counts in a way that the consequent</code></span>
<span class="codeline" id="line-301"><code>   Huffman tree compression, especially its RLE-part will be more</code></span>
<span class="codeline" id="line-302"><code>   likely to compress this data more efficiently.</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>   length contains the size of the histogram.</code></span>
<span class="codeline" id="line-305"><code>   counts contains the population counts.</code></span>
<span class="codeline" id="line-306"><code>   good_for_rle is a buffer of at least length size */</code></span>
<span class="codeline" id="line-307"><code>func optimizeHuffmanCountsForRLE(length uint, counts []uint32, good_for_rle []byte) {</code></span>
<span class="codeline" id="line-308"><code>	var nonzero_count uint = 0</code></span>
<span class="codeline" id="line-309"><code>	var stride uint</code></span>
<span class="codeline" id="line-310"><code>	var limit uint</code></span>
<span class="codeline" id="line-311"><code>	var sum uint</code></span>
<span class="codeline" id="line-312"><code>	var streak_limit uint = 1240</code></span>
<span class="codeline" id="line-313"><code>	var i uint</code></span>
<span class="codeline" id="line-314"><code>	/* Let's make the Huffman code more compatible with RLE encoding. */</code></span>
<span class="codeline" id="line-315"><code>	for i = 0; i &lt; length; i++ {</code></span>
<span class="codeline" id="line-316"><code>		if counts[i] != 0 {</code></span>
<span class="codeline" id="line-317"><code>			nonzero_count++</code></span>
<span class="codeline" id="line-318"><code>		}</code></span>
<span class="codeline" id="line-319"><code>	}</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>	if nonzero_count &lt; 16 {</code></span>
<span class="codeline" id="line-322"><code>		return</code></span>
<span class="codeline" id="line-323"><code>	}</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	for length != 0 &amp;&amp; counts[length-1] == 0 {</code></span>
<span class="codeline" id="line-326"><code>		length--</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code></code></span>
<span class="codeline" id="line-329"><code>	if length == 0 {</code></span>
<span class="codeline" id="line-330"><code>		return /* All zeros. */</code></span>
<span class="codeline" id="line-331"><code>	}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>	/* Now counts[0..length - 1] does not have trailing zeros. */</code></span>
<span class="codeline" id="line-334"><code>	{</code></span>
<span class="codeline" id="line-335"><code>		var nonzeros uint = 0</code></span>
<span class="codeline" id="line-336"><code>		var smallest_nonzero uint32 = 1 &lt;&lt; 30</code></span>
<span class="codeline" id="line-337"><code>		for i = 0; i &lt; length; i++ {</code></span>
<span class="codeline" id="line-338"><code>			if counts[i] != 0 {</code></span>
<span class="codeline" id="line-339"><code>				nonzeros++</code></span>
<span class="codeline" id="line-340"><code>				if smallest_nonzero &gt; counts[i] {</code></span>
<span class="codeline" id="line-341"><code>					smallest_nonzero = counts[i]</code></span>
<span class="codeline" id="line-342"><code>				}</code></span>
<span class="codeline" id="line-343"><code>			}</code></span>
<span class="codeline" id="line-344"><code>		}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>		if nonzeros &lt; 5 {</code></span>
<span class="codeline" id="line-347"><code>			/* Small histogram will model it well. */</code></span>
<span class="codeline" id="line-348"><code>			return</code></span>
<span class="codeline" id="line-349"><code>		}</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>		if smallest_nonzero &lt; 4 {</code></span>
<span class="codeline" id="line-352"><code>			var zeros uint = length - nonzeros</code></span>
<span class="codeline" id="line-353"><code>			if zeros &lt; 6 {</code></span>
<span class="codeline" id="line-354"><code>				for i = 1; i &lt; length-1; i++ {</code></span>
<span class="codeline" id="line-355"><code>					if counts[i-1] != 0 &amp;&amp; counts[i] == 0 &amp;&amp; counts[i+1] != 0 {</code></span>
<span class="codeline" id="line-356"><code>						counts[i] = 1</code></span>
<span class="codeline" id="line-357"><code>					}</code></span>
<span class="codeline" id="line-358"><code>				}</code></span>
<span class="codeline" id="line-359"><code>			}</code></span>
<span class="codeline" id="line-360"><code>		}</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>		if nonzeros &lt; 28 {</code></span>
<span class="codeline" id="line-363"><code>			return</code></span>
<span class="codeline" id="line-364"><code>		}</code></span>
<span class="codeline" id="line-365"><code>	}</code></span>
<span class="codeline" id="line-366"><code></code></span>
<span class="codeline" id="line-367"><code>	/* 2) Let's mark all population counts that already can be encoded</code></span>
<span class="codeline" id="line-368"><code>	   with an RLE code. */</code></span>
<span class="codeline" id="line-369"><code>	for i := 0; i &lt; int(length); i++ {</code></span>
<span class="codeline" id="line-370"><code>		good_for_rle[i] = 0</code></span>
<span class="codeline" id="line-371"><code>	}</code></span>
<span class="codeline" id="line-372"><code>	{</code></span>
<span class="codeline" id="line-373"><code>		var symbol uint32 = counts[0]</code></span>
<span class="codeline" id="line-374"><code>		/* Let's not spoil any of the existing good RLE codes.</code></span>
<span class="codeline" id="line-375"><code>		   Mark any seq of 0's that is longer as 5 as a good_for_rle.</code></span>
<span class="codeline" id="line-376"><code>		   Mark any seq of non-0's that is longer as 7 as a good_for_rle. */</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>		var step uint = 0</code></span>
<span class="codeline" id="line-379"><code>		for i = 0; i &lt;= length; i++ {</code></span>
<span class="codeline" id="line-380"><code>			if i == length || counts[i] != symbol {</code></span>
<span class="codeline" id="line-381"><code>				if (symbol == 0 &amp;&amp; step &gt;= 5) || (symbol != 0 &amp;&amp; step &gt;= 7) {</code></span>
<span class="codeline" id="line-382"><code>					var k uint</code></span>
<span class="codeline" id="line-383"><code>					for k = 0; k &lt; step; k++ {</code></span>
<span class="codeline" id="line-384"><code>						good_for_rle[i-k-1] = 1</code></span>
<span class="codeline" id="line-385"><code>					}</code></span>
<span class="codeline" id="line-386"><code>				}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>				step = 1</code></span>
<span class="codeline" id="line-389"><code>				if i != length {</code></span>
<span class="codeline" id="line-390"><code>					symbol = counts[i]</code></span>
<span class="codeline" id="line-391"><code>				}</code></span>
<span class="codeline" id="line-392"><code>			} else {</code></span>
<span class="codeline" id="line-393"><code>				step++</code></span>
<span class="codeline" id="line-394"><code>			}</code></span>
<span class="codeline" id="line-395"><code>		}</code></span>
<span class="codeline" id="line-396"><code>	}</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>	/* 3) Let's replace those population counts that lead to more RLE codes.</code></span>
<span class="codeline" id="line-399"><code>	   Math here is in 24.8 fixed point representation. */</code></span>
<span class="codeline" id="line-400"><code>	stride = 0</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>	limit = uint(256*(counts[0]+counts[1]+counts[2])/3 + 420)</code></span>
<span class="codeline" id="line-403"><code>	sum = 0</code></span>
<span class="codeline" id="line-404"><code>	for i = 0; i &lt;= length; i++ {</code></span>
<span class="codeline" id="line-405"><code>		if i == length || good_for_rle[i] != 0 || (i != 0 &amp;&amp; good_for_rle[i-1] != 0) || (256*counts[i]-uint32(limit)+uint32(streak_limit)) &gt;= uint32(2*streak_limit) {</code></span>
<span class="codeline" id="line-406"><code>			if stride &gt;= 4 || (stride &gt;= 3 &amp;&amp; sum == 0) {</code></span>
<span class="codeline" id="line-407"><code>				var k uint</code></span>
<span class="codeline" id="line-408"><code>				var count uint = (sum + stride/2) / stride</code></span>
<span class="codeline" id="line-409"><code>				/* The stride must end, collapse what we have, if we have enough (4). */</code></span>
<span class="codeline" id="line-410"><code>				if count == 0 {</code></span>
<span class="codeline" id="line-411"><code>					count = 1</code></span>
<span class="codeline" id="line-412"><code>				}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>				if sum == 0 {</code></span>
<span class="codeline" id="line-415"><code>					/* Don't make an all zeros stride to be upgraded to ones. */</code></span>
<span class="codeline" id="line-416"><code>					count = 0</code></span>
<span class="codeline" id="line-417"><code>				}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>				for k = 0; k &lt; stride; k++ {</code></span>
<span class="codeline" id="line-420"><code>					/* We don't want to change value at counts[i],</code></span>
<span class="codeline" id="line-421"><code>					   that is already belonging to the next stride. Thus - 1. */</code></span>
<span class="codeline" id="line-422"><code>					counts[i-k-1] = uint32(count)</code></span>
<span class="codeline" id="line-423"><code>				}</code></span>
<span class="codeline" id="line-424"><code>			}</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>			stride = 0</code></span>
<span class="codeline" id="line-427"><code>			sum = 0</code></span>
<span class="codeline" id="line-428"><code>			if i &lt; length-2 {</code></span>
<span class="codeline" id="line-429"><code>				/* All interesting strides have a count of at least 4, */</code></span>
<span class="codeline" id="line-430"><code>				/* at least when non-zeros. */</code></span>
<span class="codeline" id="line-431"><code>				limit = uint(256*(counts[i]+counts[i+1]+counts[i+2])/3 + 420)</code></span>
<span class="codeline" id="line-432"><code>			} else if i &lt; length {</code></span>
<span class="codeline" id="line-433"><code>				limit = uint(256 * counts[i])</code></span>
<span class="codeline" id="line-434"><code>			} else {</code></span>
<span class="codeline" id="line-435"><code>				limit = 0</code></span>
<span class="codeline" id="line-436"><code>			}</code></span>
<span class="codeline" id="line-437"><code>		}</code></span>
<span class="codeline" id="line-438"><code></code></span>
<span class="codeline" id="line-439"><code>		stride++</code></span>
<span class="codeline" id="line-440"><code>		if i != length {</code></span>
<span class="codeline" id="line-441"><code>			sum += uint(counts[i])</code></span>
<span class="codeline" id="line-442"><code>			if stride &gt;= 4 {</code></span>
<span class="codeline" id="line-443"><code>				limit = (256*sum + stride/2) / stride</code></span>
<span class="codeline" id="line-444"><code>			}</code></span>
<span class="codeline" id="line-445"><code></code></span>
<span class="codeline" id="line-446"><code>			if stride == 4 {</code></span>
<span class="codeline" id="line-447"><code>				limit += 120</code></span>
<span class="codeline" id="line-448"><code>			}</code></span>
<span class="codeline" id="line-449"><code>		}</code></span>
<span class="codeline" id="line-450"><code>	}</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>func decideOverRLEUse(depth []byte, length uint, use_rle_for_non_zero *bool, use_rle_for_zero *bool) {</code></span>
<span class="codeline" id="line-454"><code>	var total_reps_zero uint = 0</code></span>
<span class="codeline" id="line-455"><code>	var total_reps_non_zero uint = 0</code></span>
<span class="codeline" id="line-456"><code>	var count_reps_zero uint = 1</code></span>
<span class="codeline" id="line-457"><code>	var count_reps_non_zero uint = 1</code></span>
<span class="codeline" id="line-458"><code>	var i uint</code></span>
<span class="codeline" id="line-459"><code>	for i = 0; i &lt; length; {</code></span>
<span class="codeline" id="line-460"><code>		var value byte = depth[i]</code></span>
<span class="codeline" id="line-461"><code>		var reps uint = 1</code></span>
<span class="codeline" id="line-462"><code>		var k uint</code></span>
<span class="codeline" id="line-463"><code>		for k = i + 1; k &lt; length &amp;&amp; depth[k] == value; k++ {</code></span>
<span class="codeline" id="line-464"><code>			reps++</code></span>
<span class="codeline" id="line-465"><code>		}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>		if reps &gt;= 3 &amp;&amp; value == 0 {</code></span>
<span class="codeline" id="line-468"><code>			total_reps_zero += reps</code></span>
<span class="codeline" id="line-469"><code>			count_reps_zero++</code></span>
<span class="codeline" id="line-470"><code>		}</code></span>
<span class="codeline" id="line-471"><code></code></span>
<span class="codeline" id="line-472"><code>		if reps &gt;= 4 &amp;&amp; value != 0 {</code></span>
<span class="codeline" id="line-473"><code>			total_reps_non_zero += reps</code></span>
<span class="codeline" id="line-474"><code>			count_reps_non_zero++</code></span>
<span class="codeline" id="line-475"><code>		}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>		i += reps</code></span>
<span class="codeline" id="line-478"><code>	}</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	*use_rle_for_non_zero = total_reps_non_zero &gt; count_reps_non_zero*2</code></span>
<span class="codeline" id="line-481"><code>	*use_rle_for_zero = total_reps_zero &gt; count_reps_zero*2</code></span>
<span class="codeline" id="line-482"><code>}</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>/* Write a Huffman tree from bit depths into the bit-stream representation</code></span>
<span class="codeline" id="line-485"><code>   of a Huffman tree. The generated Huffman tree is to be compressed once</code></span>
<span class="codeline" id="line-486"><code>   more using a Huffman tree */</code></span>
<span class="codeline" id="line-487"><code>func writeHuffmanTree(depth []byte, length uint, tree_size *uint, tree []byte, extra_bits_data []byte) {</code></span>
<span class="codeline" id="line-488"><code>	var previous_value byte = initialRepeatedCodeLength</code></span>
<span class="codeline" id="line-489"><code>	var i uint</code></span>
<span class="codeline" id="line-490"><code>	var use_rle_for_non_zero bool = false</code></span>
<span class="codeline" id="line-491"><code>	var use_rle_for_zero bool = false</code></span>
<span class="codeline" id="line-492"><code>	var new_length uint = length</code></span>
<span class="codeline" id="line-493"><code>	/* Throw away trailing zeros. */</code></span>
<span class="codeline" id="line-494"><code>	for i = 0; i &lt; length; i++ {</code></span>
<span class="codeline" id="line-495"><code>		if depth[length-i-1] == 0 {</code></span>
<span class="codeline" id="line-496"><code>			new_length--</code></span>
<span class="codeline" id="line-497"><code>		} else {</code></span>
<span class="codeline" id="line-498"><code>			break</code></span>
<span class="codeline" id="line-499"><code>		}</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code></code></span>
<span class="codeline" id="line-502"><code>	/* First gather statistics on if it is a good idea to do RLE. */</code></span>
<span class="codeline" id="line-503"><code>	if length &gt; 50 {</code></span>
<span class="codeline" id="line-504"><code>		/* Find RLE coding for longer codes.</code></span>
<span class="codeline" id="line-505"><code>		   Shorter codes seem not to benefit from RLE. */</code></span>
<span class="codeline" id="line-506"><code>		decideOverRLEUse(depth, new_length, &amp;use_rle_for_non_zero, &amp;use_rle_for_zero)</code></span>
<span class="codeline" id="line-507"><code>	}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	/* Actual RLE coding. */</code></span>
<span class="codeline" id="line-510"><code>	for i = 0; i &lt; new_length; {</code></span>
<span class="codeline" id="line-511"><code>		var value byte = depth[i]</code></span>
<span class="codeline" id="line-512"><code>		var reps uint = 1</code></span>
<span class="codeline" id="line-513"><code>		if (value != 0 &amp;&amp; use_rle_for_non_zero) || (value == 0 &amp;&amp; use_rle_for_zero) {</code></span>
<span class="codeline" id="line-514"><code>			var k uint</code></span>
<span class="codeline" id="line-515"><code>			for k = i + 1; k &lt; new_length &amp;&amp; depth[k] == value; k++ {</code></span>
<span class="codeline" id="line-516"><code>				reps++</code></span>
<span class="codeline" id="line-517"><code>			}</code></span>
<span class="codeline" id="line-518"><code>		}</code></span>
<span class="codeline" id="line-519"><code></code></span>
<span class="codeline" id="line-520"><code>		if value == 0 {</code></span>
<span class="codeline" id="line-521"><code>			writeHuffmanTreeRepetitionsZeros(reps, tree_size, tree, extra_bits_data)</code></span>
<span class="codeline" id="line-522"><code>		} else {</code></span>
<span class="codeline" id="line-523"><code>			writeHuffmanTreeRepetitions(previous_value, value, reps, tree_size, tree, extra_bits_data)</code></span>
<span class="codeline" id="line-524"><code>			previous_value = value</code></span>
<span class="codeline" id="line-525"><code>		}</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>		i += reps</code></span>
<span class="codeline" id="line-528"><code>	}</code></span>
<span class="codeline" id="line-529"><code>}</code></span>
<span class="codeline" id="line-530"><code></code></span>
<span class="codeline" id="line-531"><code>var reverseBits_kLut = [16]uint{</code></span>
<span class="codeline" id="line-532"><code>	0x00,</code></span>
<span class="codeline" id="line-533"><code>	0x08,</code></span>
<span class="codeline" id="line-534"><code>	0x04,</code></span>
<span class="codeline" id="line-535"><code>	0x0C,</code></span>
<span class="codeline" id="line-536"><code>	0x02,</code></span>
<span class="codeline" id="line-537"><code>	0x0A,</code></span>
<span class="codeline" id="line-538"><code>	0x06,</code></span>
<span class="codeline" id="line-539"><code>	0x0E,</code></span>
<span class="codeline" id="line-540"><code>	0x01,</code></span>
<span class="codeline" id="line-541"><code>	0x09,</code></span>
<span class="codeline" id="line-542"><code>	0x05,</code></span>
<span class="codeline" id="line-543"><code>	0x0D,</code></span>
<span class="codeline" id="line-544"><code>	0x03,</code></span>
<span class="codeline" id="line-545"><code>	0x0B,</code></span>
<span class="codeline" id="line-546"><code>	0x07,</code></span>
<span class="codeline" id="line-547"><code>	0x0F,</code></span>
<span class="codeline" id="line-548"><code>}</code></span>
<span class="codeline" id="line-549"><code></code></span>
<span class="codeline" id="line-550"><code>func reverseBits(num_bits uint, bits uint16) uint16 {</code></span>
<span class="codeline" id="line-551"><code>	var retval uint = reverseBits_kLut[bits&amp;0x0F]</code></span>
<span class="codeline" id="line-552"><code>	var i uint</code></span>
<span class="codeline" id="line-553"><code>	for i = 4; i &lt; num_bits; i += 4 {</code></span>
<span class="codeline" id="line-554"><code>		retval &lt;&lt;= 4</code></span>
<span class="codeline" id="line-555"><code>		bits = uint16(bits &gt;&gt; 4)</code></span>
<span class="codeline" id="line-556"><code>		retval |= reverseBits_kLut[bits&amp;0x0F]</code></span>
<span class="codeline" id="line-557"><code>	}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>	retval &gt;&gt;= ((0 - num_bits) &amp; 0x03)</code></span>
<span class="codeline" id="line-560"><code>	return uint16(retval)</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>/* 0..15 are values for bits */</code></span>
<span class="codeline" id="line-564"><code>const maxHuffmanBits = 16</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>/* Get the actual bit values for a tree of bit depths. */</code></span>
<span class="codeline" id="line-567"><code>func convertBitDepthsToSymbols(depth []byte, len uint, bits []uint16) {</code></span>
<span class="codeline" id="line-568"><code>	var bl_count = [maxHuffmanBits]uint16{0}</code></span>
<span class="codeline" id="line-569"><code>	var next_code [maxHuffmanBits]uint16</code></span>
<span class="codeline" id="line-570"><code>	var i uint</code></span>
<span class="codeline" id="line-571"><code>	/* In Brotli, all bit depths are [1..15]</code></span>
<span class="codeline" id="line-572"><code>	   0 bit depth means that the symbol does not exist. */</code></span>
<span class="codeline" id="line-573"><code></code></span>
<span class="codeline" id="line-574"><code>	var code int = 0</code></span>
<span class="codeline" id="line-575"><code>	for i = 0; i &lt; len; i++ {</code></span>
<span class="codeline" id="line-576"><code>		bl_count[depth[i]]++</code></span>
<span class="codeline" id="line-577"><code>	}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>	bl_count[0] = 0</code></span>
<span class="codeline" id="line-580"><code>	next_code[0] = 0</code></span>
<span class="codeline" id="line-581"><code>	for i = 1; i &lt; maxHuffmanBits; i++ {</code></span>
<span class="codeline" id="line-582"><code>		code = (code + int(bl_count[i-1])) &lt;&lt; 1</code></span>
<span class="codeline" id="line-583"><code>		next_code[i] = uint16(code)</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>	for i = 0; i &lt; len; i++ {</code></span>
<span class="codeline" id="line-587"><code>		if depth[i] != 0 {</code></span>
<span class="codeline" id="line-588"><code>			bits[i] = reverseBits(uint(depth[i]), next_code[depth[i]])</code></span>
<span class="codeline" id="line-589"><code>			next_code[depth[i]]++</code></span>
<span class="codeline" id="line-590"><code>		}</code></span>
<span class="codeline" id="line-591"><code>	}</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>