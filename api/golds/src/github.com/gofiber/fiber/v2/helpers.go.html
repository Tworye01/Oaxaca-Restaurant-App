<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: helpers.go in package github.com/gofiber/fiber/v2</title>
<link href="../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	helpers.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/github.com/gofiber/fiber/v2.html">github.com/gofiber/fiber/v2</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// ‚ö°Ô∏è Fiber is an Express inspired web framework written in Go with ‚òïÔ∏è</code></span>
<span class="codeline" id="line-2"><code>// ü§ñ Github Repository: https://github.com/gofiber/fiber</code></span>
<span class="codeline" id="line-3"><code>// üìå API Documentation: https://docs.gofiber.io</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package fiber</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"bytes"</code></span>
<span class="codeline" id="line-9"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-10"><code>	"fmt"</code></span>
<span class="codeline" id="line-11"><code>	"hash/crc32"</code></span>
<span class="codeline" id="line-12"><code>	"io"</code></span>
<span class="codeline" id="line-13"><code>	"net"</code></span>
<span class="codeline" id="line-14"><code>	"os"</code></span>
<span class="codeline" id="line-15"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-16"><code>	"reflect"</code></span>
<span class="codeline" id="line-17"><code>	"strings"</code></span>
<span class="codeline" id="line-18"><code>	"time"</code></span>
<span class="codeline" id="line-19"><code>	"unsafe"</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>	"github.com/gofiber/fiber/v2/log"</code></span>
<span class="codeline" id="line-22"><code>	"github.com/gofiber/fiber/v2/utils"</code></span>
<span class="codeline" id="line-23"><code></code></span>
<span class="codeline" id="line-24"><code>	"github.com/valyala/bytebufferpool"</code></span>
<span class="codeline" id="line-25"><code>	"github.com/valyala/fasthttp"</code></span>
<span class="codeline" id="line-26"><code>)</code></span>
<span class="codeline" id="line-27"><code></code></span>
<span class="codeline" id="line-28"><code>// acceptType is a struct that holds the parsed value of an Accept header</code></span>
<span class="codeline" id="line-29"><code>// along with quality, specificity, parameters, and order.</code></span>
<span class="codeline" id="line-30"><code>// Used for sorting accept headers.</code></span>
<span class="codeline" id="line-31"><code>type acceptedType struct {</code></span>
<span class="codeline" id="line-32"><code>	spec        string</code></span>
<span class="codeline" id="line-33"><code>	quality     float64</code></span>
<span class="codeline" id="line-34"><code>	specificity int</code></span>
<span class="codeline" id="line-35"><code>	order       int</code></span>
<span class="codeline" id="line-36"><code>	params      string</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// getTLSConfig returns a net listener's tls config</code></span>
<span class="codeline" id="line-40"><code>func getTLSConfig(ln net.Listener) *tls.Config {</code></span>
<span class="codeline" id="line-41"><code>	// Get listener type</code></span>
<span class="codeline" id="line-42"><code>	pointer := reflect.ValueOf(ln)</code></span>
<span class="codeline" id="line-43"><code></code></span>
<span class="codeline" id="line-44"><code>	// Is it a tls.listener?</code></span>
<span class="codeline" id="line-45"><code>	if pointer.String() == "&lt;*tls.listener Value&gt;" {</code></span>
<span class="codeline" id="line-46"><code>		// Copy value from pointer</code></span>
<span class="codeline" id="line-47"><code>		if val := reflect.Indirect(pointer); val.Type() != nil {</code></span>
<span class="codeline" id="line-48"><code>			// Get private field from value</code></span>
<span class="codeline" id="line-49"><code>			if field := val.FieldByName("config"); field.Type() != nil {</code></span>
<span class="codeline" id="line-50"><code>				// Copy value from pointer field (unsafe)</code></span>
<span class="codeline" id="line-51"><code>				newval := reflect.NewAt(field.Type(), unsafe.Pointer(field.UnsafeAddr())) //nolint:gosec // Probably the only way to extract the *tls.Config from a net.Listener. TODO: Verify there really is no easier way without using unsafe.</code></span>
<span class="codeline" id="line-52"><code>				if newval.Type() != nil {</code></span>
<span class="codeline" id="line-53"><code>					// Get element from pointer</code></span>
<span class="codeline" id="line-54"><code>					if elem := newval.Elem(); elem.Type() != nil {</code></span>
<span class="codeline" id="line-55"><code>						// Cast value to *tls.Config</code></span>
<span class="codeline" id="line-56"><code>						c, ok := elem.Interface().(*tls.Config)</code></span>
<span class="codeline" id="line-57"><code>						if !ok {</code></span>
<span class="codeline" id="line-58"><code>							panic(fmt.Errorf("failed to type-assert to *tls.Config"))</code></span>
<span class="codeline" id="line-59"><code>						}</code></span>
<span class="codeline" id="line-60"><code>						return c</code></span>
<span class="codeline" id="line-61"><code>					}</code></span>
<span class="codeline" id="line-62"><code>				}</code></span>
<span class="codeline" id="line-63"><code>			}</code></span>
<span class="codeline" id="line-64"><code>		}</code></span>
<span class="codeline" id="line-65"><code>	}</code></span>
<span class="codeline" id="line-66"><code></code></span>
<span class="codeline" id="line-67"><code>	return nil</code></span>
<span class="codeline" id="line-68"><code>}</code></span>
<span class="codeline" id="line-69"><code></code></span>
<span class="codeline" id="line-70"><code>// readContent opens a named file and read content from it</code></span>
<span class="codeline" id="line-71"><code>func readContent(rf io.ReaderFrom, name string) (int64, error) {</code></span>
<span class="codeline" id="line-72"><code>	// Read file</code></span>
<span class="codeline" id="line-73"><code>	f, err := os.Open(filepath.Clean(name))</code></span>
<span class="codeline" id="line-74"><code>	if err != nil {</code></span>
<span class="codeline" id="line-75"><code>		return 0, fmt.Errorf("failed to open: %w", err)</code></span>
<span class="codeline" id="line-76"><code>	}</code></span>
<span class="codeline" id="line-77"><code>	defer func() {</code></span>
<span class="codeline" id="line-78"><code>		if err = f.Close(); err != nil {</code></span>
<span class="codeline" id="line-79"><code>			log.Errorf("Error closing file: %s", err)</code></span>
<span class="codeline" id="line-80"><code>		}</code></span>
<span class="codeline" id="line-81"><code>	}()</code></span>
<span class="codeline" id="line-82"><code>	if n, err := rf.ReadFrom(f); err != nil {</code></span>
<span class="codeline" id="line-83"><code>		return n, fmt.Errorf("failed to read: %w", err)</code></span>
<span class="codeline" id="line-84"><code>	}</code></span>
<span class="codeline" id="line-85"><code>	return 0, nil</code></span>
<span class="codeline" id="line-86"><code>}</code></span>
<span class="codeline" id="line-87"><code></code></span>
<span class="codeline" id="line-88"><code>// quoteString escape special characters in a given string</code></span>
<span class="codeline" id="line-89"><code>func (app *App) quoteString(raw string) string {</code></span>
<span class="codeline" id="line-90"><code>	bb := bytebufferpool.Get()</code></span>
<span class="codeline" id="line-91"><code>	// quoted := string(fasthttp.AppendQuotedArg(bb.B, getBytes(raw)))</code></span>
<span class="codeline" id="line-92"><code>	quoted := app.getString(fasthttp.AppendQuotedArg(bb.B, app.getBytes(raw)))</code></span>
<span class="codeline" id="line-93"><code>	bytebufferpool.Put(bb)</code></span>
<span class="codeline" id="line-94"><code>	return quoted</code></span>
<span class="codeline" id="line-95"><code>}</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>// Scan stack if other methods match the request</code></span>
<span class="codeline" id="line-98"><code>func (app *App) methodExist(ctx *Ctx) bool {</code></span>
<span class="codeline" id="line-99"><code>	var exists bool</code></span>
<span class="codeline" id="line-100"><code>	methods := app.config.RequestMethods</code></span>
<span class="codeline" id="line-101"><code>	for i := 0; i &lt; len(methods); i++ {</code></span>
<span class="codeline" id="line-102"><code>		// Skip original method</code></span>
<span class="codeline" id="line-103"><code>		if ctx.methodINT == i {</code></span>
<span class="codeline" id="line-104"><code>			continue</code></span>
<span class="codeline" id="line-105"><code>		}</code></span>
<span class="codeline" id="line-106"><code>		// Reset stack index</code></span>
<span class="codeline" id="line-107"><code>		indexRoute := -1</code></span>
<span class="codeline" id="line-108"><code>		tree, ok := ctx.app.treeStack[i][ctx.treePath]</code></span>
<span class="codeline" id="line-109"><code>		if !ok {</code></span>
<span class="codeline" id="line-110"><code>			tree = ctx.app.treeStack[i][""]</code></span>
<span class="codeline" id="line-111"><code>		}</code></span>
<span class="codeline" id="line-112"><code>		// Get stack length</code></span>
<span class="codeline" id="line-113"><code>		lenr := len(tree) - 1</code></span>
<span class="codeline" id="line-114"><code>		// Loop over the route stack starting from previous index</code></span>
<span class="codeline" id="line-115"><code>		for indexRoute &lt; lenr {</code></span>
<span class="codeline" id="line-116"><code>			// Increment route index</code></span>
<span class="codeline" id="line-117"><code>			indexRoute++</code></span>
<span class="codeline" id="line-118"><code>			// Get *Route</code></span>
<span class="codeline" id="line-119"><code>			route := tree[indexRoute]</code></span>
<span class="codeline" id="line-120"><code>			// Skip use routes</code></span>
<span class="codeline" id="line-121"><code>			if route.use {</code></span>
<span class="codeline" id="line-122"><code>				continue</code></span>
<span class="codeline" id="line-123"><code>			}</code></span>
<span class="codeline" id="line-124"><code>			// Check if it matches the request path</code></span>
<span class="codeline" id="line-125"><code>			match := route.match(ctx.detectionPath, ctx.path, &amp;ctx.values)</code></span>
<span class="codeline" id="line-126"><code>			// No match, next route</code></span>
<span class="codeline" id="line-127"><code>			if match {</code></span>
<span class="codeline" id="line-128"><code>				// We matched</code></span>
<span class="codeline" id="line-129"><code>				exists = true</code></span>
<span class="codeline" id="line-130"><code>				// Add method to Allow header</code></span>
<span class="codeline" id="line-131"><code>				ctx.Append(HeaderAllow, methods[i])</code></span>
<span class="codeline" id="line-132"><code>				// Break stack loop</code></span>
<span class="codeline" id="line-133"><code>				break</code></span>
<span class="codeline" id="line-134"><code>			}</code></span>
<span class="codeline" id="line-135"><code>		}</code></span>
<span class="codeline" id="line-136"><code>	}</code></span>
<span class="codeline" id="line-137"><code>	return exists</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>// uniqueRouteStack drop all not unique routes from the slice</code></span>
<span class="codeline" id="line-141"><code>func uniqueRouteStack(stack []*Route) []*Route {</code></span>
<span class="codeline" id="line-142"><code>	var unique []*Route</code></span>
<span class="codeline" id="line-143"><code>	m := make(map[*Route]int)</code></span>
<span class="codeline" id="line-144"><code>	for _, v := range stack {</code></span>
<span class="codeline" id="line-145"><code>		if _, ok := m[v]; !ok {</code></span>
<span class="codeline" id="line-146"><code>			// Unique key found. Record position and collect</code></span>
<span class="codeline" id="line-147"><code>			// in result.</code></span>
<span class="codeline" id="line-148"><code>			m[v] = len(unique)</code></span>
<span class="codeline" id="line-149"><code>			unique = append(unique, v)</code></span>
<span class="codeline" id="line-150"><code>		}</code></span>
<span class="codeline" id="line-151"><code>	}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>	return unique</code></span>
<span class="codeline" id="line-154"><code>}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>// defaultString returns the value or a default value if it is set</code></span>
<span class="codeline" id="line-157"><code>func defaultString(value string, defaultValue []string) string {</code></span>
<span class="codeline" id="line-158"><code>	if len(value) == 0 &amp;&amp; len(defaultValue) &gt; 0 {</code></span>
<span class="codeline" id="line-159"><code>		return defaultValue[0]</code></span>
<span class="codeline" id="line-160"><code>	}</code></span>
<span class="codeline" id="line-161"><code>	return value</code></span>
<span class="codeline" id="line-162"><code>}</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>const normalizedHeaderETag = "Etag"</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>// Generate and set ETag header to response</code></span>
<span class="codeline" id="line-167"><code>func setETag(c *Ctx, weak bool) { //nolint: revive // Accepting a bool param is fine here</code></span>
<span class="codeline" id="line-168"><code>	// Don't generate ETags for invalid responses</code></span>
<span class="codeline" id="line-169"><code>	if c.fasthttp.Response.StatusCode() != StatusOK {</code></span>
<span class="codeline" id="line-170"><code>		return</code></span>
<span class="codeline" id="line-171"><code>	}</code></span>
<span class="codeline" id="line-172"><code>	body := c.fasthttp.Response.Body()</code></span>
<span class="codeline" id="line-173"><code>	// Skips ETag if no response body is present</code></span>
<span class="codeline" id="line-174"><code>	if len(body) == 0 {</code></span>
<span class="codeline" id="line-175"><code>		return</code></span>
<span class="codeline" id="line-176"><code>	}</code></span>
<span class="codeline" id="line-177"><code>	// Get ETag header from request</code></span>
<span class="codeline" id="line-178"><code>	clientEtag := c.Get(HeaderIfNoneMatch)</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	// Generate ETag for response</code></span>
<span class="codeline" id="line-181"><code>	const pol = 0xD5828281</code></span>
<span class="codeline" id="line-182"><code>	crc32q := crc32.MakeTable(pol)</code></span>
<span class="codeline" id="line-183"><code>	etag := fmt.Sprintf("\"%d-%v\"", len(body), crc32.Checksum(body, crc32q))</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>	// Enable weak tag</code></span>
<span class="codeline" id="line-186"><code>	if weak {</code></span>
<span class="codeline" id="line-187"><code>		etag = "W/" + etag</code></span>
<span class="codeline" id="line-188"><code>	}</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>	// Check if client's ETag is weak</code></span>
<span class="codeline" id="line-191"><code>	if strings.HasPrefix(clientEtag, "W/") {</code></span>
<span class="codeline" id="line-192"><code>		// Check if server's ETag is weak</code></span>
<span class="codeline" id="line-193"><code>		if clientEtag[2:] == etag || clientEtag[2:] == etag[2:] {</code></span>
<span class="codeline" id="line-194"><code>			// W/1 == 1 || W/1 == W/1</code></span>
<span class="codeline" id="line-195"><code>			if err := c.SendStatus(StatusNotModified); err != nil {</code></span>
<span class="codeline" id="line-196"><code>				log.Errorf("setETag: failed to SendStatus: %v", err)</code></span>
<span class="codeline" id="line-197"><code>			}</code></span>
<span class="codeline" id="line-198"><code>			c.fasthttp.ResetBody()</code></span>
<span class="codeline" id="line-199"><code>			return</code></span>
<span class="codeline" id="line-200"><code>		}</code></span>
<span class="codeline" id="line-201"><code>		// W/1 != W/2 || W/1 != 2</code></span>
<span class="codeline" id="line-202"><code>		c.setCanonical(normalizedHeaderETag, etag)</code></span>
<span class="codeline" id="line-203"><code>		return</code></span>
<span class="codeline" id="line-204"><code>	}</code></span>
<span class="codeline" id="line-205"><code>	if strings.Contains(clientEtag, etag) {</code></span>
<span class="codeline" id="line-206"><code>		// 1 == 1</code></span>
<span class="codeline" id="line-207"><code>		if err := c.SendStatus(StatusNotModified); err != nil {</code></span>
<span class="codeline" id="line-208"><code>			log.Errorf("setETag: failed to SendStatus: %v", err)</code></span>
<span class="codeline" id="line-209"><code>		}</code></span>
<span class="codeline" id="line-210"><code>		c.fasthttp.ResetBody()</code></span>
<span class="codeline" id="line-211"><code>		return</code></span>
<span class="codeline" id="line-212"><code>	}</code></span>
<span class="codeline" id="line-213"><code>	// 1 != 2</code></span>
<span class="codeline" id="line-214"><code>	c.setCanonical(normalizedHeaderETag, etag)</code></span>
<span class="codeline" id="line-215"><code>}</code></span>
<span class="codeline" id="line-216"><code></code></span>
<span class="codeline" id="line-217"><code>func getGroupPath(prefix, path string) string {</code></span>
<span class="codeline" id="line-218"><code>	if len(path) == 0 {</code></span>
<span class="codeline" id="line-219"><code>		return prefix</code></span>
<span class="codeline" id="line-220"><code>	}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>	if path[0] != '/' {</code></span>
<span class="codeline" id="line-223"><code>		path = "/" + path</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code></code></span>
<span class="codeline" id="line-226"><code>	return utils.TrimRight(prefix, '/') + path</code></span>
<span class="codeline" id="line-227"><code>}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>// acceptsOffer This function determines if an offer matches a given specification.</code></span>
<span class="codeline" id="line-230"><code>// It checks if the specification ends with a '*' or if the offer has the prefix of the specification.</code></span>
<span class="codeline" id="line-231"><code>// Returns true if the offer matches the specification, false otherwise.</code></span>
<span class="codeline" id="line-232"><code>func acceptsOffer(spec, offer, _ string) bool {</code></span>
<span class="codeline" id="line-233"><code>	if len(spec) &gt;= 1 &amp;&amp; spec[len(spec)-1] == '*' {</code></span>
<span class="codeline" id="line-234"><code>		return true</code></span>
<span class="codeline" id="line-235"><code>	} else if strings.HasPrefix(spec, offer) {</code></span>
<span class="codeline" id="line-236"><code>		return true</code></span>
<span class="codeline" id="line-237"><code>	}</code></span>
<span class="codeline" id="line-238"><code>	return false</code></span>
<span class="codeline" id="line-239"><code>}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>// acceptsOfferType This function determines if an offer type matches a given specification.</code></span>
<span class="codeline" id="line-242"><code>// It checks if the specification is equal to */* (i.e., all types are accepted).</code></span>
<span class="codeline" id="line-243"><code>// It gets the MIME type of the offer (either from the offer itself or by its file extension).</code></span>
<span class="codeline" id="line-244"><code>// It checks if the offer MIME type matches the specification MIME type or if the specification is of the form &lt;MIME_type&gt;/* and the offer MIME type has the same MIME type.</code></span>
<span class="codeline" id="line-245"><code>// It checks if the offer contains every parameter present in the specification.</code></span>
<span class="codeline" id="line-246"><code>// Returns true if the offer type matches the specification, false otherwise.</code></span>
<span class="codeline" id="line-247"><code>func acceptsOfferType(spec, offerType, specParams string) bool {</code></span>
<span class="codeline" id="line-248"><code>	var offerMime, offerParams string</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	if i := strings.IndexByte(offerType, ';'); i == -1 {</code></span>
<span class="codeline" id="line-251"><code>		offerMime = offerType</code></span>
<span class="codeline" id="line-252"><code>	} else {</code></span>
<span class="codeline" id="line-253"><code>		offerMime = offerType[:i]</code></span>
<span class="codeline" id="line-254"><code>		offerParams = offerType[i:]</code></span>
<span class="codeline" id="line-255"><code>	}</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>	// Accept: */*</code></span>
<span class="codeline" id="line-258"><code>	if spec == "*/*" {</code></span>
<span class="codeline" id="line-259"><code>		return paramsMatch(specParams, offerParams)</code></span>
<span class="codeline" id="line-260"><code>	}</code></span>
<span class="codeline" id="line-261"><code></code></span>
<span class="codeline" id="line-262"><code>	var mimetype string</code></span>
<span class="codeline" id="line-263"><code>	if strings.IndexByte(offerMime, '/') != -1 {</code></span>
<span class="codeline" id="line-264"><code>		mimetype = offerMime // MIME type</code></span>
<span class="codeline" id="line-265"><code>	} else {</code></span>
<span class="codeline" id="line-266"><code>		mimetype = utils.GetMIME(offerMime) // extension</code></span>
<span class="codeline" id="line-267"><code>	}</code></span>
<span class="codeline" id="line-268"><code></code></span>
<span class="codeline" id="line-269"><code>	if spec == mimetype {</code></span>
<span class="codeline" id="line-270"><code>		// Accept: &lt;MIME_type&gt;/&lt;MIME_subtype&gt;</code></span>
<span class="codeline" id="line-271"><code>		return paramsMatch(specParams, offerParams)</code></span>
<span class="codeline" id="line-272"><code>	}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>	s := strings.IndexByte(mimetype, '/')</code></span>
<span class="codeline" id="line-275"><code>	// Accept: &lt;MIME_type&gt;/*</code></span>
<span class="codeline" id="line-276"><code>	if strings.HasPrefix(spec, mimetype[:s]) &amp;&amp; (spec[s:] == "/*" || mimetype[s:] == "/*") {</code></span>
<span class="codeline" id="line-277"><code>		return paramsMatch(specParams, offerParams)</code></span>
<span class="codeline" id="line-278"><code>	}</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	return false</code></span>
<span class="codeline" id="line-281"><code>}</code></span>
<span class="codeline" id="line-282"><code></code></span>
<span class="codeline" id="line-283"><code>// paramsMatch returns whether offerParams contains all parameters present in specParams.</code></span>
<span class="codeline" id="line-284"><code>// Matching is case insensitive, and surrounding quotes are stripped.</code></span>
<span class="codeline" id="line-285"><code>// To align with the behavior of res.format from Express, the order of parameters is</code></span>
<span class="codeline" id="line-286"><code>// ignored, and if a parameter is specified twice in the incoming Accept, the last</code></span>
<span class="codeline" id="line-287"><code>// provided value is given precedence.</code></span>
<span class="codeline" id="line-288"><code>// In the case of quoted values, RFC 9110 says that we must treat any character escaped</code></span>
<span class="codeline" id="line-289"><code>// by a backslash as equivalent to the character itself (e.g., "a\aa" is equivalent to "aaa").</code></span>
<span class="codeline" id="line-290"><code>// For the sake of simplicity, we forgo this and compare the value as-is. Besides, it would</code></span>
<span class="codeline" id="line-291"><code>// be highly unusual for a client to escape something other than a double quote or backslash.</code></span>
<span class="codeline" id="line-292"><code>// See https://www.rfc-editor.org/rfc/rfc9110#name-parameters</code></span>
<span class="codeline" id="line-293"><code>func paramsMatch(specParamStr, offerParams string) bool {</code></span>
<span class="codeline" id="line-294"><code>	if specParamStr == "" {</code></span>
<span class="codeline" id="line-295"><code>		return true</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code></code></span>
<span class="codeline" id="line-298"><code>	// Preprocess the spec params to more easily test</code></span>
<span class="codeline" id="line-299"><code>	// for out-of-order parameters</code></span>
<span class="codeline" id="line-300"><code>	specParams := make([][2]string, 0, 2)</code></span>
<span class="codeline" id="line-301"><code>	forEachParameter(specParamStr, func(s1, s2 string) bool {</code></span>
<span class="codeline" id="line-302"><code>		if s1 == "q" || s1 == "Q" {</code></span>
<span class="codeline" id="line-303"><code>			return false</code></span>
<span class="codeline" id="line-304"><code>		}</code></span>
<span class="codeline" id="line-305"><code>		for i := range specParams {</code></span>
<span class="codeline" id="line-306"><code>			if utils.EqualFold(s1, specParams[i][0]) {</code></span>
<span class="codeline" id="line-307"><code>				specParams[i][1] = s2</code></span>
<span class="codeline" id="line-308"><code>				return false</code></span>
<span class="codeline" id="line-309"><code>			}</code></span>
<span class="codeline" id="line-310"><code>		}</code></span>
<span class="codeline" id="line-311"><code>		specParams = append(specParams, [2]string{s1, s2})</code></span>
<span class="codeline" id="line-312"><code>		return true</code></span>
<span class="codeline" id="line-313"><code>	})</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>	allSpecParamsMatch := true</code></span>
<span class="codeline" id="line-316"><code>	for i := range specParams {</code></span>
<span class="codeline" id="line-317"><code>		foundParam := false</code></span>
<span class="codeline" id="line-318"><code>		forEachParameter(offerParams, func(offerParam, offerVal string) bool {</code></span>
<span class="codeline" id="line-319"><code>			if utils.EqualFold(specParams[i][0], offerParam) {</code></span>
<span class="codeline" id="line-320"><code>				foundParam = true</code></span>
<span class="codeline" id="line-321"><code>				allSpecParamsMatch = utils.EqualFold(specParams[i][1], offerVal)</code></span>
<span class="codeline" id="line-322"><code>				return false</code></span>
<span class="codeline" id="line-323"><code>			}</code></span>
<span class="codeline" id="line-324"><code>			return true</code></span>
<span class="codeline" id="line-325"><code>		})</code></span>
<span class="codeline" id="line-326"><code>		if !foundParam || !allSpecParamsMatch {</code></span>
<span class="codeline" id="line-327"><code>			return false</code></span>
<span class="codeline" id="line-328"><code>		}</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>	return allSpecParamsMatch</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>// getSplicedStrList function takes a string and a string slice as an argument, divides the string into different</code></span>
<span class="codeline" id="line-334"><code>// elements divided by ',' and stores these elements in the string slice.</code></span>
<span class="codeline" id="line-335"><code>// It returns the populated string slice as an output.</code></span>
<span class="codeline" id="line-336"><code>//</code></span>
<span class="codeline" id="line-337"><code>// If the given slice hasn't enough space, it will allocate more and return.</code></span>
<span class="codeline" id="line-338"><code>func getSplicedStrList(headerValue string, dst []string) []string {</code></span>
<span class="codeline" id="line-339"><code>	if headerValue == "" {</code></span>
<span class="codeline" id="line-340"><code>		return nil</code></span>
<span class="codeline" id="line-341"><code>	}</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>	var (</code></span>
<span class="codeline" id="line-344"><code>		index             int</code></span>
<span class="codeline" id="line-345"><code>		character         rune</code></span>
<span class="codeline" id="line-346"><code>		lastElementEndsAt uint8</code></span>
<span class="codeline" id="line-347"><code>		insertIndex       int</code></span>
<span class="codeline" id="line-348"><code>	)</code></span>
<span class="codeline" id="line-349"><code>	for index, character = range headerValue + "$" {</code></span>
<span class="codeline" id="line-350"><code>		if character == ',' || index == len(headerValue) {</code></span>
<span class="codeline" id="line-351"><code>			if insertIndex &gt;= len(dst) {</code></span>
<span class="codeline" id="line-352"><code>				oldSlice := dst</code></span>
<span class="codeline" id="line-353"><code>				dst = make([]string, len(dst)+(len(dst)&gt;&gt;1)+2)</code></span>
<span class="codeline" id="line-354"><code>				copy(dst, oldSlice)</code></span>
<span class="codeline" id="line-355"><code>			}</code></span>
<span class="codeline" id="line-356"><code>			dst[insertIndex] = utils.TrimLeft(headerValue[lastElementEndsAt:index], ' ')</code></span>
<span class="codeline" id="line-357"><code>			lastElementEndsAt = uint8(index + 1)</code></span>
<span class="codeline" id="line-358"><code>			insertIndex++</code></span>
<span class="codeline" id="line-359"><code>		}</code></span>
<span class="codeline" id="line-360"><code>	}</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>	if len(dst) &gt; insertIndex {</code></span>
<span class="codeline" id="line-363"><code>		dst = dst[:insertIndex]</code></span>
<span class="codeline" id="line-364"><code>	}</code></span>
<span class="codeline" id="line-365"><code>	return dst</code></span>
<span class="codeline" id="line-366"><code>}</code></span>
<span class="codeline" id="line-367"><code></code></span>
<span class="codeline" id="line-368"><code>// forEachMediaRange parses an Accept or Content-Type header, calling functor</code></span>
<span class="codeline" id="line-369"><code>// on each media range.</code></span>
<span class="codeline" id="line-370"><code>// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields</code></span>
<span class="codeline" id="line-371"><code>func forEachMediaRange(header string, functor func(string)) {</code></span>
<span class="codeline" id="line-372"><code>	hasDQuote := strings.IndexByte(header, '"') != -1</code></span>
<span class="codeline" id="line-373"><code></code></span>
<span class="codeline" id="line-374"><code>	for len(header) &gt; 0 {</code></span>
<span class="codeline" id="line-375"><code>		n := 0</code></span>
<span class="codeline" id="line-376"><code>		header = utils.TrimLeft(header, ' ')</code></span>
<span class="codeline" id="line-377"><code>		quotes := 0</code></span>
<span class="codeline" id="line-378"><code>		escaping := false</code></span>
<span class="codeline" id="line-379"><code></code></span>
<span class="codeline" id="line-380"><code>		if hasDQuote {</code></span>
<span class="codeline" id="line-381"><code>			// Complex case. We need to keep track of quotes and quoted-pairs (i.e.,  characters escaped with \ )</code></span>
<span class="codeline" id="line-382"><code>		loop:</code></span>
<span class="codeline" id="line-383"><code>			for n &lt; len(header) {</code></span>
<span class="codeline" id="line-384"><code>				switch header[n] {</code></span>
<span class="codeline" id="line-385"><code>				case ',':</code></span>
<span class="codeline" id="line-386"><code>					if quotes%2 == 0 {</code></span>
<span class="codeline" id="line-387"><code>						break loop</code></span>
<span class="codeline" id="line-388"><code>					}</code></span>
<span class="codeline" id="line-389"><code>				case '"':</code></span>
<span class="codeline" id="line-390"><code>					if !escaping {</code></span>
<span class="codeline" id="line-391"><code>						quotes++</code></span>
<span class="codeline" id="line-392"><code>					}</code></span>
<span class="codeline" id="line-393"><code>				case '\\':</code></span>
<span class="codeline" id="line-394"><code>					if quotes%2 == 1 {</code></span>
<span class="codeline" id="line-395"><code>						escaping = !escaping</code></span>
<span class="codeline" id="line-396"><code>					}</code></span>
<span class="codeline" id="line-397"><code>				}</code></span>
<span class="codeline" id="line-398"><code>				n++</code></span>
<span class="codeline" id="line-399"><code>			}</code></span>
<span class="codeline" id="line-400"><code>		} else {</code></span>
<span class="codeline" id="line-401"><code>			// Simple case. Just look for the next comma.</code></span>
<span class="codeline" id="line-402"><code>			if n = strings.IndexByte(header, ','); n == -1 {</code></span>
<span class="codeline" id="line-403"><code>				n = len(header)</code></span>
<span class="codeline" id="line-404"><code>			}</code></span>
<span class="codeline" id="line-405"><code>		}</code></span>
<span class="codeline" id="line-406"><code></code></span>
<span class="codeline" id="line-407"><code>		functor(header[:n])</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>		if n &gt;= len(header) {</code></span>
<span class="codeline" id="line-410"><code>			return</code></span>
<span class="codeline" id="line-411"><code>		}</code></span>
<span class="codeline" id="line-412"><code>		header = header[n+1:]</code></span>
<span class="codeline" id="line-413"><code>	}</code></span>
<span class="codeline" id="line-414"><code>}</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>// forEachParamter parses a given parameter list, calling functor</code></span>
<span class="codeline" id="line-417"><code>// on each valid parameter. If functor returns false, we stop processing.</code></span>
<span class="codeline" id="line-418"><code>// It expects a leading ';'.</code></span>
<span class="codeline" id="line-419"><code>// See: https://www.rfc-editor.org/rfc/rfc9110#section-5.6.6</code></span>
<span class="codeline" id="line-420"><code>// According to RFC-9110 2.4, it is up to our discretion whether</code></span>
<span class="codeline" id="line-421"><code>// to attempt to recover from errors in HTTP semantics. Therefor,</code></span>
<span class="codeline" id="line-422"><code>// we take the simple approach and exit early when a semantic error</code></span>
<span class="codeline" id="line-423"><code>// is detected in the header.</code></span>
<span class="codeline" id="line-424"><code>//</code></span>
<span class="codeline" id="line-425"><code>//	parameter = parameter-name "=" parameter-value</code></span>
<span class="codeline" id="line-426"><code>//	parameter-name = token</code></span>
<span class="codeline" id="line-427"><code>//	parameter-value = ( token / quoted-string )</code></span>
<span class="codeline" id="line-428"><code>//	parameters = *( OWS ";" OWS [ parameter ] )</code></span>
<span class="codeline" id="line-429"><code>func forEachParameter(params string, functor func(string, string) bool) {</code></span>
<span class="codeline" id="line-430"><code>	for len(params) &gt; 0 {</code></span>
<span class="codeline" id="line-431"><code>		// eat OWS ";" OWS</code></span>
<span class="codeline" id="line-432"><code>		params = utils.TrimLeft(params, ' ')</code></span>
<span class="codeline" id="line-433"><code>		if len(params) == 0 || params[0] != ';' {</code></span>
<span class="codeline" id="line-434"><code>			return</code></span>
<span class="codeline" id="line-435"><code>		}</code></span>
<span class="codeline" id="line-436"><code>		params = utils.TrimLeft(params[1:], ' ')</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>		n := 0</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>		// make sure the parameter is at least one character long</code></span>
<span class="codeline" id="line-441"><code>		if len(params) == 0 || !validHeaderFieldByte(params[n]) {</code></span>
<span class="codeline" id="line-442"><code>			return</code></span>
<span class="codeline" id="line-443"><code>		}</code></span>
<span class="codeline" id="line-444"><code>		n++</code></span>
<span class="codeline" id="line-445"><code>		for n &lt; len(params) &amp;&amp; validHeaderFieldByte(params[n]) {</code></span>
<span class="codeline" id="line-446"><code>			n++</code></span>
<span class="codeline" id="line-447"><code>		}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>		// We should hit a '=' (that has more characters after it)</code></span>
<span class="codeline" id="line-450"><code>		// If not, the parameter is invalid.</code></span>
<span class="codeline" id="line-451"><code>		// param=foo</code></span>
<span class="codeline" id="line-452"><code>		// ~~~~~^</code></span>
<span class="codeline" id="line-453"><code>		if n &gt;= len(params)-1 || params[n] != '=' {</code></span>
<span class="codeline" id="line-454"><code>			return</code></span>
<span class="codeline" id="line-455"><code>		}</code></span>
<span class="codeline" id="line-456"><code>		param := params[:n]</code></span>
<span class="codeline" id="line-457"><code>		n++</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>		if params[n] == '"' {</code></span>
<span class="codeline" id="line-460"><code>			// Handle quoted strings and quoted-pairs (i.e., characters escaped with \ )</code></span>
<span class="codeline" id="line-461"><code>			// See: https://www.rfc-editor.org/rfc/rfc9110#section-5.6.4</code></span>
<span class="codeline" id="line-462"><code>			foundEndQuote := false</code></span>
<span class="codeline" id="line-463"><code>			escaping := false</code></span>
<span class="codeline" id="line-464"><code>			n++</code></span>
<span class="codeline" id="line-465"><code>			m := n</code></span>
<span class="codeline" id="line-466"><code>			for ; n &lt; len(params); n++ {</code></span>
<span class="codeline" id="line-467"><code>				if params[n] == '"' &amp;&amp; !escaping {</code></span>
<span class="codeline" id="line-468"><code>					foundEndQuote = true</code></span>
<span class="codeline" id="line-469"><code>					break</code></span>
<span class="codeline" id="line-470"><code>				}</code></span>
<span class="codeline" id="line-471"><code>				// Recipients that process the value of a quoted-string MUST handle</code></span>
<span class="codeline" id="line-472"><code>				// a quoted-pair as if it were replaced by the octet following the backslash</code></span>
<span class="codeline" id="line-473"><code>				escaping = params[n] == '\\' &amp;&amp; !escaping</code></span>
<span class="codeline" id="line-474"><code>			}</code></span>
<span class="codeline" id="line-475"><code>			if !foundEndQuote {</code></span>
<span class="codeline" id="line-476"><code>				// Not a valid parameter</code></span>
<span class="codeline" id="line-477"><code>				return</code></span>
<span class="codeline" id="line-478"><code>			}</code></span>
<span class="codeline" id="line-479"><code>			if !functor(param, params[m:n]) {</code></span>
<span class="codeline" id="line-480"><code>				return</code></span>
<span class="codeline" id="line-481"><code>			}</code></span>
<span class="codeline" id="line-482"><code>			n++</code></span>
<span class="codeline" id="line-483"><code>		} else if validHeaderFieldByte(params[n]) {</code></span>
<span class="codeline" id="line-484"><code>			// Parse a normal value, which should just be a token.</code></span>
<span class="codeline" id="line-485"><code>			m := n</code></span>
<span class="codeline" id="line-486"><code>			n++</code></span>
<span class="codeline" id="line-487"><code>			for n &lt; len(params) &amp;&amp; validHeaderFieldByte(params[n]) {</code></span>
<span class="codeline" id="line-488"><code>				n++</code></span>
<span class="codeline" id="line-489"><code>			}</code></span>
<span class="codeline" id="line-490"><code>			if !functor(param, params[m:n]) {</code></span>
<span class="codeline" id="line-491"><code>				return</code></span>
<span class="codeline" id="line-492"><code>			}</code></span>
<span class="codeline" id="line-493"><code>		} else {</code></span>
<span class="codeline" id="line-494"><code>			// Value was invalid</code></span>
<span class="codeline" id="line-495"><code>			return</code></span>
<span class="codeline" id="line-496"><code>		}</code></span>
<span class="codeline" id="line-497"><code>		params = params[n:]</code></span>
<span class="codeline" id="line-498"><code>	}</code></span>
<span class="codeline" id="line-499"><code>}</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>// validHeaderFieldByte returns true if a valid tchar</code></span>
<span class="codeline" id="line-502"><code>//</code></span>
<span class="codeline" id="line-503"><code>//	tchar = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /</code></span>
<span class="codeline" id="line-504"><code>//	"^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA</code></span>
<span class="codeline" id="line-505"><code>//</code></span>
<span class="codeline" id="line-506"><code>// See: https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2</code></span>
<span class="codeline" id="line-507"><code>// Function copied from net/textproto:</code></span>
<span class="codeline" id="line-508"><code>// https://github.com/golang/go/blob/master/src/net/textproto/reader.go#L663</code></span>
<span class="codeline" id="line-509"><code>func validHeaderFieldByte(c byte) bool {</code></span>
<span class="codeline" id="line-510"><code>	// mask is a 128-bit bitmap with 1s for allowed bytes,</code></span>
<span class="codeline" id="line-511"><code>	// so that the byte c can be tested with a shift and an and.</code></span>
<span class="codeline" id="line-512"><code>	// If c &gt;= 128, then 1&lt;&lt;c and 1&lt;&lt;(c-64) will both be zero,</code></span>
<span class="codeline" id="line-513"><code>	// and this function will return false.</code></span>
<span class="codeline" id="line-514"><code>	const mask = 0 |</code></span>
<span class="codeline" id="line-515"><code>		(1&lt;&lt;(10)-1)&lt;&lt;'0' |</code></span>
<span class="codeline" id="line-516"><code>		(1&lt;&lt;(26)-1)&lt;&lt;'a' |</code></span>
<span class="codeline" id="line-517"><code>		(1&lt;&lt;(26)-1)&lt;&lt;'A' |</code></span>
<span class="codeline" id="line-518"><code>		1&lt;&lt;'!' |</code></span>
<span class="codeline" id="line-519"><code>		1&lt;&lt;'#' |</code></span>
<span class="codeline" id="line-520"><code>		1&lt;&lt;'$' |</code></span>
<span class="codeline" id="line-521"><code>		1&lt;&lt;'%' |</code></span>
<span class="codeline" id="line-522"><code>		1&lt;&lt;'&amp;' |</code></span>
<span class="codeline" id="line-523"><code>		1&lt;&lt;'\'' |</code></span>
<span class="codeline" id="line-524"><code>		1&lt;&lt;'*' |</code></span>
<span class="codeline" id="line-525"><code>		1&lt;&lt;'+' |</code></span>
<span class="codeline" id="line-526"><code>		1&lt;&lt;'-' |</code></span>
<span class="codeline" id="line-527"><code>		1&lt;&lt;'.' |</code></span>
<span class="codeline" id="line-528"><code>		1&lt;&lt;'^' |</code></span>
<span class="codeline" id="line-529"><code>		1&lt;&lt;'_' |</code></span>
<span class="codeline" id="line-530"><code>		1&lt;&lt;'`' |</code></span>
<span class="codeline" id="line-531"><code>		1&lt;&lt;'|' |</code></span>
<span class="codeline" id="line-532"><code>		1&lt;&lt;'~'</code></span>
<span class="codeline" id="line-533"><code>	return ((uint64(1)&lt;&lt;c)&amp;(mask&amp;(1&lt;&lt;64-1)) |</code></span>
<span class="codeline" id="line-534"><code>		(uint64(1)&lt;&lt;(c-64))&amp;(mask&gt;&gt;64)) != 0</code></span>
<span class="codeline" id="line-535"><code>}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>// getOffer return valid offer for header negotiation</code></span>
<span class="codeline" id="line-538"><code>func getOffer(header string, isAccepted func(spec, offer, specParams string) bool, offers ...string) string {</code></span>
<span class="codeline" id="line-539"><code>	if len(offers) == 0 {</code></span>
<span class="codeline" id="line-540"><code>		return ""</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code>	if header == "" {</code></span>
<span class="codeline" id="line-543"><code>		return offers[0]</code></span>
<span class="codeline" id="line-544"><code>	}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>	acceptedTypes := make([]acceptedType, 0, 8)</code></span>
<span class="codeline" id="line-547"><code>	order := 0</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>	// Parse header and get accepted types with their quality and specificity</code></span>
<span class="codeline" id="line-550"><code>	// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields</code></span>
<span class="codeline" id="line-551"><code>	forEachMediaRange(header, func(accept string) {</code></span>
<span class="codeline" id="line-552"><code>		order++</code></span>
<span class="codeline" id="line-553"><code>		spec, quality, params := accept, 1.0, ""</code></span>
<span class="codeline" id="line-554"><code></code></span>
<span class="codeline" id="line-555"><code>		if i := strings.IndexByte(accept, ';'); i != -1 {</code></span>
<span class="codeline" id="line-556"><code>			spec = accept[:i]</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>			// The vast majority of requests will have only the q parameter with</code></span>
<span class="codeline" id="line-559"><code>			// no whitespace. Check this first to see if we can skip</code></span>
<span class="codeline" id="line-560"><code>			// the more involved parsing.</code></span>
<span class="codeline" id="line-561"><code>			if strings.HasPrefix(accept[i:], ";q=") &amp;&amp; strings.IndexByte(accept[i+3:], ';') == -1 {</code></span>
<span class="codeline" id="line-562"><code>				if q, err := fasthttp.ParseUfloat([]byte(utils.TrimRight(accept[i+3:], ' '))); err == nil {</code></span>
<span class="codeline" id="line-563"><code>					quality = q</code></span>
<span class="codeline" id="line-564"><code>				}</code></span>
<span class="codeline" id="line-565"><code>			} else {</code></span>
<span class="codeline" id="line-566"><code>				hasParams := false</code></span>
<span class="codeline" id="line-567"><code>				forEachParameter(accept[i:], func(param, val string) bool {</code></span>
<span class="codeline" id="line-568"><code>					if param == "q" || param == "Q" {</code></span>
<span class="codeline" id="line-569"><code>						if q, err := fasthttp.ParseUfloat([]byte(val)); err == nil {</code></span>
<span class="codeline" id="line-570"><code>							quality = q</code></span>
<span class="codeline" id="line-571"><code>						}</code></span>
<span class="codeline" id="line-572"><code>						return false</code></span>
<span class="codeline" id="line-573"><code>					}</code></span>
<span class="codeline" id="line-574"><code>					hasParams = true</code></span>
<span class="codeline" id="line-575"><code>					return true</code></span>
<span class="codeline" id="line-576"><code>				})</code></span>
<span class="codeline" id="line-577"><code>				if hasParams {</code></span>
<span class="codeline" id="line-578"><code>					params = accept[i:]</code></span>
<span class="codeline" id="line-579"><code>				}</code></span>
<span class="codeline" id="line-580"><code>			}</code></span>
<span class="codeline" id="line-581"><code>			// Skip this accept type if quality is 0.0</code></span>
<span class="codeline" id="line-582"><code>			// See: https://www.rfc-editor.org/rfc/rfc9110#quality.values</code></span>
<span class="codeline" id="line-583"><code>			if quality == 0.0 {</code></span>
<span class="codeline" id="line-584"><code>				return</code></span>
<span class="codeline" id="line-585"><code>			}</code></span>
<span class="codeline" id="line-586"><code>		}</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>		spec = utils.TrimRight(spec, ' ')</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>		// Get specificity</code></span>
<span class="codeline" id="line-591"><code>		var specificity int</code></span>
<span class="codeline" id="line-592"><code>		// check for wildcard this could be a mime */* or a wildcard character *</code></span>
<span class="codeline" id="line-593"><code>		if spec == "*/*" || spec == "*" {</code></span>
<span class="codeline" id="line-594"><code>			specificity = 1</code></span>
<span class="codeline" id="line-595"><code>		} else if strings.HasSuffix(spec, "/*") {</code></span>
<span class="codeline" id="line-596"><code>			specificity = 2</code></span>
<span class="codeline" id="line-597"><code>		} else if strings.IndexByte(spec, '/') != -1 {</code></span>
<span class="codeline" id="line-598"><code>			specificity = 3</code></span>
<span class="codeline" id="line-599"><code>		} else {</code></span>
<span class="codeline" id="line-600"><code>			specificity = 4</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code></code></span>
<span class="codeline" id="line-603"><code>		// Add to accepted types</code></span>
<span class="codeline" id="line-604"><code>		acceptedTypes = append(acceptedTypes, acceptedType{spec, quality, specificity, order, params})</code></span>
<span class="codeline" id="line-605"><code>	})</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	if len(acceptedTypes) &gt; 1 {</code></span>
<span class="codeline" id="line-608"><code>		// Sort accepted types by quality and specificity, preserving order of equal elements</code></span>
<span class="codeline" id="line-609"><code>		sortAcceptedTypes(&amp;acceptedTypes)</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>	// Find the first offer that matches the accepted types</code></span>
<span class="codeline" id="line-613"><code>	for _, acceptedType := range acceptedTypes {</code></span>
<span class="codeline" id="line-614"><code>		for _, offer := range offers {</code></span>
<span class="codeline" id="line-615"><code>			if len(offer) == 0 {</code></span>
<span class="codeline" id="line-616"><code>				continue</code></span>
<span class="codeline" id="line-617"><code>			}</code></span>
<span class="codeline" id="line-618"><code>			if isAccepted(acceptedType.spec, offer, acceptedType.params) {</code></span>
<span class="codeline" id="line-619"><code>				return offer</code></span>
<span class="codeline" id="line-620"><code>			}</code></span>
<span class="codeline" id="line-621"><code>		}</code></span>
<span class="codeline" id="line-622"><code>	}</code></span>
<span class="codeline" id="line-623"><code></code></span>
<span class="codeline" id="line-624"><code>	return ""</code></span>
<span class="codeline" id="line-625"><code>}</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>// sortAcceptedTypes sorts accepted types by quality and specificity, preserving order of equal elements</code></span>
<span class="codeline" id="line-628"><code>// A type with parameters has higher priority than an equivalent one without parameters.</code></span>
<span class="codeline" id="line-629"><code>// e.g., text/html;a=1;b=2 comes before text/html;a=1</code></span>
<span class="codeline" id="line-630"><code>// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields</code></span>
<span class="codeline" id="line-631"><code>func sortAcceptedTypes(acceptedTypes *[]acceptedType) {</code></span>
<span class="codeline" id="line-632"><code>	if acceptedTypes == nil || len(*acceptedTypes) &lt; 2 {</code></span>
<span class="codeline" id="line-633"><code>		return</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	at := *acceptedTypes</code></span>
<span class="codeline" id="line-636"><code></code></span>
<span class="codeline" id="line-637"><code>	for i := 1; i &lt; len(at); i++ {</code></span>
<span class="codeline" id="line-638"><code>		lo, hi := 0, i-1</code></span>
<span class="codeline" id="line-639"><code>		for lo &lt;= hi {</code></span>
<span class="codeline" id="line-640"><code>			mid := (lo + hi) / 2</code></span>
<span class="codeline" id="line-641"><code>			if at[i].quality &lt; at[mid].quality ||</code></span>
<span class="codeline" id="line-642"><code>				(at[i].quality == at[mid].quality &amp;&amp; at[i].specificity &lt; at[mid].specificity) ||</code></span>
<span class="codeline" id="line-643"><code>				(at[i].quality == at[mid].quality &amp;&amp; at[i].specificity &lt; at[mid].specificity &amp;&amp; len(at[i].params) &lt; len(at[mid].params)) ||</code></span>
<span class="codeline" id="line-644"><code>				(at[i].quality == at[mid].quality &amp;&amp; at[i].specificity == at[mid].specificity &amp;&amp; len(at[i].params) == len(at[mid].params) &amp;&amp; at[i].order &gt; at[mid].order) {</code></span>
<span class="codeline" id="line-645"><code>				lo = mid + 1</code></span>
<span class="codeline" id="line-646"><code>			} else {</code></span>
<span class="codeline" id="line-647"><code>				hi = mid - 1</code></span>
<span class="codeline" id="line-648"><code>			}</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>		for j := i; j &gt; lo; j-- {</code></span>
<span class="codeline" id="line-651"><code>			at[j-1], at[j] = at[j], at[j-1]</code></span>
<span class="codeline" id="line-652"><code>		}</code></span>
<span class="codeline" id="line-653"><code>	}</code></span>
<span class="codeline" id="line-654"><code>}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>func matchEtag(s, etag string) bool {</code></span>
<span class="codeline" id="line-657"><code>	if s == etag || s == "W/"+etag || "W/"+s == etag {</code></span>
<span class="codeline" id="line-658"><code>		return true</code></span>
<span class="codeline" id="line-659"><code>	}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>	return false</code></span>
<span class="codeline" id="line-662"><code>}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>func (app *App) isEtagStale(etag string, noneMatchBytes []byte) bool {</code></span>
<span class="codeline" id="line-665"><code>	var start, end int</code></span>
<span class="codeline" id="line-666"><code></code></span>
<span class="codeline" id="line-667"><code>	// Adapted from:</code></span>
<span class="codeline" id="line-668"><code>	// https://github.com/jshttp/fresh/blob/10e0471669dbbfbfd8de65bc6efac2ddd0bfa057/index.js#L110</code></span>
<span class="codeline" id="line-669"><code>	for i := range noneMatchBytes {</code></span>
<span class="codeline" id="line-670"><code>		switch noneMatchBytes[i] {</code></span>
<span class="codeline" id="line-671"><code>		case 0x20:</code></span>
<span class="codeline" id="line-672"><code>			if start == end {</code></span>
<span class="codeline" id="line-673"><code>				start = i + 1</code></span>
<span class="codeline" id="line-674"><code>				end = i + 1</code></span>
<span class="codeline" id="line-675"><code>			}</code></span>
<span class="codeline" id="line-676"><code>		case 0x2c:</code></span>
<span class="codeline" id="line-677"><code>			if matchEtag(app.getString(noneMatchBytes[start:end]), etag) {</code></span>
<span class="codeline" id="line-678"><code>				return false</code></span>
<span class="codeline" id="line-679"><code>			}</code></span>
<span class="codeline" id="line-680"><code>			start = i + 1</code></span>
<span class="codeline" id="line-681"><code>			end = i + 1</code></span>
<span class="codeline" id="line-682"><code>		default:</code></span>
<span class="codeline" id="line-683"><code>			end = i + 1</code></span>
<span class="codeline" id="line-684"><code>		}</code></span>
<span class="codeline" id="line-685"><code>	}</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>	return !matchEtag(app.getString(noneMatchBytes[start:end]), etag)</code></span>
<span class="codeline" id="line-688"><code>}</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>func parseAddr(raw string) (string, string) { //nolint:revive // Returns (host, port)</code></span>
<span class="codeline" id="line-691"><code>	if i := strings.LastIndex(raw, ":"); i != -1 {</code></span>
<span class="codeline" id="line-692"><code>		return raw[:i], raw[i+1:]</code></span>
<span class="codeline" id="line-693"><code>	}</code></span>
<span class="codeline" id="line-694"><code>	return raw, ""</code></span>
<span class="codeline" id="line-695"><code>}</code></span>
<span class="codeline" id="line-696"><code></code></span>
<span class="codeline" id="line-697"><code>const noCacheValue = "no-cache"</code></span>
<span class="codeline" id="line-698"><code></code></span>
<span class="codeline" id="line-699"><code>// isNoCache checks if the cacheControl header value is a `no-cache`.</code></span>
<span class="codeline" id="line-700"><code>func isNoCache(cacheControl string) bool {</code></span>
<span class="codeline" id="line-701"><code>	i := strings.Index(cacheControl, noCacheValue)</code></span>
<span class="codeline" id="line-702"><code>	if i == -1 {</code></span>
<span class="codeline" id="line-703"><code>		return false</code></span>
<span class="codeline" id="line-704"><code>	}</code></span>
<span class="codeline" id="line-705"><code></code></span>
<span class="codeline" id="line-706"><code>	// Xno-cache</code></span>
<span class="codeline" id="line-707"><code>	if i &gt; 0 &amp;&amp; !(cacheControl[i-1] == ' ' || cacheControl[i-1] == ',') {</code></span>
<span class="codeline" id="line-708"><code>		return false</code></span>
<span class="codeline" id="line-709"><code>	}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>	// bla bla, no-cache</code></span>
<span class="codeline" id="line-712"><code>	if i+len(noCacheValue) == len(cacheControl) {</code></span>
<span class="codeline" id="line-713"><code>		return true</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>	// bla bla, no-cacheX</code></span>
<span class="codeline" id="line-717"><code>	if cacheControl[i+len(noCacheValue)] != ',' {</code></span>
<span class="codeline" id="line-718"><code>		return false</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code></code></span>
<span class="codeline" id="line-721"><code>	// OK</code></span>
<span class="codeline" id="line-722"><code>	return true</code></span>
<span class="codeline" id="line-723"><code>}</code></span>
<span class="codeline" id="line-724"><code></code></span>
<span class="codeline" id="line-725"><code>type testConn struct {</code></span>
<span class="codeline" id="line-726"><code>	r bytes.Buffer</code></span>
<span class="codeline" id="line-727"><code>	w bytes.Buffer</code></span>
<span class="codeline" id="line-728"><code>}</code></span>
<span class="codeline" id="line-729"><code></code></span>
<span class="codeline" id="line-730"><code>func (c *testConn) Read(b []byte) (int, error)  { return c.r.Read(b) }  //nolint:wrapcheck // This must not be wrapped</code></span>
<span class="codeline" id="line-731"><code>func (c *testConn) Write(b []byte) (int, error) { return c.w.Write(b) } //nolint:wrapcheck // This must not be wrapped</code></span>
<span class="codeline" id="line-732"><code>func (*testConn) Close() error                  { return nil }</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>func (*testConn) LocalAddr() net.Addr                { return &amp;net.TCPAddr{Port: 0, Zone: "", IP: net.IPv4zero} }</code></span>
<span class="codeline" id="line-735"><code>func (*testConn) RemoteAddr() net.Addr               { return &amp;net.TCPAddr{Port: 0, Zone: "", IP: net.IPv4zero} }</code></span>
<span class="codeline" id="line-736"><code>func (*testConn) SetDeadline(_ time.Time) error      { return nil }</code></span>
<span class="codeline" id="line-737"><code>func (*testConn) SetReadDeadline(_ time.Time) error  { return nil }</code></span>
<span class="codeline" id="line-738"><code>func (*testConn) SetWriteDeadline(_ time.Time) error { return nil }</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>func getStringImmutable(b []byte) string {</code></span>
<span class="codeline" id="line-741"><code>	return string(b)</code></span>
<span class="codeline" id="line-742"><code>}</code></span>
<span class="codeline" id="line-743"><code></code></span>
<span class="codeline" id="line-744"><code>func getBytesImmutable(s string) []byte {</code></span>
<span class="codeline" id="line-745"><code>	return []byte(s)</code></span>
<span class="codeline" id="line-746"><code>}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>// HTTP methods and their unique INTs</code></span>
<span class="codeline" id="line-749"><code>func (app *App) methodInt(s string) int {</code></span>
<span class="codeline" id="line-750"><code>	// For better performance</code></span>
<span class="codeline" id="line-751"><code>	if len(app.configured.RequestMethods) == 0 {</code></span>
<span class="codeline" id="line-752"><code>		// TODO: Use iota instead</code></span>
<span class="codeline" id="line-753"><code>		switch s {</code></span>
<span class="codeline" id="line-754"><code>		case MethodGet:</code></span>
<span class="codeline" id="line-755"><code>			return 0</code></span>
<span class="codeline" id="line-756"><code>		case MethodHead:</code></span>
<span class="codeline" id="line-757"><code>			return 1</code></span>
<span class="codeline" id="line-758"><code>		case MethodPost:</code></span>
<span class="codeline" id="line-759"><code>			return 2</code></span>
<span class="codeline" id="line-760"><code>		case MethodPut:</code></span>
<span class="codeline" id="line-761"><code>			return 3</code></span>
<span class="codeline" id="line-762"><code>		case MethodDelete:</code></span>
<span class="codeline" id="line-763"><code>			return 4</code></span>
<span class="codeline" id="line-764"><code>		case MethodConnect:</code></span>
<span class="codeline" id="line-765"><code>			return 5</code></span>
<span class="codeline" id="line-766"><code>		case MethodOptions:</code></span>
<span class="codeline" id="line-767"><code>			return 6</code></span>
<span class="codeline" id="line-768"><code>		case MethodTrace:</code></span>
<span class="codeline" id="line-769"><code>			return 7</code></span>
<span class="codeline" id="line-770"><code>		case MethodPatch:</code></span>
<span class="codeline" id="line-771"><code>			return 8</code></span>
<span class="codeline" id="line-772"><code>		default:</code></span>
<span class="codeline" id="line-773"><code>			return -1</code></span>
<span class="codeline" id="line-774"><code>		}</code></span>
<span class="codeline" id="line-775"><code>	}</code></span>
<span class="codeline" id="line-776"><code></code></span>
<span class="codeline" id="line-777"><code>	// For method customization</code></span>
<span class="codeline" id="line-778"><code>	for i, v := range app.config.RequestMethods {</code></span>
<span class="codeline" id="line-779"><code>		if s == v {</code></span>
<span class="codeline" id="line-780"><code>			return i</code></span>
<span class="codeline" id="line-781"><code>		}</code></span>
<span class="codeline" id="line-782"><code>	}</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>	return -1</code></span>
<span class="codeline" id="line-785"><code>}</code></span>
<span class="codeline" id="line-786"><code></code></span>
<span class="codeline" id="line-787"><code>// IsMethodSafe reports whether the HTTP method is considered safe.</code></span>
<span class="codeline" id="line-788"><code>// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.1</code></span>
<span class="codeline" id="line-789"><code>func IsMethodSafe(m string) bool {</code></span>
<span class="codeline" id="line-790"><code>	switch m {</code></span>
<span class="codeline" id="line-791"><code>	case MethodGet,</code></span>
<span class="codeline" id="line-792"><code>		MethodHead,</code></span>
<span class="codeline" id="line-793"><code>		MethodOptions,</code></span>
<span class="codeline" id="line-794"><code>		MethodTrace:</code></span>
<span class="codeline" id="line-795"><code>		return true</code></span>
<span class="codeline" id="line-796"><code>	default:</code></span>
<span class="codeline" id="line-797"><code>		return false</code></span>
<span class="codeline" id="line-798"><code>	}</code></span>
<span class="codeline" id="line-799"><code>}</code></span>
<span class="codeline" id="line-800"><code></code></span>
<span class="codeline" id="line-801"><code>// IsMethodIdempotent reports whether the HTTP method is considered idempotent.</code></span>
<span class="codeline" id="line-802"><code>// See https://datatracker.ietf.org/doc/html/rfc9110#section-9.2.2</code></span>
<span class="codeline" id="line-803"><code>func IsMethodIdempotent(m string) bool {</code></span>
<span class="codeline" id="line-804"><code>	if IsMethodSafe(m) {</code></span>
<span class="codeline" id="line-805"><code>		return true</code></span>
<span class="codeline" id="line-806"><code>	}</code></span>
<span class="codeline" id="line-807"><code></code></span>
<span class="codeline" id="line-808"><code>	switch m {</code></span>
<span class="codeline" id="line-809"><code>	case MethodPut, MethodDelete:</code></span>
<span class="codeline" id="line-810"><code>		return true</code></span>
<span class="codeline" id="line-811"><code>	default:</code></span>
<span class="codeline" id="line-812"><code>		return false</code></span>
<span class="codeline" id="line-813"><code>	}</code></span>
<span class="codeline" id="line-814"><code>}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>// HTTP methods were copied from net/http.</code></span>
<span class="codeline" id="line-817"><code>const (</code></span>
<span class="codeline" id="line-818"><code>	MethodGet     = "GET"     // RFC 7231, 4.3.1</code></span>
<span class="codeline" id="line-819"><code>	MethodHead    = "HEAD"    // RFC 7231, 4.3.2</code></span>
<span class="codeline" id="line-820"><code>	MethodPost    = "POST"    // RFC 7231, 4.3.3</code></span>
<span class="codeline" id="line-821"><code>	MethodPut     = "PUT"     // RFC 7231, 4.3.4</code></span>
<span class="codeline" id="line-822"><code>	MethodPatch   = "PATCH"   // RFC 5789</code></span>
<span class="codeline" id="line-823"><code>	MethodDelete  = "DELETE"  // RFC 7231, 4.3.5</code></span>
<span class="codeline" id="line-824"><code>	MethodConnect = "CONNECT" // RFC 7231, 4.3.6</code></span>
<span class="codeline" id="line-825"><code>	MethodOptions = "OPTIONS" // RFC 7231, 4.3.7</code></span>
<span class="codeline" id="line-826"><code>	MethodTrace   = "TRACE"   // RFC 7231, 4.3.8</code></span>
<span class="codeline" id="line-827"><code>	methodUse     = "USE"</code></span>
<span class="codeline" id="line-828"><code>)</code></span>
<span class="codeline" id="line-829"><code></code></span>
<span class="codeline" id="line-830"><code>// MIME types that are commonly used</code></span>
<span class="codeline" id="line-831"><code>const (</code></span>
<span class="codeline" id="line-832"><code>	MIMETextXML         = "text/xml"</code></span>
<span class="codeline" id="line-833"><code>	MIMETextHTML        = "text/html"</code></span>
<span class="codeline" id="line-834"><code>	MIMETextPlain       = "text/plain"</code></span>
<span class="codeline" id="line-835"><code>	MIMETextJavaScript  = "text/javascript"</code></span>
<span class="codeline" id="line-836"><code>	MIMEApplicationXML  = "application/xml"</code></span>
<span class="codeline" id="line-837"><code>	MIMEApplicationJSON = "application/json"</code></span>
<span class="codeline" id="line-838"><code>	// Deprecated: use MIMETextJavaScript instead</code></span>
<span class="codeline" id="line-839"><code>	MIMEApplicationJavaScript = "application/javascript"</code></span>
<span class="codeline" id="line-840"><code>	MIMEApplicationForm       = "application/x-www-form-urlencoded"</code></span>
<span class="codeline" id="line-841"><code>	MIMEOctetStream           = "application/octet-stream"</code></span>
<span class="codeline" id="line-842"><code>	MIMEMultipartForm         = "multipart/form-data"</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>	MIMETextXMLCharsetUTF8         = "text/xml; charset=utf-8"</code></span>
<span class="codeline" id="line-845"><code>	MIMETextHTMLCharsetUTF8        = "text/html; charset=utf-8"</code></span>
<span class="codeline" id="line-846"><code>	MIMETextPlainCharsetUTF8       = "text/plain; charset=utf-8"</code></span>
<span class="codeline" id="line-847"><code>	MIMETextJavaScriptCharsetUTF8  = "text/javascript; charset=utf-8"</code></span>
<span class="codeline" id="line-848"><code>	MIMEApplicationXMLCharsetUTF8  = "application/xml; charset=utf-8"</code></span>
<span class="codeline" id="line-849"><code>	MIMEApplicationJSONCharsetUTF8 = "application/json; charset=utf-8"</code></span>
<span class="codeline" id="line-850"><code>	// Deprecated: use MIMETextJavaScriptCharsetUTF8 instead</code></span>
<span class="codeline" id="line-851"><code>	MIMEApplicationJavaScriptCharsetUTF8 = "application/javascript; charset=utf-8"</code></span>
<span class="codeline" id="line-852"><code>)</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>// HTTP status codes were copied from net/http with the following updates:</code></span>
<span class="codeline" id="line-855"><code>// - Rename StatusNonAuthoritativeInfo to StatusNonAuthoritativeInformation</code></span>
<span class="codeline" id="line-856"><code>// - Add StatusSwitchProxy (306)</code></span>
<span class="codeline" id="line-857"><code>// NOTE: Keep this list in sync with statusMessage</code></span>
<span class="codeline" id="line-858"><code>const (</code></span>
<span class="codeline" id="line-859"><code>	StatusContinue           = 100 // RFC 9110, 15.2.1</code></span>
<span class="codeline" id="line-860"><code>	StatusSwitchingProtocols = 101 // RFC 9110, 15.2.2</code></span>
<span class="codeline" id="line-861"><code>	StatusProcessing         = 102 // RFC 2518, 10.1</code></span>
<span class="codeline" id="line-862"><code>	StatusEarlyHints         = 103 // RFC 8297</code></span>
<span class="codeline" id="line-863"><code></code></span>
<span class="codeline" id="line-864"><code>	StatusOK                          = 200 // RFC 9110, 15.3.1</code></span>
<span class="codeline" id="line-865"><code>	StatusCreated                     = 201 // RFC 9110, 15.3.2</code></span>
<span class="codeline" id="line-866"><code>	StatusAccepted                    = 202 // RFC 9110, 15.3.3</code></span>
<span class="codeline" id="line-867"><code>	StatusNonAuthoritativeInformation = 203 // RFC 9110, 15.3.4</code></span>
<span class="codeline" id="line-868"><code>	StatusNoContent                   = 204 // RFC 9110, 15.3.5</code></span>
<span class="codeline" id="line-869"><code>	StatusResetContent                = 205 // RFC 9110, 15.3.6</code></span>
<span class="codeline" id="line-870"><code>	StatusPartialContent              = 206 // RFC 9110, 15.3.7</code></span>
<span class="codeline" id="line-871"><code>	StatusMultiStatus                 = 207 // RFC 4918, 11.1</code></span>
<span class="codeline" id="line-872"><code>	StatusAlreadyReported             = 208 // RFC 5842, 7.1</code></span>
<span class="codeline" id="line-873"><code>	StatusIMUsed                      = 226 // RFC 3229, 10.4.1</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>	StatusMultipleChoices   = 300 // RFC 9110, 15.4.1</code></span>
<span class="codeline" id="line-876"><code>	StatusMovedPermanently  = 301 // RFC 9110, 15.4.2</code></span>
<span class="codeline" id="line-877"><code>	StatusFound             = 302 // RFC 9110, 15.4.3</code></span>
<span class="codeline" id="line-878"><code>	StatusSeeOther          = 303 // RFC 9110, 15.4.4</code></span>
<span class="codeline" id="line-879"><code>	StatusNotModified       = 304 // RFC 9110, 15.4.5</code></span>
<span class="codeline" id="line-880"><code>	StatusUseProxy          = 305 // RFC 9110, 15.4.6</code></span>
<span class="codeline" id="line-881"><code>	StatusSwitchProxy       = 306 // RFC 9110, 15.4.7 (Unused)</code></span>
<span class="codeline" id="line-882"><code>	StatusTemporaryRedirect = 307 // RFC 9110, 15.4.8</code></span>
<span class="codeline" id="line-883"><code>	StatusPermanentRedirect = 308 // RFC 9110, 15.4.9</code></span>
<span class="codeline" id="line-884"><code></code></span>
<span class="codeline" id="line-885"><code>	StatusBadRequest                   = 400 // RFC 9110, 15.5.1</code></span>
<span class="codeline" id="line-886"><code>	StatusUnauthorized                 = 401 // RFC 9110, 15.5.2</code></span>
<span class="codeline" id="line-887"><code>	StatusPaymentRequired              = 402 // RFC 9110, 15.5.3</code></span>
<span class="codeline" id="line-888"><code>	StatusForbidden                    = 403 // RFC 9110, 15.5.4</code></span>
<span class="codeline" id="line-889"><code>	StatusNotFound                     = 404 // RFC 9110, 15.5.5</code></span>
<span class="codeline" id="line-890"><code>	StatusMethodNotAllowed             = 405 // RFC 9110, 15.5.6</code></span>
<span class="codeline" id="line-891"><code>	StatusNotAcceptable                = 406 // RFC 9110, 15.5.7</code></span>
<span class="codeline" id="line-892"><code>	StatusProxyAuthRequired            = 407 // RFC 9110, 15.5.8</code></span>
<span class="codeline" id="line-893"><code>	StatusRequestTimeout               = 408 // RFC 9110, 15.5.9</code></span>
<span class="codeline" id="line-894"><code>	StatusConflict                     = 409 // RFC 9110, 15.5.10</code></span>
<span class="codeline" id="line-895"><code>	StatusGone                         = 410 // RFC 9110, 15.5.11</code></span>
<span class="codeline" id="line-896"><code>	StatusLengthRequired               = 411 // RFC 9110, 15.5.12</code></span>
<span class="codeline" id="line-897"><code>	StatusPreconditionFailed           = 412 // RFC 9110, 15.5.13</code></span>
<span class="codeline" id="line-898"><code>	StatusRequestEntityTooLarge        = 413 // RFC 9110, 15.5.14</code></span>
<span class="codeline" id="line-899"><code>	StatusRequestURITooLong            = 414 // RFC 9110, 15.5.15</code></span>
<span class="codeline" id="line-900"><code>	StatusUnsupportedMediaType         = 415 // RFC 9110, 15.5.16</code></span>
<span class="codeline" id="line-901"><code>	StatusRequestedRangeNotSatisfiable = 416 // RFC 9110, 15.5.17</code></span>
<span class="codeline" id="line-902"><code>	StatusExpectationFailed            = 417 // RFC 9110, 15.5.18</code></span>
<span class="codeline" id="line-903"><code>	StatusTeapot                       = 418 // RFC 9110, 15.5.19 (Unused)</code></span>
<span class="codeline" id="line-904"><code>	StatusMisdirectedRequest           = 421 // RFC 9110, 15.5.20</code></span>
<span class="codeline" id="line-905"><code>	StatusUnprocessableEntity          = 422 // RFC 9110, 15.5.21</code></span>
<span class="codeline" id="line-906"><code>	StatusLocked                       = 423 // RFC 4918, 11.3</code></span>
<span class="codeline" id="line-907"><code>	StatusFailedDependency             = 424 // RFC 4918, 11.4</code></span>
<span class="codeline" id="line-908"><code>	StatusTooEarly                     = 425 // RFC 8470, 5.2.</code></span>
<span class="codeline" id="line-909"><code>	StatusUpgradeRequired              = 426 // RFC 9110, 15.5.22</code></span>
<span class="codeline" id="line-910"><code>	StatusPreconditionRequired         = 428 // RFC 6585, 3</code></span>
<span class="codeline" id="line-911"><code>	StatusTooManyRequests              = 429 // RFC 6585, 4</code></span>
<span class="codeline" id="line-912"><code>	StatusRequestHeaderFieldsTooLarge  = 431 // RFC 6585, 5</code></span>
<span class="codeline" id="line-913"><code>	StatusUnavailableForLegalReasons   = 451 // RFC 7725, 3</code></span>
<span class="codeline" id="line-914"><code></code></span>
<span class="codeline" id="line-915"><code>	StatusInternalServerError           = 500 // RFC 9110, 15.6.1</code></span>
<span class="codeline" id="line-916"><code>	StatusNotImplemented                = 501 // RFC 9110, 15.6.2</code></span>
<span class="codeline" id="line-917"><code>	StatusBadGateway                    = 502 // RFC 9110, 15.6.3</code></span>
<span class="codeline" id="line-918"><code>	StatusServiceUnavailable            = 503 // RFC 9110, 15.6.4</code></span>
<span class="codeline" id="line-919"><code>	StatusGatewayTimeout                = 504 // RFC 9110, 15.6.5</code></span>
<span class="codeline" id="line-920"><code>	StatusHTTPVersionNotSupported       = 505 // RFC 9110, 15.6.6</code></span>
<span class="codeline" id="line-921"><code>	StatusVariantAlsoNegotiates         = 506 // RFC 2295, 8.1</code></span>
<span class="codeline" id="line-922"><code>	StatusInsufficientStorage           = 507 // RFC 4918, 11.5</code></span>
<span class="codeline" id="line-923"><code>	StatusLoopDetected                  = 508 // RFC 5842, 7.2</code></span>
<span class="codeline" id="line-924"><code>	StatusNotExtended                   = 510 // RFC 2774, 7</code></span>
<span class="codeline" id="line-925"><code>	StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6</code></span>
<span class="codeline" id="line-926"><code>)</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>// Errors</code></span>
<span class="codeline" id="line-929"><code>var (</code></span>
<span class="codeline" id="line-930"><code>	ErrBadRequest                   = NewError(StatusBadRequest)                   // 400</code></span>
<span class="codeline" id="line-931"><code>	ErrUnauthorized                 = NewError(StatusUnauthorized)                 // 401</code></span>
<span class="codeline" id="line-932"><code>	ErrPaymentRequired              = NewError(StatusPaymentRequired)              // 402</code></span>
<span class="codeline" id="line-933"><code>	ErrForbidden                    = NewError(StatusForbidden)                    // 403</code></span>
<span class="codeline" id="line-934"><code>	ErrNotFound                     = NewError(StatusNotFound)                     // 404</code></span>
<span class="codeline" id="line-935"><code>	ErrMethodNotAllowed             = NewError(StatusMethodNotAllowed)             // 405</code></span>
<span class="codeline" id="line-936"><code>	ErrNotAcceptable                = NewError(StatusNotAcceptable)                // 406</code></span>
<span class="codeline" id="line-937"><code>	ErrProxyAuthRequired            = NewError(StatusProxyAuthRequired)            // 407</code></span>
<span class="codeline" id="line-938"><code>	ErrRequestTimeout               = NewError(StatusRequestTimeout)               // 408</code></span>
<span class="codeline" id="line-939"><code>	ErrConflict                     = NewError(StatusConflict)                     // 409</code></span>
<span class="codeline" id="line-940"><code>	ErrGone                         = NewError(StatusGone)                         // 410</code></span>
<span class="codeline" id="line-941"><code>	ErrLengthRequired               = NewError(StatusLengthRequired)               // 411</code></span>
<span class="codeline" id="line-942"><code>	ErrPreconditionFailed           = NewError(StatusPreconditionFailed)           // 412</code></span>
<span class="codeline" id="line-943"><code>	ErrRequestEntityTooLarge        = NewError(StatusRequestEntityTooLarge)        // 413</code></span>
<span class="codeline" id="line-944"><code>	ErrRequestURITooLong            = NewError(StatusRequestURITooLong)            // 414</code></span>
<span class="codeline" id="line-945"><code>	ErrUnsupportedMediaType         = NewError(StatusUnsupportedMediaType)         // 415</code></span>
<span class="codeline" id="line-946"><code>	ErrRequestedRangeNotSatisfiable = NewError(StatusRequestedRangeNotSatisfiable) // 416</code></span>
<span class="codeline" id="line-947"><code>	ErrExpectationFailed            = NewError(StatusExpectationFailed)            // 417</code></span>
<span class="codeline" id="line-948"><code>	ErrTeapot                       = NewError(StatusTeapot)                       // 418</code></span>
<span class="codeline" id="line-949"><code>	ErrMisdirectedRequest           = NewError(StatusMisdirectedRequest)           // 421</code></span>
<span class="codeline" id="line-950"><code>	ErrUnprocessableEntity          = NewError(StatusUnprocessableEntity)          // 422</code></span>
<span class="codeline" id="line-951"><code>	ErrLocked                       = NewError(StatusLocked)                       // 423</code></span>
<span class="codeline" id="line-952"><code>	ErrFailedDependency             = NewError(StatusFailedDependency)             // 424</code></span>
<span class="codeline" id="line-953"><code>	ErrTooEarly                     = NewError(StatusTooEarly)                     // 425</code></span>
<span class="codeline" id="line-954"><code>	ErrUpgradeRequired              = NewError(StatusUpgradeRequired)              // 426</code></span>
<span class="codeline" id="line-955"><code>	ErrPreconditionRequired         = NewError(StatusPreconditionRequired)         // 428</code></span>
<span class="codeline" id="line-956"><code>	ErrTooManyRequests              = NewError(StatusTooManyRequests)              // 429</code></span>
<span class="codeline" id="line-957"><code>	ErrRequestHeaderFieldsTooLarge  = NewError(StatusRequestHeaderFieldsTooLarge)  // 431</code></span>
<span class="codeline" id="line-958"><code>	ErrUnavailableForLegalReasons   = NewError(StatusUnavailableForLegalReasons)   // 451</code></span>
<span class="codeline" id="line-959"><code></code></span>
<span class="codeline" id="line-960"><code>	ErrInternalServerError           = NewError(StatusInternalServerError)           // 500</code></span>
<span class="codeline" id="line-961"><code>	ErrNotImplemented                = NewError(StatusNotImplemented)                // 501</code></span>
<span class="codeline" id="line-962"><code>	ErrBadGateway                    = NewError(StatusBadGateway)                    // 502</code></span>
<span class="codeline" id="line-963"><code>	ErrServiceUnavailable            = NewError(StatusServiceUnavailable)            // 503</code></span>
<span class="codeline" id="line-964"><code>	ErrGatewayTimeout                = NewError(StatusGatewayTimeout)                // 504</code></span>
<span class="codeline" id="line-965"><code>	ErrHTTPVersionNotSupported       = NewError(StatusHTTPVersionNotSupported)       // 505</code></span>
<span class="codeline" id="line-966"><code>	ErrVariantAlsoNegotiates         = NewError(StatusVariantAlsoNegotiates)         // 506</code></span>
<span class="codeline" id="line-967"><code>	ErrInsufficientStorage           = NewError(StatusInsufficientStorage)           // 507</code></span>
<span class="codeline" id="line-968"><code>	ErrLoopDetected                  = NewError(StatusLoopDetected)                  // 508</code></span>
<span class="codeline" id="line-969"><code>	ErrNotExtended                   = NewError(StatusNotExtended)                   // 510</code></span>
<span class="codeline" id="line-970"><code>	ErrNetworkAuthenticationRequired = NewError(StatusNetworkAuthenticationRequired) // 511</code></span>
<span class="codeline" id="line-971"><code>)</code></span>
<span class="codeline" id="line-972"><code></code></span>
<span class="codeline" id="line-973"><code>// HTTP Headers were copied from net/http.</code></span>
<span class="codeline" id="line-974"><code>const (</code></span>
<span class="codeline" id="line-975"><code>	HeaderAuthorization                   = "Authorization"</code></span>
<span class="codeline" id="line-976"><code>	HeaderProxyAuthenticate               = "Proxy-Authenticate"</code></span>
<span class="codeline" id="line-977"><code>	HeaderProxyAuthorization              = "Proxy-Authorization"</code></span>
<span class="codeline" id="line-978"><code>	HeaderWWWAuthenticate                 = "WWW-Authenticate"</code></span>
<span class="codeline" id="line-979"><code>	HeaderAge                             = "Age"</code></span>
<span class="codeline" id="line-980"><code>	HeaderCacheControl                    = "Cache-Control"</code></span>
<span class="codeline" id="line-981"><code>	HeaderClearSiteData                   = "Clear-Site-Data"</code></span>
<span class="codeline" id="line-982"><code>	HeaderExpires                         = "Expires"</code></span>
<span class="codeline" id="line-983"><code>	HeaderPragma                          = "Pragma"</code></span>
<span class="codeline" id="line-984"><code>	HeaderWarning                         = "Warning"</code></span>
<span class="codeline" id="line-985"><code>	HeaderAcceptCH                        = "Accept-CH"</code></span>
<span class="codeline" id="line-986"><code>	HeaderAcceptCHLifetime                = "Accept-CH-Lifetime"</code></span>
<span class="codeline" id="line-987"><code>	HeaderContentDPR                      = "Content-DPR"</code></span>
<span class="codeline" id="line-988"><code>	HeaderDPR                             = "DPR"</code></span>
<span class="codeline" id="line-989"><code>	HeaderEarlyData                       = "Early-Data"</code></span>
<span class="codeline" id="line-990"><code>	HeaderSaveData                        = "Save-Data"</code></span>
<span class="codeline" id="line-991"><code>	HeaderViewportWidth                   = "Viewport-Width"</code></span>
<span class="codeline" id="line-992"><code>	HeaderWidth                           = "Width"</code></span>
<span class="codeline" id="line-993"><code>	HeaderETag                            = "ETag"</code></span>
<span class="codeline" id="line-994"><code>	HeaderIfMatch                         = "If-Match"</code></span>
<span class="codeline" id="line-995"><code>	HeaderIfModifiedSince                 = "If-Modified-Since"</code></span>
<span class="codeline" id="line-996"><code>	HeaderIfNoneMatch                     = "If-None-Match"</code></span>
<span class="codeline" id="line-997"><code>	HeaderIfUnmodifiedSince               = "If-Unmodified-Since"</code></span>
<span class="codeline" id="line-998"><code>	HeaderLastModified                    = "Last-Modified"</code></span>
<span class="codeline" id="line-999"><code>	HeaderVary                            = "Vary"</code></span>
<span class="codeline" id="line-1000"><code>	HeaderConnection                      = "Connection"</code></span>
<span class="codeline" id="line-1001"><code>	HeaderKeepAlive                       = "Keep-Alive"</code></span>
<span class="codeline" id="line-1002"><code>	HeaderAccept                          = "Accept"</code></span>
<span class="codeline" id="line-1003"><code>	HeaderAcceptCharset                   = "Accept-Charset"</code></span>
<span class="codeline" id="line-1004"><code>	HeaderAcceptEncoding                  = "Accept-Encoding"</code></span>
<span class="codeline" id="line-1005"><code>	HeaderAcceptLanguage                  = "Accept-Language"</code></span>
<span class="codeline" id="line-1006"><code>	HeaderCookie                          = "Cookie"</code></span>
<span class="codeline" id="line-1007"><code>	HeaderExpect                          = "Expect"</code></span>
<span class="codeline" id="line-1008"><code>	HeaderMaxForwards                     = "Max-Forwards"</code></span>
<span class="codeline" id="line-1009"><code>	HeaderSetCookie                       = "Set-Cookie"</code></span>
<span class="codeline" id="line-1010"><code>	HeaderAccessControlAllowCredentials   = "Access-Control-Allow-Credentials"</code></span>
<span class="codeline" id="line-1011"><code>	HeaderAccessControlAllowHeaders       = "Access-Control-Allow-Headers"</code></span>
<span class="codeline" id="line-1012"><code>	HeaderAccessControlAllowMethods       = "Access-Control-Allow-Methods"</code></span>
<span class="codeline" id="line-1013"><code>	HeaderAccessControlAllowOrigin        = "Access-Control-Allow-Origin"</code></span>
<span class="codeline" id="line-1014"><code>	HeaderAccessControlExposeHeaders      = "Access-Control-Expose-Headers"</code></span>
<span class="codeline" id="line-1015"><code>	HeaderAccessControlMaxAge             = "Access-Control-Max-Age"</code></span>
<span class="codeline" id="line-1016"><code>	HeaderAccessControlRequestHeaders     = "Access-Control-Request-Headers"</code></span>
<span class="codeline" id="line-1017"><code>	HeaderAccessControlRequestMethod      = "Access-Control-Request-Method"</code></span>
<span class="codeline" id="line-1018"><code>	HeaderOrigin                          = "Origin"</code></span>
<span class="codeline" id="line-1019"><code>	HeaderTimingAllowOrigin               = "Timing-Allow-Origin"</code></span>
<span class="codeline" id="line-1020"><code>	HeaderXPermittedCrossDomainPolicies   = "X-Permitted-Cross-Domain-Policies"</code></span>
<span class="codeline" id="line-1021"><code>	HeaderDNT                             = "DNT"</code></span>
<span class="codeline" id="line-1022"><code>	HeaderTk                              = "Tk"</code></span>
<span class="codeline" id="line-1023"><code>	HeaderContentDisposition              = "Content-Disposition"</code></span>
<span class="codeline" id="line-1024"><code>	HeaderContentEncoding                 = "Content-Encoding"</code></span>
<span class="codeline" id="line-1025"><code>	HeaderContentLanguage                 = "Content-Language"</code></span>
<span class="codeline" id="line-1026"><code>	HeaderContentLength                   = "Content-Length"</code></span>
<span class="codeline" id="line-1027"><code>	HeaderContentLocation                 = "Content-Location"</code></span>
<span class="codeline" id="line-1028"><code>	HeaderContentType                     = "Content-Type"</code></span>
<span class="codeline" id="line-1029"><code>	HeaderForwarded                       = "Forwarded"</code></span>
<span class="codeline" id="line-1030"><code>	HeaderVia                             = "Via"</code></span>
<span class="codeline" id="line-1031"><code>	HeaderXForwardedFor                   = "X-Forwarded-For"</code></span>
<span class="codeline" id="line-1032"><code>	HeaderXForwardedHost                  = "X-Forwarded-Host"</code></span>
<span class="codeline" id="line-1033"><code>	HeaderXForwardedProto                 = "X-Forwarded-Proto"</code></span>
<span class="codeline" id="line-1034"><code>	HeaderXForwardedProtocol              = "X-Forwarded-Protocol"</code></span>
<span class="codeline" id="line-1035"><code>	HeaderXForwardedSsl                   = "X-Forwarded-Ssl"</code></span>
<span class="codeline" id="line-1036"><code>	HeaderXUrlScheme                      = "X-Url-Scheme"</code></span>
<span class="codeline" id="line-1037"><code>	HeaderLocation                        = "Location"</code></span>
<span class="codeline" id="line-1038"><code>	HeaderFrom                            = "From"</code></span>
<span class="codeline" id="line-1039"><code>	HeaderHost                            = "Host"</code></span>
<span class="codeline" id="line-1040"><code>	HeaderReferer                         = "Referer"</code></span>
<span class="codeline" id="line-1041"><code>	HeaderReferrerPolicy                  = "Referrer-Policy"</code></span>
<span class="codeline" id="line-1042"><code>	HeaderUserAgent                       = "User-Agent"</code></span>
<span class="codeline" id="line-1043"><code>	HeaderAllow                           = "Allow"</code></span>
<span class="codeline" id="line-1044"><code>	HeaderServer                          = "Server"</code></span>
<span class="codeline" id="line-1045"><code>	HeaderAcceptRanges                    = "Accept-Ranges"</code></span>
<span class="codeline" id="line-1046"><code>	HeaderContentRange                    = "Content-Range"</code></span>
<span class="codeline" id="line-1047"><code>	HeaderIfRange                         = "If-Range"</code></span>
<span class="codeline" id="line-1048"><code>	HeaderRange                           = "Range"</code></span>
<span class="codeline" id="line-1049"><code>	HeaderContentSecurityPolicy           = "Content-Security-Policy"</code></span>
<span class="codeline" id="line-1050"><code>	HeaderContentSecurityPolicyReportOnly = "Content-Security-Policy-Report-Only"</code></span>
<span class="codeline" id="line-1051"><code>	HeaderCrossOriginResourcePolicy       = "Cross-Origin-Resource-Policy"</code></span>
<span class="codeline" id="line-1052"><code>	HeaderExpectCT                        = "Expect-CT"</code></span>
<span class="codeline" id="line-1053"><code>	// Deprecated: use HeaderPermissionsPolicy instead</code></span>
<span class="codeline" id="line-1054"><code>	HeaderFeaturePolicy           = "Feature-Policy"</code></span>
<span class="codeline" id="line-1055"><code>	HeaderPermissionsPolicy       = "Permissions-Policy"</code></span>
<span class="codeline" id="line-1056"><code>	HeaderPublicKeyPins           = "Public-Key-Pins"</code></span>
<span class="codeline" id="line-1057"><code>	HeaderPublicKeyPinsReportOnly = "Public-Key-Pins-Report-Only"</code></span>
<span class="codeline" id="line-1058"><code>	HeaderStrictTransportSecurity = "Strict-Transport-Security"</code></span>
<span class="codeline" id="line-1059"><code>	HeaderUpgradeInsecureRequests = "Upgrade-Insecure-Requests"</code></span>
<span class="codeline" id="line-1060"><code>	HeaderXContentTypeOptions     = "X-Content-Type-Options"</code></span>
<span class="codeline" id="line-1061"><code>	HeaderXDownloadOptions        = "X-Download-Options"</code></span>
<span class="codeline" id="line-1062"><code>	HeaderXFrameOptions           = "X-Frame-Options"</code></span>
<span class="codeline" id="line-1063"><code>	HeaderXPoweredBy              = "X-Powered-By"</code></span>
<span class="codeline" id="line-1064"><code>	HeaderXXSSProtection          = "X-XSS-Protection"</code></span>
<span class="codeline" id="line-1065"><code>	HeaderLastEventID             = "Last-Event-ID"</code></span>
<span class="codeline" id="line-1066"><code>	HeaderNEL                     = "NEL"</code></span>
<span class="codeline" id="line-1067"><code>	HeaderPingFrom                = "Ping-From"</code></span>
<span class="codeline" id="line-1068"><code>	HeaderPingTo                  = "Ping-To"</code></span>
<span class="codeline" id="line-1069"><code>	HeaderReportTo                = "Report-To"</code></span>
<span class="codeline" id="line-1070"><code>	HeaderTE                      = "TE"</code></span>
<span class="codeline" id="line-1071"><code>	HeaderTrailer                 = "Trailer"</code></span>
<span class="codeline" id="line-1072"><code>	HeaderTransferEncoding        = "Transfer-Encoding"</code></span>
<span class="codeline" id="line-1073"><code>	HeaderSecWebSocketAccept      = "Sec-WebSocket-Accept"</code></span>
<span class="codeline" id="line-1074"><code>	HeaderSecWebSocketExtensions  = "Sec-WebSocket-Extensions"</code></span>
<span class="codeline" id="line-1075"><code>	HeaderSecWebSocketKey         = "Sec-WebSocket-Key"</code></span>
<span class="codeline" id="line-1076"><code>	HeaderSecWebSocketProtocol    = "Sec-WebSocket-Protocol"</code></span>
<span class="codeline" id="line-1077"><code>	HeaderSecWebSocketVersion     = "Sec-WebSocket-Version"</code></span>
<span class="codeline" id="line-1078"><code>	HeaderAcceptPatch             = "Accept-Patch"</code></span>
<span class="codeline" id="line-1079"><code>	HeaderAcceptPushPolicy        = "Accept-Push-Policy"</code></span>
<span class="codeline" id="line-1080"><code>	HeaderAcceptSignature         = "Accept-Signature"</code></span>
<span class="codeline" id="line-1081"><code>	HeaderAltSvc                  = "Alt-Svc"</code></span>
<span class="codeline" id="line-1082"><code>	HeaderDate                    = "Date"</code></span>
<span class="codeline" id="line-1083"><code>	HeaderIndex                   = "Index"</code></span>
<span class="codeline" id="line-1084"><code>	HeaderLargeAllocation         = "Large-Allocation"</code></span>
<span class="codeline" id="line-1085"><code>	HeaderLink                    = "Link"</code></span>
<span class="codeline" id="line-1086"><code>	HeaderPushPolicy              = "Push-Policy"</code></span>
<span class="codeline" id="line-1087"><code>	HeaderRetryAfter              = "Retry-After"</code></span>
<span class="codeline" id="line-1088"><code>	HeaderServerTiming            = "Server-Timing"</code></span>
<span class="codeline" id="line-1089"><code>	HeaderSignature               = "Signature"</code></span>
<span class="codeline" id="line-1090"><code>	HeaderSignedHeaders           = "Signed-Headers"</code></span>
<span class="codeline" id="line-1091"><code>	HeaderSourceMap               = "SourceMap"</code></span>
<span class="codeline" id="line-1092"><code>	HeaderUpgrade                 = "Upgrade"</code></span>
<span class="codeline" id="line-1093"><code>	HeaderXDNSPrefetchControl     = "X-DNS-Prefetch-Control"</code></span>
<span class="codeline" id="line-1094"><code>	HeaderXPingback               = "X-Pingback"</code></span>
<span class="codeline" id="line-1095"><code>	HeaderXRequestID              = "X-Request-ID"</code></span>
<span class="codeline" id="line-1096"><code>	HeaderXRequestedWith          = "X-Requested-With"</code></span>
<span class="codeline" id="line-1097"><code>	HeaderXRobotsTag              = "X-Robots-Tag"</code></span>
<span class="codeline" id="line-1098"><code>	HeaderXUACompatible           = "X-UA-Compatible"</code></span>
<span class="codeline" id="line-1099"><code>)</code></span>
<span class="codeline" id="line-1100"><code></code></span>
<span class="codeline" id="line-1101"><code>// Network types that are commonly used</code></span>
<span class="codeline" id="line-1102"><code>const (</code></span>
<span class="codeline" id="line-1103"><code>	NetworkTCP  = "tcp"</code></span>
<span class="codeline" id="line-1104"><code>	NetworkTCP4 = "tcp4"</code></span>
<span class="codeline" id="line-1105"><code>	NetworkTCP6 = "tcp6"</code></span>
<span class="codeline" id="line-1106"><code>)</code></span>
<span class="codeline" id="line-1107"><code></code></span>
<span class="codeline" id="line-1108"><code>// Compression types</code></span>
<span class="codeline" id="line-1109"><code>const (</code></span>
<span class="codeline" id="line-1110"><code>	StrGzip    = "gzip"</code></span>
<span class="codeline" id="line-1111"><code>	StrBr      = "br"</code></span>
<span class="codeline" id="line-1112"><code>	StrDeflate = "deflate"</code></span>
<span class="codeline" id="line-1113"><code>	StrBrotli  = "brotli"</code></span>
<span class="codeline" id="line-1114"><code>)</code></span>
<span class="codeline" id="line-1115"><code></code></span>
<span class="codeline" id="line-1116"><code>// Cookie SameSite</code></span>
<span class="codeline" id="line-1117"><code>// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7</code></span>
<span class="codeline" id="line-1118"><code>const (</code></span>
<span class="codeline" id="line-1119"><code>	CookieSameSiteDisabled   = "disabled" // not in RFC, just control "SameSite" attribute will not be set.</code></span>
<span class="codeline" id="line-1120"><code>	CookieSameSiteLaxMode    = "lax"</code></span>
<span class="codeline" id="line-1121"><code>	CookieSameSiteStrictMode = "strict"</code></span>
<span class="codeline" id="line-1122"><code>	CookieSameSiteNoneMode   = "none"</code></span>
<span class="codeline" id="line-1123"><code>)</code></span>
<span class="codeline" id="line-1124"><code></code></span>
<span class="codeline" id="line-1125"><code>// Route Constraints</code></span>
<span class="codeline" id="line-1126"><code>const (</code></span>
<span class="codeline" id="line-1127"><code>	ConstraintInt             = "int"</code></span>
<span class="codeline" id="line-1128"><code>	ConstraintBool            = "bool"</code></span>
<span class="codeline" id="line-1129"><code>	ConstraintFloat           = "float"</code></span>
<span class="codeline" id="line-1130"><code>	ConstraintAlpha           = "alpha"</code></span>
<span class="codeline" id="line-1131"><code>	ConstraintGuid            = "guid" //nolint:revive,stylecheck // TODO: Rename to "ConstraintGUID" in v3</code></span>
<span class="codeline" id="line-1132"><code>	ConstraintMinLen          = "minLen"</code></span>
<span class="codeline" id="line-1133"><code>	ConstraintMaxLen          = "maxLen"</code></span>
<span class="codeline" id="line-1134"><code>	ConstraintLen             = "len"</code></span>
<span class="codeline" id="line-1135"><code>	ConstraintBetweenLen      = "betweenLen"</code></span>
<span class="codeline" id="line-1136"><code>	ConstraintMinLenLower     = "minlen"</code></span>
<span class="codeline" id="line-1137"><code>	ConstraintMaxLenLower     = "maxlen"</code></span>
<span class="codeline" id="line-1138"><code>	ConstraintBetweenLenLower = "betweenlen"</code></span>
<span class="codeline" id="line-1139"><code>	ConstraintMin             = "min"</code></span>
<span class="codeline" id="line-1140"><code>	ConstraintMax             = "max"</code></span>
<span class="codeline" id="line-1141"><code>	ConstraintRange           = "range"</code></span>
<span class="codeline" id="line-1142"><code>	ConstraintDatetime        = "datetime"</code></span>
<span class="codeline" id="line-1143"><code>	ConstraintRegex           = "regex"</code></span>
<span class="codeline" id="line-1144"><code>)</code></span>
<span class="codeline" id="line-1145"><code></code></span>
<span class="codeline" id="line-1146"><code>func IndexRune(str string, needle int32) bool {</code></span>
<span class="codeline" id="line-1147"><code>	for _, b := range str {</code></span>
<span class="codeline" id="line-1148"><code>		if b == needle {</code></span>
<span class="codeline" id="line-1149"><code>			return true</code></span>
<span class="codeline" id="line-1150"><code>		}</code></span>
<span class="codeline" id="line-1151"><code>	}</code></span>
<span class="codeline" id="line-1152"><code>	return false</code></span>
<span class="codeline" id="line-1153"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>