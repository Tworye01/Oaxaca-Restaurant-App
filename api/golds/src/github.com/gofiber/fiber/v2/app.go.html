<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: app.go in package github.com/gofiber/fiber/v2</title>
<link href="../../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	app.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/github.com/gofiber/fiber/v2.html">github.com/gofiber/fiber/v2</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// ‚ö°Ô∏è Fiber is an Express inspired web framework written in Go with ‚òïÔ∏è</code></span>
<span class="codeline" id="line-2"><code>// ü§ñ Github Repository: https://github.com/gofiber/fiber</code></span>
<span class="codeline" id="line-3"><code>// üìå API Documentation: https://docs.gofiber.io</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package fiber is an Express inspired web framework built on top of Fasthttp,</code></span>
<span class="codeline" id="line-6"><code>// the fastest HTTP engine for Go. Designed to ease things up for fast</code></span>
<span class="codeline" id="line-7"><code>// development with zero memory allocation and performance in mind.</code></span></div><span class="codeline" id="line-8"><code>package fiber</code></span>
<span class="codeline" id="line-9"><code></code></span>
<span class="codeline" id="line-10"><code>import (</code></span>
<span class="codeline" id="line-11"><code>	"bufio"</code></span>
<span class="codeline" id="line-12"><code>	"context"</code></span>
<span class="codeline" id="line-13"><code>	"encoding/json"</code></span>
<span class="codeline" id="line-14"><code>	"encoding/xml"</code></span>
<span class="codeline" id="line-15"><code>	"errors"</code></span>
<span class="codeline" id="line-16"><code>	"fmt"</code></span>
<span class="codeline" id="line-17"><code>	"net"</code></span>
<span class="codeline" id="line-18"><code>	"net/http"</code></span>
<span class="codeline" id="line-19"><code>	"net/http/httputil"</code></span>
<span class="codeline" id="line-20"><code>	"reflect"</code></span>
<span class="codeline" id="line-21"><code>	"strconv"</code></span>
<span class="codeline" id="line-22"><code>	"strings"</code></span>
<span class="codeline" id="line-23"><code>	"sync"</code></span>
<span class="codeline" id="line-24"><code>	"time"</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>	"github.com/gofiber/fiber/v2/log"</code></span>
<span class="codeline" id="line-27"><code>	"github.com/gofiber/fiber/v2/utils"</code></span>
<span class="codeline" id="line-28"><code></code></span>
<span class="codeline" id="line-29"><code>	"github.com/valyala/fasthttp"</code></span>
<span class="codeline" id="line-30"><code>)</code></span>
<span class="codeline" id="line-31"><code></code></span>
<span class="codeline" id="line-32"><code>// Version of current fiber package</code></span>
<span class="codeline" id="line-33"><code>const Version = "2.52.1"</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>// Handler defines a function to serve HTTP requests.</code></span>
<span class="codeline" id="line-36"><code>type Handler = func(*Ctx) error</code></span>
<span class="codeline" id="line-37"><code></code></span>
<span class="codeline" id="line-38"><code>// Map is a shortcut for map[string]interface{}, useful for JSON returns</code></span>
<span class="codeline" id="line-39"><code>type Map map[string]interface{}</code></span>
<span class="codeline" id="line-40"><code></code></span>
<span class="codeline" id="line-41"><code>// Storage interface for communicating with different database/key-value</code></span>
<span class="codeline" id="line-42"><code>// providers</code></span>
<span class="codeline" id="line-43"><code>type Storage interface {</code></span>
<span class="codeline" id="line-44"><code>	// Get gets the value for the given key.</code></span>
<span class="codeline" id="line-45"><code>	// `nil, nil` is returned when the key does not exist</code></span>
<span class="codeline" id="line-46"><code>	Get(key string) ([]byte, error)</code></span>
<span class="codeline" id="line-47"><code></code></span>
<span class="codeline" id="line-48"><code>	// Set stores the given value for the given key along</code></span>
<span class="codeline" id="line-49"><code>	// with an expiration value, 0 means no expiration.</code></span>
<span class="codeline" id="line-50"><code>	// Empty key or value will be ignored without an error.</code></span>
<span class="codeline" id="line-51"><code>	Set(key string, val []byte, exp time.Duration) error</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>	// Delete deletes the value for the given key.</code></span>
<span class="codeline" id="line-54"><code>	// It returns no error if the storage does not contain the key,</code></span>
<span class="codeline" id="line-55"><code>	Delete(key string) error</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>	// Reset resets the storage and delete all keys.</code></span>
<span class="codeline" id="line-58"><code>	Reset() error</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>	// Close closes the storage and will stop any running garbage</code></span>
<span class="codeline" id="line-61"><code>	// collectors and open connections.</code></span>
<span class="codeline" id="line-62"><code>	Close() error</code></span>
<span class="codeline" id="line-63"><code>}</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>// ErrorHandler defines a function that will process all errors</code></span>
<span class="codeline" id="line-66"><code>// returned from any handlers in the stack</code></span>
<span class="codeline" id="line-67"><code>//</code></span>
<span class="codeline" id="line-68"><code>//	cfg := fiber.Config{}</code></span>
<span class="codeline" id="line-69"><code>//	cfg.ErrorHandler = func(c *Ctx, err error) error {</code></span>
<span class="codeline" id="line-70"><code>//	 code := StatusInternalServerError</code></span>
<span class="codeline" id="line-71"><code>//	 var e *fiber.Error</code></span>
<span class="codeline" id="line-72"><code>//	 if errors.As(err, &amp;e) {</code></span>
<span class="codeline" id="line-73"><code>//	   code = e.Code</code></span>
<span class="codeline" id="line-74"><code>//	 }</code></span>
<span class="codeline" id="line-75"><code>//	 c.Set(HeaderContentType, MIMETextPlainCharsetUTF8)</code></span>
<span class="codeline" id="line-76"><code>//	 return c.Status(code).SendString(err.Error())</code></span>
<span class="codeline" id="line-77"><code>//	}</code></span>
<span class="codeline" id="line-78"><code>//	app := fiber.New(cfg)</code></span>
<span class="codeline" id="line-79"><code>type ErrorHandler = func(*Ctx, error) error</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>// Error represents an error that occurred while handling a request.</code></span>
<span class="codeline" id="line-82"><code>type Error struct {</code></span>
<span class="codeline" id="line-83"><code>	Code    int    `json:"code"`</code></span>
<span class="codeline" id="line-84"><code>	Message string `json:"message"`</code></span>
<span class="codeline" id="line-85"><code>}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>// App denotes the Fiber application.</code></span>
<span class="codeline" id="line-88"><code>type App struct {</code></span>
<span class="codeline" id="line-89"><code>	mutex sync.Mutex</code></span>
<span class="codeline" id="line-90"><code>	// Route stack divided by HTTP methods</code></span>
<span class="codeline" id="line-91"><code>	stack [][]*Route</code></span>
<span class="codeline" id="line-92"><code>	// Route stack divided by HTTP methods and route prefixes</code></span>
<span class="codeline" id="line-93"><code>	treeStack []map[string][]*Route</code></span>
<span class="codeline" id="line-94"><code>	// contains the information if the route stack has been changed to build the optimized tree</code></span>
<span class="codeline" id="line-95"><code>	routesRefreshed bool</code></span>
<span class="codeline" id="line-96"><code>	// Amount of registered routes</code></span>
<span class="codeline" id="line-97"><code>	routesCount uint32</code></span>
<span class="codeline" id="line-98"><code>	// Amount of registered handlers</code></span>
<span class="codeline" id="line-99"><code>	handlersCount uint32</code></span>
<span class="codeline" id="line-100"><code>	// Ctx pool</code></span>
<span class="codeline" id="line-101"><code>	pool sync.Pool</code></span>
<span class="codeline" id="line-102"><code>	// Fasthttp server</code></span>
<span class="codeline" id="line-103"><code>	server *fasthttp.Server</code></span>
<span class="codeline" id="line-104"><code>	// App config</code></span>
<span class="codeline" id="line-105"><code>	config Config</code></span>
<span class="codeline" id="line-106"><code>	// Converts string to a byte slice</code></span>
<span class="codeline" id="line-107"><code>	getBytes func(s string) (b []byte)</code></span>
<span class="codeline" id="line-108"><code>	// Converts byte slice to a string</code></span>
<span class="codeline" id="line-109"><code>	getString func(b []byte) string</code></span>
<span class="codeline" id="line-110"><code>	// Hooks</code></span>
<span class="codeline" id="line-111"><code>	hooks *Hooks</code></span>
<span class="codeline" id="line-112"><code>	// Latest route &amp; group</code></span>
<span class="codeline" id="line-113"><code>	latestRoute *Route</code></span>
<span class="codeline" id="line-114"><code>	// TLS handler</code></span>
<span class="codeline" id="line-115"><code>	tlsHandler *TLSHandler</code></span>
<span class="codeline" id="line-116"><code>	// Mount fields</code></span>
<span class="codeline" id="line-117"><code>	mountFields *mountFields</code></span>
<span class="codeline" id="line-118"><code>	// Indicates if the value was explicitly configured</code></span>
<span class="codeline" id="line-119"><code>	configured Config</code></span>
<span class="codeline" id="line-120"><code>}</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>// Config is a struct holding the server settings.</code></span>
<span class="codeline" id="line-123"><code>type Config struct {</code></span>
<span class="codeline" id="line-124"><code>	// When set to true, this will spawn multiple Go processes listening on the same port.</code></span>
<span class="codeline" id="line-125"><code>	//</code></span>
<span class="codeline" id="line-126"><code>	// Default: false</code></span>
<span class="codeline" id="line-127"><code>	Prefork bool `json:"prefork"`</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>	// Enables the "Server: value" HTTP header.</code></span>
<span class="codeline" id="line-130"><code>	//</code></span>
<span class="codeline" id="line-131"><code>	// Default: ""</code></span>
<span class="codeline" id="line-132"><code>	ServerHeader string `json:"server_header"`</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>	// When set to true, the router treats "/foo" and "/foo/" as different.</code></span>
<span class="codeline" id="line-135"><code>	// By default this is disabled and both "/foo" and "/foo/" will execute the same handler.</code></span>
<span class="codeline" id="line-136"><code>	//</code></span>
<span class="codeline" id="line-137"><code>	// Default: false</code></span>
<span class="codeline" id="line-138"><code>	StrictRouting bool `json:"strict_routing"`</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	// When set to true, enables case sensitive routing.</code></span>
<span class="codeline" id="line-141"><code>	// E.g. "/FoO" and "/foo" are treated as different routes.</code></span>
<span class="codeline" id="line-142"><code>	// By default this is disabled and both "/FoO" and "/foo" will execute the same handler.</code></span>
<span class="codeline" id="line-143"><code>	//</code></span>
<span class="codeline" id="line-144"><code>	// Default: false</code></span>
<span class="codeline" id="line-145"><code>	CaseSensitive bool `json:"case_sensitive"`</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>	// When set to true, this relinquishes the 0-allocation promise in certain</code></span>
<span class="codeline" id="line-148"><code>	// cases in order to access the handler values (e.g. request bodies) in an</code></span>
<span class="codeline" id="line-149"><code>	// immutable fashion so that these values are available even if you return</code></span>
<span class="codeline" id="line-150"><code>	// from handler.</code></span>
<span class="codeline" id="line-151"><code>	//</code></span>
<span class="codeline" id="line-152"><code>	// Default: false</code></span>
<span class="codeline" id="line-153"><code>	Immutable bool `json:"immutable"`</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// When set to true, converts all encoded characters in the route back</code></span>
<span class="codeline" id="line-156"><code>	// before setting the path for the context, so that the routing,</code></span>
<span class="codeline" id="line-157"><code>	// the returning of the current url from the context `ctx.Path()`</code></span>
<span class="codeline" id="line-158"><code>	// and the parameters `ctx.Params(%key%)` with decoded characters will work</code></span>
<span class="codeline" id="line-159"><code>	//</code></span>
<span class="codeline" id="line-160"><code>	// Default: false</code></span>
<span class="codeline" id="line-161"><code>	UnescapePath bool `json:"unescape_path"`</code></span>
<span class="codeline" id="line-162"><code></code></span>
<span class="codeline" id="line-163"><code>	// Enable or disable ETag header generation, since both weak and strong etags are generated</code></span>
<span class="codeline" id="line-164"><code>	// using the same hashing method (CRC-32). Weak ETags are the default when enabled.</code></span>
<span class="codeline" id="line-165"><code>	//</code></span>
<span class="codeline" id="line-166"><code>	// Default: false</code></span>
<span class="codeline" id="line-167"><code>	ETag bool `json:"etag"`</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>	// Max body size that the server accepts.</code></span>
<span class="codeline" id="line-170"><code>	// -1 will decline any body size</code></span>
<span class="codeline" id="line-171"><code>	//</code></span>
<span class="codeline" id="line-172"><code>	// Default: 4 * 1024 * 1024</code></span>
<span class="codeline" id="line-173"><code>	BodyLimit int `json:"body_limit"`</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>	// Maximum number of concurrent connections.</code></span>
<span class="codeline" id="line-176"><code>	//</code></span>
<span class="codeline" id="line-177"><code>	// Default: 256 * 1024</code></span>
<span class="codeline" id="line-178"><code>	Concurrency int `json:"concurrency"`</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	// Views is the interface that wraps the Render function.</code></span>
<span class="codeline" id="line-181"><code>	//</code></span>
<span class="codeline" id="line-182"><code>	// Default: nil</code></span>
<span class="codeline" id="line-183"><code>	Views Views `json:"-"`</code></span>
<span class="codeline" id="line-184"><code></code></span>
<span class="codeline" id="line-185"><code>	// Views Layout is the global layout for all template render until override on Render function.</code></span>
<span class="codeline" id="line-186"><code>	//</code></span>
<span class="codeline" id="line-187"><code>	// Default: ""</code></span>
<span class="codeline" id="line-188"><code>	ViewsLayout string `json:"views_layout"`</code></span>
<span class="codeline" id="line-189"><code></code></span>
<span class="codeline" id="line-190"><code>	// PassLocalsToViews Enables passing of the locals set on a fiber.Ctx to the template engine</code></span>
<span class="codeline" id="line-191"><code>	//</code></span>
<span class="codeline" id="line-192"><code>	// Default: false</code></span>
<span class="codeline" id="line-193"><code>	PassLocalsToViews bool `json:"pass_locals_to_views"`</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>	// The amount of time allowed to read the full request including body.</code></span>
<span class="codeline" id="line-196"><code>	// It is reset after the request handler has returned.</code></span>
<span class="codeline" id="line-197"><code>	// The connection's read deadline is reset when the connection opens.</code></span>
<span class="codeline" id="line-198"><code>	//</code></span>
<span class="codeline" id="line-199"><code>	// Default: unlimited</code></span>
<span class="codeline" id="line-200"><code>	ReadTimeout time.Duration `json:"read_timeout"`</code></span>
<span class="codeline" id="line-201"><code></code></span>
<span class="codeline" id="line-202"><code>	// The maximum duration before timing out writes of the response.</code></span>
<span class="codeline" id="line-203"><code>	// It is reset after the request handler has returned.</code></span>
<span class="codeline" id="line-204"><code>	//</code></span>
<span class="codeline" id="line-205"><code>	// Default: unlimited</code></span>
<span class="codeline" id="line-206"><code>	WriteTimeout time.Duration `json:"write_timeout"`</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	// The maximum amount of time to wait for the next request when keep-alive is enabled.</code></span>
<span class="codeline" id="line-209"><code>	// If IdleTimeout is zero, the value of ReadTimeout is used.</code></span>
<span class="codeline" id="line-210"><code>	//</code></span>
<span class="codeline" id="line-211"><code>	// Default: unlimited</code></span>
<span class="codeline" id="line-212"><code>	IdleTimeout time.Duration `json:"idle_timeout"`</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>	// Per-connection buffer size for requests' reading.</code></span>
<span class="codeline" id="line-215"><code>	// This also limits the maximum header size.</code></span>
<span class="codeline" id="line-216"><code>	// Increase this buffer if your clients send multi-KB RequestURIs</code></span>
<span class="codeline" id="line-217"><code>	// and/or multi-KB headers (for example, BIG cookies).</code></span>
<span class="codeline" id="line-218"><code>	//</code></span>
<span class="codeline" id="line-219"><code>	// Default: 4096</code></span>
<span class="codeline" id="line-220"><code>	ReadBufferSize int `json:"read_buffer_size"`</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>	// Per-connection buffer size for responses' writing.</code></span>
<span class="codeline" id="line-223"><code>	//</code></span>
<span class="codeline" id="line-224"><code>	// Default: 4096</code></span>
<span class="codeline" id="line-225"><code>	WriteBufferSize int `json:"write_buffer_size"`</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>	// CompressedFileSuffix adds suffix to the original file name and</code></span>
<span class="codeline" id="line-228"><code>	// tries saving the resulting compressed file under the new file name.</code></span>
<span class="codeline" id="line-229"><code>	//</code></span>
<span class="codeline" id="line-230"><code>	// Default: ".fiber.gz"</code></span>
<span class="codeline" id="line-231"><code>	CompressedFileSuffix string `json:"compressed_file_suffix"`</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>	// ProxyHeader will enable c.IP() to return the value of the given header key</code></span>
<span class="codeline" id="line-234"><code>	// By default c.IP() will return the Remote IP from the TCP connection</code></span>
<span class="codeline" id="line-235"><code>	// This property can be useful if you are behind a load balancer: X-Forwarded-*</code></span>
<span class="codeline" id="line-236"><code>	// NOTE: headers are easily spoofed and the detected IP addresses are unreliable.</code></span>
<span class="codeline" id="line-237"><code>	//</code></span>
<span class="codeline" id="line-238"><code>	// Default: ""</code></span>
<span class="codeline" id="line-239"><code>	ProxyHeader string `json:"proxy_header"`</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	// GETOnly rejects all non-GET requests if set to true.</code></span>
<span class="codeline" id="line-242"><code>	// This option is useful as anti-DoS protection for servers</code></span>
<span class="codeline" id="line-243"><code>	// accepting only GET requests. The request size is limited</code></span>
<span class="codeline" id="line-244"><code>	// by ReadBufferSize if GETOnly is set.</code></span>
<span class="codeline" id="line-245"><code>	//</code></span>
<span class="codeline" id="line-246"><code>	// Default: false</code></span>
<span class="codeline" id="line-247"><code>	GETOnly bool `json:"get_only"`</code></span>
<span class="codeline" id="line-248"><code></code></span>
<span class="codeline" id="line-249"><code>	// ErrorHandler is executed when an error is returned from fiber.Handler.</code></span>
<span class="codeline" id="line-250"><code>	//</code></span>
<span class="codeline" id="line-251"><code>	// Default: DefaultErrorHandler</code></span>
<span class="codeline" id="line-252"><code>	ErrorHandler ErrorHandler `json:"-"`</code></span>
<span class="codeline" id="line-253"><code></code></span>
<span class="codeline" id="line-254"><code>	// When set to true, disables keep-alive connections.</code></span>
<span class="codeline" id="line-255"><code>	// The server will close incoming connections after sending the first response to client.</code></span>
<span class="codeline" id="line-256"><code>	//</code></span>
<span class="codeline" id="line-257"><code>	// Default: false</code></span>
<span class="codeline" id="line-258"><code>	DisableKeepalive bool `json:"disable_keepalive"`</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>	// When set to true, causes the default date header to be excluded from the response.</code></span>
<span class="codeline" id="line-261"><code>	//</code></span>
<span class="codeline" id="line-262"><code>	// Default: false</code></span>
<span class="codeline" id="line-263"><code>	DisableDefaultDate bool `json:"disable_default_date"`</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>	// When set to true, causes the default Content-Type header to be excluded from the response.</code></span>
<span class="codeline" id="line-266"><code>	//</code></span>
<span class="codeline" id="line-267"><code>	// Default: false</code></span>
<span class="codeline" id="line-268"><code>	DisableDefaultContentType bool `json:"disable_default_content_type"`</code></span>
<span class="codeline" id="line-269"><code></code></span>
<span class="codeline" id="line-270"><code>	// When set to true, disables header normalization.</code></span>
<span class="codeline" id="line-271"><code>	// By default all header names are normalized: conteNT-tYPE -&gt; Content-Type.</code></span>
<span class="codeline" id="line-272"><code>	//</code></span>
<span class="codeline" id="line-273"><code>	// Default: false</code></span>
<span class="codeline" id="line-274"><code>	DisableHeaderNormalizing bool `json:"disable_header_normalizing"`</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	// When set to true, it will not print out the ¬´Fiber¬ª ASCII art and listening address.</code></span>
<span class="codeline" id="line-277"><code>	//</code></span>
<span class="codeline" id="line-278"><code>	// Default: false</code></span>
<span class="codeline" id="line-279"><code>	DisableStartupMessage bool `json:"disable_startup_message"`</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// This function allows to setup app name for the app</code></span>
<span class="codeline" id="line-282"><code>	//</code></span>
<span class="codeline" id="line-283"><code>	// Default: nil</code></span>
<span class="codeline" id="line-284"><code>	AppName string `json:"app_name"`</code></span>
<span class="codeline" id="line-285"><code></code></span>
<span class="codeline" id="line-286"><code>	// StreamRequestBody enables request body streaming,</code></span>
<span class="codeline" id="line-287"><code>	// and calls the handler sooner when given body is</code></span>
<span class="codeline" id="line-288"><code>	// larger then the current limit.</code></span>
<span class="codeline" id="line-289"><code>	StreamRequestBody bool</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	// Will not pre parse Multipart Form data if set to true.</code></span>
<span class="codeline" id="line-292"><code>	//</code></span>
<span class="codeline" id="line-293"><code>	// This option is useful for servers that desire to treat</code></span>
<span class="codeline" id="line-294"><code>	// multipart form data as a binary blob, or choose when to parse the data.</code></span>
<span class="codeline" id="line-295"><code>	//</code></span>
<span class="codeline" id="line-296"><code>	// Server pre parses multipart form data by default.</code></span>
<span class="codeline" id="line-297"><code>	DisablePreParseMultipartForm bool</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>	// Aggressively reduces memory usage at the cost of higher CPU usage</code></span>
<span class="codeline" id="line-300"><code>	// if set to true.</code></span>
<span class="codeline" id="line-301"><code>	//</code></span>
<span class="codeline" id="line-302"><code>	// Try enabling this option only if the server consumes too much memory</code></span>
<span class="codeline" id="line-303"><code>	// serving mostly idle keep-alive connections. This may reduce memory</code></span>
<span class="codeline" id="line-304"><code>	// usage by more than 50%.</code></span>
<span class="codeline" id="line-305"><code>	//</code></span>
<span class="codeline" id="line-306"><code>	// Default: false</code></span>
<span class="codeline" id="line-307"><code>	ReduceMemoryUsage bool `json:"reduce_memory_usage"`</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>	// FEATURE: v2.3.x</code></span>
<span class="codeline" id="line-310"><code>	// The router executes the same handler by default if StrictRouting or CaseSensitive is disabled.</code></span>
<span class="codeline" id="line-311"><code>	// Enabling RedirectFixedPath will change this behavior into a client redirect to the original route path.</code></span>
<span class="codeline" id="line-312"><code>	// Using the status code 301 for GET requests and 308 for all other request methods.</code></span>
<span class="codeline" id="line-313"><code>	//</code></span>
<span class="codeline" id="line-314"><code>	// Default: false</code></span>
<span class="codeline" id="line-315"><code>	// RedirectFixedPath bool</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>	// When set by an external client of Fiber it will use the provided implementation of a</code></span>
<span class="codeline" id="line-318"><code>	// JSONMarshal</code></span>
<span class="codeline" id="line-319"><code>	//</code></span>
<span class="codeline" id="line-320"><code>	// Allowing for flexibility in using another json library for encoding</code></span>
<span class="codeline" id="line-321"><code>	// Default: json.Marshal</code></span>
<span class="codeline" id="line-322"><code>	JSONEncoder utils.JSONMarshal `json:"-"`</code></span>
<span class="codeline" id="line-323"><code></code></span>
<span class="codeline" id="line-324"><code>	// When set by an external client of Fiber it will use the provided implementation of a</code></span>
<span class="codeline" id="line-325"><code>	// JSONUnmarshal</code></span>
<span class="codeline" id="line-326"><code>	//</code></span>
<span class="codeline" id="line-327"><code>	// Allowing for flexibility in using another json library for decoding</code></span>
<span class="codeline" id="line-328"><code>	// Default: json.Unmarshal</code></span>
<span class="codeline" id="line-329"><code>	JSONDecoder utils.JSONUnmarshal `json:"-"`</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>	// XMLEncoder set by an external client of Fiber it will use the provided implementation of a</code></span>
<span class="codeline" id="line-332"><code>	// XMLMarshal</code></span>
<span class="codeline" id="line-333"><code>	//</code></span>
<span class="codeline" id="line-334"><code>	// Allowing for flexibility in using another XML library for encoding</code></span>
<span class="codeline" id="line-335"><code>	// Default: xml.Marshal</code></span>
<span class="codeline" id="line-336"><code>	XMLEncoder utils.XMLMarshal `json:"-"`</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>	// Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only)</code></span>
<span class="codeline" id="line-339"><code>	// WARNING: When prefork is set to true, only "tcp4" and "tcp6" can be chose.</code></span>
<span class="codeline" id="line-340"><code>	//</code></span>
<span class="codeline" id="line-341"><code>	// Default: NetworkTCP4</code></span>
<span class="codeline" id="line-342"><code>	Network string</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>	// If you find yourself behind some sort of proxy, like a load balancer,</code></span>
<span class="codeline" id="line-345"><code>	// then certain header information may be sent to you using special X-Forwarded-* headers or the Forwarded header.</code></span>
<span class="codeline" id="line-346"><code>	// For example, the Host HTTP header is usually used to return the requested host.</code></span>
<span class="codeline" id="line-347"><code>	// But when you‚Äôre behind a proxy, the actual host may be stored in an X-Forwarded-Host header.</code></span>
<span class="codeline" id="line-348"><code>	//</code></span>
<span class="codeline" id="line-349"><code>	// If you are behind a proxy, you should enable TrustedProxyCheck to prevent header spoofing.</code></span>
<span class="codeline" id="line-350"><code>	// If you enable EnableTrustedProxyCheck and leave TrustedProxies empty Fiber will skip</code></span>
<span class="codeline" id="line-351"><code>	// all headers that could be spoofed.</code></span>
<span class="codeline" id="line-352"><code>	// If request ip in TrustedProxies whitelist then:</code></span>
<span class="codeline" id="line-353"><code>	//   1. c.Protocol() get value from X-Forwarded-Proto, X-Forwarded-Protocol, X-Forwarded-Ssl or X-Url-Scheme header</code></span>
<span class="codeline" id="line-354"><code>	//   2. c.IP() get value from ProxyHeader header.</code></span>
<span class="codeline" id="line-355"><code>	//   3. c.Hostname() get value from X-Forwarded-Host header</code></span>
<span class="codeline" id="line-356"><code>	// But if request ip NOT in Trusted Proxies whitelist then:</code></span>
<span class="codeline" id="line-357"><code>	//   1. c.Protocol() WON't get value from X-Forwarded-Proto, X-Forwarded-Protocol, X-Forwarded-Ssl or X-Url-Scheme header,</code></span>
<span class="codeline" id="line-358"><code>	//    will return https in case when tls connection is handled by the app, of http otherwise</code></span>
<span class="codeline" id="line-359"><code>	//   2. c.IP() WON'T get value from ProxyHeader header, will return RemoteIP() from fasthttp context</code></span>
<span class="codeline" id="line-360"><code>	//   3. c.Hostname() WON'T get value from X-Forwarded-Host header, fasthttp.Request.URI().Host()</code></span>
<span class="codeline" id="line-361"><code>	//    will be used to get the hostname.</code></span>
<span class="codeline" id="line-362"><code>	//</code></span>
<span class="codeline" id="line-363"><code>	// Default: false</code></span>
<span class="codeline" id="line-364"><code>	EnableTrustedProxyCheck bool `json:"enable_trusted_proxy_check"`</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>	// Read EnableTrustedProxyCheck doc.</code></span>
<span class="codeline" id="line-367"><code>	//</code></span>
<span class="codeline" id="line-368"><code>	// Default: []string</code></span>
<span class="codeline" id="line-369"><code>	TrustedProxies     []string `json:"trusted_proxies"`</code></span>
<span class="codeline" id="line-370"><code>	trustedProxiesMap  map[string]struct{}</code></span>
<span class="codeline" id="line-371"><code>	trustedProxyRanges []*net.IPNet</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>	// If set to true, c.IP() and c.IPs() will validate IP addresses before returning them.</code></span>
<span class="codeline" id="line-374"><code>	// Also, c.IP() will return only the first valid IP rather than just the raw header</code></span>
<span class="codeline" id="line-375"><code>	// WARNING: this has a performance cost associated with it.</code></span>
<span class="codeline" id="line-376"><code>	//</code></span>
<span class="codeline" id="line-377"><code>	// Default: false</code></span>
<span class="codeline" id="line-378"><code>	EnableIPValidation bool `json:"enable_ip_validation"`</code></span>
<span class="codeline" id="line-379"><code></code></span>
<span class="codeline" id="line-380"><code>	// If set to true, will print all routes with their method, path and handler.</code></span>
<span class="codeline" id="line-381"><code>	// Default: false</code></span>
<span class="codeline" id="line-382"><code>	EnablePrintRoutes bool `json:"enable_print_routes"`</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>	// You can define custom color scheme. They'll be used for startup message, route list and some middlewares.</code></span>
<span class="codeline" id="line-385"><code>	//</code></span>
<span class="codeline" id="line-386"><code>	// Optional. Default: DefaultColors</code></span>
<span class="codeline" id="line-387"><code>	ColorScheme Colors `json:"color_scheme"`</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>	// RequestMethods provides customizibility for HTTP methods. You can add/remove methods as you wish.</code></span>
<span class="codeline" id="line-390"><code>	//</code></span>
<span class="codeline" id="line-391"><code>	// Optional. Default: DefaultMethods</code></span>
<span class="codeline" id="line-392"><code>	RequestMethods []string</code></span>
<span class="codeline" id="line-393"><code></code></span>
<span class="codeline" id="line-394"><code>	// EnableSplittingOnParsers splits the query/body/header parameters by comma when it's true.</code></span>
<span class="codeline" id="line-395"><code>	// For example, you can use it to parse multiple values from a query parameter like this:</code></span>
<span class="codeline" id="line-396"><code>	//   /api?foo=bar,baz == foo[]=bar&amp;foo[]=baz</code></span>
<span class="codeline" id="line-397"><code>	//</code></span>
<span class="codeline" id="line-398"><code>	// Optional. Default: false</code></span>
<span class="codeline" id="line-399"><code>	EnableSplittingOnParsers bool `json:"enable_splitting_on_parsers"`</code></span>
<span class="codeline" id="line-400"><code>}</code></span>
<span class="codeline" id="line-401"><code></code></span>
<span class="codeline" id="line-402"><code>// Static defines configuration options when defining static assets.</code></span>
<span class="codeline" id="line-403"><code>type Static struct {</code></span>
<span class="codeline" id="line-404"><code>	// When set to true, the server tries minimizing CPU usage by caching compressed files.</code></span>
<span class="codeline" id="line-405"><code>	// This works differently than the github.com/gofiber/compression middleware.</code></span>
<span class="codeline" id="line-406"><code>	// Optional. Default value false</code></span>
<span class="codeline" id="line-407"><code>	Compress bool `json:"compress"`</code></span>
<span class="codeline" id="line-408"><code></code></span>
<span class="codeline" id="line-409"><code>	// When set to true, enables byte range requests.</code></span>
<span class="codeline" id="line-410"><code>	// Optional. Default value false</code></span>
<span class="codeline" id="line-411"><code>	ByteRange bool `json:"byte_range"`</code></span>
<span class="codeline" id="line-412"><code></code></span>
<span class="codeline" id="line-413"><code>	// When set to true, enables directory browsing.</code></span>
<span class="codeline" id="line-414"><code>	// Optional. Default value false.</code></span>
<span class="codeline" id="line-415"><code>	Browse bool `json:"browse"`</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>	// When set to true, enables direct download.</code></span>
<span class="codeline" id="line-418"><code>	// Optional. Default value false.</code></span>
<span class="codeline" id="line-419"><code>	Download bool `json:"download"`</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>	// The name of the index file for serving a directory.</code></span>
<span class="codeline" id="line-422"><code>	// Optional. Default value "index.html".</code></span>
<span class="codeline" id="line-423"><code>	Index string `json:"index"`</code></span>
<span class="codeline" id="line-424"><code></code></span>
<span class="codeline" id="line-425"><code>	// Expiration duration for inactive file handlers.</code></span>
<span class="codeline" id="line-426"><code>	// Use a negative time.Duration to disable it.</code></span>
<span class="codeline" id="line-427"><code>	//</code></span>
<span class="codeline" id="line-428"><code>	// Optional. Default value 10 * time.Second.</code></span>
<span class="codeline" id="line-429"><code>	CacheDuration time.Duration `json:"cache_duration"`</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>	// The value for the Cache-Control HTTP-header</code></span>
<span class="codeline" id="line-432"><code>	// that is set on the file response. MaxAge is defined in seconds.</code></span>
<span class="codeline" id="line-433"><code>	//</code></span>
<span class="codeline" id="line-434"><code>	// Optional. Default value 0.</code></span>
<span class="codeline" id="line-435"><code>	MaxAge int `json:"max_age"`</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	// ModifyResponse defines a function that allows you to alter the response.</code></span>
<span class="codeline" id="line-438"><code>	//</code></span>
<span class="codeline" id="line-439"><code>	// Optional. Default: nil</code></span>
<span class="codeline" id="line-440"><code>	ModifyResponse Handler</code></span>
<span class="codeline" id="line-441"><code></code></span>
<span class="codeline" id="line-442"><code>	// Next defines a function to skip this middleware when returned true.</code></span>
<span class="codeline" id="line-443"><code>	//</code></span>
<span class="codeline" id="line-444"><code>	// Optional. Default: nil</code></span>
<span class="codeline" id="line-445"><code>	Next func(c *Ctx) bool</code></span>
<span class="codeline" id="line-446"><code>}</code></span>
<span class="codeline" id="line-447"><code></code></span>
<span class="codeline" id="line-448"><code>// RouteMessage is some message need to be print when server starts</code></span>
<span class="codeline" id="line-449"><code>type RouteMessage struct {</code></span>
<span class="codeline" id="line-450"><code>	name     string</code></span>
<span class="codeline" id="line-451"><code>	method   string</code></span>
<span class="codeline" id="line-452"><code>	path     string</code></span>
<span class="codeline" id="line-453"><code>	handlers string</code></span>
<span class="codeline" id="line-454"><code>}</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>// Default Config values</code></span>
<span class="codeline" id="line-457"><code>const (</code></span>
<span class="codeline" id="line-458"><code>	DefaultBodyLimit            = 4 * 1024 * 1024</code></span>
<span class="codeline" id="line-459"><code>	DefaultConcurrency          = 256 * 1024</code></span>
<span class="codeline" id="line-460"><code>	DefaultReadBufferSize       = 4096</code></span>
<span class="codeline" id="line-461"><code>	DefaultWriteBufferSize      = 4096</code></span>
<span class="codeline" id="line-462"><code>	DefaultCompressedFileSuffix = ".fiber.gz"</code></span>
<span class="codeline" id="line-463"><code>)</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>// HTTP methods enabled by default</code></span>
<span class="codeline" id="line-466"><code>var DefaultMethods = []string{</code></span>
<span class="codeline" id="line-467"><code>	MethodGet,</code></span>
<span class="codeline" id="line-468"><code>	MethodHead,</code></span>
<span class="codeline" id="line-469"><code>	MethodPost,</code></span>
<span class="codeline" id="line-470"><code>	MethodPut,</code></span>
<span class="codeline" id="line-471"><code>	MethodDelete,</code></span>
<span class="codeline" id="line-472"><code>	MethodConnect,</code></span>
<span class="codeline" id="line-473"><code>	MethodOptions,</code></span>
<span class="codeline" id="line-474"><code>	MethodTrace,</code></span>
<span class="codeline" id="line-475"><code>	MethodPatch,</code></span>
<span class="codeline" id="line-476"><code>}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>// DefaultErrorHandler that process return errors from handlers</code></span>
<span class="codeline" id="line-479"><code>func DefaultErrorHandler(c *Ctx, err error) error {</code></span>
<span class="codeline" id="line-480"><code>	code := StatusInternalServerError</code></span>
<span class="codeline" id="line-481"><code>	var e *Error</code></span>
<span class="codeline" id="line-482"><code>	if errors.As(err, &amp;e) {</code></span>
<span class="codeline" id="line-483"><code>		code = e.Code</code></span>
<span class="codeline" id="line-484"><code>	}</code></span>
<span class="codeline" id="line-485"><code>	c.Set(HeaderContentType, MIMETextPlainCharsetUTF8)</code></span>
<span class="codeline" id="line-486"><code>	return c.Status(code).SendString(err.Error())</code></span>
<span class="codeline" id="line-487"><code>}</code></span>
<span class="codeline" id="line-488"><code></code></span>
<span class="codeline" id="line-489"><code>// New creates a new Fiber named instance.</code></span>
<span class="codeline" id="line-490"><code>//</code></span>
<span class="codeline" id="line-491"><code>//	app := fiber.New()</code></span>
<span class="codeline" id="line-492"><code>//</code></span>
<span class="codeline" id="line-493"><code>// You can pass optional configuration options by passing a Config struct:</code></span>
<span class="codeline" id="line-494"><code>//</code></span>
<span class="codeline" id="line-495"><code>//	app := fiber.New(fiber.Config{</code></span>
<span class="codeline" id="line-496"><code>//	    Prefork: true,</code></span>
<span class="codeline" id="line-497"><code>//	    ServerHeader: "Fiber",</code></span>
<span class="codeline" id="line-498"><code>//	})</code></span>
<span class="codeline" id="line-499"><code>func New(config ...Config) *App {</code></span>
<span class="codeline" id="line-500"><code>	// Create a new app</code></span>
<span class="codeline" id="line-501"><code>	app := &amp;App{</code></span>
<span class="codeline" id="line-502"><code>		// Create Ctx pool</code></span>
<span class="codeline" id="line-503"><code>		pool: sync.Pool{</code></span>
<span class="codeline" id="line-504"><code>			New: func() interface{} {</code></span>
<span class="codeline" id="line-505"><code>				return new(Ctx)</code></span>
<span class="codeline" id="line-506"><code>			},</code></span>
<span class="codeline" id="line-507"><code>		},</code></span>
<span class="codeline" id="line-508"><code>		// Create config</code></span>
<span class="codeline" id="line-509"><code>		config:      Config{},</code></span>
<span class="codeline" id="line-510"><code>		getBytes:    utils.UnsafeBytes,</code></span>
<span class="codeline" id="line-511"><code>		getString:   utils.UnsafeString,</code></span>
<span class="codeline" id="line-512"><code>		latestRoute: &amp;Route{},</code></span>
<span class="codeline" id="line-513"><code>	}</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>	// Define hooks</code></span>
<span class="codeline" id="line-516"><code>	app.hooks = newHooks(app)</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>	// Define mountFields</code></span>
<span class="codeline" id="line-519"><code>	app.mountFields = newMountFields(app)</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>	// Override config if provided</code></span>
<span class="codeline" id="line-522"><code>	if len(config) &gt; 0 {</code></span>
<span class="codeline" id="line-523"><code>		app.config = config[0]</code></span>
<span class="codeline" id="line-524"><code>	}</code></span>
<span class="codeline" id="line-525"><code></code></span>
<span class="codeline" id="line-526"><code>	// Initialize configured before defaults are set</code></span>
<span class="codeline" id="line-527"><code>	app.configured = app.config</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	if app.config.ETag {</code></span>
<span class="codeline" id="line-530"><code>		if !IsChild() {</code></span>
<span class="codeline" id="line-531"><code>			log.Warn("Config.ETag is deprecated since v2.0.6, please use 'middleware/etag'.")</code></span>
<span class="codeline" id="line-532"><code>		}</code></span>
<span class="codeline" id="line-533"><code>	}</code></span>
<span class="codeline" id="line-534"><code></code></span>
<span class="codeline" id="line-535"><code>	// Override default values</code></span>
<span class="codeline" id="line-536"><code>	if app.config.BodyLimit == 0 {</code></span>
<span class="codeline" id="line-537"><code>		app.config.BodyLimit = DefaultBodyLimit</code></span>
<span class="codeline" id="line-538"><code>	}</code></span>
<span class="codeline" id="line-539"><code>	if app.config.Concurrency &lt;= 0 {</code></span>
<span class="codeline" id="line-540"><code>		app.config.Concurrency = DefaultConcurrency</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code>	if app.config.ReadBufferSize &lt;= 0 {</code></span>
<span class="codeline" id="line-543"><code>		app.config.ReadBufferSize = DefaultReadBufferSize</code></span>
<span class="codeline" id="line-544"><code>	}</code></span>
<span class="codeline" id="line-545"><code>	if app.config.WriteBufferSize &lt;= 0 {</code></span>
<span class="codeline" id="line-546"><code>		app.config.WriteBufferSize = DefaultWriteBufferSize</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code>	if app.config.CompressedFileSuffix == "" {</code></span>
<span class="codeline" id="line-549"><code>		app.config.CompressedFileSuffix = DefaultCompressedFileSuffix</code></span>
<span class="codeline" id="line-550"><code>	}</code></span>
<span class="codeline" id="line-551"><code>	if app.config.Immutable {</code></span>
<span class="codeline" id="line-552"><code>		app.getBytes, app.getString = getBytesImmutable, getStringImmutable</code></span>
<span class="codeline" id="line-553"><code>	}</code></span>
<span class="codeline" id="line-554"><code></code></span>
<span class="codeline" id="line-555"><code>	if app.config.ErrorHandler == nil {</code></span>
<span class="codeline" id="line-556"><code>		app.config.ErrorHandler = DefaultErrorHandler</code></span>
<span class="codeline" id="line-557"><code>	}</code></span>
<span class="codeline" id="line-558"><code></code></span>
<span class="codeline" id="line-559"><code>	if app.config.JSONEncoder == nil {</code></span>
<span class="codeline" id="line-560"><code>		app.config.JSONEncoder = json.Marshal</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code>	if app.config.JSONDecoder == nil {</code></span>
<span class="codeline" id="line-563"><code>		app.config.JSONDecoder = json.Unmarshal</code></span>
<span class="codeline" id="line-564"><code>	}</code></span>
<span class="codeline" id="line-565"><code>	if app.config.XMLEncoder == nil {</code></span>
<span class="codeline" id="line-566"><code>		app.config.XMLEncoder = xml.Marshal</code></span>
<span class="codeline" id="line-567"><code>	}</code></span>
<span class="codeline" id="line-568"><code>	if app.config.Network == "" {</code></span>
<span class="codeline" id="line-569"><code>		app.config.Network = NetworkTCP4</code></span>
<span class="codeline" id="line-570"><code>	}</code></span>
<span class="codeline" id="line-571"><code>	if len(app.config.RequestMethods) == 0 {</code></span>
<span class="codeline" id="line-572"><code>		app.config.RequestMethods = DefaultMethods</code></span>
<span class="codeline" id="line-573"><code>	}</code></span>
<span class="codeline" id="line-574"><code></code></span>
<span class="codeline" id="line-575"><code>	app.config.trustedProxiesMap = make(map[string]struct{}, len(app.config.TrustedProxies))</code></span>
<span class="codeline" id="line-576"><code>	for _, ipAddress := range app.config.TrustedProxies {</code></span>
<span class="codeline" id="line-577"><code>		app.handleTrustedProxy(ipAddress)</code></span>
<span class="codeline" id="line-578"><code>	}</code></span>
<span class="codeline" id="line-579"><code></code></span>
<span class="codeline" id="line-580"><code>	// Create router stack</code></span>
<span class="codeline" id="line-581"><code>	app.stack = make([][]*Route, len(app.config.RequestMethods))</code></span>
<span class="codeline" id="line-582"><code>	app.treeStack = make([]map[string][]*Route, len(app.config.RequestMethods))</code></span>
<span class="codeline" id="line-583"><code></code></span>
<span class="codeline" id="line-584"><code>	// Override colors</code></span>
<span class="codeline" id="line-585"><code>	app.config.ColorScheme = defaultColors(app.config.ColorScheme)</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>	// Init app</code></span>
<span class="codeline" id="line-588"><code>	app.init()</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>	// Return app</code></span>
<span class="codeline" id="line-591"><code>	return app</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>// Adds an ip address to trustedProxyRanges or trustedProxiesMap based on whether it is an IP range or not</code></span>
<span class="codeline" id="line-595"><code>func (app *App) handleTrustedProxy(ipAddress string) {</code></span>
<span class="codeline" id="line-596"><code>	if strings.Contains(ipAddress, "/") {</code></span>
<span class="codeline" id="line-597"><code>		_, ipNet, err := net.ParseCIDR(ipAddress)</code></span>
<span class="codeline" id="line-598"><code>		if err != nil {</code></span>
<span class="codeline" id="line-599"><code>			log.Warnf("IP range %q could not be parsed: %v", ipAddress, err)</code></span>
<span class="codeline" id="line-600"><code>		} else {</code></span>
<span class="codeline" id="line-601"><code>			app.config.trustedProxyRanges = append(app.config.trustedProxyRanges, ipNet)</code></span>
<span class="codeline" id="line-602"><code>		}</code></span>
<span class="codeline" id="line-603"><code>	} else {</code></span>
<span class="codeline" id="line-604"><code>		app.config.trustedProxiesMap[ipAddress] = struct{}{}</code></span>
<span class="codeline" id="line-605"><code>	}</code></span>
<span class="codeline" id="line-606"><code>}</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>// SetTLSHandler You can use SetTLSHandler to use ClientHelloInfo when using TLS with Listener.</code></span>
<span class="codeline" id="line-609"><code>func (app *App) SetTLSHandler(tlsHandler *TLSHandler) {</code></span>
<span class="codeline" id="line-610"><code>	// Attach the tlsHandler to the config</code></span>
<span class="codeline" id="line-611"><code>	app.mutex.Lock()</code></span>
<span class="codeline" id="line-612"><code>	app.tlsHandler = tlsHandler</code></span>
<span class="codeline" id="line-613"><code>	app.mutex.Unlock()</code></span>
<span class="codeline" id="line-614"><code>}</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>// Name Assign name to specific route.</code></span>
<span class="codeline" id="line-617"><code>func (app *App) Name(name string) Router {</code></span>
<span class="codeline" id="line-618"><code>	app.mutex.Lock()</code></span>
<span class="codeline" id="line-619"><code>	defer app.mutex.Unlock()</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>	for _, routes := range app.stack {</code></span>
<span class="codeline" id="line-622"><code>		for _, route := range routes {</code></span>
<span class="codeline" id="line-623"><code>			isMethodValid := route.Method == app.latestRoute.Method || app.latestRoute.use ||</code></span>
<span class="codeline" id="line-624"><code>				(app.latestRoute.Method == MethodGet &amp;&amp; route.Method == MethodHead)</code></span>
<span class="codeline" id="line-625"><code></code></span>
<span class="codeline" id="line-626"><code>			if route.Path == app.latestRoute.Path &amp;&amp; isMethodValid {</code></span>
<span class="codeline" id="line-627"><code>				route.Name = name</code></span>
<span class="codeline" id="line-628"><code>				if route.group != nil {</code></span>
<span class="codeline" id="line-629"><code>					route.Name = route.group.name + route.Name</code></span>
<span class="codeline" id="line-630"><code>				}</code></span>
<span class="codeline" id="line-631"><code>			}</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>	}</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>	if err := app.hooks.executeOnNameHooks(*app.latestRoute); err != nil {</code></span>
<span class="codeline" id="line-636"><code>		panic(err)</code></span>
<span class="codeline" id="line-637"><code>	}</code></span>
<span class="codeline" id="line-638"><code></code></span>
<span class="codeline" id="line-639"><code>	return app</code></span>
<span class="codeline" id="line-640"><code>}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>// GetRoute Get route by name</code></span>
<span class="codeline" id="line-643"><code>func (app *App) GetRoute(name string) Route {</code></span>
<span class="codeline" id="line-644"><code>	for _, routes := range app.stack {</code></span>
<span class="codeline" id="line-645"><code>		for _, route := range routes {</code></span>
<span class="codeline" id="line-646"><code>			if route.Name == name {</code></span>
<span class="codeline" id="line-647"><code>				return *route</code></span>
<span class="codeline" id="line-648"><code>			}</code></span>
<span class="codeline" id="line-649"><code>		}</code></span>
<span class="codeline" id="line-650"><code>	}</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>	return Route{}</code></span>
<span class="codeline" id="line-653"><code>}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>// GetRoutes Get all routes. When filterUseOption equal to true, it will filter the routes registered by the middleware.</code></span>
<span class="codeline" id="line-656"><code>func (app *App) GetRoutes(filterUseOption ...bool) []Route {</code></span>
<span class="codeline" id="line-657"><code>	var rs []Route</code></span>
<span class="codeline" id="line-658"><code>	var filterUse bool</code></span>
<span class="codeline" id="line-659"><code>	if len(filterUseOption) != 0 {</code></span>
<span class="codeline" id="line-660"><code>		filterUse = filterUseOption[0]</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code>	for _, routes := range app.stack {</code></span>
<span class="codeline" id="line-663"><code>		for _, route := range routes {</code></span>
<span class="codeline" id="line-664"><code>			if filterUse &amp;&amp; route.use {</code></span>
<span class="codeline" id="line-665"><code>				continue</code></span>
<span class="codeline" id="line-666"><code>			}</code></span>
<span class="codeline" id="line-667"><code>			rs = append(rs, *route)</code></span>
<span class="codeline" id="line-668"><code>		}</code></span>
<span class="codeline" id="line-669"><code>	}</code></span>
<span class="codeline" id="line-670"><code>	return rs</code></span>
<span class="codeline" id="line-671"><code>}</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>// Use registers a middleware route that will match requests</code></span>
<span class="codeline" id="line-674"><code>// with the provided prefix (which is optional and defaults to "/").</code></span>
<span class="codeline" id="line-675"><code>//</code></span>
<span class="codeline" id="line-676"><code>//	app.Use(func(c *fiber.Ctx) error {</code></span>
<span class="codeline" id="line-677"><code>//	     return c.Next()</code></span>
<span class="codeline" id="line-678"><code>//	})</code></span>
<span class="codeline" id="line-679"><code>//	app.Use("/api", func(c *fiber.Ctx) error {</code></span>
<span class="codeline" id="line-680"><code>//	     return c.Next()</code></span>
<span class="codeline" id="line-681"><code>//	})</code></span>
<span class="codeline" id="line-682"><code>//	app.Use("/api", handler, func(c *fiber.Ctx) error {</code></span>
<span class="codeline" id="line-683"><code>//	     return c.Next()</code></span>
<span class="codeline" id="line-684"><code>//	})</code></span>
<span class="codeline" id="line-685"><code>//</code></span>
<span class="codeline" id="line-686"><code>// This method will match all HTTP verbs: GET, POST, PUT, HEAD etc...</code></span>
<span class="codeline" id="line-687"><code>func (app *App) Use(args ...interface{}) Router {</code></span>
<span class="codeline" id="line-688"><code>	var prefix string</code></span>
<span class="codeline" id="line-689"><code>	var prefixes []string</code></span>
<span class="codeline" id="line-690"><code>	var handlers []Handler</code></span>
<span class="codeline" id="line-691"><code></code></span>
<span class="codeline" id="line-692"><code>	for i := 0; i &lt; len(args); i++ {</code></span>
<span class="codeline" id="line-693"><code>		switch arg := args[i].(type) {</code></span>
<span class="codeline" id="line-694"><code>		case string:</code></span>
<span class="codeline" id="line-695"><code>			prefix = arg</code></span>
<span class="codeline" id="line-696"><code>		case []string:</code></span>
<span class="codeline" id="line-697"><code>			prefixes = arg</code></span>
<span class="codeline" id="line-698"><code>		case Handler:</code></span>
<span class="codeline" id="line-699"><code>			handlers = append(handlers, arg)</code></span>
<span class="codeline" id="line-700"><code>		default:</code></span>
<span class="codeline" id="line-701"><code>			panic(fmt.Sprintf("use: invalid handler %v\n", reflect.TypeOf(arg)))</code></span>
<span class="codeline" id="line-702"><code>		}</code></span>
<span class="codeline" id="line-703"><code>	}</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>	if len(prefixes) == 0 {</code></span>
<span class="codeline" id="line-706"><code>		prefixes = append(prefixes, prefix)</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>	for _, prefix := range prefixes {</code></span>
<span class="codeline" id="line-710"><code>		app.register(methodUse, prefix, nil, handlers...)</code></span>
<span class="codeline" id="line-711"><code>	}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>	return app</code></span>
<span class="codeline" id="line-714"><code>}</code></span>
<span class="codeline" id="line-715"><code></code></span>
<span class="codeline" id="line-716"><code>// Get registers a route for GET methods that requests a representation</code></span>
<span class="codeline" id="line-717"><code>// of the specified resource. Requests using GET should only retrieve data.</code></span>
<span class="codeline" id="line-718"><code>func (app *App) Get(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-719"><code>	return app.Head(path, handlers...).Add(MethodGet, path, handlers...)</code></span>
<span class="codeline" id="line-720"><code>}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>// Head registers a route for HEAD methods that asks for a response identical</code></span>
<span class="codeline" id="line-723"><code>// to that of a GET request, but without the response body.</code></span>
<span class="codeline" id="line-724"><code>func (app *App) Head(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-725"><code>	return app.Add(MethodHead, path, handlers...)</code></span>
<span class="codeline" id="line-726"><code>}</code></span>
<span class="codeline" id="line-727"><code></code></span>
<span class="codeline" id="line-728"><code>// Post registers a route for POST methods that is used to submit an entity to the</code></span>
<span class="codeline" id="line-729"><code>// specified resource, often causing a change in state or side effects on the server.</code></span>
<span class="codeline" id="line-730"><code>func (app *App) Post(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-731"><code>	return app.Add(MethodPost, path, handlers...)</code></span>
<span class="codeline" id="line-732"><code>}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>// Put registers a route for PUT methods that replaces all current representations</code></span>
<span class="codeline" id="line-735"><code>// of the target resource with the request payload.</code></span>
<span class="codeline" id="line-736"><code>func (app *App) Put(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-737"><code>	return app.Add(MethodPut, path, handlers...)</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>// Delete registers a route for DELETE methods that deletes the specified resource.</code></span>
<span class="codeline" id="line-741"><code>func (app *App) Delete(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-742"><code>	return app.Add(MethodDelete, path, handlers...)</code></span>
<span class="codeline" id="line-743"><code>}</code></span>
<span class="codeline" id="line-744"><code></code></span>
<span class="codeline" id="line-745"><code>// Connect registers a route for CONNECT methods that establishes a tunnel to the</code></span>
<span class="codeline" id="line-746"><code>// server identified by the target resource.</code></span>
<span class="codeline" id="line-747"><code>func (app *App) Connect(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-748"><code>	return app.Add(MethodConnect, path, handlers...)</code></span>
<span class="codeline" id="line-749"><code>}</code></span>
<span class="codeline" id="line-750"><code></code></span>
<span class="codeline" id="line-751"><code>// Options registers a route for OPTIONS methods that is used to describe the</code></span>
<span class="codeline" id="line-752"><code>// communication options for the target resource.</code></span>
<span class="codeline" id="line-753"><code>func (app *App) Options(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-754"><code>	return app.Add(MethodOptions, path, handlers...)</code></span>
<span class="codeline" id="line-755"><code>}</code></span>
<span class="codeline" id="line-756"><code></code></span>
<span class="codeline" id="line-757"><code>// Trace registers a route for TRACE methods that performs a message loop-back</code></span>
<span class="codeline" id="line-758"><code>// test along the path to the target resource.</code></span>
<span class="codeline" id="line-759"><code>func (app *App) Trace(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-760"><code>	return app.Add(MethodTrace, path, handlers...)</code></span>
<span class="codeline" id="line-761"><code>}</code></span>
<span class="codeline" id="line-762"><code></code></span>
<span class="codeline" id="line-763"><code>// Patch registers a route for PATCH methods that is used to apply partial</code></span>
<span class="codeline" id="line-764"><code>// modifications to a resource.</code></span>
<span class="codeline" id="line-765"><code>func (app *App) Patch(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-766"><code>	return app.Add(MethodPatch, path, handlers...)</code></span>
<span class="codeline" id="line-767"><code>}</code></span>
<span class="codeline" id="line-768"><code></code></span>
<span class="codeline" id="line-769"><code>// Add allows you to specify a HTTP method to register a route</code></span>
<span class="codeline" id="line-770"><code>func (app *App) Add(method, path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-771"><code>	app.register(method, path, nil, handlers...)</code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>	return app</code></span>
<span class="codeline" id="line-774"><code>}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>// Static will create a file server serving static files</code></span>
<span class="codeline" id="line-777"><code>func (app *App) Static(prefix, root string, config ...Static) Router {</code></span>
<span class="codeline" id="line-778"><code>	app.registerStatic(prefix, root, config...)</code></span>
<span class="codeline" id="line-779"><code></code></span>
<span class="codeline" id="line-780"><code>	return app</code></span>
<span class="codeline" id="line-781"><code>}</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>// All will register the handler on all HTTP methods</code></span>
<span class="codeline" id="line-784"><code>func (app *App) All(path string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-785"><code>	for _, method := range app.config.RequestMethods {</code></span>
<span class="codeline" id="line-786"><code>		_ = app.Add(method, path, handlers...)</code></span>
<span class="codeline" id="line-787"><code>	}</code></span>
<span class="codeline" id="line-788"><code>	return app</code></span>
<span class="codeline" id="line-789"><code>}</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>// Group is used for Routes with common prefix to define a new sub-router with optional middleware.</code></span>
<span class="codeline" id="line-792"><code>//</code></span>
<span class="codeline" id="line-793"><code>//	api := app.Group("/api")</code></span>
<span class="codeline" id="line-794"><code>//	api.Get("/users", handler)</code></span>
<span class="codeline" id="line-795"><code>func (app *App) Group(prefix string, handlers ...Handler) Router {</code></span>
<span class="codeline" id="line-796"><code>	grp := &amp;Group{Prefix: prefix, app: app}</code></span>
<span class="codeline" id="line-797"><code>	if len(handlers) &gt; 0 {</code></span>
<span class="codeline" id="line-798"><code>		app.register(methodUse, prefix, grp, handlers...)</code></span>
<span class="codeline" id="line-799"><code>	}</code></span>
<span class="codeline" id="line-800"><code>	if err := app.hooks.executeOnGroupHooks(*grp); err != nil {</code></span>
<span class="codeline" id="line-801"><code>		panic(err)</code></span>
<span class="codeline" id="line-802"><code>	}</code></span>
<span class="codeline" id="line-803"><code></code></span>
<span class="codeline" id="line-804"><code>	return grp</code></span>
<span class="codeline" id="line-805"><code>}</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>// Route is used to define routes with a common prefix inside the common function.</code></span>
<span class="codeline" id="line-808"><code>// Uses Group method to define new sub-router.</code></span>
<span class="codeline" id="line-809"><code>func (app *App) Route(prefix string, fn func(router Router), name ...string) Router {</code></span>
<span class="codeline" id="line-810"><code>	// Create new group</code></span>
<span class="codeline" id="line-811"><code>	group := app.Group(prefix)</code></span>
<span class="codeline" id="line-812"><code>	if len(name) &gt; 0 {</code></span>
<span class="codeline" id="line-813"><code>		group.Name(name[0])</code></span>
<span class="codeline" id="line-814"><code>	}</code></span>
<span class="codeline" id="line-815"><code></code></span>
<span class="codeline" id="line-816"><code>	// Define routes</code></span>
<span class="codeline" id="line-817"><code>	fn(group)</code></span>
<span class="codeline" id="line-818"><code></code></span>
<span class="codeline" id="line-819"><code>	return group</code></span>
<span class="codeline" id="line-820"><code>}</code></span>
<span class="codeline" id="line-821"><code></code></span>
<span class="codeline" id="line-822"><code>// Error makes it compatible with the `error` interface.</code></span>
<span class="codeline" id="line-823"><code>func (e *Error) Error() string {</code></span>
<span class="codeline" id="line-824"><code>	return e.Message</code></span>
<span class="codeline" id="line-825"><code>}</code></span>
<span class="codeline" id="line-826"><code></code></span>
<span class="codeline" id="line-827"><code>// NewError creates a new Error instance with an optional message</code></span>
<span class="codeline" id="line-828"><code>func NewError(code int, message ...string) *Error {</code></span>
<span class="codeline" id="line-829"><code>	err := &amp;Error{</code></span>
<span class="codeline" id="line-830"><code>		Code:    code,</code></span>
<span class="codeline" id="line-831"><code>		Message: utils.StatusMessage(code),</code></span>
<span class="codeline" id="line-832"><code>	}</code></span>
<span class="codeline" id="line-833"><code>	if len(message) &gt; 0 {</code></span>
<span class="codeline" id="line-834"><code>		err.Message = message[0]</code></span>
<span class="codeline" id="line-835"><code>	}</code></span>
<span class="codeline" id="line-836"><code>	return err</code></span>
<span class="codeline" id="line-837"><code>}</code></span>
<span class="codeline" id="line-838"><code></code></span>
<span class="codeline" id="line-839"><code>// Config returns the app config as value ( read-only ).</code></span>
<span class="codeline" id="line-840"><code>func (app *App) Config() Config {</code></span>
<span class="codeline" id="line-841"><code>	return app.config</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>// Handler returns the server handler.</code></span>
<span class="codeline" id="line-845"><code>func (app *App) Handler() fasthttp.RequestHandler { //revive:disable-line:confusing-naming // Having both a Handler() (uppercase) and a handler() (lowercase) is fine. TODO: Use nolint:revive directive instead. See https://github.com/golangci/golangci-lint/issues/3476</code></span>
<span class="codeline" id="line-846"><code>	// prepare the server for the start</code></span>
<span class="codeline" id="line-847"><code>	app.startupProcess()</code></span>
<span class="codeline" id="line-848"><code>	return app.handler</code></span>
<span class="codeline" id="line-849"><code>}</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>// Stack returns the raw router stack.</code></span>
<span class="codeline" id="line-852"><code>func (app *App) Stack() [][]*Route {</code></span>
<span class="codeline" id="line-853"><code>	return app.stack</code></span>
<span class="codeline" id="line-854"><code>}</code></span>
<span class="codeline" id="line-855"><code></code></span>
<span class="codeline" id="line-856"><code>// HandlersCount returns the amount of registered handlers.</code></span>
<span class="codeline" id="line-857"><code>func (app *App) HandlersCount() uint32 {</code></span>
<span class="codeline" id="line-858"><code>	return app.handlersCount</code></span>
<span class="codeline" id="line-859"><code>}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>// Shutdown gracefully shuts down the server without interrupting any active connections.</code></span>
<span class="codeline" id="line-862"><code>// Shutdown works by first closing all open listeners and then waiting indefinitely for all connections to return to idle before shutting down.</code></span>
<span class="codeline" id="line-863"><code>//</code></span>
<span class="codeline" id="line-864"><code>// Make sure the program doesn't exit and waits instead for Shutdown to return.</code></span>
<span class="codeline" id="line-865"><code>//</code></span>
<span class="codeline" id="line-866"><code>// Shutdown does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.</code></span>
<span class="codeline" id="line-867"><code>func (app *App) Shutdown() error {</code></span>
<span class="codeline" id="line-868"><code>	return app.ShutdownWithContext(context.Background())</code></span>
<span class="codeline" id="line-869"><code>}</code></span>
<span class="codeline" id="line-870"><code></code></span>
<span class="codeline" id="line-871"><code>// ShutdownWithTimeout gracefully shuts down the server without interrupting any active connections. However, if the timeout is exceeded,</code></span>
<span class="codeline" id="line-872"><code>// ShutdownWithTimeout will forcefully close any active connections.</code></span>
<span class="codeline" id="line-873"><code>// ShutdownWithTimeout works by first closing all open listeners and then waiting for all connections to return to idle before shutting down.</code></span>
<span class="codeline" id="line-874"><code>//</code></span>
<span class="codeline" id="line-875"><code>// Make sure the program doesn't exit and waits instead for ShutdownWithTimeout to return.</code></span>
<span class="codeline" id="line-876"><code>//</code></span>
<span class="codeline" id="line-877"><code>// ShutdownWithTimeout does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.</code></span>
<span class="codeline" id="line-878"><code>func (app *App) ShutdownWithTimeout(timeout time.Duration) error {</code></span>
<span class="codeline" id="line-879"><code>	ctx, cancelFunc := context.WithTimeout(context.Background(), timeout)</code></span>
<span class="codeline" id="line-880"><code>	defer cancelFunc()</code></span>
<span class="codeline" id="line-881"><code>	return app.ShutdownWithContext(ctx)</code></span>
<span class="codeline" id="line-882"><code>}</code></span>
<span class="codeline" id="line-883"><code></code></span>
<span class="codeline" id="line-884"><code>// ShutdownWithContext shuts down the server including by force if the context's deadline is exceeded.</code></span>
<span class="codeline" id="line-885"><code>//</code></span>
<span class="codeline" id="line-886"><code>// Make sure the program doesn't exit and waits instead for ShutdownWithTimeout to return.</code></span>
<span class="codeline" id="line-887"><code>//</code></span>
<span class="codeline" id="line-888"><code>// ShutdownWithContext does not close keepalive connections so its recommended to set ReadTimeout to something else than 0.</code></span>
<span class="codeline" id="line-889"><code>func (app *App) ShutdownWithContext(ctx context.Context) error {</code></span>
<span class="codeline" id="line-890"><code>	if app.hooks != nil {</code></span>
<span class="codeline" id="line-891"><code>		defer app.hooks.executeOnShutdownHooks()</code></span>
<span class="codeline" id="line-892"><code>	}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>	app.mutex.Lock()</code></span>
<span class="codeline" id="line-895"><code>	defer app.mutex.Unlock()</code></span>
<span class="codeline" id="line-896"><code>	if app.server == nil {</code></span>
<span class="codeline" id="line-897"><code>		return fmt.Errorf("shutdown: server is not running")</code></span>
<span class="codeline" id="line-898"><code>	}</code></span>
<span class="codeline" id="line-899"><code>	return app.server.ShutdownWithContext(ctx)</code></span>
<span class="codeline" id="line-900"><code>}</code></span>
<span class="codeline" id="line-901"><code></code></span>
<span class="codeline" id="line-902"><code>// Server returns the underlying fasthttp server</code></span>
<span class="codeline" id="line-903"><code>func (app *App) Server() *fasthttp.Server {</code></span>
<span class="codeline" id="line-904"><code>	return app.server</code></span>
<span class="codeline" id="line-905"><code>}</code></span>
<span class="codeline" id="line-906"><code></code></span>
<span class="codeline" id="line-907"><code>// Hooks returns the hook struct to register hooks.</code></span>
<span class="codeline" id="line-908"><code>func (app *App) Hooks() *Hooks {</code></span>
<span class="codeline" id="line-909"><code>	return app.hooks</code></span>
<span class="codeline" id="line-910"><code>}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>// Test is used for internal debugging by passing a *http.Request.</code></span>
<span class="codeline" id="line-913"><code>// Timeout is optional and defaults to 1s, -1 will disable it completely.</code></span>
<span class="codeline" id="line-914"><code>func (app *App) Test(req *http.Request, msTimeout ...int) (*http.Response, error) {</code></span>
<span class="codeline" id="line-915"><code>	// Set timeout</code></span>
<span class="codeline" id="line-916"><code>	timeout := 1000</code></span>
<span class="codeline" id="line-917"><code>	if len(msTimeout) &gt; 0 {</code></span>
<span class="codeline" id="line-918"><code>		timeout = msTimeout[0]</code></span>
<span class="codeline" id="line-919"><code>	}</code></span>
<span class="codeline" id="line-920"><code></code></span>
<span class="codeline" id="line-921"><code>	// Add Content-Length if not provided with body</code></span>
<span class="codeline" id="line-922"><code>	if req.Body != http.NoBody &amp;&amp; req.Header.Get(HeaderContentLength) == "" {</code></span>
<span class="codeline" id="line-923"><code>		req.Header.Add(HeaderContentLength, strconv.FormatInt(req.ContentLength, 10))</code></span>
<span class="codeline" id="line-924"><code>	}</code></span>
<span class="codeline" id="line-925"><code></code></span>
<span class="codeline" id="line-926"><code>	// Dump raw http request</code></span>
<span class="codeline" id="line-927"><code>	dump, err := httputil.DumpRequest(req, true)</code></span>
<span class="codeline" id="line-928"><code>	if err != nil {</code></span>
<span class="codeline" id="line-929"><code>		return nil, fmt.Errorf("failed to dump request: %w", err)</code></span>
<span class="codeline" id="line-930"><code>	}</code></span>
<span class="codeline" id="line-931"><code></code></span>
<span class="codeline" id="line-932"><code>	// Create test connection</code></span>
<span class="codeline" id="line-933"><code>	conn := new(testConn)</code></span>
<span class="codeline" id="line-934"><code></code></span>
<span class="codeline" id="line-935"><code>	// Write raw http request</code></span>
<span class="codeline" id="line-936"><code>	if _, err := conn.r.Write(dump); err != nil {</code></span>
<span class="codeline" id="line-937"><code>		return nil, fmt.Errorf("failed to write: %w", err)</code></span>
<span class="codeline" id="line-938"><code>	}</code></span>
<span class="codeline" id="line-939"><code>	// prepare the server for the start</code></span>
<span class="codeline" id="line-940"><code>	app.startupProcess()</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>	// Serve conn to server</code></span>
<span class="codeline" id="line-943"><code>	channel := make(chan error)</code></span>
<span class="codeline" id="line-944"><code>	go func() {</code></span>
<span class="codeline" id="line-945"><code>		var returned bool</code></span>
<span class="codeline" id="line-946"><code>		defer func() {</code></span>
<span class="codeline" id="line-947"><code>			if !returned {</code></span>
<span class="codeline" id="line-948"><code>				channel &lt;- fmt.Errorf("runtime.Goexit() called in handler or server panic")</code></span>
<span class="codeline" id="line-949"><code>			}</code></span>
<span class="codeline" id="line-950"><code>		}()</code></span>
<span class="codeline" id="line-951"><code></code></span>
<span class="codeline" id="line-952"><code>		channel &lt;- app.server.ServeConn(conn)</code></span>
<span class="codeline" id="line-953"><code>		returned = true</code></span>
<span class="codeline" id="line-954"><code>	}()</code></span>
<span class="codeline" id="line-955"><code></code></span>
<span class="codeline" id="line-956"><code>	// Wait for callback</code></span>
<span class="codeline" id="line-957"><code>	if timeout &gt;= 0 {</code></span>
<span class="codeline" id="line-958"><code>		// With timeout</code></span>
<span class="codeline" id="line-959"><code>		select {</code></span>
<span class="codeline" id="line-960"><code>		case err = &lt;-channel:</code></span>
<span class="codeline" id="line-961"><code>		case &lt;-time.After(time.Duration(timeout) * time.Millisecond):</code></span>
<span class="codeline" id="line-962"><code>			return nil, fmt.Errorf("test: timeout error %vms", timeout)</code></span>
<span class="codeline" id="line-963"><code>		}</code></span>
<span class="codeline" id="line-964"><code>	} else {</code></span>
<span class="codeline" id="line-965"><code>		// Without timeout</code></span>
<span class="codeline" id="line-966"><code>		err = &lt;-channel</code></span>
<span class="codeline" id="line-967"><code>	}</code></span>
<span class="codeline" id="line-968"><code></code></span>
<span class="codeline" id="line-969"><code>	// Check for errors</code></span>
<span class="codeline" id="line-970"><code>	if err != nil &amp;&amp; !errors.Is(err, fasthttp.ErrGetOnly) {</code></span>
<span class="codeline" id="line-971"><code>		return nil, err</code></span>
<span class="codeline" id="line-972"><code>	}</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>	// Read response</code></span>
<span class="codeline" id="line-975"><code>	buffer := bufio.NewReader(&amp;conn.w)</code></span>
<span class="codeline" id="line-976"><code></code></span>
<span class="codeline" id="line-977"><code>	// Convert raw http response to *http.Response</code></span>
<span class="codeline" id="line-978"><code>	res, err := http.ReadResponse(buffer, req)</code></span>
<span class="codeline" id="line-979"><code>	if err != nil {</code></span>
<span class="codeline" id="line-980"><code>		return nil, fmt.Errorf("failed to read response: %w", err)</code></span>
<span class="codeline" id="line-981"><code>	}</code></span>
<span class="codeline" id="line-982"><code></code></span>
<span class="codeline" id="line-983"><code>	return res, nil</code></span>
<span class="codeline" id="line-984"><code>}</code></span>
<span class="codeline" id="line-985"><code></code></span>
<span class="codeline" id="line-986"><code>type disableLogger struct{}</code></span>
<span class="codeline" id="line-987"><code></code></span>
<span class="codeline" id="line-988"><code>func (*disableLogger) Printf(_ string, _ ...interface{}) {</code></span>
<span class="codeline" id="line-989"><code>	// fmt.Println(fmt.Sprintf(format, args...))</code></span>
<span class="codeline" id="line-990"><code>}</code></span>
<span class="codeline" id="line-991"><code></code></span>
<span class="codeline" id="line-992"><code>func (app *App) init() *App {</code></span>
<span class="codeline" id="line-993"><code>	// lock application</code></span>
<span class="codeline" id="line-994"><code>	app.mutex.Lock()</code></span>
<span class="codeline" id="line-995"><code></code></span>
<span class="codeline" id="line-996"><code>	// Only load templates if a view engine is specified</code></span>
<span class="codeline" id="line-997"><code>	if app.config.Views != nil {</code></span>
<span class="codeline" id="line-998"><code>		if err := app.config.Views.Load(); err != nil {</code></span>
<span class="codeline" id="line-999"><code>			log.Warnf("failed to load views: %v", err)</code></span>
<span class="codeline" id="line-1000"><code>		}</code></span>
<span class="codeline" id="line-1001"><code>	}</code></span>
<span class="codeline" id="line-1002"><code></code></span>
<span class="codeline" id="line-1003"><code>	// create fasthttp server</code></span>
<span class="codeline" id="line-1004"><code>	app.server = &amp;fasthttp.Server{</code></span>
<span class="codeline" id="line-1005"><code>		Logger:       &amp;disableLogger{},</code></span>
<span class="codeline" id="line-1006"><code>		LogAllErrors: false,</code></span>
<span class="codeline" id="line-1007"><code>		ErrorHandler: app.serverErrorHandler,</code></span>
<span class="codeline" id="line-1008"><code>	}</code></span>
<span class="codeline" id="line-1009"><code></code></span>
<span class="codeline" id="line-1010"><code>	// fasthttp server settings</code></span>
<span class="codeline" id="line-1011"><code>	app.server.Handler = app.handler</code></span>
<span class="codeline" id="line-1012"><code>	app.server.Name = app.config.ServerHeader</code></span>
<span class="codeline" id="line-1013"><code>	app.server.Concurrency = app.config.Concurrency</code></span>
<span class="codeline" id="line-1014"><code>	app.server.NoDefaultDate = app.config.DisableDefaultDate</code></span>
<span class="codeline" id="line-1015"><code>	app.server.NoDefaultContentType = app.config.DisableDefaultContentType</code></span>
<span class="codeline" id="line-1016"><code>	app.server.DisableHeaderNamesNormalizing = app.config.DisableHeaderNormalizing</code></span>
<span class="codeline" id="line-1017"><code>	app.server.DisableKeepalive = app.config.DisableKeepalive</code></span>
<span class="codeline" id="line-1018"><code>	app.server.MaxRequestBodySize = app.config.BodyLimit</code></span>
<span class="codeline" id="line-1019"><code>	app.server.NoDefaultServerHeader = app.config.ServerHeader == ""</code></span>
<span class="codeline" id="line-1020"><code>	app.server.ReadTimeout = app.config.ReadTimeout</code></span>
<span class="codeline" id="line-1021"><code>	app.server.WriteTimeout = app.config.WriteTimeout</code></span>
<span class="codeline" id="line-1022"><code>	app.server.IdleTimeout = app.config.IdleTimeout</code></span>
<span class="codeline" id="line-1023"><code>	app.server.ReadBufferSize = app.config.ReadBufferSize</code></span>
<span class="codeline" id="line-1024"><code>	app.server.WriteBufferSize = app.config.WriteBufferSize</code></span>
<span class="codeline" id="line-1025"><code>	app.server.GetOnly = app.config.GETOnly</code></span>
<span class="codeline" id="line-1026"><code>	app.server.ReduceMemoryUsage = app.config.ReduceMemoryUsage</code></span>
<span class="codeline" id="line-1027"><code>	app.server.StreamRequestBody = app.config.StreamRequestBody</code></span>
<span class="codeline" id="line-1028"><code>	app.server.DisablePreParseMultipartForm = app.config.DisablePreParseMultipartForm</code></span>
<span class="codeline" id="line-1029"><code></code></span>
<span class="codeline" id="line-1030"><code>	// unlock application</code></span>
<span class="codeline" id="line-1031"><code>	app.mutex.Unlock()</code></span>
<span class="codeline" id="line-1032"><code>	return app</code></span>
<span class="codeline" id="line-1033"><code>}</code></span>
<span class="codeline" id="line-1034"><code></code></span>
<span class="codeline" id="line-1035"><code>// ErrorHandler is the application's method in charge of finding the</code></span>
<span class="codeline" id="line-1036"><code>// appropriate handler for the given request. It searches any mounted</code></span>
<span class="codeline" id="line-1037"><code>// sub fibers by their prefixes and if it finds a match, it uses that</code></span>
<span class="codeline" id="line-1038"><code>// error handler. Otherwise it uses the configured error handler for</code></span>
<span class="codeline" id="line-1039"><code>// the app, which if not set is the DefaultErrorHandler.</code></span>
<span class="codeline" id="line-1040"><code>func (app *App) ErrorHandler(ctx *Ctx, err error) error {</code></span>
<span class="codeline" id="line-1041"><code>	var (</code></span>
<span class="codeline" id="line-1042"><code>		mountedErrHandler  ErrorHandler</code></span>
<span class="codeline" id="line-1043"><code>		mountedPrefixParts int</code></span>
<span class="codeline" id="line-1044"><code>	)</code></span>
<span class="codeline" id="line-1045"><code></code></span>
<span class="codeline" id="line-1046"><code>	for prefix, subApp := range app.mountFields.appList {</code></span>
<span class="codeline" id="line-1047"><code>		if prefix != "" &amp;&amp; strings.HasPrefix(ctx.path, prefix) {</code></span>
<span class="codeline" id="line-1048"><code>			parts := len(strings.Split(prefix, "/"))</code></span>
<span class="codeline" id="line-1049"><code>			if mountedPrefixParts &lt;= parts {</code></span>
<span class="codeline" id="line-1050"><code>				if subApp.configured.ErrorHandler != nil {</code></span>
<span class="codeline" id="line-1051"><code>					mountedErrHandler = subApp.config.ErrorHandler</code></span>
<span class="codeline" id="line-1052"><code>				}</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>				mountedPrefixParts = parts</code></span>
<span class="codeline" id="line-1055"><code>			}</code></span>
<span class="codeline" id="line-1056"><code>		}</code></span>
<span class="codeline" id="line-1057"><code>	}</code></span>
<span class="codeline" id="line-1058"><code></code></span>
<span class="codeline" id="line-1059"><code>	if mountedErrHandler != nil {</code></span>
<span class="codeline" id="line-1060"><code>		return mountedErrHandler(ctx, err)</code></span>
<span class="codeline" id="line-1061"><code>	}</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>	return app.config.ErrorHandler(ctx, err)</code></span>
<span class="codeline" id="line-1064"><code>}</code></span>
<span class="codeline" id="line-1065"><code></code></span>
<span class="codeline" id="line-1066"><code>// serverErrorHandler is a wrapper around the application's error handler method</code></span>
<span class="codeline" id="line-1067"><code>// user for the fasthttp server configuration. It maps a set of fasthttp errors to fiber</code></span>
<span class="codeline" id="line-1068"><code>// errors before calling the application's error handler method.</code></span>
<span class="codeline" id="line-1069"><code>func (app *App) serverErrorHandler(fctx *fasthttp.RequestCtx, err error) {</code></span>
<span class="codeline" id="line-1070"><code>	c := app.AcquireCtx(fctx)</code></span>
<span class="codeline" id="line-1071"><code>	defer app.ReleaseCtx(c)</code></span>
<span class="codeline" id="line-1072"><code></code></span>
<span class="codeline" id="line-1073"><code>	var (</code></span>
<span class="codeline" id="line-1074"><code>		errNetOP *net.OpError</code></span>
<span class="codeline" id="line-1075"><code>		netErr   net.Error</code></span>
<span class="codeline" id="line-1076"><code>	)</code></span>
<span class="codeline" id="line-1077"><code></code></span>
<span class="codeline" id="line-1078"><code>	switch {</code></span>
<span class="codeline" id="line-1079"><code>	case errors.As(err, new(*fasthttp.ErrSmallBuffer)):</code></span>
<span class="codeline" id="line-1080"><code>		err = ErrRequestHeaderFieldsTooLarge</code></span>
<span class="codeline" id="line-1081"><code>	case errors.As(err, &amp;errNetOP) &amp;&amp; errNetOP.Timeout():</code></span>
<span class="codeline" id="line-1082"><code>		err = ErrRequestTimeout</code></span>
<span class="codeline" id="line-1083"><code>	case errors.As(err, &amp;netErr):</code></span>
<span class="codeline" id="line-1084"><code>		err = ErrBadGateway</code></span>
<span class="codeline" id="line-1085"><code>	case errors.Is(err, fasthttp.ErrBodyTooLarge):</code></span>
<span class="codeline" id="line-1086"><code>		err = ErrRequestEntityTooLarge</code></span>
<span class="codeline" id="line-1087"><code>	case errors.Is(err, fasthttp.ErrGetOnly):</code></span>
<span class="codeline" id="line-1088"><code>		err = ErrMethodNotAllowed</code></span>
<span class="codeline" id="line-1089"><code>	case strings.Contains(err.Error(), "timeout"):</code></span>
<span class="codeline" id="line-1090"><code>		err = ErrRequestTimeout</code></span>
<span class="codeline" id="line-1091"><code>	default:</code></span>
<span class="codeline" id="line-1092"><code>		err = NewError(StatusBadRequest, err.Error())</code></span>
<span class="codeline" id="line-1093"><code>	}</code></span>
<span class="codeline" id="line-1094"><code></code></span>
<span class="codeline" id="line-1095"><code>	if catch := app.ErrorHandler(c, err); catch != nil {</code></span>
<span class="codeline" id="line-1096"><code>		log.Errorf("serverErrorHandler: failed to call ErrorHandler: %v", catch)</code></span>
<span class="codeline" id="line-1097"><code>		_ = c.SendStatus(StatusInternalServerError) //nolint:errcheck // It is fine to ignore the error here</code></span>
<span class="codeline" id="line-1098"><code>		return</code></span>
<span class="codeline" id="line-1099"><code>	}</code></span>
<span class="codeline" id="line-1100"><code>}</code></span>
<span class="codeline" id="line-1101"><code></code></span>
<span class="codeline" id="line-1102"><code>// startupProcess Is the method which executes all the necessary processes just before the start of the server.</code></span>
<span class="codeline" id="line-1103"><code>func (app *App) startupProcess() *App {</code></span>
<span class="codeline" id="line-1104"><code>	app.mutex.Lock()</code></span>
<span class="codeline" id="line-1105"><code>	defer app.mutex.Unlock()</code></span>
<span class="codeline" id="line-1106"><code></code></span>
<span class="codeline" id="line-1107"><code>	app.mountStartupProcess()</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>	// build route tree stack</code></span>
<span class="codeline" id="line-1110"><code>	app.buildTree()</code></span>
<span class="codeline" id="line-1111"><code></code></span>
<span class="codeline" id="line-1112"><code>	return app</code></span>
<span class="codeline" id="line-1113"><code>}</code></span>
<span class="codeline" id="line-1114"><code></code></span>
<span class="codeline" id="line-1115"><code>// Run onListen hooks. If they return an error, panic.</code></span>
<span class="codeline" id="line-1116"><code>func (app *App) runOnListenHooks(listenData ListenData) {</code></span>
<span class="codeline" id="line-1117"><code>	if err := app.hooks.executeOnListenHooks(listenData); err != nil {</code></span>
<span class="codeline" id="line-1118"><code>		panic(err)</code></span>
<span class="codeline" id="line-1119"><code>	}</code></span>
<span class="codeline" id="line-1120"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>