<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: client.go in package github.com/valyala/fasthttp</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	client.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/valyala/fasthttp.html">github.com/valyala/fasthttp</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package fasthttp</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"bufio"</code></span>
<span class="codeline" id="line-5"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-6"><code>	"errors"</code></span>
<span class="codeline" id="line-7"><code>	"fmt"</code></span>
<span class="codeline" id="line-8"><code>	"io"</code></span>
<span class="codeline" id="line-9"><code>	"net"</code></span>
<span class="codeline" id="line-10"><code>	"strings"</code></span>
<span class="codeline" id="line-11"><code>	"sync"</code></span>
<span class="codeline" id="line-12"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-13"><code>	"time"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// Do performs the given http request and fills the given http response.</code></span>
<span class="codeline" id="line-17"><code>//</code></span>
<span class="codeline" id="line-18"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-19"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-20"><code>//</code></span>
<span class="codeline" id="line-21"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-22"><code>//</code></span>
<span class="codeline" id="line-23"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-24"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-25"><code>//</code></span>
<span class="codeline" id="line-26"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-27"><code>//</code></span>
<span class="codeline" id="line-28"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-29"><code>//</code></span>
<span class="codeline" id="line-30"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-31"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-34"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-35"><code>func Do(req *Request, resp *Response) error {</code></span>
<span class="codeline" id="line-36"><code>	return defaultClient.Do(req, resp)</code></span>
<span class="codeline" id="line-37"><code>}</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>// DoTimeout performs the given request and waits for response during</code></span>
<span class="codeline" id="line-40"><code>// the given timeout duration.</code></span>
<span class="codeline" id="line-41"><code>//</code></span>
<span class="codeline" id="line-42"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-43"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-44"><code>//</code></span>
<span class="codeline" id="line-45"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-46"><code>//</code></span>
<span class="codeline" id="line-47"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-48"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-49"><code>//</code></span>
<span class="codeline" id="line-50"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-53"><code>//</code></span>
<span class="codeline" id="line-54"><code>// ErrTimeout is returned if the response wasn't returned during</code></span>
<span class="codeline" id="line-55"><code>// the given timeout.</code></span>
<span class="codeline" id="line-56"><code>//</code></span>
<span class="codeline" id="line-57"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-58"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-59"><code>//</code></span>
<span class="codeline" id="line-60"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-61"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-62"><code>func DoTimeout(req *Request, resp *Response, timeout time.Duration) error {</code></span>
<span class="codeline" id="line-63"><code>	return defaultClient.DoTimeout(req, resp, timeout)</code></span>
<span class="codeline" id="line-64"><code>}</code></span>
<span class="codeline" id="line-65"><code></code></span>
<span class="codeline" id="line-66"><code>// DoDeadline performs the given request and waits for response until</code></span>
<span class="codeline" id="line-67"><code>// the given deadline.</code></span>
<span class="codeline" id="line-68"><code>//</code></span>
<span class="codeline" id="line-69"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-70"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-71"><code>//</code></span>
<span class="codeline" id="line-72"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-73"><code>//</code></span>
<span class="codeline" id="line-74"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-75"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-76"><code>//</code></span>
<span class="codeline" id="line-77"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-78"><code>//</code></span>
<span class="codeline" id="line-79"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-80"><code>//</code></span>
<span class="codeline" id="line-81"><code>// ErrTimeout is returned if the response wasn't returned until</code></span>
<span class="codeline" id="line-82"><code>// the given deadline.</code></span>
<span class="codeline" id="line-83"><code>//</code></span>
<span class="codeline" id="line-84"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-85"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-86"><code>//</code></span>
<span class="codeline" id="line-87"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-88"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-89"><code>func DoDeadline(req *Request, resp *Response, deadline time.Time) error {</code></span>
<span class="codeline" id="line-90"><code>	return defaultClient.DoDeadline(req, resp, deadline)</code></span>
<span class="codeline" id="line-91"><code>}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>// DoRedirects performs the given http request and fills the given http response,</code></span>
<span class="codeline" id="line-94"><code>// following up to maxRedirectsCount redirects. When the redirect count exceeds</code></span>
<span class="codeline" id="line-95"><code>// maxRedirectsCount, ErrTooManyRedirects is returned.</code></span>
<span class="codeline" id="line-96"><code>//</code></span>
<span class="codeline" id="line-97"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-98"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-99"><code>//</code></span>
<span class="codeline" id="line-100"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-101"><code>//</code></span>
<span class="codeline" id="line-102"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-103"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-104"><code>//</code></span>
<span class="codeline" id="line-105"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-106"><code>//</code></span>
<span class="codeline" id="line-107"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-108"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-109"><code>//</code></span>
<span class="codeline" id="line-110"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-111"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-112"><code>func DoRedirects(req *Request, resp *Response, maxRedirectsCount int) error {</code></span>
<span class="codeline" id="line-113"><code>	_, _, err := doRequestFollowRedirects(req, resp, req.URI().String(), maxRedirectsCount, &amp;defaultClient)</code></span>
<span class="codeline" id="line-114"><code>	return err</code></span>
<span class="codeline" id="line-115"><code>}</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>// Get returns the status code and body of url.</code></span>
<span class="codeline" id="line-118"><code>//</code></span>
<span class="codeline" id="line-119"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-120"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-121"><code>//</code></span>
<span class="codeline" id="line-122"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-123"><code>func Get(dst []byte, url string) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-124"><code>	return defaultClient.Get(dst, url)</code></span>
<span class="codeline" id="line-125"><code>}</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>// GetTimeout returns the status code and body of url.</code></span>
<span class="codeline" id="line-128"><code>//</code></span>
<span class="codeline" id="line-129"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-130"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-131"><code>//</code></span>
<span class="codeline" id="line-132"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-133"><code>//</code></span>
<span class="codeline" id="line-134"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-135"><code>// during the given timeout.</code></span>
<span class="codeline" id="line-136"><code>func GetTimeout(dst []byte, url string, timeout time.Duration) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-137"><code>	return defaultClient.GetTimeout(dst, url, timeout)</code></span>
<span class="codeline" id="line-138"><code>}</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>// GetDeadline returns the status code and body of url.</code></span>
<span class="codeline" id="line-141"><code>//</code></span>
<span class="codeline" id="line-142"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-143"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-144"><code>//</code></span>
<span class="codeline" id="line-145"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-146"><code>//</code></span>
<span class="codeline" id="line-147"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-148"><code>// until the given deadline.</code></span>
<span class="codeline" id="line-149"><code>func GetDeadline(dst []byte, url string, deadline time.Time) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-150"><code>	return defaultClient.GetDeadline(dst, url, deadline)</code></span>
<span class="codeline" id="line-151"><code>}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>// Post sends POST request to the given url with the given POST arguments.</code></span>
<span class="codeline" id="line-154"><code>//</code></span>
<span class="codeline" id="line-155"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-156"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-157"><code>//</code></span>
<span class="codeline" id="line-158"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-159"><code>//</code></span>
<span class="codeline" id="line-160"><code>// Empty POST body is sent if postArgs is nil.</code></span>
<span class="codeline" id="line-161"><code>func Post(dst []byte, url string, postArgs *Args) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-162"><code>	return defaultClient.Post(dst, url, postArgs)</code></span>
<span class="codeline" id="line-163"><code>}</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>var defaultClient Client</code></span>
<span class="codeline" id="line-166"><code></code></span>
<span class="codeline" id="line-167"><code>// Client implements http client.</code></span>
<span class="codeline" id="line-168"><code>//</code></span>
<span class="codeline" id="line-169"><code>// Copying Client by value is prohibited. Create new instance instead.</code></span>
<span class="codeline" id="line-170"><code>//</code></span>
<span class="codeline" id="line-171"><code>// It is safe calling Client methods from concurrently running goroutines.</code></span>
<span class="codeline" id="line-172"><code>//</code></span>
<span class="codeline" id="line-173"><code>// The fields of a Client should not be changed while it is in use.</code></span>
<span class="codeline" id="line-174"><code>type Client struct {</code></span>
<span class="codeline" id="line-175"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// Client name. Used in User-Agent request header.</code></span>
<span class="codeline" id="line-178"><code>	//</code></span>
<span class="codeline" id="line-179"><code>	// Default client name is used if not set.</code></span>
<span class="codeline" id="line-180"><code>	Name string</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>	// NoDefaultUserAgentHeader when set to true, causes the default</code></span>
<span class="codeline" id="line-183"><code>	// User-Agent header to be excluded from the Request.</code></span>
<span class="codeline" id="line-184"><code>	NoDefaultUserAgentHeader bool</code></span>
<span class="codeline" id="line-185"><code></code></span>
<span class="codeline" id="line-186"><code>	// Callback for establishing new connections to hosts.</code></span>
<span class="codeline" id="line-187"><code>	//</code></span>
<span class="codeline" id="line-188"><code>	// Default DialTimeout is used if not set.</code></span>
<span class="codeline" id="line-189"><code>	DialTimeout DialFuncWithTimeout</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>	// Callback for establishing new connections to hosts.</code></span>
<span class="codeline" id="line-192"><code>	//</code></span>
<span class="codeline" id="line-193"><code>	// Note that if Dial is set instead of DialTimeout, Dial will ignore Request timeout.</code></span>
<span class="codeline" id="line-194"><code>	// If you want the tcp dial process to account for request timeouts, use DialTimeout instead.</code></span>
<span class="codeline" id="line-195"><code>	//</code></span>
<span class="codeline" id="line-196"><code>	// If not set, DialTimeout is used.</code></span>
<span class="codeline" id="line-197"><code>	Dial DialFunc</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>	// Attempt to connect to both ipv4 and ipv6 addresses if set to true.</code></span>
<span class="codeline" id="line-200"><code>	//</code></span>
<span class="codeline" id="line-201"><code>	// This option is used only if default TCP dialer is used,</code></span>
<span class="codeline" id="line-202"><code>	// i.e. if Dial is blank.</code></span>
<span class="codeline" id="line-203"><code>	//</code></span>
<span class="codeline" id="line-204"><code>	// By default client connects only to ipv4 addresses,</code></span>
<span class="codeline" id="line-205"><code>	// since unfortunately ipv6 remains broken in many networks worldwide :)</code></span>
<span class="codeline" id="line-206"><code>	DialDualStack bool</code></span>
<span class="codeline" id="line-207"><code></code></span>
<span class="codeline" id="line-208"><code>	// TLS config for https connections.</code></span>
<span class="codeline" id="line-209"><code>	//</code></span>
<span class="codeline" id="line-210"><code>	// Default TLS config is used if not set.</code></span>
<span class="codeline" id="line-211"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-212"><code></code></span>
<span class="codeline" id="line-213"><code>	// Maximum number of connections per each host which may be established.</code></span>
<span class="codeline" id="line-214"><code>	//</code></span>
<span class="codeline" id="line-215"><code>	// DefaultMaxConnsPerHost is used if not set.</code></span>
<span class="codeline" id="line-216"><code>	MaxConnsPerHost int</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>	// Idle keep-alive connections are closed after this duration.</code></span>
<span class="codeline" id="line-219"><code>	//</code></span>
<span class="codeline" id="line-220"><code>	// By default idle connections are closed</code></span>
<span class="codeline" id="line-221"><code>	// after DefaultMaxIdleConnDuration.</code></span>
<span class="codeline" id="line-222"><code>	MaxIdleConnDuration time.Duration</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>	// Keep-alive connections are closed after this duration.</code></span>
<span class="codeline" id="line-225"><code>	//</code></span>
<span class="codeline" id="line-226"><code>	// By default connection duration is unlimited.</code></span>
<span class="codeline" id="line-227"><code>	MaxConnDuration time.Duration</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>	// Maximum number of attempts for idempotent calls.</code></span>
<span class="codeline" id="line-230"><code>	//</code></span>
<span class="codeline" id="line-231"><code>	// DefaultMaxIdemponentCallAttempts is used if not set.</code></span>
<span class="codeline" id="line-232"><code>	MaxIdemponentCallAttempts int</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>	// Per-connection buffer size for responses' reading.</code></span>
<span class="codeline" id="line-235"><code>	// This also limits the maximum header size.</code></span>
<span class="codeline" id="line-236"><code>	//</code></span>
<span class="codeline" id="line-237"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-238"><code>	ReadBufferSize int</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>	// Per-connection buffer size for requests' writing.</code></span>
<span class="codeline" id="line-241"><code>	//</code></span>
<span class="codeline" id="line-242"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-243"><code>	WriteBufferSize int</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>	// Maximum duration for full response reading (including body).</code></span>
<span class="codeline" id="line-246"><code>	//</code></span>
<span class="codeline" id="line-247"><code>	// By default response read timeout is unlimited.</code></span>
<span class="codeline" id="line-248"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	// Maximum duration for full request writing (including body).</code></span>
<span class="codeline" id="line-251"><code>	//</code></span>
<span class="codeline" id="line-252"><code>	// By default request write timeout is unlimited.</code></span>
<span class="codeline" id="line-253"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>	// Maximum response body size.</code></span>
<span class="codeline" id="line-256"><code>	//</code></span>
<span class="codeline" id="line-257"><code>	// The client returns ErrBodyTooLarge if this limit is greater than 0</code></span>
<span class="codeline" id="line-258"><code>	// and response body is greater than the limit.</code></span>
<span class="codeline" id="line-259"><code>	//</code></span>
<span class="codeline" id="line-260"><code>	// By default response body size is unlimited.</code></span>
<span class="codeline" id="line-261"><code>	MaxResponseBodySize int</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	// Header names are passed as-is without normalization</code></span>
<span class="codeline" id="line-264"><code>	// if this option is set.</code></span>
<span class="codeline" id="line-265"><code>	//</code></span>
<span class="codeline" id="line-266"><code>	// Disabled header names' normalization may be useful only for proxying</code></span>
<span class="codeline" id="line-267"><code>	// responses to other clients expecting case-sensitive</code></span>
<span class="codeline" id="line-268"><code>	// header names. See https://github.com/valyala/fasthttp/issues/57</code></span>
<span class="codeline" id="line-269"><code>	// for details.</code></span>
<span class="codeline" id="line-270"><code>	//</code></span>
<span class="codeline" id="line-271"><code>	// By default request and response header names are normalized, i.e.</code></span>
<span class="codeline" id="line-272"><code>	// The first letter and the first letters following dashes</code></span>
<span class="codeline" id="line-273"><code>	// are uppercased, while all the other letters are lowercased.</code></span>
<span class="codeline" id="line-274"><code>	// Examples:</code></span>
<span class="codeline" id="line-275"><code>	//</code></span>
<span class="codeline" id="line-276"><code>	//     * HOST -&gt; Host</code></span>
<span class="codeline" id="line-277"><code>	//     * content-type -&gt; Content-Type</code></span>
<span class="codeline" id="line-278"><code>	//     * cONTENT-lenGTH -&gt; Content-Length</code></span>
<span class="codeline" id="line-279"><code>	DisableHeaderNamesNormalizing bool</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>	// Path values are sent as-is without normalization.</code></span>
<span class="codeline" id="line-282"><code>	//</code></span>
<span class="codeline" id="line-283"><code>	// Disabled path normalization may be useful for proxying incoming requests</code></span>
<span class="codeline" id="line-284"><code>	// to servers that are expecting paths to be forwarded as-is.</code></span>
<span class="codeline" id="line-285"><code>	//</code></span>
<span class="codeline" id="line-286"><code>	// By default path values are normalized, i.e.</code></span>
<span class="codeline" id="line-287"><code>	// extra slashes are removed, special characters are encoded.</code></span>
<span class="codeline" id="line-288"><code>	DisablePathNormalizing bool</code></span>
<span class="codeline" id="line-289"><code></code></span>
<span class="codeline" id="line-290"><code>	// Maximum duration for waiting for a free connection.</code></span>
<span class="codeline" id="line-291"><code>	//</code></span>
<span class="codeline" id="line-292"><code>	// By default will not waiting, return ErrNoFreeConns immediately.</code></span>
<span class="codeline" id="line-293"><code>	MaxConnWaitTimeout time.Duration</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>	// RetryIf controls whether a retry should be attempted after an error.</code></span>
<span class="codeline" id="line-296"><code>	//</code></span>
<span class="codeline" id="line-297"><code>	// By default will use isIdempotent function.</code></span>
<span class="codeline" id="line-298"><code>	RetryIf RetryIfFunc</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>	// Connection pool strategy. Can be either LIFO or FIFO (default).</code></span>
<span class="codeline" id="line-301"><code>	ConnPoolStrategy ConnPoolStrategyType</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>	// StreamResponseBody enables response body streaming.</code></span>
<span class="codeline" id="line-304"><code>	StreamResponseBody bool</code></span>
<span class="codeline" id="line-305"><code></code></span>
<span class="codeline" id="line-306"><code>	// ConfigureClient configures the fasthttp.HostClient.</code></span>
<span class="codeline" id="line-307"><code>	ConfigureClient func(hc *HostClient) error</code></span>
<span class="codeline" id="line-308"><code></code></span>
<span class="codeline" id="line-309"><code>	mLock      sync.RWMutex</code></span>
<span class="codeline" id="line-310"><code>	mOnce      sync.Once</code></span>
<span class="codeline" id="line-311"><code>	m          map[string]*HostClient</code></span>
<span class="codeline" id="line-312"><code>	ms         map[string]*HostClient</code></span>
<span class="codeline" id="line-313"><code>	readerPool sync.Pool</code></span>
<span class="codeline" id="line-314"><code>	writerPool sync.Pool</code></span>
<span class="codeline" id="line-315"><code>}</code></span>
<span class="codeline" id="line-316"><code></code></span>
<span class="codeline" id="line-317"><code>// Get returns the status code and body of url.</code></span>
<span class="codeline" id="line-318"><code>//</code></span>
<span class="codeline" id="line-319"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-320"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-321"><code>//</code></span>
<span class="codeline" id="line-322"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-323"><code>func (c *Client) Get(dst []byte, url string) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-324"><code>	return clientGetURL(dst, url, c)</code></span>
<span class="codeline" id="line-325"><code>}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>// GetTimeout returns the status code and body of url.</code></span>
<span class="codeline" id="line-328"><code>//</code></span>
<span class="codeline" id="line-329"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-330"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-331"><code>//</code></span>
<span class="codeline" id="line-332"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-333"><code>//</code></span>
<span class="codeline" id="line-334"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-335"><code>// during the given timeout.</code></span>
<span class="codeline" id="line-336"><code>func (c *Client) GetTimeout(dst []byte, url string, timeout time.Duration) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-337"><code>	return clientGetURLTimeout(dst, url, timeout, c)</code></span>
<span class="codeline" id="line-338"><code>}</code></span>
<span class="codeline" id="line-339"><code></code></span>
<span class="codeline" id="line-340"><code>// GetDeadline returns the status code and body of url.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-343"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-344"><code>//</code></span>
<span class="codeline" id="line-345"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-346"><code>//</code></span>
<span class="codeline" id="line-347"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-348"><code>// until the given deadline.</code></span>
<span class="codeline" id="line-349"><code>func (c *Client) GetDeadline(dst []byte, url string, deadline time.Time) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-350"><code>	return clientGetURLDeadline(dst, url, deadline, c)</code></span>
<span class="codeline" id="line-351"><code>}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>// Post sends POST request to the given url with the given POST arguments.</code></span>
<span class="codeline" id="line-354"><code>//</code></span>
<span class="codeline" id="line-355"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-356"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-357"><code>//</code></span>
<span class="codeline" id="line-358"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-359"><code>//</code></span>
<span class="codeline" id="line-360"><code>// Empty POST body is sent if postArgs is nil.</code></span>
<span class="codeline" id="line-361"><code>func (c *Client) Post(dst []byte, url string, postArgs *Args) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-362"><code>	return clientPostURL(dst, url, postArgs, c)</code></span>
<span class="codeline" id="line-363"><code>}</code></span>
<span class="codeline" id="line-364"><code></code></span>
<span class="codeline" id="line-365"><code>// DoTimeout performs the given request and waits for response during</code></span>
<span class="codeline" id="line-366"><code>// the given timeout duration.</code></span>
<span class="codeline" id="line-367"><code>//</code></span>
<span class="codeline" id="line-368"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-369"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-370"><code>//</code></span>
<span class="codeline" id="line-371"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-372"><code>//</code></span>
<span class="codeline" id="line-373"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-374"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-375"><code>//</code></span>
<span class="codeline" id="line-376"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-377"><code>//</code></span>
<span class="codeline" id="line-378"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-379"><code>//</code></span>
<span class="codeline" id="line-380"><code>// ErrTimeout is returned if the response wasn't returned during</code></span>
<span class="codeline" id="line-381"><code>// the given timeout.</code></span>
<span class="codeline" id="line-382"><code>// Immediately returns ErrTimeout if timeout value is negative.</code></span>
<span class="codeline" id="line-383"><code>//</code></span>
<span class="codeline" id="line-384"><code>// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections</code></span>
<span class="codeline" id="line-385"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-386"><code>//</code></span>
<span class="codeline" id="line-387"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-388"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-389"><code>func (c *Client) DoTimeout(req *Request, resp *Response, timeout time.Duration) error {</code></span>
<span class="codeline" id="line-390"><code>	req.timeout = timeout</code></span>
<span class="codeline" id="line-391"><code>	if req.timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-392"><code>		return ErrTimeout</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	return c.Do(req, resp)</code></span>
<span class="codeline" id="line-395"><code>}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>// DoDeadline performs the given request and waits for response until</code></span>
<span class="codeline" id="line-398"><code>// the given deadline.</code></span>
<span class="codeline" id="line-399"><code>//</code></span>
<span class="codeline" id="line-400"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-401"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-402"><code>//</code></span>
<span class="codeline" id="line-403"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-404"><code>//</code></span>
<span class="codeline" id="line-405"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-406"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-407"><code>//</code></span>
<span class="codeline" id="line-408"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-409"><code>//</code></span>
<span class="codeline" id="line-410"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-411"><code>//</code></span>
<span class="codeline" id="line-412"><code>// ErrTimeout is returned if the response wasn't returned until</code></span>
<span class="codeline" id="line-413"><code>// the given deadline.</code></span>
<span class="codeline" id="line-414"><code>// Immediately returns ErrTimeout if the deadline has already been reached.</code></span>
<span class="codeline" id="line-415"><code>//</code></span>
<span class="codeline" id="line-416"><code>// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections</code></span>
<span class="codeline" id="line-417"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-418"><code>//</code></span>
<span class="codeline" id="line-419"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-420"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-421"><code>func (c *Client) DoDeadline(req *Request, resp *Response, deadline time.Time) error {</code></span>
<span class="codeline" id="line-422"><code>	req.timeout = time.Until(deadline)</code></span>
<span class="codeline" id="line-423"><code>	if req.timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-424"><code>		return ErrTimeout</code></span>
<span class="codeline" id="line-425"><code>	}</code></span>
<span class="codeline" id="line-426"><code>	return c.Do(req, resp)</code></span>
<span class="codeline" id="line-427"><code>}</code></span>
<span class="codeline" id="line-428"><code></code></span>
<span class="codeline" id="line-429"><code>// DoRedirects performs the given http request and fills the given http response,</code></span>
<span class="codeline" id="line-430"><code>// following up to maxRedirectsCount redirects. When the redirect count exceeds</code></span>
<span class="codeline" id="line-431"><code>// maxRedirectsCount, ErrTooManyRedirects is returned.</code></span>
<span class="codeline" id="line-432"><code>//</code></span>
<span class="codeline" id="line-433"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-434"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-435"><code>//</code></span>
<span class="codeline" id="line-436"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-437"><code>//</code></span>
<span class="codeline" id="line-438"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-439"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-440"><code>//</code></span>
<span class="codeline" id="line-441"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-442"><code>//</code></span>
<span class="codeline" id="line-443"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-444"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-445"><code>//</code></span>
<span class="codeline" id="line-446"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-447"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-448"><code>func (c *Client) DoRedirects(req *Request, resp *Response, maxRedirectsCount int) error {</code></span>
<span class="codeline" id="line-449"><code>	_, _, err := doRequestFollowRedirects(req, resp, req.URI().String(), maxRedirectsCount, c)</code></span>
<span class="codeline" id="line-450"><code>	return err</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>// Do performs the given http request and fills the given http response.</code></span>
<span class="codeline" id="line-454"><code>//</code></span>
<span class="codeline" id="line-455"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-456"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-457"><code>//</code></span>
<span class="codeline" id="line-458"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-459"><code>//</code></span>
<span class="codeline" id="line-460"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-461"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-462"><code>//</code></span>
<span class="codeline" id="line-463"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-464"><code>//</code></span>
<span class="codeline" id="line-465"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-466"><code>//</code></span>
<span class="codeline" id="line-467"><code>// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections</code></span>
<span class="codeline" id="line-468"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-469"><code>//</code></span>
<span class="codeline" id="line-470"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-471"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-472"><code>func (c *Client) Do(req *Request, resp *Response) error {</code></span>
<span class="codeline" id="line-473"><code>	uri := req.URI()</code></span>
<span class="codeline" id="line-474"><code>	if uri == nil {</code></span>
<span class="codeline" id="line-475"><code>		return ErrorInvalidURI</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>	host := uri.Host()</code></span>
<span class="codeline" id="line-479"><code></code></span>
<span class="codeline" id="line-480"><code>	isTLS := false</code></span>
<span class="codeline" id="line-481"><code>	if uri.isHTTPS() {</code></span>
<span class="codeline" id="line-482"><code>		isTLS = true</code></span>
<span class="codeline" id="line-483"><code>	} else if !uri.isHTTP() {</code></span>
<span class="codeline" id="line-484"><code>		return fmt.Errorf("unsupported protocol %q. http and https are supported", uri.Scheme())</code></span>
<span class="codeline" id="line-485"><code>	}</code></span>
<span class="codeline" id="line-486"><code></code></span>
<span class="codeline" id="line-487"><code>	c.mOnce.Do(func() {</code></span>
<span class="codeline" id="line-488"><code>		c.mLock.Lock()</code></span>
<span class="codeline" id="line-489"><code>		c.m = make(map[string]*HostClient)</code></span>
<span class="codeline" id="line-490"><code>		c.ms = make(map[string]*HostClient)</code></span>
<span class="codeline" id="line-491"><code>		c.mLock.Unlock()</code></span>
<span class="codeline" id="line-492"><code>	})</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	startCleaner := false</code></span>
<span class="codeline" id="line-495"><code></code></span>
<span class="codeline" id="line-496"><code>	c.mLock.RLock()</code></span>
<span class="codeline" id="line-497"><code>	m := c.m</code></span>
<span class="codeline" id="line-498"><code>	if isTLS {</code></span>
<span class="codeline" id="line-499"><code>		m = c.ms</code></span>
<span class="codeline" id="line-500"><code>	}</code></span>
<span class="codeline" id="line-501"><code>	hc := m[string(host)]</code></span>
<span class="codeline" id="line-502"><code>	if hc != nil {</code></span>
<span class="codeline" id="line-503"><code>		atomic.AddInt32(&amp;hc.pendingClientRequests, 1)</code></span>
<span class="codeline" id="line-504"><code>		defer atomic.AddInt32(&amp;hc.pendingClientRequests, -1)</code></span>
<span class="codeline" id="line-505"><code>	}</code></span>
<span class="codeline" id="line-506"><code>	c.mLock.RUnlock()</code></span>
<span class="codeline" id="line-507"><code>	if hc == nil {</code></span>
<span class="codeline" id="line-508"><code>		c.mLock.Lock()</code></span>
<span class="codeline" id="line-509"><code>		hc = m[string(host)]</code></span>
<span class="codeline" id="line-510"><code>		if hc == nil {</code></span>
<span class="codeline" id="line-511"><code>			hc = &amp;HostClient{</code></span>
<span class="codeline" id="line-512"><code>				Addr:                          AddMissingPort(string(host), isTLS),</code></span>
<span class="codeline" id="line-513"><code>				Name:                          c.Name,</code></span>
<span class="codeline" id="line-514"><code>				NoDefaultUserAgentHeader:      c.NoDefaultUserAgentHeader,</code></span>
<span class="codeline" id="line-515"><code>				Dial:                          c.Dial,</code></span>
<span class="codeline" id="line-516"><code>				DialTimeout:                   c.DialTimeout,</code></span>
<span class="codeline" id="line-517"><code>				DialDualStack:                 c.DialDualStack,</code></span>
<span class="codeline" id="line-518"><code>				IsTLS:                         isTLS,</code></span>
<span class="codeline" id="line-519"><code>				TLSConfig:                     c.TLSConfig,</code></span>
<span class="codeline" id="line-520"><code>				MaxConns:                      c.MaxConnsPerHost,</code></span>
<span class="codeline" id="line-521"><code>				MaxIdleConnDuration:           c.MaxIdleConnDuration,</code></span>
<span class="codeline" id="line-522"><code>				MaxConnDuration:               c.MaxConnDuration,</code></span>
<span class="codeline" id="line-523"><code>				MaxIdemponentCallAttempts:     c.MaxIdemponentCallAttempts,</code></span>
<span class="codeline" id="line-524"><code>				ReadBufferSize:                c.ReadBufferSize,</code></span>
<span class="codeline" id="line-525"><code>				WriteBufferSize:               c.WriteBufferSize,</code></span>
<span class="codeline" id="line-526"><code>				ReadTimeout:                   c.ReadTimeout,</code></span>
<span class="codeline" id="line-527"><code>				WriteTimeout:                  c.WriteTimeout,</code></span>
<span class="codeline" id="line-528"><code>				MaxResponseBodySize:           c.MaxResponseBodySize,</code></span>
<span class="codeline" id="line-529"><code>				DisableHeaderNamesNormalizing: c.DisableHeaderNamesNormalizing,</code></span>
<span class="codeline" id="line-530"><code>				DisablePathNormalizing:        c.DisablePathNormalizing,</code></span>
<span class="codeline" id="line-531"><code>				MaxConnWaitTimeout:            c.MaxConnWaitTimeout,</code></span>
<span class="codeline" id="line-532"><code>				RetryIf:                       c.RetryIf,</code></span>
<span class="codeline" id="line-533"><code>				ConnPoolStrategy:              c.ConnPoolStrategy,</code></span>
<span class="codeline" id="line-534"><code>				StreamResponseBody:            c.StreamResponseBody,</code></span>
<span class="codeline" id="line-535"><code>				clientReaderPool:              &amp;c.readerPool,</code></span>
<span class="codeline" id="line-536"><code>				clientWriterPool:              &amp;c.writerPool,</code></span>
<span class="codeline" id="line-537"><code>			}</code></span>
<span class="codeline" id="line-538"><code></code></span>
<span class="codeline" id="line-539"><code>			if c.ConfigureClient != nil {</code></span>
<span class="codeline" id="line-540"><code>				if err := c.ConfigureClient(hc); err != nil {</code></span>
<span class="codeline" id="line-541"><code>					c.mLock.Unlock()</code></span>
<span class="codeline" id="line-542"><code>					return err</code></span>
<span class="codeline" id="line-543"><code>				}</code></span>
<span class="codeline" id="line-544"><code>			}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>			m[string(host)] = hc</code></span>
<span class="codeline" id="line-547"><code>			if len(m) == 1 {</code></span>
<span class="codeline" id="line-548"><code>				startCleaner = true</code></span>
<span class="codeline" id="line-549"><code>			}</code></span>
<span class="codeline" id="line-550"><code>		}</code></span>
<span class="codeline" id="line-551"><code>		atomic.AddInt32(&amp;hc.pendingClientRequests, 1)</code></span>
<span class="codeline" id="line-552"><code>		defer atomic.AddInt32(&amp;hc.pendingClientRequests, -1)</code></span>
<span class="codeline" id="line-553"><code>		c.mLock.Unlock()</code></span>
<span class="codeline" id="line-554"><code>	}</code></span>
<span class="codeline" id="line-555"><code></code></span>
<span class="codeline" id="line-556"><code>	if startCleaner {</code></span>
<span class="codeline" id="line-557"><code>		go c.mCleaner(m)</code></span>
<span class="codeline" id="line-558"><code>	}</code></span>
<span class="codeline" id="line-559"><code></code></span>
<span class="codeline" id="line-560"><code>	return hc.Do(req, resp)</code></span>
<span class="codeline" id="line-561"><code>}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>// CloseIdleConnections closes any connections which were previously</code></span>
<span class="codeline" id="line-564"><code>// connected from previous requests but are now sitting idle in a</code></span>
<span class="codeline" id="line-565"><code>// "keep-alive" state. It does not interrupt any connections currently</code></span>
<span class="codeline" id="line-566"><code>// in use.</code></span>
<span class="codeline" id="line-567"><code>func (c *Client) CloseIdleConnections() {</code></span>
<span class="codeline" id="line-568"><code>	c.mLock.RLock()</code></span>
<span class="codeline" id="line-569"><code>	for _, v := range c.m {</code></span>
<span class="codeline" id="line-570"><code>		v.CloseIdleConnections()</code></span>
<span class="codeline" id="line-571"><code>	}</code></span>
<span class="codeline" id="line-572"><code>	for _, v := range c.ms {</code></span>
<span class="codeline" id="line-573"><code>		v.CloseIdleConnections()</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	c.mLock.RUnlock()</code></span>
<span class="codeline" id="line-576"><code>}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>func (c *Client) mCleaner(m map[string]*HostClient) {</code></span>
<span class="codeline" id="line-579"><code>	mustStop := false</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>	sleep := c.MaxIdleConnDuration</code></span>
<span class="codeline" id="line-582"><code>	if sleep &lt; time.Second {</code></span>
<span class="codeline" id="line-583"><code>		sleep = time.Second</code></span>
<span class="codeline" id="line-584"><code>	} else if sleep &gt; 10*time.Second {</code></span>
<span class="codeline" id="line-585"><code>		sleep = 10 * time.Second</code></span>
<span class="codeline" id="line-586"><code>	}</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>	for {</code></span>
<span class="codeline" id="line-589"><code>		time.Sleep(sleep)</code></span>
<span class="codeline" id="line-590"><code>		c.mLock.Lock()</code></span>
<span class="codeline" id="line-591"><code>		for k, v := range m {</code></span>
<span class="codeline" id="line-592"><code>			v.connsLock.Lock()</code></span>
<span class="codeline" id="line-593"><code>			/* #nosec G601 */</code></span>
<span class="codeline" id="line-594"><code>			if v.connsCount == 0 &amp;&amp; atomic.LoadInt32(&amp;v.pendingClientRequests) == 0 {</code></span>
<span class="codeline" id="line-595"><code>				delete(m, k)</code></span>
<span class="codeline" id="line-596"><code>			}</code></span>
<span class="codeline" id="line-597"><code>			v.connsLock.Unlock()</code></span>
<span class="codeline" id="line-598"><code>		}</code></span>
<span class="codeline" id="line-599"><code>		if len(m) == 0 {</code></span>
<span class="codeline" id="line-600"><code>			mustStop = true</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code>		c.mLock.Unlock()</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>		if mustStop {</code></span>
<span class="codeline" id="line-605"><code>			break</code></span>
<span class="codeline" id="line-606"><code>		}</code></span>
<span class="codeline" id="line-607"><code>	}</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>// DefaultMaxConnsPerHost is the maximum number of concurrent connections</code></span>
<span class="codeline" id="line-611"><code>// http client may establish per host by default (i.e. if</code></span>
<span class="codeline" id="line-612"><code>// Client.MaxConnsPerHost isn't set).</code></span>
<span class="codeline" id="line-613"><code>const DefaultMaxConnsPerHost = 512</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>// DefaultMaxIdleConnDuration is the default duration before idle keep-alive</code></span>
<span class="codeline" id="line-616"><code>// connection is closed.</code></span>
<span class="codeline" id="line-617"><code>const DefaultMaxIdleConnDuration = 10 * time.Second</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>// DefaultMaxIdemponentCallAttempts is the default idempotent calls attempts count.</code></span>
<span class="codeline" id="line-620"><code>const DefaultMaxIdemponentCallAttempts = 5</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>// DialFunc must establish connection to addr.</code></span>
<span class="codeline" id="line-623"><code>//</code></span>
<span class="codeline" id="line-624"><code>// There is no need in establishing TLS (SSL) connection for https.</code></span>
<span class="codeline" id="line-625"><code>// The client automatically converts connection to TLS</code></span>
<span class="codeline" id="line-626"><code>// if HostClient.IsTLS is set.</code></span>
<span class="codeline" id="line-627"><code>//</code></span>
<span class="codeline" id="line-628"><code>// TCP address passed to DialFunc always contains host and port.</code></span>
<span class="codeline" id="line-629"><code>// Example TCP addr values:</code></span>
<span class="codeline" id="line-630"><code>//</code></span>
<span class="codeline" id="line-631"><code>//   - foobar.com:80</code></span>
<span class="codeline" id="line-632"><code>//   - foobar.com:443</code></span>
<span class="codeline" id="line-633"><code>//   - foobar.com:8080</code></span>
<span class="codeline" id="line-634"><code>type DialFunc func(addr string) (net.Conn, error)</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>// DialFuncWithTimeout must establish connection to addr.</code></span>
<span class="codeline" id="line-637"><code>// Unlike DialFunc, it also accepts a timeout.</code></span>
<span class="codeline" id="line-638"><code>//</code></span>
<span class="codeline" id="line-639"><code>// There is no need in establishing TLS (SSL) connection for https.</code></span>
<span class="codeline" id="line-640"><code>// The client automatically converts connection to TLS</code></span>
<span class="codeline" id="line-641"><code>// if HostClient.IsTLS is set.</code></span>
<span class="codeline" id="line-642"><code>//</code></span>
<span class="codeline" id="line-643"><code>// TCP address passed to DialFuncWithTimeout always contains host and port.</code></span>
<span class="codeline" id="line-644"><code>// Example TCP addr values:</code></span>
<span class="codeline" id="line-645"><code>//</code></span>
<span class="codeline" id="line-646"><code>//   - foobar.com:80</code></span>
<span class="codeline" id="line-647"><code>//   - foobar.com:443</code></span>
<span class="codeline" id="line-648"><code>//   - foobar.com:8080</code></span>
<span class="codeline" id="line-649"><code>type DialFuncWithTimeout func(addr string, timeout time.Duration) (net.Conn, error)</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>// RetryIfFunc signature of retry if function.</code></span>
<span class="codeline" id="line-652"><code>//</code></span>
<span class="codeline" id="line-653"><code>// Request argument passed to RetryIfFunc, if there are any request errors.</code></span>
<span class="codeline" id="line-654"><code>type RetryIfFunc func(request *Request) bool</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>// RoundTripper wraps every request/response.</code></span>
<span class="codeline" id="line-657"><code>type RoundTripper interface {</code></span>
<span class="codeline" id="line-658"><code>	RoundTrip(hc *HostClient, req *Request, resp *Response) (retry bool, err error)</code></span>
<span class="codeline" id="line-659"><code>}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>// ConnPoolStrategyType define strategy of connection pool enqueue/dequeue.</code></span>
<span class="codeline" id="line-662"><code>type ConnPoolStrategyType int</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>const (</code></span>
<span class="codeline" id="line-665"><code>	FIFO ConnPoolStrategyType = iota</code></span>
<span class="codeline" id="line-666"><code>	LIFO</code></span>
<span class="codeline" id="line-667"><code>)</code></span>
<span class="codeline" id="line-668"><code></code></span>
<span class="codeline" id="line-669"><code>// HostClient balances http requests among hosts listed in Addr.</code></span>
<span class="codeline" id="line-670"><code>//</code></span>
<span class="codeline" id="line-671"><code>// HostClient may be used for balancing load among multiple upstream hosts.</code></span>
<span class="codeline" id="line-672"><code>// While multiple addresses passed to HostClient.Addr may be used for balancing</code></span>
<span class="codeline" id="line-673"><code>// load among them, it would be better using LBClient instead, since HostClient</code></span>
<span class="codeline" id="line-674"><code>// may unevenly balance load among upstream hosts.</code></span>
<span class="codeline" id="line-675"><code>//</code></span>
<span class="codeline" id="line-676"><code>// It is forbidden copying HostClient instances. Create new instances instead.</code></span>
<span class="codeline" id="line-677"><code>//</code></span>
<span class="codeline" id="line-678"><code>// It is safe calling HostClient methods from concurrently running goroutines.</code></span>
<span class="codeline" id="line-679"><code>type HostClient struct {</code></span>
<span class="codeline" id="line-680"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-681"><code></code></span>
<span class="codeline" id="line-682"><code>	// Comma-separated list of upstream HTTP server host addresses,</code></span>
<span class="codeline" id="line-683"><code>	// which are passed to Dial or DialTimeout in a round-robin manner.</code></span>
<span class="codeline" id="line-684"><code>	//</code></span>
<span class="codeline" id="line-685"><code>	// Each address may contain port if default dialer is used.</code></span>
<span class="codeline" id="line-686"><code>	// For example,</code></span>
<span class="codeline" id="line-687"><code>	//</code></span>
<span class="codeline" id="line-688"><code>	//    - foobar.com:80</code></span>
<span class="codeline" id="line-689"><code>	//    - foobar.com:443</code></span>
<span class="codeline" id="line-690"><code>	//    - foobar.com:8080</code></span>
<span class="codeline" id="line-691"><code>	Addr string</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>	// Client name. Used in User-Agent request header.</code></span>
<span class="codeline" id="line-694"><code>	Name string</code></span>
<span class="codeline" id="line-695"><code></code></span>
<span class="codeline" id="line-696"><code>	// NoDefaultUserAgentHeader when set to true, causes the default</code></span>
<span class="codeline" id="line-697"><code>	// User-Agent header to be excluded from the Request.</code></span>
<span class="codeline" id="line-698"><code>	NoDefaultUserAgentHeader bool</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>	// Callback for establishing new connections to hosts.</code></span>
<span class="codeline" id="line-701"><code>	//</code></span>
<span class="codeline" id="line-702"><code>	// Default DialTimeout is used if not set.</code></span>
<span class="codeline" id="line-703"><code>	DialTimeout DialFuncWithTimeout</code></span>
<span class="codeline" id="line-704"><code></code></span>
<span class="codeline" id="line-705"><code>	// Callback for establishing new connections to hosts.</code></span>
<span class="codeline" id="line-706"><code>	//</code></span>
<span class="codeline" id="line-707"><code>	// Note that if Dial is set instead of DialTimeout, Dial will ignore Request timeout.</code></span>
<span class="codeline" id="line-708"><code>	// If you want the tcp dial process to account for request timeouts, use DialTimeout instead.</code></span>
<span class="codeline" id="line-709"><code>	//</code></span>
<span class="codeline" id="line-710"><code>	// If not set, DialTimeout is used.</code></span>
<span class="codeline" id="line-711"><code>	Dial DialFunc</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>	// Attempt to connect to both ipv4 and ipv6 host addresses</code></span>
<span class="codeline" id="line-714"><code>	// if set to true.</code></span>
<span class="codeline" id="line-715"><code>	//</code></span>
<span class="codeline" id="line-716"><code>	// This option is used only if default TCP dialer is used,</code></span>
<span class="codeline" id="line-717"><code>	// i.e. if Dial and DialTimeout are blank.</code></span>
<span class="codeline" id="line-718"><code>	//</code></span>
<span class="codeline" id="line-719"><code>	// By default client connects only to ipv4 addresses,</code></span>
<span class="codeline" id="line-720"><code>	// since unfortunately ipv6 remains broken in many networks worldwide :)</code></span>
<span class="codeline" id="line-721"><code>	DialDualStack bool</code></span>
<span class="codeline" id="line-722"><code></code></span>
<span class="codeline" id="line-723"><code>	// Whether to use TLS (aka SSL or HTTPS) for host connections.</code></span>
<span class="codeline" id="line-724"><code>	IsTLS bool</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>	// Optional TLS config.</code></span>
<span class="codeline" id="line-727"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-728"><code></code></span>
<span class="codeline" id="line-729"><code>	// Maximum number of connections which may be established to all hosts</code></span>
<span class="codeline" id="line-730"><code>	// listed in Addr.</code></span>
<span class="codeline" id="line-731"><code>	//</code></span>
<span class="codeline" id="line-732"><code>	// You can change this value while the HostClient is being used</code></span>
<span class="codeline" id="line-733"><code>	// with HostClient.SetMaxConns(value)</code></span>
<span class="codeline" id="line-734"><code>	//</code></span>
<span class="codeline" id="line-735"><code>	// DefaultMaxConnsPerHost is used if not set.</code></span>
<span class="codeline" id="line-736"><code>	MaxConns int</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>	// Keep-alive connections are closed after this duration.</code></span>
<span class="codeline" id="line-739"><code>	//</code></span>
<span class="codeline" id="line-740"><code>	// By default connection duration is unlimited.</code></span>
<span class="codeline" id="line-741"><code>	MaxConnDuration time.Duration</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>	// Idle keep-alive connections are closed after this duration.</code></span>
<span class="codeline" id="line-744"><code>	//</code></span>
<span class="codeline" id="line-745"><code>	// By default idle connections are closed</code></span>
<span class="codeline" id="line-746"><code>	// after DefaultMaxIdleConnDuration.</code></span>
<span class="codeline" id="line-747"><code>	MaxIdleConnDuration time.Duration</code></span>
<span class="codeline" id="line-748"><code></code></span>
<span class="codeline" id="line-749"><code>	// Maximum number of attempts for idempotent calls.</code></span>
<span class="codeline" id="line-750"><code>	//</code></span>
<span class="codeline" id="line-751"><code>	// DefaultMaxIdemponentCallAttempts is used if not set.</code></span>
<span class="codeline" id="line-752"><code>	MaxIdemponentCallAttempts int</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>	// Per-connection buffer size for responses' reading.</code></span>
<span class="codeline" id="line-755"><code>	// This also limits the maximum header size.</code></span>
<span class="codeline" id="line-756"><code>	//</code></span>
<span class="codeline" id="line-757"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-758"><code>	ReadBufferSize int</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>	// Per-connection buffer size for requests' writing.</code></span>
<span class="codeline" id="line-761"><code>	//</code></span>
<span class="codeline" id="line-762"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-763"><code>	WriteBufferSize int</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	// Maximum duration for full response reading (including body).</code></span>
<span class="codeline" id="line-766"><code>	//</code></span>
<span class="codeline" id="line-767"><code>	// By default response read timeout is unlimited.</code></span>
<span class="codeline" id="line-768"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>	// Maximum duration for full request writing (including body).</code></span>
<span class="codeline" id="line-771"><code>	//</code></span>
<span class="codeline" id="line-772"><code>	// By default request write timeout is unlimited.</code></span>
<span class="codeline" id="line-773"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>	// Maximum response body size.</code></span>
<span class="codeline" id="line-776"><code>	//</code></span>
<span class="codeline" id="line-777"><code>	// The client returns ErrBodyTooLarge if this limit is greater than 0</code></span>
<span class="codeline" id="line-778"><code>	// and response body is greater than the limit.</code></span>
<span class="codeline" id="line-779"><code>	//</code></span>
<span class="codeline" id="line-780"><code>	// By default response body size is unlimited.</code></span>
<span class="codeline" id="line-781"><code>	MaxResponseBodySize int</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>	// Header names are passed as-is without normalization</code></span>
<span class="codeline" id="line-784"><code>	// if this option is set.</code></span>
<span class="codeline" id="line-785"><code>	//</code></span>
<span class="codeline" id="line-786"><code>	// Disabled header names' normalization may be useful only for proxying</code></span>
<span class="codeline" id="line-787"><code>	// responses to other clients expecting case-sensitive</code></span>
<span class="codeline" id="line-788"><code>	// header names. See https://github.com/valyala/fasthttp/issues/57</code></span>
<span class="codeline" id="line-789"><code>	// for details.</code></span>
<span class="codeline" id="line-790"><code>	//</code></span>
<span class="codeline" id="line-791"><code>	// By default request and response header names are normalized, i.e.</code></span>
<span class="codeline" id="line-792"><code>	// The first letter and the first letters following dashes</code></span>
<span class="codeline" id="line-793"><code>	// are uppercased, while all the other letters are lowercased.</code></span>
<span class="codeline" id="line-794"><code>	// Examples:</code></span>
<span class="codeline" id="line-795"><code>	//</code></span>
<span class="codeline" id="line-796"><code>	//     * HOST -&gt; Host</code></span>
<span class="codeline" id="line-797"><code>	//     * content-type -&gt; Content-Type</code></span>
<span class="codeline" id="line-798"><code>	//     * cONTENT-lenGTH -&gt; Content-Length</code></span>
<span class="codeline" id="line-799"><code>	DisableHeaderNamesNormalizing bool</code></span>
<span class="codeline" id="line-800"><code></code></span>
<span class="codeline" id="line-801"><code>	// Path values are sent as-is without normalization.</code></span>
<span class="codeline" id="line-802"><code>	//</code></span>
<span class="codeline" id="line-803"><code>	// Disabled path normalization may be useful for proxying incoming requests</code></span>
<span class="codeline" id="line-804"><code>	// to servers that are expecting paths to be forwarded as-is.</code></span>
<span class="codeline" id="line-805"><code>	//</code></span>
<span class="codeline" id="line-806"><code>	// By default path values are normalized, i.e.</code></span>
<span class="codeline" id="line-807"><code>	// extra slashes are removed, special characters are encoded.</code></span>
<span class="codeline" id="line-808"><code>	DisablePathNormalizing bool</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>	// Will not log potentially sensitive content in error logs.</code></span>
<span class="codeline" id="line-811"><code>	//</code></span>
<span class="codeline" id="line-812"><code>	// This option is useful for servers that handle sensitive data</code></span>
<span class="codeline" id="line-813"><code>	// in the request/response.</code></span>
<span class="codeline" id="line-814"><code>	//</code></span>
<span class="codeline" id="line-815"><code>	// Client logs full errors by default.</code></span>
<span class="codeline" id="line-816"><code>	SecureErrorLogMessage bool</code></span>
<span class="codeline" id="line-817"><code></code></span>
<span class="codeline" id="line-818"><code>	// Maximum duration for waiting for a free connection.</code></span>
<span class="codeline" id="line-819"><code>	//</code></span>
<span class="codeline" id="line-820"><code>	// By default will not waiting, return ErrNoFreeConns immediately</code></span>
<span class="codeline" id="line-821"><code>	MaxConnWaitTimeout time.Duration</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>	// RetryIf controls whether a retry should be attempted after an error.</code></span>
<span class="codeline" id="line-824"><code>	//</code></span>
<span class="codeline" id="line-825"><code>	// By default will use isIdempotent function</code></span>
<span class="codeline" id="line-826"><code>	RetryIf RetryIfFunc</code></span>
<span class="codeline" id="line-827"><code></code></span>
<span class="codeline" id="line-828"><code>	// Transport defines a transport-like mechanism that wraps every request/response.</code></span>
<span class="codeline" id="line-829"><code>	Transport RoundTripper</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>	// Connection pool strategy. Can be either LIFO or FIFO (default).</code></span>
<span class="codeline" id="line-832"><code>	ConnPoolStrategy ConnPoolStrategyType</code></span>
<span class="codeline" id="line-833"><code></code></span>
<span class="codeline" id="line-834"><code>	// StreamResponseBody enables response body streaming.</code></span>
<span class="codeline" id="line-835"><code>	StreamResponseBody bool</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>	lastUseTime uint32</code></span>
<span class="codeline" id="line-838"><code></code></span>
<span class="codeline" id="line-839"><code>	connsLock  sync.Mutex</code></span>
<span class="codeline" id="line-840"><code>	connsCount int</code></span>
<span class="codeline" id="line-841"><code>	conns      []*clientConn</code></span>
<span class="codeline" id="line-842"><code>	connsWait  *wantConnQueue</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>	addrsLock sync.Mutex</code></span>
<span class="codeline" id="line-845"><code>	addrs     []string</code></span>
<span class="codeline" id="line-846"><code>	addrIdx   uint32</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>	tlsConfigMap     map[string]*tls.Config</code></span>
<span class="codeline" id="line-849"><code>	tlsConfigMapLock sync.Mutex</code></span>
<span class="codeline" id="line-850"><code></code></span>
<span class="codeline" id="line-851"><code>	readerPool sync.Pool</code></span>
<span class="codeline" id="line-852"><code>	writerPool sync.Pool</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>	clientReaderPool *sync.Pool</code></span>
<span class="codeline" id="line-855"><code>	clientWriterPool *sync.Pool</code></span>
<span class="codeline" id="line-856"><code></code></span>
<span class="codeline" id="line-857"><code>	pendingRequests int32</code></span>
<span class="codeline" id="line-858"><code></code></span>
<span class="codeline" id="line-859"><code>	// pendingClientRequests counts the number of requests that a Client is currently running using this HostClient.</code></span>
<span class="codeline" id="line-860"><code>	// It will be incremented earlier than pendingRequests and will be used by Client to see if the HostClient is still in use.</code></span>
<span class="codeline" id="line-861"><code>	pendingClientRequests int32</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>	connsCleanerRun bool</code></span>
<span class="codeline" id="line-864"><code>}</code></span>
<span class="codeline" id="line-865"><code></code></span>
<span class="codeline" id="line-866"><code>type clientConn struct {</code></span>
<span class="codeline" id="line-867"><code>	c net.Conn</code></span>
<span class="codeline" id="line-868"><code></code></span>
<span class="codeline" id="line-869"><code>	createdTime time.Time</code></span>
<span class="codeline" id="line-870"><code>	lastUseTime time.Time</code></span>
<span class="codeline" id="line-871"><code>}</code></span>
<span class="codeline" id="line-872"><code></code></span>
<span class="codeline" id="line-873"><code>var startTimeUnix = time.Now().Unix()</code></span>
<span class="codeline" id="line-874"><code></code></span>
<span class="codeline" id="line-875"><code>// LastUseTime returns time the client was last used.</code></span>
<span class="codeline" id="line-876"><code>func (c *HostClient) LastUseTime() time.Time {</code></span>
<span class="codeline" id="line-877"><code>	n := atomic.LoadUint32(&amp;c.lastUseTime)</code></span>
<span class="codeline" id="line-878"><code>	return time.Unix(startTimeUnix+int64(n), 0)</code></span>
<span class="codeline" id="line-879"><code>}</code></span>
<span class="codeline" id="line-880"><code></code></span>
<span class="codeline" id="line-881"><code>// Get returns the status code and body of url.</code></span>
<span class="codeline" id="line-882"><code>//</code></span>
<span class="codeline" id="line-883"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-884"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-885"><code>//</code></span>
<span class="codeline" id="line-886"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-887"><code>func (c *HostClient) Get(dst []byte, url string) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-888"><code>	return clientGetURL(dst, url, c)</code></span>
<span class="codeline" id="line-889"><code>}</code></span>
<span class="codeline" id="line-890"><code></code></span>
<span class="codeline" id="line-891"><code>// GetTimeout returns the status code and body of url.</code></span>
<span class="codeline" id="line-892"><code>//</code></span>
<span class="codeline" id="line-893"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-894"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-895"><code>//</code></span>
<span class="codeline" id="line-896"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-897"><code>//</code></span>
<span class="codeline" id="line-898"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-899"><code>// during the given timeout.</code></span>
<span class="codeline" id="line-900"><code>func (c *HostClient) GetTimeout(dst []byte, url string, timeout time.Duration) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-901"><code>	return clientGetURLTimeout(dst, url, timeout, c)</code></span>
<span class="codeline" id="line-902"><code>}</code></span>
<span class="codeline" id="line-903"><code></code></span>
<span class="codeline" id="line-904"><code>// GetDeadline returns the status code and body of url.</code></span>
<span class="codeline" id="line-905"><code>//</code></span>
<span class="codeline" id="line-906"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-907"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-908"><code>//</code></span>
<span class="codeline" id="line-909"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-910"><code>//</code></span>
<span class="codeline" id="line-911"><code>// ErrTimeout error is returned if url contents couldn't be fetched</code></span>
<span class="codeline" id="line-912"><code>// until the given deadline.</code></span>
<span class="codeline" id="line-913"><code>func (c *HostClient) GetDeadline(dst []byte, url string, deadline time.Time) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-914"><code>	return clientGetURLDeadline(dst, url, deadline, c)</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
<span class="codeline" id="line-916"><code></code></span>
<span class="codeline" id="line-917"><code>// Post sends POST request to the given url with the given POST arguments.</code></span>
<span class="codeline" id="line-918"><code>//</code></span>
<span class="codeline" id="line-919"><code>// The contents of dst will be replaced by the body and returned, if the dst</code></span>
<span class="codeline" id="line-920"><code>// is too small a new slice will be allocated.</code></span>
<span class="codeline" id="line-921"><code>//</code></span>
<span class="codeline" id="line-922"><code>// The function follows redirects. Use Do* for manually handling redirects.</code></span>
<span class="codeline" id="line-923"><code>//</code></span>
<span class="codeline" id="line-924"><code>// Empty POST body is sent if postArgs is nil.</code></span>
<span class="codeline" id="line-925"><code>func (c *HostClient) Post(dst []byte, url string, postArgs *Args) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-926"><code>	return clientPostURL(dst, url, postArgs, c)</code></span>
<span class="codeline" id="line-927"><code>}</code></span>
<span class="codeline" id="line-928"><code></code></span>
<span class="codeline" id="line-929"><code>type clientDoer interface {</code></span>
<span class="codeline" id="line-930"><code>	Do(req *Request, resp *Response) error</code></span>
<span class="codeline" id="line-931"><code>}</code></span>
<span class="codeline" id="line-932"><code></code></span>
<span class="codeline" id="line-933"><code>func clientGetURL(dst []byte, url string, c clientDoer) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-934"><code>	req := AcquireRequest()</code></span>
<span class="codeline" id="line-935"><code></code></span>
<span class="codeline" id="line-936"><code>	statusCode, body, err = doRequestFollowRedirectsBuffer(req, dst, url, c)</code></span>
<span class="codeline" id="line-937"><code></code></span>
<span class="codeline" id="line-938"><code>	ReleaseRequest(req)</code></span>
<span class="codeline" id="line-939"><code>	return statusCode, body, err</code></span>
<span class="codeline" id="line-940"><code>}</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>func clientGetURLTimeout(dst []byte, url string, timeout time.Duration, c clientDoer) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-943"><code>	deadline := time.Now().Add(timeout)</code></span>
<span class="codeline" id="line-944"><code>	return clientGetURLDeadline(dst, url, deadline, c)</code></span>
<span class="codeline" id="line-945"><code>}</code></span>
<span class="codeline" id="line-946"><code></code></span>
<span class="codeline" id="line-947"><code>type clientURLResponse struct {</code></span>
<span class="codeline" id="line-948"><code>	statusCode int</code></span>
<span class="codeline" id="line-949"><code>	body       []byte</code></span>
<span class="codeline" id="line-950"><code>	err        error</code></span>
<span class="codeline" id="line-951"><code>}</code></span>
<span class="codeline" id="line-952"><code></code></span>
<span class="codeline" id="line-953"><code>func clientGetURLDeadline(dst []byte, url string, deadline time.Time, c clientDoer) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-954"><code>	timeout := time.Until(deadline)</code></span>
<span class="codeline" id="line-955"><code>	if timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-956"><code>		return 0, dst, ErrTimeout</code></span>
<span class="codeline" id="line-957"><code>	}</code></span>
<span class="codeline" id="line-958"><code></code></span>
<span class="codeline" id="line-959"><code>	var ch chan clientURLResponse</code></span>
<span class="codeline" id="line-960"><code>	chv := clientURLResponseChPool.Get()</code></span>
<span class="codeline" id="line-961"><code>	if chv == nil {</code></span>
<span class="codeline" id="line-962"><code>		chv = make(chan clientURLResponse, 1)</code></span>
<span class="codeline" id="line-963"><code>	}</code></span>
<span class="codeline" id="line-964"><code>	ch = chv.(chan clientURLResponse)</code></span>
<span class="codeline" id="line-965"><code></code></span>
<span class="codeline" id="line-966"><code>	// Note that the request continues execution on ErrTimeout until</code></span>
<span class="codeline" id="line-967"><code>	// client-specific ReadTimeout exceeds. This helps limiting load</code></span>
<span class="codeline" id="line-968"><code>	// on slow hosts by MaxConns* concurrent requests.</code></span>
<span class="codeline" id="line-969"><code>	//</code></span>
<span class="codeline" id="line-970"><code>	// Without this 'hack' the load on slow host could exceed MaxConns*</code></span>
<span class="codeline" id="line-971"><code>	// concurrent requests, since timed out requests on client side</code></span>
<span class="codeline" id="line-972"><code>	// usually continue execution on the host.</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>	var mu sync.Mutex</code></span>
<span class="codeline" id="line-975"><code>	var timedout, responded bool</code></span>
<span class="codeline" id="line-976"><code></code></span>
<span class="codeline" id="line-977"><code>	go func() {</code></span>
<span class="codeline" id="line-978"><code>		req := AcquireRequest()</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>		statusCodeCopy, bodyCopy, errCopy := doRequestFollowRedirectsBuffer(req, dst, url, c)</code></span>
<span class="codeline" id="line-981"><code>		mu.Lock()</code></span>
<span class="codeline" id="line-982"><code>		if !timedout {</code></span>
<span class="codeline" id="line-983"><code>			ch &lt;- clientURLResponse{</code></span>
<span class="codeline" id="line-984"><code>				statusCode: statusCodeCopy,</code></span>
<span class="codeline" id="line-985"><code>				body:       bodyCopy,</code></span>
<span class="codeline" id="line-986"><code>				err:        errCopy,</code></span>
<span class="codeline" id="line-987"><code>			}</code></span>
<span class="codeline" id="line-988"><code>			responded = true</code></span>
<span class="codeline" id="line-989"><code>		}</code></span>
<span class="codeline" id="line-990"><code>		mu.Unlock()</code></span>
<span class="codeline" id="line-991"><code></code></span>
<span class="codeline" id="line-992"><code>		ReleaseRequest(req)</code></span>
<span class="codeline" id="line-993"><code>	}()</code></span>
<span class="codeline" id="line-994"><code></code></span>
<span class="codeline" id="line-995"><code>	tc := AcquireTimer(timeout)</code></span>
<span class="codeline" id="line-996"><code>	select {</code></span>
<span class="codeline" id="line-997"><code>	case resp := &lt;-ch:</code></span>
<span class="codeline" id="line-998"><code>		statusCode = resp.statusCode</code></span>
<span class="codeline" id="line-999"><code>		body = resp.body</code></span>
<span class="codeline" id="line-1000"><code>		err = resp.err</code></span>
<span class="codeline" id="line-1001"><code>	case &lt;-tc.C:</code></span>
<span class="codeline" id="line-1002"><code>		mu.Lock()</code></span>
<span class="codeline" id="line-1003"><code>		if responded {</code></span>
<span class="codeline" id="line-1004"><code>			resp := &lt;-ch</code></span>
<span class="codeline" id="line-1005"><code>			statusCode = resp.statusCode</code></span>
<span class="codeline" id="line-1006"><code>			body = resp.body</code></span>
<span class="codeline" id="line-1007"><code>			err = resp.err</code></span>
<span class="codeline" id="line-1008"><code>		} else {</code></span>
<span class="codeline" id="line-1009"><code>			timedout = true</code></span>
<span class="codeline" id="line-1010"><code>			err = ErrTimeout</code></span>
<span class="codeline" id="line-1011"><code>			body = dst</code></span>
<span class="codeline" id="line-1012"><code>		}</code></span>
<span class="codeline" id="line-1013"><code>		mu.Unlock()</code></span>
<span class="codeline" id="line-1014"><code>	}</code></span>
<span class="codeline" id="line-1015"><code>	ReleaseTimer(tc)</code></span>
<span class="codeline" id="line-1016"><code></code></span>
<span class="codeline" id="line-1017"><code>	clientURLResponseChPool.Put(chv)</code></span>
<span class="codeline" id="line-1018"><code></code></span>
<span class="codeline" id="line-1019"><code>	return statusCode, body, err</code></span>
<span class="codeline" id="line-1020"><code>}</code></span>
<span class="codeline" id="line-1021"><code></code></span>
<span class="codeline" id="line-1022"><code>var clientURLResponseChPool sync.Pool</code></span>
<span class="codeline" id="line-1023"><code></code></span>
<span class="codeline" id="line-1024"><code>func clientPostURL(dst []byte, url string, postArgs *Args, c clientDoer) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-1025"><code>	req := AcquireRequest()</code></span>
<span class="codeline" id="line-1026"><code>	defer ReleaseRequest(req)</code></span>
<span class="codeline" id="line-1027"><code></code></span>
<span class="codeline" id="line-1028"><code>	req.Header.SetMethod(MethodPost)</code></span>
<span class="codeline" id="line-1029"><code>	req.Header.SetContentTypeBytes(strPostArgsContentType)</code></span>
<span class="codeline" id="line-1030"><code>	if postArgs != nil {</code></span>
<span class="codeline" id="line-1031"><code>		if _, err := postArgs.WriteTo(req.BodyWriter()); err != nil {</code></span>
<span class="codeline" id="line-1032"><code>			return 0, nil, err</code></span>
<span class="codeline" id="line-1033"><code>		}</code></span>
<span class="codeline" id="line-1034"><code>	}</code></span>
<span class="codeline" id="line-1035"><code></code></span>
<span class="codeline" id="line-1036"><code>	statusCode, body, err = doRequestFollowRedirectsBuffer(req, dst, url, c)</code></span>
<span class="codeline" id="line-1037"><code></code></span>
<span class="codeline" id="line-1038"><code>	return statusCode, body, err</code></span>
<span class="codeline" id="line-1039"><code>}</code></span>
<span class="codeline" id="line-1040"><code></code></span>
<span class="codeline" id="line-1041"><code>var (</code></span>
<span class="codeline" id="line-1042"><code>	// ErrMissingLocation is returned by clients when the Location header is missing on</code></span>
<span class="codeline" id="line-1043"><code>	// an HTTP response with a redirect status code.</code></span>
<span class="codeline" id="line-1044"><code>	ErrMissingLocation = errors.New("missing Location header for http redirect")</code></span>
<span class="codeline" id="line-1045"><code>	// ErrTooManyRedirects is returned by clients when the number of redirects followed</code></span>
<span class="codeline" id="line-1046"><code>	// exceed the max count.</code></span>
<span class="codeline" id="line-1047"><code>	ErrTooManyRedirects = errors.New("too many redirects detected when doing the request")</code></span>
<span class="codeline" id="line-1048"><code></code></span>
<span class="codeline" id="line-1049"><code>	// HostClients are only able to follow redirects to the same protocol.</code></span>
<span class="codeline" id="line-1050"><code>	ErrHostClientRedirectToDifferentScheme = errors.New("HostClient can't follow redirects to a different protocol," +</code></span>
<span class="codeline" id="line-1051"><code>		" please use Client instead")</code></span>
<span class="codeline" id="line-1052"><code>)</code></span>
<span class="codeline" id="line-1053"><code></code></span>
<span class="codeline" id="line-1054"><code>const defaultMaxRedirectsCount = 16</code></span>
<span class="codeline" id="line-1055"><code></code></span>
<span class="codeline" id="line-1056"><code>func doRequestFollowRedirectsBuffer(req *Request, dst []byte, url string, c clientDoer) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-1057"><code>	resp := AcquireResponse()</code></span>
<span class="codeline" id="line-1058"><code>	bodyBuf := resp.bodyBuffer()</code></span>
<span class="codeline" id="line-1059"><code>	resp.keepBodyBuffer = true</code></span>
<span class="codeline" id="line-1060"><code>	oldBody := bodyBuf.B</code></span>
<span class="codeline" id="line-1061"><code>	bodyBuf.B = dst</code></span>
<span class="codeline" id="line-1062"><code></code></span>
<span class="codeline" id="line-1063"><code>	statusCode, _, err = doRequestFollowRedirects(req, resp, url, defaultMaxRedirectsCount, c)</code></span>
<span class="codeline" id="line-1064"><code></code></span>
<span class="codeline" id="line-1065"><code>	body = bodyBuf.B</code></span>
<span class="codeline" id="line-1066"><code>	bodyBuf.B = oldBody</code></span>
<span class="codeline" id="line-1067"><code>	resp.keepBodyBuffer = false</code></span>
<span class="codeline" id="line-1068"><code>	ReleaseResponse(resp)</code></span>
<span class="codeline" id="line-1069"><code></code></span>
<span class="codeline" id="line-1070"><code>	return statusCode, body, err</code></span>
<span class="codeline" id="line-1071"><code>}</code></span>
<span class="codeline" id="line-1072"><code></code></span>
<span class="codeline" id="line-1073"><code>func doRequestFollowRedirects(</code></span>
<span class="codeline" id="line-1074"><code>	req *Request, resp *Response, url string, maxRedirectsCount int, c clientDoer,</code></span>
<span class="codeline" id="line-1075"><code>) (statusCode int, body []byte, err error) {</code></span>
<span class="codeline" id="line-1076"><code>	redirectsCount := 0</code></span>
<span class="codeline" id="line-1077"><code></code></span>
<span class="codeline" id="line-1078"><code>	for {</code></span>
<span class="codeline" id="line-1079"><code>		req.SetRequestURI(url)</code></span>
<span class="codeline" id="line-1080"><code>		if err := req.parseURI(); err != nil {</code></span>
<span class="codeline" id="line-1081"><code>			return 0, nil, err</code></span>
<span class="codeline" id="line-1082"><code>		}</code></span>
<span class="codeline" id="line-1083"><code></code></span>
<span class="codeline" id="line-1084"><code>		if err = c.Do(req, resp); err != nil {</code></span>
<span class="codeline" id="line-1085"><code>			break</code></span>
<span class="codeline" id="line-1086"><code>		}</code></span>
<span class="codeline" id="line-1087"><code>		statusCode = resp.Header.StatusCode()</code></span>
<span class="codeline" id="line-1088"><code>		if !StatusCodeIsRedirect(statusCode) {</code></span>
<span class="codeline" id="line-1089"><code>			break</code></span>
<span class="codeline" id="line-1090"><code>		}</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>		redirectsCount++</code></span>
<span class="codeline" id="line-1093"><code>		if redirectsCount &gt; maxRedirectsCount {</code></span>
<span class="codeline" id="line-1094"><code>			err = ErrTooManyRedirects</code></span>
<span class="codeline" id="line-1095"><code>			break</code></span>
<span class="codeline" id="line-1096"><code>		}</code></span>
<span class="codeline" id="line-1097"><code>		location := resp.Header.peek(strLocation)</code></span>
<span class="codeline" id="line-1098"><code>		if len(location) == 0 {</code></span>
<span class="codeline" id="line-1099"><code>			err = ErrMissingLocation</code></span>
<span class="codeline" id="line-1100"><code>			break</code></span>
<span class="codeline" id="line-1101"><code>		}</code></span>
<span class="codeline" id="line-1102"><code>		url = getRedirectURL(url, location, req.DisableRedirectPathNormalizing)</code></span>
<span class="codeline" id="line-1103"><code>	}</code></span>
<span class="codeline" id="line-1104"><code></code></span>
<span class="codeline" id="line-1105"><code>	return statusCode, body, err</code></span>
<span class="codeline" id="line-1106"><code>}</code></span>
<span class="codeline" id="line-1107"><code></code></span>
<span class="codeline" id="line-1108"><code>func getRedirectURL(baseURL string, location []byte, disablePathNormalizing bool) string {</code></span>
<span class="codeline" id="line-1109"><code>	u := AcquireURI()</code></span>
<span class="codeline" id="line-1110"><code>	u.Update(baseURL)</code></span>
<span class="codeline" id="line-1111"><code>	u.UpdateBytes(location)</code></span>
<span class="codeline" id="line-1112"><code>	u.DisablePathNormalizing = disablePathNormalizing</code></span>
<span class="codeline" id="line-1113"><code>	redirectURL := u.String()</code></span>
<span class="codeline" id="line-1114"><code>	ReleaseURI(u)</code></span>
<span class="codeline" id="line-1115"><code>	return redirectURL</code></span>
<span class="codeline" id="line-1116"><code>}</code></span>
<span class="codeline" id="line-1117"><code></code></span>
<span class="codeline" id="line-1118"><code>// StatusCodeIsRedirect returns true if the status code indicates a redirect.</code></span>
<span class="codeline" id="line-1119"><code>func StatusCodeIsRedirect(statusCode int) bool {</code></span>
<span class="codeline" id="line-1120"><code>	return statusCode == StatusMovedPermanently ||</code></span>
<span class="codeline" id="line-1121"><code>		statusCode == StatusFound ||</code></span>
<span class="codeline" id="line-1122"><code>		statusCode == StatusSeeOther ||</code></span>
<span class="codeline" id="line-1123"><code>		statusCode == StatusTemporaryRedirect ||</code></span>
<span class="codeline" id="line-1124"><code>		statusCode == StatusPermanentRedirect</code></span>
<span class="codeline" id="line-1125"><code>}</code></span>
<span class="codeline" id="line-1126"><code></code></span>
<span class="codeline" id="line-1127"><code>var (</code></span>
<span class="codeline" id="line-1128"><code>	requestPool  sync.Pool</code></span>
<span class="codeline" id="line-1129"><code>	responsePool sync.Pool</code></span>
<span class="codeline" id="line-1130"><code>)</code></span>
<span class="codeline" id="line-1131"><code></code></span>
<span class="codeline" id="line-1132"><code>// AcquireRequest returns an empty Request instance from request pool.</code></span>
<span class="codeline" id="line-1133"><code>//</code></span>
<span class="codeline" id="line-1134"><code>// The returned Request instance may be passed to ReleaseRequest when it is</code></span>
<span class="codeline" id="line-1135"><code>// no longer needed. This allows Request recycling, reduces GC pressure</code></span>
<span class="codeline" id="line-1136"><code>// and usually improves performance.</code></span>
<span class="codeline" id="line-1137"><code>func AcquireRequest() *Request {</code></span>
<span class="codeline" id="line-1138"><code>	v := requestPool.Get()</code></span>
<span class="codeline" id="line-1139"><code>	if v == nil {</code></span>
<span class="codeline" id="line-1140"><code>		return &amp;Request{}</code></span>
<span class="codeline" id="line-1141"><code>	}</code></span>
<span class="codeline" id="line-1142"><code>	return v.(*Request)</code></span>
<span class="codeline" id="line-1143"><code>}</code></span>
<span class="codeline" id="line-1144"><code></code></span>
<span class="codeline" id="line-1145"><code>// ReleaseRequest returns req acquired via AcquireRequest to request pool.</code></span>
<span class="codeline" id="line-1146"><code>//</code></span>
<span class="codeline" id="line-1147"><code>// It is forbidden accessing req and/or its' members after returning</code></span>
<span class="codeline" id="line-1148"><code>// it to request pool.</code></span>
<span class="codeline" id="line-1149"><code>func ReleaseRequest(req *Request) {</code></span>
<span class="codeline" id="line-1150"><code>	req.Reset()</code></span>
<span class="codeline" id="line-1151"><code>	requestPool.Put(req)</code></span>
<span class="codeline" id="line-1152"><code>}</code></span>
<span class="codeline" id="line-1153"><code></code></span>
<span class="codeline" id="line-1154"><code>// AcquireResponse returns an empty Response instance from response pool.</code></span>
<span class="codeline" id="line-1155"><code>//</code></span>
<span class="codeline" id="line-1156"><code>// The returned Response instance may be passed to ReleaseResponse when it is</code></span>
<span class="codeline" id="line-1157"><code>// no longer needed. This allows Response recycling, reduces GC pressure</code></span>
<span class="codeline" id="line-1158"><code>// and usually improves performance.</code></span>
<span class="codeline" id="line-1159"><code>func AcquireResponse() *Response {</code></span>
<span class="codeline" id="line-1160"><code>	v := responsePool.Get()</code></span>
<span class="codeline" id="line-1161"><code>	if v == nil {</code></span>
<span class="codeline" id="line-1162"><code>		return &amp;Response{}</code></span>
<span class="codeline" id="line-1163"><code>	}</code></span>
<span class="codeline" id="line-1164"><code>	return v.(*Response)</code></span>
<span class="codeline" id="line-1165"><code>}</code></span>
<span class="codeline" id="line-1166"><code></code></span>
<span class="codeline" id="line-1167"><code>// ReleaseResponse return resp acquired via AcquireResponse to response pool.</code></span>
<span class="codeline" id="line-1168"><code>//</code></span>
<span class="codeline" id="line-1169"><code>// It is forbidden accessing resp and/or its' members after returning</code></span>
<span class="codeline" id="line-1170"><code>// it to response pool.</code></span>
<span class="codeline" id="line-1171"><code>func ReleaseResponse(resp *Response) {</code></span>
<span class="codeline" id="line-1172"><code>	resp.Reset()</code></span>
<span class="codeline" id="line-1173"><code>	responsePool.Put(resp)</code></span>
<span class="codeline" id="line-1174"><code>}</code></span>
<span class="codeline" id="line-1175"><code></code></span>
<span class="codeline" id="line-1176"><code>// DoTimeout performs the given request and waits for response during</code></span>
<span class="codeline" id="line-1177"><code>// the given timeout duration.</code></span>
<span class="codeline" id="line-1178"><code>//</code></span>
<span class="codeline" id="line-1179"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-1180"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-1181"><code>//</code></span>
<span class="codeline" id="line-1182"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-1183"><code>//</code></span>
<span class="codeline" id="line-1184"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-1185"><code>//</code></span>
<span class="codeline" id="line-1186"><code>// ErrTimeout is returned if the response wasn't returned during</code></span>
<span class="codeline" id="line-1187"><code>// the given timeout.</code></span>
<span class="codeline" id="line-1188"><code>// Immediately returns ErrTimeout if timeout value is negative.</code></span>
<span class="codeline" id="line-1189"><code>//</code></span>
<span class="codeline" id="line-1190"><code>// ErrNoFreeConns is returned if all HostClient.MaxConns connections</code></span>
<span class="codeline" id="line-1191"><code>// to the host are busy.</code></span>
<span class="codeline" id="line-1192"><code>//</code></span>
<span class="codeline" id="line-1193"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-1194"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-1195"><code>func (c *HostClient) DoTimeout(req *Request, resp *Response, timeout time.Duration) error {</code></span>
<span class="codeline" id="line-1196"><code>	req.timeout = timeout</code></span>
<span class="codeline" id="line-1197"><code>	if req.timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1198"><code>		return ErrTimeout</code></span>
<span class="codeline" id="line-1199"><code>	}</code></span>
<span class="codeline" id="line-1200"><code>	return c.Do(req, resp)</code></span>
<span class="codeline" id="line-1201"><code>}</code></span>
<span class="codeline" id="line-1202"><code></code></span>
<span class="codeline" id="line-1203"><code>// DoDeadline performs the given request and waits for response until</code></span>
<span class="codeline" id="line-1204"><code>// the given deadline.</code></span>
<span class="codeline" id="line-1205"><code>//</code></span>
<span class="codeline" id="line-1206"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-1207"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-1208"><code>//</code></span>
<span class="codeline" id="line-1209"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-1210"><code>//</code></span>
<span class="codeline" id="line-1211"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-1212"><code>//</code></span>
<span class="codeline" id="line-1213"><code>// ErrTimeout is returned if the response wasn't returned until</code></span>
<span class="codeline" id="line-1214"><code>// the given deadline.</code></span>
<span class="codeline" id="line-1215"><code>// Immediately returns ErrTimeout if the deadline has already been reached.</code></span>
<span class="codeline" id="line-1216"><code>//</code></span>
<span class="codeline" id="line-1217"><code>// ErrNoFreeConns is returned if all HostClient.MaxConns connections</code></span>
<span class="codeline" id="line-1218"><code>// to the host are busy.</code></span>
<span class="codeline" id="line-1219"><code>//</code></span>
<span class="codeline" id="line-1220"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-1221"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-1222"><code>func (c *HostClient) DoDeadline(req *Request, resp *Response, deadline time.Time) error {</code></span>
<span class="codeline" id="line-1223"><code>	req.timeout = time.Until(deadline)</code></span>
<span class="codeline" id="line-1224"><code>	if req.timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1225"><code>		return ErrTimeout</code></span>
<span class="codeline" id="line-1226"><code>	}</code></span>
<span class="codeline" id="line-1227"><code>	return c.Do(req, resp)</code></span>
<span class="codeline" id="line-1228"><code>}</code></span>
<span class="codeline" id="line-1229"><code></code></span>
<span class="codeline" id="line-1230"><code>// DoRedirects performs the given http request and fills the given http response,</code></span>
<span class="codeline" id="line-1231"><code>// following up to maxRedirectsCount redirects. When the redirect count exceeds</code></span>
<span class="codeline" id="line-1232"><code>// maxRedirectsCount, ErrTooManyRedirects is returned.</code></span>
<span class="codeline" id="line-1233"><code>//</code></span>
<span class="codeline" id="line-1234"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-1235"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-1236"><code>//</code></span>
<span class="codeline" id="line-1237"><code>// Client determines the server to be requested in the following order:</code></span>
<span class="codeline" id="line-1238"><code>//</code></span>
<span class="codeline" id="line-1239"><code>//   - from RequestURI if it contains full url with scheme and host;</code></span>
<span class="codeline" id="line-1240"><code>//   - from Host header otherwise.</code></span>
<span class="codeline" id="line-1241"><code>//</code></span>
<span class="codeline" id="line-1242"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-1243"><code>//</code></span>
<span class="codeline" id="line-1244"><code>// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections</code></span>
<span class="codeline" id="line-1245"><code>// to the requested host are busy.</code></span>
<span class="codeline" id="line-1246"><code>//</code></span>
<span class="codeline" id="line-1247"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-1248"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-1249"><code>func (c *HostClient) DoRedirects(req *Request, resp *Response, maxRedirectsCount int) error {</code></span>
<span class="codeline" id="line-1250"><code>	_, _, err := doRequestFollowRedirects(req, resp, req.URI().String(), maxRedirectsCount, c)</code></span>
<span class="codeline" id="line-1251"><code>	return err</code></span>
<span class="codeline" id="line-1252"><code>}</code></span>
<span class="codeline" id="line-1253"><code></code></span>
<span class="codeline" id="line-1254"><code>// Do performs the given http request and sets the corresponding response.</code></span>
<span class="codeline" id="line-1255"><code>//</code></span>
<span class="codeline" id="line-1256"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-1257"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-1258"><code>//</code></span>
<span class="codeline" id="line-1259"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-1260"><code>//</code></span>
<span class="codeline" id="line-1261"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-1262"><code>//</code></span>
<span class="codeline" id="line-1263"><code>// ErrNoFreeConns is returned if all HostClient.MaxConns connections</code></span>
<span class="codeline" id="line-1264"><code>// to the host are busy.</code></span>
<span class="codeline" id="line-1265"><code>//</code></span>
<span class="codeline" id="line-1266"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-1267"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-1268"><code>func (c *HostClient) Do(req *Request, resp *Response) error {</code></span>
<span class="codeline" id="line-1269"><code>	var err error</code></span>
<span class="codeline" id="line-1270"><code>	var retry bool</code></span>
<span class="codeline" id="line-1271"><code>	maxAttempts := c.MaxIdemponentCallAttempts</code></span>
<span class="codeline" id="line-1272"><code>	if maxAttempts &lt;= 0 {</code></span>
<span class="codeline" id="line-1273"><code>		maxAttempts = DefaultMaxIdemponentCallAttempts</code></span>
<span class="codeline" id="line-1274"><code>	}</code></span>
<span class="codeline" id="line-1275"><code>	isRequestRetryable := isIdempotent</code></span>
<span class="codeline" id="line-1276"><code>	if c.RetryIf != nil {</code></span>
<span class="codeline" id="line-1277"><code>		isRequestRetryable = c.RetryIf</code></span>
<span class="codeline" id="line-1278"><code>	}</code></span>
<span class="codeline" id="line-1279"><code>	attempts := 0</code></span>
<span class="codeline" id="line-1280"><code>	hasBodyStream := req.IsBodyStream()</code></span>
<span class="codeline" id="line-1281"><code></code></span>
<span class="codeline" id="line-1282"><code>	// If a request has a timeout we store the timeout</code></span>
<span class="codeline" id="line-1283"><code>	// and calculate a deadline so we can keep updating the</code></span>
<span class="codeline" id="line-1284"><code>	// timeout on each retry.</code></span>
<span class="codeline" id="line-1285"><code>	deadline := time.Time{}</code></span>
<span class="codeline" id="line-1286"><code>	timeout := req.timeout</code></span>
<span class="codeline" id="line-1287"><code>	if timeout &gt; 0 {</code></span>
<span class="codeline" id="line-1288"><code>		deadline = time.Now().Add(timeout)</code></span>
<span class="codeline" id="line-1289"><code>	}</code></span>
<span class="codeline" id="line-1290"><code></code></span>
<span class="codeline" id="line-1291"><code>	atomic.AddInt32(&amp;c.pendingRequests, 1)</code></span>
<span class="codeline" id="line-1292"><code>	for {</code></span>
<span class="codeline" id="line-1293"><code>		// If the original timeout was set, we need to update</code></span>
<span class="codeline" id="line-1294"><code>		// the one set on the request to reflect the remaining time.</code></span>
<span class="codeline" id="line-1295"><code>		if timeout &gt; 0 {</code></span>
<span class="codeline" id="line-1296"><code>			req.timeout = time.Until(deadline)</code></span>
<span class="codeline" id="line-1297"><code>			if req.timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1298"><code>				err = ErrTimeout</code></span>
<span class="codeline" id="line-1299"><code>				break</code></span>
<span class="codeline" id="line-1300"><code>			}</code></span>
<span class="codeline" id="line-1301"><code>		}</code></span>
<span class="codeline" id="line-1302"><code></code></span>
<span class="codeline" id="line-1303"><code>		retry, err = c.do(req, resp)</code></span>
<span class="codeline" id="line-1304"><code>		if err == nil || !retry {</code></span>
<span class="codeline" id="line-1305"><code>			break</code></span>
<span class="codeline" id="line-1306"><code>		}</code></span>
<span class="codeline" id="line-1307"><code></code></span>
<span class="codeline" id="line-1308"><code>		if hasBodyStream {</code></span>
<span class="codeline" id="line-1309"><code>			break</code></span>
<span class="codeline" id="line-1310"><code>		}</code></span>
<span class="codeline" id="line-1311"><code>		if !isRequestRetryable(req) {</code></span>
<span class="codeline" id="line-1312"><code>			// Retry non-idempotent requests if the server closes</code></span>
<span class="codeline" id="line-1313"><code>			// the connection before sending the response.</code></span>
<span class="codeline" id="line-1314"><code>			//</code></span>
<span class="codeline" id="line-1315"><code>			// This case is possible if the server closes the idle</code></span>
<span class="codeline" id="line-1316"><code>			// keep-alive connection on timeout.</code></span>
<span class="codeline" id="line-1317"><code>			//</code></span>
<span class="codeline" id="line-1318"><code>			// Apache and nginx usually do this.</code></span>
<span class="codeline" id="line-1319"><code>			if err != io.EOF {</code></span>
<span class="codeline" id="line-1320"><code>				break</code></span>
<span class="codeline" id="line-1321"><code>			}</code></span>
<span class="codeline" id="line-1322"><code>		}</code></span>
<span class="codeline" id="line-1323"><code>		attempts++</code></span>
<span class="codeline" id="line-1324"><code>		if attempts &gt;= maxAttempts {</code></span>
<span class="codeline" id="line-1325"><code>			break</code></span>
<span class="codeline" id="line-1326"><code>		}</code></span>
<span class="codeline" id="line-1327"><code>	}</code></span>
<span class="codeline" id="line-1328"><code>	atomic.AddInt32(&amp;c.pendingRequests, -1)</code></span>
<span class="codeline" id="line-1329"><code></code></span>
<span class="codeline" id="line-1330"><code>	// Restore the original timeout.</code></span>
<span class="codeline" id="line-1331"><code>	req.timeout = timeout</code></span>
<span class="codeline" id="line-1332"><code></code></span>
<span class="codeline" id="line-1333"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-1334"><code>		err = ErrConnectionClosed</code></span>
<span class="codeline" id="line-1335"><code>	}</code></span>
<span class="codeline" id="line-1336"><code>	return err</code></span>
<span class="codeline" id="line-1337"><code>}</code></span>
<span class="codeline" id="line-1338"><code></code></span>
<span class="codeline" id="line-1339"><code>// PendingRequests returns the current number of requests the client</code></span>
<span class="codeline" id="line-1340"><code>// is executing.</code></span>
<span class="codeline" id="line-1341"><code>//</code></span>
<span class="codeline" id="line-1342"><code>// This function may be used for balancing load among multiple HostClient</code></span>
<span class="codeline" id="line-1343"><code>// instances.</code></span>
<span class="codeline" id="line-1344"><code>func (c *HostClient) PendingRequests() int {</code></span>
<span class="codeline" id="line-1345"><code>	return int(atomic.LoadInt32(&amp;c.pendingRequests))</code></span>
<span class="codeline" id="line-1346"><code>}</code></span>
<span class="codeline" id="line-1347"><code></code></span>
<span class="codeline" id="line-1348"><code>func isIdempotent(req *Request) bool {</code></span>
<span class="codeline" id="line-1349"><code>	return req.Header.IsGet() || req.Header.IsHead() || req.Header.IsPut()</code></span>
<span class="codeline" id="line-1350"><code>}</code></span>
<span class="codeline" id="line-1351"><code></code></span>
<span class="codeline" id="line-1352"><code>func (c *HostClient) do(req *Request, resp *Response) (bool, error) {</code></span>
<span class="codeline" id="line-1353"><code>	if resp == nil {</code></span>
<span class="codeline" id="line-1354"><code>		resp = AcquireResponse()</code></span>
<span class="codeline" id="line-1355"><code>		defer ReleaseResponse(resp)</code></span>
<span class="codeline" id="line-1356"><code>	}</code></span>
<span class="codeline" id="line-1357"><code></code></span>
<span class="codeline" id="line-1358"><code>	ok, err := c.doNonNilReqResp(req, resp)</code></span>
<span class="codeline" id="line-1359"><code></code></span>
<span class="codeline" id="line-1360"><code>	return ok, err</code></span>
<span class="codeline" id="line-1361"><code>}</code></span>
<span class="codeline" id="line-1362"><code></code></span>
<span class="codeline" id="line-1363"><code>func (c *HostClient) doNonNilReqResp(req *Request, resp *Response) (bool, error) {</code></span>
<span class="codeline" id="line-1364"><code>	if req == nil {</code></span>
<span class="codeline" id="line-1365"><code>		// for debugging purposes</code></span>
<span class="codeline" id="line-1366"><code>		panic("BUG: req cannot be nil")</code></span>
<span class="codeline" id="line-1367"><code>	}</code></span>
<span class="codeline" id="line-1368"><code>	if resp == nil {</code></span>
<span class="codeline" id="line-1369"><code>		// for debugging purposes</code></span>
<span class="codeline" id="line-1370"><code>		panic("BUG: resp cannot be nil")</code></span>
<span class="codeline" id="line-1371"><code>	}</code></span>
<span class="codeline" id="line-1372"><code></code></span>
<span class="codeline" id="line-1373"><code>	// Secure header error logs configuration</code></span>
<span class="codeline" id="line-1374"><code>	resp.secureErrorLogMessage = c.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-1375"><code>	resp.Header.secureErrorLogMessage = c.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-1376"><code>	req.secureErrorLogMessage = c.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-1377"><code>	req.Header.secureErrorLogMessage = c.SecureErrorLogMessage</code></span>
<span class="codeline" id="line-1378"><code></code></span>
<span class="codeline" id="line-1379"><code>	if c.IsTLS != req.URI().isHTTPS() {</code></span>
<span class="codeline" id="line-1380"><code>		return false, ErrHostClientRedirectToDifferentScheme</code></span>
<span class="codeline" id="line-1381"><code>	}</code></span>
<span class="codeline" id="line-1382"><code></code></span>
<span class="codeline" id="line-1383"><code>	atomic.StoreUint32(&amp;c.lastUseTime, uint32(time.Now().Unix()-startTimeUnix))</code></span>
<span class="codeline" id="line-1384"><code></code></span>
<span class="codeline" id="line-1385"><code>	// Free up resources occupied by response before sending the request,</code></span>
<span class="codeline" id="line-1386"><code>	// so the GC may reclaim these resources (e.g. response body).</code></span>
<span class="codeline" id="line-1387"><code></code></span>
<span class="codeline" id="line-1388"><code>	// backing up SkipBody in case it was set explicitly</code></span>
<span class="codeline" id="line-1389"><code>	customSkipBody := resp.SkipBody</code></span>
<span class="codeline" id="line-1390"><code>	customStreamBody := resp.StreamBody || c.StreamResponseBody</code></span>
<span class="codeline" id="line-1391"><code>	resp.Reset()</code></span>
<span class="codeline" id="line-1392"><code>	resp.SkipBody = customSkipBody</code></span>
<span class="codeline" id="line-1393"><code>	resp.StreamBody = customStreamBody</code></span>
<span class="codeline" id="line-1394"><code></code></span>
<span class="codeline" id="line-1395"><code>	req.URI().DisablePathNormalizing = c.DisablePathNormalizing</code></span>
<span class="codeline" id="line-1396"><code></code></span>
<span class="codeline" id="line-1397"><code>	userAgentOld := req.Header.UserAgent()</code></span>
<span class="codeline" id="line-1398"><code>	if len(userAgentOld) == 0 {</code></span>
<span class="codeline" id="line-1399"><code>		userAgent := c.Name</code></span>
<span class="codeline" id="line-1400"><code>		if userAgent == "" &amp;&amp; !c.NoDefaultUserAgentHeader {</code></span>
<span class="codeline" id="line-1401"><code>			userAgent = defaultUserAgent</code></span>
<span class="codeline" id="line-1402"><code>		}</code></span>
<span class="codeline" id="line-1403"><code>		if userAgent != "" {</code></span>
<span class="codeline" id="line-1404"><code>			req.Header.userAgent = append(req.Header.userAgent[:0], userAgent...)</code></span>
<span class="codeline" id="line-1405"><code>		}</code></span>
<span class="codeline" id="line-1406"><code>	}</code></span>
<span class="codeline" id="line-1407"><code></code></span>
<span class="codeline" id="line-1408"><code>	return c.transport().RoundTrip(c, req, resp)</code></span>
<span class="codeline" id="line-1409"><code>}</code></span>
<span class="codeline" id="line-1410"><code></code></span>
<span class="codeline" id="line-1411"><code>func (c *HostClient) transport() RoundTripper {</code></span>
<span class="codeline" id="line-1412"><code>	if c.Transport == nil {</code></span>
<span class="codeline" id="line-1413"><code>		return DefaultTransport</code></span>
<span class="codeline" id="line-1414"><code>	}</code></span>
<span class="codeline" id="line-1415"><code>	return c.Transport</code></span>
<span class="codeline" id="line-1416"><code>}</code></span>
<span class="codeline" id="line-1417"><code></code></span>
<span class="codeline" id="line-1418"><code>var (</code></span>
<span class="codeline" id="line-1419"><code>	// ErrNoFreeConns is returned when no free connections available</code></span>
<span class="codeline" id="line-1420"><code>	// to the given host.</code></span>
<span class="codeline" id="line-1421"><code>	//</code></span>
<span class="codeline" id="line-1422"><code>	// Increase the allowed number of connections per host if you</code></span>
<span class="codeline" id="line-1423"><code>	// see this error.</code></span>
<span class="codeline" id="line-1424"><code>	ErrNoFreeConns = errors.New("no free connections available to host")</code></span>
<span class="codeline" id="line-1425"><code></code></span>
<span class="codeline" id="line-1426"><code>	// ErrConnectionClosed may be returned from client methods if the server</code></span>
<span class="codeline" id="line-1427"><code>	// closes connection before returning the first response byte.</code></span>
<span class="codeline" id="line-1428"><code>	//</code></span>
<span class="codeline" id="line-1429"><code>	// If you see this error, then either fix the server by returning</code></span>
<span class="codeline" id="line-1430"><code>	// 'Connection: close' response header before closing the connection</code></span>
<span class="codeline" id="line-1431"><code>	// or add 'Connection: close' request header before sending requests</code></span>
<span class="codeline" id="line-1432"><code>	// to broken server.</code></span>
<span class="codeline" id="line-1433"><code>	ErrConnectionClosed = errors.New("the server closed connection before returning the first response byte. " +</code></span>
<span class="codeline" id="line-1434"><code>		"Make sure the server returns 'Connection: close' response header before closing the connection")</code></span>
<span class="codeline" id="line-1435"><code></code></span>
<span class="codeline" id="line-1436"><code>	// ErrConnPoolStrategyNotImpl is returned when HostClient.ConnPoolStrategy is not implement yet.</code></span>
<span class="codeline" id="line-1437"><code>	// If you see this error, then you need to check your HostClient configuration.</code></span>
<span class="codeline" id="line-1438"><code>	ErrConnPoolStrategyNotImpl = errors.New("connection pool strategy is not implement")</code></span>
<span class="codeline" id="line-1439"><code>)</code></span>
<span class="codeline" id="line-1440"><code></code></span>
<span class="codeline" id="line-1441"><code>type timeoutError struct{}</code></span>
<span class="codeline" id="line-1442"><code></code></span>
<span class="codeline" id="line-1443"><code>func (e *timeoutError) Error() string {</code></span>
<span class="codeline" id="line-1444"><code>	return "timeout"</code></span>
<span class="codeline" id="line-1445"><code>}</code></span>
<span class="codeline" id="line-1446"><code></code></span>
<span class="codeline" id="line-1447"><code>// Only implement the Timeout() function of the net.Error interface.</code></span>
<span class="codeline" id="line-1448"><code>// This allows for checks like:</code></span>
<span class="codeline" id="line-1449"><code>//</code></span>
<span class="codeline" id="line-1450"><code>//	if x, ok := err.(interface{ Timeout() bool }); ok &amp;&amp; x.Timeout() {</code></span>
<span class="codeline" id="line-1451"><code>func (e *timeoutError) Timeout() bool {</code></span>
<span class="codeline" id="line-1452"><code>	return true</code></span>
<span class="codeline" id="line-1453"><code>}</code></span>
<span class="codeline" id="line-1454"><code></code></span>
<span class="codeline" id="line-1455"><code>// ErrTimeout is returned from timed out calls.</code></span>
<span class="codeline" id="line-1456"><code>var ErrTimeout = &amp;timeoutError{}</code></span>
<span class="codeline" id="line-1457"><code></code></span>
<span class="codeline" id="line-1458"><code>// SetMaxConns sets up the maximum number of connections which may be established to all hosts listed in Addr.</code></span>
<span class="codeline" id="line-1459"><code>func (c *HostClient) SetMaxConns(newMaxConns int) {</code></span>
<span class="codeline" id="line-1460"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1461"><code>	c.MaxConns = newMaxConns</code></span>
<span class="codeline" id="line-1462"><code>	c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1463"><code>}</code></span>
<span class="codeline" id="line-1464"><code></code></span>
<span class="codeline" id="line-1465"><code>func (c *HostClient) acquireConn(reqTimeout time.Duration, connectionClose bool) (cc *clientConn, err error) {</code></span>
<span class="codeline" id="line-1466"><code>	createConn := false</code></span>
<span class="codeline" id="line-1467"><code>	startCleaner := false</code></span>
<span class="codeline" id="line-1468"><code></code></span>
<span class="codeline" id="line-1469"><code>	var n int</code></span>
<span class="codeline" id="line-1470"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1471"><code>	n = len(c.conns)</code></span>
<span class="codeline" id="line-1472"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1473"><code>		maxConns := c.MaxConns</code></span>
<span class="codeline" id="line-1474"><code>		if maxConns &lt;= 0 {</code></span>
<span class="codeline" id="line-1475"><code>			maxConns = DefaultMaxConnsPerHost</code></span>
<span class="codeline" id="line-1476"><code>		}</code></span>
<span class="codeline" id="line-1477"><code>		if c.connsCount &lt; maxConns {</code></span>
<span class="codeline" id="line-1478"><code>			c.connsCount++</code></span>
<span class="codeline" id="line-1479"><code>			createConn = true</code></span>
<span class="codeline" id="line-1480"><code>			if !c.connsCleanerRun &amp;&amp; !connectionClose {</code></span>
<span class="codeline" id="line-1481"><code>				startCleaner = true</code></span>
<span class="codeline" id="line-1482"><code>				c.connsCleanerRun = true</code></span>
<span class="codeline" id="line-1483"><code>			}</code></span>
<span class="codeline" id="line-1484"><code>		}</code></span>
<span class="codeline" id="line-1485"><code>	} else {</code></span>
<span class="codeline" id="line-1486"><code>		switch c.ConnPoolStrategy {</code></span>
<span class="codeline" id="line-1487"><code>		case LIFO:</code></span>
<span class="codeline" id="line-1488"><code>			n--</code></span>
<span class="codeline" id="line-1489"><code>			cc = c.conns[n]</code></span>
<span class="codeline" id="line-1490"><code>			c.conns[n] = nil</code></span>
<span class="codeline" id="line-1491"><code>			c.conns = c.conns[:n]</code></span>
<span class="codeline" id="line-1492"><code>		case FIFO:</code></span>
<span class="codeline" id="line-1493"><code>			cc = c.conns[0]</code></span>
<span class="codeline" id="line-1494"><code>			copy(c.conns, c.conns[1:])</code></span>
<span class="codeline" id="line-1495"><code>			c.conns[n-1] = nil</code></span>
<span class="codeline" id="line-1496"><code>			c.conns = c.conns[:n-1]</code></span>
<span class="codeline" id="line-1497"><code>		default:</code></span>
<span class="codeline" id="line-1498"><code>			c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1499"><code>			return nil, ErrConnPoolStrategyNotImpl</code></span>
<span class="codeline" id="line-1500"><code>		}</code></span>
<span class="codeline" id="line-1501"><code>	}</code></span>
<span class="codeline" id="line-1502"><code>	c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1503"><code></code></span>
<span class="codeline" id="line-1504"><code>	if cc != nil {</code></span>
<span class="codeline" id="line-1505"><code>		return cc, nil</code></span>
<span class="codeline" id="line-1506"><code>	}</code></span>
<span class="codeline" id="line-1507"><code>	if !createConn {</code></span>
<span class="codeline" id="line-1508"><code>		if c.MaxConnWaitTimeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1509"><code>			return nil, ErrNoFreeConns</code></span>
<span class="codeline" id="line-1510"><code>		}</code></span>
<span class="codeline" id="line-1511"><code></code></span>
<span class="codeline" id="line-1512"><code>		//nolint:dupword</code></span>
<span class="codeline" id="line-1513"><code>		// reqTimeout    c.MaxConnWaitTimeout   wait duration</code></span>
<span class="codeline" id="line-1514"><code>		//     d1                 d2            min(d1, d2)</code></span>
<span class="codeline" id="line-1515"><code>		//  0(not set)            d2            d2</code></span>
<span class="codeline" id="line-1516"><code>		//     d1            0(don't wait)      0(don't wait)</code></span>
<span class="codeline" id="line-1517"><code>		//  0(not set)            d2            d2</code></span>
<span class="codeline" id="line-1518"><code>		timeout := c.MaxConnWaitTimeout</code></span>
<span class="codeline" id="line-1519"><code>		timeoutOverridden := false</code></span>
<span class="codeline" id="line-1520"><code>		// reqTimeout == 0 means not set</code></span>
<span class="codeline" id="line-1521"><code>		if reqTimeout &gt; 0 &amp;&amp; reqTimeout &lt; timeout {</code></span>
<span class="codeline" id="line-1522"><code>			timeout = reqTimeout</code></span>
<span class="codeline" id="line-1523"><code>			timeoutOverridden = true</code></span>
<span class="codeline" id="line-1524"><code>		}</code></span>
<span class="codeline" id="line-1525"><code></code></span>
<span class="codeline" id="line-1526"><code>		// wait for a free connection</code></span>
<span class="codeline" id="line-1527"><code>		tc := AcquireTimer(timeout)</code></span>
<span class="codeline" id="line-1528"><code>		defer ReleaseTimer(tc)</code></span>
<span class="codeline" id="line-1529"><code></code></span>
<span class="codeline" id="line-1530"><code>		w := &amp;wantConn{</code></span>
<span class="codeline" id="line-1531"><code>			ready: make(chan struct{}, 1),</code></span>
<span class="codeline" id="line-1532"><code>		}</code></span>
<span class="codeline" id="line-1533"><code>		defer func() {</code></span>
<span class="codeline" id="line-1534"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1535"><code>				w.cancel(c, err)</code></span>
<span class="codeline" id="line-1536"><code>			}</code></span>
<span class="codeline" id="line-1537"><code>		}()</code></span>
<span class="codeline" id="line-1538"><code></code></span>
<span class="codeline" id="line-1539"><code>		c.queueForIdle(w)</code></span>
<span class="codeline" id="line-1540"><code></code></span>
<span class="codeline" id="line-1541"><code>		select {</code></span>
<span class="codeline" id="line-1542"><code>		case &lt;-w.ready:</code></span>
<span class="codeline" id="line-1543"><code>			return w.conn, w.err</code></span>
<span class="codeline" id="line-1544"><code>		case &lt;-tc.C:</code></span>
<span class="codeline" id="line-1545"><code>			if timeoutOverridden {</code></span>
<span class="codeline" id="line-1546"><code>				return nil, ErrTimeout</code></span>
<span class="codeline" id="line-1547"><code>			}</code></span>
<span class="codeline" id="line-1548"><code>			return nil, ErrNoFreeConns</code></span>
<span class="codeline" id="line-1549"><code>		}</code></span>
<span class="codeline" id="line-1550"><code>	}</code></span>
<span class="codeline" id="line-1551"><code></code></span>
<span class="codeline" id="line-1552"><code>	if startCleaner {</code></span>
<span class="codeline" id="line-1553"><code>		go c.connsCleaner()</code></span>
<span class="codeline" id="line-1554"><code>	}</code></span>
<span class="codeline" id="line-1555"><code></code></span>
<span class="codeline" id="line-1556"><code>	conn, err := c.dialHostHard(reqTimeout)</code></span>
<span class="codeline" id="line-1557"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1558"><code>		c.decConnsCount()</code></span>
<span class="codeline" id="line-1559"><code>		return nil, err</code></span>
<span class="codeline" id="line-1560"><code>	}</code></span>
<span class="codeline" id="line-1561"><code>	cc = acquireClientConn(conn)</code></span>
<span class="codeline" id="line-1562"><code></code></span>
<span class="codeline" id="line-1563"><code>	return cc, nil</code></span>
<span class="codeline" id="line-1564"><code>}</code></span>
<span class="codeline" id="line-1565"><code></code></span>
<span class="codeline" id="line-1566"><code>func (c *HostClient) queueForIdle(w *wantConn) {</code></span>
<span class="codeline" id="line-1567"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1568"><code>	defer c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1569"><code>	if c.connsWait == nil {</code></span>
<span class="codeline" id="line-1570"><code>		c.connsWait = &amp;wantConnQueue{}</code></span>
<span class="codeline" id="line-1571"><code>	}</code></span>
<span class="codeline" id="line-1572"><code>	c.connsWait.clearFront()</code></span>
<span class="codeline" id="line-1573"><code>	c.connsWait.pushBack(w)</code></span>
<span class="codeline" id="line-1574"><code>}</code></span>
<span class="codeline" id="line-1575"><code></code></span>
<span class="codeline" id="line-1576"><code>func (c *HostClient) dialConnFor(w *wantConn) {</code></span>
<span class="codeline" id="line-1577"><code>	conn, err := c.dialHostHard(0)</code></span>
<span class="codeline" id="line-1578"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1579"><code>		w.tryDeliver(nil, err)</code></span>
<span class="codeline" id="line-1580"><code>		c.decConnsCount()</code></span>
<span class="codeline" id="line-1581"><code>		return</code></span>
<span class="codeline" id="line-1582"><code>	}</code></span>
<span class="codeline" id="line-1583"><code></code></span>
<span class="codeline" id="line-1584"><code>	cc := acquireClientConn(conn)</code></span>
<span class="codeline" id="line-1585"><code>	if !w.tryDeliver(cc, nil) {</code></span>
<span class="codeline" id="line-1586"><code>		// not delivered, return idle connection</code></span>
<span class="codeline" id="line-1587"><code>		c.releaseConn(cc)</code></span>
<span class="codeline" id="line-1588"><code>	}</code></span>
<span class="codeline" id="line-1589"><code>}</code></span>
<span class="codeline" id="line-1590"><code></code></span>
<span class="codeline" id="line-1591"><code>// CloseIdleConnections closes any connections which were previously</code></span>
<span class="codeline" id="line-1592"><code>// connected from previous requests but are now sitting idle in a</code></span>
<span class="codeline" id="line-1593"><code>// "keep-alive" state. It does not interrupt any connections currently</code></span>
<span class="codeline" id="line-1594"><code>// in use.</code></span>
<span class="codeline" id="line-1595"><code>func (c *HostClient) CloseIdleConnections() {</code></span>
<span class="codeline" id="line-1596"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1597"><code>	scratch := append([]*clientConn{}, c.conns...)</code></span>
<span class="codeline" id="line-1598"><code>	for i := range c.conns {</code></span>
<span class="codeline" id="line-1599"><code>		c.conns[i] = nil</code></span>
<span class="codeline" id="line-1600"><code>	}</code></span>
<span class="codeline" id="line-1601"><code>	c.conns = c.conns[:0]</code></span>
<span class="codeline" id="line-1602"><code>	c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1603"><code></code></span>
<span class="codeline" id="line-1604"><code>	for _, cc := range scratch {</code></span>
<span class="codeline" id="line-1605"><code>		c.closeConn(cc)</code></span>
<span class="codeline" id="line-1606"><code>	}</code></span>
<span class="codeline" id="line-1607"><code>}</code></span>
<span class="codeline" id="line-1608"><code></code></span>
<span class="codeline" id="line-1609"><code>func (c *HostClient) connsCleaner() {</code></span>
<span class="codeline" id="line-1610"><code>	var (</code></span>
<span class="codeline" id="line-1611"><code>		scratch             []*clientConn</code></span>
<span class="codeline" id="line-1612"><code>		maxIdleConnDuration = c.MaxIdleConnDuration</code></span>
<span class="codeline" id="line-1613"><code>	)</code></span>
<span class="codeline" id="line-1614"><code>	if maxIdleConnDuration &lt;= 0 {</code></span>
<span class="codeline" id="line-1615"><code>		maxIdleConnDuration = DefaultMaxIdleConnDuration</code></span>
<span class="codeline" id="line-1616"><code>	}</code></span>
<span class="codeline" id="line-1617"><code>	for {</code></span>
<span class="codeline" id="line-1618"><code>		currentTime := time.Now()</code></span>
<span class="codeline" id="line-1619"><code></code></span>
<span class="codeline" id="line-1620"><code>		// Determine idle connections to be closed.</code></span>
<span class="codeline" id="line-1621"><code>		c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1622"><code>		conns := c.conns</code></span>
<span class="codeline" id="line-1623"><code>		n := len(conns)</code></span>
<span class="codeline" id="line-1624"><code>		i := 0</code></span>
<span class="codeline" id="line-1625"><code>		for i &lt; n &amp;&amp; currentTime.Sub(conns[i].lastUseTime) &gt; maxIdleConnDuration {</code></span>
<span class="codeline" id="line-1626"><code>			i++</code></span>
<span class="codeline" id="line-1627"><code>		}</code></span>
<span class="codeline" id="line-1628"><code>		sleepFor := maxIdleConnDuration</code></span>
<span class="codeline" id="line-1629"><code>		if i &lt; n {</code></span>
<span class="codeline" id="line-1630"><code>			// + 1 so we actually sleep past the expiration time and not up to it.</code></span>
<span class="codeline" id="line-1631"><code>			// Otherwise the &gt; check above would still fail.</code></span>
<span class="codeline" id="line-1632"><code>			sleepFor = maxIdleConnDuration - currentTime.Sub(conns[i].lastUseTime) + 1</code></span>
<span class="codeline" id="line-1633"><code>		}</code></span>
<span class="codeline" id="line-1634"><code>		scratch = append(scratch[:0], conns[:i]...)</code></span>
<span class="codeline" id="line-1635"><code>		if i &gt; 0 {</code></span>
<span class="codeline" id="line-1636"><code>			m := copy(conns, conns[i:])</code></span>
<span class="codeline" id="line-1637"><code>			for i = m; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-1638"><code>				conns[i] = nil</code></span>
<span class="codeline" id="line-1639"><code>			}</code></span>
<span class="codeline" id="line-1640"><code>			c.conns = conns[:m]</code></span>
<span class="codeline" id="line-1641"><code>		}</code></span>
<span class="codeline" id="line-1642"><code>		c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1643"><code></code></span>
<span class="codeline" id="line-1644"><code>		// Close idle connections.</code></span>
<span class="codeline" id="line-1645"><code>		for i, cc := range scratch {</code></span>
<span class="codeline" id="line-1646"><code>			c.closeConn(cc)</code></span>
<span class="codeline" id="line-1647"><code>			scratch[i] = nil</code></span>
<span class="codeline" id="line-1648"><code>		}</code></span>
<span class="codeline" id="line-1649"><code></code></span>
<span class="codeline" id="line-1650"><code>		// Determine whether to stop the connsCleaner.</code></span>
<span class="codeline" id="line-1651"><code>		c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1652"><code>		mustStop := c.connsCount == 0</code></span>
<span class="codeline" id="line-1653"><code>		if mustStop {</code></span>
<span class="codeline" id="line-1654"><code>			c.connsCleanerRun = false</code></span>
<span class="codeline" id="line-1655"><code>		}</code></span>
<span class="codeline" id="line-1656"><code>		c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1657"><code>		if mustStop {</code></span>
<span class="codeline" id="line-1658"><code>			break</code></span>
<span class="codeline" id="line-1659"><code>		}</code></span>
<span class="codeline" id="line-1660"><code></code></span>
<span class="codeline" id="line-1661"><code>		time.Sleep(sleepFor)</code></span>
<span class="codeline" id="line-1662"><code>	}</code></span>
<span class="codeline" id="line-1663"><code>}</code></span>
<span class="codeline" id="line-1664"><code></code></span>
<span class="codeline" id="line-1665"><code>func (c *HostClient) closeConn(cc *clientConn) {</code></span>
<span class="codeline" id="line-1666"><code>	c.decConnsCount()</code></span>
<span class="codeline" id="line-1667"><code>	cc.c.Close()</code></span>
<span class="codeline" id="line-1668"><code>	releaseClientConn(cc)</code></span>
<span class="codeline" id="line-1669"><code>}</code></span>
<span class="codeline" id="line-1670"><code></code></span>
<span class="codeline" id="line-1671"><code>func (c *HostClient) decConnsCount() {</code></span>
<span class="codeline" id="line-1672"><code>	if c.MaxConnWaitTimeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1673"><code>		c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1674"><code>		c.connsCount--</code></span>
<span class="codeline" id="line-1675"><code>		c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1676"><code>		return</code></span>
<span class="codeline" id="line-1677"><code>	}</code></span>
<span class="codeline" id="line-1678"><code></code></span>
<span class="codeline" id="line-1679"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1680"><code>	defer c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1681"><code>	dialed := false</code></span>
<span class="codeline" id="line-1682"><code>	if q := c.connsWait; q != nil &amp;&amp; q.len() &gt; 0 {</code></span>
<span class="codeline" id="line-1683"><code>		for q.len() &gt; 0 {</code></span>
<span class="codeline" id="line-1684"><code>			w := q.popFront()</code></span>
<span class="codeline" id="line-1685"><code>			if w.waiting() {</code></span>
<span class="codeline" id="line-1686"><code>				go c.dialConnFor(w)</code></span>
<span class="codeline" id="line-1687"><code>				dialed = true</code></span>
<span class="codeline" id="line-1688"><code>				break</code></span>
<span class="codeline" id="line-1689"><code>			}</code></span>
<span class="codeline" id="line-1690"><code>		}</code></span>
<span class="codeline" id="line-1691"><code>	}</code></span>
<span class="codeline" id="line-1692"><code>	if !dialed {</code></span>
<span class="codeline" id="line-1693"><code>		c.connsCount--</code></span>
<span class="codeline" id="line-1694"><code>	}</code></span>
<span class="codeline" id="line-1695"><code>}</code></span>
<span class="codeline" id="line-1696"><code></code></span>
<span class="codeline" id="line-1697"><code>// ConnsCount returns connection count of HostClient.</code></span>
<span class="codeline" id="line-1698"><code>func (c *HostClient) ConnsCount() int {</code></span>
<span class="codeline" id="line-1699"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1700"><code>	defer c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1701"><code></code></span>
<span class="codeline" id="line-1702"><code>	return c.connsCount</code></span>
<span class="codeline" id="line-1703"><code>}</code></span>
<span class="codeline" id="line-1704"><code></code></span>
<span class="codeline" id="line-1705"><code>func acquireClientConn(conn net.Conn) *clientConn {</code></span>
<span class="codeline" id="line-1706"><code>	v := clientConnPool.Get()</code></span>
<span class="codeline" id="line-1707"><code>	if v == nil {</code></span>
<span class="codeline" id="line-1708"><code>		v = &amp;clientConn{}</code></span>
<span class="codeline" id="line-1709"><code>	}</code></span>
<span class="codeline" id="line-1710"><code>	cc := v.(*clientConn)</code></span>
<span class="codeline" id="line-1711"><code>	cc.c = conn</code></span>
<span class="codeline" id="line-1712"><code>	cc.createdTime = time.Now()</code></span>
<span class="codeline" id="line-1713"><code>	return cc</code></span>
<span class="codeline" id="line-1714"><code>}</code></span>
<span class="codeline" id="line-1715"><code></code></span>
<span class="codeline" id="line-1716"><code>func releaseClientConn(cc *clientConn) {</code></span>
<span class="codeline" id="line-1717"><code>	// Reset all fields.</code></span>
<span class="codeline" id="line-1718"><code>	*cc = clientConn{}</code></span>
<span class="codeline" id="line-1719"><code>	clientConnPool.Put(cc)</code></span>
<span class="codeline" id="line-1720"><code>}</code></span>
<span class="codeline" id="line-1721"><code></code></span>
<span class="codeline" id="line-1722"><code>var clientConnPool sync.Pool</code></span>
<span class="codeline" id="line-1723"><code></code></span>
<span class="codeline" id="line-1724"><code>func (c *HostClient) releaseConn(cc *clientConn) {</code></span>
<span class="codeline" id="line-1725"><code>	cc.lastUseTime = time.Now()</code></span>
<span class="codeline" id="line-1726"><code>	if c.MaxConnWaitTimeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1727"><code>		c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1728"><code>		c.conns = append(c.conns, cc)</code></span>
<span class="codeline" id="line-1729"><code>		c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1730"><code>		return</code></span>
<span class="codeline" id="line-1731"><code>	}</code></span>
<span class="codeline" id="line-1732"><code></code></span>
<span class="codeline" id="line-1733"><code>	// try to deliver an idle connection to a *wantConn</code></span>
<span class="codeline" id="line-1734"><code>	c.connsLock.Lock()</code></span>
<span class="codeline" id="line-1735"><code>	defer c.connsLock.Unlock()</code></span>
<span class="codeline" id="line-1736"><code>	delivered := false</code></span>
<span class="codeline" id="line-1737"><code>	if q := c.connsWait; q != nil &amp;&amp; q.len() &gt; 0 {</code></span>
<span class="codeline" id="line-1738"><code>		for q.len() &gt; 0 {</code></span>
<span class="codeline" id="line-1739"><code>			w := q.popFront()</code></span>
<span class="codeline" id="line-1740"><code>			if w.waiting() {</code></span>
<span class="codeline" id="line-1741"><code>				delivered = w.tryDeliver(cc, nil)</code></span>
<span class="codeline" id="line-1742"><code>				break</code></span>
<span class="codeline" id="line-1743"><code>			}</code></span>
<span class="codeline" id="line-1744"><code>		}</code></span>
<span class="codeline" id="line-1745"><code>	}</code></span>
<span class="codeline" id="line-1746"><code>	if !delivered {</code></span>
<span class="codeline" id="line-1747"><code>		c.conns = append(c.conns, cc)</code></span>
<span class="codeline" id="line-1748"><code>	}</code></span>
<span class="codeline" id="line-1749"><code>}</code></span>
<span class="codeline" id="line-1750"><code></code></span>
<span class="codeline" id="line-1751"><code>func (c *HostClient) acquireWriter(conn net.Conn) *bufio.Writer {</code></span>
<span class="codeline" id="line-1752"><code>	var v any</code></span>
<span class="codeline" id="line-1753"><code>	if c.clientWriterPool != nil {</code></span>
<span class="codeline" id="line-1754"><code>		v = c.clientWriterPool.Get()</code></span>
<span class="codeline" id="line-1755"><code>		if v == nil {</code></span>
<span class="codeline" id="line-1756"><code>			n := c.WriteBufferSize</code></span>
<span class="codeline" id="line-1757"><code>			if n &lt;= 0 {</code></span>
<span class="codeline" id="line-1758"><code>				n = defaultWriteBufferSize</code></span>
<span class="codeline" id="line-1759"><code>			}</code></span>
<span class="codeline" id="line-1760"><code>			return bufio.NewWriterSize(conn, n)</code></span>
<span class="codeline" id="line-1761"><code>		}</code></span>
<span class="codeline" id="line-1762"><code>	} else {</code></span>
<span class="codeline" id="line-1763"><code>		v = c.writerPool.Get()</code></span>
<span class="codeline" id="line-1764"><code>		if v == nil {</code></span>
<span class="codeline" id="line-1765"><code>			n := c.WriteBufferSize</code></span>
<span class="codeline" id="line-1766"><code>			if n &lt;= 0 {</code></span>
<span class="codeline" id="line-1767"><code>				n = defaultWriteBufferSize</code></span>
<span class="codeline" id="line-1768"><code>			}</code></span>
<span class="codeline" id="line-1769"><code>			return bufio.NewWriterSize(conn, n)</code></span>
<span class="codeline" id="line-1770"><code>		}</code></span>
<span class="codeline" id="line-1771"><code>	}</code></span>
<span class="codeline" id="line-1772"><code></code></span>
<span class="codeline" id="line-1773"><code>	bw := v.(*bufio.Writer)</code></span>
<span class="codeline" id="line-1774"><code>	bw.Reset(conn)</code></span>
<span class="codeline" id="line-1775"><code>	return bw</code></span>
<span class="codeline" id="line-1776"><code>}</code></span>
<span class="codeline" id="line-1777"><code></code></span>
<span class="codeline" id="line-1778"><code>func (c *HostClient) releaseWriter(bw *bufio.Writer) {</code></span>
<span class="codeline" id="line-1779"><code>	if c.clientWriterPool != nil {</code></span>
<span class="codeline" id="line-1780"><code>		c.clientWriterPool.Put(bw)</code></span>
<span class="codeline" id="line-1781"><code>	} else {</code></span>
<span class="codeline" id="line-1782"><code>		c.writerPool.Put(bw)</code></span>
<span class="codeline" id="line-1783"><code>	}</code></span>
<span class="codeline" id="line-1784"><code>}</code></span>
<span class="codeline" id="line-1785"><code></code></span>
<span class="codeline" id="line-1786"><code>func (c *HostClient) acquireReader(conn net.Conn) *bufio.Reader {</code></span>
<span class="codeline" id="line-1787"><code>	var v any</code></span>
<span class="codeline" id="line-1788"><code>	if c.clientReaderPool != nil {</code></span>
<span class="codeline" id="line-1789"><code>		v = c.clientReaderPool.Get()</code></span>
<span class="codeline" id="line-1790"><code>		if v == nil {</code></span>
<span class="codeline" id="line-1791"><code>			n := c.ReadBufferSize</code></span>
<span class="codeline" id="line-1792"><code>			if n &lt;= 0 {</code></span>
<span class="codeline" id="line-1793"><code>				n = defaultReadBufferSize</code></span>
<span class="codeline" id="line-1794"><code>			}</code></span>
<span class="codeline" id="line-1795"><code>			return bufio.NewReaderSize(conn, n)</code></span>
<span class="codeline" id="line-1796"><code>		}</code></span>
<span class="codeline" id="line-1797"><code>	} else {</code></span>
<span class="codeline" id="line-1798"><code>		v = c.readerPool.Get()</code></span>
<span class="codeline" id="line-1799"><code>		if v == nil {</code></span>
<span class="codeline" id="line-1800"><code>			n := c.ReadBufferSize</code></span>
<span class="codeline" id="line-1801"><code>			if n &lt;= 0 {</code></span>
<span class="codeline" id="line-1802"><code>				n = defaultReadBufferSize</code></span>
<span class="codeline" id="line-1803"><code>			}</code></span>
<span class="codeline" id="line-1804"><code>			return bufio.NewReaderSize(conn, n)</code></span>
<span class="codeline" id="line-1805"><code>		}</code></span>
<span class="codeline" id="line-1806"><code>	}</code></span>
<span class="codeline" id="line-1807"><code></code></span>
<span class="codeline" id="line-1808"><code>	br := v.(*bufio.Reader)</code></span>
<span class="codeline" id="line-1809"><code>	br.Reset(conn)</code></span>
<span class="codeline" id="line-1810"><code>	return br</code></span>
<span class="codeline" id="line-1811"><code>}</code></span>
<span class="codeline" id="line-1812"><code></code></span>
<span class="codeline" id="line-1813"><code>func (c *HostClient) releaseReader(br *bufio.Reader) {</code></span>
<span class="codeline" id="line-1814"><code>	if c.clientReaderPool != nil {</code></span>
<span class="codeline" id="line-1815"><code>		c.clientReaderPool.Put(br)</code></span>
<span class="codeline" id="line-1816"><code>	} else {</code></span>
<span class="codeline" id="line-1817"><code>		c.readerPool.Put(br)</code></span>
<span class="codeline" id="line-1818"><code>	}</code></span>
<span class="codeline" id="line-1819"><code>}</code></span>
<span class="codeline" id="line-1820"><code></code></span>
<span class="codeline" id="line-1821"><code>func newClientTLSConfig(c *tls.Config, addr string) *tls.Config {</code></span>
<span class="codeline" id="line-1822"><code>	if c == nil {</code></span>
<span class="codeline" id="line-1823"><code>		c = &amp;tls.Config{}</code></span>
<span class="codeline" id="line-1824"><code>	} else {</code></span>
<span class="codeline" id="line-1825"><code>		c = c.Clone()</code></span>
<span class="codeline" id="line-1826"><code>	}</code></span>
<span class="codeline" id="line-1827"><code></code></span>
<span class="codeline" id="line-1828"><code>	if c.ServerName == "" {</code></span>
<span class="codeline" id="line-1829"><code>		serverName := tlsServerName(addr)</code></span>
<span class="codeline" id="line-1830"><code>		if serverName == "*" {</code></span>
<span class="codeline" id="line-1831"><code>			c.InsecureSkipVerify = true</code></span>
<span class="codeline" id="line-1832"><code>		} else {</code></span>
<span class="codeline" id="line-1833"><code>			c.ServerName = serverName</code></span>
<span class="codeline" id="line-1834"><code>		}</code></span>
<span class="codeline" id="line-1835"><code>	}</code></span>
<span class="codeline" id="line-1836"><code>	return c</code></span>
<span class="codeline" id="line-1837"><code>}</code></span>
<span class="codeline" id="line-1838"><code></code></span>
<span class="codeline" id="line-1839"><code>func tlsServerName(addr string) string {</code></span>
<span class="codeline" id="line-1840"><code>	if !strings.Contains(addr, ":") {</code></span>
<span class="codeline" id="line-1841"><code>		return addr</code></span>
<span class="codeline" id="line-1842"><code>	}</code></span>
<span class="codeline" id="line-1843"><code>	host, _, err := net.SplitHostPort(addr)</code></span>
<span class="codeline" id="line-1844"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1845"><code>		return "*"</code></span>
<span class="codeline" id="line-1846"><code>	}</code></span>
<span class="codeline" id="line-1847"><code>	return host</code></span>
<span class="codeline" id="line-1848"><code>}</code></span>
<span class="codeline" id="line-1849"><code></code></span>
<span class="codeline" id="line-1850"><code>func (c *HostClient) nextAddr() string {</code></span>
<span class="codeline" id="line-1851"><code>	c.addrsLock.Lock()</code></span>
<span class="codeline" id="line-1852"><code>	if c.addrs == nil {</code></span>
<span class="codeline" id="line-1853"><code>		c.addrs = strings.Split(c.Addr, ",")</code></span>
<span class="codeline" id="line-1854"><code>	}</code></span>
<span class="codeline" id="line-1855"><code>	addr := c.addrs[0]</code></span>
<span class="codeline" id="line-1856"><code>	if len(c.addrs) &gt; 1 {</code></span>
<span class="codeline" id="line-1857"><code>		addr = c.addrs[c.addrIdx%uint32(len(c.addrs))]</code></span>
<span class="codeline" id="line-1858"><code>		c.addrIdx++</code></span>
<span class="codeline" id="line-1859"><code>	}</code></span>
<span class="codeline" id="line-1860"><code>	c.addrsLock.Unlock()</code></span>
<span class="codeline" id="line-1861"><code>	return addr</code></span>
<span class="codeline" id="line-1862"><code>}</code></span>
<span class="codeline" id="line-1863"><code></code></span>
<span class="codeline" id="line-1864"><code>func (c *HostClient) dialHostHard(dialTimeout time.Duration) (conn net.Conn, err error) {</code></span>
<span class="codeline" id="line-1865"><code>	// use dialTimeout to control the timeout of each dial. It does not work if dialTimeout is 0 or if</code></span>
<span class="codeline" id="line-1866"><code>	// c.DialTimeout has not been set and c.Dial has been set.</code></span>
<span class="codeline" id="line-1867"><code>	// attempt to dial all the available hosts before giving up.</code></span>
<span class="codeline" id="line-1868"><code></code></span>
<span class="codeline" id="line-1869"><code>	c.addrsLock.Lock()</code></span>
<span class="codeline" id="line-1870"><code>	n := len(c.addrs)</code></span>
<span class="codeline" id="line-1871"><code>	c.addrsLock.Unlock()</code></span>
<span class="codeline" id="line-1872"><code></code></span>
<span class="codeline" id="line-1873"><code>	if n == 0 {</code></span>
<span class="codeline" id="line-1874"><code>		// It looks like c.addrs isn't initialized yet.</code></span>
<span class="codeline" id="line-1875"><code>		n = 1</code></span>
<span class="codeline" id="line-1876"><code>	}</code></span>
<span class="codeline" id="line-1877"><code></code></span>
<span class="codeline" id="line-1878"><code>	timeout := c.ReadTimeout + c.WriteTimeout</code></span>
<span class="codeline" id="line-1879"><code>	if timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-1880"><code>		timeout = DefaultDialTimeout</code></span>
<span class="codeline" id="line-1881"><code>	}</code></span>
<span class="codeline" id="line-1882"><code>	deadline := time.Now().Add(timeout)</code></span>
<span class="codeline" id="line-1883"><code>	for n &gt; 0 {</code></span>
<span class="codeline" id="line-1884"><code>		addr := c.nextAddr()</code></span>
<span class="codeline" id="line-1885"><code>		tlsConfig := c.cachedTLSConfig(addr)</code></span>
<span class="codeline" id="line-1886"><code>		conn, err = dialAddr(addr, c.Dial, c.DialTimeout, c.DialDualStack, c.IsTLS, tlsConfig, dialTimeout, c.WriteTimeout)</code></span>
<span class="codeline" id="line-1887"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1888"><code>			return conn, nil</code></span>
<span class="codeline" id="line-1889"><code>		}</code></span>
<span class="codeline" id="line-1890"><code>		if time.Since(deadline) &gt;= 0 {</code></span>
<span class="codeline" id="line-1891"><code>			break</code></span>
<span class="codeline" id="line-1892"><code>		}</code></span>
<span class="codeline" id="line-1893"><code>		n--</code></span>
<span class="codeline" id="line-1894"><code>	}</code></span>
<span class="codeline" id="line-1895"><code>	return nil, err</code></span>
<span class="codeline" id="line-1896"><code>}</code></span>
<span class="codeline" id="line-1897"><code></code></span>
<span class="codeline" id="line-1898"><code>func (c *HostClient) cachedTLSConfig(addr string) *tls.Config {</code></span>
<span class="codeline" id="line-1899"><code>	if !c.IsTLS {</code></span>
<span class="codeline" id="line-1900"><code>		return nil</code></span>
<span class="codeline" id="line-1901"><code>	}</code></span>
<span class="codeline" id="line-1902"><code></code></span>
<span class="codeline" id="line-1903"><code>	c.tlsConfigMapLock.Lock()</code></span>
<span class="codeline" id="line-1904"><code>	if c.tlsConfigMap == nil {</code></span>
<span class="codeline" id="line-1905"><code>		c.tlsConfigMap = make(map[string]*tls.Config)</code></span>
<span class="codeline" id="line-1906"><code>	}</code></span>
<span class="codeline" id="line-1907"><code>	cfg := c.tlsConfigMap[addr]</code></span>
<span class="codeline" id="line-1908"><code>	if cfg == nil {</code></span>
<span class="codeline" id="line-1909"><code>		cfg = newClientTLSConfig(c.TLSConfig, addr)</code></span>
<span class="codeline" id="line-1910"><code>		c.tlsConfigMap[addr] = cfg</code></span>
<span class="codeline" id="line-1911"><code>	}</code></span>
<span class="codeline" id="line-1912"><code>	c.tlsConfigMapLock.Unlock()</code></span>
<span class="codeline" id="line-1913"><code></code></span>
<span class="codeline" id="line-1914"><code>	return cfg</code></span>
<span class="codeline" id="line-1915"><code>}</code></span>
<span class="codeline" id="line-1916"><code></code></span>
<span class="codeline" id="line-1917"><code>// ErrTLSHandshakeTimeout indicates there is a timeout from tls handshake.</code></span>
<span class="codeline" id="line-1918"><code>var ErrTLSHandshakeTimeout = errors.New("tls handshake timed out")</code></span>
<span class="codeline" id="line-1919"><code></code></span>
<span class="codeline" id="line-1920"><code>func tlsClientHandshake(rawConn net.Conn, tlsConfig *tls.Config, deadline time.Time) (_ net.Conn, retErr error) {</code></span>
<span class="codeline" id="line-1921"><code>	defer func() {</code></span>
<span class="codeline" id="line-1922"><code>		if retErr != nil {</code></span>
<span class="codeline" id="line-1923"><code>			rawConn.Close()</code></span>
<span class="codeline" id="line-1924"><code>		}</code></span>
<span class="codeline" id="line-1925"><code>	}()</code></span>
<span class="codeline" id="line-1926"><code>	conn := tls.Client(rawConn, tlsConfig)</code></span>
<span class="codeline" id="line-1927"><code>	err := conn.SetDeadline(deadline)</code></span>
<span class="codeline" id="line-1928"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1929"><code>		return nil, err</code></span>
<span class="codeline" id="line-1930"><code>	}</code></span>
<span class="codeline" id="line-1931"><code>	err = conn.Handshake()</code></span>
<span class="codeline" id="line-1932"><code>	if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() {</code></span>
<span class="codeline" id="line-1933"><code>		return nil, ErrTLSHandshakeTimeout</code></span>
<span class="codeline" id="line-1934"><code>	}</code></span>
<span class="codeline" id="line-1935"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1936"><code>		return nil, err</code></span>
<span class="codeline" id="line-1937"><code>	}</code></span>
<span class="codeline" id="line-1938"><code>	err = conn.SetDeadline(time.Time{})</code></span>
<span class="codeline" id="line-1939"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1940"><code>		return nil, err</code></span>
<span class="codeline" id="line-1941"><code>	}</code></span>
<span class="codeline" id="line-1942"><code>	return conn, nil</code></span>
<span class="codeline" id="line-1943"><code>}</code></span>
<span class="codeline" id="line-1944"><code></code></span>
<span class="codeline" id="line-1945"><code>func dialAddr(</code></span>
<span class="codeline" id="line-1946"><code>	addr string, dial DialFunc, dialWithTimeout DialFuncWithTimeout, dialDualStack, isTLS bool,</code></span>
<span class="codeline" id="line-1947"><code>	tlsConfig *tls.Config, dialTimeout, writeTimeout time.Duration,</code></span>
<span class="codeline" id="line-1948"><code>) (net.Conn, error) {</code></span>
<span class="codeline" id="line-1949"><code>	deadline := time.Now().Add(writeTimeout)</code></span>
<span class="codeline" id="line-1950"><code>	conn, err := callDialFunc(addr, dial, dialWithTimeout, dialDualStack, isTLS, dialTimeout)</code></span>
<span class="codeline" id="line-1951"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1952"><code>		return nil, err</code></span>
<span class="codeline" id="line-1953"><code>	}</code></span>
<span class="codeline" id="line-1954"><code>	if conn == nil {</code></span>
<span class="codeline" id="line-1955"><code>		return nil, errors.New("dialling unsuccessful. Please report this bug")</code></span>
<span class="codeline" id="line-1956"><code>	}</code></span>
<span class="codeline" id="line-1957"><code></code></span>
<span class="codeline" id="line-1958"><code>	// We assume that any conn that has the Handshake() method is a TLS conn already.</code></span>
<span class="codeline" id="line-1959"><code>	// This doesn't cover just tls.Conn but also other TLS implementations.</code></span>
<span class="codeline" id="line-1960"><code>	_, isTLSAlready := conn.(interface{ Handshake() error })</code></span>
<span class="codeline" id="line-1961"><code></code></span>
<span class="codeline" id="line-1962"><code>	if isTLS &amp;&amp; !isTLSAlready {</code></span>
<span class="codeline" id="line-1963"><code>		if writeTimeout == 0 {</code></span>
<span class="codeline" id="line-1964"><code>			return tls.Client(conn, tlsConfig), nil</code></span>
<span class="codeline" id="line-1965"><code>		}</code></span>
<span class="codeline" id="line-1966"><code>		return tlsClientHandshake(conn, tlsConfig, deadline)</code></span>
<span class="codeline" id="line-1967"><code>	}</code></span>
<span class="codeline" id="line-1968"><code>	return conn, nil</code></span>
<span class="codeline" id="line-1969"><code>}</code></span>
<span class="codeline" id="line-1970"><code></code></span>
<span class="codeline" id="line-1971"><code>func callDialFunc(</code></span>
<span class="codeline" id="line-1972"><code>	addr string, dial DialFunc, dialWithTimeout DialFuncWithTimeout, dialDualStack, isTLS bool, timeout time.Duration,</code></span>
<span class="codeline" id="line-1973"><code>) (net.Conn, error) {</code></span>
<span class="codeline" id="line-1974"><code>	if dialWithTimeout != nil {</code></span>
<span class="codeline" id="line-1975"><code>		return dialWithTimeout(addr, timeout)</code></span>
<span class="codeline" id="line-1976"><code>	}</code></span>
<span class="codeline" id="line-1977"><code>	if dial != nil {</code></span>
<span class="codeline" id="line-1978"><code>		return dial(addr)</code></span>
<span class="codeline" id="line-1979"><code>	}</code></span>
<span class="codeline" id="line-1980"><code>	addr = AddMissingPort(addr, isTLS)</code></span>
<span class="codeline" id="line-1981"><code>	if timeout &gt; 0 {</code></span>
<span class="codeline" id="line-1982"><code>		if dialDualStack {</code></span>
<span class="codeline" id="line-1983"><code>			return DialDualStackTimeout(addr, timeout)</code></span>
<span class="codeline" id="line-1984"><code>		}</code></span>
<span class="codeline" id="line-1985"><code>		return DialTimeout(addr, timeout)</code></span>
<span class="codeline" id="line-1986"><code>	}</code></span>
<span class="codeline" id="line-1987"><code>	if dialDualStack {</code></span>
<span class="codeline" id="line-1988"><code>		return DialDualStack(addr)</code></span>
<span class="codeline" id="line-1989"><code>	}</code></span>
<span class="codeline" id="line-1990"><code>	return Dial(addr)</code></span>
<span class="codeline" id="line-1991"><code>}</code></span>
<span class="codeline" id="line-1992"><code></code></span>
<span class="codeline" id="line-1993"><code>// AddMissingPort adds a port to a host if it is missing.</code></span>
<span class="codeline" id="line-1994"><code>// A literal IPv6 address in hostport must be enclosed in square</code></span>
<span class="codeline" id="line-1995"><code>// brackets, as in "[::1]:80", "[::1%lo0]:80".</code></span>
<span class="codeline" id="line-1996"><code>func AddMissingPort(addr string, isTLS bool) string {</code></span>
<span class="codeline" id="line-1997"><code>	addrLen := len(addr)</code></span>
<span class="codeline" id="line-1998"><code>	if addrLen == 0 {</code></span>
<span class="codeline" id="line-1999"><code>		return addr</code></span>
<span class="codeline" id="line-2000"><code>	}</code></span>
<span class="codeline" id="line-2001"><code></code></span>
<span class="codeline" id="line-2002"><code>	isIP6 := addr[0] == '['</code></span>
<span class="codeline" id="line-2003"><code>	if isIP6 {</code></span>
<span class="codeline" id="line-2004"><code>		// if the IPv6 has opening bracket but closing bracket is the last char then it doesn't have a port</code></span>
<span class="codeline" id="line-2005"><code>		isIP6WithoutPort := addr[addrLen-1] == ']'</code></span>
<span class="codeline" id="line-2006"><code>		if !isIP6WithoutPort {</code></span>
<span class="codeline" id="line-2007"><code>			return addr</code></span>
<span class="codeline" id="line-2008"><code>		}</code></span>
<span class="codeline" id="line-2009"><code>	} else { // IPv4</code></span>
<span class="codeline" id="line-2010"><code>		columnPos := strings.LastIndexByte(addr, ':')</code></span>
<span class="codeline" id="line-2011"><code>		if columnPos &gt; 0 {</code></span>
<span class="codeline" id="line-2012"><code>			return addr</code></span>
<span class="codeline" id="line-2013"><code>		}</code></span>
<span class="codeline" id="line-2014"><code>	}</code></span>
<span class="codeline" id="line-2015"><code>	port := ":80"</code></span>
<span class="codeline" id="line-2016"><code>	if isTLS {</code></span>
<span class="codeline" id="line-2017"><code>		port = ":443"</code></span>
<span class="codeline" id="line-2018"><code>	}</code></span>
<span class="codeline" id="line-2019"><code>	return addr + port</code></span>
<span class="codeline" id="line-2020"><code>}</code></span>
<span class="codeline" id="line-2021"><code></code></span>
<span class="codeline" id="line-2022"><code>// A wantConn records state about a wanted connection</code></span>
<span class="codeline" id="line-2023"><code>// (that is, an active call to getConn).</code></span>
<span class="codeline" id="line-2024"><code>// The conn may be gotten by dialing or by finding an idle connection,</code></span>
<span class="codeline" id="line-2025"><code>// or a cancellation may make the conn no longer wanted.</code></span>
<span class="codeline" id="line-2026"><code>// These three options are racing against each other and use</code></span>
<span class="codeline" id="line-2027"><code>// wantConn to coordinate and agree about the winning outcome.</code></span>
<span class="codeline" id="line-2028"><code>//</code></span>
<span class="codeline" id="line-2029"><code>// Inspired by net/http/transport.go.</code></span>
<span class="codeline" id="line-2030"><code>type wantConn struct {</code></span>
<span class="codeline" id="line-2031"><code>	ready chan struct{}</code></span>
<span class="codeline" id="line-2032"><code>	mu    sync.Mutex // protects conn, err, close(ready)</code></span>
<span class="codeline" id="line-2033"><code>	conn  *clientConn</code></span>
<span class="codeline" id="line-2034"><code>	err   error</code></span>
<span class="codeline" id="line-2035"><code>}</code></span>
<span class="codeline" id="line-2036"><code></code></span>
<span class="codeline" id="line-2037"><code>// waiting reports whether w is still waiting for an answer (connection or error).</code></span>
<span class="codeline" id="line-2038"><code>func (w *wantConn) waiting() bool {</code></span>
<span class="codeline" id="line-2039"><code>	select {</code></span>
<span class="codeline" id="line-2040"><code>	case &lt;-w.ready:</code></span>
<span class="codeline" id="line-2041"><code>		return false</code></span>
<span class="codeline" id="line-2042"><code>	default:</code></span>
<span class="codeline" id="line-2043"><code>		return true</code></span>
<span class="codeline" id="line-2044"><code>	}</code></span>
<span class="codeline" id="line-2045"><code>}</code></span>
<span class="codeline" id="line-2046"><code></code></span>
<span class="codeline" id="line-2047"><code>// tryDeliver attempts to deliver conn, err to w and reports whether it succeeded.</code></span>
<span class="codeline" id="line-2048"><code>func (w *wantConn) tryDeliver(conn *clientConn, err error) bool {</code></span>
<span class="codeline" id="line-2049"><code>	w.mu.Lock()</code></span>
<span class="codeline" id="line-2050"><code>	defer w.mu.Unlock()</code></span>
<span class="codeline" id="line-2051"><code></code></span>
<span class="codeline" id="line-2052"><code>	if w.conn != nil || w.err != nil {</code></span>
<span class="codeline" id="line-2053"><code>		return false</code></span>
<span class="codeline" id="line-2054"><code>	}</code></span>
<span class="codeline" id="line-2055"><code>	w.conn = conn</code></span>
<span class="codeline" id="line-2056"><code>	w.err = err</code></span>
<span class="codeline" id="line-2057"><code>	if w.conn == nil &amp;&amp; w.err == nil {</code></span>
<span class="codeline" id="line-2058"><code>		panic("fasthttp: internal error: misuse of tryDeliver")</code></span>
<span class="codeline" id="line-2059"><code>	}</code></span>
<span class="codeline" id="line-2060"><code>	close(w.ready)</code></span>
<span class="codeline" id="line-2061"><code>	return true</code></span>
<span class="codeline" id="line-2062"><code>}</code></span>
<span class="codeline" id="line-2063"><code></code></span>
<span class="codeline" id="line-2064"><code>// cancel marks w as no longer wanting a result (for example, due to cancellation).</code></span>
<span class="codeline" id="line-2065"><code>// If a connection has been delivered already, cancel returns it with c.releaseConn.</code></span>
<span class="codeline" id="line-2066"><code>func (w *wantConn) cancel(c *HostClient, err error) {</code></span>
<span class="codeline" id="line-2067"><code>	w.mu.Lock()</code></span>
<span class="codeline" id="line-2068"><code>	if w.conn == nil &amp;&amp; w.err == nil {</code></span>
<span class="codeline" id="line-2069"><code>		close(w.ready) // catch misbehavior in future delivery</code></span>
<span class="codeline" id="line-2070"><code>	}</code></span>
<span class="codeline" id="line-2071"><code></code></span>
<span class="codeline" id="line-2072"><code>	conn := w.conn</code></span>
<span class="codeline" id="line-2073"><code>	w.conn = nil</code></span>
<span class="codeline" id="line-2074"><code>	w.err = err</code></span>
<span class="codeline" id="line-2075"><code>	w.mu.Unlock()</code></span>
<span class="codeline" id="line-2076"><code></code></span>
<span class="codeline" id="line-2077"><code>	if conn != nil {</code></span>
<span class="codeline" id="line-2078"><code>		c.releaseConn(conn)</code></span>
<span class="codeline" id="line-2079"><code>	}</code></span>
<span class="codeline" id="line-2080"><code>}</code></span>
<span class="codeline" id="line-2081"><code></code></span>
<span class="codeline" id="line-2082"><code>// A wantConnQueue is a queue of wantConns.</code></span>
<span class="codeline" id="line-2083"><code>//</code></span>
<span class="codeline" id="line-2084"><code>// Inspired by net/http/transport.go.</code></span>
<span class="codeline" id="line-2085"><code>type wantConnQueue struct {</code></span>
<span class="codeline" id="line-2086"><code>	// This is a queue, not a dequeue.</code></span>
<span class="codeline" id="line-2087"><code>	// It is split into two stages - head[headPos:] and tail.</code></span>
<span class="codeline" id="line-2088"><code>	// popFront is trivial (headPos++) on the first stage, and</code></span>
<span class="codeline" id="line-2089"><code>	// pushBack is trivial (append) on the second stage.</code></span>
<span class="codeline" id="line-2090"><code>	// If the first stage is empty, popFront can swap the</code></span>
<span class="codeline" id="line-2091"><code>	// first and second stages to remedy the situation.</code></span>
<span class="codeline" id="line-2092"><code>	//</code></span>
<span class="codeline" id="line-2093"><code>	// This two-stage split is analogous to the use of two lists</code></span>
<span class="codeline" id="line-2094"><code>	// in Okasaki's purely functional queue but without the</code></span>
<span class="codeline" id="line-2095"><code>	// overhead of reversing the list when swapping stages.</code></span>
<span class="codeline" id="line-2096"><code>	head    []*wantConn</code></span>
<span class="codeline" id="line-2097"><code>	headPos int</code></span>
<span class="codeline" id="line-2098"><code>	tail    []*wantConn</code></span>
<span class="codeline" id="line-2099"><code>}</code></span>
<span class="codeline" id="line-2100"><code></code></span>
<span class="codeline" id="line-2101"><code>// len returns the number of items in the queue.</code></span>
<span class="codeline" id="line-2102"><code>func (q *wantConnQueue) len() int {</code></span>
<span class="codeline" id="line-2103"><code>	return len(q.head) - q.headPos + len(q.tail)</code></span>
<span class="codeline" id="line-2104"><code>}</code></span>
<span class="codeline" id="line-2105"><code></code></span>
<span class="codeline" id="line-2106"><code>// pushBack adds w to the back of the queue.</code></span>
<span class="codeline" id="line-2107"><code>func (q *wantConnQueue) pushBack(w *wantConn) {</code></span>
<span class="codeline" id="line-2108"><code>	q.tail = append(q.tail, w)</code></span>
<span class="codeline" id="line-2109"><code>}</code></span>
<span class="codeline" id="line-2110"><code></code></span>
<span class="codeline" id="line-2111"><code>// popFront removes and returns the wantConn at the front of the queue.</code></span>
<span class="codeline" id="line-2112"><code>func (q *wantConnQueue) popFront() *wantConn {</code></span>
<span class="codeline" id="line-2113"><code>	if q.headPos &gt;= len(q.head) {</code></span>
<span class="codeline" id="line-2114"><code>		if len(q.tail) == 0 {</code></span>
<span class="codeline" id="line-2115"><code>			return nil</code></span>
<span class="codeline" id="line-2116"><code>		}</code></span>
<span class="codeline" id="line-2117"><code>		// Pick up tail as new head, clear tail.</code></span>
<span class="codeline" id="line-2118"><code>		q.head, q.headPos, q.tail = q.tail, 0, q.head[:0]</code></span>
<span class="codeline" id="line-2119"><code>	}</code></span>
<span class="codeline" id="line-2120"><code></code></span>
<span class="codeline" id="line-2121"><code>	w := q.head[q.headPos]</code></span>
<span class="codeline" id="line-2122"><code>	q.head[q.headPos] = nil</code></span>
<span class="codeline" id="line-2123"><code>	q.headPos++</code></span>
<span class="codeline" id="line-2124"><code>	return w</code></span>
<span class="codeline" id="line-2125"><code>}</code></span>
<span class="codeline" id="line-2126"><code></code></span>
<span class="codeline" id="line-2127"><code>// peekFront returns the wantConn at the front of the queue without removing it.</code></span>
<span class="codeline" id="line-2128"><code>func (q *wantConnQueue) peekFront() *wantConn {</code></span>
<span class="codeline" id="line-2129"><code>	if q.headPos &lt; len(q.head) {</code></span>
<span class="codeline" id="line-2130"><code>		return q.head[q.headPos]</code></span>
<span class="codeline" id="line-2131"><code>	}</code></span>
<span class="codeline" id="line-2132"><code>	if len(q.tail) &gt; 0 {</code></span>
<span class="codeline" id="line-2133"><code>		return q.tail[0]</code></span>
<span class="codeline" id="line-2134"><code>	}</code></span>
<span class="codeline" id="line-2135"><code>	return nil</code></span>
<span class="codeline" id="line-2136"><code>}</code></span>
<span class="codeline" id="line-2137"><code></code></span>
<span class="codeline" id="line-2138"><code>// clearFront pops any wantConns that are no longer waiting from the head of the</code></span>
<span class="codeline" id="line-2139"><code>// queue, reporting whether any were popped.</code></span>
<span class="codeline" id="line-2140"><code>func (q *wantConnQueue) clearFront() (cleaned bool) {</code></span>
<span class="codeline" id="line-2141"><code>	for {</code></span>
<span class="codeline" id="line-2142"><code>		w := q.peekFront()</code></span>
<span class="codeline" id="line-2143"><code>		if w == nil || w.waiting() {</code></span>
<span class="codeline" id="line-2144"><code>			return cleaned</code></span>
<span class="codeline" id="line-2145"><code>		}</code></span>
<span class="codeline" id="line-2146"><code>		q.popFront()</code></span>
<span class="codeline" id="line-2147"><code>		cleaned = true</code></span>
<span class="codeline" id="line-2148"><code>	}</code></span>
<span class="codeline" id="line-2149"><code>}</code></span>
<span class="codeline" id="line-2150"><code></code></span>
<span class="codeline" id="line-2151"><code>// PipelineClient pipelines requests over a limited set of concurrent</code></span>
<span class="codeline" id="line-2152"><code>// connections to the given Addr.</code></span>
<span class="codeline" id="line-2153"><code>//</code></span>
<span class="codeline" id="line-2154"><code>// This client may be used in highly loaded HTTP-based RPC systems for reducing</code></span>
<span class="codeline" id="line-2155"><code>// context switches and network level overhead.</code></span>
<span class="codeline" id="line-2156"><code>// See https://en.wikipedia.org/wiki/HTTP_pipelining for details.</code></span>
<span class="codeline" id="line-2157"><code>//</code></span>
<span class="codeline" id="line-2158"><code>// It is forbidden copying PipelineClient instances. Create new instances</code></span>
<span class="codeline" id="line-2159"><code>// instead.</code></span>
<span class="codeline" id="line-2160"><code>//</code></span>
<span class="codeline" id="line-2161"><code>// It is safe calling PipelineClient methods from concurrently running</code></span>
<span class="codeline" id="line-2162"><code>// goroutines.</code></span>
<span class="codeline" id="line-2163"><code>type PipelineClient struct {</code></span>
<span class="codeline" id="line-2164"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-2165"><code></code></span>
<span class="codeline" id="line-2166"><code>	// Address of the host to connect to.</code></span>
<span class="codeline" id="line-2167"><code>	Addr string</code></span>
<span class="codeline" id="line-2168"><code></code></span>
<span class="codeline" id="line-2169"><code>	// PipelineClient name. Used in User-Agent request header.</code></span>
<span class="codeline" id="line-2170"><code>	Name string</code></span>
<span class="codeline" id="line-2171"><code></code></span>
<span class="codeline" id="line-2172"><code>	// NoDefaultUserAgentHeader when set to true, causes the default</code></span>
<span class="codeline" id="line-2173"><code>	// User-Agent header to be excluded from the Request.</code></span>
<span class="codeline" id="line-2174"><code>	NoDefaultUserAgentHeader bool</code></span>
<span class="codeline" id="line-2175"><code></code></span>
<span class="codeline" id="line-2176"><code>	// The maximum number of concurrent connections to the Addr.</code></span>
<span class="codeline" id="line-2177"><code>	//</code></span>
<span class="codeline" id="line-2178"><code>	// A single connection is used by default.</code></span>
<span class="codeline" id="line-2179"><code>	MaxConns int</code></span>
<span class="codeline" id="line-2180"><code></code></span>
<span class="codeline" id="line-2181"><code>	// The maximum number of pending pipelined requests over</code></span>
<span class="codeline" id="line-2182"><code>	// a single connection to Addr.</code></span>
<span class="codeline" id="line-2183"><code>	//</code></span>
<span class="codeline" id="line-2184"><code>	// DefaultMaxPendingRequests is used by default.</code></span>
<span class="codeline" id="line-2185"><code>	MaxPendingRequests int</code></span>
<span class="codeline" id="line-2186"><code></code></span>
<span class="codeline" id="line-2187"><code>	// The maximum delay before sending pipelined requests as a batch</code></span>
<span class="codeline" id="line-2188"><code>	// to the server.</code></span>
<span class="codeline" id="line-2189"><code>	//</code></span>
<span class="codeline" id="line-2190"><code>	// By default requests are sent immediately to the server.</code></span>
<span class="codeline" id="line-2191"><code>	MaxBatchDelay time.Duration</code></span>
<span class="codeline" id="line-2192"><code></code></span>
<span class="codeline" id="line-2193"><code>	// Callback for connection establishing to the host.</code></span>
<span class="codeline" id="line-2194"><code>	//</code></span>
<span class="codeline" id="line-2195"><code>	// Default Dial is used if not set.</code></span>
<span class="codeline" id="line-2196"><code>	Dial DialFunc</code></span>
<span class="codeline" id="line-2197"><code></code></span>
<span class="codeline" id="line-2198"><code>	// Attempt to connect to both ipv4 and ipv6 host addresses</code></span>
<span class="codeline" id="line-2199"><code>	// if set to true.</code></span>
<span class="codeline" id="line-2200"><code>	//</code></span>
<span class="codeline" id="line-2201"><code>	// This option is used only if default TCP dialer is used,</code></span>
<span class="codeline" id="line-2202"><code>	// i.e. if Dial is blank.</code></span>
<span class="codeline" id="line-2203"><code>	//</code></span>
<span class="codeline" id="line-2204"><code>	// By default client connects only to ipv4 addresses,</code></span>
<span class="codeline" id="line-2205"><code>	// since unfortunately ipv6 remains broken in many networks worldwide :)</code></span>
<span class="codeline" id="line-2206"><code>	DialDualStack bool</code></span>
<span class="codeline" id="line-2207"><code></code></span>
<span class="codeline" id="line-2208"><code>	// Response header names are passed as-is without normalization</code></span>
<span class="codeline" id="line-2209"><code>	// if this option is set.</code></span>
<span class="codeline" id="line-2210"><code>	//</code></span>
<span class="codeline" id="line-2211"><code>	// Disabled header names' normalization may be useful only for proxying</code></span>
<span class="codeline" id="line-2212"><code>	// responses to other clients expecting case-sensitive</code></span>
<span class="codeline" id="line-2213"><code>	// header names. See https://github.com/valyala/fasthttp/issues/57</code></span>
<span class="codeline" id="line-2214"><code>	// for details.</code></span>
<span class="codeline" id="line-2215"><code>	//</code></span>
<span class="codeline" id="line-2216"><code>	// By default request and response header names are normalized, i.e.</code></span>
<span class="codeline" id="line-2217"><code>	// The first letter and the first letters following dashes</code></span>
<span class="codeline" id="line-2218"><code>	// are uppercased, while all the other letters are lowercased.</code></span>
<span class="codeline" id="line-2219"><code>	// Examples:</code></span>
<span class="codeline" id="line-2220"><code>	//</code></span>
<span class="codeline" id="line-2221"><code>	//     * HOST -&gt; Host</code></span>
<span class="codeline" id="line-2222"><code>	//     * content-type -&gt; Content-Type</code></span>
<span class="codeline" id="line-2223"><code>	//     * cONTENT-lenGTH -&gt; Content-Length</code></span>
<span class="codeline" id="line-2224"><code>	DisableHeaderNamesNormalizing bool</code></span>
<span class="codeline" id="line-2225"><code></code></span>
<span class="codeline" id="line-2226"><code>	// Path values are sent as-is without normalization</code></span>
<span class="codeline" id="line-2227"><code>	//</code></span>
<span class="codeline" id="line-2228"><code>	// Disabled path normalization may be useful for proxying incoming requests</code></span>
<span class="codeline" id="line-2229"><code>	// to servers that are expecting paths to be forwarded as-is.</code></span>
<span class="codeline" id="line-2230"><code>	//</code></span>
<span class="codeline" id="line-2231"><code>	// By default path values are normalized, i.e.</code></span>
<span class="codeline" id="line-2232"><code>	// extra slashes are removed, special characters are encoded.</code></span>
<span class="codeline" id="line-2233"><code>	DisablePathNormalizing bool</code></span>
<span class="codeline" id="line-2234"><code></code></span>
<span class="codeline" id="line-2235"><code>	// Whether to use TLS (aka SSL or HTTPS) for host connections.</code></span>
<span class="codeline" id="line-2236"><code>	IsTLS bool</code></span>
<span class="codeline" id="line-2237"><code></code></span>
<span class="codeline" id="line-2238"><code>	// Optional TLS config.</code></span>
<span class="codeline" id="line-2239"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-2240"><code></code></span>
<span class="codeline" id="line-2241"><code>	// Idle connection to the host is closed after this duration.</code></span>
<span class="codeline" id="line-2242"><code>	//</code></span>
<span class="codeline" id="line-2243"><code>	// By default idle connection is closed after</code></span>
<span class="codeline" id="line-2244"><code>	// DefaultMaxIdleConnDuration.</code></span>
<span class="codeline" id="line-2245"><code>	MaxIdleConnDuration time.Duration</code></span>
<span class="codeline" id="line-2246"><code></code></span>
<span class="codeline" id="line-2247"><code>	// Buffer size for responses' reading.</code></span>
<span class="codeline" id="line-2248"><code>	// This also limits the maximum header size.</code></span>
<span class="codeline" id="line-2249"><code>	//</code></span>
<span class="codeline" id="line-2250"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-2251"><code>	ReadBufferSize int</code></span>
<span class="codeline" id="line-2252"><code></code></span>
<span class="codeline" id="line-2253"><code>	// Buffer size for requests' writing.</code></span>
<span class="codeline" id="line-2254"><code>	//</code></span>
<span class="codeline" id="line-2255"><code>	// Default buffer size is used if 0.</code></span>
<span class="codeline" id="line-2256"><code>	WriteBufferSize int</code></span>
<span class="codeline" id="line-2257"><code></code></span>
<span class="codeline" id="line-2258"><code>	// Maximum duration for full response reading (including body).</code></span>
<span class="codeline" id="line-2259"><code>	//</code></span>
<span class="codeline" id="line-2260"><code>	// By default response read timeout is unlimited.</code></span>
<span class="codeline" id="line-2261"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>	// Maximum duration for full request writing (including body).</code></span>
<span class="codeline" id="line-2264"><code>	//</code></span>
<span class="codeline" id="line-2265"><code>	// By default request write timeout is unlimited.</code></span>
<span class="codeline" id="line-2266"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-2267"><code></code></span>
<span class="codeline" id="line-2268"><code>	// Logger for logging client errors.</code></span>
<span class="codeline" id="line-2269"><code>	//</code></span>
<span class="codeline" id="line-2270"><code>	// By default standard logger from log package is used.</code></span>
<span class="codeline" id="line-2271"><code>	Logger Logger</code></span>
<span class="codeline" id="line-2272"><code></code></span>
<span class="codeline" id="line-2273"><code>	connClients     []*pipelineConnClient</code></span>
<span class="codeline" id="line-2274"><code>	connClientsLock sync.Mutex</code></span>
<span class="codeline" id="line-2275"><code>}</code></span>
<span class="codeline" id="line-2276"><code></code></span>
<span class="codeline" id="line-2277"><code>type pipelineConnClient struct {</code></span>
<span class="codeline" id="line-2278"><code>	noCopy noCopy</code></span>
<span class="codeline" id="line-2279"><code></code></span>
<span class="codeline" id="line-2280"><code>	Addr                          string</code></span>
<span class="codeline" id="line-2281"><code>	Name                          string</code></span>
<span class="codeline" id="line-2282"><code>	NoDefaultUserAgentHeader      bool</code></span>
<span class="codeline" id="line-2283"><code>	MaxPendingRequests            int</code></span>
<span class="codeline" id="line-2284"><code>	MaxBatchDelay                 time.Duration</code></span>
<span class="codeline" id="line-2285"><code>	Dial                          DialFunc</code></span>
<span class="codeline" id="line-2286"><code>	DialDualStack                 bool</code></span>
<span class="codeline" id="line-2287"><code>	DisableHeaderNamesNormalizing bool</code></span>
<span class="codeline" id="line-2288"><code>	DisablePathNormalizing        bool</code></span>
<span class="codeline" id="line-2289"><code>	IsTLS                         bool</code></span>
<span class="codeline" id="line-2290"><code>	TLSConfig                     *tls.Config</code></span>
<span class="codeline" id="line-2291"><code>	MaxIdleConnDuration           time.Duration</code></span>
<span class="codeline" id="line-2292"><code>	ReadBufferSize                int</code></span>
<span class="codeline" id="line-2293"><code>	WriteBufferSize               int</code></span>
<span class="codeline" id="line-2294"><code>	ReadTimeout                   time.Duration</code></span>
<span class="codeline" id="line-2295"><code>	WriteTimeout                  time.Duration</code></span>
<span class="codeline" id="line-2296"><code>	Logger                        Logger</code></span>
<span class="codeline" id="line-2297"><code></code></span>
<span class="codeline" id="line-2298"><code>	workPool sync.Pool</code></span>
<span class="codeline" id="line-2299"><code></code></span>
<span class="codeline" id="line-2300"><code>	chLock sync.Mutex</code></span>
<span class="codeline" id="line-2301"><code>	chW    chan *pipelineWork</code></span>
<span class="codeline" id="line-2302"><code>	chR    chan *pipelineWork</code></span>
<span class="codeline" id="line-2303"><code></code></span>
<span class="codeline" id="line-2304"><code>	tlsConfigLock sync.Mutex</code></span>
<span class="codeline" id="line-2305"><code>	tlsConfig     *tls.Config</code></span>
<span class="codeline" id="line-2306"><code>}</code></span>
<span class="codeline" id="line-2307"><code></code></span>
<span class="codeline" id="line-2308"><code>type pipelineWork struct {</code></span>
<span class="codeline" id="line-2309"><code>	reqCopy  Request</code></span>
<span class="codeline" id="line-2310"><code>	respCopy Response</code></span>
<span class="codeline" id="line-2311"><code>	req      *Request</code></span>
<span class="codeline" id="line-2312"><code>	resp     *Response</code></span>
<span class="codeline" id="line-2313"><code>	t        *time.Timer</code></span>
<span class="codeline" id="line-2314"><code>	deadline time.Time</code></span>
<span class="codeline" id="line-2315"><code>	err      error</code></span>
<span class="codeline" id="line-2316"><code>	done     chan struct{}</code></span>
<span class="codeline" id="line-2317"><code>}</code></span>
<span class="codeline" id="line-2318"><code></code></span>
<span class="codeline" id="line-2319"><code>// DoTimeout performs the given request and waits for response during</code></span>
<span class="codeline" id="line-2320"><code>// the given timeout duration.</code></span>
<span class="codeline" id="line-2321"><code>//</code></span>
<span class="codeline" id="line-2322"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-2323"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-2324"><code>//</code></span>
<span class="codeline" id="line-2325"><code>// The function doesn't follow redirects.</code></span>
<span class="codeline" id="line-2326"><code>//</code></span>
<span class="codeline" id="line-2327"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-2328"><code>//</code></span>
<span class="codeline" id="line-2329"><code>// ErrTimeout is returned if the response wasn't returned during</code></span>
<span class="codeline" id="line-2330"><code>// the given timeout.</code></span>
<span class="codeline" id="line-2331"><code>//</code></span>
<span class="codeline" id="line-2332"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-2333"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-2334"><code>func (c *PipelineClient) DoTimeout(req *Request, resp *Response, timeout time.Duration) error {</code></span>
<span class="codeline" id="line-2335"><code>	return c.DoDeadline(req, resp, time.Now().Add(timeout))</code></span>
<span class="codeline" id="line-2336"><code>}</code></span>
<span class="codeline" id="line-2337"><code></code></span>
<span class="codeline" id="line-2338"><code>// DoDeadline performs the given request and waits for response until</code></span>
<span class="codeline" id="line-2339"><code>// the given deadline.</code></span>
<span class="codeline" id="line-2340"><code>//</code></span>
<span class="codeline" id="line-2341"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-2342"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-2343"><code>//</code></span>
<span class="codeline" id="line-2344"><code>// The function doesn't follow redirects.</code></span>
<span class="codeline" id="line-2345"><code>//</code></span>
<span class="codeline" id="line-2346"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-2347"><code>//</code></span>
<span class="codeline" id="line-2348"><code>// ErrTimeout is returned if the response wasn't returned until</code></span>
<span class="codeline" id="line-2349"><code>// the given deadline.</code></span>
<span class="codeline" id="line-2350"><code>//</code></span>
<span class="codeline" id="line-2351"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-2352"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-2353"><code>func (c *PipelineClient) DoDeadline(req *Request, resp *Response, deadline time.Time) error {</code></span>
<span class="codeline" id="line-2354"><code>	return c.getConnClient().DoDeadline(req, resp, deadline)</code></span>
<span class="codeline" id="line-2355"><code>}</code></span>
<span class="codeline" id="line-2356"><code></code></span>
<span class="codeline" id="line-2357"><code>func (c *pipelineConnClient) DoDeadline(req *Request, resp *Response, deadline time.Time) error {</code></span>
<span class="codeline" id="line-2358"><code>	c.init()</code></span>
<span class="codeline" id="line-2359"><code></code></span>
<span class="codeline" id="line-2360"><code>	timeout := time.Until(deadline)</code></span>
<span class="codeline" id="line-2361"><code>	if timeout &lt;= 0 {</code></span>
<span class="codeline" id="line-2362"><code>		return ErrTimeout</code></span>
<span class="codeline" id="line-2363"><code>	}</code></span>
<span class="codeline" id="line-2364"><code></code></span>
<span class="codeline" id="line-2365"><code>	if c.DisablePathNormalizing {</code></span>
<span class="codeline" id="line-2366"><code>		req.URI().DisablePathNormalizing = true</code></span>
<span class="codeline" id="line-2367"><code>	}</code></span>
<span class="codeline" id="line-2368"><code></code></span>
<span class="codeline" id="line-2369"><code>	userAgentOld := req.Header.UserAgent()</code></span>
<span class="codeline" id="line-2370"><code>	if len(userAgentOld) == 0 {</code></span>
<span class="codeline" id="line-2371"><code>		userAgent := c.Name</code></span>
<span class="codeline" id="line-2372"><code>		if userAgent == "" &amp;&amp; !c.NoDefaultUserAgentHeader {</code></span>
<span class="codeline" id="line-2373"><code>			userAgent = defaultUserAgent</code></span>
<span class="codeline" id="line-2374"><code>		}</code></span>
<span class="codeline" id="line-2375"><code>		if userAgent != "" {</code></span>
<span class="codeline" id="line-2376"><code>			req.Header.userAgent = append(req.Header.userAgent[:0], userAgent...)</code></span>
<span class="codeline" id="line-2377"><code>		}</code></span>
<span class="codeline" id="line-2378"><code>	}</code></span>
<span class="codeline" id="line-2379"><code></code></span>
<span class="codeline" id="line-2380"><code>	w := c.acquirePipelineWork(timeout)</code></span>
<span class="codeline" id="line-2381"><code>	w.respCopy.Header.disableNormalizing = c.DisableHeaderNamesNormalizing</code></span>
<span class="codeline" id="line-2382"><code>	w.req = &amp;w.reqCopy</code></span>
<span class="codeline" id="line-2383"><code>	w.resp = &amp;w.respCopy</code></span>
<span class="codeline" id="line-2384"><code></code></span>
<span class="codeline" id="line-2385"><code>	// Make a copy of the request in order to avoid data races on timeouts</code></span>
<span class="codeline" id="line-2386"><code>	req.copyToSkipBody(&amp;w.reqCopy)</code></span>
<span class="codeline" id="line-2387"><code>	swapRequestBody(req, &amp;w.reqCopy)</code></span>
<span class="codeline" id="line-2388"><code></code></span>
<span class="codeline" id="line-2389"><code>	// Put the request to outgoing queue</code></span>
<span class="codeline" id="line-2390"><code>	select {</code></span>
<span class="codeline" id="line-2391"><code>	case c.chW &lt;- w:</code></span>
<span class="codeline" id="line-2392"><code>		// Fast path: len(c.ch) &lt; cap(c.ch)</code></span>
<span class="codeline" id="line-2393"><code>	default:</code></span>
<span class="codeline" id="line-2394"><code>		// Slow path</code></span>
<span class="codeline" id="line-2395"><code>		select {</code></span>
<span class="codeline" id="line-2396"><code>		case c.chW &lt;- w:</code></span>
<span class="codeline" id="line-2397"><code>		case &lt;-w.t.C:</code></span>
<span class="codeline" id="line-2398"><code>			c.releasePipelineWork(w)</code></span>
<span class="codeline" id="line-2399"><code>			return ErrTimeout</code></span>
<span class="codeline" id="line-2400"><code>		}</code></span>
<span class="codeline" id="line-2401"><code>	}</code></span>
<span class="codeline" id="line-2402"><code></code></span>
<span class="codeline" id="line-2403"><code>	// Wait for the response</code></span>
<span class="codeline" id="line-2404"><code>	var err error</code></span>
<span class="codeline" id="line-2405"><code>	select {</code></span>
<span class="codeline" id="line-2406"><code>	case &lt;-w.done:</code></span>
<span class="codeline" id="line-2407"><code>		if resp != nil {</code></span>
<span class="codeline" id="line-2408"><code>			w.respCopy.copyToSkipBody(resp)</code></span>
<span class="codeline" id="line-2409"><code>			swapResponseBody(resp, &amp;w.respCopy)</code></span>
<span class="codeline" id="line-2410"><code>		}</code></span>
<span class="codeline" id="line-2411"><code>		err = w.err</code></span>
<span class="codeline" id="line-2412"><code>		c.releasePipelineWork(w)</code></span>
<span class="codeline" id="line-2413"><code>	case &lt;-w.t.C:</code></span>
<span class="codeline" id="line-2414"><code>		err = ErrTimeout</code></span>
<span class="codeline" id="line-2415"><code>	}</code></span>
<span class="codeline" id="line-2416"><code></code></span>
<span class="codeline" id="line-2417"><code>	return err</code></span>
<span class="codeline" id="line-2418"><code>}</code></span>
<span class="codeline" id="line-2419"><code></code></span>
<span class="codeline" id="line-2420"><code>func (c *pipelineConnClient) acquirePipelineWork(timeout time.Duration) (w *pipelineWork) {</code></span>
<span class="codeline" id="line-2421"><code>	v := c.workPool.Get()</code></span>
<span class="codeline" id="line-2422"><code>	if v != nil {</code></span>
<span class="codeline" id="line-2423"><code>		w = v.(*pipelineWork)</code></span>
<span class="codeline" id="line-2424"><code>	} else {</code></span>
<span class="codeline" id="line-2425"><code>		w = &amp;pipelineWork{</code></span>
<span class="codeline" id="line-2426"><code>			done: make(chan struct{}, 1),</code></span>
<span class="codeline" id="line-2427"><code>		}</code></span>
<span class="codeline" id="line-2428"><code>	}</code></span>
<span class="codeline" id="line-2429"><code>	if timeout &gt; 0 {</code></span>
<span class="codeline" id="line-2430"><code>		if w.t == nil {</code></span>
<span class="codeline" id="line-2431"><code>			w.t = time.NewTimer(timeout)</code></span>
<span class="codeline" id="line-2432"><code>		} else {</code></span>
<span class="codeline" id="line-2433"><code>			w.t.Reset(timeout)</code></span>
<span class="codeline" id="line-2434"><code>		}</code></span>
<span class="codeline" id="line-2435"><code>		w.deadline = time.Now().Add(timeout)</code></span>
<span class="codeline" id="line-2436"><code>	} else {</code></span>
<span class="codeline" id="line-2437"><code>		w.deadline = zeroTime</code></span>
<span class="codeline" id="line-2438"><code>	}</code></span>
<span class="codeline" id="line-2439"><code>	return w</code></span>
<span class="codeline" id="line-2440"><code>}</code></span>
<span class="codeline" id="line-2441"><code></code></span>
<span class="codeline" id="line-2442"><code>func (c *pipelineConnClient) releasePipelineWork(w *pipelineWork) {</code></span>
<span class="codeline" id="line-2443"><code>	if w.t != nil {</code></span>
<span class="codeline" id="line-2444"><code>		w.t.Stop()</code></span>
<span class="codeline" id="line-2445"><code>	}</code></span>
<span class="codeline" id="line-2446"><code>	w.reqCopy.Reset()</code></span>
<span class="codeline" id="line-2447"><code>	w.respCopy.Reset()</code></span>
<span class="codeline" id="line-2448"><code>	w.req = nil</code></span>
<span class="codeline" id="line-2449"><code>	w.resp = nil</code></span>
<span class="codeline" id="line-2450"><code>	w.err = nil</code></span>
<span class="codeline" id="line-2451"><code>	c.workPool.Put(w)</code></span>
<span class="codeline" id="line-2452"><code>}</code></span>
<span class="codeline" id="line-2453"><code></code></span>
<span class="codeline" id="line-2454"><code>// Do performs the given http request and sets the corresponding response.</code></span>
<span class="codeline" id="line-2455"><code>//</code></span>
<span class="codeline" id="line-2456"><code>// Request must contain at least non-zero RequestURI with full url (including</code></span>
<span class="codeline" id="line-2457"><code>// scheme and host) or non-zero Host header + RequestURI.</code></span>
<span class="codeline" id="line-2458"><code>//</code></span>
<span class="codeline" id="line-2459"><code>// The function doesn't follow redirects. Use Get* for following redirects.</code></span>
<span class="codeline" id="line-2460"><code>//</code></span>
<span class="codeline" id="line-2461"><code>// Response is ignored if resp is nil.</code></span>
<span class="codeline" id="line-2462"><code>//</code></span>
<span class="codeline" id="line-2463"><code>// It is recommended obtaining req and resp via AcquireRequest</code></span>
<span class="codeline" id="line-2464"><code>// and AcquireResponse in performance-critical code.</code></span>
<span class="codeline" id="line-2465"><code>func (c *PipelineClient) Do(req *Request, resp *Response) error {</code></span>
<span class="codeline" id="line-2466"><code>	return c.getConnClient().Do(req, resp)</code></span>
<span class="codeline" id="line-2467"><code>}</code></span>
<span class="codeline" id="line-2468"><code></code></span>
<span class="codeline" id="line-2469"><code>func (c *pipelineConnClient) Do(req *Request, resp *Response) error {</code></span>
<span class="codeline" id="line-2470"><code>	c.init()</code></span>
<span class="codeline" id="line-2471"><code></code></span>
<span class="codeline" id="line-2472"><code>	if c.DisablePathNormalizing {</code></span>
<span class="codeline" id="line-2473"><code>		req.URI().DisablePathNormalizing = true</code></span>
<span class="codeline" id="line-2474"><code>	}</code></span>
<span class="codeline" id="line-2475"><code></code></span>
<span class="codeline" id="line-2476"><code>	userAgentOld := req.Header.UserAgent()</code></span>
<span class="codeline" id="line-2477"><code>	if len(userAgentOld) == 0 {</code></span>
<span class="codeline" id="line-2478"><code>		userAgent := c.Name</code></span>
<span class="codeline" id="line-2479"><code>		if userAgent == "" &amp;&amp; !c.NoDefaultUserAgentHeader {</code></span>
<span class="codeline" id="line-2480"><code>			userAgent = defaultUserAgent</code></span>
<span class="codeline" id="line-2481"><code>		}</code></span>
<span class="codeline" id="line-2482"><code>		if userAgent != "" {</code></span>
<span class="codeline" id="line-2483"><code>			req.Header.userAgent = append(req.Header.userAgent[:0], userAgent...)</code></span>
<span class="codeline" id="line-2484"><code>		}</code></span>
<span class="codeline" id="line-2485"><code>	}</code></span>
<span class="codeline" id="line-2486"><code></code></span>
<span class="codeline" id="line-2487"><code>	w := c.acquirePipelineWork(0)</code></span>
<span class="codeline" id="line-2488"><code>	w.req = req</code></span>
<span class="codeline" id="line-2489"><code>	if resp != nil {</code></span>
<span class="codeline" id="line-2490"><code>		resp.Header.disableNormalizing = c.DisableHeaderNamesNormalizing</code></span>
<span class="codeline" id="line-2491"><code>		w.resp = resp</code></span>
<span class="codeline" id="line-2492"><code>	} else {</code></span>
<span class="codeline" id="line-2493"><code>		w.resp = &amp;w.respCopy</code></span>
<span class="codeline" id="line-2494"><code>	}</code></span>
<span class="codeline" id="line-2495"><code></code></span>
<span class="codeline" id="line-2496"><code>	// Put the request to outgoing queue</code></span>
<span class="codeline" id="line-2497"><code>	select {</code></span>
<span class="codeline" id="line-2498"><code>	case c.chW &lt;- w:</code></span>
<span class="codeline" id="line-2499"><code>	default:</code></span>
<span class="codeline" id="line-2500"><code>		// Try substituting the oldest w with the current one.</code></span>
<span class="codeline" id="line-2501"><code>		select {</code></span>
<span class="codeline" id="line-2502"><code>		case wOld := &lt;-c.chW:</code></span>
<span class="codeline" id="line-2503"><code>			wOld.err = ErrPipelineOverflow</code></span>
<span class="codeline" id="line-2504"><code>			wOld.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2505"><code>		default:</code></span>
<span class="codeline" id="line-2506"><code>		}</code></span>
<span class="codeline" id="line-2507"><code>		select {</code></span>
<span class="codeline" id="line-2508"><code>		case c.chW &lt;- w:</code></span>
<span class="codeline" id="line-2509"><code>		default:</code></span>
<span class="codeline" id="line-2510"><code>			c.releasePipelineWork(w)</code></span>
<span class="codeline" id="line-2511"><code>			return ErrPipelineOverflow</code></span>
<span class="codeline" id="line-2512"><code>		}</code></span>
<span class="codeline" id="line-2513"><code>	}</code></span>
<span class="codeline" id="line-2514"><code></code></span>
<span class="codeline" id="line-2515"><code>	// Wait for the response</code></span>
<span class="codeline" id="line-2516"><code>	&lt;-w.done</code></span>
<span class="codeline" id="line-2517"><code>	err := w.err</code></span>
<span class="codeline" id="line-2518"><code></code></span>
<span class="codeline" id="line-2519"><code>	c.releasePipelineWork(w)</code></span>
<span class="codeline" id="line-2520"><code></code></span>
<span class="codeline" id="line-2521"><code>	return err</code></span>
<span class="codeline" id="line-2522"><code>}</code></span>
<span class="codeline" id="line-2523"><code></code></span>
<span class="codeline" id="line-2524"><code>func (c *PipelineClient) getConnClient() *pipelineConnClient {</code></span>
<span class="codeline" id="line-2525"><code>	c.connClientsLock.Lock()</code></span>
<span class="codeline" id="line-2526"><code>	cc := c.getConnClientUnlocked()</code></span>
<span class="codeline" id="line-2527"><code>	c.connClientsLock.Unlock()</code></span>
<span class="codeline" id="line-2528"><code>	return cc</code></span>
<span class="codeline" id="line-2529"><code>}</code></span>
<span class="codeline" id="line-2530"><code></code></span>
<span class="codeline" id="line-2531"><code>func (c *PipelineClient) getConnClientUnlocked() *pipelineConnClient {</code></span>
<span class="codeline" id="line-2532"><code>	if len(c.connClients) == 0 {</code></span>
<span class="codeline" id="line-2533"><code>		return c.newConnClient()</code></span>
<span class="codeline" id="line-2534"><code>	}</code></span>
<span class="codeline" id="line-2535"><code></code></span>
<span class="codeline" id="line-2536"><code>	// Return the client with the minimum number of pending requests.</code></span>
<span class="codeline" id="line-2537"><code>	minCC := c.connClients[0]</code></span>
<span class="codeline" id="line-2538"><code>	minReqs := minCC.PendingRequests()</code></span>
<span class="codeline" id="line-2539"><code>	if minReqs == 0 {</code></span>
<span class="codeline" id="line-2540"><code>		return minCC</code></span>
<span class="codeline" id="line-2541"><code>	}</code></span>
<span class="codeline" id="line-2542"><code>	for i := 1; i &lt; len(c.connClients); i++ {</code></span>
<span class="codeline" id="line-2543"><code>		cc := c.connClients[i]</code></span>
<span class="codeline" id="line-2544"><code>		reqs := cc.PendingRequests()</code></span>
<span class="codeline" id="line-2545"><code>		if reqs == 0 {</code></span>
<span class="codeline" id="line-2546"><code>			return cc</code></span>
<span class="codeline" id="line-2547"><code>		}</code></span>
<span class="codeline" id="line-2548"><code>		if reqs &lt; minReqs {</code></span>
<span class="codeline" id="line-2549"><code>			minCC = cc</code></span>
<span class="codeline" id="line-2550"><code>			minReqs = reqs</code></span>
<span class="codeline" id="line-2551"><code>		}</code></span>
<span class="codeline" id="line-2552"><code>	}</code></span>
<span class="codeline" id="line-2553"><code></code></span>
<span class="codeline" id="line-2554"><code>	maxConns := c.MaxConns</code></span>
<span class="codeline" id="line-2555"><code>	if maxConns &lt;= 0 {</code></span>
<span class="codeline" id="line-2556"><code>		maxConns = 1</code></span>
<span class="codeline" id="line-2557"><code>	}</code></span>
<span class="codeline" id="line-2558"><code>	if len(c.connClients) &lt; maxConns {</code></span>
<span class="codeline" id="line-2559"><code>		return c.newConnClient()</code></span>
<span class="codeline" id="line-2560"><code>	}</code></span>
<span class="codeline" id="line-2561"><code>	return minCC</code></span>
<span class="codeline" id="line-2562"><code>}</code></span>
<span class="codeline" id="line-2563"><code></code></span>
<span class="codeline" id="line-2564"><code>func (c *PipelineClient) newConnClient() *pipelineConnClient {</code></span>
<span class="codeline" id="line-2565"><code>	cc := &amp;pipelineConnClient{</code></span>
<span class="codeline" id="line-2566"><code>		Addr:                          c.Addr,</code></span>
<span class="codeline" id="line-2567"><code>		Name:                          c.Name,</code></span>
<span class="codeline" id="line-2568"><code>		NoDefaultUserAgentHeader:      c.NoDefaultUserAgentHeader,</code></span>
<span class="codeline" id="line-2569"><code>		MaxPendingRequests:            c.MaxPendingRequests,</code></span>
<span class="codeline" id="line-2570"><code>		MaxBatchDelay:                 c.MaxBatchDelay,</code></span>
<span class="codeline" id="line-2571"><code>		Dial:                          c.Dial,</code></span>
<span class="codeline" id="line-2572"><code>		DialDualStack:                 c.DialDualStack,</code></span>
<span class="codeline" id="line-2573"><code>		DisableHeaderNamesNormalizing: c.DisableHeaderNamesNormalizing,</code></span>
<span class="codeline" id="line-2574"><code>		DisablePathNormalizing:        c.DisablePathNormalizing,</code></span>
<span class="codeline" id="line-2575"><code>		IsTLS:                         c.IsTLS,</code></span>
<span class="codeline" id="line-2576"><code>		TLSConfig:                     c.TLSConfig,</code></span>
<span class="codeline" id="line-2577"><code>		MaxIdleConnDuration:           c.MaxIdleConnDuration,</code></span>
<span class="codeline" id="line-2578"><code>		ReadBufferSize:                c.ReadBufferSize,</code></span>
<span class="codeline" id="line-2579"><code>		WriteBufferSize:               c.WriteBufferSize,</code></span>
<span class="codeline" id="line-2580"><code>		ReadTimeout:                   c.ReadTimeout,</code></span>
<span class="codeline" id="line-2581"><code>		WriteTimeout:                  c.WriteTimeout,</code></span>
<span class="codeline" id="line-2582"><code>		Logger:                        c.Logger,</code></span>
<span class="codeline" id="line-2583"><code>	}</code></span>
<span class="codeline" id="line-2584"><code>	c.connClients = append(c.connClients, cc)</code></span>
<span class="codeline" id="line-2585"><code>	return cc</code></span>
<span class="codeline" id="line-2586"><code>}</code></span>
<span class="codeline" id="line-2587"><code></code></span>
<span class="codeline" id="line-2588"><code>// ErrPipelineOverflow may be returned from PipelineClient.Do*</code></span>
<span class="codeline" id="line-2589"><code>// if the requests' queue is overflowed.</code></span>
<span class="codeline" id="line-2590"><code>var ErrPipelineOverflow = errors.New("pipelined requests' queue has been overflowed. Increase MaxConns and/or MaxPendingRequests")</code></span>
<span class="codeline" id="line-2591"><code></code></span>
<span class="codeline" id="line-2592"><code>// DefaultMaxPendingRequests is the default value</code></span>
<span class="codeline" id="line-2593"><code>// for PipelineClient.MaxPendingRequests.</code></span>
<span class="codeline" id="line-2594"><code>const DefaultMaxPendingRequests = 1024</code></span>
<span class="codeline" id="line-2595"><code></code></span>
<span class="codeline" id="line-2596"><code>func (c *pipelineConnClient) init() {</code></span>
<span class="codeline" id="line-2597"><code>	c.chLock.Lock()</code></span>
<span class="codeline" id="line-2598"><code>	if c.chR == nil {</code></span>
<span class="codeline" id="line-2599"><code>		maxPendingRequests := c.MaxPendingRequests</code></span>
<span class="codeline" id="line-2600"><code>		if maxPendingRequests &lt;= 0 {</code></span>
<span class="codeline" id="line-2601"><code>			maxPendingRequests = DefaultMaxPendingRequests</code></span>
<span class="codeline" id="line-2602"><code>		}</code></span>
<span class="codeline" id="line-2603"><code>		c.chR = make(chan *pipelineWork, maxPendingRequests)</code></span>
<span class="codeline" id="line-2604"><code>		if c.chW == nil {</code></span>
<span class="codeline" id="line-2605"><code>			c.chW = make(chan *pipelineWork, maxPendingRequests)</code></span>
<span class="codeline" id="line-2606"><code>		}</code></span>
<span class="codeline" id="line-2607"><code>		go func() {</code></span>
<span class="codeline" id="line-2608"><code>			// Keep restarting the worker if it fails (connection errors for example).</code></span>
<span class="codeline" id="line-2609"><code>			for {</code></span>
<span class="codeline" id="line-2610"><code>				if err := c.worker(); err != nil {</code></span>
<span class="codeline" id="line-2611"><code>					c.logger().Printf("error in PipelineClient(%q): %v", c.Addr, err)</code></span>
<span class="codeline" id="line-2612"><code>					if netErr, ok := err.(net.Error); ok &amp;&amp; netErr.Timeout() {</code></span>
<span class="codeline" id="line-2613"><code>						// Throttle client reconnections on timeout errors</code></span>
<span class="codeline" id="line-2614"><code>						time.Sleep(time.Second)</code></span>
<span class="codeline" id="line-2615"><code>					}</code></span>
<span class="codeline" id="line-2616"><code>				} else {</code></span>
<span class="codeline" id="line-2617"><code>					c.chLock.Lock()</code></span>
<span class="codeline" id="line-2618"><code>					stop := len(c.chR) == 0 &amp;&amp; len(c.chW) == 0</code></span>
<span class="codeline" id="line-2619"><code>					if !stop {</code></span>
<span class="codeline" id="line-2620"><code>						c.chR = nil</code></span>
<span class="codeline" id="line-2621"><code>						c.chW = nil</code></span>
<span class="codeline" id="line-2622"><code>					}</code></span>
<span class="codeline" id="line-2623"><code>					c.chLock.Unlock()</code></span>
<span class="codeline" id="line-2624"><code></code></span>
<span class="codeline" id="line-2625"><code>					if stop {</code></span>
<span class="codeline" id="line-2626"><code>						break</code></span>
<span class="codeline" id="line-2627"><code>					}</code></span>
<span class="codeline" id="line-2628"><code>				}</code></span>
<span class="codeline" id="line-2629"><code>			}</code></span>
<span class="codeline" id="line-2630"><code>		}()</code></span>
<span class="codeline" id="line-2631"><code>	}</code></span>
<span class="codeline" id="line-2632"><code>	c.chLock.Unlock()</code></span>
<span class="codeline" id="line-2633"><code>}</code></span>
<span class="codeline" id="line-2634"><code></code></span>
<span class="codeline" id="line-2635"><code>func (c *pipelineConnClient) worker() error {</code></span>
<span class="codeline" id="line-2636"><code>	tlsConfig := c.cachedTLSConfig()</code></span>
<span class="codeline" id="line-2637"><code>	conn, err := dialAddr(c.Addr, c.Dial, nil, c.DialDualStack, c.IsTLS, tlsConfig, 0, c.WriteTimeout)</code></span>
<span class="codeline" id="line-2638"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2639"><code>		return err</code></span>
<span class="codeline" id="line-2640"><code>	}</code></span>
<span class="codeline" id="line-2641"><code></code></span>
<span class="codeline" id="line-2642"><code>	// Start reader and writer</code></span>
<span class="codeline" id="line-2643"><code>	stopW := make(chan struct{})</code></span>
<span class="codeline" id="line-2644"><code>	doneW := make(chan error)</code></span>
<span class="codeline" id="line-2645"><code>	go func() {</code></span>
<span class="codeline" id="line-2646"><code>		doneW &lt;- c.writer(conn, stopW)</code></span>
<span class="codeline" id="line-2647"><code>	}()</code></span>
<span class="codeline" id="line-2648"><code>	stopR := make(chan struct{})</code></span>
<span class="codeline" id="line-2649"><code>	doneR := make(chan error)</code></span>
<span class="codeline" id="line-2650"><code>	go func() {</code></span>
<span class="codeline" id="line-2651"><code>		doneR &lt;- c.reader(conn, stopR)</code></span>
<span class="codeline" id="line-2652"><code>	}()</code></span>
<span class="codeline" id="line-2653"><code></code></span>
<span class="codeline" id="line-2654"><code>	// Wait until reader and writer are stopped</code></span>
<span class="codeline" id="line-2655"><code>	select {</code></span>
<span class="codeline" id="line-2656"><code>	case err = &lt;-doneW:</code></span>
<span class="codeline" id="line-2657"><code>		conn.Close()</code></span>
<span class="codeline" id="line-2658"><code>		close(stopR)</code></span>
<span class="codeline" id="line-2659"><code>		&lt;-doneR</code></span>
<span class="codeline" id="line-2660"><code>	case err = &lt;-doneR:</code></span>
<span class="codeline" id="line-2661"><code>		conn.Close()</code></span>
<span class="codeline" id="line-2662"><code>		close(stopW)</code></span>
<span class="codeline" id="line-2663"><code>		&lt;-doneW</code></span>
<span class="codeline" id="line-2664"><code>	}</code></span>
<span class="codeline" id="line-2665"><code></code></span>
<span class="codeline" id="line-2666"><code>	// Notify pending readers</code></span>
<span class="codeline" id="line-2667"><code>	for len(c.chR) &gt; 0 {</code></span>
<span class="codeline" id="line-2668"><code>		w := &lt;-c.chR</code></span>
<span class="codeline" id="line-2669"><code>		w.err = errPipelineConnStopped</code></span>
<span class="codeline" id="line-2670"><code>		w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2671"><code>	}</code></span>
<span class="codeline" id="line-2672"><code></code></span>
<span class="codeline" id="line-2673"><code>	return err</code></span>
<span class="codeline" id="line-2674"><code>}</code></span>
<span class="codeline" id="line-2675"><code></code></span>
<span class="codeline" id="line-2676"><code>func (c *pipelineConnClient) cachedTLSConfig() *tls.Config {</code></span>
<span class="codeline" id="line-2677"><code>	if !c.IsTLS {</code></span>
<span class="codeline" id="line-2678"><code>		return nil</code></span>
<span class="codeline" id="line-2679"><code>	}</code></span>
<span class="codeline" id="line-2680"><code></code></span>
<span class="codeline" id="line-2681"><code>	c.tlsConfigLock.Lock()</code></span>
<span class="codeline" id="line-2682"><code>	cfg := c.tlsConfig</code></span>
<span class="codeline" id="line-2683"><code>	if cfg == nil {</code></span>
<span class="codeline" id="line-2684"><code>		cfg = newClientTLSConfig(c.TLSConfig, c.Addr)</code></span>
<span class="codeline" id="line-2685"><code>		c.tlsConfig = cfg</code></span>
<span class="codeline" id="line-2686"><code>	}</code></span>
<span class="codeline" id="line-2687"><code>	c.tlsConfigLock.Unlock()</code></span>
<span class="codeline" id="line-2688"><code></code></span>
<span class="codeline" id="line-2689"><code>	return cfg</code></span>
<span class="codeline" id="line-2690"><code>}</code></span>
<span class="codeline" id="line-2691"><code></code></span>
<span class="codeline" id="line-2692"><code>func (c *pipelineConnClient) writer(conn net.Conn, stopCh &lt;-chan struct{}) error {</code></span>
<span class="codeline" id="line-2693"><code>	writeBufferSize := c.WriteBufferSize</code></span>
<span class="codeline" id="line-2694"><code>	if writeBufferSize &lt;= 0 {</code></span>
<span class="codeline" id="line-2695"><code>		writeBufferSize = defaultWriteBufferSize</code></span>
<span class="codeline" id="line-2696"><code>	}</code></span>
<span class="codeline" id="line-2697"><code>	bw := bufio.NewWriterSize(conn, writeBufferSize)</code></span>
<span class="codeline" id="line-2698"><code>	defer bw.Flush()</code></span>
<span class="codeline" id="line-2699"><code>	chR := c.chR</code></span>
<span class="codeline" id="line-2700"><code>	chW := c.chW</code></span>
<span class="codeline" id="line-2701"><code>	writeTimeout := c.WriteTimeout</code></span>
<span class="codeline" id="line-2702"><code></code></span>
<span class="codeline" id="line-2703"><code>	maxIdleConnDuration := c.MaxIdleConnDuration</code></span>
<span class="codeline" id="line-2704"><code>	if maxIdleConnDuration &lt;= 0 {</code></span>
<span class="codeline" id="line-2705"><code>		maxIdleConnDuration = DefaultMaxIdleConnDuration</code></span>
<span class="codeline" id="line-2706"><code>	}</code></span>
<span class="codeline" id="line-2707"><code>	maxBatchDelay := c.MaxBatchDelay</code></span>
<span class="codeline" id="line-2708"><code></code></span>
<span class="codeline" id="line-2709"><code>	var (</code></span>
<span class="codeline" id="line-2710"><code>		stopTimer      = time.NewTimer(time.Hour)</code></span>
<span class="codeline" id="line-2711"><code>		flushTimer     = time.NewTimer(time.Hour)</code></span>
<span class="codeline" id="line-2712"><code>		flushTimerCh   &lt;-chan time.Time</code></span>
<span class="codeline" id="line-2713"><code>		instantTimerCh = make(chan time.Time)</code></span>
<span class="codeline" id="line-2714"><code></code></span>
<span class="codeline" id="line-2715"><code>		w   *pipelineWork</code></span>
<span class="codeline" id="line-2716"><code>		err error</code></span>
<span class="codeline" id="line-2717"><code>	)</code></span>
<span class="codeline" id="line-2718"><code>	close(instantTimerCh)</code></span>
<span class="codeline" id="line-2719"><code>	for {</code></span>
<span class="codeline" id="line-2720"><code>	againChW:</code></span>
<span class="codeline" id="line-2721"><code>		select {</code></span>
<span class="codeline" id="line-2722"><code>		case w = &lt;-chW:</code></span>
<span class="codeline" id="line-2723"><code>			// Fast path: len(chW) &gt; 0</code></span>
<span class="codeline" id="line-2724"><code>		default:</code></span>
<span class="codeline" id="line-2725"><code>			// Slow path</code></span>
<span class="codeline" id="line-2726"><code>			stopTimer.Reset(maxIdleConnDuration)</code></span>
<span class="codeline" id="line-2727"><code>			select {</code></span>
<span class="codeline" id="line-2728"><code>			case w = &lt;-chW:</code></span>
<span class="codeline" id="line-2729"><code>			case &lt;-stopTimer.C:</code></span>
<span class="codeline" id="line-2730"><code>				return nil</code></span>
<span class="codeline" id="line-2731"><code>			case &lt;-stopCh:</code></span>
<span class="codeline" id="line-2732"><code>				return nil</code></span>
<span class="codeline" id="line-2733"><code>			case &lt;-flushTimerCh:</code></span>
<span class="codeline" id="line-2734"><code>				if err = bw.Flush(); err != nil {</code></span>
<span class="codeline" id="line-2735"><code>					return err</code></span>
<span class="codeline" id="line-2736"><code>				}</code></span>
<span class="codeline" id="line-2737"><code>				flushTimerCh = nil</code></span>
<span class="codeline" id="line-2738"><code>				goto againChW</code></span>
<span class="codeline" id="line-2739"><code>			}</code></span>
<span class="codeline" id="line-2740"><code>		}</code></span>
<span class="codeline" id="line-2741"><code></code></span>
<span class="codeline" id="line-2742"><code>		if !w.deadline.IsZero() &amp;&amp; time.Since(w.deadline) &gt;= 0 {</code></span>
<span class="codeline" id="line-2743"><code>			w.err = ErrTimeout</code></span>
<span class="codeline" id="line-2744"><code>			w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2745"><code>			continue</code></span>
<span class="codeline" id="line-2746"><code>		}</code></span>
<span class="codeline" id="line-2747"><code></code></span>
<span class="codeline" id="line-2748"><code>		w.resp.parseNetConn(conn)</code></span>
<span class="codeline" id="line-2749"><code></code></span>
<span class="codeline" id="line-2750"><code>		if writeTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2751"><code>			// Set Deadline every time, since golang has fixed the performance issue</code></span>
<span class="codeline" id="line-2752"><code>			// See https://github.com/golang/go/issues/15133#issuecomment-271571395 for details</code></span>
<span class="codeline" id="line-2753"><code>			currentTime := time.Now()</code></span>
<span class="codeline" id="line-2754"><code>			if err = conn.SetWriteDeadline(currentTime.Add(writeTimeout)); err != nil {</code></span>
<span class="codeline" id="line-2755"><code>				w.err = err</code></span>
<span class="codeline" id="line-2756"><code>				w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2757"><code>				return err</code></span>
<span class="codeline" id="line-2758"><code>			}</code></span>
<span class="codeline" id="line-2759"><code>		}</code></span>
<span class="codeline" id="line-2760"><code>		if err = w.req.Write(bw); err != nil {</code></span>
<span class="codeline" id="line-2761"><code>			w.err = err</code></span>
<span class="codeline" id="line-2762"><code>			w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2763"><code>			return err</code></span>
<span class="codeline" id="line-2764"><code>		}</code></span>
<span class="codeline" id="line-2765"><code>		if flushTimerCh == nil &amp;&amp; (len(chW) == 0 || len(chR) == cap(chR)) {</code></span>
<span class="codeline" id="line-2766"><code>			if maxBatchDelay &gt; 0 {</code></span>
<span class="codeline" id="line-2767"><code>				flushTimer.Reset(maxBatchDelay)</code></span>
<span class="codeline" id="line-2768"><code>				flushTimerCh = flushTimer.C</code></span>
<span class="codeline" id="line-2769"><code>			} else {</code></span>
<span class="codeline" id="line-2770"><code>				flushTimerCh = instantTimerCh</code></span>
<span class="codeline" id="line-2771"><code>			}</code></span>
<span class="codeline" id="line-2772"><code>		}</code></span>
<span class="codeline" id="line-2773"><code></code></span>
<span class="codeline" id="line-2774"><code>	againChR:</code></span>
<span class="codeline" id="line-2775"><code>		select {</code></span>
<span class="codeline" id="line-2776"><code>		case chR &lt;- w:</code></span>
<span class="codeline" id="line-2777"><code>			// Fast path: len(chR) &lt; cap(chR)</code></span>
<span class="codeline" id="line-2778"><code>		default:</code></span>
<span class="codeline" id="line-2779"><code>			// Slow path</code></span>
<span class="codeline" id="line-2780"><code>			select {</code></span>
<span class="codeline" id="line-2781"><code>			case chR &lt;- w:</code></span>
<span class="codeline" id="line-2782"><code>			case &lt;-stopCh:</code></span>
<span class="codeline" id="line-2783"><code>				w.err = errPipelineConnStopped</code></span>
<span class="codeline" id="line-2784"><code>				w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2785"><code>				return nil</code></span>
<span class="codeline" id="line-2786"><code>			case &lt;-flushTimerCh:</code></span>
<span class="codeline" id="line-2787"><code>				if err = bw.Flush(); err != nil {</code></span>
<span class="codeline" id="line-2788"><code>					w.err = err</code></span>
<span class="codeline" id="line-2789"><code>					w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2790"><code>					return err</code></span>
<span class="codeline" id="line-2791"><code>				}</code></span>
<span class="codeline" id="line-2792"><code>				flushTimerCh = nil</code></span>
<span class="codeline" id="line-2793"><code>				goto againChR</code></span>
<span class="codeline" id="line-2794"><code>			}</code></span>
<span class="codeline" id="line-2795"><code>		}</code></span>
<span class="codeline" id="line-2796"><code>	}</code></span>
<span class="codeline" id="line-2797"><code>}</code></span>
<span class="codeline" id="line-2798"><code></code></span>
<span class="codeline" id="line-2799"><code>func (c *pipelineConnClient) reader(conn net.Conn, stopCh &lt;-chan struct{}) error {</code></span>
<span class="codeline" id="line-2800"><code>	readBufferSize := c.ReadBufferSize</code></span>
<span class="codeline" id="line-2801"><code>	if readBufferSize &lt;= 0 {</code></span>
<span class="codeline" id="line-2802"><code>		readBufferSize = defaultReadBufferSize</code></span>
<span class="codeline" id="line-2803"><code>	}</code></span>
<span class="codeline" id="line-2804"><code>	br := bufio.NewReaderSize(conn, readBufferSize)</code></span>
<span class="codeline" id="line-2805"><code>	chR := c.chR</code></span>
<span class="codeline" id="line-2806"><code>	readTimeout := c.ReadTimeout</code></span>
<span class="codeline" id="line-2807"><code></code></span>
<span class="codeline" id="line-2808"><code>	var (</code></span>
<span class="codeline" id="line-2809"><code>		w   *pipelineWork</code></span>
<span class="codeline" id="line-2810"><code>		err error</code></span>
<span class="codeline" id="line-2811"><code>	)</code></span>
<span class="codeline" id="line-2812"><code>	for {</code></span>
<span class="codeline" id="line-2813"><code>		select {</code></span>
<span class="codeline" id="line-2814"><code>		case w = &lt;-chR:</code></span>
<span class="codeline" id="line-2815"><code>			// Fast path: len(chR) &gt; 0</code></span>
<span class="codeline" id="line-2816"><code>		default:</code></span>
<span class="codeline" id="line-2817"><code>			// Slow path</code></span>
<span class="codeline" id="line-2818"><code>			select {</code></span>
<span class="codeline" id="line-2819"><code>			case w = &lt;-chR:</code></span>
<span class="codeline" id="line-2820"><code>			case &lt;-stopCh:</code></span>
<span class="codeline" id="line-2821"><code>				return nil</code></span>
<span class="codeline" id="line-2822"><code>			}</code></span>
<span class="codeline" id="line-2823"><code>		}</code></span>
<span class="codeline" id="line-2824"><code></code></span>
<span class="codeline" id="line-2825"><code>		if readTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2826"><code>			// Set Deadline every time, since golang has fixed the performance issue</code></span>
<span class="codeline" id="line-2827"><code>			// See https://github.com/golang/go/issues/15133#issuecomment-271571395 for details</code></span>
<span class="codeline" id="line-2828"><code>			currentTime := time.Now()</code></span>
<span class="codeline" id="line-2829"><code>			if err = conn.SetReadDeadline(currentTime.Add(readTimeout)); err != nil {</code></span>
<span class="codeline" id="line-2830"><code>				w.err = err</code></span>
<span class="codeline" id="line-2831"><code>				w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2832"><code>				return err</code></span>
<span class="codeline" id="line-2833"><code>			}</code></span>
<span class="codeline" id="line-2834"><code>		}</code></span>
<span class="codeline" id="line-2835"><code>		if err = w.resp.Read(br); err != nil {</code></span>
<span class="codeline" id="line-2836"><code>			w.err = err</code></span>
<span class="codeline" id="line-2837"><code>			w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2838"><code>			return err</code></span>
<span class="codeline" id="line-2839"><code>		}</code></span>
<span class="codeline" id="line-2840"><code></code></span>
<span class="codeline" id="line-2841"><code>		w.done &lt;- struct{}{}</code></span>
<span class="codeline" id="line-2842"><code>	}</code></span>
<span class="codeline" id="line-2843"><code>}</code></span>
<span class="codeline" id="line-2844"><code></code></span>
<span class="codeline" id="line-2845"><code>func (c *pipelineConnClient) logger() Logger {</code></span>
<span class="codeline" id="line-2846"><code>	if c.Logger != nil {</code></span>
<span class="codeline" id="line-2847"><code>		return c.Logger</code></span>
<span class="codeline" id="line-2848"><code>	}</code></span>
<span class="codeline" id="line-2849"><code>	return defaultLogger</code></span>
<span class="codeline" id="line-2850"><code>}</code></span>
<span class="codeline" id="line-2851"><code></code></span>
<span class="codeline" id="line-2852"><code>// PendingRequests returns the current number of pending requests pipelined</code></span>
<span class="codeline" id="line-2853"><code>// to the server.</code></span>
<span class="codeline" id="line-2854"><code>//</code></span>
<span class="codeline" id="line-2855"><code>// This number may exceed MaxPendingRequests*MaxConns by up to two times, since</code></span>
<span class="codeline" id="line-2856"><code>// each connection to the server may keep up to MaxPendingRequests requests</code></span>
<span class="codeline" id="line-2857"><code>// in the queue before sending them to the server.</code></span>
<span class="codeline" id="line-2858"><code>//</code></span>
<span class="codeline" id="line-2859"><code>// This function may be used for balancing load among multiple PipelineClient</code></span>
<span class="codeline" id="line-2860"><code>// instances.</code></span>
<span class="codeline" id="line-2861"><code>func (c *PipelineClient) PendingRequests() int {</code></span>
<span class="codeline" id="line-2862"><code>	c.connClientsLock.Lock()</code></span>
<span class="codeline" id="line-2863"><code>	n := 0</code></span>
<span class="codeline" id="line-2864"><code>	for _, cc := range c.connClients {</code></span>
<span class="codeline" id="line-2865"><code>		n += cc.PendingRequests()</code></span>
<span class="codeline" id="line-2866"><code>	}</code></span>
<span class="codeline" id="line-2867"><code>	c.connClientsLock.Unlock()</code></span>
<span class="codeline" id="line-2868"><code>	return n</code></span>
<span class="codeline" id="line-2869"><code>}</code></span>
<span class="codeline" id="line-2870"><code></code></span>
<span class="codeline" id="line-2871"><code>func (c *pipelineConnClient) PendingRequests() int {</code></span>
<span class="codeline" id="line-2872"><code>	c.init()</code></span>
<span class="codeline" id="line-2873"><code></code></span>
<span class="codeline" id="line-2874"><code>	c.chLock.Lock()</code></span>
<span class="codeline" id="line-2875"><code>	n := len(c.chR) + len(c.chW)</code></span>
<span class="codeline" id="line-2876"><code>	c.chLock.Unlock()</code></span>
<span class="codeline" id="line-2877"><code>	return n</code></span>
<span class="codeline" id="line-2878"><code>}</code></span>
<span class="codeline" id="line-2879"><code></code></span>
<span class="codeline" id="line-2880"><code>var errPipelineConnStopped = errors.New("pipeline connection has been stopped")</code></span>
<span class="codeline" id="line-2881"><code></code></span>
<span class="codeline" id="line-2882"><code>var DefaultTransport RoundTripper = &amp;transport{}</code></span>
<span class="codeline" id="line-2883"><code></code></span>
<span class="codeline" id="line-2884"><code>type transport struct{}</code></span>
<span class="codeline" id="line-2885"><code></code></span>
<span class="codeline" id="line-2886"><code>func (t *transport) RoundTrip(hc *HostClient, req *Request, resp *Response) (retry bool, err error) {</code></span>
<span class="codeline" id="line-2887"><code>	customSkipBody := resp.SkipBody</code></span>
<span class="codeline" id="line-2888"><code>	customStreamBody := resp.StreamBody</code></span>
<span class="codeline" id="line-2889"><code></code></span>
<span class="codeline" id="line-2890"><code>	var deadline time.Time</code></span>
<span class="codeline" id="line-2891"><code>	if req.timeout &gt; 0 {</code></span>
<span class="codeline" id="line-2892"><code>		deadline = time.Now().Add(req.timeout)</code></span>
<span class="codeline" id="line-2893"><code>	}</code></span>
<span class="codeline" id="line-2894"><code></code></span>
<span class="codeline" id="line-2895"><code>	cc, err := hc.acquireConn(req.timeout, req.ConnectionClose())</code></span>
<span class="codeline" id="line-2896"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2897"><code>		return false, err</code></span>
<span class="codeline" id="line-2898"><code>	}</code></span>
<span class="codeline" id="line-2899"><code>	conn := cc.c</code></span>
<span class="codeline" id="line-2900"><code></code></span>
<span class="codeline" id="line-2901"><code>	resp.parseNetConn(conn)</code></span>
<span class="codeline" id="line-2902"><code></code></span>
<span class="codeline" id="line-2903"><code>	writeDeadline := deadline</code></span>
<span class="codeline" id="line-2904"><code>	if hc.WriteTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2905"><code>		tmpWriteDeadline := time.Now().Add(hc.WriteTimeout)</code></span>
<span class="codeline" id="line-2906"><code>		if writeDeadline.IsZero() || tmpWriteDeadline.Before(writeDeadline) {</code></span>
<span class="codeline" id="line-2907"><code>			writeDeadline = tmpWriteDeadline</code></span>
<span class="codeline" id="line-2908"><code>		}</code></span>
<span class="codeline" id="line-2909"><code>	}</code></span>
<span class="codeline" id="line-2910"><code></code></span>
<span class="codeline" id="line-2911"><code>	if err = conn.SetWriteDeadline(writeDeadline); err != nil {</code></span>
<span class="codeline" id="line-2912"><code>		hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2913"><code>		return true, err</code></span>
<span class="codeline" id="line-2914"><code>	}</code></span>
<span class="codeline" id="line-2915"><code></code></span>
<span class="codeline" id="line-2916"><code>	resetConnection := false</code></span>
<span class="codeline" id="line-2917"><code>	if hc.MaxConnDuration &gt; 0 &amp;&amp; time.Since(cc.createdTime) &gt; hc.MaxConnDuration &amp;&amp; !req.ConnectionClose() {</code></span>
<span class="codeline" id="line-2918"><code>		req.SetConnectionClose()</code></span>
<span class="codeline" id="line-2919"><code>		resetConnection = true</code></span>
<span class="codeline" id="line-2920"><code>	}</code></span>
<span class="codeline" id="line-2921"><code></code></span>
<span class="codeline" id="line-2922"><code>	bw := hc.acquireWriter(conn)</code></span>
<span class="codeline" id="line-2923"><code>	err = req.Write(bw)</code></span>
<span class="codeline" id="line-2924"><code></code></span>
<span class="codeline" id="line-2925"><code>	if resetConnection {</code></span>
<span class="codeline" id="line-2926"><code>		req.Header.ResetConnectionClose()</code></span>
<span class="codeline" id="line-2927"><code>	}</code></span>
<span class="codeline" id="line-2928"><code></code></span>
<span class="codeline" id="line-2929"><code>	if err == nil {</code></span>
<span class="codeline" id="line-2930"><code>		err = bw.Flush()</code></span>
<span class="codeline" id="line-2931"><code>	}</code></span>
<span class="codeline" id="line-2932"><code>	hc.releaseWriter(bw)</code></span>
<span class="codeline" id="line-2933"><code></code></span>
<span class="codeline" id="line-2934"><code>	// Return ErrTimeout on any timeout.</code></span>
<span class="codeline" id="line-2935"><code>	if x, ok := err.(interface{ Timeout() bool }); ok &amp;&amp; x.Timeout() {</code></span>
<span class="codeline" id="line-2936"><code>		err = ErrTimeout</code></span>
<span class="codeline" id="line-2937"><code>	}</code></span>
<span class="codeline" id="line-2938"><code></code></span>
<span class="codeline" id="line-2939"><code>	isConnRST := isConnectionReset(err)</code></span>
<span class="codeline" id="line-2940"><code>	if err != nil &amp;&amp; !isConnRST {</code></span>
<span class="codeline" id="line-2941"><code>		hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2942"><code>		return true, err</code></span>
<span class="codeline" id="line-2943"><code>	}</code></span>
<span class="codeline" id="line-2944"><code></code></span>
<span class="codeline" id="line-2945"><code>	readDeadline := deadline</code></span>
<span class="codeline" id="line-2946"><code>	if hc.ReadTimeout &gt; 0 {</code></span>
<span class="codeline" id="line-2947"><code>		tmpReadDeadline := time.Now().Add(hc.ReadTimeout)</code></span>
<span class="codeline" id="line-2948"><code>		if readDeadline.IsZero() || tmpReadDeadline.Before(readDeadline) {</code></span>
<span class="codeline" id="line-2949"><code>			readDeadline = tmpReadDeadline</code></span>
<span class="codeline" id="line-2950"><code>		}</code></span>
<span class="codeline" id="line-2951"><code>	}</code></span>
<span class="codeline" id="line-2952"><code></code></span>
<span class="codeline" id="line-2953"><code>	if err = conn.SetReadDeadline(readDeadline); err != nil {</code></span>
<span class="codeline" id="line-2954"><code>		hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2955"><code>		return true, err</code></span>
<span class="codeline" id="line-2956"><code>	}</code></span>
<span class="codeline" id="line-2957"><code></code></span>
<span class="codeline" id="line-2958"><code>	if customSkipBody || req.Header.IsHead() {</code></span>
<span class="codeline" id="line-2959"><code>		resp.SkipBody = true</code></span>
<span class="codeline" id="line-2960"><code>	}</code></span>
<span class="codeline" id="line-2961"><code>	if hc.DisableHeaderNamesNormalizing {</code></span>
<span class="codeline" id="line-2962"><code>		resp.Header.DisableNormalizing()</code></span>
<span class="codeline" id="line-2963"><code>	}</code></span>
<span class="codeline" id="line-2964"><code></code></span>
<span class="codeline" id="line-2965"><code>	br := hc.acquireReader(conn)</code></span>
<span class="codeline" id="line-2966"><code>	err = resp.ReadLimitBody(br, hc.MaxResponseBodySize)</code></span>
<span class="codeline" id="line-2967"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2968"><code>		hc.releaseReader(br)</code></span>
<span class="codeline" id="line-2969"><code>		hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2970"><code>		// Don't retry in case of ErrBodyTooLarge since we will just get the same again.</code></span>
<span class="codeline" id="line-2971"><code>		needRetry := err != ErrBodyTooLarge</code></span>
<span class="codeline" id="line-2972"><code>		return needRetry, err</code></span>
<span class="codeline" id="line-2973"><code>	}</code></span>
<span class="codeline" id="line-2974"><code></code></span>
<span class="codeline" id="line-2975"><code>	closeConn := resetConnection || req.ConnectionClose() || resp.ConnectionClose() || isConnRST</code></span>
<span class="codeline" id="line-2976"><code>	if customStreamBody &amp;&amp; resp.bodyStream != nil {</code></span>
<span class="codeline" id="line-2977"><code>		rbs := resp.bodyStream</code></span>
<span class="codeline" id="line-2978"><code>		resp.bodyStream = newCloseReader(rbs, func() error {</code></span>
<span class="codeline" id="line-2979"><code>			hc.releaseReader(br)</code></span>
<span class="codeline" id="line-2980"><code>			if r, ok := rbs.(*requestStream); ok {</code></span>
<span class="codeline" id="line-2981"><code>				releaseRequestStream(r)</code></span>
<span class="codeline" id="line-2982"><code>			}</code></span>
<span class="codeline" id="line-2983"><code>			if closeConn || resp.ConnectionClose() {</code></span>
<span class="codeline" id="line-2984"><code>				hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2985"><code>			} else {</code></span>
<span class="codeline" id="line-2986"><code>				hc.releaseConn(cc)</code></span>
<span class="codeline" id="line-2987"><code>			}</code></span>
<span class="codeline" id="line-2988"><code>			return nil</code></span>
<span class="codeline" id="line-2989"><code>		})</code></span>
<span class="codeline" id="line-2990"><code>		return false, nil</code></span>
<span class="codeline" id="line-2991"><code>	} else {</code></span>
<span class="codeline" id="line-2992"><code>		hc.releaseReader(br)</code></span>
<span class="codeline" id="line-2993"><code>	}</code></span>
<span class="codeline" id="line-2994"><code></code></span>
<span class="codeline" id="line-2995"><code>	if closeConn {</code></span>
<span class="codeline" id="line-2996"><code>		hc.closeConn(cc)</code></span>
<span class="codeline" id="line-2997"><code>	} else {</code></span>
<span class="codeline" id="line-2998"><code>		hc.releaseConn(cc)</code></span>
<span class="codeline" id="line-2999"><code>	}</code></span>
<span class="codeline" id="line-3000"><code>	return false, nil</code></span>
<span class="codeline" id="line-3001"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>