<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: parser.go in package github.com/swaggo/swag</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	parser.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/github.com/swaggo/swag.html">github.com/swaggo/swag</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package swag</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"context"</code></span>
<span class="codeline" id="line-5"><code>	"encoding/json"</code></span>
<span class="codeline" id="line-6"><code>	"errors"</code></span>
<span class="codeline" id="line-7"><code>	"fmt"</code></span>
<span class="codeline" id="line-8"><code>	"go/ast"</code></span>
<span class="codeline" id="line-9"><code>	"go/build"</code></span>
<span class="codeline" id="line-10"><code>	goparser "go/parser"</code></span>
<span class="codeline" id="line-11"><code>	"go/token"</code></span>
<span class="codeline" id="line-12"><code>	"log"</code></span>
<span class="codeline" id="line-13"><code>	"net/http"</code></span>
<span class="codeline" id="line-14"><code>	"os"</code></span>
<span class="codeline" id="line-15"><code>	"os/exec"</code></span>
<span class="codeline" id="line-16"><code>	"path/filepath"</code></span>
<span class="codeline" id="line-17"><code>	"reflect"</code></span>
<span class="codeline" id="line-18"><code>	"sort"</code></span>
<span class="codeline" id="line-19"><code>	"strconv"</code></span>
<span class="codeline" id="line-20"><code>	"strings"</code></span>
<span class="codeline" id="line-21"><code></code></span>
<span class="codeline" id="line-22"><code>	"github.com/KyleBanks/depth"</code></span>
<span class="codeline" id="line-23"><code>	"github.com/go-openapi/spec"</code></span>
<span class="codeline" id="line-24"><code>)</code></span>
<span class="codeline" id="line-25"><code></code></span>
<span class="codeline" id="line-26"><code>const (</code></span>
<span class="codeline" id="line-27"><code>	// CamelCase indicates using CamelCase strategy for struct field.</code></span>
<span class="codeline" id="line-28"><code>	CamelCase = "camelcase"</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>	// PascalCase indicates using PascalCase strategy for struct field.</code></span>
<span class="codeline" id="line-31"><code>	PascalCase = "pascalcase"</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>	// SnakeCase indicates using SnakeCase strategy for struct field.</code></span>
<span class="codeline" id="line-34"><code>	SnakeCase = "snakecase"</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>	idAttr                  = "@id"</code></span>
<span class="codeline" id="line-37"><code>	acceptAttr              = "@accept"</code></span>
<span class="codeline" id="line-38"><code>	produceAttr             = "@produce"</code></span>
<span class="codeline" id="line-39"><code>	paramAttr               = "@param"</code></span>
<span class="codeline" id="line-40"><code>	successAttr             = "@success"</code></span>
<span class="codeline" id="line-41"><code>	failureAttr             = "@failure"</code></span>
<span class="codeline" id="line-42"><code>	responseAttr            = "@response"</code></span>
<span class="codeline" id="line-43"><code>	headerAttr              = "@header"</code></span>
<span class="codeline" id="line-44"><code>	tagsAttr                = "@tags"</code></span>
<span class="codeline" id="line-45"><code>	routerAttr              = "@router"</code></span>
<span class="codeline" id="line-46"><code>	deprecatedRouterAttr    = "@deprecatedrouter"</code></span>
<span class="codeline" id="line-47"><code>	summaryAttr             = "@summary"</code></span>
<span class="codeline" id="line-48"><code>	deprecatedAttr          = "@deprecated"</code></span>
<span class="codeline" id="line-49"><code>	securityAttr            = "@security"</code></span>
<span class="codeline" id="line-50"><code>	titleAttr               = "@title"</code></span>
<span class="codeline" id="line-51"><code>	conNameAttr             = "@contact.name"</code></span>
<span class="codeline" id="line-52"><code>	conURLAttr              = "@contact.url"</code></span>
<span class="codeline" id="line-53"><code>	conEmailAttr            = "@contact.email"</code></span>
<span class="codeline" id="line-54"><code>	licNameAttr             = "@license.name"</code></span>
<span class="codeline" id="line-55"><code>	licURLAttr              = "@license.url"</code></span>
<span class="codeline" id="line-56"><code>	versionAttr             = "@version"</code></span>
<span class="codeline" id="line-57"><code>	descriptionAttr         = "@description"</code></span>
<span class="codeline" id="line-58"><code>	descriptionMarkdownAttr = "@description.markdown"</code></span>
<span class="codeline" id="line-59"><code>	secBasicAttr            = "@securitydefinitions.basic"</code></span>
<span class="codeline" id="line-60"><code>	secAPIKeyAttr           = "@securitydefinitions.apikey"</code></span>
<span class="codeline" id="line-61"><code>	secApplicationAttr      = "@securitydefinitions.oauth2.application"</code></span>
<span class="codeline" id="line-62"><code>	secImplicitAttr         = "@securitydefinitions.oauth2.implicit"</code></span>
<span class="codeline" id="line-63"><code>	secPasswordAttr         = "@securitydefinitions.oauth2.password"</code></span>
<span class="codeline" id="line-64"><code>	secAccessCodeAttr       = "@securitydefinitions.oauth2.accesscode"</code></span>
<span class="codeline" id="line-65"><code>	tosAttr                 = "@termsofservice"</code></span>
<span class="codeline" id="line-66"><code>	extDocsDescAttr         = "@externaldocs.description"</code></span>
<span class="codeline" id="line-67"><code>	extDocsURLAttr          = "@externaldocs.url"</code></span>
<span class="codeline" id="line-68"><code>	xCodeSamplesAttr        = "@x-codesamples"</code></span>
<span class="codeline" id="line-69"><code>	scopeAttrPrefix         = "@scope."</code></span>
<span class="codeline" id="line-70"><code>	stateAttr               = "@state"</code></span>
<span class="codeline" id="line-71"><code>)</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>// ParseFlag determine what to parse</code></span>
<span class="codeline" id="line-74"><code>type ParseFlag int</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>const (</code></span>
<span class="codeline" id="line-77"><code>	// ParseNone parse nothing</code></span>
<span class="codeline" id="line-78"><code>	ParseNone ParseFlag = 0x00</code></span>
<span class="codeline" id="line-79"><code>	// ParseModels parse models</code></span>
<span class="codeline" id="line-80"><code>	ParseModels = 0x01</code></span>
<span class="codeline" id="line-81"><code>	// ParseOperations parse operations</code></span>
<span class="codeline" id="line-82"><code>	ParseOperations = 0x02</code></span>
<span class="codeline" id="line-83"><code>	// ParseAll parse operations and models</code></span>
<span class="codeline" id="line-84"><code>	ParseAll = ParseOperations | ParseModels</code></span>
<span class="codeline" id="line-85"><code>)</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>var (</code></span>
<span class="codeline" id="line-88"><code>	// ErrRecursiveParseStruct recursively parsing struct.</code></span>
<span class="codeline" id="line-89"><code>	ErrRecursiveParseStruct = errors.New("recursively parsing struct")</code></span>
<span class="codeline" id="line-90"><code></code></span>
<span class="codeline" id="line-91"><code>	// ErrFuncTypeField field type is func.</code></span>
<span class="codeline" id="line-92"><code>	ErrFuncTypeField = errors.New("field type is func")</code></span>
<span class="codeline" id="line-93"><code></code></span>
<span class="codeline" id="line-94"><code>	// ErrFailedConvertPrimitiveType Failed to convert for swag to interpretable type.</code></span>
<span class="codeline" id="line-95"><code>	ErrFailedConvertPrimitiveType = errors.New("swag property: failed convert primitive type")</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>	// ErrSkippedField .swaggo specifies field should be skipped.</code></span>
<span class="codeline" id="line-98"><code>	ErrSkippedField = errors.New("field is skipped by global overrides")</code></span>
<span class="codeline" id="line-99"><code>)</code></span>
<span class="codeline" id="line-100"><code></code></span>
<span class="codeline" id="line-101"><code>var allMethod = map[string]struct{}{</code></span>
<span class="codeline" id="line-102"><code>	http.MethodGet:     {},</code></span>
<span class="codeline" id="line-103"><code>	http.MethodPut:     {},</code></span>
<span class="codeline" id="line-104"><code>	http.MethodPost:    {},</code></span>
<span class="codeline" id="line-105"><code>	http.MethodDelete:  {},</code></span>
<span class="codeline" id="line-106"><code>	http.MethodOptions: {},</code></span>
<span class="codeline" id="line-107"><code>	http.MethodHead:    {},</code></span>
<span class="codeline" id="line-108"><code>	http.MethodPatch:   {},</code></span>
<span class="codeline" id="line-109"><code>}</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>// Parser implements a parser for Go source files.</code></span>
<span class="codeline" id="line-112"><code>type Parser struct {</code></span>
<span class="codeline" id="line-113"><code>	// swagger represents the root document object for the API specification</code></span>
<span class="codeline" id="line-114"><code>	swagger *spec.Swagger</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>	// packages store entities of APIs, definitions, file, package path etc.  and their relations</code></span>
<span class="codeline" id="line-117"><code>	packages *PackagesDefinitions</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>	// parsedSchemas store schemas which have been parsed from ast.TypeSpec</code></span>
<span class="codeline" id="line-120"><code>	parsedSchemas map[*TypeSpecDef]*Schema</code></span>
<span class="codeline" id="line-121"><code></code></span>
<span class="codeline" id="line-122"><code>	// outputSchemas store schemas which will be export to swagger</code></span>
<span class="codeline" id="line-123"><code>	outputSchemas map[*TypeSpecDef]*Schema</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>	// PropNamingStrategy naming strategy</code></span>
<span class="codeline" id="line-126"><code>	PropNamingStrategy string</code></span>
<span class="codeline" id="line-127"><code></code></span>
<span class="codeline" id="line-128"><code>	// ParseVendor parse vendor folder</code></span>
<span class="codeline" id="line-129"><code>	ParseVendor bool</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>	// ParseDependencies whether swag should be parse outside dependency folder: 0 none, 1 models, 2 operations, 3 all</code></span>
<span class="codeline" id="line-132"><code>	ParseDependency ParseFlag</code></span>
<span class="codeline" id="line-133"><code></code></span>
<span class="codeline" id="line-134"><code>	// ParseInternal whether swag should parse internal packages</code></span>
<span class="codeline" id="line-135"><code>	ParseInternal bool</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	// Strict whether swag should error or warn when it detects cases which are most likely user errors</code></span>
<span class="codeline" id="line-138"><code>	Strict bool</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	// RequiredByDefault set validation required for all fields by default</code></span>
<span class="codeline" id="line-141"><code>	RequiredByDefault bool</code></span>
<span class="codeline" id="line-142"><code></code></span>
<span class="codeline" id="line-143"><code>	// structStack stores full names of the structures that were already parsed or are being parsed now</code></span>
<span class="codeline" id="line-144"><code>	structStack []*TypeSpecDef</code></span>
<span class="codeline" id="line-145"><code></code></span>
<span class="codeline" id="line-146"><code>	// markdownFileDir holds the path to the folder, where markdown files are stored</code></span>
<span class="codeline" id="line-147"><code>	markdownFileDir string</code></span>
<span class="codeline" id="line-148"><code></code></span>
<span class="codeline" id="line-149"><code>	// codeExampleFilesDir holds path to the folder, where code example files are stored</code></span>
<span class="codeline" id="line-150"><code>	codeExampleFilesDir string</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>	// collectionFormatInQuery set the default collectionFormat otherwise then 'csv' for array in query params</code></span>
<span class="codeline" id="line-153"><code>	collectionFormatInQuery string</code></span>
<span class="codeline" id="line-154"><code></code></span>
<span class="codeline" id="line-155"><code>	// excludes excludes dirs and files in SearchDir</code></span>
<span class="codeline" id="line-156"><code>	excludes map[string]struct{}</code></span>
<span class="codeline" id="line-157"><code></code></span>
<span class="codeline" id="line-158"><code>	// packagePrefix is a list of package path prefixes, packages that do not</code></span>
<span class="codeline" id="line-159"><code>	// match any one of them will be excluded when searching.</code></span>
<span class="codeline" id="line-160"><code>	packagePrefix []string</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>	// tells parser to include only specific extension</code></span>
<span class="codeline" id="line-163"><code>	parseExtension string</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>	// debugging output goes here</code></span>
<span class="codeline" id="line-166"><code>	debug Debugger</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>	// fieldParserFactory create FieldParser</code></span>
<span class="codeline" id="line-169"><code>	fieldParserFactory FieldParserFactory</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>	// Overrides allows global replacements of types. A blank replacement will be skipped.</code></span>
<span class="codeline" id="line-172"><code>	Overrides map[string]string</code></span>
<span class="codeline" id="line-173"><code></code></span>
<span class="codeline" id="line-174"><code>	// parseGoList whether swag use go list to parse dependency</code></span>
<span class="codeline" id="line-175"><code>	parseGoList bool</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// tags to filter the APIs after</code></span>
<span class="codeline" id="line-178"><code>	tags map[string]struct{}</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	// HostState is the state of the host</code></span>
<span class="codeline" id="line-181"><code>	HostState string</code></span>
<span class="codeline" id="line-182"><code>}</code></span>
<span class="codeline" id="line-183"><code></code></span>
<span class="codeline" id="line-184"><code>// FieldParserFactory create FieldParser.</code></span>
<span class="codeline" id="line-185"><code>type FieldParserFactory func(ps *Parser, field *ast.Field) FieldParser</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>// FieldParser parse struct field.</code></span>
<span class="codeline" id="line-188"><code>type FieldParser interface {</code></span>
<span class="codeline" id="line-189"><code>	ShouldSkip() bool</code></span>
<span class="codeline" id="line-190"><code>	FieldName() (string, error)</code></span>
<span class="codeline" id="line-191"><code>	FormName() string</code></span>
<span class="codeline" id="line-192"><code>	HeaderName() string</code></span>
<span class="codeline" id="line-193"><code>	PathName() string</code></span>
<span class="codeline" id="line-194"><code>	CustomSchema() (*spec.Schema, error)</code></span>
<span class="codeline" id="line-195"><code>	ComplementSchema(schema *spec.Schema) error</code></span>
<span class="codeline" id="line-196"><code>	IsRequired() (bool, error)</code></span>
<span class="codeline" id="line-197"><code>}</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>// Debugger is the interface that wraps the basic Printf method.</code></span>
<span class="codeline" id="line-200"><code>type Debugger interface {</code></span>
<span class="codeline" id="line-201"><code>	Printf(format string, v ...interface{})</code></span>
<span class="codeline" id="line-202"><code>}</code></span>
<span class="codeline" id="line-203"><code></code></span>
<span class="codeline" id="line-204"><code>// New creates a new Parser with default properties.</code></span>
<span class="codeline" id="line-205"><code>func New(options ...func(*Parser)) *Parser {</code></span>
<span class="codeline" id="line-206"><code>	parser := &amp;Parser{</code></span>
<span class="codeline" id="line-207"><code>		swagger: &amp;spec.Swagger{</code></span>
<span class="codeline" id="line-208"><code>			SwaggerProps: spec.SwaggerProps{</code></span>
<span class="codeline" id="line-209"><code>				Info: &amp;spec.Info{</code></span>
<span class="codeline" id="line-210"><code>					InfoProps: spec.InfoProps{</code></span>
<span class="codeline" id="line-211"><code>						Contact: &amp;spec.ContactInfo{},</code></span>
<span class="codeline" id="line-212"><code>						License: nil,</code></span>
<span class="codeline" id="line-213"><code>					},</code></span>
<span class="codeline" id="line-214"><code>					VendorExtensible: spec.VendorExtensible{</code></span>
<span class="codeline" id="line-215"><code>						Extensions: spec.Extensions{},</code></span>
<span class="codeline" id="line-216"><code>					},</code></span>
<span class="codeline" id="line-217"><code>				},</code></span>
<span class="codeline" id="line-218"><code>				Paths: &amp;spec.Paths{</code></span>
<span class="codeline" id="line-219"><code>					Paths: make(map[string]spec.PathItem),</code></span>
<span class="codeline" id="line-220"><code>					VendorExtensible: spec.VendorExtensible{</code></span>
<span class="codeline" id="line-221"><code>						Extensions: nil,</code></span>
<span class="codeline" id="line-222"><code>					},</code></span>
<span class="codeline" id="line-223"><code>				},</code></span>
<span class="codeline" id="line-224"><code>				Definitions:         make(map[string]spec.Schema),</code></span>
<span class="codeline" id="line-225"><code>				SecurityDefinitions: make(map[string]*spec.SecurityScheme),</code></span>
<span class="codeline" id="line-226"><code>			},</code></span>
<span class="codeline" id="line-227"><code>			VendorExtensible: spec.VendorExtensible{</code></span>
<span class="codeline" id="line-228"><code>				Extensions: nil,</code></span>
<span class="codeline" id="line-229"><code>			},</code></span>
<span class="codeline" id="line-230"><code>		},</code></span>
<span class="codeline" id="line-231"><code>		packages:           NewPackagesDefinitions(),</code></span>
<span class="codeline" id="line-232"><code>		debug:              log.New(os.Stdout, "", log.LstdFlags),</code></span>
<span class="codeline" id="line-233"><code>		parsedSchemas:      make(map[*TypeSpecDef]*Schema),</code></span>
<span class="codeline" id="line-234"><code>		outputSchemas:      make(map[*TypeSpecDef]*Schema),</code></span>
<span class="codeline" id="line-235"><code>		excludes:           make(map[string]struct{}),</code></span>
<span class="codeline" id="line-236"><code>		tags:               make(map[string]struct{}),</code></span>
<span class="codeline" id="line-237"><code>		fieldParserFactory: newTagBaseFieldParser,</code></span>
<span class="codeline" id="line-238"><code>		Overrides:          make(map[string]string),</code></span>
<span class="codeline" id="line-239"><code>	}</code></span>
<span class="codeline" id="line-240"><code></code></span>
<span class="codeline" id="line-241"><code>	for _, option := range options {</code></span>
<span class="codeline" id="line-242"><code>		option(parser)</code></span>
<span class="codeline" id="line-243"><code>	}</code></span>
<span class="codeline" id="line-244"><code></code></span>
<span class="codeline" id="line-245"><code>	parser.packages.debug = parser.debug</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>	return parser</code></span>
<span class="codeline" id="line-248"><code>}</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>// SetParseDependency sets whether to parse the dependent packages.</code></span>
<span class="codeline" id="line-251"><code>func SetParseDependency(parseDependency int) func(*Parser) {</code></span>
<span class="codeline" id="line-252"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-253"><code>		p.ParseDependency = ParseFlag(parseDependency)</code></span>
<span class="codeline" id="line-254"><code>		if p.packages != nil {</code></span>
<span class="codeline" id="line-255"><code>			p.packages.parseDependency = p.ParseDependency</code></span>
<span class="codeline" id="line-256"><code>		}</code></span>
<span class="codeline" id="line-257"><code>	}</code></span>
<span class="codeline" id="line-258"><code>}</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>// SetMarkdownFileDirectory sets the directory to search for markdown files.</code></span>
<span class="codeline" id="line-261"><code>func SetMarkdownFileDirectory(directoryPath string) func(*Parser) {</code></span>
<span class="codeline" id="line-262"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-263"><code>		p.markdownFileDir = directoryPath</code></span>
<span class="codeline" id="line-264"><code>	}</code></span>
<span class="codeline" id="line-265"><code>}</code></span>
<span class="codeline" id="line-266"><code></code></span>
<span class="codeline" id="line-267"><code>// SetCodeExamplesDirectory sets the directory to search for code example files.</code></span>
<span class="codeline" id="line-268"><code>func SetCodeExamplesDirectory(directoryPath string) func(*Parser) {</code></span>
<span class="codeline" id="line-269"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-270"><code>		p.codeExampleFilesDir = directoryPath</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>}</code></span>
<span class="codeline" id="line-273"><code></code></span>
<span class="codeline" id="line-274"><code>// SetExcludedDirsAndFiles sets directories and files to be excluded when searching.</code></span>
<span class="codeline" id="line-275"><code>func SetExcludedDirsAndFiles(excludes string) func(*Parser) {</code></span>
<span class="codeline" id="line-276"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-277"><code>		for _, f := range strings.Split(excludes, ",") {</code></span>
<span class="codeline" id="line-278"><code>			f = strings.TrimSpace(f)</code></span>
<span class="codeline" id="line-279"><code>			if f != "" {</code></span>
<span class="codeline" id="line-280"><code>				f = filepath.Clean(f)</code></span>
<span class="codeline" id="line-281"><code>				p.excludes[f] = struct{}{}</code></span>
<span class="codeline" id="line-282"><code>			}</code></span>
<span class="codeline" id="line-283"><code>		}</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>}</code></span>
<span class="codeline" id="line-286"><code></code></span>
<span class="codeline" id="line-287"><code>// SetPackagePrefix sets a list of package path prefixes from a comma-separated</code></span>
<span class="codeline" id="line-288"><code>// string, packages that do not match any one of them will be excluded when</code></span>
<span class="codeline" id="line-289"><code>// searching.</code></span>
<span class="codeline" id="line-290"><code>func SetPackagePrefix(packagePrefix string) func(*Parser) {</code></span>
<span class="codeline" id="line-291"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-292"><code>		for _, f := range strings.Split(packagePrefix, ",") {</code></span>
<span class="codeline" id="line-293"><code>			f = strings.TrimSpace(f)</code></span>
<span class="codeline" id="line-294"><code>			if f != "" {</code></span>
<span class="codeline" id="line-295"><code>				p.packagePrefix = append(p.packagePrefix, f)</code></span>
<span class="codeline" id="line-296"><code>			}</code></span>
<span class="codeline" id="line-297"><code>		}</code></span>
<span class="codeline" id="line-298"><code>	}</code></span>
<span class="codeline" id="line-299"><code>}</code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>// SetTags sets the tags to be included</code></span>
<span class="codeline" id="line-302"><code>func SetTags(include string) func(*Parser) {</code></span>
<span class="codeline" id="line-303"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-304"><code>		for _, f := range strings.Split(include, ",") {</code></span>
<span class="codeline" id="line-305"><code>			f = strings.TrimSpace(f)</code></span>
<span class="codeline" id="line-306"><code>			if f != "" {</code></span>
<span class="codeline" id="line-307"><code>				p.tags[f] = struct{}{}</code></span>
<span class="codeline" id="line-308"><code>			}</code></span>
<span class="codeline" id="line-309"><code>		}</code></span>
<span class="codeline" id="line-310"><code>	}</code></span>
<span class="codeline" id="line-311"><code>}</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>// SetParseExtension parses only those operations which match given extension</code></span>
<span class="codeline" id="line-314"><code>func SetParseExtension(parseExtension string) func(*Parser) {</code></span>
<span class="codeline" id="line-315"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-316"><code>		p.parseExtension = parseExtension</code></span>
<span class="codeline" id="line-317"><code>	}</code></span>
<span class="codeline" id="line-318"><code>}</code></span>
<span class="codeline" id="line-319"><code></code></span>
<span class="codeline" id="line-320"><code>// SetStrict sets whether swag should error or warn when it detects cases which are most likely user errors.</code></span>
<span class="codeline" id="line-321"><code>func SetStrict(strict bool) func(*Parser) {</code></span>
<span class="codeline" id="line-322"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-323"><code>		p.Strict = strict</code></span>
<span class="codeline" id="line-324"><code>	}</code></span>
<span class="codeline" id="line-325"><code>}</code></span>
<span class="codeline" id="line-326"><code></code></span>
<span class="codeline" id="line-327"><code>// SetDebugger allows the use of user-defined implementations.</code></span>
<span class="codeline" id="line-328"><code>func SetDebugger(logger Debugger) func(parser *Parser) {</code></span>
<span class="codeline" id="line-329"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-330"><code>		if logger != nil {</code></span>
<span class="codeline" id="line-331"><code>			p.debug = logger</code></span>
<span class="codeline" id="line-332"><code>		}</code></span>
<span class="codeline" id="line-333"><code>	}</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>// SetFieldParserFactory allows the use of user-defined implementations.</code></span>
<span class="codeline" id="line-337"><code>func SetFieldParserFactory(factory FieldParserFactory) func(parser *Parser) {</code></span>
<span class="codeline" id="line-338"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-339"><code>		p.fieldParserFactory = factory</code></span>
<span class="codeline" id="line-340"><code>	}</code></span>
<span class="codeline" id="line-341"><code>}</code></span>
<span class="codeline" id="line-342"><code></code></span>
<span class="codeline" id="line-343"><code>// SetOverrides allows the use of user-defined global type overrides.</code></span>
<span class="codeline" id="line-344"><code>func SetOverrides(overrides map[string]string) func(parser *Parser) {</code></span>
<span class="codeline" id="line-345"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-346"><code>		for k, v := range overrides {</code></span>
<span class="codeline" id="line-347"><code>			p.Overrides[k] = v</code></span>
<span class="codeline" id="line-348"><code>		}</code></span>
<span class="codeline" id="line-349"><code>	}</code></span>
<span class="codeline" id="line-350"><code>}</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>// SetCollectionFormat set default collection format</code></span>
<span class="codeline" id="line-353"><code>func SetCollectionFormat(collectionFormat string) func(*Parser) {</code></span>
<span class="codeline" id="line-354"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-355"><code>		p.collectionFormatInQuery = collectionFormat</code></span>
<span class="codeline" id="line-356"><code>	}</code></span>
<span class="codeline" id="line-357"><code>}</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>// ParseUsingGoList sets whether swag use go list to parse dependency</code></span>
<span class="codeline" id="line-360"><code>func ParseUsingGoList(enabled bool) func(parser *Parser) {</code></span>
<span class="codeline" id="line-361"><code>	return func(p *Parser) {</code></span>
<span class="codeline" id="line-362"><code>		p.parseGoList = enabled</code></span>
<span class="codeline" id="line-363"><code>	}</code></span>
<span class="codeline" id="line-364"><code>}</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>// ParseAPI parses general api info for given searchDir and mainAPIFile.</code></span>
<span class="codeline" id="line-367"><code>func (parser *Parser) ParseAPI(searchDir string, mainAPIFile string, parseDepth int) error {</code></span>
<span class="codeline" id="line-368"><code>	return parser.ParseAPIMultiSearchDir([]string{searchDir}, mainAPIFile, parseDepth)</code></span>
<span class="codeline" id="line-369"><code>}</code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code>// skipPackageByPrefix returns true the given pkgpath does not match</code></span>
<span class="codeline" id="line-372"><code>// any user-defined package path prefixes.</code></span>
<span class="codeline" id="line-373"><code>func (parser *Parser) skipPackageByPrefix(pkgpath string) bool {</code></span>
<span class="codeline" id="line-374"><code>	if len(parser.packagePrefix) == 0 {</code></span>
<span class="codeline" id="line-375"><code>		return false</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code>	for _, prefix := range parser.packagePrefix {</code></span>
<span class="codeline" id="line-378"><code>		if strings.HasPrefix(pkgpath, prefix) {</code></span>
<span class="codeline" id="line-379"><code>			return false</code></span>
<span class="codeline" id="line-380"><code>		}</code></span>
<span class="codeline" id="line-381"><code>	}</code></span>
<span class="codeline" id="line-382"><code>	return true</code></span>
<span class="codeline" id="line-383"><code>}</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>// ParseAPIMultiSearchDir is like ParseAPI but for multiple search dirs.</code></span>
<span class="codeline" id="line-386"><code>func (parser *Parser) ParseAPIMultiSearchDir(searchDirs []string, mainAPIFile string, parseDepth int) error {</code></span>
<span class="codeline" id="line-387"><code>	for _, searchDir := range searchDirs {</code></span>
<span class="codeline" id="line-388"><code>		parser.debug.Printf("Generate general API Info, search dir:%s", searchDir)</code></span>
<span class="codeline" id="line-389"><code></code></span>
<span class="codeline" id="line-390"><code>		packageDir, err := getPkgName(searchDir)</code></span>
<span class="codeline" id="line-391"><code>		if err != nil {</code></span>
<span class="codeline" id="line-392"><code>			parser.debug.Printf("warning: failed to get package name in dir: %s, error: %s", searchDir, err.Error())</code></span>
<span class="codeline" id="line-393"><code>		}</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>		err = parser.getAllGoFileInfo(packageDir, searchDir)</code></span>
<span class="codeline" id="line-396"><code>		if err != nil {</code></span>
<span class="codeline" id="line-397"><code>			return err</code></span>
<span class="codeline" id="line-398"><code>		}</code></span>
<span class="codeline" id="line-399"><code>	}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>	absMainAPIFilePath, err := filepath.Abs(filepath.Join(searchDirs[0], mainAPIFile))</code></span>
<span class="codeline" id="line-402"><code>	if err != nil {</code></span>
<span class="codeline" id="line-403"><code>		return err</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code></code></span>
<span class="codeline" id="line-406"><code>	// Use 'go list' command instead of depth.Resolve()</code></span>
<span class="codeline" id="line-407"><code>	if parser.ParseDependency &gt; 0 {</code></span>
<span class="codeline" id="line-408"><code>		if parser.parseGoList {</code></span>
<span class="codeline" id="line-409"><code>			pkgs, err := listPackages(context.Background(), filepath.Dir(absMainAPIFilePath), nil, "-deps")</code></span>
<span class="codeline" id="line-410"><code>			if err != nil {</code></span>
<span class="codeline" id="line-411"><code>				return fmt.Errorf("pkg %s cannot find all dependencies, %s", filepath.Dir(absMainAPIFilePath), err)</code></span>
<span class="codeline" id="line-412"><code>			}</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>			length := len(pkgs)</code></span>
<span class="codeline" id="line-415"><code>			for i := 0; i &lt; length; i++ {</code></span>
<span class="codeline" id="line-416"><code>				err := parser.getAllGoFileInfoFromDepsByList(pkgs[i], parser.ParseDependency)</code></span>
<span class="codeline" id="line-417"><code>				if err != nil {</code></span>
<span class="codeline" id="line-418"><code>					return err</code></span>
<span class="codeline" id="line-419"><code>				}</code></span>
<span class="codeline" id="line-420"><code>			}</code></span>
<span class="codeline" id="line-421"><code>		} else {</code></span>
<span class="codeline" id="line-422"><code>			var t depth.Tree</code></span>
<span class="codeline" id="line-423"><code>			t.ResolveInternal = true</code></span>
<span class="codeline" id="line-424"><code>			t.MaxDepth = parseDepth</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>			pkgName, err := getPkgName(filepath.Dir(absMainAPIFilePath))</code></span>
<span class="codeline" id="line-427"><code>			if err != nil {</code></span>
<span class="codeline" id="line-428"><code>				return err</code></span>
<span class="codeline" id="line-429"><code>			}</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>			err = t.Resolve(pkgName)</code></span>
<span class="codeline" id="line-432"><code>			if err != nil {</code></span>
<span class="codeline" id="line-433"><code>				return fmt.Errorf("pkg %s cannot find all dependencies, %s", pkgName, err)</code></span>
<span class="codeline" id="line-434"><code>			}</code></span>
<span class="codeline" id="line-435"><code>			for i := 0; i &lt; len(t.Root.Deps); i++ {</code></span>
<span class="codeline" id="line-436"><code>				err := parser.getAllGoFileInfoFromDeps(&amp;t.Root.Deps[i], parser.ParseDependency)</code></span>
<span class="codeline" id="line-437"><code>				if err != nil {</code></span>
<span class="codeline" id="line-438"><code>					return err</code></span>
<span class="codeline" id="line-439"><code>				}</code></span>
<span class="codeline" id="line-440"><code>			}</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>	err = parser.ParseGeneralAPIInfo(absMainAPIFilePath)</code></span>
<span class="codeline" id="line-445"><code>	if err != nil {</code></span>
<span class="codeline" id="line-446"><code>		return err</code></span>
<span class="codeline" id="line-447"><code>	}</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code>	parser.parsedSchemas, err = parser.packages.ParseTypes()</code></span>
<span class="codeline" id="line-450"><code>	if err != nil {</code></span>
<span class="codeline" id="line-451"><code>		return err</code></span>
<span class="codeline" id="line-452"><code>	}</code></span>
<span class="codeline" id="line-453"><code></code></span>
<span class="codeline" id="line-454"><code>	err = parser.packages.RangeFiles(parser.ParseRouterAPIInfo)</code></span>
<span class="codeline" id="line-455"><code>	if err != nil {</code></span>
<span class="codeline" id="line-456"><code>		return err</code></span>
<span class="codeline" id="line-457"><code>	}</code></span>
<span class="codeline" id="line-458"><code></code></span>
<span class="codeline" id="line-459"><code>	return parser.checkOperationIDUniqueness()</code></span>
<span class="codeline" id="line-460"><code>}</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>func getPkgName(searchDir string) (string, error) {</code></span>
<span class="codeline" id="line-463"><code>	cmd := exec.Command("go", "list", "-f={{.ImportPath}}")</code></span>
<span class="codeline" id="line-464"><code>	cmd.Dir = searchDir</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>	var stdout, stderr strings.Builder</code></span>
<span class="codeline" id="line-467"><code></code></span>
<span class="codeline" id="line-468"><code>	cmd.Stdout = &amp;stdout</code></span>
<span class="codeline" id="line-469"><code>	cmd.Stderr = &amp;stderr</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	if err := cmd.Run(); err != nil {</code></span>
<span class="codeline" id="line-472"><code>		return "", fmt.Errorf("execute go list command, %s, stdout:%s, stderr:%s", err, stdout.String(), stderr.String())</code></span>
<span class="codeline" id="line-473"><code>	}</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>	outStr, _ := stdout.String(), stderr.String()</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>	if outStr[0] == '_' { // will shown like _/{GOPATH}/src/{YOUR_PACKAGE} when NOT enable GO MODULE.</code></span>
<span class="codeline" id="line-478"><code>		outStr = strings.TrimPrefix(outStr, "_"+build.Default.GOPATH+"/src/")</code></span>
<span class="codeline" id="line-479"><code>	}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>	f := strings.Split(outStr, "\n")</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	outStr = f[0]</code></span>
<span class="codeline" id="line-484"><code></code></span>
<span class="codeline" id="line-485"><code>	return outStr, nil</code></span>
<span class="codeline" id="line-486"><code>}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>// ParseGeneralAPIInfo parses general api info for given mainAPIFile path.</code></span>
<span class="codeline" id="line-489"><code>func (parser *Parser) ParseGeneralAPIInfo(mainAPIFile string) error {</code></span>
<span class="codeline" id="line-490"><code>	fileTree, err := goparser.ParseFile(token.NewFileSet(), mainAPIFile, nil, goparser.ParseComments)</code></span>
<span class="codeline" id="line-491"><code>	if err != nil {</code></span>
<span class="codeline" id="line-492"><code>		return fmt.Errorf("cannot parse source files %s: %s", mainAPIFile, err)</code></span>
<span class="codeline" id="line-493"><code>	}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>	parser.swagger.Swagger = "2.0"</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>	for _, comment := range fileTree.Comments {</code></span>
<span class="codeline" id="line-498"><code>		comments := strings.Split(comment.Text(), "\n")</code></span>
<span class="codeline" id="line-499"><code>		if !isGeneralAPIComment(comments) {</code></span>
<span class="codeline" id="line-500"><code>			continue</code></span>
<span class="codeline" id="line-501"><code>		}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>		err = parseGeneralAPIInfo(parser, comments)</code></span>
<span class="codeline" id="line-504"><code>		if err != nil {</code></span>
<span class="codeline" id="line-505"><code>			return err</code></span>
<span class="codeline" id="line-506"><code>		}</code></span>
<span class="codeline" id="line-507"><code>	}</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>	return nil</code></span>
<span class="codeline" id="line-510"><code>}</code></span>
<span class="codeline" id="line-511"><code></code></span>
<span class="codeline" id="line-512"><code>func parseGeneralAPIInfo(parser *Parser, comments []string) error {</code></span>
<span class="codeline" id="line-513"><code>	previousAttribute := ""</code></span>
<span class="codeline" id="line-514"><code></code></span>
<span class="codeline" id="line-515"><code>	// parsing classic meta data model</code></span>
<span class="codeline" id="line-516"><code>	for line := 0; line &lt; len(comments); line++ {</code></span>
<span class="codeline" id="line-517"><code>		commentLine := comments[line]</code></span>
<span class="codeline" id="line-518"><code>		commentLine = strings.TrimSpace(commentLine)</code></span>
<span class="codeline" id="line-519"><code>		if len(commentLine) == 0 {</code></span>
<span class="codeline" id="line-520"><code>			continue</code></span>
<span class="codeline" id="line-521"><code>		}</code></span>
<span class="codeline" id="line-522"><code>		fields := FieldsByAnySpace(commentLine, 2)</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>		attribute := fields[0]</code></span>
<span class="codeline" id="line-525"><code>		var value string</code></span>
<span class="codeline" id="line-526"><code>		if len(fields) &gt; 1 {</code></span>
<span class="codeline" id="line-527"><code>			value = fields[1]</code></span>
<span class="codeline" id="line-528"><code>		}</code></span>
<span class="codeline" id="line-529"><code></code></span>
<span class="codeline" id="line-530"><code>		switch attr := strings.ToLower(attribute); attr {</code></span>
<span class="codeline" id="line-531"><code>		case versionAttr, titleAttr, tosAttr, licNameAttr, licURLAttr, conNameAttr, conURLAttr, conEmailAttr:</code></span>
<span class="codeline" id="line-532"><code>			setSwaggerInfo(parser.swagger, attr, value)</code></span>
<span class="codeline" id="line-533"><code>		case descriptionAttr:</code></span>
<span class="codeline" id="line-534"><code>			if previousAttribute == attribute {</code></span>
<span class="codeline" id="line-535"><code>				parser.swagger.Info.Description += "\n" + value</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>				continue</code></span>
<span class="codeline" id="line-538"><code>			}</code></span>
<span class="codeline" id="line-539"><code></code></span>
<span class="codeline" id="line-540"><code>			setSwaggerInfo(parser.swagger, attr, value)</code></span>
<span class="codeline" id="line-541"><code>		case descriptionMarkdownAttr:</code></span>
<span class="codeline" id="line-542"><code>			commentInfo, err := getMarkdownForTag("api", parser.markdownFileDir)</code></span>
<span class="codeline" id="line-543"><code>			if err != nil {</code></span>
<span class="codeline" id="line-544"><code>				return err</code></span>
<span class="codeline" id="line-545"><code>			}</code></span>
<span class="codeline" id="line-546"><code></code></span>
<span class="codeline" id="line-547"><code>			setSwaggerInfo(parser.swagger, descriptionAttr, string(commentInfo))</code></span>
<span class="codeline" id="line-548"><code></code></span>
<span class="codeline" id="line-549"><code>		case "@host":</code></span>
<span class="codeline" id="line-550"><code>			parser.swagger.Host = value</code></span>
<span class="codeline" id="line-551"><code>		case "@hoststate":</code></span>
<span class="codeline" id="line-552"><code>			fields = FieldsByAnySpace(commentLine, 3)</code></span>
<span class="codeline" id="line-553"><code>			if len(fields) != 3 {</code></span>
<span class="codeline" id="line-554"><code>				return fmt.Errorf("%s needs 3 arguments", attribute)</code></span>
<span class="codeline" id="line-555"><code>			}</code></span>
<span class="codeline" id="line-556"><code>			if parser.HostState == fields[1] {</code></span>
<span class="codeline" id="line-557"><code>				parser.swagger.Host = fields[2]</code></span>
<span class="codeline" id="line-558"><code>			}</code></span>
<span class="codeline" id="line-559"><code>		case "@basepath":</code></span>
<span class="codeline" id="line-560"><code>			parser.swagger.BasePath = value</code></span>
<span class="codeline" id="line-561"><code></code></span>
<span class="codeline" id="line-562"><code>		case acceptAttr:</code></span>
<span class="codeline" id="line-563"><code>			err := parser.ParseAcceptComment(value)</code></span>
<span class="codeline" id="line-564"><code>			if err != nil {</code></span>
<span class="codeline" id="line-565"><code>				return err</code></span>
<span class="codeline" id="line-566"><code>			}</code></span>
<span class="codeline" id="line-567"><code>		case produceAttr:</code></span>
<span class="codeline" id="line-568"><code>			err := parser.ParseProduceComment(value)</code></span>
<span class="codeline" id="line-569"><code>			if err != nil {</code></span>
<span class="codeline" id="line-570"><code>				return err</code></span>
<span class="codeline" id="line-571"><code>			}</code></span>
<span class="codeline" id="line-572"><code>		case "@schemes":</code></span>
<span class="codeline" id="line-573"><code>			parser.swagger.Schemes = strings.Split(value, " ")</code></span>
<span class="codeline" id="line-574"><code>		case "@tag.name":</code></span>
<span class="codeline" id="line-575"><code>			parser.swagger.Tags = append(parser.swagger.Tags, spec.Tag{</code></span>
<span class="codeline" id="line-576"><code>				TagProps: spec.TagProps{</code></span>
<span class="codeline" id="line-577"><code>					Name: value,</code></span>
<span class="codeline" id="line-578"><code>				},</code></span>
<span class="codeline" id="line-579"><code>			})</code></span>
<span class="codeline" id="line-580"><code>		case "@tag.description":</code></span>
<span class="codeline" id="line-581"><code>			tag := parser.swagger.Tags[len(parser.swagger.Tags)-1]</code></span>
<span class="codeline" id="line-582"><code>			tag.TagProps.Description = value</code></span>
<span class="codeline" id="line-583"><code>			replaceLastTag(parser.swagger.Tags, tag)</code></span>
<span class="codeline" id="line-584"><code>		case "@tag.description.markdown":</code></span>
<span class="codeline" id="line-585"><code>			tag := parser.swagger.Tags[len(parser.swagger.Tags)-1]</code></span>
<span class="codeline" id="line-586"><code></code></span>
<span class="codeline" id="line-587"><code>			commentInfo, err := getMarkdownForTag(tag.TagProps.Name, parser.markdownFileDir)</code></span>
<span class="codeline" id="line-588"><code>			if err != nil {</code></span>
<span class="codeline" id="line-589"><code>				return err</code></span>
<span class="codeline" id="line-590"><code>			}</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>			tag.TagProps.Description = string(commentInfo)</code></span>
<span class="codeline" id="line-593"><code>			replaceLastTag(parser.swagger.Tags, tag)</code></span>
<span class="codeline" id="line-594"><code>		case "@tag.docs.url":</code></span>
<span class="codeline" id="line-595"><code>			tag := parser.swagger.Tags[len(parser.swagger.Tags)-1]</code></span>
<span class="codeline" id="line-596"><code>			tag.TagProps.ExternalDocs = &amp;spec.ExternalDocumentation{</code></span>
<span class="codeline" id="line-597"><code>				URL:         value,</code></span>
<span class="codeline" id="line-598"><code>				Description: "",</code></span>
<span class="codeline" id="line-599"><code>			}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>			replaceLastTag(parser.swagger.Tags, tag)</code></span>
<span class="codeline" id="line-602"><code>		case "@tag.docs.description":</code></span>
<span class="codeline" id="line-603"><code>			tag := parser.swagger.Tags[len(parser.swagger.Tags)-1]</code></span>
<span class="codeline" id="line-604"><code>			if tag.TagProps.ExternalDocs == nil {</code></span>
<span class="codeline" id="line-605"><code>				return fmt.Errorf("%s needs to come after a @tags.docs.url", attribute)</code></span>
<span class="codeline" id="line-606"><code>			}</code></span>
<span class="codeline" id="line-607"><code></code></span>
<span class="codeline" id="line-608"><code>			tag.TagProps.ExternalDocs.Description = value</code></span>
<span class="codeline" id="line-609"><code>			replaceLastTag(parser.swagger.Tags, tag)</code></span>
<span class="codeline" id="line-610"><code></code></span>
<span class="codeline" id="line-611"><code>		case secBasicAttr, secAPIKeyAttr, secApplicationAttr, secImplicitAttr, secPasswordAttr, secAccessCodeAttr:</code></span>
<span class="codeline" id="line-612"><code>			scheme, err := parseSecAttributes(attribute, comments, &amp;line)</code></span>
<span class="codeline" id="line-613"><code>			if err != nil {</code></span>
<span class="codeline" id="line-614"><code>				return err</code></span>
<span class="codeline" id="line-615"><code>			}</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>			parser.swagger.SecurityDefinitions[value] = scheme</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>		case securityAttr:</code></span>
<span class="codeline" id="line-620"><code>			parser.swagger.Security = append(parser.swagger.Security, parseSecurity(value))</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>		case "@query.collection.format":</code></span>
<span class="codeline" id="line-623"><code>			parser.collectionFormatInQuery = TransToValidCollectionFormat(value)</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>		case extDocsDescAttr, extDocsURLAttr:</code></span>
<span class="codeline" id="line-626"><code>			if parser.swagger.ExternalDocs == nil {</code></span>
<span class="codeline" id="line-627"><code>				parser.swagger.ExternalDocs = new(spec.ExternalDocumentation)</code></span>
<span class="codeline" id="line-628"><code>			}</code></span>
<span class="codeline" id="line-629"><code>			switch attr {</code></span>
<span class="codeline" id="line-630"><code>			case extDocsDescAttr:</code></span>
<span class="codeline" id="line-631"><code>				parser.swagger.ExternalDocs.Description = value</code></span>
<span class="codeline" id="line-632"><code>			case extDocsURLAttr:</code></span>
<span class="codeline" id="line-633"><code>				parser.swagger.ExternalDocs.URL = value</code></span>
<span class="codeline" id="line-634"><code>			}</code></span>
<span class="codeline" id="line-635"><code></code></span>
<span class="codeline" id="line-636"><code>		default:</code></span>
<span class="codeline" id="line-637"><code>			if strings.HasPrefix(attribute, "@x-") {</code></span>
<span class="codeline" id="line-638"><code>				extensionName := attribute[1:]</code></span>
<span class="codeline" id="line-639"><code></code></span>
<span class="codeline" id="line-640"><code>				extExistsInSecurityDef := false</code></span>
<span class="codeline" id="line-641"><code>				// for each security definition</code></span>
<span class="codeline" id="line-642"><code>				for _, v := range parser.swagger.SecurityDefinitions {</code></span>
<span class="codeline" id="line-643"><code>					// check if extension exists</code></span>
<span class="codeline" id="line-644"><code>					_, extExistsInSecurityDef = v.VendorExtensible.Extensions.GetString(extensionName)</code></span>
<span class="codeline" id="line-645"><code>					// if it exists in at least one, then we stop iterating</code></span>
<span class="codeline" id="line-646"><code>					if extExistsInSecurityDef {</code></span>
<span class="codeline" id="line-647"><code>						break</code></span>
<span class="codeline" id="line-648"><code>					}</code></span>
<span class="codeline" id="line-649"><code>				}</code></span>
<span class="codeline" id="line-650"><code></code></span>
<span class="codeline" id="line-651"><code>				// if it is present on security def, don't add it again</code></span>
<span class="codeline" id="line-652"><code>				if extExistsInSecurityDef {</code></span>
<span class="codeline" id="line-653"><code>					break</code></span>
<span class="codeline" id="line-654"><code>				}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>				if len(value) == 0 {</code></span>
<span class="codeline" id="line-657"><code>					return fmt.Errorf("annotation %s need a value", attribute)</code></span>
<span class="codeline" id="line-658"><code>				}</code></span>
<span class="codeline" id="line-659"><code></code></span>
<span class="codeline" id="line-660"><code>				var valueJSON interface{}</code></span>
<span class="codeline" id="line-661"><code>				err := json.Unmarshal([]byte(value), &amp;valueJSON)</code></span>
<span class="codeline" id="line-662"><code>				if err != nil {</code></span>
<span class="codeline" id="line-663"><code>					return fmt.Errorf("annotation %s need a valid json value", attribute)</code></span>
<span class="codeline" id="line-664"><code>				}</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>				if strings.Contains(extensionName, "logo") {</code></span>
<span class="codeline" id="line-667"><code>					parser.swagger.Info.Extensions.Add(extensionName, valueJSON)</code></span>
<span class="codeline" id="line-668"><code>				} else {</code></span>
<span class="codeline" id="line-669"><code>					if parser.swagger.Extensions == nil {</code></span>
<span class="codeline" id="line-670"><code>						parser.swagger.Extensions = make(map[string]interface{})</code></span>
<span class="codeline" id="line-671"><code>					}</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>					parser.swagger.Extensions[attribute[1:]] = valueJSON</code></span>
<span class="codeline" id="line-674"><code>				}</code></span>
<span class="codeline" id="line-675"><code>			}</code></span>
<span class="codeline" id="line-676"><code>		}</code></span>
<span class="codeline" id="line-677"><code></code></span>
<span class="codeline" id="line-678"><code>		previousAttribute = attribute</code></span>
<span class="codeline" id="line-679"><code>	}</code></span>
<span class="codeline" id="line-680"><code></code></span>
<span class="codeline" id="line-681"><code>	return nil</code></span>
<span class="codeline" id="line-682"><code>}</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>func setSwaggerInfo(swagger *spec.Swagger, attribute, value string) {</code></span>
<span class="codeline" id="line-685"><code>	switch attribute {</code></span>
<span class="codeline" id="line-686"><code>	case versionAttr:</code></span>
<span class="codeline" id="line-687"><code>		swagger.Info.Version = value</code></span>
<span class="codeline" id="line-688"><code>	case titleAttr:</code></span>
<span class="codeline" id="line-689"><code>		swagger.Info.Title = value</code></span>
<span class="codeline" id="line-690"><code>	case tosAttr:</code></span>
<span class="codeline" id="line-691"><code>		swagger.Info.TermsOfService = value</code></span>
<span class="codeline" id="line-692"><code>	case descriptionAttr:</code></span>
<span class="codeline" id="line-693"><code>		swagger.Info.Description = value</code></span>
<span class="codeline" id="line-694"><code>	case conNameAttr:</code></span>
<span class="codeline" id="line-695"><code>		swagger.Info.Contact.Name = value</code></span>
<span class="codeline" id="line-696"><code>	case conEmailAttr:</code></span>
<span class="codeline" id="line-697"><code>		swagger.Info.Contact.Email = value</code></span>
<span class="codeline" id="line-698"><code>	case conURLAttr:</code></span>
<span class="codeline" id="line-699"><code>		swagger.Info.Contact.URL = value</code></span>
<span class="codeline" id="line-700"><code>	case licNameAttr:</code></span>
<span class="codeline" id="line-701"><code>		swagger.Info.License = initIfEmpty(swagger.Info.License)</code></span>
<span class="codeline" id="line-702"><code>		swagger.Info.License.Name = value</code></span>
<span class="codeline" id="line-703"><code>	case licURLAttr:</code></span>
<span class="codeline" id="line-704"><code>		swagger.Info.License = initIfEmpty(swagger.Info.License)</code></span>
<span class="codeline" id="line-705"><code>		swagger.Info.License.URL = value</code></span>
<span class="codeline" id="line-706"><code>	}</code></span>
<span class="codeline" id="line-707"><code>}</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>func parseSecAttributes(context string, lines []string, index *int) (*spec.SecurityScheme, error) {</code></span>
<span class="codeline" id="line-710"><code>	const (</code></span>
<span class="codeline" id="line-711"><code>		in               = "@in"</code></span>
<span class="codeline" id="line-712"><code>		name             = "@name"</code></span>
<span class="codeline" id="line-713"><code>		descriptionAttr  = "@description"</code></span>
<span class="codeline" id="line-714"><code>		tokenURL         = "@tokenurl"</code></span>
<span class="codeline" id="line-715"><code>		authorizationURL = "@authorizationurl"</code></span>
<span class="codeline" id="line-716"><code>	)</code></span>
<span class="codeline" id="line-717"><code></code></span>
<span class="codeline" id="line-718"><code>	var search []string</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>	attribute := strings.ToLower(FieldsByAnySpace(lines[*index], 2)[0])</code></span>
<span class="codeline" id="line-721"><code>	switch attribute {</code></span>
<span class="codeline" id="line-722"><code>	case secBasicAttr:</code></span>
<span class="codeline" id="line-723"><code>		return spec.BasicAuth(), nil</code></span>
<span class="codeline" id="line-724"><code>	case secAPIKeyAttr:</code></span>
<span class="codeline" id="line-725"><code>		search = []string{in, name}</code></span>
<span class="codeline" id="line-726"><code>	case secApplicationAttr, secPasswordAttr:</code></span>
<span class="codeline" id="line-727"><code>		search = []string{tokenURL}</code></span>
<span class="codeline" id="line-728"><code>	case secImplicitAttr:</code></span>
<span class="codeline" id="line-729"><code>		search = []string{authorizationURL}</code></span>
<span class="codeline" id="line-730"><code>	case secAccessCodeAttr:</code></span>
<span class="codeline" id="line-731"><code>		search = []string{tokenURL, authorizationURL}</code></span>
<span class="codeline" id="line-732"><code>	}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>	// For the first line we get the attributes in the context parameter, so we skip to the next one</code></span>
<span class="codeline" id="line-735"><code>	*index++</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>	attrMap, scopes := make(map[string]string), make(map[string]string)</code></span>
<span class="codeline" id="line-738"><code>	extensions, description := make(map[string]interface{}), ""</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>loopline:</code></span>
<span class="codeline" id="line-741"><code>	for ; *index &lt; len(lines); *index++ {</code></span>
<span class="codeline" id="line-742"><code>		v := strings.TrimSpace(lines[*index])</code></span>
<span class="codeline" id="line-743"><code>		if len(v) == 0 {</code></span>
<span class="codeline" id="line-744"><code>			continue</code></span>
<span class="codeline" id="line-745"><code>		}</code></span>
<span class="codeline" id="line-746"><code></code></span>
<span class="codeline" id="line-747"><code>		fields := FieldsByAnySpace(v, 2)</code></span>
<span class="codeline" id="line-748"><code>		securityAttr := strings.ToLower(fields[0])</code></span>
<span class="codeline" id="line-749"><code>		var value string</code></span>
<span class="codeline" id="line-750"><code>		if len(fields) &gt; 1 {</code></span>
<span class="codeline" id="line-751"><code>			value = fields[1]</code></span>
<span class="codeline" id="line-752"><code>		}</code></span>
<span class="codeline" id="line-753"><code></code></span>
<span class="codeline" id="line-754"><code>		for _, findterm := range search {</code></span>
<span class="codeline" id="line-755"><code>			if securityAttr == findterm {</code></span>
<span class="codeline" id="line-756"><code>				attrMap[securityAttr] = value</code></span>
<span class="codeline" id="line-757"><code>				continue loopline</code></span>
<span class="codeline" id="line-758"><code>			}</code></span>
<span class="codeline" id="line-759"><code>		}</code></span>
<span class="codeline" id="line-760"><code></code></span>
<span class="codeline" id="line-761"><code>		if isExists, err := isExistsScope(securityAttr); err != nil {</code></span>
<span class="codeline" id="line-762"><code>			return nil, err</code></span>
<span class="codeline" id="line-763"><code>		} else if isExists {</code></span>
<span class="codeline" id="line-764"><code>			scopes[securityAttr[len(scopeAttrPrefix):]] = value</code></span>
<span class="codeline" id="line-765"><code>			continue</code></span>
<span class="codeline" id="line-766"><code>		}</code></span>
<span class="codeline" id="line-767"><code></code></span>
<span class="codeline" id="line-768"><code>		if strings.HasPrefix(securityAttr, "@x-") {</code></span>
<span class="codeline" id="line-769"><code>			// Add the custom attribute without the @</code></span>
<span class="codeline" id="line-770"><code>			extensions[securityAttr[1:]] = value</code></span>
<span class="codeline" id="line-771"><code>			continue</code></span>
<span class="codeline" id="line-772"><code>		}</code></span>
<span class="codeline" id="line-773"><code></code></span>
<span class="codeline" id="line-774"><code>		// Not mandatory field</code></span>
<span class="codeline" id="line-775"><code>		if securityAttr == descriptionAttr {</code></span>
<span class="codeline" id="line-776"><code>			description = value</code></span>
<span class="codeline" id="line-777"><code>		}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>		// next securityDefinitions</code></span>
<span class="codeline" id="line-780"><code>		if strings.Index(securityAttr, "@securitydefinitions.") == 0 {</code></span>
<span class="codeline" id="line-781"><code>			// Go back to the previous line and break</code></span>
<span class="codeline" id="line-782"><code>			*index--</code></span>
<span class="codeline" id="line-783"><code></code></span>
<span class="codeline" id="line-784"><code>			break</code></span>
<span class="codeline" id="line-785"><code>		}</code></span>
<span class="codeline" id="line-786"><code>	}</code></span>
<span class="codeline" id="line-787"><code></code></span>
<span class="codeline" id="line-788"><code>	if len(attrMap) != len(search) {</code></span>
<span class="codeline" id="line-789"><code>		return nil, fmt.Errorf("%s is %v required", context, search)</code></span>
<span class="codeline" id="line-790"><code>	}</code></span>
<span class="codeline" id="line-791"><code></code></span>
<span class="codeline" id="line-792"><code>	var scheme *spec.SecurityScheme</code></span>
<span class="codeline" id="line-793"><code></code></span>
<span class="codeline" id="line-794"><code>	switch attribute {</code></span>
<span class="codeline" id="line-795"><code>	case secAPIKeyAttr:</code></span>
<span class="codeline" id="line-796"><code>		scheme = spec.APIKeyAuth(attrMap[name], attrMap[in])</code></span>
<span class="codeline" id="line-797"><code>	case secApplicationAttr:</code></span>
<span class="codeline" id="line-798"><code>		scheme = spec.OAuth2Application(attrMap[tokenURL])</code></span>
<span class="codeline" id="line-799"><code>	case secImplicitAttr:</code></span>
<span class="codeline" id="line-800"><code>		scheme = spec.OAuth2Implicit(attrMap[authorizationURL])</code></span>
<span class="codeline" id="line-801"><code>	case secPasswordAttr:</code></span>
<span class="codeline" id="line-802"><code>		scheme = spec.OAuth2Password(attrMap[tokenURL])</code></span>
<span class="codeline" id="line-803"><code>	case secAccessCodeAttr:</code></span>
<span class="codeline" id="line-804"><code>		scheme = spec.OAuth2AccessToken(attrMap[authorizationURL], attrMap[tokenURL])</code></span>
<span class="codeline" id="line-805"><code>	}</code></span>
<span class="codeline" id="line-806"><code></code></span>
<span class="codeline" id="line-807"><code>	scheme.Description = description</code></span>
<span class="codeline" id="line-808"><code></code></span>
<span class="codeline" id="line-809"><code>	for extKey, extValue := range extensions {</code></span>
<span class="codeline" id="line-810"><code>		scheme.AddExtension(extKey, extValue)</code></span>
<span class="codeline" id="line-811"><code>	}</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>	for scope, scopeDescription := range scopes {</code></span>
<span class="codeline" id="line-814"><code>		scheme.AddScope(scope, scopeDescription)</code></span>
<span class="codeline" id="line-815"><code>	}</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>	return scheme, nil</code></span>
<span class="codeline" id="line-818"><code>}</code></span>
<span class="codeline" id="line-819"><code></code></span>
<span class="codeline" id="line-820"><code>func parseSecurity(commentLine string) map[string][]string {</code></span>
<span class="codeline" id="line-821"><code>	securityMap := make(map[string][]string)</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>	for _, securityOption := range strings.Split(commentLine, "||") {</code></span>
<span class="codeline" id="line-824"><code>		securityOption = strings.TrimSpace(securityOption)</code></span>
<span class="codeline" id="line-825"><code></code></span>
<span class="codeline" id="line-826"><code>		left, right := strings.Index(securityOption, "["), strings.Index(securityOption, "]")</code></span>
<span class="codeline" id="line-827"><code></code></span>
<span class="codeline" id="line-828"><code>		if !(left == -1 &amp;&amp; right == -1) {</code></span>
<span class="codeline" id="line-829"><code>			scopes := securityOption[left+1 : right]</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>			var options []string</code></span>
<span class="codeline" id="line-832"><code></code></span>
<span class="codeline" id="line-833"><code>			for _, scope := range strings.Split(scopes, ",") {</code></span>
<span class="codeline" id="line-834"><code>				options = append(options, strings.TrimSpace(scope))</code></span>
<span class="codeline" id="line-835"><code>			}</code></span>
<span class="codeline" id="line-836"><code></code></span>
<span class="codeline" id="line-837"><code>			securityKey := securityOption[0:left]</code></span>
<span class="codeline" id="line-838"><code>			securityMap[securityKey] = append(securityMap[securityKey], options...)</code></span>
<span class="codeline" id="line-839"><code>		} else {</code></span>
<span class="codeline" id="line-840"><code>			securityKey := strings.TrimSpace(securityOption)</code></span>
<span class="codeline" id="line-841"><code>			securityMap[securityKey] = []string{}</code></span>
<span class="codeline" id="line-842"><code>		}</code></span>
<span class="codeline" id="line-843"><code>	}</code></span>
<span class="codeline" id="line-844"><code></code></span>
<span class="codeline" id="line-845"><code>	return securityMap</code></span>
<span class="codeline" id="line-846"><code>}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>func initIfEmpty(license *spec.License) *spec.License {</code></span>
<span class="codeline" id="line-849"><code>	if license == nil {</code></span>
<span class="codeline" id="line-850"><code>		return new(spec.License)</code></span>
<span class="codeline" id="line-851"><code>	}</code></span>
<span class="codeline" id="line-852"><code></code></span>
<span class="codeline" id="line-853"><code>	return license</code></span>
<span class="codeline" id="line-854"><code>}</code></span>
<span class="codeline" id="line-855"><code></code></span>
<span class="codeline" id="line-856"><code>// ParseAcceptComment parses comment for given `accept` comment string.</code></span>
<span class="codeline" id="line-857"><code>func (parser *Parser) ParseAcceptComment(commentLine string) error {</code></span>
<span class="codeline" id="line-858"><code>	return parseMimeTypeList(commentLine, &amp;parser.swagger.Consumes, "%v accept type can't be accepted")</code></span>
<span class="codeline" id="line-859"><code>}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>// ParseProduceComment parses comment for given `produce` comment string.</code></span>
<span class="codeline" id="line-862"><code>func (parser *Parser) ParseProduceComment(commentLine string) error {</code></span>
<span class="codeline" id="line-863"><code>	return parseMimeTypeList(commentLine, &amp;parser.swagger.Produces, "%v produce type can't be accepted")</code></span>
<span class="codeline" id="line-864"><code>}</code></span>
<span class="codeline" id="line-865"><code></code></span>
<span class="codeline" id="line-866"><code>func isGeneralAPIComment(comments []string) bool {</code></span>
<span class="codeline" id="line-867"><code>	for _, commentLine := range comments {</code></span>
<span class="codeline" id="line-868"><code>		commentLine = strings.TrimSpace(commentLine)</code></span>
<span class="codeline" id="line-869"><code>		if len(commentLine) == 0 {</code></span>
<span class="codeline" id="line-870"><code>			continue</code></span>
<span class="codeline" id="line-871"><code>		}</code></span>
<span class="codeline" id="line-872"><code>		attribute := strings.ToLower(FieldsByAnySpace(commentLine, 2)[0])</code></span>
<span class="codeline" id="line-873"><code>		switch attribute {</code></span>
<span class="codeline" id="line-874"><code>		// The @summary, @router, @success, @failure annotation belongs to Operation</code></span>
<span class="codeline" id="line-875"><code>		case summaryAttr, routerAttr, successAttr, failureAttr, responseAttr:</code></span>
<span class="codeline" id="line-876"><code>			return false</code></span>
<span class="codeline" id="line-877"><code>		}</code></span>
<span class="codeline" id="line-878"><code>	}</code></span>
<span class="codeline" id="line-879"><code></code></span>
<span class="codeline" id="line-880"><code>	return true</code></span>
<span class="codeline" id="line-881"><code>}</code></span>
<span class="codeline" id="line-882"><code></code></span>
<span class="codeline" id="line-883"><code>func getMarkdownForTag(tagName string, dirPath string) ([]byte, error) {</code></span>
<span class="codeline" id="line-884"><code>	dirEntries, err := os.ReadDir(dirPath)</code></span>
<span class="codeline" id="line-885"><code>	if err != nil {</code></span>
<span class="codeline" id="line-886"><code>		return nil, err</code></span>
<span class="codeline" id="line-887"><code>	}</code></span>
<span class="codeline" id="line-888"><code></code></span>
<span class="codeline" id="line-889"><code>	for _, entry := range dirEntries {</code></span>
<span class="codeline" id="line-890"><code>		if entry.IsDir() {</code></span>
<span class="codeline" id="line-891"><code>			continue</code></span>
<span class="codeline" id="line-892"><code>		}</code></span>
<span class="codeline" id="line-893"><code></code></span>
<span class="codeline" id="line-894"><code>		fileName := entry.Name()</code></span>
<span class="codeline" id="line-895"><code></code></span>
<span class="codeline" id="line-896"><code>		if !strings.Contains(fileName, ".md") {</code></span>
<span class="codeline" id="line-897"><code>			continue</code></span>
<span class="codeline" id="line-898"><code>		}</code></span>
<span class="codeline" id="line-899"><code></code></span>
<span class="codeline" id="line-900"><code>		if strings.Contains(fileName, tagName) {</code></span>
<span class="codeline" id="line-901"><code>			fullPath := filepath.Join(dirPath, fileName)</code></span>
<span class="codeline" id="line-902"><code></code></span>
<span class="codeline" id="line-903"><code>			commentInfo, err := os.ReadFile(fullPath)</code></span>
<span class="codeline" id="line-904"><code>			if err != nil {</code></span>
<span class="codeline" id="line-905"><code>				return nil, fmt.Errorf("Failed to read markdown file %s error: %s ", fullPath, err)</code></span>
<span class="codeline" id="line-906"><code>			}</code></span>
<span class="codeline" id="line-907"><code></code></span>
<span class="codeline" id="line-908"><code>			return commentInfo, nil</code></span>
<span class="codeline" id="line-909"><code>		}</code></span>
<span class="codeline" id="line-910"><code>	}</code></span>
<span class="codeline" id="line-911"><code></code></span>
<span class="codeline" id="line-912"><code>	return nil, fmt.Errorf("Unable to find markdown file for tag %s in the given directory", tagName)</code></span>
<span class="codeline" id="line-913"><code>}</code></span>
<span class="codeline" id="line-914"><code></code></span>
<span class="codeline" id="line-915"><code>func isExistsScope(scope string) (bool, error) {</code></span>
<span class="codeline" id="line-916"><code>	s := strings.Fields(scope)</code></span>
<span class="codeline" id="line-917"><code>	for _, v := range s {</code></span>
<span class="codeline" id="line-918"><code>		if strings.HasPrefix(v, scopeAttrPrefix) {</code></span>
<span class="codeline" id="line-919"><code>			if strings.Contains(v, ",") {</code></span>
<span class="codeline" id="line-920"><code>				return false, fmt.Errorf("@scope can't use comma(,) get=" + v)</code></span>
<span class="codeline" id="line-921"><code>			}</code></span>
<span class="codeline" id="line-922"><code>		}</code></span>
<span class="codeline" id="line-923"><code>	}</code></span>
<span class="codeline" id="line-924"><code></code></span>
<span class="codeline" id="line-925"><code>	return strings.HasPrefix(scope, scopeAttrPrefix), nil</code></span>
<span class="codeline" id="line-926"><code>}</code></span>
<span class="codeline" id="line-927"><code></code></span>
<span class="codeline" id="line-928"><code>func getTagsFromComment(comment string) (tags []string) {</code></span>
<span class="codeline" id="line-929"><code>	commentLine := strings.TrimSpace(strings.TrimLeft(comment, "/"))</code></span>
<span class="codeline" id="line-930"><code>	if len(commentLine) == 0 {</code></span>
<span class="codeline" id="line-931"><code>		return nil</code></span>
<span class="codeline" id="line-932"><code>	}</code></span>
<span class="codeline" id="line-933"><code></code></span>
<span class="codeline" id="line-934"><code>	attribute := strings.Fields(commentLine)[0]</code></span>
<span class="codeline" id="line-935"><code>	lineRemainder, lowerAttribute := strings.TrimSpace(commentLine[len(attribute):]), strings.ToLower(attribute)</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>	if lowerAttribute == tagsAttr {</code></span>
<span class="codeline" id="line-938"><code>		for _, tag := range strings.Split(lineRemainder, ",") {</code></span>
<span class="codeline" id="line-939"><code>			tags = append(tags, strings.TrimSpace(tag))</code></span>
<span class="codeline" id="line-940"><code>		}</code></span>
<span class="codeline" id="line-941"><code>	}</code></span>
<span class="codeline" id="line-942"><code>	return</code></span>
<span class="codeline" id="line-943"><code></code></span>
<span class="codeline" id="line-944"><code>}</code></span>
<span class="codeline" id="line-945"><code></code></span>
<span class="codeline" id="line-946"><code>func (parser *Parser) matchTags(comments []*ast.Comment) (match bool) {</code></span>
<span class="codeline" id="line-947"><code>	if len(parser.tags) == 0 {</code></span>
<span class="codeline" id="line-948"><code>		return true</code></span>
<span class="codeline" id="line-949"><code>	}</code></span>
<span class="codeline" id="line-950"><code></code></span>
<span class="codeline" id="line-951"><code>	match = false</code></span>
<span class="codeline" id="line-952"><code>	for _, comment := range comments {</code></span>
<span class="codeline" id="line-953"><code>		for _, tag := range getTagsFromComment(comment.Text) {</code></span>
<span class="codeline" id="line-954"><code>			if _, has := parser.tags["!"+tag]; has {</code></span>
<span class="codeline" id="line-955"><code>				return false</code></span>
<span class="codeline" id="line-956"><code>			}</code></span>
<span class="codeline" id="line-957"><code>			if _, has := parser.tags[tag]; has {</code></span>
<span class="codeline" id="line-958"><code>				match = true // keep iterating as it may contain a tag that is excluded</code></span>
<span class="codeline" id="line-959"><code>			}</code></span>
<span class="codeline" id="line-960"><code>		}</code></span>
<span class="codeline" id="line-961"><code>	}</code></span>
<span class="codeline" id="line-962"><code></code></span>
<span class="codeline" id="line-963"><code>	if !match {</code></span>
<span class="codeline" id="line-964"><code>		// If all tags are negation then we should return true</code></span>
<span class="codeline" id="line-965"><code>		for key := range parser.tags {</code></span>
<span class="codeline" id="line-966"><code>			if key[0] != '!' {</code></span>
<span class="codeline" id="line-967"><code>				return false</code></span>
<span class="codeline" id="line-968"><code>			}</code></span>
<span class="codeline" id="line-969"><code>		}</code></span>
<span class="codeline" id="line-970"><code>	}</code></span>
<span class="codeline" id="line-971"><code>	return true</code></span>
<span class="codeline" id="line-972"><code>}</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>func matchExtension(extensionToMatch string, comments []*ast.Comment) (match bool) {</code></span>
<span class="codeline" id="line-975"><code>	if len(extensionToMatch) != 0 {</code></span>
<span class="codeline" id="line-976"><code>		for _, comment := range comments {</code></span>
<span class="codeline" id="line-977"><code>			commentLine := strings.TrimSpace(strings.TrimLeft(comment.Text, "/"))</code></span>
<span class="codeline" id="line-978"><code>			fields := FieldsByAnySpace(commentLine, 2)</code></span>
<span class="codeline" id="line-979"><code>			if len(fields) &gt; 0 {</code></span>
<span class="codeline" id="line-980"><code>				lowerAttribute := strings.ToLower(fields[0])</code></span>
<span class="codeline" id="line-981"><code></code></span>
<span class="codeline" id="line-982"><code>				if lowerAttribute == fmt.Sprintf("@x-%s", strings.ToLower(extensionToMatch)) {</code></span>
<span class="codeline" id="line-983"><code>					return true</code></span>
<span class="codeline" id="line-984"><code>				}</code></span>
<span class="codeline" id="line-985"><code>			}</code></span>
<span class="codeline" id="line-986"><code>		}</code></span>
<span class="codeline" id="line-987"><code>		return false</code></span>
<span class="codeline" id="line-988"><code>	}</code></span>
<span class="codeline" id="line-989"><code>	return true</code></span>
<span class="codeline" id="line-990"><code>}</code></span>
<span class="codeline" id="line-991"><code></code></span>
<span class="codeline" id="line-992"><code>// ParseRouterAPIInfo parses router api info for given astFile.</code></span>
<span class="codeline" id="line-993"><code>func (parser *Parser) ParseRouterAPIInfo(fileInfo *AstFileInfo) error {</code></span>
<span class="codeline" id="line-994"><code>DeclsLoop:</code></span>
<span class="codeline" id="line-995"><code>	for _, astDescription := range fileInfo.File.Decls {</code></span>
<span class="codeline" id="line-996"><code>		if (fileInfo.ParseFlag &amp; ParseOperations) == ParseNone {</code></span>
<span class="codeline" id="line-997"><code>			continue</code></span>
<span class="codeline" id="line-998"><code>		}</code></span>
<span class="codeline" id="line-999"><code>		astDeclaration, ok := astDescription.(*ast.FuncDecl)</code></span>
<span class="codeline" id="line-1000"><code>		if ok &amp;&amp; astDeclaration.Doc != nil &amp;&amp; astDeclaration.Doc.List != nil {</code></span>
<span class="codeline" id="line-1001"><code>			if parser.matchTags(astDeclaration.Doc.List) &amp;&amp;</code></span>
<span class="codeline" id="line-1002"><code>				matchExtension(parser.parseExtension, astDeclaration.Doc.List) {</code></span>
<span class="codeline" id="line-1003"><code>				// for per 'function' comment, create a new 'Operation' object</code></span>
<span class="codeline" id="line-1004"><code>				operation := NewOperation(parser, SetCodeExampleFilesDirectory(parser.codeExampleFilesDir))</code></span>
<span class="codeline" id="line-1005"><code>				for _, comment := range astDeclaration.Doc.List {</code></span>
<span class="codeline" id="line-1006"><code>					err := operation.ParseComment(comment.Text, fileInfo.File)</code></span>
<span class="codeline" id="line-1007"><code>					if err != nil {</code></span>
<span class="codeline" id="line-1008"><code>						return fmt.Errorf("ParseComment error in file %s :%+v", fileInfo.Path, err)</code></span>
<span class="codeline" id="line-1009"><code>					}</code></span>
<span class="codeline" id="line-1010"><code>					if operation.State != "" &amp;&amp; operation.State != parser.HostState {</code></span>
<span class="codeline" id="line-1011"><code>						continue DeclsLoop</code></span>
<span class="codeline" id="line-1012"><code>					}</code></span>
<span class="codeline" id="line-1013"><code>				}</code></span>
<span class="codeline" id="line-1014"><code>				err := processRouterOperation(parser, operation)</code></span>
<span class="codeline" id="line-1015"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1016"><code>					return err</code></span>
<span class="codeline" id="line-1017"><code>				}</code></span>
<span class="codeline" id="line-1018"><code>			}</code></span>
<span class="codeline" id="line-1019"><code>		}</code></span>
<span class="codeline" id="line-1020"><code>	}</code></span>
<span class="codeline" id="line-1021"><code></code></span>
<span class="codeline" id="line-1022"><code>	return nil</code></span>
<span class="codeline" id="line-1023"><code>}</code></span>
<span class="codeline" id="line-1024"><code></code></span>
<span class="codeline" id="line-1025"><code>func refRouteMethodOp(item *spec.PathItem, method string) (op **spec.Operation) {</code></span>
<span class="codeline" id="line-1026"><code>	switch method {</code></span>
<span class="codeline" id="line-1027"><code>	case http.MethodGet:</code></span>
<span class="codeline" id="line-1028"><code>		op = &amp;item.Get</code></span>
<span class="codeline" id="line-1029"><code>	case http.MethodPost:</code></span>
<span class="codeline" id="line-1030"><code>		op = &amp;item.Post</code></span>
<span class="codeline" id="line-1031"><code>	case http.MethodDelete:</code></span>
<span class="codeline" id="line-1032"><code>		op = &amp;item.Delete</code></span>
<span class="codeline" id="line-1033"><code>	case http.MethodPut:</code></span>
<span class="codeline" id="line-1034"><code>		op = &amp;item.Put</code></span>
<span class="codeline" id="line-1035"><code>	case http.MethodPatch:</code></span>
<span class="codeline" id="line-1036"><code>		op = &amp;item.Patch</code></span>
<span class="codeline" id="line-1037"><code>	case http.MethodHead:</code></span>
<span class="codeline" id="line-1038"><code>		op = &amp;item.Head</code></span>
<span class="codeline" id="line-1039"><code>	case http.MethodOptions:</code></span>
<span class="codeline" id="line-1040"><code>		op = &amp;item.Options</code></span>
<span class="codeline" id="line-1041"><code>	}</code></span>
<span class="codeline" id="line-1042"><code></code></span>
<span class="codeline" id="line-1043"><code>	return</code></span>
<span class="codeline" id="line-1044"><code>}</code></span>
<span class="codeline" id="line-1045"><code></code></span>
<span class="codeline" id="line-1046"><code>func processRouterOperation(parser *Parser, operation *Operation) error {</code></span>
<span class="codeline" id="line-1047"><code>	for _, routeProperties := range operation.RouterProperties {</code></span>
<span class="codeline" id="line-1048"><code>		var (</code></span>
<span class="codeline" id="line-1049"><code>			pathItem spec.PathItem</code></span>
<span class="codeline" id="line-1050"><code>			ok       bool</code></span>
<span class="codeline" id="line-1051"><code>		)</code></span>
<span class="codeline" id="line-1052"><code></code></span>
<span class="codeline" id="line-1053"><code>		pathItem, ok = parser.swagger.Paths.Paths[routeProperties.Path]</code></span>
<span class="codeline" id="line-1054"><code>		if !ok {</code></span>
<span class="codeline" id="line-1055"><code>			pathItem = spec.PathItem{}</code></span>
<span class="codeline" id="line-1056"><code>		}</code></span>
<span class="codeline" id="line-1057"><code></code></span>
<span class="codeline" id="line-1058"><code>		op := refRouteMethodOp(&amp;pathItem, routeProperties.HTTPMethod)</code></span>
<span class="codeline" id="line-1059"><code></code></span>
<span class="codeline" id="line-1060"><code>		// check if we already have an operation for this path and method</code></span>
<span class="codeline" id="line-1061"><code>		if *op != nil {</code></span>
<span class="codeline" id="line-1062"><code>			err := fmt.Errorf("route %s %s is declared multiple times", routeProperties.HTTPMethod, routeProperties.Path)</code></span>
<span class="codeline" id="line-1063"><code>			if parser.Strict {</code></span>
<span class="codeline" id="line-1064"><code>				return err</code></span>
<span class="codeline" id="line-1065"><code>			}</code></span>
<span class="codeline" id="line-1066"><code></code></span>
<span class="codeline" id="line-1067"><code>			parser.debug.Printf("warning: %s\n", err)</code></span>
<span class="codeline" id="line-1068"><code>		}</code></span>
<span class="codeline" id="line-1069"><code></code></span>
<span class="codeline" id="line-1070"><code>		if len(operation.RouterProperties) &gt; 1 {</code></span>
<span class="codeline" id="line-1071"><code>			newOp := *operation</code></span>
<span class="codeline" id="line-1072"><code>			var validParams []spec.Parameter</code></span>
<span class="codeline" id="line-1073"><code>			for _, param := range newOp.Operation.OperationProps.Parameters {</code></span>
<span class="codeline" id="line-1074"><code>				if param.In == "path" &amp;&amp; !strings.Contains(routeProperties.Path, param.Name) {</code></span>
<span class="codeline" id="line-1075"><code>					// This path param is not actually contained in the path, skip adding it to the final params</code></span>
<span class="codeline" id="line-1076"><code>					continue</code></span>
<span class="codeline" id="line-1077"><code>				}</code></span>
<span class="codeline" id="line-1078"><code>				validParams = append(validParams, param)</code></span>
<span class="codeline" id="line-1079"><code>			}</code></span>
<span class="codeline" id="line-1080"><code>			newOp.Operation.OperationProps.Parameters = validParams</code></span>
<span class="codeline" id="line-1081"><code>			*op = &amp;newOp.Operation</code></span>
<span class="codeline" id="line-1082"><code>		} else {</code></span>
<span class="codeline" id="line-1083"><code>			*op = &amp;operation.Operation</code></span>
<span class="codeline" id="line-1084"><code>		}</code></span>
<span class="codeline" id="line-1085"><code></code></span>
<span class="codeline" id="line-1086"><code>		if routeProperties.Deprecated {</code></span>
<span class="codeline" id="line-1087"><code>			(*op).Deprecated = routeProperties.Deprecated</code></span>
<span class="codeline" id="line-1088"><code>		}</code></span>
<span class="codeline" id="line-1089"><code></code></span>
<span class="codeline" id="line-1090"><code>		parser.swagger.Paths.Paths[routeProperties.Path] = pathItem</code></span>
<span class="codeline" id="line-1091"><code>	}</code></span>
<span class="codeline" id="line-1092"><code></code></span>
<span class="codeline" id="line-1093"><code>	return nil</code></span>
<span class="codeline" id="line-1094"><code>}</code></span>
<span class="codeline" id="line-1095"><code></code></span>
<span class="codeline" id="line-1096"><code>func convertFromSpecificToPrimitive(typeName string) (string, error) {</code></span>
<span class="codeline" id="line-1097"><code>	name := typeName</code></span>
<span class="codeline" id="line-1098"><code>	if strings.ContainsRune(name, '.') {</code></span>
<span class="codeline" id="line-1099"><code>		name = strings.Split(name, ".")[1]</code></span>
<span class="codeline" id="line-1100"><code>	}</code></span>
<span class="codeline" id="line-1101"><code></code></span>
<span class="codeline" id="line-1102"><code>	switch strings.ToUpper(name) {</code></span>
<span class="codeline" id="line-1103"><code>	case "TIME", "OBJECTID", "UUID":</code></span>
<span class="codeline" id="line-1104"><code>		return STRING, nil</code></span>
<span class="codeline" id="line-1105"><code>	case "DECIMAL":</code></span>
<span class="codeline" id="line-1106"><code>		return NUMBER, nil</code></span>
<span class="codeline" id="line-1107"><code>	}</code></span>
<span class="codeline" id="line-1108"><code></code></span>
<span class="codeline" id="line-1109"><code>	return typeName, ErrFailedConvertPrimitiveType</code></span>
<span class="codeline" id="line-1110"><code>}</code></span>
<span class="codeline" id="line-1111"><code></code></span>
<span class="codeline" id="line-1112"><code>func (parser *Parser) getTypeSchema(typeName string, file *ast.File, ref bool) (*spec.Schema, error) {</code></span>
<span class="codeline" id="line-1113"><code>	if override, ok := parser.Overrides[typeName]; ok {</code></span>
<span class="codeline" id="line-1114"><code>		parser.debug.Printf("Override detected for %s: using %s instead", typeName, override)</code></span>
<span class="codeline" id="line-1115"><code>		return parseObjectSchema(parser, override, file)</code></span>
<span class="codeline" id="line-1116"><code>	}</code></span>
<span class="codeline" id="line-1117"><code></code></span>
<span class="codeline" id="line-1118"><code>	if IsInterfaceLike(typeName) {</code></span>
<span class="codeline" id="line-1119"><code>		return &amp;spec.Schema{}, nil</code></span>
<span class="codeline" id="line-1120"><code>	}</code></span>
<span class="codeline" id="line-1121"><code>	if IsGolangPrimitiveType(typeName) {</code></span>
<span class="codeline" id="line-1122"><code>		return PrimitiveSchema(TransToValidSchemeType(typeName)), nil</code></span>
<span class="codeline" id="line-1123"><code>	}</code></span>
<span class="codeline" id="line-1124"><code></code></span>
<span class="codeline" id="line-1125"><code>	schemaType, err := convertFromSpecificToPrimitive(typeName)</code></span>
<span class="codeline" id="line-1126"><code>	if err == nil {</code></span>
<span class="codeline" id="line-1127"><code>		return PrimitiveSchema(schemaType), nil</code></span>
<span class="codeline" id="line-1128"><code>	}</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>	typeSpecDef := parser.packages.FindTypeSpec(typeName, file)</code></span>
<span class="codeline" id="line-1131"><code>	if typeSpecDef == nil {</code></span>
<span class="codeline" id="line-1132"><code>		return nil, fmt.Errorf("cannot find type definition: %s", typeName)</code></span>
<span class="codeline" id="line-1133"><code>	}</code></span>
<span class="codeline" id="line-1134"><code></code></span>
<span class="codeline" id="line-1135"><code>	if override, ok := parser.Overrides[typeSpecDef.FullPath()]; ok {</code></span>
<span class="codeline" id="line-1136"><code>		if override == "" {</code></span>
<span class="codeline" id="line-1137"><code>			parser.debug.Printf("Override detected for %s: ignoring", typeSpecDef.FullPath())</code></span>
<span class="codeline" id="line-1138"><code></code></span>
<span class="codeline" id="line-1139"><code>			return nil, ErrSkippedField</code></span>
<span class="codeline" id="line-1140"><code>		}</code></span>
<span class="codeline" id="line-1141"><code></code></span>
<span class="codeline" id="line-1142"><code>		parser.debug.Printf("Override detected for %s: using %s instead", typeSpecDef.FullPath(), override)</code></span>
<span class="codeline" id="line-1143"><code></code></span>
<span class="codeline" id="line-1144"><code>		separator := strings.LastIndex(override, ".")</code></span>
<span class="codeline" id="line-1145"><code>		if separator == -1 {</code></span>
<span class="codeline" id="line-1146"><code>			// treat as a swaggertype tag</code></span>
<span class="codeline" id="line-1147"><code>			parts := strings.Split(override, ",")</code></span>
<span class="codeline" id="line-1148"><code></code></span>
<span class="codeline" id="line-1149"><code>			return BuildCustomSchema(parts)</code></span>
<span class="codeline" id="line-1150"><code>		}</code></span>
<span class="codeline" id="line-1151"><code></code></span>
<span class="codeline" id="line-1152"><code>		typeSpecDef = parser.packages.findTypeSpec(override[0:separator], override[separator+1:])</code></span>
<span class="codeline" id="line-1153"><code>	}</code></span>
<span class="codeline" id="line-1154"><code></code></span>
<span class="codeline" id="line-1155"><code>	schema, ok := parser.parsedSchemas[typeSpecDef]</code></span>
<span class="codeline" id="line-1156"><code>	if !ok {</code></span>
<span class="codeline" id="line-1157"><code>		var err error</code></span>
<span class="codeline" id="line-1158"><code></code></span>
<span class="codeline" id="line-1159"><code>		schema, err = parser.ParseDefinition(typeSpecDef)</code></span>
<span class="codeline" id="line-1160"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1161"><code>			if err == ErrRecursiveParseStruct &amp;&amp; ref {</code></span>
<span class="codeline" id="line-1162"><code>				return parser.getRefTypeSchema(typeSpecDef, schema), nil</code></span>
<span class="codeline" id="line-1163"><code>			}</code></span>
<span class="codeline" id="line-1164"><code>			return nil, fmt.Errorf("%s: %w", typeName, err)</code></span>
<span class="codeline" id="line-1165"><code>		}</code></span>
<span class="codeline" id="line-1166"><code>	}</code></span>
<span class="codeline" id="line-1167"><code></code></span>
<span class="codeline" id="line-1168"><code>	if ref {</code></span>
<span class="codeline" id="line-1169"><code>		if IsComplexSchema(schema.Schema) {</code></span>
<span class="codeline" id="line-1170"><code>			return parser.getRefTypeSchema(typeSpecDef, schema), nil</code></span>
<span class="codeline" id="line-1171"><code>		}</code></span>
<span class="codeline" id="line-1172"><code>		// if it is a simple schema, just return a copy</code></span>
<span class="codeline" id="line-1173"><code>		newSchema := *schema.Schema</code></span>
<span class="codeline" id="line-1174"><code>		return &amp;newSchema, nil</code></span>
<span class="codeline" id="line-1175"><code>	}</code></span>
<span class="codeline" id="line-1176"><code></code></span>
<span class="codeline" id="line-1177"><code>	return schema.Schema, nil</code></span>
<span class="codeline" id="line-1178"><code>}</code></span>
<span class="codeline" id="line-1179"><code></code></span>
<span class="codeline" id="line-1180"><code>func (parser *Parser) getRefTypeSchema(typeSpecDef *TypeSpecDef, schema *Schema) *spec.Schema {</code></span>
<span class="codeline" id="line-1181"><code>	_, ok := parser.outputSchemas[typeSpecDef]</code></span>
<span class="codeline" id="line-1182"><code>	if !ok {</code></span>
<span class="codeline" id="line-1183"><code>		parser.swagger.Definitions[schema.Name] = spec.Schema{}</code></span>
<span class="codeline" id="line-1184"><code></code></span>
<span class="codeline" id="line-1185"><code>		if schema.Schema != nil {</code></span>
<span class="codeline" id="line-1186"><code>			parser.swagger.Definitions[schema.Name] = *schema.Schema</code></span>
<span class="codeline" id="line-1187"><code>		}</code></span>
<span class="codeline" id="line-1188"><code></code></span>
<span class="codeline" id="line-1189"><code>		parser.outputSchemas[typeSpecDef] = schema</code></span>
<span class="codeline" id="line-1190"><code>	}</code></span>
<span class="codeline" id="line-1191"><code></code></span>
<span class="codeline" id="line-1192"><code>	refSchema := RefSchema(schema.Name)</code></span>
<span class="codeline" id="line-1193"><code></code></span>
<span class="codeline" id="line-1194"><code>	return refSchema</code></span>
<span class="codeline" id="line-1195"><code>}</code></span>
<span class="codeline" id="line-1196"><code></code></span>
<span class="codeline" id="line-1197"><code>func (parser *Parser) isInStructStack(typeSpecDef *TypeSpecDef) bool {</code></span>
<span class="codeline" id="line-1198"><code>	for _, specDef := range parser.structStack {</code></span>
<span class="codeline" id="line-1199"><code>		if typeSpecDef == specDef {</code></span>
<span class="codeline" id="line-1200"><code>			return true</code></span>
<span class="codeline" id="line-1201"><code>		}</code></span>
<span class="codeline" id="line-1202"><code>	}</code></span>
<span class="codeline" id="line-1203"><code></code></span>
<span class="codeline" id="line-1204"><code>	return false</code></span>
<span class="codeline" id="line-1205"><code>}</code></span>
<span class="codeline" id="line-1206"><code></code></span>
<span class="codeline" id="line-1207"><code>// ParseDefinition parses given type spec that corresponds to the type under</code></span>
<span class="codeline" id="line-1208"><code>// given name and package, and populates swagger schema definitions registry</code></span>
<span class="codeline" id="line-1209"><code>// with a schema for the given type</code></span>
<span class="codeline" id="line-1210"><code>func (parser *Parser) ParseDefinition(typeSpecDef *TypeSpecDef) (*Schema, error) {</code></span>
<span class="codeline" id="line-1211"><code>	typeName := typeSpecDef.TypeName()</code></span>
<span class="codeline" id="line-1212"><code>	schema, found := parser.parsedSchemas[typeSpecDef]</code></span>
<span class="codeline" id="line-1213"><code>	if found {</code></span>
<span class="codeline" id="line-1214"><code>		parser.debug.Printf("Skipping '%s', already parsed.", typeName)</code></span>
<span class="codeline" id="line-1215"><code></code></span>
<span class="codeline" id="line-1216"><code>		return schema, nil</code></span>
<span class="codeline" id="line-1217"><code>	}</code></span>
<span class="codeline" id="line-1218"><code></code></span>
<span class="codeline" id="line-1219"><code>	if parser.isInStructStack(typeSpecDef) {</code></span>
<span class="codeline" id="line-1220"><code>		parser.debug.Printf("Skipping '%s', recursion detected.", typeName)</code></span>
<span class="codeline" id="line-1221"><code></code></span>
<span class="codeline" id="line-1222"><code>		return &amp;Schema{</code></span>
<span class="codeline" id="line-1223"><code>				Name:    typeName,</code></span>
<span class="codeline" id="line-1224"><code>				PkgPath: typeSpecDef.PkgPath,</code></span>
<span class="codeline" id="line-1225"><code>				Schema:  PrimitiveSchema(OBJECT),</code></span>
<span class="codeline" id="line-1226"><code>			},</code></span>
<span class="codeline" id="line-1227"><code>			ErrRecursiveParseStruct</code></span>
<span class="codeline" id="line-1228"><code>	}</code></span>
<span class="codeline" id="line-1229"><code></code></span>
<span class="codeline" id="line-1230"><code>	parser.structStack = append(parser.structStack, typeSpecDef)</code></span>
<span class="codeline" id="line-1231"><code></code></span>
<span class="codeline" id="line-1232"><code>	parser.debug.Printf("Generating %s", typeName)</code></span>
<span class="codeline" id="line-1233"><code></code></span>
<span class="codeline" id="line-1234"><code>	definition, err := parser.parseTypeExpr(typeSpecDef.File, typeSpecDef.TypeSpec.Type, false)</code></span>
<span class="codeline" id="line-1235"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1236"><code>		parser.debug.Printf("Error parsing type definition '%s': %s", typeName, err)</code></span>
<span class="codeline" id="line-1237"><code>		return nil, err</code></span>
<span class="codeline" id="line-1238"><code>	}</code></span>
<span class="codeline" id="line-1239"><code></code></span>
<span class="codeline" id="line-1240"><code>	if definition.Description == "" {</code></span>
<span class="codeline" id="line-1241"><code>		fillDefinitionDescription(definition, typeSpecDef.File, typeSpecDef)</code></span>
<span class="codeline" id="line-1242"><code>	}</code></span>
<span class="codeline" id="line-1243"><code></code></span>
<span class="codeline" id="line-1244"><code>	if len(typeSpecDef.Enums) &gt; 0 {</code></span>
<span class="codeline" id="line-1245"><code>		var varnames []string</code></span>
<span class="codeline" id="line-1246"><code>		var enumComments = make(map[string]string)</code></span>
<span class="codeline" id="line-1247"><code>		for _, value := range typeSpecDef.Enums {</code></span>
<span class="codeline" id="line-1248"><code>			definition.Enum = append(definition.Enum, value.Value)</code></span>
<span class="codeline" id="line-1249"><code>			varnames = append(varnames, value.key)</code></span>
<span class="codeline" id="line-1250"><code>			if len(value.Comment) &gt; 0 {</code></span>
<span class="codeline" id="line-1251"><code>				enumComments[value.key] = value.Comment</code></span>
<span class="codeline" id="line-1252"><code>			}</code></span>
<span class="codeline" id="line-1253"><code>		}</code></span>
<span class="codeline" id="line-1254"><code>		if definition.Extensions == nil {</code></span>
<span class="codeline" id="line-1255"><code>			definition.Extensions = make(spec.Extensions)</code></span>
<span class="codeline" id="line-1256"><code>		}</code></span>
<span class="codeline" id="line-1257"><code>		definition.Extensions[enumVarNamesExtension] = varnames</code></span>
<span class="codeline" id="line-1258"><code>		if len(enumComments) &gt; 0 {</code></span>
<span class="codeline" id="line-1259"><code>			definition.Extensions[enumCommentsExtension] = enumComments</code></span>
<span class="codeline" id="line-1260"><code>		}</code></span>
<span class="codeline" id="line-1261"><code>	}</code></span>
<span class="codeline" id="line-1262"><code></code></span>
<span class="codeline" id="line-1263"><code>	sch := Schema{</code></span>
<span class="codeline" id="line-1264"><code>		Name:    typeName,</code></span>
<span class="codeline" id="line-1265"><code>		PkgPath: typeSpecDef.PkgPath,</code></span>
<span class="codeline" id="line-1266"><code>		Schema:  definition,</code></span>
<span class="codeline" id="line-1267"><code>	}</code></span>
<span class="codeline" id="line-1268"><code>	parser.parsedSchemas[typeSpecDef] = &amp;sch</code></span>
<span class="codeline" id="line-1269"><code></code></span>
<span class="codeline" id="line-1270"><code>	// update an empty schema as a result of recursion</code></span>
<span class="codeline" id="line-1271"><code>	s2, found := parser.outputSchemas[typeSpecDef]</code></span>
<span class="codeline" id="line-1272"><code>	if found {</code></span>
<span class="codeline" id="line-1273"><code>		parser.swagger.Definitions[s2.Name] = *definition</code></span>
<span class="codeline" id="line-1274"><code>	}</code></span>
<span class="codeline" id="line-1275"><code></code></span>
<span class="codeline" id="line-1276"><code>	return &amp;sch, nil</code></span>
<span class="codeline" id="line-1277"><code>}</code></span>
<span class="codeline" id="line-1278"><code></code></span>
<span class="codeline" id="line-1279"><code>func fullTypeName(parts ...string) string {</code></span>
<span class="codeline" id="line-1280"><code>	return strings.Join(parts, ".")</code></span>
<span class="codeline" id="line-1281"><code>}</code></span>
<span class="codeline" id="line-1282"><code></code></span>
<span class="codeline" id="line-1283"><code>// fillDefinitionDescription additionally fills fields in definition (spec.Schema)</code></span>
<span class="codeline" id="line-1284"><code>// TODO: If .go file contains many types, it may work for a long time</code></span>
<span class="codeline" id="line-1285"><code>func fillDefinitionDescription(definition *spec.Schema, file *ast.File, typeSpecDef *TypeSpecDef) {</code></span>
<span class="codeline" id="line-1286"><code>	if file == nil {</code></span>
<span class="codeline" id="line-1287"><code>		return</code></span>
<span class="codeline" id="line-1288"><code>	}</code></span>
<span class="codeline" id="line-1289"><code>	for _, astDeclaration := range file.Decls {</code></span>
<span class="codeline" id="line-1290"><code>		generalDeclaration, ok := astDeclaration.(*ast.GenDecl)</code></span>
<span class="codeline" id="line-1291"><code>		if !ok || generalDeclaration.Tok != token.TYPE {</code></span>
<span class="codeline" id="line-1292"><code>			continue</code></span>
<span class="codeline" id="line-1293"><code>		}</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>		for _, astSpec := range generalDeclaration.Specs {</code></span>
<span class="codeline" id="line-1296"><code>			typeSpec, ok := astSpec.(*ast.TypeSpec)</code></span>
<span class="codeline" id="line-1297"><code>			if !ok || typeSpec != typeSpecDef.TypeSpec {</code></span>
<span class="codeline" id="line-1298"><code>				continue</code></span>
<span class="codeline" id="line-1299"><code>			}</code></span>
<span class="codeline" id="line-1300"><code></code></span>
<span class="codeline" id="line-1301"><code>			definition.Description =</code></span>
<span class="codeline" id="line-1302"><code>				extractDeclarationDescription(typeSpec.Doc, typeSpec.Comment, generalDeclaration.Doc)</code></span>
<span class="codeline" id="line-1303"><code>		}</code></span>
<span class="codeline" id="line-1304"><code>	}</code></span>
<span class="codeline" id="line-1305"><code>}</code></span>
<span class="codeline" id="line-1306"><code></code></span>
<span class="codeline" id="line-1307"><code>// extractDeclarationDescription gets first description</code></span>
<span class="codeline" id="line-1308"><code>// from attribute descriptionAttr in commentGroups (ast.CommentGroup)</code></span>
<span class="codeline" id="line-1309"><code>func extractDeclarationDescription(commentGroups ...*ast.CommentGroup) string {</code></span>
<span class="codeline" id="line-1310"><code>	var description string</code></span>
<span class="codeline" id="line-1311"><code></code></span>
<span class="codeline" id="line-1312"><code>	for _, commentGroup := range commentGroups {</code></span>
<span class="codeline" id="line-1313"><code>		if commentGroup == nil {</code></span>
<span class="codeline" id="line-1314"><code>			continue</code></span>
<span class="codeline" id="line-1315"><code>		}</code></span>
<span class="codeline" id="line-1316"><code></code></span>
<span class="codeline" id="line-1317"><code>		isHandlingDescription := false</code></span>
<span class="codeline" id="line-1318"><code></code></span>
<span class="codeline" id="line-1319"><code>		for _, comment := range commentGroup.List {</code></span>
<span class="codeline" id="line-1320"><code>			commentText := strings.TrimSpace(strings.TrimLeft(comment.Text, "/"))</code></span>
<span class="codeline" id="line-1321"><code>			if len(commentText) == 0 {</code></span>
<span class="codeline" id="line-1322"><code>				continue</code></span>
<span class="codeline" id="line-1323"><code>			}</code></span>
<span class="codeline" id="line-1324"><code>			attribute := FieldsByAnySpace(commentText, 2)[0]</code></span>
<span class="codeline" id="line-1325"><code></code></span>
<span class="codeline" id="line-1326"><code>			if strings.ToLower(attribute) != descriptionAttr {</code></span>
<span class="codeline" id="line-1327"><code>				if !isHandlingDescription {</code></span>
<span class="codeline" id="line-1328"><code>					continue</code></span>
<span class="codeline" id="line-1329"><code>				}</code></span>
<span class="codeline" id="line-1330"><code></code></span>
<span class="codeline" id="line-1331"><code>				break</code></span>
<span class="codeline" id="line-1332"><code>			}</code></span>
<span class="codeline" id="line-1333"><code></code></span>
<span class="codeline" id="line-1334"><code>			isHandlingDescription = true</code></span>
<span class="codeline" id="line-1335"><code>			description += " " + strings.TrimSpace(commentText[len(attribute):])</code></span>
<span class="codeline" id="line-1336"><code>		}</code></span>
<span class="codeline" id="line-1337"><code>	}</code></span>
<span class="codeline" id="line-1338"><code></code></span>
<span class="codeline" id="line-1339"><code>	return strings.TrimLeft(description, " ")</code></span>
<span class="codeline" id="line-1340"><code>}</code></span>
<span class="codeline" id="line-1341"><code></code></span>
<span class="codeline" id="line-1342"><code>// parseTypeExpr parses given type expression that corresponds to the type under</code></span>
<span class="codeline" id="line-1343"><code>// given name and package, and returns swagger schema for it.</code></span>
<span class="codeline" id="line-1344"><code>func (parser *Parser) parseTypeExpr(file *ast.File, typeExpr ast.Expr, ref bool) (*spec.Schema, error) {</code></span>
<span class="codeline" id="line-1345"><code>	switch expr := typeExpr.(type) {</code></span>
<span class="codeline" id="line-1346"><code>	// type Foo interface{}</code></span>
<span class="codeline" id="line-1347"><code>	case *ast.InterfaceType:</code></span>
<span class="codeline" id="line-1348"><code>		return &amp;spec.Schema{}, nil</code></span>
<span class="codeline" id="line-1349"><code></code></span>
<span class="codeline" id="line-1350"><code>	// type Foo struct {...}</code></span>
<span class="codeline" id="line-1351"><code>	case *ast.StructType:</code></span>
<span class="codeline" id="line-1352"><code>		return parser.parseStruct(file, expr.Fields)</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>	// type Foo Baz</code></span>
<span class="codeline" id="line-1355"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-1356"><code>		return parser.getTypeSchema(expr.Name, file, ref)</code></span>
<span class="codeline" id="line-1357"><code></code></span>
<span class="codeline" id="line-1358"><code>	// type Foo *Baz</code></span>
<span class="codeline" id="line-1359"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-1360"><code>		return parser.parseTypeExpr(file, expr.X, ref)</code></span>
<span class="codeline" id="line-1361"><code></code></span>
<span class="codeline" id="line-1362"><code>	// type Foo pkg.Bar</code></span>
<span class="codeline" id="line-1363"><code>	case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-1364"><code>		if xIdent, ok := expr.X.(*ast.Ident); ok {</code></span>
<span class="codeline" id="line-1365"><code>			return parser.getTypeSchema(fullTypeName(xIdent.Name, expr.Sel.Name), file, ref)</code></span>
<span class="codeline" id="line-1366"><code>		}</code></span>
<span class="codeline" id="line-1367"><code>	// type Foo []Baz</code></span>
<span class="codeline" id="line-1368"><code>	case *ast.ArrayType:</code></span>
<span class="codeline" id="line-1369"><code>		itemSchema, err := parser.parseTypeExpr(file, expr.Elt, true)</code></span>
<span class="codeline" id="line-1370"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1371"><code>			return nil, err</code></span>
<span class="codeline" id="line-1372"><code>		}</code></span>
<span class="codeline" id="line-1373"><code></code></span>
<span class="codeline" id="line-1374"><code>		return spec.ArrayProperty(itemSchema), nil</code></span>
<span class="codeline" id="line-1375"><code>	// type Foo map[string]Bar</code></span>
<span class="codeline" id="line-1376"><code>	case *ast.MapType:</code></span>
<span class="codeline" id="line-1377"><code>		if _, ok := expr.Value.(*ast.InterfaceType); ok {</code></span>
<span class="codeline" id="line-1378"><code>			return spec.MapProperty(nil), nil</code></span>
<span class="codeline" id="line-1379"><code>		}</code></span>
<span class="codeline" id="line-1380"><code>		schema, err := parser.parseTypeExpr(file, expr.Value, true)</code></span>
<span class="codeline" id="line-1381"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1382"><code>			return nil, err</code></span>
<span class="codeline" id="line-1383"><code>		}</code></span>
<span class="codeline" id="line-1384"><code></code></span>
<span class="codeline" id="line-1385"><code>		return spec.MapProperty(schema), nil</code></span>
<span class="codeline" id="line-1386"><code></code></span>
<span class="codeline" id="line-1387"><code>	case *ast.FuncType:</code></span>
<span class="codeline" id="line-1388"><code>		return nil, ErrFuncTypeField</code></span>
<span class="codeline" id="line-1389"><code>		// ...</code></span>
<span class="codeline" id="line-1390"><code>	}</code></span>
<span class="codeline" id="line-1391"><code></code></span>
<span class="codeline" id="line-1392"><code>	return parser.parseGenericTypeExpr(file, typeExpr)</code></span>
<span class="codeline" id="line-1393"><code>}</code></span>
<span class="codeline" id="line-1394"><code></code></span>
<span class="codeline" id="line-1395"><code>func (parser *Parser) parseStruct(file *ast.File, fields *ast.FieldList) (*spec.Schema, error) {</code></span>
<span class="codeline" id="line-1396"><code>	required, properties := make([]string, 0), make(map[string]spec.Schema)</code></span>
<span class="codeline" id="line-1397"><code></code></span>
<span class="codeline" id="line-1398"><code>	for _, field := range fields.List {</code></span>
<span class="codeline" id="line-1399"><code>		fieldProps, requiredFromAnon, err := parser.parseStructField(file, field)</code></span>
<span class="codeline" id="line-1400"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1401"><code>			if errors.Is(err, ErrFuncTypeField) || errors.Is(err, ErrSkippedField) {</code></span>
<span class="codeline" id="line-1402"><code>				continue</code></span>
<span class="codeline" id="line-1403"><code>			}</code></span>
<span class="codeline" id="line-1404"><code></code></span>
<span class="codeline" id="line-1405"><code>			return nil, err</code></span>
<span class="codeline" id="line-1406"><code>		}</code></span>
<span class="codeline" id="line-1407"><code></code></span>
<span class="codeline" id="line-1408"><code>		if len(fieldProps) == 0 {</code></span>
<span class="codeline" id="line-1409"><code>			continue</code></span>
<span class="codeline" id="line-1410"><code>		}</code></span>
<span class="codeline" id="line-1411"><code></code></span>
<span class="codeline" id="line-1412"><code>		required = append(required, requiredFromAnon...)</code></span>
<span class="codeline" id="line-1413"><code></code></span>
<span class="codeline" id="line-1414"><code>		for k, v := range fieldProps {</code></span>
<span class="codeline" id="line-1415"><code>			properties[k] = v</code></span>
<span class="codeline" id="line-1416"><code>		}</code></span>
<span class="codeline" id="line-1417"><code>	}</code></span>
<span class="codeline" id="line-1418"><code></code></span>
<span class="codeline" id="line-1419"><code>	sort.Strings(required)</code></span>
<span class="codeline" id="line-1420"><code></code></span>
<span class="codeline" id="line-1421"><code>	return &amp;spec.Schema{</code></span>
<span class="codeline" id="line-1422"><code>		SchemaProps: spec.SchemaProps{</code></span>
<span class="codeline" id="line-1423"><code>			Type:       []string{OBJECT},</code></span>
<span class="codeline" id="line-1424"><code>			Properties: properties,</code></span>
<span class="codeline" id="line-1425"><code>			Required:   required,</code></span>
<span class="codeline" id="line-1426"><code>		},</code></span>
<span class="codeline" id="line-1427"><code>	}, nil</code></span>
<span class="codeline" id="line-1428"><code>}</code></span>
<span class="codeline" id="line-1429"><code></code></span>
<span class="codeline" id="line-1430"><code>func (parser *Parser) parseStructField(file *ast.File, field *ast.Field) (map[string]spec.Schema, []string, error) {</code></span>
<span class="codeline" id="line-1431"><code>	if field.Tag != nil {</code></span>
<span class="codeline" id="line-1432"><code>		skip, ok := reflect.StructTag(strings.ReplaceAll(field.Tag.Value, "`", "")).Lookup("swaggerignore")</code></span>
<span class="codeline" id="line-1433"><code>		if ok &amp;&amp; strings.EqualFold(skip, "true") {</code></span>
<span class="codeline" id="line-1434"><code>			return nil, nil, nil</code></span>
<span class="codeline" id="line-1435"><code>		}</code></span>
<span class="codeline" id="line-1436"><code>	}</code></span>
<span class="codeline" id="line-1437"><code></code></span>
<span class="codeline" id="line-1438"><code>	ps := parser.fieldParserFactory(parser, field)</code></span>
<span class="codeline" id="line-1439"><code></code></span>
<span class="codeline" id="line-1440"><code>	if ps.ShouldSkip() {</code></span>
<span class="codeline" id="line-1441"><code>		return nil, nil, nil</code></span>
<span class="codeline" id="line-1442"><code>	}</code></span>
<span class="codeline" id="line-1443"><code></code></span>
<span class="codeline" id="line-1444"><code>	fieldName, err := ps.FieldName()</code></span>
<span class="codeline" id="line-1445"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1446"><code>		return nil, nil, err</code></span>
<span class="codeline" id="line-1447"><code>	}</code></span>
<span class="codeline" id="line-1448"><code></code></span>
<span class="codeline" id="line-1449"><code>	if fieldName == "" {</code></span>
<span class="codeline" id="line-1450"><code>		typeName, err := getFieldType(file, field.Type, nil)</code></span>
<span class="codeline" id="line-1451"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1452"><code>			return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1453"><code>		}</code></span>
<span class="codeline" id="line-1454"><code></code></span>
<span class="codeline" id="line-1455"><code>		schema, err := parser.getTypeSchema(typeName, file, false)</code></span>
<span class="codeline" id="line-1456"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1457"><code>			return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1458"><code>		}</code></span>
<span class="codeline" id="line-1459"><code></code></span>
<span class="codeline" id="line-1460"><code>		if len(schema.Type) &gt; 0 &amp;&amp; schema.Type[0] == OBJECT {</code></span>
<span class="codeline" id="line-1461"><code>			if len(schema.Properties) == 0 {</code></span>
<span class="codeline" id="line-1462"><code>				return nil, nil, nil</code></span>
<span class="codeline" id="line-1463"><code>			}</code></span>
<span class="codeline" id="line-1464"><code></code></span>
<span class="codeline" id="line-1465"><code>			properties := map[string]spec.Schema{}</code></span>
<span class="codeline" id="line-1466"><code>			for k, v := range schema.Properties {</code></span>
<span class="codeline" id="line-1467"><code>				properties[k] = v</code></span>
<span class="codeline" id="line-1468"><code>			}</code></span>
<span class="codeline" id="line-1469"><code></code></span>
<span class="codeline" id="line-1470"><code>			return properties, schema.SchemaProps.Required, nil</code></span>
<span class="codeline" id="line-1471"><code>		}</code></span>
<span class="codeline" id="line-1472"><code>		// for alias type of non-struct types ,such as array,map, etc. ignore field tag.</code></span>
<span class="codeline" id="line-1473"><code>		return map[string]spec.Schema{typeName: *schema}, nil, nil</code></span>
<span class="codeline" id="line-1474"><code></code></span>
<span class="codeline" id="line-1475"><code>	}</code></span>
<span class="codeline" id="line-1476"><code></code></span>
<span class="codeline" id="line-1477"><code>	schema, err := ps.CustomSchema()</code></span>
<span class="codeline" id="line-1478"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1479"><code>		return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1480"><code>	}</code></span>
<span class="codeline" id="line-1481"><code></code></span>
<span class="codeline" id="line-1482"><code>	if schema == nil {</code></span>
<span class="codeline" id="line-1483"><code>		typeName, err := getFieldType(file, field.Type, nil)</code></span>
<span class="codeline" id="line-1484"><code>		if err == nil {</code></span>
<span class="codeline" id="line-1485"><code>			// named type</code></span>
<span class="codeline" id="line-1486"><code>			schema, err = parser.getTypeSchema(typeName, file, true)</code></span>
<span class="codeline" id="line-1487"><code>		} else {</code></span>
<span class="codeline" id="line-1488"><code>			// unnamed type</code></span>
<span class="codeline" id="line-1489"><code>			schema, err = parser.parseTypeExpr(file, field.Type, false)</code></span>
<span class="codeline" id="line-1490"><code>		}</code></span>
<span class="codeline" id="line-1491"><code></code></span>
<span class="codeline" id="line-1492"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1493"><code>			return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1494"><code>		}</code></span>
<span class="codeline" id="line-1495"><code>	}</code></span>
<span class="codeline" id="line-1496"><code></code></span>
<span class="codeline" id="line-1497"><code>	err = ps.ComplementSchema(schema)</code></span>
<span class="codeline" id="line-1498"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1499"><code>		return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1500"><code>	}</code></span>
<span class="codeline" id="line-1501"><code></code></span>
<span class="codeline" id="line-1502"><code>	var tagRequired []string</code></span>
<span class="codeline" id="line-1503"><code></code></span>
<span class="codeline" id="line-1504"><code>	required, err := ps.IsRequired()</code></span>
<span class="codeline" id="line-1505"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1506"><code>		return nil, nil, fmt.Errorf("%s: %w", fieldName, err)</code></span>
<span class="codeline" id="line-1507"><code>	}</code></span>
<span class="codeline" id="line-1508"><code></code></span>
<span class="codeline" id="line-1509"><code>	if required {</code></span>
<span class="codeline" id="line-1510"><code>		tagRequired = append(tagRequired, fieldName)</code></span>
<span class="codeline" id="line-1511"><code>	}</code></span>
<span class="codeline" id="line-1512"><code></code></span>
<span class="codeline" id="line-1513"><code>	if schema.Extensions == nil {</code></span>
<span class="codeline" id="line-1514"><code>		schema.Extensions = make(spec.Extensions)</code></span>
<span class="codeline" id="line-1515"><code>	}</code></span>
<span class="codeline" id="line-1516"><code>	if formName := ps.FormName(); len(formName) &gt; 0 {</code></span>
<span class="codeline" id="line-1517"><code>		schema.Extensions["formData"] = formName</code></span>
<span class="codeline" id="line-1518"><code>	}</code></span>
<span class="codeline" id="line-1519"><code>	if headerName := ps.HeaderName(); len(headerName) &gt; 0 {</code></span>
<span class="codeline" id="line-1520"><code>		schema.Extensions["header"] = headerName</code></span>
<span class="codeline" id="line-1521"><code>	}</code></span>
<span class="codeline" id="line-1522"><code>	if pathName := ps.PathName(); len(pathName) &gt; 0 {</code></span>
<span class="codeline" id="line-1523"><code>		schema.Extensions["path"] = pathName</code></span>
<span class="codeline" id="line-1524"><code>	}</code></span>
<span class="codeline" id="line-1525"><code></code></span>
<span class="codeline" id="line-1526"><code>	return map[string]spec.Schema{fieldName: *schema}, tagRequired, nil</code></span>
<span class="codeline" id="line-1527"><code>}</code></span>
<span class="codeline" id="line-1528"><code></code></span>
<span class="codeline" id="line-1529"><code>func getFieldType(file *ast.File, field ast.Expr, genericParamTypeDefs map[string]*genericTypeSpec) (string, error) {</code></span>
<span class="codeline" id="line-1530"><code>	switch fieldType := field.(type) {</code></span>
<span class="codeline" id="line-1531"><code>	case *ast.Ident:</code></span>
<span class="codeline" id="line-1532"><code>		return fieldType.Name, nil</code></span>
<span class="codeline" id="line-1533"><code>	case *ast.SelectorExpr:</code></span>
<span class="codeline" id="line-1534"><code>		packageName, err := getFieldType(file, fieldType.X, genericParamTypeDefs)</code></span>
<span class="codeline" id="line-1535"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1536"><code>			return "", err</code></span>
<span class="codeline" id="line-1537"><code>		}</code></span>
<span class="codeline" id="line-1538"><code></code></span>
<span class="codeline" id="line-1539"><code>		return fullTypeName(packageName, fieldType.Sel.Name), nil</code></span>
<span class="codeline" id="line-1540"><code>	case *ast.StarExpr:</code></span>
<span class="codeline" id="line-1541"><code>		fullName, err := getFieldType(file, fieldType.X, genericParamTypeDefs)</code></span>
<span class="codeline" id="line-1542"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1543"><code>			return "", err</code></span>
<span class="codeline" id="line-1544"><code>		}</code></span>
<span class="codeline" id="line-1545"><code></code></span>
<span class="codeline" id="line-1546"><code>		return fullName, nil</code></span>
<span class="codeline" id="line-1547"><code>	default:</code></span>
<span class="codeline" id="line-1548"><code>		return getGenericFieldType(file, field, genericParamTypeDefs)</code></span>
<span class="codeline" id="line-1549"><code>	}</code></span>
<span class="codeline" id="line-1550"><code>}</code></span>
<span class="codeline" id="line-1551"><code></code></span>
<span class="codeline" id="line-1552"><code>func (parser *Parser) getUnderlyingSchema(schema *spec.Schema) *spec.Schema {</code></span>
<span class="codeline" id="line-1553"><code>	if schema == nil {</code></span>
<span class="codeline" id="line-1554"><code>		return nil</code></span>
<span class="codeline" id="line-1555"><code>	}</code></span>
<span class="codeline" id="line-1556"><code></code></span>
<span class="codeline" id="line-1557"><code>	if url := schema.Ref.GetURL(); url != nil {</code></span>
<span class="codeline" id="line-1558"><code>		if pos := strings.LastIndexByte(url.Fragment, '/'); pos &gt;= 0 {</code></span>
<span class="codeline" id="line-1559"><code>			name := url.Fragment[pos+1:]</code></span>
<span class="codeline" id="line-1560"><code>			if schema, ok := parser.swagger.Definitions[name]; ok {</code></span>
<span class="codeline" id="line-1561"><code>				return &amp;schema</code></span>
<span class="codeline" id="line-1562"><code>			}</code></span>
<span class="codeline" id="line-1563"><code>		}</code></span>
<span class="codeline" id="line-1564"><code>	}</code></span>
<span class="codeline" id="line-1565"><code></code></span>
<span class="codeline" id="line-1566"><code>	if len(schema.AllOf) &gt; 0 {</code></span>
<span class="codeline" id="line-1567"><code>		merged := &amp;spec.Schema{}</code></span>
<span class="codeline" id="line-1568"><code>		MergeSchema(merged, schema)</code></span>
<span class="codeline" id="line-1569"><code>		for _, s := range schema.AllOf {</code></span>
<span class="codeline" id="line-1570"><code>			MergeSchema(merged, parser.getUnderlyingSchema(&amp;s))</code></span>
<span class="codeline" id="line-1571"><code>		}</code></span>
<span class="codeline" id="line-1572"><code>		return merged</code></span>
<span class="codeline" id="line-1573"><code>	}</code></span>
<span class="codeline" id="line-1574"><code>	return nil</code></span>
<span class="codeline" id="line-1575"><code>}</code></span>
<span class="codeline" id="line-1576"><code></code></span>
<span class="codeline" id="line-1577"><code>// GetSchemaTypePath get path of schema type.</code></span>
<span class="codeline" id="line-1578"><code>func (parser *Parser) GetSchemaTypePath(schema *spec.Schema, depth int) []string {</code></span>
<span class="codeline" id="line-1579"><code>	if schema == nil || depth == 0 {</code></span>
<span class="codeline" id="line-1580"><code>		return nil</code></span>
<span class="codeline" id="line-1581"><code>	}</code></span>
<span class="codeline" id="line-1582"><code></code></span>
<span class="codeline" id="line-1583"><code>	if underlying := parser.getUnderlyingSchema(schema); underlying != nil {</code></span>
<span class="codeline" id="line-1584"><code>		return parser.GetSchemaTypePath(underlying, depth)</code></span>
<span class="codeline" id="line-1585"><code>	}</code></span>
<span class="codeline" id="line-1586"><code></code></span>
<span class="codeline" id="line-1587"><code>	if len(schema.Type) &gt; 0 {</code></span>
<span class="codeline" id="line-1588"><code>		switch schema.Type[0] {</code></span>
<span class="codeline" id="line-1589"><code>		case ARRAY:</code></span>
<span class="codeline" id="line-1590"><code>			depth--</code></span>
<span class="codeline" id="line-1591"><code></code></span>
<span class="codeline" id="line-1592"><code>			s := []string{schema.Type[0]}</code></span>
<span class="codeline" id="line-1593"><code></code></span>
<span class="codeline" id="line-1594"><code>			return append(s, parser.GetSchemaTypePath(schema.Items.Schema, depth)...)</code></span>
<span class="codeline" id="line-1595"><code>		case OBJECT:</code></span>
<span class="codeline" id="line-1596"><code>			if schema.AdditionalProperties != nil &amp;&amp; schema.AdditionalProperties.Schema != nil {</code></span>
<span class="codeline" id="line-1597"><code>				// for map</code></span>
<span class="codeline" id="line-1598"><code>				depth--</code></span>
<span class="codeline" id="line-1599"><code></code></span>
<span class="codeline" id="line-1600"><code>				s := []string{schema.Type[0]}</code></span>
<span class="codeline" id="line-1601"><code></code></span>
<span class="codeline" id="line-1602"><code>				return append(s, parser.GetSchemaTypePath(schema.AdditionalProperties.Schema, depth)...)</code></span>
<span class="codeline" id="line-1603"><code>			}</code></span>
<span class="codeline" id="line-1604"><code>		}</code></span>
<span class="codeline" id="line-1605"><code></code></span>
<span class="codeline" id="line-1606"><code>		return []string{schema.Type[0]}</code></span>
<span class="codeline" id="line-1607"><code>	}</code></span>
<span class="codeline" id="line-1608"><code></code></span>
<span class="codeline" id="line-1609"><code>	return []string{ANY}</code></span>
<span class="codeline" id="line-1610"><code>}</code></span>
<span class="codeline" id="line-1611"><code></code></span>
<span class="codeline" id="line-1612"><code>func replaceLastTag(slice []spec.Tag, element spec.Tag) {</code></span>
<span class="codeline" id="line-1613"><code>	slice = append(slice[:len(slice)-1], element)</code></span>
<span class="codeline" id="line-1614"><code>}</code></span>
<span class="codeline" id="line-1615"><code></code></span>
<span class="codeline" id="line-1616"><code>// defineTypeOfExample example value define the type (object and array unsupported).</code></span>
<span class="codeline" id="line-1617"><code>func defineTypeOfExample(schemaType, arrayType, exampleValue string) (interface{}, error) {</code></span>
<span class="codeline" id="line-1618"><code>	switch schemaType {</code></span>
<span class="codeline" id="line-1619"><code>	case STRING:</code></span>
<span class="codeline" id="line-1620"><code>		return exampleValue, nil</code></span>
<span class="codeline" id="line-1621"><code>	case NUMBER:</code></span>
<span class="codeline" id="line-1622"><code>		v, err := strconv.ParseFloat(exampleValue, 64)</code></span>
<span class="codeline" id="line-1623"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1624"><code>			return nil, fmt.Errorf("example value %s can't convert to %s err: %s", exampleValue, schemaType, err)</code></span>
<span class="codeline" id="line-1625"><code>		}</code></span>
<span class="codeline" id="line-1626"><code></code></span>
<span class="codeline" id="line-1627"><code>		return v, nil</code></span>
<span class="codeline" id="line-1628"><code>	case INTEGER:</code></span>
<span class="codeline" id="line-1629"><code>		v, err := strconv.Atoi(exampleValue)</code></span>
<span class="codeline" id="line-1630"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1631"><code>			return nil, fmt.Errorf("example value %s can't convert to %s err: %s", exampleValue, schemaType, err)</code></span>
<span class="codeline" id="line-1632"><code>		}</code></span>
<span class="codeline" id="line-1633"><code></code></span>
<span class="codeline" id="line-1634"><code>		return v, nil</code></span>
<span class="codeline" id="line-1635"><code>	case BOOLEAN:</code></span>
<span class="codeline" id="line-1636"><code>		v, err := strconv.ParseBool(exampleValue)</code></span>
<span class="codeline" id="line-1637"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1638"><code>			return nil, fmt.Errorf("example value %s can't convert to %s err: %s", exampleValue, schemaType, err)</code></span>
<span class="codeline" id="line-1639"><code>		}</code></span>
<span class="codeline" id="line-1640"><code></code></span>
<span class="codeline" id="line-1641"><code>		return v, nil</code></span>
<span class="codeline" id="line-1642"><code>	case ARRAY:</code></span>
<span class="codeline" id="line-1643"><code>		values := strings.Split(exampleValue, ",")</code></span>
<span class="codeline" id="line-1644"><code>		result := make([]interface{}, 0)</code></span>
<span class="codeline" id="line-1645"><code>		for _, value := range values {</code></span>
<span class="codeline" id="line-1646"><code>			v, err := defineTypeOfExample(arrayType, "", value)</code></span>
<span class="codeline" id="line-1647"><code>			if err != nil {</code></span>
<span class="codeline" id="line-1648"><code>				return nil, err</code></span>
<span class="codeline" id="line-1649"><code>			}</code></span>
<span class="codeline" id="line-1650"><code></code></span>
<span class="codeline" id="line-1651"><code>			result = append(result, v)</code></span>
<span class="codeline" id="line-1652"><code>		}</code></span>
<span class="codeline" id="line-1653"><code></code></span>
<span class="codeline" id="line-1654"><code>		return result, nil</code></span>
<span class="codeline" id="line-1655"><code>	case OBJECT:</code></span>
<span class="codeline" id="line-1656"><code>		if arrayType == "" {</code></span>
<span class="codeline" id="line-1657"><code>			return nil, fmt.Errorf("%s is unsupported type in example value `%s`", schemaType, exampleValue)</code></span>
<span class="codeline" id="line-1658"><code>		}</code></span>
<span class="codeline" id="line-1659"><code></code></span>
<span class="codeline" id="line-1660"><code>		values := strings.Split(exampleValue, ",")</code></span>
<span class="codeline" id="line-1661"><code></code></span>
<span class="codeline" id="line-1662"><code>		result := map[string]interface{}{}</code></span>
<span class="codeline" id="line-1663"><code></code></span>
<span class="codeline" id="line-1664"><code>		for _, value := range values {</code></span>
<span class="codeline" id="line-1665"><code>			mapData := strings.SplitN(value, ":", 2)</code></span>
<span class="codeline" id="line-1666"><code></code></span>
<span class="codeline" id="line-1667"><code>			if len(mapData) == 2 {</code></span>
<span class="codeline" id="line-1668"><code>				v, err := defineTypeOfExample(arrayType, "", mapData[1])</code></span>
<span class="codeline" id="line-1669"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1670"><code>					return nil, err</code></span>
<span class="codeline" id="line-1671"><code>				}</code></span>
<span class="codeline" id="line-1672"><code></code></span>
<span class="codeline" id="line-1673"><code>				result[mapData[0]] = v</code></span>
<span class="codeline" id="line-1674"><code></code></span>
<span class="codeline" id="line-1675"><code>				continue</code></span>
<span class="codeline" id="line-1676"><code>			}</code></span>
<span class="codeline" id="line-1677"><code></code></span>
<span class="codeline" id="line-1678"><code>			return nil, fmt.Errorf("example value %s should format: key:value", exampleValue)</code></span>
<span class="codeline" id="line-1679"><code>		}</code></span>
<span class="codeline" id="line-1680"><code></code></span>
<span class="codeline" id="line-1681"><code>		return result, nil</code></span>
<span class="codeline" id="line-1682"><code>	}</code></span>
<span class="codeline" id="line-1683"><code></code></span>
<span class="codeline" id="line-1684"><code>	return nil, fmt.Errorf("%s is unsupported type in example value %s", schemaType, exampleValue)</code></span>
<span class="codeline" id="line-1685"><code>}</code></span>
<span class="codeline" id="line-1686"><code></code></span>
<span class="codeline" id="line-1687"><code>// GetAllGoFileInfo gets all Go source files information for given searchDir.</code></span>
<span class="codeline" id="line-1688"><code>func (parser *Parser) getAllGoFileInfo(packageDir, searchDir string) error {</code></span>
<span class="codeline" id="line-1689"><code>	if parser.skipPackageByPrefix(packageDir) {</code></span>
<span class="codeline" id="line-1690"><code>		return nil // ignored by user-defined package path prefixes</code></span>
<span class="codeline" id="line-1691"><code>	}</code></span>
<span class="codeline" id="line-1692"><code>	return filepath.Walk(searchDir, func(path string, f os.FileInfo, _ error) error {</code></span>
<span class="codeline" id="line-1693"><code>		err := parser.Skip(path, f)</code></span>
<span class="codeline" id="line-1694"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1695"><code>			return err</code></span>
<span class="codeline" id="line-1696"><code>		}</code></span>
<span class="codeline" id="line-1697"><code></code></span>
<span class="codeline" id="line-1698"><code>		if f.IsDir() {</code></span>
<span class="codeline" id="line-1699"><code>			return nil</code></span>
<span class="codeline" id="line-1700"><code>		}</code></span>
<span class="codeline" id="line-1701"><code></code></span>
<span class="codeline" id="line-1702"><code>		relPath, err := filepath.Rel(searchDir, path)</code></span>
<span class="codeline" id="line-1703"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1704"><code>			return err</code></span>
<span class="codeline" id="line-1705"><code>		}</code></span>
<span class="codeline" id="line-1706"><code></code></span>
<span class="codeline" id="line-1707"><code>		return parser.parseFile(filepath.ToSlash(filepath.Dir(filepath.Clean(filepath.Join(packageDir, relPath)))), path, nil, ParseAll)</code></span>
<span class="codeline" id="line-1708"><code>	})</code></span>
<span class="codeline" id="line-1709"><code>}</code></span>
<span class="codeline" id="line-1710"><code></code></span>
<span class="codeline" id="line-1711"><code>func (parser *Parser) getAllGoFileInfoFromDeps(pkg *depth.Pkg, parseFlag ParseFlag) error {</code></span>
<span class="codeline" id="line-1712"><code>	ignoreInternal := pkg.Internal &amp;&amp; !parser.ParseInternal</code></span>
<span class="codeline" id="line-1713"><code>	if ignoreInternal || !pkg.Resolved { // ignored internal and not resolved dependencies</code></span>
<span class="codeline" id="line-1714"><code>		return nil</code></span>
<span class="codeline" id="line-1715"><code>	}</code></span>
<span class="codeline" id="line-1716"><code></code></span>
<span class="codeline" id="line-1717"><code>	if pkg.Raw != nil &amp;&amp; parser.skipPackageByPrefix(pkg.Raw.ImportPath) {</code></span>
<span class="codeline" id="line-1718"><code>		return nil // ignored by user-defined package path prefixes</code></span>
<span class="codeline" id="line-1719"><code>	}</code></span>
<span class="codeline" id="line-1720"><code></code></span>
<span class="codeline" id="line-1721"><code>	// Skip cgo</code></span>
<span class="codeline" id="line-1722"><code>	if pkg.Raw == nil &amp;&amp; pkg.Name == "C" {</code></span>
<span class="codeline" id="line-1723"><code>		return nil</code></span>
<span class="codeline" id="line-1724"><code>	}</code></span>
<span class="codeline" id="line-1725"><code></code></span>
<span class="codeline" id="line-1726"><code>	srcDir := pkg.Raw.Dir</code></span>
<span class="codeline" id="line-1727"><code></code></span>
<span class="codeline" id="line-1728"><code>	files, err := os.ReadDir(srcDir) // only parsing files in the dir(don't contain sub dir files)</code></span>
<span class="codeline" id="line-1729"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1730"><code>		return err</code></span>
<span class="codeline" id="line-1731"><code>	}</code></span>
<span class="codeline" id="line-1732"><code></code></span>
<span class="codeline" id="line-1733"><code>	for _, f := range files {</code></span>
<span class="codeline" id="line-1734"><code>		if f.IsDir() {</code></span>
<span class="codeline" id="line-1735"><code>			continue</code></span>
<span class="codeline" id="line-1736"><code>		}</code></span>
<span class="codeline" id="line-1737"><code></code></span>
<span class="codeline" id="line-1738"><code>		path := filepath.Join(srcDir, f.Name())</code></span>
<span class="codeline" id="line-1739"><code>		if err := parser.parseFile(pkg.Name, path, nil, parseFlag); err != nil {</code></span>
<span class="codeline" id="line-1740"><code>			return err</code></span>
<span class="codeline" id="line-1741"><code>		}</code></span>
<span class="codeline" id="line-1742"><code>	}</code></span>
<span class="codeline" id="line-1743"><code></code></span>
<span class="codeline" id="line-1744"><code>	for i := 0; i &lt; len(pkg.Deps); i++ {</code></span>
<span class="codeline" id="line-1745"><code>		if err := parser.getAllGoFileInfoFromDeps(&amp;pkg.Deps[i], parseFlag); err != nil {</code></span>
<span class="codeline" id="line-1746"><code>			return err</code></span>
<span class="codeline" id="line-1747"><code>		}</code></span>
<span class="codeline" id="line-1748"><code>	}</code></span>
<span class="codeline" id="line-1749"><code></code></span>
<span class="codeline" id="line-1750"><code>	return nil</code></span>
<span class="codeline" id="line-1751"><code>}</code></span>
<span class="codeline" id="line-1752"><code></code></span>
<span class="codeline" id="line-1753"><code>func (parser *Parser) parseFile(packageDir, path string, src interface{}, flag ParseFlag) error {</code></span>
<span class="codeline" id="line-1754"><code>	if strings.HasSuffix(strings.ToLower(path), "_test.go") || filepath.Ext(path) != ".go" {</code></span>
<span class="codeline" id="line-1755"><code>		return nil</code></span>
<span class="codeline" id="line-1756"><code>	}</code></span>
<span class="codeline" id="line-1757"><code></code></span>
<span class="codeline" id="line-1758"><code>	return parser.packages.ParseFile(packageDir, path, src, flag)</code></span>
<span class="codeline" id="line-1759"><code>}</code></span>
<span class="codeline" id="line-1760"><code></code></span>
<span class="codeline" id="line-1761"><code>func (parser *Parser) checkOperationIDUniqueness() error {</code></span>
<span class="codeline" id="line-1762"><code>	// operationsIds contains all operationId annotations to check it's unique</code></span>
<span class="codeline" id="line-1763"><code>	operationsIds := make(map[string]string)</code></span>
<span class="codeline" id="line-1764"><code></code></span>
<span class="codeline" id="line-1765"><code>	for path, item := range parser.swagger.Paths.Paths {</code></span>
<span class="codeline" id="line-1766"><code>		var method, id string</code></span>
<span class="codeline" id="line-1767"><code></code></span>
<span class="codeline" id="line-1768"><code>		for method = range allMethod {</code></span>
<span class="codeline" id="line-1769"><code>			op := refRouteMethodOp(&amp;item, method)</code></span>
<span class="codeline" id="line-1770"><code>			if *op != nil {</code></span>
<span class="codeline" id="line-1771"><code>				id = (**op).ID</code></span>
<span class="codeline" id="line-1772"><code></code></span>
<span class="codeline" id="line-1773"><code>				break</code></span>
<span class="codeline" id="line-1774"><code>			}</code></span>
<span class="codeline" id="line-1775"><code>		}</code></span>
<span class="codeline" id="line-1776"><code></code></span>
<span class="codeline" id="line-1777"><code>		if id == "" {</code></span>
<span class="codeline" id="line-1778"><code>			continue</code></span>
<span class="codeline" id="line-1779"><code>		}</code></span>
<span class="codeline" id="line-1780"><code></code></span>
<span class="codeline" id="line-1781"><code>		current := fmt.Sprintf("%s %s", method, path)</code></span>
<span class="codeline" id="line-1782"><code></code></span>
<span class="codeline" id="line-1783"><code>		previous, ok := operationsIds[id]</code></span>
<span class="codeline" id="line-1784"><code>		if ok {</code></span>
<span class="codeline" id="line-1785"><code>			return fmt.Errorf(</code></span>
<span class="codeline" id="line-1786"><code>				"duplicated @id annotation '%s' found in '%s', previously declared in: '%s'",</code></span>
<span class="codeline" id="line-1787"><code>				id, current, previous)</code></span>
<span class="codeline" id="line-1788"><code>		}</code></span>
<span class="codeline" id="line-1789"><code></code></span>
<span class="codeline" id="line-1790"><code>		operationsIds[id] = current</code></span>
<span class="codeline" id="line-1791"><code>	}</code></span>
<span class="codeline" id="line-1792"><code></code></span>
<span class="codeline" id="line-1793"><code>	return nil</code></span>
<span class="codeline" id="line-1794"><code>}</code></span>
<span class="codeline" id="line-1795"><code></code></span>
<span class="codeline" id="line-1796"><code>// Skip returns filepath.SkipDir error if match vendor and hidden folder.</code></span>
<span class="codeline" id="line-1797"><code>func (parser *Parser) Skip(path string, f os.FileInfo) error {</code></span>
<span class="codeline" id="line-1798"><code>	return walkWith(parser.excludes, parser.ParseVendor)(path, f)</code></span>
<span class="codeline" id="line-1799"><code>}</code></span>
<span class="codeline" id="line-1800"><code></code></span>
<span class="codeline" id="line-1801"><code>func walkWith(excludes map[string]struct{}, parseVendor bool) func(path string, fileInfo os.FileInfo) error {</code></span>
<span class="codeline" id="line-1802"><code>	return func(path string, f os.FileInfo) error {</code></span>
<span class="codeline" id="line-1803"><code>		if f.IsDir() {</code></span>
<span class="codeline" id="line-1804"><code>			if !parseVendor &amp;&amp; f.Name() == "vendor" || // ignore "vendor"</code></span>
<span class="codeline" id="line-1805"><code>				f.Name() == "docs" || // exclude docs</code></span>
<span class="codeline" id="line-1806"><code>				len(f.Name()) &gt; 1 &amp;&amp; f.Name()[0] == '.' &amp;&amp; f.Name() != ".." { // exclude all hidden folder</code></span>
<span class="codeline" id="line-1807"><code>				return filepath.SkipDir</code></span>
<span class="codeline" id="line-1808"><code>			}</code></span>
<span class="codeline" id="line-1809"><code></code></span>
<span class="codeline" id="line-1810"><code>			if excludes != nil {</code></span>
<span class="codeline" id="line-1811"><code>				if _, ok := excludes[path]; ok {</code></span>
<span class="codeline" id="line-1812"><code>					return filepath.SkipDir</code></span>
<span class="codeline" id="line-1813"><code>				}</code></span>
<span class="codeline" id="line-1814"><code>			}</code></span>
<span class="codeline" id="line-1815"><code>		}</code></span>
<span class="codeline" id="line-1816"><code></code></span>
<span class="codeline" id="line-1817"><code>		return nil</code></span>
<span class="codeline" id="line-1818"><code>	}</code></span>
<span class="codeline" id="line-1819"><code>}</code></span>
<span class="codeline" id="line-1820"><code></code></span>
<span class="codeline" id="line-1821"><code>// GetSwagger returns *spec.Swagger which is the root document object for the API specification.</code></span>
<span class="codeline" id="line-1822"><code>func (parser *Parser) GetSwagger() *spec.Swagger {</code></span>
<span class="codeline" id="line-1823"><code>	return parser.swagger</code></span>
<span class="codeline" id="line-1824"><code>}</code></span>
<span class="codeline" id="line-1825"><code></code></span>
<span class="codeline" id="line-1826"><code>// addTestType just for tests.</code></span>
<span class="codeline" id="line-1827"><code>func (parser *Parser) addTestType(typename string) {</code></span>
<span class="codeline" id="line-1828"><code>	typeDef := &amp;TypeSpecDef{}</code></span>
<span class="codeline" id="line-1829"><code>	parser.packages.uniqueDefinitions[typename] = typeDef</code></span>
<span class="codeline" id="line-1830"><code>	parser.parsedSchemas[typeDef] = &amp;Schema{</code></span>
<span class="codeline" id="line-1831"><code>		PkgPath: "",</code></span>
<span class="codeline" id="line-1832"><code>		Name:    typename,</code></span>
<span class="codeline" id="line-1833"><code>		Schema:  PrimitiveSchema(OBJECT),</code></span>
<span class="codeline" id="line-1834"><code>	}</code></span>
<span class="codeline" id="line-1835"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>