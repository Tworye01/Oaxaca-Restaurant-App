<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: migrator.go in package gorm.io/driver/postgres</title>
<link href="../../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	migrator.go

<span class="title">Belonging Package</span>
	<a href="../../../../pkg/gorm.io/driver/postgres.html">gorm.io/driver/postgres</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>package postgres</code></span>
<span class="codeline" id="line-2"><code></code></span>
<span class="codeline" id="line-3"><code>import (</code></span>
<span class="codeline" id="line-4"><code>	"database/sql"</code></span>
<span class="codeline" id="line-5"><code>	"fmt"</code></span>
<span class="codeline" id="line-6"><code>	"regexp"</code></span>
<span class="codeline" id="line-7"><code>	"strings"</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>	"github.com/jackc/pgx/v5"</code></span>
<span class="codeline" id="line-10"><code>	"gorm.io/gorm"</code></span>
<span class="codeline" id="line-11"><code>	"gorm.io/gorm/clause"</code></span>
<span class="codeline" id="line-12"><code>	"gorm.io/gorm/migrator"</code></span>
<span class="codeline" id="line-13"><code>	"gorm.io/gorm/schema"</code></span>
<span class="codeline" id="line-14"><code>)</code></span>
<span class="codeline" id="line-15"><code></code></span>
<span class="codeline" id="line-16"><code>// See https://stackoverflow.com/questions/2204058/list-columns-with-indexes-in-postgresql</code></span>
<span class="codeline" id="line-17"><code>// Here are some changes:</code></span>
<span class="codeline" id="line-18"><code>// - use `LEFT JOIN` instead of `CROSS JOIN`</code></span>
<span class="codeline" id="line-19"><code>// - exclude indexes used to support constraints (they are auto-generated)</code></span>
<span class="codeline" id="line-20"><code>const indexSql = `</code></span>
<span class="codeline" id="line-21"><code>SELECT</code></span>
<span class="codeline" id="line-22"><code>	ct.relname AS table_name,</code></span>
<span class="codeline" id="line-23"><code>	ci.relname AS index_name,</code></span>
<span class="codeline" id="line-24"><code>	i.indisunique AS non_unique,</code></span>
<span class="codeline" id="line-25"><code>	i.indisprimary AS primary,</code></span>
<span class="codeline" id="line-26"><code>	a.attname AS column_name</code></span>
<span class="codeline" id="line-27"><code>FROM</code></span>
<span class="codeline" id="line-28"><code>	pg_index i</code></span>
<span class="codeline" id="line-29"><code>	LEFT JOIN pg_class ct ON ct.oid = i.indrelid</code></span>
<span class="codeline" id="line-30"><code>	LEFT JOIN pg_class ci ON ci.oid = i.indexrelid</code></span>
<span class="codeline" id="line-31"><code>	LEFT JOIN pg_attribute a ON a.attrelid = ct.oid</code></span>
<span class="codeline" id="line-32"><code>	LEFT JOIN pg_constraint con ON con.conindid = i.indexrelid</code></span>
<span class="codeline" id="line-33"><code>WHERE</code></span>
<span class="codeline" id="line-34"><code>	a.attnum = ANY(i.indkey)</code></span>
<span class="codeline" id="line-35"><code>	AND con.oid IS NULL</code></span>
<span class="codeline" id="line-36"><code>	AND ct.relkind = 'r'</code></span>
<span class="codeline" id="line-37"><code>	AND ct.relname = ?</code></span>
<span class="codeline" id="line-38"><code>`</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>var typeAliasMap = map[string][]string{</code></span>
<span class="codeline" id="line-41"><code>	"int2":                     {"smallint"},</code></span>
<span class="codeline" id="line-42"><code>	"int4":                     {"integer"},</code></span>
<span class="codeline" id="line-43"><code>	"int8":                     {"bigint"},</code></span>
<span class="codeline" id="line-44"><code>	"smallint":                 {"int2"},</code></span>
<span class="codeline" id="line-45"><code>	"integer":                  {"int4"},</code></span>
<span class="codeline" id="line-46"><code>	"bigint":                   {"int8"},</code></span>
<span class="codeline" id="line-47"><code>	"decimal":                  {"numeric"},</code></span>
<span class="codeline" id="line-48"><code>	"numeric":                  {"decimal"},</code></span>
<span class="codeline" id="line-49"><code>	"timestamptz":              {"timestamp with time zone"},</code></span>
<span class="codeline" id="line-50"><code>	"timestamp with time zone": {"timestamptz"},</code></span>
<span class="codeline" id="line-51"><code>}</code></span>
<span class="codeline" id="line-52"><code></code></span>
<span class="codeline" id="line-53"><code>type Migrator struct {</code></span>
<span class="codeline" id="line-54"><code>	migrator.Migrator</code></span>
<span class="codeline" id="line-55"><code>}</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>func (m Migrator) CurrentDatabase() (name string) {</code></span>
<span class="codeline" id="line-58"><code>	m.DB.Raw("SELECT CURRENT_DATABASE()").Scan(&amp;name)</code></span>
<span class="codeline" id="line-59"><code>	return</code></span>
<span class="codeline" id="line-60"><code>}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>func (m Migrator) BuildIndexOptions(opts []schema.IndexOption, stmt *gorm.Statement) (results []interface{}) {</code></span>
<span class="codeline" id="line-63"><code>	for _, opt := range opts {</code></span>
<span class="codeline" id="line-64"><code>		str := stmt.Quote(opt.DBName)</code></span>
<span class="codeline" id="line-65"><code>		if opt.Expression != "" {</code></span>
<span class="codeline" id="line-66"><code>			str = opt.Expression</code></span>
<span class="codeline" id="line-67"><code>		}</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>		if opt.Collate != "" {</code></span>
<span class="codeline" id="line-70"><code>			str += " COLLATE " + opt.Collate</code></span>
<span class="codeline" id="line-71"><code>		}</code></span>
<span class="codeline" id="line-72"><code></code></span>
<span class="codeline" id="line-73"><code>		if opt.Sort != "" {</code></span>
<span class="codeline" id="line-74"><code>			str += " " + opt.Sort</code></span>
<span class="codeline" id="line-75"><code>		}</code></span>
<span class="codeline" id="line-76"><code>		results = append(results, clause.Expr{SQL: str})</code></span>
<span class="codeline" id="line-77"><code>	}</code></span>
<span class="codeline" id="line-78"><code>	return</code></span>
<span class="codeline" id="line-79"><code>}</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>func (m Migrator) HasIndex(value interface{}, name string) bool {</code></span>
<span class="codeline" id="line-82"><code>	var count int64</code></span>
<span class="codeline" id="line-83"><code>	m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-84"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-85"><code>			if idx := stmt.Schema.LookIndex(name); idx != nil {</code></span>
<span class="codeline" id="line-86"><code>				name = idx.Name</code></span>
<span class="codeline" id="line-87"><code>			}</code></span>
<span class="codeline" id="line-88"><code>		}</code></span>
<span class="codeline" id="line-89"><code>		currentSchema, curTable := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-90"><code>		return m.DB.Raw(</code></span>
<span class="codeline" id="line-91"><code>			"SELECT count(*) FROM pg_indexes WHERE tablename = ? AND indexname = ? AND schemaname = ?", curTable, name, currentSchema,</code></span>
<span class="codeline" id="line-92"><code>		).Scan(&amp;count).Error</code></span>
<span class="codeline" id="line-93"><code>	})</code></span>
<span class="codeline" id="line-94"><code></code></span>
<span class="codeline" id="line-95"><code>	return count &gt; 0</code></span>
<span class="codeline" id="line-96"><code>}</code></span>
<span class="codeline" id="line-97"><code></code></span>
<span class="codeline" id="line-98"><code>func (m Migrator) CreateIndex(value interface{}, name string) error {</code></span>
<span class="codeline" id="line-99"><code>	return m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-100"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-101"><code>			if idx := stmt.Schema.LookIndex(name); idx != nil {</code></span>
<span class="codeline" id="line-102"><code>				opts := m.BuildIndexOptions(idx.Fields, stmt)</code></span>
<span class="codeline" id="line-103"><code>				values := []interface{}{clause.Column{Name: idx.Name}, m.CurrentTable(stmt), opts}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>				createIndexSQL := "CREATE "</code></span>
<span class="codeline" id="line-106"><code>				if idx.Class != "" {</code></span>
<span class="codeline" id="line-107"><code>					createIndexSQL += idx.Class + " "</code></span>
<span class="codeline" id="line-108"><code>				}</code></span>
<span class="codeline" id="line-109"><code>				createIndexSQL += "INDEX "</code></span>
<span class="codeline" id="line-110"><code></code></span>
<span class="codeline" id="line-111"><code>				if strings.TrimSpace(strings.ToUpper(idx.Option)) == "CONCURRENTLY" {</code></span>
<span class="codeline" id="line-112"><code>					createIndexSQL += "CONCURRENTLY "</code></span>
<span class="codeline" id="line-113"><code>				}</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>				createIndexSQL += "IF NOT EXISTS ? ON ?"</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>				if idx.Type != "" {</code></span>
<span class="codeline" id="line-118"><code>					createIndexSQL += " USING " + idx.Type + "(?)"</code></span>
<span class="codeline" id="line-119"><code>				} else {</code></span>
<span class="codeline" id="line-120"><code>					createIndexSQL += " ?"</code></span>
<span class="codeline" id="line-121"><code>				}</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>				if idx.Where != "" {</code></span>
<span class="codeline" id="line-124"><code>					createIndexSQL += " WHERE " + idx.Where</code></span>
<span class="codeline" id="line-125"><code>				}</code></span>
<span class="codeline" id="line-126"><code></code></span>
<span class="codeline" id="line-127"><code>				return m.DB.Exec(createIndexSQL, values...).Error</code></span>
<span class="codeline" id="line-128"><code>			}</code></span>
<span class="codeline" id="line-129"><code>		}</code></span>
<span class="codeline" id="line-130"><code></code></span>
<span class="codeline" id="line-131"><code>		return fmt.Errorf("failed to create index with name %v", name)</code></span>
<span class="codeline" id="line-132"><code>	})</code></span>
<span class="codeline" id="line-133"><code>}</code></span>
<span class="codeline" id="line-134"><code></code></span>
<span class="codeline" id="line-135"><code>func (m Migrator) RenameIndex(value interface{}, oldName, newName string) error {</code></span>
<span class="codeline" id="line-136"><code>	return m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-137"><code>		return m.DB.Exec(</code></span>
<span class="codeline" id="line-138"><code>			"ALTER INDEX ? RENAME TO ?",</code></span>
<span class="codeline" id="line-139"><code>			clause.Column{Name: oldName}, clause.Column{Name: newName},</code></span>
<span class="codeline" id="line-140"><code>		).Error</code></span>
<span class="codeline" id="line-141"><code>	})</code></span>
<span class="codeline" id="line-142"><code>}</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>func (m Migrator) DropIndex(value interface{}, name string) error {</code></span>
<span class="codeline" id="line-145"><code>	return m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-146"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-147"><code>			if idx := stmt.Schema.LookIndex(name); idx != nil {</code></span>
<span class="codeline" id="line-148"><code>				name = idx.Name</code></span>
<span class="codeline" id="line-149"><code>			}</code></span>
<span class="codeline" id="line-150"><code>		}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>		return m.DB.Exec("DROP INDEX ?", clause.Column{Name: name}).Error</code></span>
<span class="codeline" id="line-153"><code>	})</code></span>
<span class="codeline" id="line-154"><code>}</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>func (m Migrator) GetTables() (tableList []string, err error) {</code></span>
<span class="codeline" id="line-157"><code>	currentSchema, _ := m.CurrentSchema(m.DB.Statement, "")</code></span>
<span class="codeline" id="line-158"><code>	return tableList, m.DB.Raw("SELECT table_name FROM information_schema.tables WHERE table_schema = ? AND table_type = ?", currentSchema, "BASE TABLE").Scan(&amp;tableList).Error</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>func (m Migrator) CreateTable(values ...interface{}) (err error) {</code></span>
<span class="codeline" id="line-162"><code>	if err = m.Migrator.CreateTable(values...); err != nil {</code></span>
<span class="codeline" id="line-163"><code>		return</code></span>
<span class="codeline" id="line-164"><code>	}</code></span>
<span class="codeline" id="line-165"><code>	for _, value := range m.ReorderModels(values, false) {</code></span>
<span class="codeline" id="line-166"><code>		if err = m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-167"><code>			if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-168"><code>				for _, fieldName := range stmt.Schema.DBNames {</code></span>
<span class="codeline" id="line-169"><code>					field := stmt.Schema.FieldsByDBName[fieldName]</code></span>
<span class="codeline" id="line-170"><code>					if field.Comment != "" {</code></span>
<span class="codeline" id="line-171"><code>						if err := m.DB.Exec(</code></span>
<span class="codeline" id="line-172"><code>							"COMMENT ON COLUMN ?.? IS ?",</code></span>
<span class="codeline" id="line-173"><code>							m.CurrentTable(stmt), clause.Column{Name: field.DBName}, gorm.Expr(m.Migrator.Dialector.Explain("$1", field.Comment)),</code></span>
<span class="codeline" id="line-174"><code>						).Error; err != nil {</code></span>
<span class="codeline" id="line-175"><code>							return err</code></span>
<span class="codeline" id="line-176"><code>						}</code></span>
<span class="codeline" id="line-177"><code>					}</code></span>
<span class="codeline" id="line-178"><code>				}</code></span>
<span class="codeline" id="line-179"><code>			}</code></span>
<span class="codeline" id="line-180"><code>			return nil</code></span>
<span class="codeline" id="line-181"><code>		}); err != nil {</code></span>
<span class="codeline" id="line-182"><code>			return</code></span>
<span class="codeline" id="line-183"><code>		}</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>	return</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>func (m Migrator) HasTable(value interface{}) bool {</code></span>
<span class="codeline" id="line-189"><code>	var count int64</code></span>
<span class="codeline" id="line-190"><code>	m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-191"><code>		currentSchema, curTable := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-192"><code>		return m.DB.Raw("SELECT count(*) FROM information_schema.tables WHERE table_schema = ? AND table_name = ? AND table_type = ?", currentSchema, curTable, "BASE TABLE").Scan(&amp;count).Error</code></span>
<span class="codeline" id="line-193"><code>	})</code></span>
<span class="codeline" id="line-194"><code>	return count &gt; 0</code></span>
<span class="codeline" id="line-195"><code>}</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>func (m Migrator) DropTable(values ...interface{}) error {</code></span>
<span class="codeline" id="line-198"><code>	values = m.ReorderModels(values, false)</code></span>
<span class="codeline" id="line-199"><code>	tx := m.DB.Session(&amp;gorm.Session{})</code></span>
<span class="codeline" id="line-200"><code>	for i := len(values) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-201"><code>		if err := m.RunWithValue(values[i], func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-202"><code>			return tx.Exec("DROP TABLE IF EXISTS ? CASCADE", m.CurrentTable(stmt)).Error</code></span>
<span class="codeline" id="line-203"><code>		}); err != nil {</code></span>
<span class="codeline" id="line-204"><code>			return err</code></span>
<span class="codeline" id="line-205"><code>		}</code></span>
<span class="codeline" id="line-206"><code>	}</code></span>
<span class="codeline" id="line-207"><code>	return nil</code></span>
<span class="codeline" id="line-208"><code>}</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>func (m Migrator) AddColumn(value interface{}, field string) error {</code></span>
<span class="codeline" id="line-211"><code>	if err := m.Migrator.AddColumn(value, field); err != nil {</code></span>
<span class="codeline" id="line-212"><code>		return err</code></span>
<span class="codeline" id="line-213"><code>	}</code></span>
<span class="codeline" id="line-214"><code>	m.resetPreparedStmts()</code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>	return m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-217"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-218"><code>			if field := stmt.Schema.LookUpField(field); field != nil {</code></span>
<span class="codeline" id="line-219"><code>				if field.Comment != "" {</code></span>
<span class="codeline" id="line-220"><code>					if err := m.DB.Exec(</code></span>
<span class="codeline" id="line-221"><code>						"COMMENT ON COLUMN ?.? IS ?",</code></span>
<span class="codeline" id="line-222"><code>						m.CurrentTable(stmt), clause.Column{Name: field.DBName}, gorm.Expr(m.Migrator.Dialector.Explain("$1", field.Comment)),</code></span>
<span class="codeline" id="line-223"><code>					).Error; err != nil {</code></span>
<span class="codeline" id="line-224"><code>						return err</code></span>
<span class="codeline" id="line-225"><code>					}</code></span>
<span class="codeline" id="line-226"><code>				}</code></span>
<span class="codeline" id="line-227"><code>			}</code></span>
<span class="codeline" id="line-228"><code>		}</code></span>
<span class="codeline" id="line-229"><code>		return nil</code></span>
<span class="codeline" id="line-230"><code>	})</code></span>
<span class="codeline" id="line-231"><code>}</code></span>
<span class="codeline" id="line-232"><code></code></span>
<span class="codeline" id="line-233"><code>func (m Migrator) HasColumn(value interface{}, field string) bool {</code></span>
<span class="codeline" id="line-234"><code>	var count int64</code></span>
<span class="codeline" id="line-235"><code>	m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-236"><code>		name := field</code></span>
<span class="codeline" id="line-237"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-238"><code>			if field := stmt.Schema.LookUpField(field); field != nil {</code></span>
<span class="codeline" id="line-239"><code>				name = field.DBName</code></span>
<span class="codeline" id="line-240"><code>			}</code></span>
<span class="codeline" id="line-241"><code>		}</code></span>
<span class="codeline" id="line-242"><code></code></span>
<span class="codeline" id="line-243"><code>		currentSchema, curTable := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-244"><code>		return m.DB.Raw(</code></span>
<span class="codeline" id="line-245"><code>			"SELECT count(*) FROM INFORMATION_SCHEMA.columns WHERE table_schema = ? AND table_name = ? AND column_name = ?",</code></span>
<span class="codeline" id="line-246"><code>			currentSchema, curTable, name,</code></span>
<span class="codeline" id="line-247"><code>		).Scan(&amp;count).Error</code></span>
<span class="codeline" id="line-248"><code>	})</code></span>
<span class="codeline" id="line-249"><code></code></span>
<span class="codeline" id="line-250"><code>	return count &gt; 0</code></span>
<span class="codeline" id="line-251"><code>}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>func (m Migrator) MigrateColumn(value interface{}, field *schema.Field, columnType gorm.ColumnType) error {</code></span>
<span class="codeline" id="line-254"><code>	// skip primary field</code></span>
<span class="codeline" id="line-255"><code>	if !field.PrimaryKey {</code></span>
<span class="codeline" id="line-256"><code>		if err := m.Migrator.MigrateColumn(value, field, columnType); err != nil {</code></span>
<span class="codeline" id="line-257"><code>			return err</code></span>
<span class="codeline" id="line-258"><code>		}</code></span>
<span class="codeline" id="line-259"><code>	}</code></span>
<span class="codeline" id="line-260"><code></code></span>
<span class="codeline" id="line-261"><code>	return m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-262"><code>		var description string</code></span>
<span class="codeline" id="line-263"><code>		currentSchema, curTable := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-264"><code>		values := []interface{}{currentSchema, curTable, field.DBName, stmt.Table, currentSchema}</code></span>
<span class="codeline" id="line-265"><code>		checkSQL := "SELECT description FROM pg_catalog.pg_description "</code></span>
<span class="codeline" id="line-266"><code>		checkSQL += "WHERE objsubid = (SELECT ordinal_position FROM information_schema.columns WHERE table_schema = ? AND table_name = ? AND column_name = ?) "</code></span>
<span class="codeline" id="line-267"><code>		checkSQL += "AND objoid = (SELECT oid FROM pg_catalog.pg_class WHERE relname = ? AND relnamespace = "</code></span>
<span class="codeline" id="line-268"><code>		checkSQL += "(SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = ?))"</code></span>
<span class="codeline" id="line-269"><code>		m.DB.Raw(checkSQL, values...).Scan(&amp;description)</code></span>
<span class="codeline" id="line-270"><code></code></span>
<span class="codeline" id="line-271"><code>		comment := strings.Trim(field.Comment, "'")</code></span>
<span class="codeline" id="line-272"><code>		comment = strings.Trim(comment, `"`)</code></span>
<span class="codeline" id="line-273"><code>		if field.Comment != "" &amp;&amp; comment != description {</code></span>
<span class="codeline" id="line-274"><code>			if err := m.DB.Exec(</code></span>
<span class="codeline" id="line-275"><code>				"COMMENT ON COLUMN ?.? IS ?",</code></span>
<span class="codeline" id="line-276"><code>				m.CurrentTable(stmt), clause.Column{Name: field.DBName}, gorm.Expr(m.Migrator.Dialector.Explain("$1", field.Comment)),</code></span>
<span class="codeline" id="line-277"><code>			).Error; err != nil {</code></span>
<span class="codeline" id="line-278"><code>				return err</code></span>
<span class="codeline" id="line-279"><code>			}</code></span>
<span class="codeline" id="line-280"><code>		}</code></span>
<span class="codeline" id="line-281"><code>		return nil</code></span>
<span class="codeline" id="line-282"><code>	})</code></span>
<span class="codeline" id="line-283"><code>}</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>// AlterColumn alter value's `field` column' type based on schema definition</code></span>
<span class="codeline" id="line-286"><code>func (m Migrator) AlterColumn(value interface{}, field string) error {</code></span>
<span class="codeline" id="line-287"><code>	err := m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-288"><code>		if stmt.Schema != nil {</code></span>
<span class="codeline" id="line-289"><code>			if field := stmt.Schema.LookUpField(field); field != nil {</code></span>
<span class="codeline" id="line-290"><code>				var (</code></span>
<span class="codeline" id="line-291"><code>					columnTypes, _  = m.DB.Migrator().ColumnTypes(value)</code></span>
<span class="codeline" id="line-292"><code>					fieldColumnType *migrator.ColumnType</code></span>
<span class="codeline" id="line-293"><code>				)</code></span>
<span class="codeline" id="line-294"><code>				for _, columnType := range columnTypes {</code></span>
<span class="codeline" id="line-295"><code>					if columnType.Name() == field.DBName {</code></span>
<span class="codeline" id="line-296"><code>						fieldColumnType, _ = columnType.(*migrator.ColumnType)</code></span>
<span class="codeline" id="line-297"><code>					}</code></span>
<span class="codeline" id="line-298"><code>				}</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>				fileType := clause.Expr{SQL: m.DataTypeOf(field)}</code></span>
<span class="codeline" id="line-301"><code>				// check for typeName and SQL name</code></span>
<span class="codeline" id="line-302"><code>				isSameType := true</code></span>
<span class="codeline" id="line-303"><code>				if fieldColumnType.DatabaseTypeName() != fileType.SQL {</code></span>
<span class="codeline" id="line-304"><code>					isSameType = false</code></span>
<span class="codeline" id="line-305"><code>					// if different, also check for aliases</code></span>
<span class="codeline" id="line-306"><code>					aliases := m.GetTypeAliases(fieldColumnType.DatabaseTypeName())</code></span>
<span class="codeline" id="line-307"><code>					for _, alias := range aliases {</code></span>
<span class="codeline" id="line-308"><code>						if strings.HasPrefix(fileType.SQL, alias) {</code></span>
<span class="codeline" id="line-309"><code>							isSameType = true</code></span>
<span class="codeline" id="line-310"><code>							break</code></span>
<span class="codeline" id="line-311"><code>						}</code></span>
<span class="codeline" id="line-312"><code>					}</code></span>
<span class="codeline" id="line-313"><code>				}</code></span>
<span class="codeline" id="line-314"><code></code></span>
<span class="codeline" id="line-315"><code>				// not same, migrate</code></span>
<span class="codeline" id="line-316"><code>				if !isSameType {</code></span>
<span class="codeline" id="line-317"><code>					filedColumnAutoIncrement, _ := fieldColumnType.AutoIncrement()</code></span>
<span class="codeline" id="line-318"><code>					if field.AutoIncrement &amp;&amp; filedColumnAutoIncrement { // update</code></span>
<span class="codeline" id="line-319"><code>						serialDatabaseType, _ := getSerialDatabaseType(fileType.SQL)</code></span>
<span class="codeline" id="line-320"><code>						if t, _ := fieldColumnType.ColumnType(); t != serialDatabaseType {</code></span>
<span class="codeline" id="line-321"><code>							if err := m.UpdateSequence(m.DB, stmt, field, serialDatabaseType); err != nil {</code></span>
<span class="codeline" id="line-322"><code>								return err</code></span>
<span class="codeline" id="line-323"><code>							}</code></span>
<span class="codeline" id="line-324"><code>						}</code></span>
<span class="codeline" id="line-325"><code>					} else if field.AutoIncrement &amp;&amp; !filedColumnAutoIncrement { // create</code></span>
<span class="codeline" id="line-326"><code>						serialDatabaseType, _ := getSerialDatabaseType(fileType.SQL)</code></span>
<span class="codeline" id="line-327"><code>						if err := m.CreateSequence(m.DB, stmt, field, serialDatabaseType); err != nil {</code></span>
<span class="codeline" id="line-328"><code>							return err</code></span>
<span class="codeline" id="line-329"><code>						}</code></span>
<span class="codeline" id="line-330"><code>					} else if !field.AutoIncrement &amp;&amp; filedColumnAutoIncrement { // delete</code></span>
<span class="codeline" id="line-331"><code>						if err := m.DeleteSequence(m.DB, stmt, field, fileType); err != nil {</code></span>
<span class="codeline" id="line-332"><code>							return err</code></span>
<span class="codeline" id="line-333"><code>						}</code></span>
<span class="codeline" id="line-334"><code>					} else {</code></span>
<span class="codeline" id="line-335"><code>						if err := m.modifyColumn(stmt, field, fileType, fieldColumnType); err != nil {</code></span>
<span class="codeline" id="line-336"><code>							return err</code></span>
<span class="codeline" id="line-337"><code>						}</code></span>
<span class="codeline" id="line-338"><code>					}</code></span>
<span class="codeline" id="line-339"><code>				}</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>				if null, _ := fieldColumnType.Nullable(); null == field.NotNull {</code></span>
<span class="codeline" id="line-342"><code>					if field.NotNull {</code></span>
<span class="codeline" id="line-343"><code>						if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? SET NOT NULL", m.CurrentTable(stmt), clause.Column{Name: field.DBName}).Error; err != nil {</code></span>
<span class="codeline" id="line-344"><code>							return err</code></span>
<span class="codeline" id="line-345"><code>						}</code></span>
<span class="codeline" id="line-346"><code>					} else {</code></span>
<span class="codeline" id="line-347"><code>						if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? DROP NOT NULL", m.CurrentTable(stmt), clause.Column{Name: field.DBName}).Error; err != nil {</code></span>
<span class="codeline" id="line-348"><code>							return err</code></span>
<span class="codeline" id="line-349"><code>						}</code></span>
<span class="codeline" id="line-350"><code>					}</code></span>
<span class="codeline" id="line-351"><code>				}</code></span>
<span class="codeline" id="line-352"><code></code></span>
<span class="codeline" id="line-353"><code>				if v, ok := fieldColumnType.DefaultValue(); (field.DefaultValueInterface == nil &amp;&amp; ok) || v != field.DefaultValue {</code></span>
<span class="codeline" id="line-354"><code>					if field.HasDefaultValue &amp;&amp; (field.DefaultValueInterface != nil || field.DefaultValue != "") {</code></span>
<span class="codeline" id="line-355"><code>						if field.DefaultValueInterface != nil {</code></span>
<span class="codeline" id="line-356"><code>							defaultStmt := &amp;gorm.Statement{Vars: []interface{}{field.DefaultValueInterface}}</code></span>
<span class="codeline" id="line-357"><code>							m.Dialector.BindVarTo(defaultStmt, defaultStmt, field.DefaultValueInterface)</code></span>
<span class="codeline" id="line-358"><code>							if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? SET DEFAULT ?", m.CurrentTable(stmt), clause.Column{Name: field.DBName}, clause.Expr{SQL: m.Dialector.Explain(defaultStmt.SQL.String(), field.DefaultValueInterface)}).Error; err != nil {</code></span>
<span class="codeline" id="line-359"><code>								return err</code></span>
<span class="codeline" id="line-360"><code>							}</code></span>
<span class="codeline" id="line-361"><code>						} else if field.DefaultValue != "(-)" {</code></span>
<span class="codeline" id="line-362"><code>							if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? SET DEFAULT ?", m.CurrentTable(stmt), clause.Column{Name: field.DBName}, clause.Expr{SQL: field.DefaultValue}).Error; err != nil {</code></span>
<span class="codeline" id="line-363"><code>								return err</code></span>
<span class="codeline" id="line-364"><code>							}</code></span>
<span class="codeline" id="line-365"><code>						} else {</code></span>
<span class="codeline" id="line-366"><code>							if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? DROP DEFAULT", m.CurrentTable(stmt), clause.Column{Name: field.DBName}, clause.Expr{SQL: field.DefaultValue}).Error; err != nil {</code></span>
<span class="codeline" id="line-367"><code>								return err</code></span>
<span class="codeline" id="line-368"><code>							}</code></span>
<span class="codeline" id="line-369"><code>						}</code></span>
<span class="codeline" id="line-370"><code>					}</code></span>
<span class="codeline" id="line-371"><code>				}</code></span>
<span class="codeline" id="line-372"><code>				return nil</code></span>
<span class="codeline" id="line-373"><code>			}</code></span>
<span class="codeline" id="line-374"><code>		}</code></span>
<span class="codeline" id="line-375"><code>		return fmt.Errorf("failed to look up field with name: %s", field)</code></span>
<span class="codeline" id="line-376"><code>	})</code></span>
<span class="codeline" id="line-377"><code></code></span>
<span class="codeline" id="line-378"><code>	if err != nil {</code></span>
<span class="codeline" id="line-379"><code>		return err</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	m.resetPreparedStmts()</code></span>
<span class="codeline" id="line-382"><code>	return nil</code></span>
<span class="codeline" id="line-383"><code>}</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>func (m Migrator) modifyColumn(stmt *gorm.Statement, field *schema.Field, targetType clause.Expr, existingColumn *migrator.ColumnType) error {</code></span>
<span class="codeline" id="line-386"><code>	alterSQL := "ALTER TABLE ? ALTER COLUMN ? TYPE ? USING ?::?"</code></span>
<span class="codeline" id="line-387"><code>	isUncastableDefaultValue := false</code></span>
<span class="codeline" id="line-388"><code></code></span>
<span class="codeline" id="line-389"><code>	if targetType.SQL == "boolean" {</code></span>
<span class="codeline" id="line-390"><code>		switch existingColumn.DatabaseTypeName() {</code></span>
<span class="codeline" id="line-391"><code>		case "int2", "int8", "numeric":</code></span>
<span class="codeline" id="line-392"><code>			alterSQL = "ALTER TABLE ? ALTER COLUMN ? TYPE ? USING ?::int::?"</code></span>
<span class="codeline" id="line-393"><code>		}</code></span>
<span class="codeline" id="line-394"><code>		isUncastableDefaultValue = true</code></span>
<span class="codeline" id="line-395"><code>	}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>	if dv, _ := existingColumn.DefaultValue(); dv != "" &amp;&amp; isUncastableDefaultValue {</code></span>
<span class="codeline" id="line-398"><code>		if err := m.DB.Exec("ALTER TABLE ? ALTER COLUMN ? DROP DEFAULT", m.CurrentTable(stmt), clause.Column{Name: field.DBName}).Error; err != nil {</code></span>
<span class="codeline" id="line-399"><code>			return err</code></span>
<span class="codeline" id="line-400"><code>		}</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code>	if err := m.DB.Exec(alterSQL, m.CurrentTable(stmt), clause.Column{Name: field.DBName}, targetType, clause.Column{Name: field.DBName}, targetType).Error; err != nil {</code></span>
<span class="codeline" id="line-403"><code>		return err</code></span>
<span class="codeline" id="line-404"><code>	}</code></span>
<span class="codeline" id="line-405"><code>	return nil</code></span>
<span class="codeline" id="line-406"><code>}</code></span>
<span class="codeline" id="line-407"><code></code></span>
<span class="codeline" id="line-408"><code>func (m Migrator) HasConstraint(value interface{}, name string) bool {</code></span>
<span class="codeline" id="line-409"><code>	var count int64</code></span>
<span class="codeline" id="line-410"><code>	m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-411"><code>		constraint, table := m.GuessConstraintInterfaceAndTable(stmt, name)</code></span>
<span class="codeline" id="line-412"><code>		if constraint != nil {</code></span>
<span class="codeline" id="line-413"><code>			name = constraint.GetName()</code></span>
<span class="codeline" id="line-414"><code>		}</code></span>
<span class="codeline" id="line-415"><code>		currentSchema, curTable := m.CurrentSchema(stmt, table)</code></span>
<span class="codeline" id="line-416"><code></code></span>
<span class="codeline" id="line-417"><code>		return m.DB.Raw(</code></span>
<span class="codeline" id="line-418"><code>			"SELECT count(*) FROM INFORMATION_SCHEMA.table_constraints WHERE table_schema = ? AND table_name = ? AND constraint_name = ?",</code></span>
<span class="codeline" id="line-419"><code>			currentSchema, curTable, name,</code></span>
<span class="codeline" id="line-420"><code>		).Scan(&amp;count).Error</code></span>
<span class="codeline" id="line-421"><code>	})</code></span>
<span class="codeline" id="line-422"><code></code></span>
<span class="codeline" id="line-423"><code>	return count &gt; 0</code></span>
<span class="codeline" id="line-424"><code>}</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>func (m Migrator) ColumnTypes(value interface{}) (columnTypes []gorm.ColumnType, err error) {</code></span>
<span class="codeline" id="line-427"><code>	columnTypes = make([]gorm.ColumnType, 0)</code></span>
<span class="codeline" id="line-428"><code>	err = m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-429"><code>		var (</code></span>
<span class="codeline" id="line-430"><code>			currentDatabase      = m.DB.Migrator().CurrentDatabase()</code></span>
<span class="codeline" id="line-431"><code>			currentSchema, table = m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-432"><code>			columns, err         = m.DB.Raw(</code></span>
<span class="codeline" id="line-433"><code>				"SELECT c.column_name, c.is_nullable = 'YES', c.udt_name, c.character_maximum_length, c.numeric_precision, c.numeric_precision_radix, c.numeric_scale, c.datetime_precision, 8 * typlen, c.column_default, pd.description, c.identity_increment FROM information_schema.columns AS c JOIN pg_type AS pgt ON c.udt_name = pgt.typname LEFT JOIN pg_catalog.pg_description as pd ON pd.objsubid = c.ordinal_position AND pd.objoid = (SELECT oid FROM pg_catalog.pg_class WHERE relname = c.table_name AND relnamespace = (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = c.table_schema)) where table_catalog = ? AND table_schema = ? AND table_name = ?",</code></span>
<span class="codeline" id="line-434"><code>				currentDatabase, currentSchema, table).Rows()</code></span>
<span class="codeline" id="line-435"><code>		)</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>		if err != nil {</code></span>
<span class="codeline" id="line-438"><code>			return err</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code></code></span>
<span class="codeline" id="line-441"><code>		for columns.Next() {</code></span>
<span class="codeline" id="line-442"><code>			var (</code></span>
<span class="codeline" id="line-443"><code>				column = &amp;migrator.ColumnType{</code></span>
<span class="codeline" id="line-444"><code>					PrimaryKeyValue: sql.NullBool{Valid: true},</code></span>
<span class="codeline" id="line-445"><code>					UniqueValue:     sql.NullBool{Valid: true},</code></span>
<span class="codeline" id="line-446"><code>				}</code></span>
<span class="codeline" id="line-447"><code>				datetimePrecision sql.NullInt64</code></span>
<span class="codeline" id="line-448"><code>				radixValue        sql.NullInt64</code></span>
<span class="codeline" id="line-449"><code>				typeLenValue      sql.NullInt64</code></span>
<span class="codeline" id="line-450"><code>				identityIncrement sql.NullString</code></span>
<span class="codeline" id="line-451"><code>			)</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>			err = columns.Scan(</code></span>
<span class="codeline" id="line-454"><code>				&amp;column.NameValue, &amp;column.NullableValue, &amp;column.DataTypeValue, &amp;column.LengthValue, &amp;column.DecimalSizeValue,</code></span>
<span class="codeline" id="line-455"><code>				&amp;radixValue, &amp;column.ScaleValue, &amp;datetimePrecision, &amp;typeLenValue, &amp;column.DefaultValueValue, &amp;column.CommentValue, &amp;identityIncrement,</code></span>
<span class="codeline" id="line-456"><code>			)</code></span>
<span class="codeline" id="line-457"><code>			if err != nil {</code></span>
<span class="codeline" id="line-458"><code>				return err</code></span>
<span class="codeline" id="line-459"><code>			}</code></span>
<span class="codeline" id="line-460"><code></code></span>
<span class="codeline" id="line-461"><code>			if typeLenValue.Valid &amp;&amp; typeLenValue.Int64 &gt; 0 {</code></span>
<span class="codeline" id="line-462"><code>				column.LengthValue = typeLenValue</code></span>
<span class="codeline" id="line-463"><code>			}</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>			if (strings.HasPrefix(column.DefaultValueValue.String, "nextval('") &amp;&amp;</code></span>
<span class="codeline" id="line-466"><code>				strings.HasSuffix(column.DefaultValueValue.String, "seq'::regclass)")) || (identityIncrement.Valid &amp;&amp; identityIncrement.String != "") {</code></span>
<span class="codeline" id="line-467"><code>				column.AutoIncrementValue = sql.NullBool{Bool: true, Valid: true}</code></span>
<span class="codeline" id="line-468"><code>				column.DefaultValueValue = sql.NullString{}</code></span>
<span class="codeline" id="line-469"><code>			}</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>			if column.DefaultValueValue.Valid {</code></span>
<span class="codeline" id="line-472"><code>				column.DefaultValueValue.String = parseDefaultValueValue(column.DefaultValueValue.String)</code></span>
<span class="codeline" id="line-473"><code>			}</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>			if datetimePrecision.Valid {</code></span>
<span class="codeline" id="line-476"><code>				column.DecimalSizeValue = datetimePrecision</code></span>
<span class="codeline" id="line-477"><code>			}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>			columnTypes = append(columnTypes, column)</code></span>
<span class="codeline" id="line-480"><code>		}</code></span>
<span class="codeline" id="line-481"><code>		columns.Close()</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>		// assign sql column type</code></span>
<span class="codeline" id="line-484"><code>		{</code></span>
<span class="codeline" id="line-485"><code>			rows, rowsErr := m.GetRows(currentSchema, table)</code></span>
<span class="codeline" id="line-486"><code>			if rowsErr != nil {</code></span>
<span class="codeline" id="line-487"><code>				return rowsErr</code></span>
<span class="codeline" id="line-488"><code>			}</code></span>
<span class="codeline" id="line-489"><code>			rawColumnTypes, err := rows.ColumnTypes()</code></span>
<span class="codeline" id="line-490"><code>			if err != nil {</code></span>
<span class="codeline" id="line-491"><code>				return err</code></span>
<span class="codeline" id="line-492"><code>			}</code></span>
<span class="codeline" id="line-493"><code>			for _, columnType := range columnTypes {</code></span>
<span class="codeline" id="line-494"><code>				for _, c := range rawColumnTypes {</code></span>
<span class="codeline" id="line-495"><code>					if c.Name() == columnType.Name() {</code></span>
<span class="codeline" id="line-496"><code>						columnType.(*migrator.ColumnType).SQLColumnType = c</code></span>
<span class="codeline" id="line-497"><code>						break</code></span>
<span class="codeline" id="line-498"><code>					}</code></span>
<span class="codeline" id="line-499"><code>				}</code></span>
<span class="codeline" id="line-500"><code>			}</code></span>
<span class="codeline" id="line-501"><code>			rows.Close()</code></span>
<span class="codeline" id="line-502"><code>		}</code></span>
<span class="codeline" id="line-503"><code></code></span>
<span class="codeline" id="line-504"><code>		// check primary, unique field</code></span>
<span class="codeline" id="line-505"><code>		{</code></span>
<span class="codeline" id="line-506"><code>			columnTypeRows, err := m.DB.Raw("SELECT constraint_name FROM information_schema.table_constraints tc JOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_catalog, table_name, constraint_name) JOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema AND tc.table_name = c.table_name AND ccu.column_name = c.column_name WHERE constraint_type IN ('PRIMARY KEY', 'UNIQUE') AND c.table_catalog = ? AND c.table_schema = ? AND c.table_name = ? AND constraint_type = ?", currentDatabase, currentSchema, table, "UNIQUE").Rows()</code></span>
<span class="codeline" id="line-507"><code>			if err != nil {</code></span>
<span class="codeline" id="line-508"><code>				return err</code></span>
<span class="codeline" id="line-509"><code>			}</code></span>
<span class="codeline" id="line-510"><code>			uniqueContraints := map[string]int{}</code></span>
<span class="codeline" id="line-511"><code>			for columnTypeRows.Next() {</code></span>
<span class="codeline" id="line-512"><code>				var constraintName string</code></span>
<span class="codeline" id="line-513"><code>				columnTypeRows.Scan(&amp;constraintName)</code></span>
<span class="codeline" id="line-514"><code>				uniqueContraints[constraintName]++</code></span>
<span class="codeline" id="line-515"><code>			}</code></span>
<span class="codeline" id="line-516"><code>			columnTypeRows.Close()</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>			columnTypeRows, err = m.DB.Raw("SELECT c.column_name, constraint_name, constraint_type FROM information_schema.table_constraints tc JOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_catalog, table_name, constraint_name) JOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema AND tc.table_name = c.table_name AND ccu.column_name = c.column_name WHERE constraint_type IN ('PRIMARY KEY', 'UNIQUE') AND c.table_catalog = ? AND c.table_schema = ? AND c.table_name = ?", currentDatabase, currentSchema, table).Rows()</code></span>
<span class="codeline" id="line-519"><code>			if err != nil {</code></span>
<span class="codeline" id="line-520"><code>				return err</code></span>
<span class="codeline" id="line-521"><code>			}</code></span>
<span class="codeline" id="line-522"><code>			for columnTypeRows.Next() {</code></span>
<span class="codeline" id="line-523"><code>				var name, constraintName, columnType string</code></span>
<span class="codeline" id="line-524"><code>				columnTypeRows.Scan(&amp;name, &amp;constraintName, &amp;columnType)</code></span>
<span class="codeline" id="line-525"><code>				for _, c := range columnTypes {</code></span>
<span class="codeline" id="line-526"><code>					mc := c.(*migrator.ColumnType)</code></span>
<span class="codeline" id="line-527"><code>					if mc.NameValue.String == name {</code></span>
<span class="codeline" id="line-528"><code>						switch columnType {</code></span>
<span class="codeline" id="line-529"><code>						case "PRIMARY KEY":</code></span>
<span class="codeline" id="line-530"><code>							mc.PrimaryKeyValue = sql.NullBool{Bool: true, Valid: true}</code></span>
<span class="codeline" id="line-531"><code>						case "UNIQUE":</code></span>
<span class="codeline" id="line-532"><code>							if uniqueContraints[constraintName] == 1 {</code></span>
<span class="codeline" id="line-533"><code>								mc.UniqueValue = sql.NullBool{Bool: true, Valid: true}</code></span>
<span class="codeline" id="line-534"><code>							}</code></span>
<span class="codeline" id="line-535"><code>						}</code></span>
<span class="codeline" id="line-536"><code>						break</code></span>
<span class="codeline" id="line-537"><code>					}</code></span>
<span class="codeline" id="line-538"><code>				}</code></span>
<span class="codeline" id="line-539"><code>			}</code></span>
<span class="codeline" id="line-540"><code>			columnTypeRows.Close()</code></span>
<span class="codeline" id="line-541"><code>		}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>		// check column type</code></span>
<span class="codeline" id="line-544"><code>		{</code></span>
<span class="codeline" id="line-545"><code>			dataTypeRows, err := m.DB.Raw(`SELECT a.attname as column_name, format_type(a.atttypid, a.atttypmod) AS data_type</code></span>
<span class="codeline" id="line-546"><code>		FROM pg_attribute a JOIN pg_class b ON a.attrelid = b.oid AND relnamespace = (SELECT oid FROM pg_catalog.pg_namespace WHERE nspname = ?)</code></span>
<span class="codeline" id="line-547"><code>		WHERE a.attnum &gt; 0 -- hide internal columns</code></span>
<span class="codeline" id="line-548"><code>		AND NOT a.attisdropped -- hide deleted columns</code></span>
<span class="codeline" id="line-549"><code>		AND b.relname = ?`, currentSchema, table).Rows()</code></span>
<span class="codeline" id="line-550"><code>			if err != nil {</code></span>
<span class="codeline" id="line-551"><code>				return err</code></span>
<span class="codeline" id="line-552"><code>			}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>			for dataTypeRows.Next() {</code></span>
<span class="codeline" id="line-555"><code>				var name, dataType string</code></span>
<span class="codeline" id="line-556"><code>				dataTypeRows.Scan(&amp;name, &amp;dataType)</code></span>
<span class="codeline" id="line-557"><code>				for _, c := range columnTypes {</code></span>
<span class="codeline" id="line-558"><code>					mc := c.(*migrator.ColumnType)</code></span>
<span class="codeline" id="line-559"><code>					if mc.NameValue.String == name {</code></span>
<span class="codeline" id="line-560"><code>						mc.ColumnTypeValue = sql.NullString{String: dataType, Valid: true}</code></span>
<span class="codeline" id="line-561"><code>						// Handle array type: _text -&gt; text[] , _int4 -&gt; integer[]</code></span>
<span class="codeline" id="line-562"><code>						// Not support array size limits and array size limits because:</code></span>
<span class="codeline" id="line-563"><code>						// https://www.postgresql.org/docs/current/arrays.html#ARRAYS-DECLARATION</code></span>
<span class="codeline" id="line-564"><code>						if strings.HasPrefix(mc.DataTypeValue.String, "_") {</code></span>
<span class="codeline" id="line-565"><code>							mc.DataTypeValue = sql.NullString{String: dataType, Valid: true}</code></span>
<span class="codeline" id="line-566"><code>						}</code></span>
<span class="codeline" id="line-567"><code>						break</code></span>
<span class="codeline" id="line-568"><code>					}</code></span>
<span class="codeline" id="line-569"><code>				}</code></span>
<span class="codeline" id="line-570"><code>			}</code></span>
<span class="codeline" id="line-571"><code>			dataTypeRows.Close()</code></span>
<span class="codeline" id="line-572"><code>		}</code></span>
<span class="codeline" id="line-573"><code></code></span>
<span class="codeline" id="line-574"><code>		return err</code></span>
<span class="codeline" id="line-575"><code>	})</code></span>
<span class="codeline" id="line-576"><code>	return</code></span>
<span class="codeline" id="line-577"><code>}</code></span>
<span class="codeline" id="line-578"><code></code></span>
<span class="codeline" id="line-579"><code>func (m Migrator) GetRows(currentSchema interface{}, table interface{}) (*sql.Rows, error) {</code></span>
<span class="codeline" id="line-580"><code>	name := table.(string)</code></span>
<span class="codeline" id="line-581"><code>	if _, ok := currentSchema.(string); ok {</code></span>
<span class="codeline" id="line-582"><code>		name = fmt.Sprintf("%v.%v", currentSchema, table)</code></span>
<span class="codeline" id="line-583"><code>	}</code></span>
<span class="codeline" id="line-584"><code></code></span>
<span class="codeline" id="line-585"><code>	return m.DB.Session(&amp;gorm.Session{}).Table(name).Limit(1).Scopes(func(d *gorm.DB) *gorm.DB {</code></span>
<span class="codeline" id="line-586"><code>		dialector, _ := m.Dialector.(Dialector)</code></span>
<span class="codeline" id="line-587"><code>		// use simple protocol</code></span>
<span class="codeline" id="line-588"><code>		if !m.DB.PrepareStmt &amp;&amp; (dialector.Config != nil &amp;&amp; (dialector.Config.DriverName == "" || dialector.Config.DriverName == "pgx")) {</code></span>
<span class="codeline" id="line-589"><code>			d.Statement.Vars = append([]interface{}{pgx.QueryExecModeSimpleProtocol}, d.Statement.Vars...)</code></span>
<span class="codeline" id="line-590"><code>		}</code></span>
<span class="codeline" id="line-591"><code>		return d</code></span>
<span class="codeline" id="line-592"><code>	}).Rows()</code></span>
<span class="codeline" id="line-593"><code>}</code></span>
<span class="codeline" id="line-594"><code></code></span>
<span class="codeline" id="line-595"><code>func (m Migrator) CurrentSchema(stmt *gorm.Statement, table string) (interface{}, interface{}) {</code></span>
<span class="codeline" id="line-596"><code>	if strings.Contains(table, ".") {</code></span>
<span class="codeline" id="line-597"><code>		if tables := strings.Split(table, `.`); len(tables) == 2 {</code></span>
<span class="codeline" id="line-598"><code>			return tables[0], tables[1]</code></span>
<span class="codeline" id="line-599"><code>		}</code></span>
<span class="codeline" id="line-600"><code>	}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>	if stmt.TableExpr != nil {</code></span>
<span class="codeline" id="line-603"><code>		if tables := strings.Split(stmt.TableExpr.SQL, `"."`); len(tables) == 2 {</code></span>
<span class="codeline" id="line-604"><code>			return strings.TrimPrefix(tables[0], `"`), table</code></span>
<span class="codeline" id="line-605"><code>		}</code></span>
<span class="codeline" id="line-606"><code>	}</code></span>
<span class="codeline" id="line-607"><code>	return clause.Expr{SQL: "CURRENT_SCHEMA()"}, table</code></span>
<span class="codeline" id="line-608"><code>}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>func (m Migrator) CreateSequence(tx *gorm.DB, stmt *gorm.Statement, field *schema.Field,</code></span>
<span class="codeline" id="line-611"><code>	serialDatabaseType string) (err error) {</code></span>
<span class="codeline" id="line-612"><code></code></span>
<span class="codeline" id="line-613"><code>	_, table := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-614"><code>	tableName := table.(string)</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>	sequenceName := strings.Join([]string{tableName, field.DBName, "seq"}, "_")</code></span>
<span class="codeline" id="line-617"><code>	if err = tx.Exec(`CREATE SEQUENCE IF NOT EXISTS ? AS ?`, clause.Expr{SQL: sequenceName},</code></span>
<span class="codeline" id="line-618"><code>		clause.Expr{SQL: serialDatabaseType}).Error; err != nil {</code></span>
<span class="codeline" id="line-619"><code>		return err</code></span>
<span class="codeline" id="line-620"><code>	}</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>	if err := tx.Exec("ALTER TABLE ? ALTER COLUMN ? SET DEFAULT nextval('?')",</code></span>
<span class="codeline" id="line-623"><code>		clause.Expr{SQL: tableName}, clause.Expr{SQL: field.DBName}, clause.Expr{SQL: sequenceName}).Error; err != nil {</code></span>
<span class="codeline" id="line-624"><code>		return err</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>	if err := tx.Exec("ALTER SEQUENCE ? OWNED BY ?.?",</code></span>
<span class="codeline" id="line-628"><code>		clause.Expr{SQL: sequenceName}, clause.Expr{SQL: tableName}, clause.Expr{SQL: field.DBName}).Error; err != nil {</code></span>
<span class="codeline" id="line-629"><code>		return err</code></span>
<span class="codeline" id="line-630"><code>	}</code></span>
<span class="codeline" id="line-631"><code>	return</code></span>
<span class="codeline" id="line-632"><code>}</code></span>
<span class="codeline" id="line-633"><code></code></span>
<span class="codeline" id="line-634"><code>func (m Migrator) UpdateSequence(tx *gorm.DB, stmt *gorm.Statement, field *schema.Field,</code></span>
<span class="codeline" id="line-635"><code>	serialDatabaseType string) (err error) {</code></span>
<span class="codeline" id="line-636"><code></code></span>
<span class="codeline" id="line-637"><code>	sequenceName, err := m.getColumnSequenceName(tx, stmt, field)</code></span>
<span class="codeline" id="line-638"><code>	if err != nil {</code></span>
<span class="codeline" id="line-639"><code>		return err</code></span>
<span class="codeline" id="line-640"><code>	}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>	if err = tx.Exec(`ALTER SEQUENCE IF EXISTS ? AS ?`, clause.Expr{SQL: sequenceName}, clause.Expr{SQL: serialDatabaseType}).Error; err != nil {</code></span>
<span class="codeline" id="line-643"><code>		return err</code></span>
<span class="codeline" id="line-644"><code>	}</code></span>
<span class="codeline" id="line-645"><code></code></span>
<span class="codeline" id="line-646"><code>	if err := tx.Exec("ALTER TABLE ? ALTER COLUMN ? TYPE ?",</code></span>
<span class="codeline" id="line-647"><code>		m.CurrentTable(stmt), clause.Expr{SQL: field.DBName}, clause.Expr{SQL: serialDatabaseType}).Error; err != nil {</code></span>
<span class="codeline" id="line-648"><code>		return err</code></span>
<span class="codeline" id="line-649"><code>	}</code></span>
<span class="codeline" id="line-650"><code>	return</code></span>
<span class="codeline" id="line-651"><code>}</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>func (m Migrator) DeleteSequence(tx *gorm.DB, stmt *gorm.Statement, field *schema.Field,</code></span>
<span class="codeline" id="line-654"><code>	fileType clause.Expr) (err error) {</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>	sequenceName, err := m.getColumnSequenceName(tx, stmt, field)</code></span>
<span class="codeline" id="line-657"><code>	if err != nil {</code></span>
<span class="codeline" id="line-658"><code>		return err</code></span>
<span class="codeline" id="line-659"><code>	}</code></span>
<span class="codeline" id="line-660"><code></code></span>
<span class="codeline" id="line-661"><code>	if err := tx.Exec("ALTER TABLE ? ALTER COLUMN ? TYPE ?", m.CurrentTable(stmt), clause.Column{Name: field.DBName}, fileType).Error; err != nil {</code></span>
<span class="codeline" id="line-662"><code>		return err</code></span>
<span class="codeline" id="line-663"><code>	}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>	if err := tx.Exec("ALTER TABLE ? ALTER COLUMN ? DROP DEFAULT",</code></span>
<span class="codeline" id="line-666"><code>		m.CurrentTable(stmt), clause.Expr{SQL: field.DBName}).Error; err != nil {</code></span>
<span class="codeline" id="line-667"><code>		return err</code></span>
<span class="codeline" id="line-668"><code>	}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>	if err = tx.Exec(`DROP SEQUENCE IF EXISTS ?`, clause.Expr{SQL: sequenceName}).Error; err != nil {</code></span>
<span class="codeline" id="line-671"><code>		return err</code></span>
<span class="codeline" id="line-672"><code>	}</code></span>
<span class="codeline" id="line-673"><code></code></span>
<span class="codeline" id="line-674"><code>	return</code></span>
<span class="codeline" id="line-675"><code>}</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>func (m Migrator) getColumnSequenceName(tx *gorm.DB, stmt *gorm.Statement, field *schema.Field) (</code></span>
<span class="codeline" id="line-678"><code>	sequenceName string, err error) {</code></span>
<span class="codeline" id="line-679"><code>	_, table := m.CurrentSchema(stmt, stmt.Table)</code></span>
<span class="codeline" id="line-680"><code></code></span>
<span class="codeline" id="line-681"><code>	// DefaultValueValue is reset by ColumnTypes, search again.</code></span>
<span class="codeline" id="line-682"><code>	var columnDefault string</code></span>
<span class="codeline" id="line-683"><code>	err = tx.Raw(</code></span>
<span class="codeline" id="line-684"><code>		`SELECT column_default FROM information_schema.columns WHERE table_name = ? AND column_name = ?`,</code></span>
<span class="codeline" id="line-685"><code>		table, field.DBName).Scan(&amp;columnDefault).Error</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>	if err != nil {</code></span>
<span class="codeline" id="line-688"><code>		return</code></span>
<span class="codeline" id="line-689"><code>	}</code></span>
<span class="codeline" id="line-690"><code></code></span>
<span class="codeline" id="line-691"><code>	sequenceName = strings.TrimSuffix(</code></span>
<span class="codeline" id="line-692"><code>		strings.TrimPrefix(columnDefault, `nextval('`),</code></span>
<span class="codeline" id="line-693"><code>		`'::regclass)`,</code></span>
<span class="codeline" id="line-694"><code>	)</code></span>
<span class="codeline" id="line-695"><code>	return</code></span>
<span class="codeline" id="line-696"><code>}</code></span>
<span class="codeline" id="line-697"><code></code></span>
<span class="codeline" id="line-698"><code>func (m Migrator) GetIndexes(value interface{}) ([]gorm.Index, error) {</code></span>
<span class="codeline" id="line-699"><code>	indexes := make([]gorm.Index, 0)</code></span>
<span class="codeline" id="line-700"><code></code></span>
<span class="codeline" id="line-701"><code>	err := m.RunWithValue(value, func(stmt *gorm.Statement) error {</code></span>
<span class="codeline" id="line-702"><code>		result := make([]*Index, 0)</code></span>
<span class="codeline" id="line-703"><code>		scanErr := m.DB.Raw(indexSql, stmt.Table).Scan(&amp;result).Error</code></span>
<span class="codeline" id="line-704"><code>		if scanErr != nil {</code></span>
<span class="codeline" id="line-705"><code>			return scanErr</code></span>
<span class="codeline" id="line-706"><code>		}</code></span>
<span class="codeline" id="line-707"><code>		indexMap := groupByIndexName(result)</code></span>
<span class="codeline" id="line-708"><code>		for _, idx := range indexMap {</code></span>
<span class="codeline" id="line-709"><code>			tempIdx := &amp;migrator.Index{</code></span>
<span class="codeline" id="line-710"><code>				TableName: idx[0].TableName,</code></span>
<span class="codeline" id="line-711"><code>				NameValue: idx[0].IndexName,</code></span>
<span class="codeline" id="line-712"><code>				PrimaryKeyValue: sql.NullBool{</code></span>
<span class="codeline" id="line-713"><code>					Bool:  idx[0].Primary,</code></span>
<span class="codeline" id="line-714"><code>					Valid: true,</code></span>
<span class="codeline" id="line-715"><code>				},</code></span>
<span class="codeline" id="line-716"><code>				UniqueValue: sql.NullBool{</code></span>
<span class="codeline" id="line-717"><code>					Bool:  idx[0].NonUnique,</code></span>
<span class="codeline" id="line-718"><code>					Valid: true,</code></span>
<span class="codeline" id="line-719"><code>				},</code></span>
<span class="codeline" id="line-720"><code>			}</code></span>
<span class="codeline" id="line-721"><code>			for _, x := range idx {</code></span>
<span class="codeline" id="line-722"><code>				tempIdx.ColumnList = append(tempIdx.ColumnList, x.ColumnName)</code></span>
<span class="codeline" id="line-723"><code>			}</code></span>
<span class="codeline" id="line-724"><code>			indexes = append(indexes, tempIdx)</code></span>
<span class="codeline" id="line-725"><code>		}</code></span>
<span class="codeline" id="line-726"><code>		return nil</code></span>
<span class="codeline" id="line-727"><code>	})</code></span>
<span class="codeline" id="line-728"><code>	return indexes, err</code></span>
<span class="codeline" id="line-729"><code>}</code></span>
<span class="codeline" id="line-730"><code></code></span>
<span class="codeline" id="line-731"><code>// Index table index info</code></span>
<span class="codeline" id="line-732"><code>type Index struct {</code></span>
<span class="codeline" id="line-733"><code>	TableName  string `gorm:"column:table_name"`</code></span>
<span class="codeline" id="line-734"><code>	ColumnName string `gorm:"column:column_name"`</code></span>
<span class="codeline" id="line-735"><code>	IndexName  string `gorm:"column:index_name"`</code></span>
<span class="codeline" id="line-736"><code>	NonUnique  bool   `gorm:"column:non_unique"`</code></span>
<span class="codeline" id="line-737"><code>	Primary    bool   `gorm:"column:primary"`</code></span>
<span class="codeline" id="line-738"><code>}</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>func groupByIndexName(indexList []*Index) map[string][]*Index {</code></span>
<span class="codeline" id="line-741"><code>	columnIndexMap := make(map[string][]*Index, len(indexList))</code></span>
<span class="codeline" id="line-742"><code>	for _, idx := range indexList {</code></span>
<span class="codeline" id="line-743"><code>		columnIndexMap[idx.IndexName] = append(columnIndexMap[idx.IndexName], idx)</code></span>
<span class="codeline" id="line-744"><code>	}</code></span>
<span class="codeline" id="line-745"><code>	return columnIndexMap</code></span>
<span class="codeline" id="line-746"><code>}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>func (m Migrator) GetTypeAliases(databaseTypeName string) []string {</code></span>
<span class="codeline" id="line-749"><code>	return typeAliasMap[databaseTypeName]</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>// should reset prepared stmts when table changed</code></span>
<span class="codeline" id="line-753"><code>func (m Migrator) resetPreparedStmts() {</code></span>
<span class="codeline" id="line-754"><code>	if m.DB.PrepareStmt {</code></span>
<span class="codeline" id="line-755"><code>		if pdb, ok := m.DB.ConnPool.(*gorm.PreparedStmtDB); ok {</code></span>
<span class="codeline" id="line-756"><code>			pdb.Reset()</code></span>
<span class="codeline" id="line-757"><code>		}</code></span>
<span class="codeline" id="line-758"><code>	}</code></span>
<span class="codeline" id="line-759"><code>}</code></span>
<span class="codeline" id="line-760"><code></code></span>
<span class="codeline" id="line-761"><code>func (m Migrator) DropColumn(dst interface{}, field string) error {</code></span>
<span class="codeline" id="line-762"><code>	if err := m.Migrator.DropColumn(dst, field); err != nil {</code></span>
<span class="codeline" id="line-763"><code>		return err</code></span>
<span class="codeline" id="line-764"><code>	}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>	m.resetPreparedStmts()</code></span>
<span class="codeline" id="line-767"><code>	return nil</code></span>
<span class="codeline" id="line-768"><code>}</code></span>
<span class="codeline" id="line-769"><code></code></span>
<span class="codeline" id="line-770"><code>func (m Migrator) RenameColumn(dst interface{}, oldName, field string) error {</code></span>
<span class="codeline" id="line-771"><code>	if err := m.Migrator.RenameColumn(dst, oldName, field); err != nil {</code></span>
<span class="codeline" id="line-772"><code>		return err</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code></code></span>
<span class="codeline" id="line-775"><code>	m.resetPreparedStmts()</code></span>
<span class="codeline" id="line-776"><code>	return nil</code></span>
<span class="codeline" id="line-777"><code>}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>func parseDefaultValueValue(defaultValue string) string {</code></span>
<span class="codeline" id="line-780"><code>	value := regexp.MustCompile(`^(.*?)(?:::.*)?$`).ReplaceAllString(defaultValue, "$1")</code></span>
<span class="codeline" id="line-781"><code>	return strings.Trim(value, "'")</code></span>
<span class="codeline" id="line-782"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>