<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: context.go in package context</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	context.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/context.html">context</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2014 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>// Package context defines the Context type, which carries deadlines,</code></span>
<span class="codeline" id="line-6"><code>// cancellation signals, and other request-scoped values across API boundaries</code></span>
<span class="codeline" id="line-7"><code>// and between processes.</code></span>
<span class="codeline" id="line-8"><code>//</code></span>
<span class="codeline" id="line-9"><code>// Incoming requests to a server should create a [Context], and outgoing</code></span>
<span class="codeline" id="line-10"><code>// calls to servers should accept a Context. The chain of function</code></span>
<span class="codeline" id="line-11"><code>// calls between them must propagate the Context, optionally replacing</code></span>
<span class="codeline" id="line-12"><code>// it with a derived Context created using [WithCancel], [WithDeadline],</code></span>
<span class="codeline" id="line-13"><code>// [WithTimeout], or [WithValue]. When a Context is canceled, all</code></span>
<span class="codeline" id="line-14"><code>// Contexts derived from it are also canceled.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>// The [WithCancel], [WithDeadline], and [WithTimeout] functions take a</code></span>
<span class="codeline" id="line-17"><code>// Context (the parent) and return a derived Context (the child) and a</code></span>
<span class="codeline" id="line-18"><code>// [CancelFunc]. Calling the CancelFunc cancels the child and its</code></span>
<span class="codeline" id="line-19"><code>// children, removes the parent's reference to the child, and stops</code></span>
<span class="codeline" id="line-20"><code>// any associated timers. Failing to call the CancelFunc leaks the</code></span>
<span class="codeline" id="line-21"><code>// child and its children until the parent is canceled or the timer</code></span>
<span class="codeline" id="line-22"><code>// fires. The go vet tool checks that CancelFuncs are used on all</code></span>
<span class="codeline" id="line-23"><code>// control-flow paths.</code></span>
<span class="codeline" id="line-24"><code>//</code></span>
<span class="codeline" id="line-25"><code>// The [WithCancelCause] function returns a [CancelCauseFunc], which</code></span>
<span class="codeline" id="line-26"><code>// takes an error and records it as the cancellation cause. Calling</code></span>
<span class="codeline" id="line-27"><code>// [Cause] on the canceled context or any of its children retrieves</code></span>
<span class="codeline" id="line-28"><code>// the cause. If no cause is specified, Cause(ctx) returns the same</code></span>
<span class="codeline" id="line-29"><code>// value as ctx.Err().</code></span>
<span class="codeline" id="line-30"><code>//</code></span>
<span class="codeline" id="line-31"><code>// Programs that use Contexts should follow these rules to keep interfaces</code></span>
<span class="codeline" id="line-32"><code>// consistent across packages and enable static analysis tools to check context</code></span>
<span class="codeline" id="line-33"><code>// propagation:</code></span>
<span class="codeline" id="line-34"><code>//</code></span>
<span class="codeline" id="line-35"><code>// Do not store Contexts inside a struct type; instead, pass a Context</code></span>
<span class="codeline" id="line-36"><code>// explicitly to each function that needs it. The Context should be the first</code></span>
<span class="codeline" id="line-37"><code>// parameter, typically named ctx:</code></span>
<span class="codeline" id="line-38"><code>//</code></span>
<span class="codeline" id="line-39"><code>//	func DoSomething(ctx context.Context, arg Arg) error {</code></span>
<span class="codeline" id="line-40"><code>//		// ... use ctx ...</code></span>
<span class="codeline" id="line-41"><code>//	}</code></span>
<span class="codeline" id="line-42"><code>//</code></span>
<span class="codeline" id="line-43"><code>// Do not pass a nil [Context], even if a function permits it. Pass [context.TODO]</code></span>
<span class="codeline" id="line-44"><code>// if you are unsure about which Context to use.</code></span>
<span class="codeline" id="line-45"><code>//</code></span>
<span class="codeline" id="line-46"><code>// Use context Values only for request-scoped data that transits processes and</code></span>
<span class="codeline" id="line-47"><code>// APIs, not for passing optional parameters to functions.</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// The same Context may be passed to functions running in different goroutines;</code></span>
<span class="codeline" id="line-50"><code>// Contexts are safe for simultaneous use by multiple goroutines.</code></span>
<span class="codeline" id="line-51"><code>//</code></span>
<span class="codeline" id="line-52"><code>// See https://blog.golang.org/context for example code for a server that uses</code></span>
<span class="codeline" id="line-53"><code>// Contexts.</code></span></div><span class="codeline" id="line-54"><code>package context</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>import (</code></span>
<span class="codeline" id="line-57"><code>	"errors"</code></span>
<span class="codeline" id="line-58"><code>	"internal/reflectlite"</code></span>
<span class="codeline" id="line-59"><code>	"sync"</code></span>
<span class="codeline" id="line-60"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-61"><code>	"time"</code></span>
<span class="codeline" id="line-62"><code>)</code></span>
<span class="codeline" id="line-63"><code></code></span>
<span class="codeline" id="line-64"><code>// A Context carries a deadline, a cancellation signal, and other values across</code></span>
<span class="codeline" id="line-65"><code>// API boundaries.</code></span>
<span class="codeline" id="line-66"><code>//</code></span>
<span class="codeline" id="line-67"><code>// Context's methods may be called by multiple goroutines simultaneously.</code></span>
<span class="codeline" id="line-68"><code>type Context interface {</code></span>
<span class="codeline" id="line-69"><code>	// Deadline returns the time when work done on behalf of this context</code></span>
<span class="codeline" id="line-70"><code>	// should be canceled. Deadline returns ok==false when no deadline is</code></span>
<span class="codeline" id="line-71"><code>	// set. Successive calls to Deadline return the same results.</code></span>
<span class="codeline" id="line-72"><code>	Deadline() (deadline time.Time, ok bool)</code></span>
<span class="codeline" id="line-73"><code></code></span>
<span class="codeline" id="line-74"><code>	// Done returns a channel that's closed when work done on behalf of this</code></span>
<span class="codeline" id="line-75"><code>	// context should be canceled. Done may return nil if this context can</code></span>
<span class="codeline" id="line-76"><code>	// never be canceled. Successive calls to Done return the same value.</code></span>
<span class="codeline" id="line-77"><code>	// The close of the Done channel may happen asynchronously,</code></span>
<span class="codeline" id="line-78"><code>	// after the cancel function returns.</code></span>
<span class="codeline" id="line-79"><code>	//</code></span>
<span class="codeline" id="line-80"><code>	// WithCancel arranges for Done to be closed when cancel is called;</code></span>
<span class="codeline" id="line-81"><code>	// WithDeadline arranges for Done to be closed when the deadline</code></span>
<span class="codeline" id="line-82"><code>	// expires; WithTimeout arranges for Done to be closed when the timeout</code></span>
<span class="codeline" id="line-83"><code>	// elapses.</code></span>
<span class="codeline" id="line-84"><code>	//</code></span>
<span class="codeline" id="line-85"><code>	// Done is provided for use in select statements:</code></span>
<span class="codeline" id="line-86"><code>	//</code></span>
<span class="codeline" id="line-87"><code>	//  // Stream generates values with DoSomething and sends them to out</code></span>
<span class="codeline" id="line-88"><code>	//  // until DoSomething returns an error or ctx.Done is closed.</code></span>
<span class="codeline" id="line-89"><code>	//  func Stream(ctx context.Context, out chan&lt;- Value) error {</code></span>
<span class="codeline" id="line-90"><code>	//  	for {</code></span>
<span class="codeline" id="line-91"><code>	//  		v, err := DoSomething(ctx)</code></span>
<span class="codeline" id="line-92"><code>	//  		if err != nil {</code></span>
<span class="codeline" id="line-93"><code>	//  			return err</code></span>
<span class="codeline" id="line-94"><code>	//  		}</code></span>
<span class="codeline" id="line-95"><code>	//  		select {</code></span>
<span class="codeline" id="line-96"><code>	//  		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-97"><code>	//  			return ctx.Err()</code></span>
<span class="codeline" id="line-98"><code>	//  		case out &lt;- v:</code></span>
<span class="codeline" id="line-99"><code>	//  		}</code></span>
<span class="codeline" id="line-100"><code>	//  	}</code></span>
<span class="codeline" id="line-101"><code>	//  }</code></span>
<span class="codeline" id="line-102"><code>	//</code></span>
<span class="codeline" id="line-103"><code>	// See https://blog.golang.org/pipelines for more examples of how to use</code></span>
<span class="codeline" id="line-104"><code>	// a Done channel for cancellation.</code></span>
<span class="codeline" id="line-105"><code>	Done() &lt;-chan struct{}</code></span>
<span class="codeline" id="line-106"><code></code></span>
<span class="codeline" id="line-107"><code>	// If Done is not yet closed, Err returns nil.</code></span>
<span class="codeline" id="line-108"><code>	// If Done is closed, Err returns a non-nil error explaining why:</code></span>
<span class="codeline" id="line-109"><code>	// Canceled if the context was canceled</code></span>
<span class="codeline" id="line-110"><code>	// or DeadlineExceeded if the context's deadline passed.</code></span>
<span class="codeline" id="line-111"><code>	// After Err returns a non-nil error, successive calls to Err return the same error.</code></span>
<span class="codeline" id="line-112"><code>	Err() error</code></span>
<span class="codeline" id="line-113"><code></code></span>
<span class="codeline" id="line-114"><code>	// Value returns the value associated with this context for key, or nil</code></span>
<span class="codeline" id="line-115"><code>	// if no value is associated with key. Successive calls to Value with</code></span>
<span class="codeline" id="line-116"><code>	// the same key returns the same result.</code></span>
<span class="codeline" id="line-117"><code>	//</code></span>
<span class="codeline" id="line-118"><code>	// Use context values only for request-scoped data that transits</code></span>
<span class="codeline" id="line-119"><code>	// processes and API boundaries, not for passing optional parameters to</code></span>
<span class="codeline" id="line-120"><code>	// functions.</code></span>
<span class="codeline" id="line-121"><code>	//</code></span>
<span class="codeline" id="line-122"><code>	// A key identifies a specific value in a Context. Functions that wish</code></span>
<span class="codeline" id="line-123"><code>	// to store values in Context typically allocate a key in a global</code></span>
<span class="codeline" id="line-124"><code>	// variable then use that key as the argument to context.WithValue and</code></span>
<span class="codeline" id="line-125"><code>	// Context.Value. A key can be any type that supports equality;</code></span>
<span class="codeline" id="line-126"><code>	// packages should define keys as an unexported type to avoid</code></span>
<span class="codeline" id="line-127"><code>	// collisions.</code></span>
<span class="codeline" id="line-128"><code>	//</code></span>
<span class="codeline" id="line-129"><code>	// Packages that define a Context key should provide type-safe accessors</code></span>
<span class="codeline" id="line-130"><code>	// for the values stored using that key:</code></span>
<span class="codeline" id="line-131"><code>	//</code></span>
<span class="codeline" id="line-132"><code>	// 	// Package user defines a User type that's stored in Contexts.</code></span>
<span class="codeline" id="line-133"><code>	// 	package user</code></span>
<span class="codeline" id="line-134"><code>	//</code></span>
<span class="codeline" id="line-135"><code>	// 	import "context"</code></span>
<span class="codeline" id="line-136"><code>	//</code></span>
<span class="codeline" id="line-137"><code>	// 	// User is the type of value stored in the Contexts.</code></span>
<span class="codeline" id="line-138"><code>	// 	type User struct {...}</code></span>
<span class="codeline" id="line-139"><code>	//</code></span>
<span class="codeline" id="line-140"><code>	// 	// key is an unexported type for keys defined in this package.</code></span>
<span class="codeline" id="line-141"><code>	// 	// This prevents collisions with keys defined in other packages.</code></span>
<span class="codeline" id="line-142"><code>	// 	type key int</code></span>
<span class="codeline" id="line-143"><code>	//</code></span>
<span class="codeline" id="line-144"><code>	// 	// userKey is the key for user.User values in Contexts. It is</code></span>
<span class="codeline" id="line-145"><code>	// 	// unexported; clients use user.NewContext and user.FromContext</code></span>
<span class="codeline" id="line-146"><code>	// 	// instead of using this key directly.</code></span>
<span class="codeline" id="line-147"><code>	// 	var userKey key</code></span>
<span class="codeline" id="line-148"><code>	//</code></span>
<span class="codeline" id="line-149"><code>	// 	// NewContext returns a new Context that carries value u.</code></span>
<span class="codeline" id="line-150"><code>	// 	func NewContext(ctx context.Context, u *User) context.Context {</code></span>
<span class="codeline" id="line-151"><code>	// 		return context.WithValue(ctx, userKey, u)</code></span>
<span class="codeline" id="line-152"><code>	// 	}</code></span>
<span class="codeline" id="line-153"><code>	//</code></span>
<span class="codeline" id="line-154"><code>	// 	// FromContext returns the User value stored in ctx, if any.</code></span>
<span class="codeline" id="line-155"><code>	// 	func FromContext(ctx context.Context) (*User, bool) {</code></span>
<span class="codeline" id="line-156"><code>	// 		u, ok := ctx.Value(userKey).(*User)</code></span>
<span class="codeline" id="line-157"><code>	// 		return u, ok</code></span>
<span class="codeline" id="line-158"><code>	// 	}</code></span>
<span class="codeline" id="line-159"><code>	Value(key any) any</code></span>
<span class="codeline" id="line-160"><code>}</code></span>
<span class="codeline" id="line-161"><code></code></span>
<span class="codeline" id="line-162"><code>// Canceled is the error returned by [Context.Err] when the context is canceled.</code></span>
<span class="codeline" id="line-163"><code>var Canceled = errors.New("context canceled")</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code>// DeadlineExceeded is the error returned by [Context.Err] when the context's</code></span>
<span class="codeline" id="line-166"><code>// deadline passes.</code></span>
<span class="codeline" id="line-167"><code>var DeadlineExceeded error = deadlineExceededError{}</code></span>
<span class="codeline" id="line-168"><code></code></span>
<span class="codeline" id="line-169"><code>type deadlineExceededError struct{}</code></span>
<span class="codeline" id="line-170"><code></code></span>
<span class="codeline" id="line-171"><code>func (deadlineExceededError) Error() string   { return "context deadline exceeded" }</code></span>
<span class="codeline" id="line-172"><code>func (deadlineExceededError) Timeout() bool   { return true }</code></span>
<span class="codeline" id="line-173"><code>func (deadlineExceededError) Temporary() bool { return true }</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>// An emptyCtx is never canceled, has no values, and has no deadline.</code></span>
<span class="codeline" id="line-176"><code>// It is the common base of backgroundCtx and todoCtx.</code></span>
<span class="codeline" id="line-177"><code>type emptyCtx struct{}</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>func (emptyCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-180"><code>	return</code></span>
<span class="codeline" id="line-181"><code>}</code></span>
<span class="codeline" id="line-182"><code></code></span>
<span class="codeline" id="line-183"><code>func (emptyCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-184"><code>	return nil</code></span>
<span class="codeline" id="line-185"><code>}</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>func (emptyCtx) Err() error {</code></span>
<span class="codeline" id="line-188"><code>	return nil</code></span>
<span class="codeline" id="line-189"><code>}</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>func (emptyCtx) Value(key any) any {</code></span>
<span class="codeline" id="line-192"><code>	return nil</code></span>
<span class="codeline" id="line-193"><code>}</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>type backgroundCtx struct{ emptyCtx }</code></span>
<span class="codeline" id="line-196"><code></code></span>
<span class="codeline" id="line-197"><code>func (backgroundCtx) String() string {</code></span>
<span class="codeline" id="line-198"><code>	return "context.Background"</code></span>
<span class="codeline" id="line-199"><code>}</code></span>
<span class="codeline" id="line-200"><code></code></span>
<span class="codeline" id="line-201"><code>type todoCtx struct{ emptyCtx }</code></span>
<span class="codeline" id="line-202"><code></code></span>
<span class="codeline" id="line-203"><code>func (todoCtx) String() string {</code></span>
<span class="codeline" id="line-204"><code>	return "context.TODO"</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>// Background returns a non-nil, empty [Context]. It is never canceled, has no</code></span>
<span class="codeline" id="line-208"><code>// values, and has no deadline. It is typically used by the main function,</code></span>
<span class="codeline" id="line-209"><code>// initialization, and tests, and as the top-level Context for incoming</code></span>
<span class="codeline" id="line-210"><code>// requests.</code></span>
<span class="codeline" id="line-211"><code>func Background() Context {</code></span>
<span class="codeline" id="line-212"><code>	return backgroundCtx{}</code></span>
<span class="codeline" id="line-213"><code>}</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code>// TODO returns a non-nil, empty [Context]. Code should use context.TODO when</code></span>
<span class="codeline" id="line-216"><code>// it's unclear which Context to use or it is not yet available (because the</code></span>
<span class="codeline" id="line-217"><code>// surrounding function has not yet been extended to accept a Context</code></span>
<span class="codeline" id="line-218"><code>// parameter).</code></span>
<span class="codeline" id="line-219"><code>func TODO() Context {</code></span>
<span class="codeline" id="line-220"><code>	return todoCtx{}</code></span>
<span class="codeline" id="line-221"><code>}</code></span>
<span class="codeline" id="line-222"><code></code></span>
<span class="codeline" id="line-223"><code>// A CancelFunc tells an operation to abandon its work.</code></span>
<span class="codeline" id="line-224"><code>// A CancelFunc does not wait for the work to stop.</code></span>
<span class="codeline" id="line-225"><code>// A CancelFunc may be called by multiple goroutines simultaneously.</code></span>
<span class="codeline" id="line-226"><code>// After the first call, subsequent calls to a CancelFunc do nothing.</code></span>
<span class="codeline" id="line-227"><code>type CancelFunc func()</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>// WithCancel returns a copy of parent with a new Done channel. The returned</code></span>
<span class="codeline" id="line-230"><code>// context's Done channel is closed when the returned cancel function is called</code></span>
<span class="codeline" id="line-231"><code>// or when the parent context's Done channel is closed, whichever happens first.</code></span>
<span class="codeline" id="line-232"><code>//</code></span>
<span class="codeline" id="line-233"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-234"><code>// call cancel as soon as the operations running in this Context complete.</code></span>
<span class="codeline" id="line-235"><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {</code></span>
<span class="codeline" id="line-236"><code>	c := withCancel(parent)</code></span>
<span class="codeline" id="line-237"><code>	return c, func() { c.cancel(true, Canceled, nil) }</code></span>
<span class="codeline" id="line-238"><code>}</code></span>
<span class="codeline" id="line-239"><code></code></span>
<span class="codeline" id="line-240"><code>// A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.</code></span>
<span class="codeline" id="line-241"><code>// This cause can be retrieved by calling [Cause] on the canceled Context or on</code></span>
<span class="codeline" id="line-242"><code>// any of its derived Contexts.</code></span>
<span class="codeline" id="line-243"><code>//</code></span>
<span class="codeline" id="line-244"><code>// If the context has already been canceled, CancelCauseFunc does not set the cause.</code></span>
<span class="codeline" id="line-245"><code>// For example, if childContext is derived from parentContext:</code></span>
<span class="codeline" id="line-246"><code>//   - if parentContext is canceled with cause1 before childContext is canceled with cause2,</code></span>
<span class="codeline" id="line-247"><code>//     then Cause(parentContext) == Cause(childContext) == cause1</code></span>
<span class="codeline" id="line-248"><code>//   - if childContext is canceled with cause2 before parentContext is canceled with cause1,</code></span>
<span class="codeline" id="line-249"><code>//     then Cause(parentContext) == cause1 and Cause(childContext) == cause2</code></span>
<span class="codeline" id="line-250"><code>type CancelCauseFunc func(cause error)</code></span>
<span class="codeline" id="line-251"><code></code></span>
<span class="codeline" id="line-252"><code>// WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].</code></span>
<span class="codeline" id="line-253"><code>// Calling cancel with a non-nil error (the "cause") records that error in ctx;</code></span>
<span class="codeline" id="line-254"><code>// it can then be retrieved using Cause(ctx).</code></span>
<span class="codeline" id="line-255"><code>// Calling cancel with nil sets the cause to Canceled.</code></span>
<span class="codeline" id="line-256"><code>//</code></span>
<span class="codeline" id="line-257"><code>// Example use:</code></span>
<span class="codeline" id="line-258"><code>//</code></span>
<span class="codeline" id="line-259"><code>//	ctx, cancel := context.WithCancelCause(parent)</code></span>
<span class="codeline" id="line-260"><code>//	cancel(myError)</code></span>
<span class="codeline" id="line-261"><code>//	ctx.Err() // returns context.Canceled</code></span>
<span class="codeline" id="line-262"><code>//	context.Cause(ctx) // returns myError</code></span>
<span class="codeline" id="line-263"><code>func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) {</code></span>
<span class="codeline" id="line-264"><code>	c := withCancel(parent)</code></span>
<span class="codeline" id="line-265"><code>	return c, func(cause error) { c.cancel(true, Canceled, cause) }</code></span>
<span class="codeline" id="line-266"><code>}</code></span>
<span class="codeline" id="line-267"><code></code></span>
<span class="codeline" id="line-268"><code>func withCancel(parent Context) *cancelCtx {</code></span>
<span class="codeline" id="line-269"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-270"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-271"><code>	}</code></span>
<span class="codeline" id="line-272"><code>	c := &amp;cancelCtx{}</code></span>
<span class="codeline" id="line-273"><code>	c.propagateCancel(parent, c)</code></span>
<span class="codeline" id="line-274"><code>	return c</code></span>
<span class="codeline" id="line-275"><code>}</code></span>
<span class="codeline" id="line-276"><code></code></span>
<span class="codeline" id="line-277"><code>// Cause returns a non-nil error explaining why c was canceled.</code></span>
<span class="codeline" id="line-278"><code>// The first cancellation of c or one of its parents sets the cause.</code></span>
<span class="codeline" id="line-279"><code>// If that cancellation happened via a call to CancelCauseFunc(err),</code></span>
<span class="codeline" id="line-280"><code>// then [Cause] returns err.</code></span>
<span class="codeline" id="line-281"><code>// Otherwise Cause(c) returns the same value as c.Err().</code></span>
<span class="codeline" id="line-282"><code>// Cause returns nil if c has not been canceled yet.</code></span>
<span class="codeline" id="line-283"><code>func Cause(c Context) error {</code></span>
<span class="codeline" id="line-284"><code>	if cc, ok := c.Value(&amp;cancelCtxKey).(*cancelCtx); ok {</code></span>
<span class="codeline" id="line-285"><code>		cc.mu.Lock()</code></span>
<span class="codeline" id="line-286"><code>		defer cc.mu.Unlock()</code></span>
<span class="codeline" id="line-287"><code>		return cc.cause</code></span>
<span class="codeline" id="line-288"><code>	}</code></span>
<span class="codeline" id="line-289"><code>	// There is no cancelCtxKey value, so we know that c is</code></span>
<span class="codeline" id="line-290"><code>	// not a descendant of some Context created by WithCancelCause.</code></span>
<span class="codeline" id="line-291"><code>	// Therefore, there is no specific cause to return.</code></span>
<span class="codeline" id="line-292"><code>	// If this is not one of the standard Context types,</code></span>
<span class="codeline" id="line-293"><code>	// it might still have an error even though it won't have a cause.</code></span>
<span class="codeline" id="line-294"><code>	return c.Err()</code></span>
<span class="codeline" id="line-295"><code>}</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>// AfterFunc arranges to call f in its own goroutine after ctx is done</code></span>
<span class="codeline" id="line-298"><code>// (cancelled or timed out).</code></span>
<span class="codeline" id="line-299"><code>// If ctx is already done, AfterFunc calls f immediately in its own goroutine.</code></span>
<span class="codeline" id="line-300"><code>//</code></span>
<span class="codeline" id="line-301"><code>// Multiple calls to AfterFunc on a context operate independently;</code></span>
<span class="codeline" id="line-302"><code>// one does not replace another.</code></span>
<span class="codeline" id="line-303"><code>//</code></span>
<span class="codeline" id="line-304"><code>// Calling the returned stop function stops the association of ctx with f.</code></span>
<span class="codeline" id="line-305"><code>// It returns true if the call stopped f from being run.</code></span>
<span class="codeline" id="line-306"><code>// If stop returns false,</code></span>
<span class="codeline" id="line-307"><code>// either the context is done and f has been started in its own goroutine;</code></span>
<span class="codeline" id="line-308"><code>// or f was already stopped.</code></span>
<span class="codeline" id="line-309"><code>// The stop function does not wait for f to complete before returning.</code></span>
<span class="codeline" id="line-310"><code>// If the caller needs to know whether f is completed,</code></span>
<span class="codeline" id="line-311"><code>// it must coordinate with f explicitly.</code></span>
<span class="codeline" id="line-312"><code>//</code></span>
<span class="codeline" id="line-313"><code>// If ctx has a "AfterFunc(func()) func() bool" method,</code></span>
<span class="codeline" id="line-314"><code>// AfterFunc will use it to schedule the call.</code></span>
<span class="codeline" id="line-315"><code>func AfterFunc(ctx Context, f func()) (stop func() bool) {</code></span>
<span class="codeline" id="line-316"><code>	a := &amp;afterFuncCtx{</code></span>
<span class="codeline" id="line-317"><code>		f: f,</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	a.cancelCtx.propagateCancel(ctx, a)</code></span>
<span class="codeline" id="line-320"><code>	return func() bool {</code></span>
<span class="codeline" id="line-321"><code>		stopped := false</code></span>
<span class="codeline" id="line-322"><code>		a.once.Do(func() {</code></span>
<span class="codeline" id="line-323"><code>			stopped = true</code></span>
<span class="codeline" id="line-324"><code>		})</code></span>
<span class="codeline" id="line-325"><code>		if stopped {</code></span>
<span class="codeline" id="line-326"><code>			a.cancel(true, Canceled, nil)</code></span>
<span class="codeline" id="line-327"><code>		}</code></span>
<span class="codeline" id="line-328"><code>		return stopped</code></span>
<span class="codeline" id="line-329"><code>	}</code></span>
<span class="codeline" id="line-330"><code>}</code></span>
<span class="codeline" id="line-331"><code></code></span>
<span class="codeline" id="line-332"><code>type afterFuncer interface {</code></span>
<span class="codeline" id="line-333"><code>	AfterFunc(func()) func() bool</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>type afterFuncCtx struct {</code></span>
<span class="codeline" id="line-337"><code>	cancelCtx</code></span>
<span class="codeline" id="line-338"><code>	once sync.Once // either starts running f or stops f from running</code></span>
<span class="codeline" id="line-339"><code>	f    func()</code></span>
<span class="codeline" id="line-340"><code>}</code></span>
<span class="codeline" id="line-341"><code></code></span>
<span class="codeline" id="line-342"><code>func (a *afterFuncCtx) cancel(removeFromParent bool, err, cause error) {</code></span>
<span class="codeline" id="line-343"><code>	a.cancelCtx.cancel(false, err, cause)</code></span>
<span class="codeline" id="line-344"><code>	if removeFromParent {</code></span>
<span class="codeline" id="line-345"><code>		removeChild(a.Context, a)</code></span>
<span class="codeline" id="line-346"><code>	}</code></span>
<span class="codeline" id="line-347"><code>	a.once.Do(func() {</code></span>
<span class="codeline" id="line-348"><code>		go a.f()</code></span>
<span class="codeline" id="line-349"><code>	})</code></span>
<span class="codeline" id="line-350"><code>}</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>// A stopCtx is used as the parent context of a cancelCtx when</code></span>
<span class="codeline" id="line-353"><code>// an AfterFunc has been registered with the parent.</code></span>
<span class="codeline" id="line-354"><code>// It holds the stop function used to unregister the AfterFunc.</code></span>
<span class="codeline" id="line-355"><code>type stopCtx struct {</code></span>
<span class="codeline" id="line-356"><code>	Context</code></span>
<span class="codeline" id="line-357"><code>	stop func() bool</code></span>
<span class="codeline" id="line-358"><code>}</code></span>
<span class="codeline" id="line-359"><code></code></span>
<span class="codeline" id="line-360"><code>// goroutines counts the number of goroutines ever created; for testing.</code></span>
<span class="codeline" id="line-361"><code>var goroutines atomic.Int32</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>// &amp;cancelCtxKey is the key that a cancelCtx returns itself for.</code></span>
<span class="codeline" id="line-364"><code>var cancelCtxKey int</code></span>
<span class="codeline" id="line-365"><code></code></span>
<span class="codeline" id="line-366"><code>// parentCancelCtx returns the underlying *cancelCtx for parent.</code></span>
<span class="codeline" id="line-367"><code>// It does this by looking up parent.Value(&amp;cancelCtxKey) to find</code></span>
<span class="codeline" id="line-368"><code>// the innermost enclosing *cancelCtx and then checking whether</code></span>
<span class="codeline" id="line-369"><code>// parent.Done() matches that *cancelCtx. (If not, the *cancelCtx</code></span>
<span class="codeline" id="line-370"><code>// has been wrapped in a custom implementation providing a</code></span>
<span class="codeline" id="line-371"><code>// different done channel, in which case we should not bypass it.)</code></span>
<span class="codeline" id="line-372"><code>func parentCancelCtx(parent Context) (*cancelCtx, bool) {</code></span>
<span class="codeline" id="line-373"><code>	done := parent.Done()</code></span>
<span class="codeline" id="line-374"><code>	if done == closedchan || done == nil {</code></span>
<span class="codeline" id="line-375"><code>		return nil, false</code></span>
<span class="codeline" id="line-376"><code>	}</code></span>
<span class="codeline" id="line-377"><code>	p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</code></span>
<span class="codeline" id="line-378"><code>	if !ok {</code></span>
<span class="codeline" id="line-379"><code>		return nil, false</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	pdone, _ := p.done.Load().(chan struct{})</code></span>
<span class="codeline" id="line-382"><code>	if pdone != done {</code></span>
<span class="codeline" id="line-383"><code>		return nil, false</code></span>
<span class="codeline" id="line-384"><code>	}</code></span>
<span class="codeline" id="line-385"><code>	return p, true</code></span>
<span class="codeline" id="line-386"><code>}</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>// removeChild removes a context from its parent.</code></span>
<span class="codeline" id="line-389"><code>func removeChild(parent Context, child canceler) {</code></span>
<span class="codeline" id="line-390"><code>	if s, ok := parent.(stopCtx); ok {</code></span>
<span class="codeline" id="line-391"><code>		s.stop()</code></span>
<span class="codeline" id="line-392"><code>		return</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	p, ok := parentCancelCtx(parent)</code></span>
<span class="codeline" id="line-395"><code>	if !ok {</code></span>
<span class="codeline" id="line-396"><code>		return</code></span>
<span class="codeline" id="line-397"><code>	}</code></span>
<span class="codeline" id="line-398"><code>	p.mu.Lock()</code></span>
<span class="codeline" id="line-399"><code>	if p.children != nil {</code></span>
<span class="codeline" id="line-400"><code>		delete(p.children, child)</code></span>
<span class="codeline" id="line-401"><code>	}</code></span>
<span class="codeline" id="line-402"><code>	p.mu.Unlock()</code></span>
<span class="codeline" id="line-403"><code>}</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>// A canceler is a context type that can be canceled directly. The</code></span>
<span class="codeline" id="line-406"><code>// implementations are *cancelCtx and *timerCtx.</code></span>
<span class="codeline" id="line-407"><code>type canceler interface {</code></span>
<span class="codeline" id="line-408"><code>	cancel(removeFromParent bool, err, cause error)</code></span>
<span class="codeline" id="line-409"><code>	Done() &lt;-chan struct{}</code></span>
<span class="codeline" id="line-410"><code>}</code></span>
<span class="codeline" id="line-411"><code></code></span>
<span class="codeline" id="line-412"><code>// closedchan is a reusable closed channel.</code></span>
<span class="codeline" id="line-413"><code>var closedchan = make(chan struct{})</code></span>
<span class="codeline" id="line-414"><code></code></span>
<span class="codeline" id="line-415"><code>func init() {</code></span>
<span class="codeline" id="line-416"><code>	close(closedchan)</code></span>
<span class="codeline" id="line-417"><code>}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>// A cancelCtx can be canceled. When canceled, it also cancels any children</code></span>
<span class="codeline" id="line-420"><code>// that implement canceler.</code></span>
<span class="codeline" id="line-421"><code>type cancelCtx struct {</code></span>
<span class="codeline" id="line-422"><code>	Context</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>	mu       sync.Mutex            // protects following fields</code></span>
<span class="codeline" id="line-425"><code>	done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call</code></span>
<span class="codeline" id="line-426"><code>	children map[canceler]struct{} // set to nil by the first cancel call</code></span>
<span class="codeline" id="line-427"><code>	err      error                 // set to non-nil by the first cancel call</code></span>
<span class="codeline" id="line-428"><code>	cause    error                 // set to non-nil by the first cancel call</code></span>
<span class="codeline" id="line-429"><code>}</code></span>
<span class="codeline" id="line-430"><code></code></span>
<span class="codeline" id="line-431"><code>func (c *cancelCtx) Value(key any) any {</code></span>
<span class="codeline" id="line-432"><code>	if key == &amp;cancelCtxKey {</code></span>
<span class="codeline" id="line-433"><code>		return c</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	return value(c.Context, key)</code></span>
<span class="codeline" id="line-436"><code>}</code></span>
<span class="codeline" id="line-437"><code></code></span>
<span class="codeline" id="line-438"><code>func (c *cancelCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-439"><code>	d := c.done.Load()</code></span>
<span class="codeline" id="line-440"><code>	if d != nil {</code></span>
<span class="codeline" id="line-441"><code>		return d.(chan struct{})</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-444"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-445"><code>	d = c.done.Load()</code></span>
<span class="codeline" id="line-446"><code>	if d == nil {</code></span>
<span class="codeline" id="line-447"><code>		d = make(chan struct{})</code></span>
<span class="codeline" id="line-448"><code>		c.done.Store(d)</code></span>
<span class="codeline" id="line-449"><code>	}</code></span>
<span class="codeline" id="line-450"><code>	return d.(chan struct{})</code></span>
<span class="codeline" id="line-451"><code>}</code></span>
<span class="codeline" id="line-452"><code></code></span>
<span class="codeline" id="line-453"><code>func (c *cancelCtx) Err() error {</code></span>
<span class="codeline" id="line-454"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-455"><code>	err := c.err</code></span>
<span class="codeline" id="line-456"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-457"><code>	return err</code></span>
<span class="codeline" id="line-458"><code>}</code></span>
<span class="codeline" id="line-459"><code></code></span>
<span class="codeline" id="line-460"><code>// propagateCancel arranges for child to be canceled when parent is.</code></span>
<span class="codeline" id="line-461"><code>// It sets the parent context of cancelCtx.</code></span>
<span class="codeline" id="line-462"><code>func (c *cancelCtx) propagateCancel(parent Context, child canceler) {</code></span>
<span class="codeline" id="line-463"><code>	c.Context = parent</code></span>
<span class="codeline" id="line-464"><code></code></span>
<span class="codeline" id="line-465"><code>	done := parent.Done()</code></span>
<span class="codeline" id="line-466"><code>	if done == nil {</code></span>
<span class="codeline" id="line-467"><code>		return // parent is never canceled</code></span>
<span class="codeline" id="line-468"><code>	}</code></span>
<span class="codeline" id="line-469"><code></code></span>
<span class="codeline" id="line-470"><code>	select {</code></span>
<span class="codeline" id="line-471"><code>	case &lt;-done:</code></span>
<span class="codeline" id="line-472"><code>		// parent is already canceled</code></span>
<span class="codeline" id="line-473"><code>		child.cancel(false, parent.Err(), Cause(parent))</code></span>
<span class="codeline" id="line-474"><code>		return</code></span>
<span class="codeline" id="line-475"><code>	default:</code></span>
<span class="codeline" id="line-476"><code>	}</code></span>
<span class="codeline" id="line-477"><code></code></span>
<span class="codeline" id="line-478"><code>	if p, ok := parentCancelCtx(parent); ok {</code></span>
<span class="codeline" id="line-479"><code>		// parent is a *cancelCtx, or derives from one.</code></span>
<span class="codeline" id="line-480"><code>		p.mu.Lock()</code></span>
<span class="codeline" id="line-481"><code>		if p.err != nil {</code></span>
<span class="codeline" id="line-482"><code>			// parent has already been canceled</code></span>
<span class="codeline" id="line-483"><code>			child.cancel(false, p.err, p.cause)</code></span>
<span class="codeline" id="line-484"><code>		} else {</code></span>
<span class="codeline" id="line-485"><code>			if p.children == nil {</code></span>
<span class="codeline" id="line-486"><code>				p.children = make(map[canceler]struct{})</code></span>
<span class="codeline" id="line-487"><code>			}</code></span>
<span class="codeline" id="line-488"><code>			p.children[child] = struct{}{}</code></span>
<span class="codeline" id="line-489"><code>		}</code></span>
<span class="codeline" id="line-490"><code>		p.mu.Unlock()</code></span>
<span class="codeline" id="line-491"><code>		return</code></span>
<span class="codeline" id="line-492"><code>	}</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>	if a, ok := parent.(afterFuncer); ok {</code></span>
<span class="codeline" id="line-495"><code>		// parent implements an AfterFunc method.</code></span>
<span class="codeline" id="line-496"><code>		c.mu.Lock()</code></span>
<span class="codeline" id="line-497"><code>		stop := a.AfterFunc(func() {</code></span>
<span class="codeline" id="line-498"><code>			child.cancel(false, parent.Err(), Cause(parent))</code></span>
<span class="codeline" id="line-499"><code>		})</code></span>
<span class="codeline" id="line-500"><code>		c.Context = stopCtx{</code></span>
<span class="codeline" id="line-501"><code>			Context: parent,</code></span>
<span class="codeline" id="line-502"><code>			stop:    stop,</code></span>
<span class="codeline" id="line-503"><code>		}</code></span>
<span class="codeline" id="line-504"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-505"><code>		return</code></span>
<span class="codeline" id="line-506"><code>	}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>	goroutines.Add(1)</code></span>
<span class="codeline" id="line-509"><code>	go func() {</code></span>
<span class="codeline" id="line-510"><code>		select {</code></span>
<span class="codeline" id="line-511"><code>		case &lt;-parent.Done():</code></span>
<span class="codeline" id="line-512"><code>			child.cancel(false, parent.Err(), Cause(parent))</code></span>
<span class="codeline" id="line-513"><code>		case &lt;-child.Done():</code></span>
<span class="codeline" id="line-514"><code>		}</code></span>
<span class="codeline" id="line-515"><code>	}()</code></span>
<span class="codeline" id="line-516"><code>}</code></span>
<span class="codeline" id="line-517"><code></code></span>
<span class="codeline" id="line-518"><code>type stringer interface {</code></span>
<span class="codeline" id="line-519"><code>	String() string</code></span>
<span class="codeline" id="line-520"><code>}</code></span>
<span class="codeline" id="line-521"><code></code></span>
<span class="codeline" id="line-522"><code>func contextName(c Context) string {</code></span>
<span class="codeline" id="line-523"><code>	if s, ok := c.(stringer); ok {</code></span>
<span class="codeline" id="line-524"><code>		return s.String()</code></span>
<span class="codeline" id="line-525"><code>	}</code></span>
<span class="codeline" id="line-526"><code>	return reflectlite.TypeOf(c).String()</code></span>
<span class="codeline" id="line-527"><code>}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>func (c *cancelCtx) String() string {</code></span>
<span class="codeline" id="line-530"><code>	return contextName(c.Context) + ".WithCancel"</code></span>
<span class="codeline" id="line-531"><code>}</code></span>
<span class="codeline" id="line-532"><code></code></span>
<span class="codeline" id="line-533"><code>// cancel closes c.done, cancels each of c's children, and, if</code></span>
<span class="codeline" id="line-534"><code>// removeFromParent is true, removes c from its parent's children.</code></span>
<span class="codeline" id="line-535"><code>// cancel sets c.cause to cause if this is the first time c is canceled.</code></span>
<span class="codeline" id="line-536"><code>func (c *cancelCtx) cancel(removeFromParent bool, err, cause error) {</code></span>
<span class="codeline" id="line-537"><code>	if err == nil {</code></span>
<span class="codeline" id="line-538"><code>		panic("context: internal error: missing cancel error")</code></span>
<span class="codeline" id="line-539"><code>	}</code></span>
<span class="codeline" id="line-540"><code>	if cause == nil {</code></span>
<span class="codeline" id="line-541"><code>		cause = err</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-544"><code>	if c.err != nil {</code></span>
<span class="codeline" id="line-545"><code>		c.mu.Unlock()</code></span>
<span class="codeline" id="line-546"><code>		return // already canceled</code></span>
<span class="codeline" id="line-547"><code>	}</code></span>
<span class="codeline" id="line-548"><code>	c.err = err</code></span>
<span class="codeline" id="line-549"><code>	c.cause = cause</code></span>
<span class="codeline" id="line-550"><code>	d, _ := c.done.Load().(chan struct{})</code></span>
<span class="codeline" id="line-551"><code>	if d == nil {</code></span>
<span class="codeline" id="line-552"><code>		c.done.Store(closedchan)</code></span>
<span class="codeline" id="line-553"><code>	} else {</code></span>
<span class="codeline" id="line-554"><code>		close(d)</code></span>
<span class="codeline" id="line-555"><code>	}</code></span>
<span class="codeline" id="line-556"><code>	for child := range c.children {</code></span>
<span class="codeline" id="line-557"><code>		// NOTE: acquiring the child's lock while holding parent's lock.</code></span>
<span class="codeline" id="line-558"><code>		child.cancel(false, err, cause)</code></span>
<span class="codeline" id="line-559"><code>	}</code></span>
<span class="codeline" id="line-560"><code>	c.children = nil</code></span>
<span class="codeline" id="line-561"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>	if removeFromParent {</code></span>
<span class="codeline" id="line-564"><code>		removeChild(c.Context, c)</code></span>
<span class="codeline" id="line-565"><code>	}</code></span>
<span class="codeline" id="line-566"><code>}</code></span>
<span class="codeline" id="line-567"><code></code></span>
<span class="codeline" id="line-568"><code>// WithoutCancel returns a copy of parent that is not canceled when parent is canceled.</code></span>
<span class="codeline" id="line-569"><code>// The returned context returns no Deadline or Err, and its Done channel is nil.</code></span>
<span class="codeline" id="line-570"><code>// Calling [Cause] on the returned context returns nil.</code></span>
<span class="codeline" id="line-571"><code>func WithoutCancel(parent Context) Context {</code></span>
<span class="codeline" id="line-572"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-573"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-574"><code>	}</code></span>
<span class="codeline" id="line-575"><code>	return withoutCancelCtx{parent}</code></span>
<span class="codeline" id="line-576"><code>}</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>type withoutCancelCtx struct {</code></span>
<span class="codeline" id="line-579"><code>	c Context</code></span>
<span class="codeline" id="line-580"><code>}</code></span>
<span class="codeline" id="line-581"><code></code></span>
<span class="codeline" id="line-582"><code>func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-583"><code>	return</code></span>
<span class="codeline" id="line-584"><code>}</code></span>
<span class="codeline" id="line-585"><code></code></span>
<span class="codeline" id="line-586"><code>func (withoutCancelCtx) Done() &lt;-chan struct{} {</code></span>
<span class="codeline" id="line-587"><code>	return nil</code></span>
<span class="codeline" id="line-588"><code>}</code></span>
<span class="codeline" id="line-589"><code></code></span>
<span class="codeline" id="line-590"><code>func (withoutCancelCtx) Err() error {</code></span>
<span class="codeline" id="line-591"><code>	return nil</code></span>
<span class="codeline" id="line-592"><code>}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>func (c withoutCancelCtx) Value(key any) any {</code></span>
<span class="codeline" id="line-595"><code>	return value(c, key)</code></span>
<span class="codeline" id="line-596"><code>}</code></span>
<span class="codeline" id="line-597"><code></code></span>
<span class="codeline" id="line-598"><code>func (c withoutCancelCtx) String() string {</code></span>
<span class="codeline" id="line-599"><code>	return contextName(c.c) + ".WithoutCancel"</code></span>
<span class="codeline" id="line-600"><code>}</code></span>
<span class="codeline" id="line-601"><code></code></span>
<span class="codeline" id="line-602"><code>// WithDeadline returns a copy of the parent context with the deadline adjusted</code></span>
<span class="codeline" id="line-603"><code>// to be no later than d. If the parent's deadline is already earlier than d,</code></span>
<span class="codeline" id="line-604"><code>// WithDeadline(parent, d) is semantically equivalent to parent. The returned</code></span>
<span class="codeline" id="line-605"><code>// [Context.Done] channel is closed when the deadline expires, when the returned</code></span>
<span class="codeline" id="line-606"><code>// cancel function is called, or when the parent context's Done channel is</code></span>
<span class="codeline" id="line-607"><code>// closed, whichever happens first.</code></span>
<span class="codeline" id="line-608"><code>//</code></span>
<span class="codeline" id="line-609"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-610"><code>// call cancel as soon as the operations running in this [Context] complete.</code></span>
<span class="codeline" id="line-611"><code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-612"><code>	return WithDeadlineCause(parent, d, nil)</code></span>
<span class="codeline" id="line-613"><code>}</code></span>
<span class="codeline" id="line-614"><code></code></span>
<span class="codeline" id="line-615"><code>// WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the</code></span>
<span class="codeline" id="line-616"><code>// returned Context when the deadline is exceeded. The returned [CancelFunc] does</code></span>
<span class="codeline" id="line-617"><code>// not set the cause.</code></span>
<span class="codeline" id="line-618"><code>func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-619"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-620"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-621"><code>	}</code></span>
<span class="codeline" id="line-622"><code>	if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) {</code></span>
<span class="codeline" id="line-623"><code>		// The current deadline is already sooner than the new one.</code></span>
<span class="codeline" id="line-624"><code>		return WithCancel(parent)</code></span>
<span class="codeline" id="line-625"><code>	}</code></span>
<span class="codeline" id="line-626"><code>	c := &amp;timerCtx{</code></span>
<span class="codeline" id="line-627"><code>		deadline: d,</code></span>
<span class="codeline" id="line-628"><code>	}</code></span>
<span class="codeline" id="line-629"><code>	c.cancelCtx.propagateCancel(parent, c)</code></span>
<span class="codeline" id="line-630"><code>	dur := time.Until(d)</code></span>
<span class="codeline" id="line-631"><code>	if dur &lt;= 0 {</code></span>
<span class="codeline" id="line-632"><code>		c.cancel(true, DeadlineExceeded, cause) // deadline has already passed</code></span>
<span class="codeline" id="line-633"><code>		return c, func() { c.cancel(false, Canceled, nil) }</code></span>
<span class="codeline" id="line-634"><code>	}</code></span>
<span class="codeline" id="line-635"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-636"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-637"><code>	if c.err == nil {</code></span>
<span class="codeline" id="line-638"><code>		c.timer = time.AfterFunc(dur, func() {</code></span>
<span class="codeline" id="line-639"><code>			c.cancel(true, DeadlineExceeded, cause)</code></span>
<span class="codeline" id="line-640"><code>		})</code></span>
<span class="codeline" id="line-641"><code>	}</code></span>
<span class="codeline" id="line-642"><code>	return c, func() { c.cancel(true, Canceled, nil) }</code></span>
<span class="codeline" id="line-643"><code>}</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</code></span>
<span class="codeline" id="line-646"><code>// implement Done and Err. It implements cancel by stopping its timer then</code></span>
<span class="codeline" id="line-647"><code>// delegating to cancelCtx.cancel.</code></span>
<span class="codeline" id="line-648"><code>type timerCtx struct {</code></span>
<span class="codeline" id="line-649"><code>	cancelCtx</code></span>
<span class="codeline" id="line-650"><code>	timer *time.Timer // Under cancelCtx.mu.</code></span>
<span class="codeline" id="line-651"><code></code></span>
<span class="codeline" id="line-652"><code>	deadline time.Time</code></span>
<span class="codeline" id="line-653"><code>}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {</code></span>
<span class="codeline" id="line-656"><code>	return c.deadline, true</code></span>
<span class="codeline" id="line-657"><code>}</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>func (c *timerCtx) String() string {</code></span>
<span class="codeline" id="line-660"><code>	return contextName(c.cancelCtx.Context) + ".WithDeadline(" +</code></span>
<span class="codeline" id="line-661"><code>		c.deadline.String() + " [" +</code></span>
<span class="codeline" id="line-662"><code>		time.Until(c.deadline).String() + "])"</code></span>
<span class="codeline" id="line-663"><code>}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>func (c *timerCtx) cancel(removeFromParent bool, err, cause error) {</code></span>
<span class="codeline" id="line-666"><code>	c.cancelCtx.cancel(false, err, cause)</code></span>
<span class="codeline" id="line-667"><code>	if removeFromParent {</code></span>
<span class="codeline" id="line-668"><code>		// Remove this timerCtx from its parent cancelCtx's children.</code></span>
<span class="codeline" id="line-669"><code>		removeChild(c.cancelCtx.Context, c)</code></span>
<span class="codeline" id="line-670"><code>	}</code></span>
<span class="codeline" id="line-671"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-672"><code>	if c.timer != nil {</code></span>
<span class="codeline" id="line-673"><code>		c.timer.Stop()</code></span>
<span class="codeline" id="line-674"><code>		c.timer = nil</code></span>
<span class="codeline" id="line-675"><code>	}</code></span>
<span class="codeline" id="line-676"><code>	c.mu.Unlock()</code></span>
<span class="codeline" id="line-677"><code>}</code></span>
<span class="codeline" id="line-678"><code></code></span>
<span class="codeline" id="line-679"><code>// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</code></span>
<span class="codeline" id="line-680"><code>//</code></span>
<span class="codeline" id="line-681"><code>// Canceling this context releases resources associated with it, so code should</code></span>
<span class="codeline" id="line-682"><code>// call cancel as soon as the operations running in this [Context] complete:</code></span>
<span class="codeline" id="line-683"><code>//</code></span>
<span class="codeline" id="line-684"><code>//	func slowOperationWithTimeout(ctx context.Context) (Result, error) {</code></span>
<span class="codeline" id="line-685"><code>//		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)</code></span>
<span class="codeline" id="line-686"><code>//		defer cancel()  // releases resources if slowOperation completes before timeout elapses</code></span>
<span class="codeline" id="line-687"><code>//		return slowOperation(ctx)</code></span>
<span class="codeline" id="line-688"><code>//	}</code></span>
<span class="codeline" id="line-689"><code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-690"><code>	return WithDeadline(parent, time.Now().Add(timeout))</code></span>
<span class="codeline" id="line-691"><code>}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>// WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the</code></span>
<span class="codeline" id="line-694"><code>// returned Context when the timeout expires. The returned [CancelFunc] does</code></span>
<span class="codeline" id="line-695"><code>// not set the cause.</code></span>
<span class="codeline" id="line-696"><code>func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc) {</code></span>
<span class="codeline" id="line-697"><code>	return WithDeadlineCause(parent, time.Now().Add(timeout), cause)</code></span>
<span class="codeline" id="line-698"><code>}</code></span>
<span class="codeline" id="line-699"><code></code></span>
<span class="codeline" id="line-700"><code>// WithValue returns a copy of parent in which the value associated with key is</code></span>
<span class="codeline" id="line-701"><code>// val.</code></span>
<span class="codeline" id="line-702"><code>//</code></span>
<span class="codeline" id="line-703"><code>// Use context Values only for request-scoped data that transits processes and</code></span>
<span class="codeline" id="line-704"><code>// APIs, not for passing optional parameters to functions.</code></span>
<span class="codeline" id="line-705"><code>//</code></span>
<span class="codeline" id="line-706"><code>// The provided key must be comparable and should not be of type</code></span>
<span class="codeline" id="line-707"><code>// string or any other built-in type to avoid collisions between</code></span>
<span class="codeline" id="line-708"><code>// packages using context. Users of WithValue should define their own</code></span>
<span class="codeline" id="line-709"><code>// types for keys. To avoid allocating when assigning to an</code></span>
<span class="codeline" id="line-710"><code>// interface{}, context keys often have concrete type</code></span>
<span class="codeline" id="line-711"><code>// struct{}. Alternatively, exported context key variables' static</code></span>
<span class="codeline" id="line-712"><code>// type should be a pointer or interface.</code></span>
<span class="codeline" id="line-713"><code>func WithValue(parent Context, key, val any) Context {</code></span>
<span class="codeline" id="line-714"><code>	if parent == nil {</code></span>
<span class="codeline" id="line-715"><code>		panic("cannot create context from nil parent")</code></span>
<span class="codeline" id="line-716"><code>	}</code></span>
<span class="codeline" id="line-717"><code>	if key == nil {</code></span>
<span class="codeline" id="line-718"><code>		panic("nil key")</code></span>
<span class="codeline" id="line-719"><code>	}</code></span>
<span class="codeline" id="line-720"><code>	if !reflectlite.TypeOf(key).Comparable() {</code></span>
<span class="codeline" id="line-721"><code>		panic("key is not comparable")</code></span>
<span class="codeline" id="line-722"><code>	}</code></span>
<span class="codeline" id="line-723"><code>	return &amp;valueCtx{parent, key, val}</code></span>
<span class="codeline" id="line-724"><code>}</code></span>
<span class="codeline" id="line-725"><code></code></span>
<span class="codeline" id="line-726"><code>// A valueCtx carries a key-value pair. It implements Value for that key and</code></span>
<span class="codeline" id="line-727"><code>// delegates all other calls to the embedded Context.</code></span>
<span class="codeline" id="line-728"><code>type valueCtx struct {</code></span>
<span class="codeline" id="line-729"><code>	Context</code></span>
<span class="codeline" id="line-730"><code>	key, val any</code></span>
<span class="codeline" id="line-731"><code>}</code></span>
<span class="codeline" id="line-732"><code></code></span>
<span class="codeline" id="line-733"><code>// stringify tries a bit to stringify v, without using fmt, since we don't</code></span>
<span class="codeline" id="line-734"><code>// want context depending on the unicode tables. This is only used by</code></span>
<span class="codeline" id="line-735"><code>// *valueCtx.String().</code></span>
<span class="codeline" id="line-736"><code>func stringify(v any) string {</code></span>
<span class="codeline" id="line-737"><code>	switch s := v.(type) {</code></span>
<span class="codeline" id="line-738"><code>	case stringer:</code></span>
<span class="codeline" id="line-739"><code>		return s.String()</code></span>
<span class="codeline" id="line-740"><code>	case string:</code></span>
<span class="codeline" id="line-741"><code>		return s</code></span>
<span class="codeline" id="line-742"><code>	}</code></span>
<span class="codeline" id="line-743"><code>	return "&lt;not Stringer&gt;"</code></span>
<span class="codeline" id="line-744"><code>}</code></span>
<span class="codeline" id="line-745"><code></code></span>
<span class="codeline" id="line-746"><code>func (c *valueCtx) String() string {</code></span>
<span class="codeline" id="line-747"><code>	return contextName(c.Context) + ".WithValue(type " +</code></span>
<span class="codeline" id="line-748"><code>		reflectlite.TypeOf(c.key).String() +</code></span>
<span class="codeline" id="line-749"><code>		", val " + stringify(c.val) + ")"</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>func (c *valueCtx) Value(key any) any {</code></span>
<span class="codeline" id="line-753"><code>	if c.key == key {</code></span>
<span class="codeline" id="line-754"><code>		return c.val</code></span>
<span class="codeline" id="line-755"><code>	}</code></span>
<span class="codeline" id="line-756"><code>	return value(c.Context, key)</code></span>
<span class="codeline" id="line-757"><code>}</code></span>
<span class="codeline" id="line-758"><code></code></span>
<span class="codeline" id="line-759"><code>func value(c Context, key any) any {</code></span>
<span class="codeline" id="line-760"><code>	for {</code></span>
<span class="codeline" id="line-761"><code>		switch ctx := c.(type) {</code></span>
<span class="codeline" id="line-762"><code>		case *valueCtx:</code></span>
<span class="codeline" id="line-763"><code>			if key == ctx.key {</code></span>
<span class="codeline" id="line-764"><code>				return ctx.val</code></span>
<span class="codeline" id="line-765"><code>			}</code></span>
<span class="codeline" id="line-766"><code>			c = ctx.Context</code></span>
<span class="codeline" id="line-767"><code>		case *cancelCtx:</code></span>
<span class="codeline" id="line-768"><code>			if key == &amp;cancelCtxKey {</code></span>
<span class="codeline" id="line-769"><code>				return c</code></span>
<span class="codeline" id="line-770"><code>			}</code></span>
<span class="codeline" id="line-771"><code>			c = ctx.Context</code></span>
<span class="codeline" id="line-772"><code>		case withoutCancelCtx:</code></span>
<span class="codeline" id="line-773"><code>			if key == &amp;cancelCtxKey {</code></span>
<span class="codeline" id="line-774"><code>				// This implements Cause(ctx) == nil</code></span>
<span class="codeline" id="line-775"><code>				// when ctx is created using WithoutCancel.</code></span>
<span class="codeline" id="line-776"><code>				return nil</code></span>
<span class="codeline" id="line-777"><code>			}</code></span>
<span class="codeline" id="line-778"><code>			c = ctx.c</code></span>
<span class="codeline" id="line-779"><code>		case *timerCtx:</code></span>
<span class="codeline" id="line-780"><code>			if key == &amp;cancelCtxKey {</code></span>
<span class="codeline" id="line-781"><code>				return &amp;ctx.cancelCtx</code></span>
<span class="codeline" id="line-782"><code>			}</code></span>
<span class="codeline" id="line-783"><code>			c = ctx.Context</code></span>
<span class="codeline" id="line-784"><code>		case backgroundCtx, todoCtx:</code></span>
<span class="codeline" id="line-785"><code>			return nil</code></span>
<span class="codeline" id="line-786"><code>		default:</code></span>
<span class="codeline" id="line-787"><code>			return c.Value(key)</code></span>
<span class="codeline" id="line-788"><code>		}</code></span>
<span class="codeline" id="line-789"><code>	}</code></span>
<span class="codeline" id="line-790"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>