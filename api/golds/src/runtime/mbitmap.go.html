<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: mbitmap.go in package runtime</title>
<link href="../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	mbitmap.go

<span class="title">Belonging Package</span>
	<a href="../../pkg/runtime.html">runtime</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package runtime</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"internal/goarch"</code></span>
<span class="codeline" id="line-9"><code>	"runtime/internal/atomic"</code></span>
<span class="codeline" id="line-10"><code>	"runtime/internal/sys"</code></span>
<span class="codeline" id="line-11"><code>	"unsafe"</code></span>
<span class="codeline" id="line-12"><code>)</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code>// addb returns the byte pointer p+n.</code></span>
<span class="codeline" id="line-15"><code>//</code></span>
<span class="codeline" id="line-16"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-17"><code>//go:nosplit</code></span>
<span class="codeline" id="line-18"><code>func addb(p *byte, n uintptr) *byte {</code></span>
<span class="codeline" id="line-19"><code>	// Note: wrote out full expression instead of calling add(p, n)</code></span>
<span class="codeline" id="line-20"><code>	// to reduce the number of temporaries generated by the</code></span>
<span class="codeline" id="line-21"><code>	// compiler for this trivial expression during inlining.</code></span>
<span class="codeline" id="line-22"><code>	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + n))</code></span>
<span class="codeline" id="line-23"><code>}</code></span>
<span class="codeline" id="line-24"><code></code></span>
<span class="codeline" id="line-25"><code>// subtractb returns the byte pointer p-n.</code></span>
<span class="codeline" id="line-26"><code>//</code></span>
<span class="codeline" id="line-27"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-28"><code>//go:nosplit</code></span>
<span class="codeline" id="line-29"><code>func subtractb(p *byte, n uintptr) *byte {</code></span>
<span class="codeline" id="line-30"><code>	// Note: wrote out full expression instead of calling add(p, -n)</code></span>
<span class="codeline" id="line-31"><code>	// to reduce the number of temporaries generated by the</code></span>
<span class="codeline" id="line-32"><code>	// compiler for this trivial expression during inlining.</code></span>
<span class="codeline" id="line-33"><code>	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - n))</code></span>
<span class="codeline" id="line-34"><code>}</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// add1 returns the byte pointer p+1.</code></span>
<span class="codeline" id="line-37"><code>//</code></span>
<span class="codeline" id="line-38"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-39"><code>//go:nosplit</code></span>
<span class="codeline" id="line-40"><code>func add1(p *byte) *byte {</code></span>
<span class="codeline" id="line-41"><code>	// Note: wrote out full expression instead of calling addb(p, 1)</code></span>
<span class="codeline" id="line-42"><code>	// to reduce the number of temporaries generated by the</code></span>
<span class="codeline" id="line-43"><code>	// compiler for this trivial expression during inlining.</code></span>
<span class="codeline" id="line-44"><code>	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1))</code></span>
<span class="codeline" id="line-45"><code>}</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code>// subtract1 returns the byte pointer p-1.</code></span>
<span class="codeline" id="line-48"><code>//</code></span>
<span class="codeline" id="line-49"><code>// nosplit because it is used during write barriers and must not be preempted.</code></span>
<span class="codeline" id="line-50"><code>//</code></span>
<span class="codeline" id="line-51"><code>//go:nowritebarrier</code></span>
<span class="codeline" id="line-52"><code>//go:nosplit</code></span>
<span class="codeline" id="line-53"><code>func subtract1(p *byte) *byte {</code></span>
<span class="codeline" id="line-54"><code>	// Note: wrote out full expression instead of calling subtractb(p, 1)</code></span>
<span class="codeline" id="line-55"><code>	// to reduce the number of temporaries generated by the</code></span>
<span class="codeline" id="line-56"><code>	// compiler for this trivial expression during inlining.</code></span>
<span class="codeline" id="line-57"><code>	return (*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - 1))</code></span>
<span class="codeline" id="line-58"><code>}</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>// markBits provides access to the mark bit for an object in the heap.</code></span>
<span class="codeline" id="line-61"><code>// bytep points to the byte holding the mark bit.</code></span>
<span class="codeline" id="line-62"><code>// mask is a byte with a single bit set that can be &amp;ed with *bytep</code></span>
<span class="codeline" id="line-63"><code>// to see if the bit has been set.</code></span>
<span class="codeline" id="line-64"><code>// *m.byte&amp;m.mask != 0 indicates the mark bit is set.</code></span>
<span class="codeline" id="line-65"><code>// index can be used along with span information to generate</code></span>
<span class="codeline" id="line-66"><code>// the address of the object in the heap.</code></span>
<span class="codeline" id="line-67"><code>// We maintain one set of mark bits for allocation and one for</code></span>
<span class="codeline" id="line-68"><code>// marking purposes.</code></span>
<span class="codeline" id="line-69"><code>type markBits struct {</code></span>
<span class="codeline" id="line-70"><code>	bytep *uint8</code></span>
<span class="codeline" id="line-71"><code>	mask  uint8</code></span>
<span class="codeline" id="line-72"><code>	index uintptr</code></span>
<span class="codeline" id="line-73"><code>}</code></span>
<span class="codeline" id="line-74"><code></code></span>
<span class="codeline" id="line-75"><code>//go:nosplit</code></span>
<span class="codeline" id="line-76"><code>func (s *mspan) allocBitsForIndex(allocBitIndex uintptr) markBits {</code></span>
<span class="codeline" id="line-77"><code>	bytep, mask := s.allocBits.bitp(allocBitIndex)</code></span>
<span class="codeline" id="line-78"><code>	return markBits{bytep, mask, allocBitIndex}</code></span>
<span class="codeline" id="line-79"><code>}</code></span>
<span class="codeline" id="line-80"><code></code></span>
<span class="codeline" id="line-81"><code>// refillAllocCache takes 8 bytes s.allocBits starting at whichByte</code></span>
<span class="codeline" id="line-82"><code>// and negates them so that ctz (count trailing zeros) instructions</code></span>
<span class="codeline" id="line-83"><code>// can be used. It then places these 8 bytes into the cached 64 bit</code></span>
<span class="codeline" id="line-84"><code>// s.allocCache.</code></span>
<span class="codeline" id="line-85"><code>func (s *mspan) refillAllocCache(whichByte uint16) {</code></span>
<span class="codeline" id="line-86"><code>	bytes := (*[8]uint8)(unsafe.Pointer(s.allocBits.bytep(uintptr(whichByte))))</code></span>
<span class="codeline" id="line-87"><code>	aCache := uint64(0)</code></span>
<span class="codeline" id="line-88"><code>	aCache |= uint64(bytes[0])</code></span>
<span class="codeline" id="line-89"><code>	aCache |= uint64(bytes[1]) &lt;&lt; (1 * 8)</code></span>
<span class="codeline" id="line-90"><code>	aCache |= uint64(bytes[2]) &lt;&lt; (2 * 8)</code></span>
<span class="codeline" id="line-91"><code>	aCache |= uint64(bytes[3]) &lt;&lt; (3 * 8)</code></span>
<span class="codeline" id="line-92"><code>	aCache |= uint64(bytes[4]) &lt;&lt; (4 * 8)</code></span>
<span class="codeline" id="line-93"><code>	aCache |= uint64(bytes[5]) &lt;&lt; (5 * 8)</code></span>
<span class="codeline" id="line-94"><code>	aCache |= uint64(bytes[6]) &lt;&lt; (6 * 8)</code></span>
<span class="codeline" id="line-95"><code>	aCache |= uint64(bytes[7]) &lt;&lt; (7 * 8)</code></span>
<span class="codeline" id="line-96"><code>	s.allocCache = ^aCache</code></span>
<span class="codeline" id="line-97"><code>}</code></span>
<span class="codeline" id="line-98"><code></code></span>
<span class="codeline" id="line-99"><code>// nextFreeIndex returns the index of the next free object in s at</code></span>
<span class="codeline" id="line-100"><code>// or after s.freeindex.</code></span>
<span class="codeline" id="line-101"><code>// There are hardware instructions that can be used to make this</code></span>
<span class="codeline" id="line-102"><code>// faster if profiling warrants it.</code></span>
<span class="codeline" id="line-103"><code>func (s *mspan) nextFreeIndex() uint16 {</code></span>
<span class="codeline" id="line-104"><code>	sfreeindex := s.freeindex</code></span>
<span class="codeline" id="line-105"><code>	snelems := s.nelems</code></span>
<span class="codeline" id="line-106"><code>	if sfreeindex == snelems {</code></span>
<span class="codeline" id="line-107"><code>		return sfreeindex</code></span>
<span class="codeline" id="line-108"><code>	}</code></span>
<span class="codeline" id="line-109"><code>	if sfreeindex &gt; snelems {</code></span>
<span class="codeline" id="line-110"><code>		throw("s.freeindex &gt; s.nelems")</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>	aCache := s.allocCache</code></span>
<span class="codeline" id="line-114"><code></code></span>
<span class="codeline" id="line-115"><code>	bitIndex := sys.TrailingZeros64(aCache)</code></span>
<span class="codeline" id="line-116"><code>	for bitIndex == 64 {</code></span>
<span class="codeline" id="line-117"><code>		// Move index to start of next cached bits.</code></span>
<span class="codeline" id="line-118"><code>		sfreeindex = (sfreeindex + 64) &amp;^ (64 - 1)</code></span>
<span class="codeline" id="line-119"><code>		if sfreeindex &gt;= snelems {</code></span>
<span class="codeline" id="line-120"><code>			s.freeindex = snelems</code></span>
<span class="codeline" id="line-121"><code>			return snelems</code></span>
<span class="codeline" id="line-122"><code>		}</code></span>
<span class="codeline" id="line-123"><code>		whichByte := sfreeindex / 8</code></span>
<span class="codeline" id="line-124"><code>		// Refill s.allocCache with the next 64 alloc bits.</code></span>
<span class="codeline" id="line-125"><code>		s.refillAllocCache(whichByte)</code></span>
<span class="codeline" id="line-126"><code>		aCache = s.allocCache</code></span>
<span class="codeline" id="line-127"><code>		bitIndex = sys.TrailingZeros64(aCache)</code></span>
<span class="codeline" id="line-128"><code>		// nothing available in cached bits</code></span>
<span class="codeline" id="line-129"><code>		// grab the next 8 bytes and try again.</code></span>
<span class="codeline" id="line-130"><code>	}</code></span>
<span class="codeline" id="line-131"><code>	result := sfreeindex + uint16(bitIndex)</code></span>
<span class="codeline" id="line-132"><code>	if result &gt;= snelems {</code></span>
<span class="codeline" id="line-133"><code>		s.freeindex = snelems</code></span>
<span class="codeline" id="line-134"><code>		return snelems</code></span>
<span class="codeline" id="line-135"><code>	}</code></span>
<span class="codeline" id="line-136"><code></code></span>
<span class="codeline" id="line-137"><code>	s.allocCache &gt;&gt;= uint(bitIndex + 1)</code></span>
<span class="codeline" id="line-138"><code>	sfreeindex = result + 1</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	if sfreeindex%64 == 0 &amp;&amp; sfreeindex != snelems {</code></span>
<span class="codeline" id="line-141"><code>		// We just incremented s.freeindex so it isn't 0.</code></span>
<span class="codeline" id="line-142"><code>		// As each 1 in s.allocCache was encountered and used for allocation</code></span>
<span class="codeline" id="line-143"><code>		// it was shifted away. At this point s.allocCache contains all 0s.</code></span>
<span class="codeline" id="line-144"><code>		// Refill s.allocCache so that it corresponds</code></span>
<span class="codeline" id="line-145"><code>		// to the bits at s.allocBits starting at s.freeindex.</code></span>
<span class="codeline" id="line-146"><code>		whichByte := sfreeindex / 8</code></span>
<span class="codeline" id="line-147"><code>		s.refillAllocCache(whichByte)</code></span>
<span class="codeline" id="line-148"><code>	}</code></span>
<span class="codeline" id="line-149"><code>	s.freeindex = sfreeindex</code></span>
<span class="codeline" id="line-150"><code>	return result</code></span>
<span class="codeline" id="line-151"><code>}</code></span>
<span class="codeline" id="line-152"><code></code></span>
<span class="codeline" id="line-153"><code>// isFree reports whether the index'th object in s is unallocated.</code></span>
<span class="codeline" id="line-154"><code>//</code></span>
<span class="codeline" id="line-155"><code>// The caller must ensure s.state is mSpanInUse, and there must have</code></span>
<span class="codeline" id="line-156"><code>// been no preemption points since ensuring this (which could allow a</code></span>
<span class="codeline" id="line-157"><code>// GC transition, which would allow the state to change).</code></span>
<span class="codeline" id="line-158"><code>func (s *mspan) isFree(index uintptr) bool {</code></span>
<span class="codeline" id="line-159"><code>	if index &lt; uintptr(s.freeIndexForScan) {</code></span>
<span class="codeline" id="line-160"><code>		return false</code></span>
<span class="codeline" id="line-161"><code>	}</code></span>
<span class="codeline" id="line-162"><code>	bytep, mask := s.allocBits.bitp(index)</code></span>
<span class="codeline" id="line-163"><code>	return *bytep&amp;mask == 0</code></span>
<span class="codeline" id="line-164"><code>}</code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>// divideByElemSize returns n/s.elemsize.</code></span>
<span class="codeline" id="line-167"><code>// n must be within [0, s.npages*_PageSize),</code></span>
<span class="codeline" id="line-168"><code>// or may be exactly s.npages*_PageSize</code></span>
<span class="codeline" id="line-169"><code>// if s.elemsize is from sizeclasses.go.</code></span>
<span class="codeline" id="line-170"><code>//</code></span>
<span class="codeline" id="line-171"><code>// nosplit, because it is called by objIndex, which is nosplit</code></span>
<span class="codeline" id="line-172"><code>//</code></span>
<span class="codeline" id="line-173"><code>//go:nosplit</code></span>
<span class="codeline" id="line-174"><code>func (s *mspan) divideByElemSize(n uintptr) uintptr {</code></span>
<span class="codeline" id="line-175"><code>	const doubleCheck = false</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>	// See explanation in mksizeclasses.go's computeDivMagic.</code></span>
<span class="codeline" id="line-178"><code>	q := uintptr((uint64(n) * uint64(s.divMul)) &gt;&gt; 32)</code></span>
<span class="codeline" id="line-179"><code></code></span>
<span class="codeline" id="line-180"><code>	if doubleCheck &amp;&amp; q != n/s.elemsize {</code></span>
<span class="codeline" id="line-181"><code>		println(n, "/", s.elemsize, "should be", n/s.elemsize, "but got", q)</code></span>
<span class="codeline" id="line-182"><code>		throw("bad magic division")</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code>	return q</code></span>
<span class="codeline" id="line-185"><code>}</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>// nosplit, because it is called by other nosplit code like findObject</code></span>
<span class="codeline" id="line-188"><code>//</code></span>
<span class="codeline" id="line-189"><code>//go:nosplit</code></span>
<span class="codeline" id="line-190"><code>func (s *mspan) objIndex(p uintptr) uintptr {</code></span>
<span class="codeline" id="line-191"><code>	return s.divideByElemSize(p - s.base())</code></span>
<span class="codeline" id="line-192"><code>}</code></span>
<span class="codeline" id="line-193"><code></code></span>
<span class="codeline" id="line-194"><code>func markBitsForAddr(p uintptr) markBits {</code></span>
<span class="codeline" id="line-195"><code>	s := spanOf(p)</code></span>
<span class="codeline" id="line-196"><code>	objIndex := s.objIndex(p)</code></span>
<span class="codeline" id="line-197"><code>	return s.markBitsForIndex(objIndex)</code></span>
<span class="codeline" id="line-198"><code>}</code></span>
<span class="codeline" id="line-199"><code></code></span>
<span class="codeline" id="line-200"><code>func (s *mspan) markBitsForIndex(objIndex uintptr) markBits {</code></span>
<span class="codeline" id="line-201"><code>	bytep, mask := s.gcmarkBits.bitp(objIndex)</code></span>
<span class="codeline" id="line-202"><code>	return markBits{bytep, mask, objIndex}</code></span>
<span class="codeline" id="line-203"><code>}</code></span>
<span class="codeline" id="line-204"><code></code></span>
<span class="codeline" id="line-205"><code>func (s *mspan) markBitsForBase() markBits {</code></span>
<span class="codeline" id="line-206"><code>	return markBits{&amp;s.gcmarkBits.x, uint8(1), 0}</code></span>
<span class="codeline" id="line-207"><code>}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>// isMarked reports whether mark bit m is set.</code></span>
<span class="codeline" id="line-210"><code>func (m markBits) isMarked() bool {</code></span>
<span class="codeline" id="line-211"><code>	return *m.bytep&amp;m.mask != 0</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>// setMarked sets the marked bit in the markbits, atomically.</code></span>
<span class="codeline" id="line-215"><code>func (m markBits) setMarked() {</code></span>
<span class="codeline" id="line-216"><code>	// Might be racing with other updates, so use atomic update always.</code></span>
<span class="codeline" id="line-217"><code>	// We used to be clever here and use a non-atomic update in certain</code></span>
<span class="codeline" id="line-218"><code>	// cases, but it's not worth the risk.</code></span>
<span class="codeline" id="line-219"><code>	atomic.Or8(m.bytep, m.mask)</code></span>
<span class="codeline" id="line-220"><code>}</code></span>
<span class="codeline" id="line-221"><code></code></span>
<span class="codeline" id="line-222"><code>// setMarkedNonAtomic sets the marked bit in the markbits, non-atomically.</code></span>
<span class="codeline" id="line-223"><code>func (m markBits) setMarkedNonAtomic() {</code></span>
<span class="codeline" id="line-224"><code>	*m.bytep |= m.mask</code></span>
<span class="codeline" id="line-225"><code>}</code></span>
<span class="codeline" id="line-226"><code></code></span>
<span class="codeline" id="line-227"><code>// clearMarked clears the marked bit in the markbits, atomically.</code></span>
<span class="codeline" id="line-228"><code>func (m markBits) clearMarked() {</code></span>
<span class="codeline" id="line-229"><code>	// Might be racing with other updates, so use atomic update always.</code></span>
<span class="codeline" id="line-230"><code>	// We used to be clever here and use a non-atomic update in certain</code></span>
<span class="codeline" id="line-231"><code>	// cases, but it's not worth the risk.</code></span>
<span class="codeline" id="line-232"><code>	atomic.And8(m.bytep, ^m.mask)</code></span>
<span class="codeline" id="line-233"><code>}</code></span>
<span class="codeline" id="line-234"><code></code></span>
<span class="codeline" id="line-235"><code>// markBitsForSpan returns the markBits for the span base address base.</code></span>
<span class="codeline" id="line-236"><code>func markBitsForSpan(base uintptr) (mbits markBits) {</code></span>
<span class="codeline" id="line-237"><code>	mbits = markBitsForAddr(base)</code></span>
<span class="codeline" id="line-238"><code>	if mbits.mask != 1 {</code></span>
<span class="codeline" id="line-239"><code>		throw("markBitsForSpan: unaligned start")</code></span>
<span class="codeline" id="line-240"><code>	}</code></span>
<span class="codeline" id="line-241"><code>	return mbits</code></span>
<span class="codeline" id="line-242"><code>}</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>// advance advances the markBits to the next object in the span.</code></span>
<span class="codeline" id="line-245"><code>func (m *markBits) advance() {</code></span>
<span class="codeline" id="line-246"><code>	if m.mask == 1&lt;&lt;7 {</code></span>
<span class="codeline" id="line-247"><code>		m.bytep = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.bytep)) + 1))</code></span>
<span class="codeline" id="line-248"><code>		m.mask = 1</code></span>
<span class="codeline" id="line-249"><code>	} else {</code></span>
<span class="codeline" id="line-250"><code>		m.mask = m.mask &lt;&lt; 1</code></span>
<span class="codeline" id="line-251"><code>	}</code></span>
<span class="codeline" id="line-252"><code>	m.index++</code></span>
<span class="codeline" id="line-253"><code>}</code></span>
<span class="codeline" id="line-254"><code></code></span>
<span class="codeline" id="line-255"><code>// clobberdeadPtr is a special value that is used by the compiler to</code></span>
<span class="codeline" id="line-256"><code>// clobber dead stack slots, when -clobberdead flag is set.</code></span>
<span class="codeline" id="line-257"><code>const clobberdeadPtr = uintptr(0xdeaddead | 0xdeaddead&lt;&lt;((^uintptr(0)&gt;&gt;63)*32))</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>// badPointer throws bad pointer in heap panic.</code></span>
<span class="codeline" id="line-260"><code>func badPointer(s *mspan, p, refBase, refOff uintptr) {</code></span>
<span class="codeline" id="line-261"><code>	// Typically this indicates an incorrect use</code></span>
<span class="codeline" id="line-262"><code>	// of unsafe or cgo to store a bad pointer in</code></span>
<span class="codeline" id="line-263"><code>	// the Go heap. It may also indicate a runtime</code></span>
<span class="codeline" id="line-264"><code>	// bug.</code></span>
<span class="codeline" id="line-265"><code>	//</code></span>
<span class="codeline" id="line-266"><code>	// TODO(austin): We could be more aggressive</code></span>
<span class="codeline" id="line-267"><code>	// and detect pointers to unallocated objects</code></span>
<span class="codeline" id="line-268"><code>	// in allocated spans.</code></span>
<span class="codeline" id="line-269"><code>	printlock()</code></span>
<span class="codeline" id="line-270"><code>	print("runtime: pointer ", hex(p))</code></span>
<span class="codeline" id="line-271"><code>	if s != nil {</code></span>
<span class="codeline" id="line-272"><code>		state := s.state.get()</code></span>
<span class="codeline" id="line-273"><code>		if state != mSpanInUse {</code></span>
<span class="codeline" id="line-274"><code>			print(" to unallocated span")</code></span>
<span class="codeline" id="line-275"><code>		} else {</code></span>
<span class="codeline" id="line-276"><code>			print(" to unused region of span")</code></span>
<span class="codeline" id="line-277"><code>		}</code></span>
<span class="codeline" id="line-278"><code>		print(" span.base()=", hex(s.base()), " span.limit=", hex(s.limit), " span.state=", state)</code></span>
<span class="codeline" id="line-279"><code>	}</code></span>
<span class="codeline" id="line-280"><code>	print("\n")</code></span>
<span class="codeline" id="line-281"><code>	if refBase != 0 {</code></span>
<span class="codeline" id="line-282"><code>		print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n")</code></span>
<span class="codeline" id="line-283"><code>		gcDumpObject("object", refBase, refOff)</code></span>
<span class="codeline" id="line-284"><code>	}</code></span>
<span class="codeline" id="line-285"><code>	getg().m.traceback = 2</code></span>
<span class="codeline" id="line-286"><code>	throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)")</code></span>
<span class="codeline" id="line-287"><code>}</code></span>
<span class="codeline" id="line-288"><code></code></span>
<span class="codeline" id="line-289"><code>// findObject returns the base address for the heap object containing</code></span>
<span class="codeline" id="line-290"><code>// the address p, the object's span, and the index of the object in s.</code></span>
<span class="codeline" id="line-291"><code>// If p does not point into a heap object, it returns base == 0.</code></span>
<span class="codeline" id="line-292"><code>//</code></span>
<span class="codeline" id="line-293"><code>// If p points is an invalid heap pointer and debug.invalidptr != 0,</code></span>
<span class="codeline" id="line-294"><code>// findObject panics.</code></span>
<span class="codeline" id="line-295"><code>//</code></span>
<span class="codeline" id="line-296"><code>// refBase and refOff optionally give the base address of the object</code></span>
<span class="codeline" id="line-297"><code>// in which the pointer p was found and the byte offset at which it</code></span>
<span class="codeline" id="line-298"><code>// was found. These are used for error reporting.</code></span>
<span class="codeline" id="line-299"><code>//</code></span>
<span class="codeline" id="line-300"><code>// It is nosplit so it is safe for p to be a pointer to the current goroutine's stack.</code></span>
<span class="codeline" id="line-301"><code>// Since p is a uintptr, it would not be adjusted if the stack were to move.</code></span>
<span class="codeline" id="line-302"><code>//</code></span>
<span class="codeline" id="line-303"><code>//go:nosplit</code></span>
<span class="codeline" id="line-304"><code>func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr) {</code></span>
<span class="codeline" id="line-305"><code>	s = spanOf(p)</code></span>
<span class="codeline" id="line-306"><code>	// If s is nil, the virtual address has never been part of the heap.</code></span>
<span class="codeline" id="line-307"><code>	// This pointer may be to some mmap'd region, so we allow it.</code></span>
<span class="codeline" id="line-308"><code>	if s == nil {</code></span>
<span class="codeline" id="line-309"><code>		if (GOARCH == "amd64" || GOARCH == "arm64") &amp;&amp; p == clobberdeadPtr &amp;&amp; debug.invalidptr != 0 {</code></span>
<span class="codeline" id="line-310"><code>			// Crash if clobberdeadPtr is seen. Only on AMD64 and ARM64 for now,</code></span>
<span class="codeline" id="line-311"><code>			// as they are the only platform where compiler's clobberdead mode is</code></span>
<span class="codeline" id="line-312"><code>			// implemented. On these platforms clobberdeadPtr cannot be a valid address.</code></span>
<span class="codeline" id="line-313"><code>			badPointer(s, p, refBase, refOff)</code></span>
<span class="codeline" id="line-314"><code>		}</code></span>
<span class="codeline" id="line-315"><code>		return</code></span>
<span class="codeline" id="line-316"><code>	}</code></span>
<span class="codeline" id="line-317"><code>	// If p is a bad pointer, it may not be in s's bounds.</code></span>
<span class="codeline" id="line-318"><code>	//</code></span>
<span class="codeline" id="line-319"><code>	// Check s.state to synchronize with span initialization</code></span>
<span class="codeline" id="line-320"><code>	// before checking other fields. See also spanOfHeap.</code></span>
<span class="codeline" id="line-321"><code>	if state := s.state.get(); state != mSpanInUse || p &lt; s.base() || p &gt;= s.limit {</code></span>
<span class="codeline" id="line-322"><code>		// Pointers into stacks are also ok, the runtime manages these explicitly.</code></span>
<span class="codeline" id="line-323"><code>		if state == mSpanManual {</code></span>
<span class="codeline" id="line-324"><code>			return</code></span>
<span class="codeline" id="line-325"><code>		}</code></span>
<span class="codeline" id="line-326"><code>		// The following ensures that we are rigorous about what data</code></span>
<span class="codeline" id="line-327"><code>		// structures hold valid pointers.</code></span>
<span class="codeline" id="line-328"><code>		if debug.invalidptr != 0 {</code></span>
<span class="codeline" id="line-329"><code>			badPointer(s, p, refBase, refOff)</code></span>
<span class="codeline" id="line-330"><code>		}</code></span>
<span class="codeline" id="line-331"><code>		return</code></span>
<span class="codeline" id="line-332"><code>	}</code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>	objIndex = s.objIndex(p)</code></span>
<span class="codeline" id="line-335"><code>	base = s.base() + objIndex*s.elemsize</code></span>
<span class="codeline" id="line-336"><code>	return</code></span>
<span class="codeline" id="line-337"><code>}</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// reflect_verifyNotInHeapPtr reports whether converting the not-in-heap pointer into a unsafe.Pointer is ok.</code></span>
<span class="codeline" id="line-340"><code>//</code></span>
<span class="codeline" id="line-341"><code>//go:linkname reflect_verifyNotInHeapPtr reflect.verifyNotInHeapPtr</code></span>
<span class="codeline" id="line-342"><code>func reflect_verifyNotInHeapPtr(p uintptr) bool {</code></span>
<span class="codeline" id="line-343"><code>	// Conversion to a pointer is ok as long as findObject above does not call badPointer.</code></span>
<span class="codeline" id="line-344"><code>	// Since we're already promised that p doesn't point into the heap, just disallow heap</code></span>
<span class="codeline" id="line-345"><code>	// pointers and the special clobbered pointer.</code></span>
<span class="codeline" id="line-346"><code>	return spanOf(p) == nil &amp;&amp; p != clobberdeadPtr</code></span>
<span class="codeline" id="line-347"><code>}</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>const ptrBits = 8 * goarch.PtrSize</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>// bulkBarrierBitmap executes write barriers for copying from [src,</code></span>
<span class="codeline" id="line-352"><code>// src+size) to [dst, dst+size) using a 1-bit pointer bitmap. src is</code></span>
<span class="codeline" id="line-353"><code>// assumed to start maskOffset bytes into the data covered by the</code></span>
<span class="codeline" id="line-354"><code>// bitmap in bits (which may not be a multiple of 8).</code></span>
<span class="codeline" id="line-355"><code>//</code></span>
<span class="codeline" id="line-356"><code>// This is used by bulkBarrierPreWrite for writes to data and BSS.</code></span>
<span class="codeline" id="line-357"><code>//</code></span>
<span class="codeline" id="line-358"><code>//go:nosplit</code></span>
<span class="codeline" id="line-359"><code>func bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8) {</code></span>
<span class="codeline" id="line-360"><code>	word := maskOffset / goarch.PtrSize</code></span>
<span class="codeline" id="line-361"><code>	bits = addb(bits, word/8)</code></span>
<span class="codeline" id="line-362"><code>	mask := uint8(1) &lt;&lt; (word % 8)</code></span>
<span class="codeline" id="line-363"><code></code></span>
<span class="codeline" id="line-364"><code>	buf := &amp;getg().m.p.ptr().wbBuf</code></span>
<span class="codeline" id="line-365"><code>	for i := uintptr(0); i &lt; size; i += goarch.PtrSize {</code></span>
<span class="codeline" id="line-366"><code>		if mask == 0 {</code></span>
<span class="codeline" id="line-367"><code>			bits = addb(bits, 1)</code></span>
<span class="codeline" id="line-368"><code>			if *bits == 0 {</code></span>
<span class="codeline" id="line-369"><code>				// Skip 8 words.</code></span>
<span class="codeline" id="line-370"><code>				i += 7 * goarch.PtrSize</code></span>
<span class="codeline" id="line-371"><code>				continue</code></span>
<span class="codeline" id="line-372"><code>			}</code></span>
<span class="codeline" id="line-373"><code>			mask = 1</code></span>
<span class="codeline" id="line-374"><code>		}</code></span>
<span class="codeline" id="line-375"><code>		if *bits&amp;mask != 0 {</code></span>
<span class="codeline" id="line-376"><code>			dstx := (*uintptr)(unsafe.Pointer(dst + i))</code></span>
<span class="codeline" id="line-377"><code>			if src == 0 {</code></span>
<span class="codeline" id="line-378"><code>				p := buf.get1()</code></span>
<span class="codeline" id="line-379"><code>				p[0] = *dstx</code></span>
<span class="codeline" id="line-380"><code>			} else {</code></span>
<span class="codeline" id="line-381"><code>				srcx := (*uintptr)(unsafe.Pointer(src + i))</code></span>
<span class="codeline" id="line-382"><code>				p := buf.get2()</code></span>
<span class="codeline" id="line-383"><code>				p[0] = *dstx</code></span>
<span class="codeline" id="line-384"><code>				p[1] = *srcx</code></span>
<span class="codeline" id="line-385"><code>			}</code></span>
<span class="codeline" id="line-386"><code>		}</code></span>
<span class="codeline" id="line-387"><code>		mask &lt;&lt;= 1</code></span>
<span class="codeline" id="line-388"><code>	}</code></span>
<span class="codeline" id="line-389"><code>}</code></span>
<span class="codeline" id="line-390"><code></code></span>
<span class="codeline" id="line-391"><code>// typeBitsBulkBarrier executes a write barrier for every</code></span>
<span class="codeline" id="line-392"><code>// pointer that would be copied from [src, src+size) to [dst,</code></span>
<span class="codeline" id="line-393"><code>// dst+size) by a memmove using the type bitmap to locate those</code></span>
<span class="codeline" id="line-394"><code>// pointer slots.</code></span>
<span class="codeline" id="line-395"><code>//</code></span>
<span class="codeline" id="line-396"><code>// The type typ must correspond exactly to [src, src+size) and [dst, dst+size).</code></span>
<span class="codeline" id="line-397"><code>// dst, src, and size must be pointer-aligned.</code></span>
<span class="codeline" id="line-398"><code>// The type typ must have a plain bitmap, not a GC program.</code></span>
<span class="codeline" id="line-399"><code>// The only use of this function is in channel sends, and the</code></span>
<span class="codeline" id="line-400"><code>// 64 kB channel element limit takes care of this for us.</code></span>
<span class="codeline" id="line-401"><code>//</code></span>
<span class="codeline" id="line-402"><code>// Must not be preempted because it typically runs right before memmove,</code></span>
<span class="codeline" id="line-403"><code>// and the GC must observe them as an atomic action.</code></span>
<span class="codeline" id="line-404"><code>//</code></span>
<span class="codeline" id="line-405"><code>// Callers must perform cgo checks if goexperiment.CgoCheck2.</code></span>
<span class="codeline" id="line-406"><code>//</code></span>
<span class="codeline" id="line-407"><code>//go:nosplit</code></span>
<span class="codeline" id="line-408"><code>func typeBitsBulkBarrier(typ *_type, dst, src, size uintptr) {</code></span>
<span class="codeline" id="line-409"><code>	if typ == nil {</code></span>
<span class="codeline" id="line-410"><code>		throw("runtime: typeBitsBulkBarrier without type")</code></span>
<span class="codeline" id="line-411"><code>	}</code></span>
<span class="codeline" id="line-412"><code>	if typ.Size_ != size {</code></span>
<span class="codeline" id="line-413"><code>		println("runtime: typeBitsBulkBarrier with type ", toRType(typ).string(), " of size ", typ.Size_, " but memory size", size)</code></span>
<span class="codeline" id="line-414"><code>		throw("runtime: invalid typeBitsBulkBarrier")</code></span>
<span class="codeline" id="line-415"><code>	}</code></span>
<span class="codeline" id="line-416"><code>	if typ.Kind_&amp;kindGCProg != 0 {</code></span>
<span class="codeline" id="line-417"><code>		println("runtime: typeBitsBulkBarrier with type ", toRType(typ).string(), " with GC prog")</code></span>
<span class="codeline" id="line-418"><code>		throw("runtime: invalid typeBitsBulkBarrier")</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code>	if !writeBarrier.enabled {</code></span>
<span class="codeline" id="line-421"><code>		return</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code>	ptrmask := typ.GCData</code></span>
<span class="codeline" id="line-424"><code>	buf := &amp;getg().m.p.ptr().wbBuf</code></span>
<span class="codeline" id="line-425"><code>	var bits uint32</code></span>
<span class="codeline" id="line-426"><code>	for i := uintptr(0); i &lt; typ.PtrBytes; i += goarch.PtrSize {</code></span>
<span class="codeline" id="line-427"><code>		if i&amp;(goarch.PtrSize*8-1) == 0 {</code></span>
<span class="codeline" id="line-428"><code>			bits = uint32(*ptrmask)</code></span>
<span class="codeline" id="line-429"><code>			ptrmask = addb(ptrmask, 1)</code></span>
<span class="codeline" id="line-430"><code>		} else {</code></span>
<span class="codeline" id="line-431"><code>			bits = bits &gt;&gt; 1</code></span>
<span class="codeline" id="line-432"><code>		}</code></span>
<span class="codeline" id="line-433"><code>		if bits&amp;1 != 0 {</code></span>
<span class="codeline" id="line-434"><code>			dstx := (*uintptr)(unsafe.Pointer(dst + i))</code></span>
<span class="codeline" id="line-435"><code>			srcx := (*uintptr)(unsafe.Pointer(src + i))</code></span>
<span class="codeline" id="line-436"><code>			p := buf.get2()</code></span>
<span class="codeline" id="line-437"><code>			p[0] = *dstx</code></span>
<span class="codeline" id="line-438"><code>			p[1] = *srcx</code></span>
<span class="codeline" id="line-439"><code>		}</code></span>
<span class="codeline" id="line-440"><code>	}</code></span>
<span class="codeline" id="line-441"><code>}</code></span>
<span class="codeline" id="line-442"><code></code></span>
<span class="codeline" id="line-443"><code>// countAlloc returns the number of objects allocated in span s by</code></span>
<span class="codeline" id="line-444"><code>// scanning the mark bitmap.</code></span>
<span class="codeline" id="line-445"><code>func (s *mspan) countAlloc() int {</code></span>
<span class="codeline" id="line-446"><code>	count := 0</code></span>
<span class="codeline" id="line-447"><code>	bytes := divRoundUp(uintptr(s.nelems), 8)</code></span>
<span class="codeline" id="line-448"><code>	// Iterate over each 8-byte chunk and count allocations</code></span>
<span class="codeline" id="line-449"><code>	// with an intrinsic. Note that newMarkBits guarantees that</code></span>
<span class="codeline" id="line-450"><code>	// gcmarkBits will be 8-byte aligned, so we don't have to</code></span>
<span class="codeline" id="line-451"><code>	// worry about edge cases, irrelevant bits will simply be zero.</code></span>
<span class="codeline" id="line-452"><code>	for i := uintptr(0); i &lt; bytes; i += 8 {</code></span>
<span class="codeline" id="line-453"><code>		// Extract 64 bits from the byte pointer and get a OnesCount.</code></span>
<span class="codeline" id="line-454"><code>		// Note that the unsafe cast here doesn't preserve endianness,</code></span>
<span class="codeline" id="line-455"><code>		// but that's OK. We only care about how many bits are 1, not</code></span>
<span class="codeline" id="line-456"><code>		// about the order we discover them in.</code></span>
<span class="codeline" id="line-457"><code>		mrkBits := *(*uint64)(unsafe.Pointer(s.gcmarkBits.bytep(i)))</code></span>
<span class="codeline" id="line-458"><code>		count += sys.OnesCount64(mrkBits)</code></span>
<span class="codeline" id="line-459"><code>	}</code></span>
<span class="codeline" id="line-460"><code>	return count</code></span>
<span class="codeline" id="line-461"><code>}</code></span>
<span class="codeline" id="line-462"><code></code></span>
<span class="codeline" id="line-463"><code>// Read the bytes starting at the aligned pointer p into a uintptr.</code></span>
<span class="codeline" id="line-464"><code>// Read is little-endian.</code></span>
<span class="codeline" id="line-465"><code>func readUintptr(p *byte) uintptr {</code></span>
<span class="codeline" id="line-466"><code>	x := *(*uintptr)(unsafe.Pointer(p))</code></span>
<span class="codeline" id="line-467"><code>	if goarch.BigEndian {</code></span>
<span class="codeline" id="line-468"><code>		if goarch.PtrSize == 8 {</code></span>
<span class="codeline" id="line-469"><code>			return uintptr(sys.Bswap64(uint64(x)))</code></span>
<span class="codeline" id="line-470"><code>		}</code></span>
<span class="codeline" id="line-471"><code>		return uintptr(sys.Bswap32(uint32(x)))</code></span>
<span class="codeline" id="line-472"><code>	}</code></span>
<span class="codeline" id="line-473"><code>	return x</code></span>
<span class="codeline" id="line-474"><code>}</code></span>
<span class="codeline" id="line-475"><code></code></span>
<span class="codeline" id="line-476"><code>var debugPtrmask struct {</code></span>
<span class="codeline" id="line-477"><code>	lock mutex</code></span>
<span class="codeline" id="line-478"><code>	data *byte</code></span>
<span class="codeline" id="line-479"><code>}</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// progToPointerMask returns the 1-bit pointer mask output by the GC program prog.</code></span>
<span class="codeline" id="line-482"><code>// size the size of the region described by prog, in bytes.</code></span>
<span class="codeline" id="line-483"><code>// The resulting bitvector will have no more than size/goarch.PtrSize bits.</code></span>
<span class="codeline" id="line-484"><code>func progToPointerMask(prog *byte, size uintptr) bitvector {</code></span>
<span class="codeline" id="line-485"><code>	n := (size/goarch.PtrSize + 7) / 8</code></span>
<span class="codeline" id="line-486"><code>	x := (*[1 &lt;&lt; 30]byte)(persistentalloc(n+1, 1, &amp;memstats.buckhash_sys))[:n+1]</code></span>
<span class="codeline" id="line-487"><code>	x[len(x)-1] = 0xa1 // overflow check sentinel</code></span>
<span class="codeline" id="line-488"><code>	n = runGCProg(prog, &amp;x[0])</code></span>
<span class="codeline" id="line-489"><code>	if x[len(x)-1] != 0xa1 {</code></span>
<span class="codeline" id="line-490"><code>		throw("progToPointerMask: overflow")</code></span>
<span class="codeline" id="line-491"><code>	}</code></span>
<span class="codeline" id="line-492"><code>	return bitvector{int32(n), &amp;x[0]}</code></span>
<span class="codeline" id="line-493"><code>}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>// Packed GC pointer bitmaps, aka GC programs.</code></span>
<span class="codeline" id="line-496"><code>//</code></span>
<span class="codeline" id="line-497"><code>// For large types containing arrays, the type information has a</code></span>
<span class="codeline" id="line-498"><code>// natural repetition that can be encoded to save space in the</code></span>
<span class="codeline" id="line-499"><code>// binary and in the memory representation of the type information.</code></span>
<span class="codeline" id="line-500"><code>//</code></span>
<span class="codeline" id="line-501"><code>// The encoding is a simple Lempel-Ziv style bytecode machine</code></span>
<span class="codeline" id="line-502"><code>// with the following instructions:</code></span>
<span class="codeline" id="line-503"><code>//</code></span>
<span class="codeline" id="line-504"><code>//	00000000: stop</code></span>
<span class="codeline" id="line-505"><code>//	0nnnnnnn: emit n bits copied from the next (n+7)/8 bytes</code></span>
<span class="codeline" id="line-506"><code>//	10000000 n c: repeat the previous n bits c times; n, c are varints</code></span>
<span class="codeline" id="line-507"><code>//	1nnnnnnn c: repeat the previous n bits c times; c is a varint</code></span>
<span class="codeline" id="line-508"><code></code></span>
<span class="codeline" id="line-509"><code>// runGCProg returns the number of 1-bit entries written to memory.</code></span>
<span class="codeline" id="line-510"><code>func runGCProg(prog, dst *byte) uintptr {</code></span>
<span class="codeline" id="line-511"><code>	dstStart := dst</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>	// Bits waiting to be written to memory.</code></span>
<span class="codeline" id="line-514"><code>	var bits uintptr</code></span>
<span class="codeline" id="line-515"><code>	var nbits uintptr</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>	p := prog</code></span>
<span class="codeline" id="line-518"><code>Run:</code></span>
<span class="codeline" id="line-519"><code>	for {</code></span>
<span class="codeline" id="line-520"><code>		// Flush accumulated full bytes.</code></span>
<span class="codeline" id="line-521"><code>		// The rest of the loop assumes that nbits &lt;= 7.</code></span>
<span class="codeline" id="line-522"><code>		for ; nbits &gt;= 8; nbits -= 8 {</code></span>
<span class="codeline" id="line-523"><code>			*dst = uint8(bits)</code></span>
<span class="codeline" id="line-524"><code>			dst = add1(dst)</code></span>
<span class="codeline" id="line-525"><code>			bits &gt;&gt;= 8</code></span>
<span class="codeline" id="line-526"><code>		}</code></span>
<span class="codeline" id="line-527"><code></code></span>
<span class="codeline" id="line-528"><code>		// Process one instruction.</code></span>
<span class="codeline" id="line-529"><code>		inst := uintptr(*p)</code></span>
<span class="codeline" id="line-530"><code>		p = add1(p)</code></span>
<span class="codeline" id="line-531"><code>		n := inst &amp; 0x7F</code></span>
<span class="codeline" id="line-532"><code>		if inst&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-533"><code>			// Literal bits; n == 0 means end of program.</code></span>
<span class="codeline" id="line-534"><code>			if n == 0 {</code></span>
<span class="codeline" id="line-535"><code>				// Program is over.</code></span>
<span class="codeline" id="line-536"><code>				break Run</code></span>
<span class="codeline" id="line-537"><code>			}</code></span>
<span class="codeline" id="line-538"><code>			nbyte := n / 8</code></span>
<span class="codeline" id="line-539"><code>			for i := uintptr(0); i &lt; nbyte; i++ {</code></span>
<span class="codeline" id="line-540"><code>				bits |= uintptr(*p) &lt;&lt; nbits</code></span>
<span class="codeline" id="line-541"><code>				p = add1(p)</code></span>
<span class="codeline" id="line-542"><code>				*dst = uint8(bits)</code></span>
<span class="codeline" id="line-543"><code>				dst = add1(dst)</code></span>
<span class="codeline" id="line-544"><code>				bits &gt;&gt;= 8</code></span>
<span class="codeline" id="line-545"><code>			}</code></span>
<span class="codeline" id="line-546"><code>			if n %= 8; n &gt; 0 {</code></span>
<span class="codeline" id="line-547"><code>				bits |= uintptr(*p) &lt;&lt; nbits</code></span>
<span class="codeline" id="line-548"><code>				p = add1(p)</code></span>
<span class="codeline" id="line-549"><code>				nbits += n</code></span>
<span class="codeline" id="line-550"><code>			}</code></span>
<span class="codeline" id="line-551"><code>			continue Run</code></span>
<span class="codeline" id="line-552"><code>		}</code></span>
<span class="codeline" id="line-553"><code></code></span>
<span class="codeline" id="line-554"><code>		// Repeat. If n == 0, it is encoded in a varint in the next bytes.</code></span>
<span class="codeline" id="line-555"><code>		if n == 0 {</code></span>
<span class="codeline" id="line-556"><code>			for off := uint(0); ; off += 7 {</code></span>
<span class="codeline" id="line-557"><code>				x := uintptr(*p)</code></span>
<span class="codeline" id="line-558"><code>				p = add1(p)</code></span>
<span class="codeline" id="line-559"><code>				n |= (x &amp; 0x7F) &lt;&lt; off</code></span>
<span class="codeline" id="line-560"><code>				if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-561"><code>					break</code></span>
<span class="codeline" id="line-562"><code>				}</code></span>
<span class="codeline" id="line-563"><code>			}</code></span>
<span class="codeline" id="line-564"><code>		}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>		// Count is encoded in a varint in the next bytes.</code></span>
<span class="codeline" id="line-567"><code>		c := uintptr(0)</code></span>
<span class="codeline" id="line-568"><code>		for off := uint(0); ; off += 7 {</code></span>
<span class="codeline" id="line-569"><code>			x := uintptr(*p)</code></span>
<span class="codeline" id="line-570"><code>			p = add1(p)</code></span>
<span class="codeline" id="line-571"><code>			c |= (x &amp; 0x7F) &lt;&lt; off</code></span>
<span class="codeline" id="line-572"><code>			if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-573"><code>				break</code></span>
<span class="codeline" id="line-574"><code>			}</code></span>
<span class="codeline" id="line-575"><code>		}</code></span>
<span class="codeline" id="line-576"><code>		c *= n // now total number of bits to copy</code></span>
<span class="codeline" id="line-577"><code></code></span>
<span class="codeline" id="line-578"><code>		// If the number of bits being repeated is small, load them</code></span>
<span class="codeline" id="line-579"><code>		// into a register and use that register for the entire loop</code></span>
<span class="codeline" id="line-580"><code>		// instead of repeatedly reading from memory.</code></span>
<span class="codeline" id="line-581"><code>		// Handling fewer than 8 bits here makes the general loop simpler.</code></span>
<span class="codeline" id="line-582"><code>		// The cutoff is goarch.PtrSize*8 - 7 to guarantee that when we add</code></span>
<span class="codeline" id="line-583"><code>		// the pattern to a bit buffer holding at most 7 bits (a partial byte)</code></span>
<span class="codeline" id="line-584"><code>		// it will not overflow.</code></span>
<span class="codeline" id="line-585"><code>		src := dst</code></span>
<span class="codeline" id="line-586"><code>		const maxBits = goarch.PtrSize*8 - 7</code></span>
<span class="codeline" id="line-587"><code>		if n &lt;= maxBits {</code></span>
<span class="codeline" id="line-588"><code>			// Start with bits in output buffer.</code></span>
<span class="codeline" id="line-589"><code>			pattern := bits</code></span>
<span class="codeline" id="line-590"><code>			npattern := nbits</code></span>
<span class="codeline" id="line-591"><code></code></span>
<span class="codeline" id="line-592"><code>			// If we need more bits, fetch them from memory.</code></span>
<span class="codeline" id="line-593"><code>			src = subtract1(src)</code></span>
<span class="codeline" id="line-594"><code>			for npattern &lt; n {</code></span>
<span class="codeline" id="line-595"><code>				pattern &lt;&lt;= 8</code></span>
<span class="codeline" id="line-596"><code>				pattern |= uintptr(*src)</code></span>
<span class="codeline" id="line-597"><code>				src = subtract1(src)</code></span>
<span class="codeline" id="line-598"><code>				npattern += 8</code></span>
<span class="codeline" id="line-599"><code>			}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>			// We started with the whole bit output buffer,</code></span>
<span class="codeline" id="line-602"><code>			// and then we loaded bits from whole bytes.</code></span>
<span class="codeline" id="line-603"><code>			// Either way, we might now have too many instead of too few.</code></span>
<span class="codeline" id="line-604"><code>			// Discard the extra.</code></span>
<span class="codeline" id="line-605"><code>			if npattern &gt; n {</code></span>
<span class="codeline" id="line-606"><code>				pattern &gt;&gt;= npattern - n</code></span>
<span class="codeline" id="line-607"><code>				npattern = n</code></span>
<span class="codeline" id="line-608"><code>			}</code></span>
<span class="codeline" id="line-609"><code></code></span>
<span class="codeline" id="line-610"><code>			// Replicate pattern to at most maxBits.</code></span>
<span class="codeline" id="line-611"><code>			if npattern == 1 {</code></span>
<span class="codeline" id="line-612"><code>				// One bit being repeated.</code></span>
<span class="codeline" id="line-613"><code>				// If the bit is 1, make the pattern all 1s.</code></span>
<span class="codeline" id="line-614"><code>				// If the bit is 0, the pattern is already all 0s,</code></span>
<span class="codeline" id="line-615"><code>				// but we can claim that the number of bits</code></span>
<span class="codeline" id="line-616"><code>				// in the word is equal to the number we need (c),</code></span>
<span class="codeline" id="line-617"><code>				// because right shift of bits will zero fill.</code></span>
<span class="codeline" id="line-618"><code>				if pattern == 1 {</code></span>
<span class="codeline" id="line-619"><code>					pattern = 1&lt;&lt;maxBits - 1</code></span>
<span class="codeline" id="line-620"><code>					npattern = maxBits</code></span>
<span class="codeline" id="line-621"><code>				} else {</code></span>
<span class="codeline" id="line-622"><code>					npattern = c</code></span>
<span class="codeline" id="line-623"><code>				}</code></span>
<span class="codeline" id="line-624"><code>			} else {</code></span>
<span class="codeline" id="line-625"><code>				b := pattern</code></span>
<span class="codeline" id="line-626"><code>				nb := npattern</code></span>
<span class="codeline" id="line-627"><code>				if nb+nb &lt;= maxBits {</code></span>
<span class="codeline" id="line-628"><code>					// Double pattern until the whole uintptr is filled.</code></span>
<span class="codeline" id="line-629"><code>					for nb &lt;= goarch.PtrSize*8 {</code></span>
<span class="codeline" id="line-630"><code>						b |= b &lt;&lt; nb</code></span>
<span class="codeline" id="line-631"><code>						nb += nb</code></span>
<span class="codeline" id="line-632"><code>					}</code></span>
<span class="codeline" id="line-633"><code>					// Trim away incomplete copy of original pattern in high bits.</code></span>
<span class="codeline" id="line-634"><code>					// TODO(rsc): Replace with table lookup or loop on systems without divide?</code></span>
<span class="codeline" id="line-635"><code>					nb = maxBits / npattern * npattern</code></span>
<span class="codeline" id="line-636"><code>					b &amp;= 1&lt;&lt;nb - 1</code></span>
<span class="codeline" id="line-637"><code>					pattern = b</code></span>
<span class="codeline" id="line-638"><code>					npattern = nb</code></span>
<span class="codeline" id="line-639"><code>				}</code></span>
<span class="codeline" id="line-640"><code>			}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>			// Add pattern to bit buffer and flush bit buffer, c/npattern times.</code></span>
<span class="codeline" id="line-643"><code>			// Since pattern contains &gt;8 bits, there will be full bytes to flush</code></span>
<span class="codeline" id="line-644"><code>			// on each iteration.</code></span>
<span class="codeline" id="line-645"><code>			for ; c &gt;= npattern; c -= npattern {</code></span>
<span class="codeline" id="line-646"><code>				bits |= pattern &lt;&lt; nbits</code></span>
<span class="codeline" id="line-647"><code>				nbits += npattern</code></span>
<span class="codeline" id="line-648"><code>				for nbits &gt;= 8 {</code></span>
<span class="codeline" id="line-649"><code>					*dst = uint8(bits)</code></span>
<span class="codeline" id="line-650"><code>					dst = add1(dst)</code></span>
<span class="codeline" id="line-651"><code>					bits &gt;&gt;= 8</code></span>
<span class="codeline" id="line-652"><code>					nbits -= 8</code></span>
<span class="codeline" id="line-653"><code>				}</code></span>
<span class="codeline" id="line-654"><code>			}</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>			// Add final fragment to bit buffer.</code></span>
<span class="codeline" id="line-657"><code>			if c &gt; 0 {</code></span>
<span class="codeline" id="line-658"><code>				pattern &amp;= 1&lt;&lt;c - 1</code></span>
<span class="codeline" id="line-659"><code>				bits |= pattern &lt;&lt; nbits</code></span>
<span class="codeline" id="line-660"><code>				nbits += c</code></span>
<span class="codeline" id="line-661"><code>			}</code></span>
<span class="codeline" id="line-662"><code>			continue Run</code></span>
<span class="codeline" id="line-663"><code>		}</code></span>
<span class="codeline" id="line-664"><code></code></span>
<span class="codeline" id="line-665"><code>		// Repeat; n too large to fit in a register.</code></span>
<span class="codeline" id="line-666"><code>		// Since nbits &lt;= 7, we know the first few bytes of repeated data</code></span>
<span class="codeline" id="line-667"><code>		// are already written to memory.</code></span>
<span class="codeline" id="line-668"><code>		off := n - nbits // n &gt; nbits because n &gt; maxBits and nbits &lt;= 7</code></span>
<span class="codeline" id="line-669"><code>		// Leading src fragment.</code></span>
<span class="codeline" id="line-670"><code>		src = subtractb(src, (off+7)/8)</code></span>
<span class="codeline" id="line-671"><code>		if frag := off &amp; 7; frag != 0 {</code></span>
<span class="codeline" id="line-672"><code>			bits |= uintptr(*src) &gt;&gt; (8 - frag) &lt;&lt; nbits</code></span>
<span class="codeline" id="line-673"><code>			src = add1(src)</code></span>
<span class="codeline" id="line-674"><code>			nbits += frag</code></span>
<span class="codeline" id="line-675"><code>			c -= frag</code></span>
<span class="codeline" id="line-676"><code>		}</code></span>
<span class="codeline" id="line-677"><code>		// Main loop: load one byte, write another.</code></span>
<span class="codeline" id="line-678"><code>		// The bits are rotating through the bit buffer.</code></span>
<span class="codeline" id="line-679"><code>		for i := c / 8; i &gt; 0; i-- {</code></span>
<span class="codeline" id="line-680"><code>			bits |= uintptr(*src) &lt;&lt; nbits</code></span>
<span class="codeline" id="line-681"><code>			src = add1(src)</code></span>
<span class="codeline" id="line-682"><code>			*dst = uint8(bits)</code></span>
<span class="codeline" id="line-683"><code>			dst = add1(dst)</code></span>
<span class="codeline" id="line-684"><code>			bits &gt;&gt;= 8</code></span>
<span class="codeline" id="line-685"><code>		}</code></span>
<span class="codeline" id="line-686"><code>		// Final src fragment.</code></span>
<span class="codeline" id="line-687"><code>		if c %= 8; c &gt; 0 {</code></span>
<span class="codeline" id="line-688"><code>			bits |= (uintptr(*src) &amp; (1&lt;&lt;c - 1)) &lt;&lt; nbits</code></span>
<span class="codeline" id="line-689"><code>			nbits += c</code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>	}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>	// Write any final bits out, using full-byte writes, even for the final byte.</code></span>
<span class="codeline" id="line-694"><code>	totalBits := (uintptr(unsafe.Pointer(dst))-uintptr(unsafe.Pointer(dstStart)))*8 + nbits</code></span>
<span class="codeline" id="line-695"><code>	nbits += -nbits &amp; 7</code></span>
<span class="codeline" id="line-696"><code>	for ; nbits &gt; 0; nbits -= 8 {</code></span>
<span class="codeline" id="line-697"><code>		*dst = uint8(bits)</code></span>
<span class="codeline" id="line-698"><code>		dst = add1(dst)</code></span>
<span class="codeline" id="line-699"><code>		bits &gt;&gt;= 8</code></span>
<span class="codeline" id="line-700"><code>	}</code></span>
<span class="codeline" id="line-701"><code>	return totalBits</code></span>
<span class="codeline" id="line-702"><code>}</code></span>
<span class="codeline" id="line-703"><code></code></span>
<span class="codeline" id="line-704"><code>// materializeGCProg allocates space for the (1-bit) pointer bitmask</code></span>
<span class="codeline" id="line-705"><code>// for an object of size ptrdata.  Then it fills that space with the</code></span>
<span class="codeline" id="line-706"><code>// pointer bitmask specified by the program prog.</code></span>
<span class="codeline" id="line-707"><code>// The bitmask starts at s.startAddr.</code></span>
<span class="codeline" id="line-708"><code>// The result must be deallocated with dematerializeGCProg.</code></span>
<span class="codeline" id="line-709"><code>func materializeGCProg(ptrdata uintptr, prog *byte) *mspan {</code></span>
<span class="codeline" id="line-710"><code>	// Each word of ptrdata needs one bit in the bitmap.</code></span>
<span class="codeline" id="line-711"><code>	bitmapBytes := divRoundUp(ptrdata, 8*goarch.PtrSize)</code></span>
<span class="codeline" id="line-712"><code>	// Compute the number of pages needed for bitmapBytes.</code></span>
<span class="codeline" id="line-713"><code>	pages := divRoundUp(bitmapBytes, pageSize)</code></span>
<span class="codeline" id="line-714"><code>	s := mheap_.allocManual(pages, spanAllocPtrScalarBits)</code></span>
<span class="codeline" id="line-715"><code>	runGCProg(addb(prog, 4), (*byte)(unsafe.Pointer(s.startAddr)))</code></span>
<span class="codeline" id="line-716"><code>	return s</code></span>
<span class="codeline" id="line-717"><code>}</code></span>
<span class="codeline" id="line-718"><code>func dematerializeGCProg(s *mspan) {</code></span>
<span class="codeline" id="line-719"><code>	mheap_.freeManual(s, spanAllocPtrScalarBits)</code></span>
<span class="codeline" id="line-720"><code>}</code></span>
<span class="codeline" id="line-721"><code></code></span>
<span class="codeline" id="line-722"><code>func dumpGCProg(p *byte) {</code></span>
<span class="codeline" id="line-723"><code>	nptr := 0</code></span>
<span class="codeline" id="line-724"><code>	for {</code></span>
<span class="codeline" id="line-725"><code>		x := *p</code></span>
<span class="codeline" id="line-726"><code>		p = add1(p)</code></span>
<span class="codeline" id="line-727"><code>		if x == 0 {</code></span>
<span class="codeline" id="line-728"><code>			print("\t", nptr, " end\n")</code></span>
<span class="codeline" id="line-729"><code>			break</code></span>
<span class="codeline" id="line-730"><code>		}</code></span>
<span class="codeline" id="line-731"><code>		if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-732"><code>			print("\t", nptr, " lit ", x, ":")</code></span>
<span class="codeline" id="line-733"><code>			n := int(x+7) / 8</code></span>
<span class="codeline" id="line-734"><code>			for i := 0; i &lt; n; i++ {</code></span>
<span class="codeline" id="line-735"><code>				print(" ", hex(*p))</code></span>
<span class="codeline" id="line-736"><code>				p = add1(p)</code></span>
<span class="codeline" id="line-737"><code>			}</code></span>
<span class="codeline" id="line-738"><code>			print("\n")</code></span>
<span class="codeline" id="line-739"><code>			nptr += int(x)</code></span>
<span class="codeline" id="line-740"><code>		} else {</code></span>
<span class="codeline" id="line-741"><code>			nbit := int(x &amp;^ 0x80)</code></span>
<span class="codeline" id="line-742"><code>			if nbit == 0 {</code></span>
<span class="codeline" id="line-743"><code>				for nb := uint(0); ; nb += 7 {</code></span>
<span class="codeline" id="line-744"><code>					x := *p</code></span>
<span class="codeline" id="line-745"><code>					p = add1(p)</code></span>
<span class="codeline" id="line-746"><code>					nbit |= int(x&amp;0x7f) &lt;&lt; nb</code></span>
<span class="codeline" id="line-747"><code>					if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-748"><code>						break</code></span>
<span class="codeline" id="line-749"><code>					}</code></span>
<span class="codeline" id="line-750"><code>				}</code></span>
<span class="codeline" id="line-751"><code>			}</code></span>
<span class="codeline" id="line-752"><code>			count := 0</code></span>
<span class="codeline" id="line-753"><code>			for nb := uint(0); ; nb += 7 {</code></span>
<span class="codeline" id="line-754"><code>				x := *p</code></span>
<span class="codeline" id="line-755"><code>				p = add1(p)</code></span>
<span class="codeline" id="line-756"><code>				count |= int(x&amp;0x7f) &lt;&lt; nb</code></span>
<span class="codeline" id="line-757"><code>				if x&amp;0x80 == 0 {</code></span>
<span class="codeline" id="line-758"><code>					break</code></span>
<span class="codeline" id="line-759"><code>				}</code></span>
<span class="codeline" id="line-760"><code>			}</code></span>
<span class="codeline" id="line-761"><code>			print("\t", nptr, " repeat ", nbit, " × ", count, "\n")</code></span>
<span class="codeline" id="line-762"><code>			nptr += nbit * count</code></span>
<span class="codeline" id="line-763"><code>		}</code></span>
<span class="codeline" id="line-764"><code>	}</code></span>
<span class="codeline" id="line-765"><code>}</code></span>
<span class="codeline" id="line-766"><code></code></span>
<span class="codeline" id="line-767"><code>// Testing.</code></span>
<span class="codeline" id="line-768"><code></code></span>
<span class="codeline" id="line-769"><code>// reflect_gcbits returns the GC type info for x, for testing.</code></span>
<span class="codeline" id="line-770"><code>// The result is the bitmap entries (0 or 1), one entry per byte.</code></span>
<span class="codeline" id="line-771"><code>//</code></span>
<span class="codeline" id="line-772"><code>//go:linkname reflect_gcbits reflect.gcbits</code></span>
<span class="codeline" id="line-773"><code>func reflect_gcbits(x any) []byte {</code></span>
<span class="codeline" id="line-774"><code>	return getgcmask(x)</code></span>
<span class="codeline" id="line-775"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>