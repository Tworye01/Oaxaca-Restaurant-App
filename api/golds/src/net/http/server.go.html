<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: server.go in package net/http</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	server.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/http.html">net/http</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>// HTTP server. See RFC 7230 through 7235.</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>package http</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>import (</code></span>
<span class="codeline" id="line-10"><code>	"bufio"</code></span>
<span class="codeline" id="line-11"><code>	"bytes"</code></span>
<span class="codeline" id="line-12"><code>	"context"</code></span>
<span class="codeline" id="line-13"><code>	"crypto/tls"</code></span>
<span class="codeline" id="line-14"><code>	"errors"</code></span>
<span class="codeline" id="line-15"><code>	"fmt"</code></span>
<span class="codeline" id="line-16"><code>	"internal/godebug"</code></span>
<span class="codeline" id="line-17"><code>	"io"</code></span>
<span class="codeline" id="line-18"><code>	"log"</code></span>
<span class="codeline" id="line-19"><code>	"math/rand"</code></span>
<span class="codeline" id="line-20"><code>	"net"</code></span>
<span class="codeline" id="line-21"><code>	"net/textproto"</code></span>
<span class="codeline" id="line-22"><code>	"net/url"</code></span>
<span class="codeline" id="line-23"><code>	urlpkg "net/url"</code></span>
<span class="codeline" id="line-24"><code>	"path"</code></span>
<span class="codeline" id="line-25"><code>	"runtime"</code></span>
<span class="codeline" id="line-26"><code>	"sort"</code></span>
<span class="codeline" id="line-27"><code>	"strconv"</code></span>
<span class="codeline" id="line-28"><code>	"strings"</code></span>
<span class="codeline" id="line-29"><code>	"sync"</code></span>
<span class="codeline" id="line-30"><code>	"sync/atomic"</code></span>
<span class="codeline" id="line-31"><code>	"time"</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>	"golang.org/x/net/http/httpguts"</code></span>
<span class="codeline" id="line-34"><code>)</code></span>
<span class="codeline" id="line-35"><code></code></span>
<span class="codeline" id="line-36"><code>// Errors used by the HTTP server.</code></span>
<span class="codeline" id="line-37"><code>var (</code></span>
<span class="codeline" id="line-38"><code>	// ErrBodyNotAllowed is returned by ResponseWriter.Write calls</code></span>
<span class="codeline" id="line-39"><code>	// when the HTTP method or response code does not permit a</code></span>
<span class="codeline" id="line-40"><code>	// body.</code></span>
<span class="codeline" id="line-41"><code>	ErrBodyNotAllowed = errors.New("http: request method or response status code does not allow body")</code></span>
<span class="codeline" id="line-42"><code></code></span>
<span class="codeline" id="line-43"><code>	// ErrHijacked is returned by ResponseWriter.Write calls when</code></span>
<span class="codeline" id="line-44"><code>	// the underlying connection has been hijacked using the</code></span>
<span class="codeline" id="line-45"><code>	// Hijacker interface. A zero-byte write on a hijacked</code></span>
<span class="codeline" id="line-46"><code>	// connection will return ErrHijacked without any other side</code></span>
<span class="codeline" id="line-47"><code>	// effects.</code></span>
<span class="codeline" id="line-48"><code>	ErrHijacked = errors.New("http: connection has been hijacked")</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>	// ErrContentLength is returned by ResponseWriter.Write calls</code></span>
<span class="codeline" id="line-51"><code>	// when a Handler set a Content-Length response header with a</code></span>
<span class="codeline" id="line-52"><code>	// declared size and then attempted to write more bytes than</code></span>
<span class="codeline" id="line-53"><code>	// declared.</code></span>
<span class="codeline" id="line-54"><code>	ErrContentLength = errors.New("http: wrote more than the declared Content-Length")</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>	// Deprecated: ErrWriteAfterFlush is no longer returned by</code></span>
<span class="codeline" id="line-57"><code>	// anything in the net/http package. Callers should not</code></span>
<span class="codeline" id="line-58"><code>	// compare errors against this variable.</code></span>
<span class="codeline" id="line-59"><code>	ErrWriteAfterFlush = errors.New("unused")</code></span>
<span class="codeline" id="line-60"><code>)</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>// A Handler responds to an HTTP request.</code></span>
<span class="codeline" id="line-63"><code>//</code></span>
<span class="codeline" id="line-64"><code>// [Handler.ServeHTTP] should write reply headers and data to the [ResponseWriter]</code></span>
<span class="codeline" id="line-65"><code>// and then return. Returning signals that the request is finished; it</code></span>
<span class="codeline" id="line-66"><code>// is not valid to use the [ResponseWriter] or read from the</code></span>
<span class="codeline" id="line-67"><code>// [Request.Body] after or concurrently with the completion of the</code></span>
<span class="codeline" id="line-68"><code>// ServeHTTP call.</code></span>
<span class="codeline" id="line-69"><code>//</code></span>
<span class="codeline" id="line-70"><code>// Depending on the HTTP client software, HTTP protocol version, and</code></span>
<span class="codeline" id="line-71"><code>// any intermediaries between the client and the Go server, it may not</code></span>
<span class="codeline" id="line-72"><code>// be possible to read from the [Request.Body] after writing to the</code></span>
<span class="codeline" id="line-73"><code>// [ResponseWriter]. Cautious handlers should read the [Request.Body]</code></span>
<span class="codeline" id="line-74"><code>// first, and then reply.</code></span>
<span class="codeline" id="line-75"><code>//</code></span>
<span class="codeline" id="line-76"><code>// Except for reading the body, handlers should not modify the</code></span>
<span class="codeline" id="line-77"><code>// provided Request.</code></span>
<span class="codeline" id="line-78"><code>//</code></span>
<span class="codeline" id="line-79"><code>// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes</code></span>
<span class="codeline" id="line-80"><code>// that the effect of the panic was isolated to the active request.</code></span>
<span class="codeline" id="line-81"><code>// It recovers the panic, logs a stack trace to the server error log,</code></span>
<span class="codeline" id="line-82"><code>// and either closes the network connection or sends an HTTP/2</code></span>
<span class="codeline" id="line-83"><code>// RST_STREAM, depending on the HTTP protocol. To abort a handler so</code></span>
<span class="codeline" id="line-84"><code>// the client sees an interrupted response but the server doesn't log</code></span>
<span class="codeline" id="line-85"><code>// an error, panic with the value [ErrAbortHandler].</code></span>
<span class="codeline" id="line-86"><code>type Handler interface {</code></span>
<span class="codeline" id="line-87"><code>	ServeHTTP(ResponseWriter, *Request)</code></span>
<span class="codeline" id="line-88"><code>}</code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>// A ResponseWriter interface is used by an HTTP handler to</code></span>
<span class="codeline" id="line-91"><code>// construct an HTTP response.</code></span>
<span class="codeline" id="line-92"><code>//</code></span>
<span class="codeline" id="line-93"><code>// A ResponseWriter may not be used after [Handler.ServeHTTP] has returned.</code></span>
<span class="codeline" id="line-94"><code>type ResponseWriter interface {</code></span>
<span class="codeline" id="line-95"><code>	// Header returns the header map that will be sent by</code></span>
<span class="codeline" id="line-96"><code>	// [ResponseWriter.WriteHeader]. The [Header] map also is the mechanism with which</code></span>
<span class="codeline" id="line-97"><code>	// [Handler] implementations can set HTTP trailers.</code></span>
<span class="codeline" id="line-98"><code>	//</code></span>
<span class="codeline" id="line-99"><code>	// Changing the header map after a call to [ResponseWriter.WriteHeader] (or</code></span>
<span class="codeline" id="line-100"><code>	// [ResponseWriter.Write]) has no effect unless the HTTP status code was of the</code></span>
<span class="codeline" id="line-101"><code>	// 1xx class or the modified headers are trailers.</code></span>
<span class="codeline" id="line-102"><code>	//</code></span>
<span class="codeline" id="line-103"><code>	// There are two ways to set Trailers. The preferred way is to</code></span>
<span class="codeline" id="line-104"><code>	// predeclare in the headers which trailers you will later</code></span>
<span class="codeline" id="line-105"><code>	// send by setting the "Trailer" header to the names of the</code></span>
<span class="codeline" id="line-106"><code>	// trailer keys which will come later. In this case, those</code></span>
<span class="codeline" id="line-107"><code>	// keys of the Header map are treated as if they were</code></span>
<span class="codeline" id="line-108"><code>	// trailers. See the example. The second way, for trailer</code></span>
<span class="codeline" id="line-109"><code>	// keys not known to the [Handler] until after the first [ResponseWriter.Write],</code></span>
<span class="codeline" id="line-110"><code>	// is to prefix the [Header] map keys with the [TrailerPrefix]</code></span>
<span class="codeline" id="line-111"><code>	// constant value.</code></span>
<span class="codeline" id="line-112"><code>	//</code></span>
<span class="codeline" id="line-113"><code>	// To suppress automatic response headers (such as "Date"), set</code></span>
<span class="codeline" id="line-114"><code>	// their value to nil.</code></span>
<span class="codeline" id="line-115"><code>	Header() Header</code></span>
<span class="codeline" id="line-116"><code></code></span>
<span class="codeline" id="line-117"><code>	// Write writes the data to the connection as part of an HTTP reply.</code></span>
<span class="codeline" id="line-118"><code>	//</code></span>
<span class="codeline" id="line-119"><code>	// If [ResponseWriter.WriteHeader] has not yet been called, Write calls</code></span>
<span class="codeline" id="line-120"><code>	// WriteHeader(http.StatusOK) before writing the data. If the Header</code></span>
<span class="codeline" id="line-121"><code>	// does not contain a Content-Type line, Write adds a Content-Type set</code></span>
<span class="codeline" id="line-122"><code>	// to the result of passing the initial 512 bytes of written data to</code></span>
<span class="codeline" id="line-123"><code>	// [DetectContentType]. Additionally, if the total size of all written</code></span>
<span class="codeline" id="line-124"><code>	// data is under a few KB and there are no Flush calls, the</code></span>
<span class="codeline" id="line-125"><code>	// Content-Length header is added automatically.</code></span>
<span class="codeline" id="line-126"><code>	//</code></span>
<span class="codeline" id="line-127"><code>	// Depending on the HTTP protocol version and the client, calling</code></span>
<span class="codeline" id="line-128"><code>	// Write or WriteHeader may prevent future reads on the</code></span>
<span class="codeline" id="line-129"><code>	// Request.Body. For HTTP/1.x requests, handlers should read any</code></span>
<span class="codeline" id="line-130"><code>	// needed request body data before writing the response. Once the</code></span>
<span class="codeline" id="line-131"><code>	// headers have been flushed (due to either an explicit Flusher.Flush</code></span>
<span class="codeline" id="line-132"><code>	// call or writing enough data to trigger a flush), the request body</code></span>
<span class="codeline" id="line-133"><code>	// may be unavailable. For HTTP/2 requests, the Go HTTP server permits</code></span>
<span class="codeline" id="line-134"><code>	// handlers to continue to read the request body while concurrently</code></span>
<span class="codeline" id="line-135"><code>	// writing the response. However, such behavior may not be supported</code></span>
<span class="codeline" id="line-136"><code>	// by all HTTP/2 clients. Handlers should read before writing if</code></span>
<span class="codeline" id="line-137"><code>	// possible to maximize compatibility.</code></span>
<span class="codeline" id="line-138"><code>	Write([]byte) (int, error)</code></span>
<span class="codeline" id="line-139"><code></code></span>
<span class="codeline" id="line-140"><code>	// WriteHeader sends an HTTP response header with the provided</code></span>
<span class="codeline" id="line-141"><code>	// status code.</code></span>
<span class="codeline" id="line-142"><code>	//</code></span>
<span class="codeline" id="line-143"><code>	// If WriteHeader is not called explicitly, the first call to Write</code></span>
<span class="codeline" id="line-144"><code>	// will trigger an implicit WriteHeader(http.StatusOK).</code></span>
<span class="codeline" id="line-145"><code>	// Thus explicit calls to WriteHeader are mainly used to</code></span>
<span class="codeline" id="line-146"><code>	// send error codes or 1xx informational responses.</code></span>
<span class="codeline" id="line-147"><code>	//</code></span>
<span class="codeline" id="line-148"><code>	// The provided code must be a valid HTTP 1xx-5xx status code.</code></span>
<span class="codeline" id="line-149"><code>	// Any number of 1xx headers may be written, followed by at most</code></span>
<span class="codeline" id="line-150"><code>	// one 2xx-5xx header. 1xx headers are sent immediately, but 2xx-5xx</code></span>
<span class="codeline" id="line-151"><code>	// headers may be buffered. Use the Flusher interface to send</code></span>
<span class="codeline" id="line-152"><code>	// buffered data. The header map is cleared when 2xx-5xx headers are</code></span>
<span class="codeline" id="line-153"><code>	// sent, but not with 1xx headers.</code></span>
<span class="codeline" id="line-154"><code>	//</code></span>
<span class="codeline" id="line-155"><code>	// The server will automatically send a 100 (Continue) header</code></span>
<span class="codeline" id="line-156"><code>	// on the first read from the request body if the request has</code></span>
<span class="codeline" id="line-157"><code>	// an "Expect: 100-continue" header.</code></span>
<span class="codeline" id="line-158"><code>	WriteHeader(statusCode int)</code></span>
<span class="codeline" id="line-159"><code>}</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>// The Flusher interface is implemented by ResponseWriters that allow</code></span>
<span class="codeline" id="line-162"><code>// an HTTP handler to flush buffered data to the client.</code></span>
<span class="codeline" id="line-163"><code>//</code></span>
<span class="codeline" id="line-164"><code>// The default HTTP/1.x and HTTP/2 [ResponseWriter] implementations</code></span>
<span class="codeline" id="line-165"><code>// support [Flusher], but ResponseWriter wrappers may not. Handlers</code></span>
<span class="codeline" id="line-166"><code>// should always test for this ability at runtime.</code></span>
<span class="codeline" id="line-167"><code>//</code></span>
<span class="codeline" id="line-168"><code>// Note that even for ResponseWriters that support Flush,</code></span>
<span class="codeline" id="line-169"><code>// if the client is connected through an HTTP proxy,</code></span>
<span class="codeline" id="line-170"><code>// the buffered data may not reach the client until the response</code></span>
<span class="codeline" id="line-171"><code>// completes.</code></span>
<span class="codeline" id="line-172"><code>type Flusher interface {</code></span>
<span class="codeline" id="line-173"><code>	// Flush sends any buffered data to the client.</code></span>
<span class="codeline" id="line-174"><code>	Flush()</code></span>
<span class="codeline" id="line-175"><code>}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>// The Hijacker interface is implemented by ResponseWriters that allow</code></span>
<span class="codeline" id="line-178"><code>// an HTTP handler to take over the connection.</code></span>
<span class="codeline" id="line-179"><code>//</code></span>
<span class="codeline" id="line-180"><code>// The default [ResponseWriter] for HTTP/1.x connections supports</code></span>
<span class="codeline" id="line-181"><code>// Hijacker, but HTTP/2 connections intentionally do not.</code></span>
<span class="codeline" id="line-182"><code>// ResponseWriter wrappers may also not support Hijacker. Handlers</code></span>
<span class="codeline" id="line-183"><code>// should always test for this ability at runtime.</code></span>
<span class="codeline" id="line-184"><code>type Hijacker interface {</code></span>
<span class="codeline" id="line-185"><code>	// Hijack lets the caller take over the connection.</code></span>
<span class="codeline" id="line-186"><code>	// After a call to Hijack the HTTP server library</code></span>
<span class="codeline" id="line-187"><code>	// will not do anything else with the connection.</code></span>
<span class="codeline" id="line-188"><code>	//</code></span>
<span class="codeline" id="line-189"><code>	// It becomes the caller's responsibility to manage</code></span>
<span class="codeline" id="line-190"><code>	// and close the connection.</code></span>
<span class="codeline" id="line-191"><code>	//</code></span>
<span class="codeline" id="line-192"><code>	// The returned net.Conn may have read or write deadlines</code></span>
<span class="codeline" id="line-193"><code>	// already set, depending on the configuration of the</code></span>
<span class="codeline" id="line-194"><code>	// Server. It is the caller's responsibility to set</code></span>
<span class="codeline" id="line-195"><code>	// or clear those deadlines as needed.</code></span>
<span class="codeline" id="line-196"><code>	//</code></span>
<span class="codeline" id="line-197"><code>	// The returned bufio.Reader may contain unprocessed buffered</code></span>
<span class="codeline" id="line-198"><code>	// data from the client.</code></span>
<span class="codeline" id="line-199"><code>	//</code></span>
<span class="codeline" id="line-200"><code>	// After a call to Hijack, the original Request.Body must not</code></span>
<span class="codeline" id="line-201"><code>	// be used. The original Request's Context remains valid and</code></span>
<span class="codeline" id="line-202"><code>	// is not canceled until the Request's ServeHTTP method</code></span>
<span class="codeline" id="line-203"><code>	// returns.</code></span>
<span class="codeline" id="line-204"><code>	Hijack() (net.Conn, *bufio.ReadWriter, error)</code></span>
<span class="codeline" id="line-205"><code>}</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>// The CloseNotifier interface is implemented by ResponseWriters which</code></span>
<span class="codeline" id="line-208"><code>// allow detecting when the underlying connection has gone away.</code></span>
<span class="codeline" id="line-209"><code>//</code></span>
<span class="codeline" id="line-210"><code>// This mechanism can be used to cancel long operations on the server</code></span>
<span class="codeline" id="line-211"><code>// if the client has disconnected before the response is ready.</code></span>
<span class="codeline" id="line-212"><code>//</code></span>
<span class="codeline" id="line-213"><code>// Deprecated: the CloseNotifier interface predates Go's context package.</code></span>
<span class="codeline" id="line-214"><code>// New code should use [Request.Context] instead.</code></span>
<span class="codeline" id="line-215"><code>type CloseNotifier interface {</code></span>
<span class="codeline" id="line-216"><code>	// CloseNotify returns a channel that receives at most a</code></span>
<span class="codeline" id="line-217"><code>	// single value (true) when the client connection has gone</code></span>
<span class="codeline" id="line-218"><code>	// away.</code></span>
<span class="codeline" id="line-219"><code>	//</code></span>
<span class="codeline" id="line-220"><code>	// CloseNotify may wait to notify until Request.Body has been</code></span>
<span class="codeline" id="line-221"><code>	// fully read.</code></span>
<span class="codeline" id="line-222"><code>	//</code></span>
<span class="codeline" id="line-223"><code>	// After the Handler has returned, there is no guarantee</code></span>
<span class="codeline" id="line-224"><code>	// that the channel receives a value.</code></span>
<span class="codeline" id="line-225"><code>	//</code></span>
<span class="codeline" id="line-226"><code>	// If the protocol is HTTP/1.1 and CloseNotify is called while</code></span>
<span class="codeline" id="line-227"><code>	// processing an idempotent request (such a GET) while</code></span>
<span class="codeline" id="line-228"><code>	// HTTP/1.1 pipelining is in use, the arrival of a subsequent</code></span>
<span class="codeline" id="line-229"><code>	// pipelined request may cause a value to be sent on the</code></span>
<span class="codeline" id="line-230"><code>	// returned channel. In practice HTTP/1.1 pipelining is not</code></span>
<span class="codeline" id="line-231"><code>	// enabled in browsers and not seen often in the wild. If this</code></span>
<span class="codeline" id="line-232"><code>	// is a problem, use HTTP/2 or only use CloseNotify on methods</code></span>
<span class="codeline" id="line-233"><code>	// such as POST.</code></span>
<span class="codeline" id="line-234"><code>	CloseNotify() &lt;-chan bool</code></span>
<span class="codeline" id="line-235"><code>}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>var (</code></span>
<span class="codeline" id="line-238"><code>	// ServerContextKey is a context key. It can be used in HTTP</code></span>
<span class="codeline" id="line-239"><code>	// handlers with Context.Value to access the server that</code></span>
<span class="codeline" id="line-240"><code>	// started the handler. The associated value will be of</code></span>
<span class="codeline" id="line-241"><code>	// type *Server.</code></span>
<span class="codeline" id="line-242"><code>	ServerContextKey = &amp;contextKey{"http-server"}</code></span>
<span class="codeline" id="line-243"><code></code></span>
<span class="codeline" id="line-244"><code>	// LocalAddrContextKey is a context key. It can be used in</code></span>
<span class="codeline" id="line-245"><code>	// HTTP handlers with Context.Value to access the local</code></span>
<span class="codeline" id="line-246"><code>	// address the connection arrived on.</code></span>
<span class="codeline" id="line-247"><code>	// The associated value will be of type net.Addr.</code></span>
<span class="codeline" id="line-248"><code>	LocalAddrContextKey = &amp;contextKey{"local-addr"}</code></span>
<span class="codeline" id="line-249"><code>)</code></span>
<span class="codeline" id="line-250"><code></code></span>
<span class="codeline" id="line-251"><code>// A conn represents the server side of an HTTP connection.</code></span>
<span class="codeline" id="line-252"><code>type conn struct {</code></span>
<span class="codeline" id="line-253"><code>	// server is the server on which the connection arrived.</code></span>
<span class="codeline" id="line-254"><code>	// Immutable; never nil.</code></span>
<span class="codeline" id="line-255"><code>	server *Server</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>	// cancelCtx cancels the connection-level context.</code></span>
<span class="codeline" id="line-258"><code>	cancelCtx context.CancelFunc</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code>	// rwc is the underlying network connection.</code></span>
<span class="codeline" id="line-261"><code>	// This is never wrapped by other types and is the value given out</code></span>
<span class="codeline" id="line-262"><code>	// to CloseNotifier callers. It is usually of type *net.TCPConn or</code></span>
<span class="codeline" id="line-263"><code>	// *tls.Conn.</code></span>
<span class="codeline" id="line-264"><code>	rwc net.Conn</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code>	// remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously</code></span>
<span class="codeline" id="line-267"><code>	// inside the Listener's Accept goroutine, as some implementations block.</code></span>
<span class="codeline" id="line-268"><code>	// It is populated immediately inside the (*conn).serve goroutine.</code></span>
<span class="codeline" id="line-269"><code>	// This is the value of a Handler's (*Request).RemoteAddr.</code></span>
<span class="codeline" id="line-270"><code>	remoteAddr string</code></span>
<span class="codeline" id="line-271"><code></code></span>
<span class="codeline" id="line-272"><code>	// tlsState is the TLS connection state when using TLS.</code></span>
<span class="codeline" id="line-273"><code>	// nil means not TLS.</code></span>
<span class="codeline" id="line-274"><code>	tlsState *tls.ConnectionState</code></span>
<span class="codeline" id="line-275"><code></code></span>
<span class="codeline" id="line-276"><code>	// werr is set to the first write error to rwc.</code></span>
<span class="codeline" id="line-277"><code>	// It is set via checkConnErrorWriter{w}, where bufw writes.</code></span>
<span class="codeline" id="line-278"><code>	werr error</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	// r is bufr's read source. It's a wrapper around rwc that provides</code></span>
<span class="codeline" id="line-281"><code>	// io.LimitedReader-style limiting (while reading request headers)</code></span>
<span class="codeline" id="line-282"><code>	// and functionality to support CloseNotifier. See *connReader docs.</code></span>
<span class="codeline" id="line-283"><code>	r *connReader</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>	// bufr reads from r.</code></span>
<span class="codeline" id="line-286"><code>	bufr *bufio.Reader</code></span>
<span class="codeline" id="line-287"><code></code></span>
<span class="codeline" id="line-288"><code>	// bufw writes to checkConnErrorWriter{c}, which populates werr on error.</code></span>
<span class="codeline" id="line-289"><code>	bufw *bufio.Writer</code></span>
<span class="codeline" id="line-290"><code></code></span>
<span class="codeline" id="line-291"><code>	// lastMethod is the method of the most recent request</code></span>
<span class="codeline" id="line-292"><code>	// on this connection, if any.</code></span>
<span class="codeline" id="line-293"><code>	lastMethod string</code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code>	curReq atomic.Pointer[response] // (which has a Request in it)</code></span>
<span class="codeline" id="line-296"><code></code></span>
<span class="codeline" id="line-297"><code>	curState atomic.Uint64 // packed (unixtime&lt;&lt;8|uint8(ConnState))</code></span>
<span class="codeline" id="line-298"><code></code></span>
<span class="codeline" id="line-299"><code>	// mu guards hijackedv</code></span>
<span class="codeline" id="line-300"><code>	mu sync.Mutex</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>	// hijackedv is whether this connection has been hijacked</code></span>
<span class="codeline" id="line-303"><code>	// by a Handler with the Hijacker interface.</code></span>
<span class="codeline" id="line-304"><code>	// It is guarded by mu.</code></span>
<span class="codeline" id="line-305"><code>	hijackedv bool</code></span>
<span class="codeline" id="line-306"><code>}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>func (c *conn) hijacked() bool {</code></span>
<span class="codeline" id="line-309"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-310"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-311"><code>	return c.hijackedv</code></span>
<span class="codeline" id="line-312"><code>}</code></span>
<span class="codeline" id="line-313"><code></code></span>
<span class="codeline" id="line-314"><code>// c.mu must be held.</code></span>
<span class="codeline" id="line-315"><code>func (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error) {</code></span>
<span class="codeline" id="line-316"><code>	if c.hijackedv {</code></span>
<span class="codeline" id="line-317"><code>		return nil, nil, ErrHijacked</code></span>
<span class="codeline" id="line-318"><code>	}</code></span>
<span class="codeline" id="line-319"><code>	c.r.abortPendingRead()</code></span>
<span class="codeline" id="line-320"><code></code></span>
<span class="codeline" id="line-321"><code>	c.hijackedv = true</code></span>
<span class="codeline" id="line-322"><code>	rwc = c.rwc</code></span>
<span class="codeline" id="line-323"><code>	rwc.SetDeadline(time.Time{})</code></span>
<span class="codeline" id="line-324"><code></code></span>
<span class="codeline" id="line-325"><code>	buf = bufio.NewReadWriter(c.bufr, bufio.NewWriter(rwc))</code></span>
<span class="codeline" id="line-326"><code>	if c.r.hasByte {</code></span>
<span class="codeline" id="line-327"><code>		if _, err := c.bufr.Peek(c.bufr.Buffered() + 1); err != nil {</code></span>
<span class="codeline" id="line-328"><code>			return nil, nil, fmt.Errorf("unexpected Peek failure reading buffered byte: %v", err)</code></span>
<span class="codeline" id="line-329"><code>		}</code></span>
<span class="codeline" id="line-330"><code>	}</code></span>
<span class="codeline" id="line-331"><code>	c.setState(rwc, StateHijacked, runHooks)</code></span>
<span class="codeline" id="line-332"><code>	return</code></span>
<span class="codeline" id="line-333"><code>}</code></span>
<span class="codeline" id="line-334"><code></code></span>
<span class="codeline" id="line-335"><code>// This should be &gt;= 512 bytes for DetectContentType,</code></span>
<span class="codeline" id="line-336"><code>// but otherwise it's somewhat arbitrary.</code></span>
<span class="codeline" id="line-337"><code>const bufferBeforeChunkingSize = 2048</code></span>
<span class="codeline" id="line-338"><code></code></span>
<span class="codeline" id="line-339"><code>// chunkWriter writes to a response's conn buffer, and is the writer</code></span>
<span class="codeline" id="line-340"><code>// wrapped by the response.w buffered writer.</code></span>
<span class="codeline" id="line-341"><code>//</code></span>
<span class="codeline" id="line-342"><code>// chunkWriter also is responsible for finalizing the Header, including</code></span>
<span class="codeline" id="line-343"><code>// conditionally setting the Content-Type and setting a Content-Length</code></span>
<span class="codeline" id="line-344"><code>// in cases where the handler's final output is smaller than the buffer</code></span>
<span class="codeline" id="line-345"><code>// size. It also conditionally adds chunk headers, when in chunking mode.</code></span>
<span class="codeline" id="line-346"><code>//</code></span>
<span class="codeline" id="line-347"><code>// See the comment above (*response).Write for the entire write flow.</code></span>
<span class="codeline" id="line-348"><code>type chunkWriter struct {</code></span>
<span class="codeline" id="line-349"><code>	res *response</code></span>
<span class="codeline" id="line-350"><code></code></span>
<span class="codeline" id="line-351"><code>	// header is either nil or a deep clone of res.handlerHeader</code></span>
<span class="codeline" id="line-352"><code>	// at the time of res.writeHeader, if res.writeHeader is</code></span>
<span class="codeline" id="line-353"><code>	// called and extra buffering is being done to calculate</code></span>
<span class="codeline" id="line-354"><code>	// Content-Type and/or Content-Length.</code></span>
<span class="codeline" id="line-355"><code>	header Header</code></span>
<span class="codeline" id="line-356"><code></code></span>
<span class="codeline" id="line-357"><code>	// wroteHeader tells whether the header's been written to "the</code></span>
<span class="codeline" id="line-358"><code>	// wire" (or rather: w.conn.buf). this is unlike</code></span>
<span class="codeline" id="line-359"><code>	// (*response).wroteHeader, which tells only whether it was</code></span>
<span class="codeline" id="line-360"><code>	// logically written.</code></span>
<span class="codeline" id="line-361"><code>	wroteHeader bool</code></span>
<span class="codeline" id="line-362"><code></code></span>
<span class="codeline" id="line-363"><code>	// set by the writeHeader method:</code></span>
<span class="codeline" id="line-364"><code>	chunking bool // using chunked transfer encoding for reply body</code></span>
<span class="codeline" id="line-365"><code>}</code></span>
<span class="codeline" id="line-366"><code></code></span>
<span class="codeline" id="line-367"><code>var (</code></span>
<span class="codeline" id="line-368"><code>	crlf       = []byte("\r\n")</code></span>
<span class="codeline" id="line-369"><code>	colonSpace = []byte(": ")</code></span>
<span class="codeline" id="line-370"><code>)</code></span>
<span class="codeline" id="line-371"><code></code></span>
<span class="codeline" id="line-372"><code>func (cw *chunkWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-373"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-374"><code>		cw.writeHeader(p)</code></span>
<span class="codeline" id="line-375"><code>	}</code></span>
<span class="codeline" id="line-376"><code>	if cw.res.req.Method == "HEAD" {</code></span>
<span class="codeline" id="line-377"><code>		// Eat writes.</code></span>
<span class="codeline" id="line-378"><code>		return len(p), nil</code></span>
<span class="codeline" id="line-379"><code>	}</code></span>
<span class="codeline" id="line-380"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-381"><code>		_, err = fmt.Fprintf(cw.res.conn.bufw, "%x\r\n", len(p))</code></span>
<span class="codeline" id="line-382"><code>		if err != nil {</code></span>
<span class="codeline" id="line-383"><code>			cw.res.conn.rwc.Close()</code></span>
<span class="codeline" id="line-384"><code>			return</code></span>
<span class="codeline" id="line-385"><code>		}</code></span>
<span class="codeline" id="line-386"><code>	}</code></span>
<span class="codeline" id="line-387"><code>	n, err = cw.res.conn.bufw.Write(p)</code></span>
<span class="codeline" id="line-388"><code>	if cw.chunking &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-389"><code>		_, err = cw.res.conn.bufw.Write(crlf)</code></span>
<span class="codeline" id="line-390"><code>	}</code></span>
<span class="codeline" id="line-391"><code>	if err != nil {</code></span>
<span class="codeline" id="line-392"><code>		cw.res.conn.rwc.Close()</code></span>
<span class="codeline" id="line-393"><code>	}</code></span>
<span class="codeline" id="line-394"><code>	return</code></span>
<span class="codeline" id="line-395"><code>}</code></span>
<span class="codeline" id="line-396"><code></code></span>
<span class="codeline" id="line-397"><code>func (cw *chunkWriter) flush() error {</code></span>
<span class="codeline" id="line-398"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-399"><code>		cw.writeHeader(nil)</code></span>
<span class="codeline" id="line-400"><code>	}</code></span>
<span class="codeline" id="line-401"><code>	return cw.res.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-402"><code>}</code></span>
<span class="codeline" id="line-403"><code></code></span>
<span class="codeline" id="line-404"><code>func (cw *chunkWriter) close() {</code></span>
<span class="codeline" id="line-405"><code>	if !cw.wroteHeader {</code></span>
<span class="codeline" id="line-406"><code>		cw.writeHeader(nil)</code></span>
<span class="codeline" id="line-407"><code>	}</code></span>
<span class="codeline" id="line-408"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-409"><code>		bw := cw.res.conn.bufw // conn's bufio writer</code></span>
<span class="codeline" id="line-410"><code>		// zero chunk to mark EOF</code></span>
<span class="codeline" id="line-411"><code>		bw.WriteString("0\r\n")</code></span>
<span class="codeline" id="line-412"><code>		if trailers := cw.res.finalTrailers(); trailers != nil {</code></span>
<span class="codeline" id="line-413"><code>			trailers.Write(bw) // the writer handles noting errors</code></span>
<span class="codeline" id="line-414"><code>		}</code></span>
<span class="codeline" id="line-415"><code>		// final blank line after the trailers (whether</code></span>
<span class="codeline" id="line-416"><code>		// present or not)</code></span>
<span class="codeline" id="line-417"><code>		bw.WriteString("\r\n")</code></span>
<span class="codeline" id="line-418"><code>	}</code></span>
<span class="codeline" id="line-419"><code>}</code></span>
<span class="codeline" id="line-420"><code></code></span>
<span class="codeline" id="line-421"><code>// A response represents the server side of an HTTP response.</code></span>
<span class="codeline" id="line-422"><code>type response struct {</code></span>
<span class="codeline" id="line-423"><code>	conn             *conn</code></span>
<span class="codeline" id="line-424"><code>	req              *Request // request for this response</code></span>
<span class="codeline" id="line-425"><code>	reqBody          io.ReadCloser</code></span>
<span class="codeline" id="line-426"><code>	cancelCtx        context.CancelFunc // when ServeHTTP exits</code></span>
<span class="codeline" id="line-427"><code>	wroteHeader      bool               // a non-1xx header has been (logically) written</code></span>
<span class="codeline" id="line-428"><code>	wroteContinue    bool               // 100 Continue response was written</code></span>
<span class="codeline" id="line-429"><code>	wants10KeepAlive bool               // HTTP/1.0 w/ Connection "keep-alive"</code></span>
<span class="codeline" id="line-430"><code>	wantsClose       bool               // HTTP request has Connection "close"</code></span>
<span class="codeline" id="line-431"><code></code></span>
<span class="codeline" id="line-432"><code>	// canWriteContinue is an atomic boolean that says whether or</code></span>
<span class="codeline" id="line-433"><code>	// not a 100 Continue header can be written to the</code></span>
<span class="codeline" id="line-434"><code>	// connection.</code></span>
<span class="codeline" id="line-435"><code>	// writeContinueMu must be held while writing the header.</code></span>
<span class="codeline" id="line-436"><code>	// These two fields together synchronize the body reader (the</code></span>
<span class="codeline" id="line-437"><code>	// expectContinueReader, which wants to write 100 Continue)</code></span>
<span class="codeline" id="line-438"><code>	// against the main writer.</code></span>
<span class="codeline" id="line-439"><code>	canWriteContinue atomic.Bool</code></span>
<span class="codeline" id="line-440"><code>	writeContinueMu  sync.Mutex</code></span>
<span class="codeline" id="line-441"><code></code></span>
<span class="codeline" id="line-442"><code>	w  *bufio.Writer // buffers output in chunks to chunkWriter</code></span>
<span class="codeline" id="line-443"><code>	cw chunkWriter</code></span>
<span class="codeline" id="line-444"><code></code></span>
<span class="codeline" id="line-445"><code>	// handlerHeader is the Header that Handlers get access to,</code></span>
<span class="codeline" id="line-446"><code>	// which may be retained and mutated even after WriteHeader.</code></span>
<span class="codeline" id="line-447"><code>	// handlerHeader is copied into cw.header at WriteHeader</code></span>
<span class="codeline" id="line-448"><code>	// time, and privately mutated thereafter.</code></span>
<span class="codeline" id="line-449"><code>	handlerHeader Header</code></span>
<span class="codeline" id="line-450"><code>	calledHeader  bool // handler accessed handlerHeader via Header</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>	written       int64 // number of bytes written in body</code></span>
<span class="codeline" id="line-453"><code>	contentLength int64 // explicitly-declared Content-Length; or -1</code></span>
<span class="codeline" id="line-454"><code>	status        int   // status code passed to WriteHeader</code></span>
<span class="codeline" id="line-455"><code></code></span>
<span class="codeline" id="line-456"><code>	// close connection after this reply.  set on request and</code></span>
<span class="codeline" id="line-457"><code>	// updated after response from handler if there's a</code></span>
<span class="codeline" id="line-458"><code>	// "Connection: keep-alive" response header and a</code></span>
<span class="codeline" id="line-459"><code>	// Content-Length.</code></span>
<span class="codeline" id="line-460"><code>	closeAfterReply bool</code></span>
<span class="codeline" id="line-461"><code></code></span>
<span class="codeline" id="line-462"><code>	// When fullDuplex is false (the default), we consume any remaining</code></span>
<span class="codeline" id="line-463"><code>	// request body before starting to write a response.</code></span>
<span class="codeline" id="line-464"><code>	fullDuplex bool</code></span>
<span class="codeline" id="line-465"><code></code></span>
<span class="codeline" id="line-466"><code>	// requestBodyLimitHit is set by requestTooLarge when</code></span>
<span class="codeline" id="line-467"><code>	// maxBytesReader hits its max size. It is checked in</code></span>
<span class="codeline" id="line-468"><code>	// WriteHeader, to make sure we don't consume the</code></span>
<span class="codeline" id="line-469"><code>	// remaining request body to try to advance to the next HTTP</code></span>
<span class="codeline" id="line-470"><code>	// request. Instead, when this is set, we stop reading</code></span>
<span class="codeline" id="line-471"><code>	// subsequent requests on this connection and stop reading</code></span>
<span class="codeline" id="line-472"><code>	// input from it.</code></span>
<span class="codeline" id="line-473"><code>	requestBodyLimitHit bool</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>	// trailers are the headers to be sent after the handler</code></span>
<span class="codeline" id="line-476"><code>	// finishes writing the body. This field is initialized from</code></span>
<span class="codeline" id="line-477"><code>	// the Trailer response header when the response header is</code></span>
<span class="codeline" id="line-478"><code>	// written.</code></span>
<span class="codeline" id="line-479"><code>	trailers []string</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>	handlerDone atomic.Bool // set true when the handler exits</code></span>
<span class="codeline" id="line-482"><code></code></span>
<span class="codeline" id="line-483"><code>	// Buffers for Date, Content-Length, and status code</code></span>
<span class="codeline" id="line-484"><code>	dateBuf   [len(TimeFormat)]byte</code></span>
<span class="codeline" id="line-485"><code>	clenBuf   [10]byte</code></span>
<span class="codeline" id="line-486"><code>	statusBuf [3]byte</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>	// closeNotifyCh is the channel returned by CloseNotify.</code></span>
<span class="codeline" id="line-489"><code>	// TODO(bradfitz): this is currently (for Go 1.8) always</code></span>
<span class="codeline" id="line-490"><code>	// non-nil. Make this lazily-created again as it used to be?</code></span>
<span class="codeline" id="line-491"><code>	closeNotifyCh  chan bool</code></span>
<span class="codeline" id="line-492"><code>	didCloseNotify atomic.Bool // atomic (only false-&gt;true winner should send)</code></span>
<span class="codeline" id="line-493"><code>}</code></span>
<span class="codeline" id="line-494"><code></code></span>
<span class="codeline" id="line-495"><code>func (c *response) SetReadDeadline(deadline time.Time) error {</code></span>
<span class="codeline" id="line-496"><code>	return c.conn.rwc.SetReadDeadline(deadline)</code></span>
<span class="codeline" id="line-497"><code>}</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>func (c *response) SetWriteDeadline(deadline time.Time) error {</code></span>
<span class="codeline" id="line-500"><code>	return c.conn.rwc.SetWriteDeadline(deadline)</code></span>
<span class="codeline" id="line-501"><code>}</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>func (c *response) EnableFullDuplex() error {</code></span>
<span class="codeline" id="line-504"><code>	c.fullDuplex = true</code></span>
<span class="codeline" id="line-505"><code>	return nil</code></span>
<span class="codeline" id="line-506"><code>}</code></span>
<span class="codeline" id="line-507"><code></code></span>
<span class="codeline" id="line-508"><code>// TrailerPrefix is a magic prefix for [ResponseWriter.Header] map keys</code></span>
<span class="codeline" id="line-509"><code>// that, if present, signals that the map entry is actually for</code></span>
<span class="codeline" id="line-510"><code>// the response trailers, and not the response headers. The prefix</code></span>
<span class="codeline" id="line-511"><code>// is stripped after the ServeHTTP call finishes and the values are</code></span>
<span class="codeline" id="line-512"><code>// sent in the trailers.</code></span>
<span class="codeline" id="line-513"><code>//</code></span>
<span class="codeline" id="line-514"><code>// This mechanism is intended only for trailers that are not known</code></span>
<span class="codeline" id="line-515"><code>// prior to the headers being written. If the set of trailers is fixed</code></span>
<span class="codeline" id="line-516"><code>// or known before the header is written, the normal Go trailers mechanism</code></span>
<span class="codeline" id="line-517"><code>// is preferred:</code></span>
<span class="codeline" id="line-518"><code>//</code></span>
<span class="codeline" id="line-519"><code>//	https://pkg.go.dev/net/http#ResponseWriter</code></span>
<span class="codeline" id="line-520"><code>//	https://pkg.go.dev/net/http#example-ResponseWriter-Trailers</code></span>
<span class="codeline" id="line-521"><code>const TrailerPrefix = "Trailer:"</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>// finalTrailers is called after the Handler exits and returns a non-nil</code></span>
<span class="codeline" id="line-524"><code>// value if the Handler set any trailers.</code></span>
<span class="codeline" id="line-525"><code>func (w *response) finalTrailers() Header {</code></span>
<span class="codeline" id="line-526"><code>	var t Header</code></span>
<span class="codeline" id="line-527"><code>	for k, vv := range w.handlerHeader {</code></span>
<span class="codeline" id="line-528"><code>		if kk, found := strings.CutPrefix(k, TrailerPrefix); found {</code></span>
<span class="codeline" id="line-529"><code>			if t == nil {</code></span>
<span class="codeline" id="line-530"><code>				t = make(Header)</code></span>
<span class="codeline" id="line-531"><code>			}</code></span>
<span class="codeline" id="line-532"><code>			t[kk] = vv</code></span>
<span class="codeline" id="line-533"><code>		}</code></span>
<span class="codeline" id="line-534"><code>	}</code></span>
<span class="codeline" id="line-535"><code>	for _, k := range w.trailers {</code></span>
<span class="codeline" id="line-536"><code>		if t == nil {</code></span>
<span class="codeline" id="line-537"><code>			t = make(Header)</code></span>
<span class="codeline" id="line-538"><code>		}</code></span>
<span class="codeline" id="line-539"><code>		for _, v := range w.handlerHeader[k] {</code></span>
<span class="codeline" id="line-540"><code>			t.Add(k, v)</code></span>
<span class="codeline" id="line-541"><code>		}</code></span>
<span class="codeline" id="line-542"><code>	}</code></span>
<span class="codeline" id="line-543"><code>	return t</code></span>
<span class="codeline" id="line-544"><code>}</code></span>
<span class="codeline" id="line-545"><code></code></span>
<span class="codeline" id="line-546"><code>// declareTrailer is called for each Trailer header when the</code></span>
<span class="codeline" id="line-547"><code>// response header is written. It notes that a header will need to be</code></span>
<span class="codeline" id="line-548"><code>// written in the trailers at the end of the response.</code></span>
<span class="codeline" id="line-549"><code>func (w *response) declareTrailer(k string) {</code></span>
<span class="codeline" id="line-550"><code>	k = CanonicalHeaderKey(k)</code></span>
<span class="codeline" id="line-551"><code>	if !httpguts.ValidTrailerHeader(k) {</code></span>
<span class="codeline" id="line-552"><code>		// Forbidden by RFC 7230, section 4.1.2</code></span>
<span class="codeline" id="line-553"><code>		return</code></span>
<span class="codeline" id="line-554"><code>	}</code></span>
<span class="codeline" id="line-555"><code>	w.trailers = append(w.trailers, k)</code></span>
<span class="codeline" id="line-556"><code>}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>// requestTooLarge is called by maxBytesReader when too much input has</code></span>
<span class="codeline" id="line-559"><code>// been read from the client.</code></span>
<span class="codeline" id="line-560"><code>func (w *response) requestTooLarge() {</code></span>
<span class="codeline" id="line-561"><code>	w.closeAfterReply = true</code></span>
<span class="codeline" id="line-562"><code>	w.requestBodyLimitHit = true</code></span>
<span class="codeline" id="line-563"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-564"><code>		w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-565"><code>	}</code></span>
<span class="codeline" id="line-566"><code>}</code></span>
<span class="codeline" id="line-567"><code></code></span>
<span class="codeline" id="line-568"><code>// writerOnly hides an io.Writer value's optional ReadFrom method</code></span>
<span class="codeline" id="line-569"><code>// from io.Copy.</code></span>
<span class="codeline" id="line-570"><code>type writerOnly struct {</code></span>
<span class="codeline" id="line-571"><code>	io.Writer</code></span>
<span class="codeline" id="line-572"><code>}</code></span>
<span class="codeline" id="line-573"><code></code></span>
<span class="codeline" id="line-574"><code>// ReadFrom is here to optimize copying from an [*os.File] regular file</code></span>
<span class="codeline" id="line-575"><code>// to a [*net.TCPConn] with sendfile, or from a supported src type such</code></span>
<span class="codeline" id="line-576"><code>// as a *net.TCPConn on Linux with splice.</code></span>
<span class="codeline" id="line-577"><code>func (w *response) ReadFrom(src io.Reader) (n int64, err error) {</code></span>
<span class="codeline" id="line-578"><code>	buf := getCopyBuf()</code></span>
<span class="codeline" id="line-579"><code>	defer putCopyBuf(buf)</code></span>
<span class="codeline" id="line-580"><code></code></span>
<span class="codeline" id="line-581"><code>	// Our underlying w.conn.rwc is usually a *TCPConn (with its</code></span>
<span class="codeline" id="line-582"><code>	// own ReadFrom method). If not, just fall back to the normal</code></span>
<span class="codeline" id="line-583"><code>	// copy method.</code></span>
<span class="codeline" id="line-584"><code>	rf, ok := w.conn.rwc.(io.ReaderFrom)</code></span>
<span class="codeline" id="line-585"><code>	if !ok {</code></span>
<span class="codeline" id="line-586"><code>		return io.CopyBuffer(writerOnly{w}, src, buf)</code></span>
<span class="codeline" id="line-587"><code>	}</code></span>
<span class="codeline" id="line-588"><code></code></span>
<span class="codeline" id="line-589"><code>	// Copy the first sniffLen bytes before switching to ReadFrom.</code></span>
<span class="codeline" id="line-590"><code>	// This ensures we don't start writing the response before the</code></span>
<span class="codeline" id="line-591"><code>	// source is available (see golang.org/issue/5660) and provides</code></span>
<span class="codeline" id="line-592"><code>	// enough bytes to perform Content-Type sniffing when required.</code></span>
<span class="codeline" id="line-593"><code>	if !w.cw.wroteHeader {</code></span>
<span class="codeline" id="line-594"><code>		n0, err := io.CopyBuffer(writerOnly{w}, io.LimitReader(src, sniffLen), buf)</code></span>
<span class="codeline" id="line-595"><code>		n += n0</code></span>
<span class="codeline" id="line-596"><code>		if err != nil || n0 &lt; sniffLen {</code></span>
<span class="codeline" id="line-597"><code>			return n, err</code></span>
<span class="codeline" id="line-598"><code>		}</code></span>
<span class="codeline" id="line-599"><code>	}</code></span>
<span class="codeline" id="line-600"><code></code></span>
<span class="codeline" id="line-601"><code>	w.w.Flush()  // get rid of any previous writes</code></span>
<span class="codeline" id="line-602"><code>	w.cw.flush() // make sure Header is written; flush data to rwc</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>	// Now that cw has been flushed, its chunking field is guaranteed initialized.</code></span>
<span class="codeline" id="line-605"><code>	if !w.cw.chunking &amp;&amp; w.bodyAllowed() {</code></span>
<span class="codeline" id="line-606"><code>		n0, err := rf.ReadFrom(src)</code></span>
<span class="codeline" id="line-607"><code>		n += n0</code></span>
<span class="codeline" id="line-608"><code>		w.written += n0</code></span>
<span class="codeline" id="line-609"><code>		return n, err</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code></code></span>
<span class="codeline" id="line-612"><code>	n0, err := io.CopyBuffer(writerOnly{w}, src, buf)</code></span>
<span class="codeline" id="line-613"><code>	n += n0</code></span>
<span class="codeline" id="line-614"><code>	return n, err</code></span>
<span class="codeline" id="line-615"><code>}</code></span>
<span class="codeline" id="line-616"><code></code></span>
<span class="codeline" id="line-617"><code>// debugServerConnections controls whether all server connections are wrapped</code></span>
<span class="codeline" id="line-618"><code>// with a verbose logging wrapper.</code></span>
<span class="codeline" id="line-619"><code>const debugServerConnections = false</code></span>
<span class="codeline" id="line-620"><code></code></span>
<span class="codeline" id="line-621"><code>// Create new connection from rwc.</code></span>
<span class="codeline" id="line-622"><code>func (srv *Server) newConn(rwc net.Conn) *conn {</code></span>
<span class="codeline" id="line-623"><code>	c := &amp;conn{</code></span>
<span class="codeline" id="line-624"><code>		server: srv,</code></span>
<span class="codeline" id="line-625"><code>		rwc:    rwc,</code></span>
<span class="codeline" id="line-626"><code>	}</code></span>
<span class="codeline" id="line-627"><code>	if debugServerConnections {</code></span>
<span class="codeline" id="line-628"><code>		c.rwc = newLoggingConn("server", c.rwc)</code></span>
<span class="codeline" id="line-629"><code>	}</code></span>
<span class="codeline" id="line-630"><code>	return c</code></span>
<span class="codeline" id="line-631"><code>}</code></span>
<span class="codeline" id="line-632"><code></code></span>
<span class="codeline" id="line-633"><code>type readResult struct {</code></span>
<span class="codeline" id="line-634"><code>	_   incomparable</code></span>
<span class="codeline" id="line-635"><code>	n   int</code></span>
<span class="codeline" id="line-636"><code>	err error</code></span>
<span class="codeline" id="line-637"><code>	b   byte // byte read, if n == 1</code></span>
<span class="codeline" id="line-638"><code>}</code></span>
<span class="codeline" id="line-639"><code></code></span>
<span class="codeline" id="line-640"><code>// connReader is the io.Reader wrapper used by *conn. It combines a</code></span>
<span class="codeline" id="line-641"><code>// selectively-activated io.LimitedReader (to bound request header</code></span>
<span class="codeline" id="line-642"><code>// read sizes) with support for selectively keeping an io.Reader.Read</code></span>
<span class="codeline" id="line-643"><code>// call blocked in a background goroutine to wait for activity and</code></span>
<span class="codeline" id="line-644"><code>// trigger a CloseNotifier channel.</code></span>
<span class="codeline" id="line-645"><code>type connReader struct {</code></span>
<span class="codeline" id="line-646"><code>	conn *conn</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>	mu      sync.Mutex // guards following</code></span>
<span class="codeline" id="line-649"><code>	hasByte bool</code></span>
<span class="codeline" id="line-650"><code>	byteBuf [1]byte</code></span>
<span class="codeline" id="line-651"><code>	cond    *sync.Cond</code></span>
<span class="codeline" id="line-652"><code>	inRead  bool</code></span>
<span class="codeline" id="line-653"><code>	aborted bool  // set true before conn.rwc deadline is set to past</code></span>
<span class="codeline" id="line-654"><code>	remain  int64 // bytes remaining</code></span>
<span class="codeline" id="line-655"><code>}</code></span>
<span class="codeline" id="line-656"><code></code></span>
<span class="codeline" id="line-657"><code>func (cr *connReader) lock() {</code></span>
<span class="codeline" id="line-658"><code>	cr.mu.Lock()</code></span>
<span class="codeline" id="line-659"><code>	if cr.cond == nil {</code></span>
<span class="codeline" id="line-660"><code>		cr.cond = sync.NewCond(&amp;cr.mu)</code></span>
<span class="codeline" id="line-661"><code>	}</code></span>
<span class="codeline" id="line-662"><code>}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>func (cr *connReader) unlock() { cr.mu.Unlock() }</code></span>
<span class="codeline" id="line-665"><code></code></span>
<span class="codeline" id="line-666"><code>func (cr *connReader) startBackgroundRead() {</code></span>
<span class="codeline" id="line-667"><code>	cr.lock()</code></span>
<span class="codeline" id="line-668"><code>	defer cr.unlock()</code></span>
<span class="codeline" id="line-669"><code>	if cr.inRead {</code></span>
<span class="codeline" id="line-670"><code>		panic("invalid concurrent Body.Read call")</code></span>
<span class="codeline" id="line-671"><code>	}</code></span>
<span class="codeline" id="line-672"><code>	if cr.hasByte {</code></span>
<span class="codeline" id="line-673"><code>		return</code></span>
<span class="codeline" id="line-674"><code>	}</code></span>
<span class="codeline" id="line-675"><code>	cr.inRead = true</code></span>
<span class="codeline" id="line-676"><code>	cr.conn.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-677"><code>	go cr.backgroundRead()</code></span>
<span class="codeline" id="line-678"><code>}</code></span>
<span class="codeline" id="line-679"><code></code></span>
<span class="codeline" id="line-680"><code>func (cr *connReader) backgroundRead() {</code></span>
<span class="codeline" id="line-681"><code>	n, err := cr.conn.rwc.Read(cr.byteBuf[:])</code></span>
<span class="codeline" id="line-682"><code>	cr.lock()</code></span>
<span class="codeline" id="line-683"><code>	if n == 1 {</code></span>
<span class="codeline" id="line-684"><code>		cr.hasByte = true</code></span>
<span class="codeline" id="line-685"><code>		// We were past the end of the previous request's body already</code></span>
<span class="codeline" id="line-686"><code>		// (since we wouldn't be in a background read otherwise), so</code></span>
<span class="codeline" id="line-687"><code>		// this is a pipelined HTTP request. Prior to Go 1.11 we used to</code></span>
<span class="codeline" id="line-688"><code>		// send on the CloseNotify channel and cancel the context here,</code></span>
<span class="codeline" id="line-689"><code>		// but the behavior was documented as only "may", and we only</code></span>
<span class="codeline" id="line-690"><code>		// did that because that's how CloseNotify accidentally behaved</code></span>
<span class="codeline" id="line-691"><code>		// in very early Go releases prior to context support. Once we</code></span>
<span class="codeline" id="line-692"><code>		// added context support, people used a Handler's</code></span>
<span class="codeline" id="line-693"><code>		// Request.Context() and passed it along. Having that context</code></span>
<span class="codeline" id="line-694"><code>		// cancel on pipelined HTTP requests caused problems.</code></span>
<span class="codeline" id="line-695"><code>		// Fortunately, almost nothing uses HTTP/1.x pipelining.</code></span>
<span class="codeline" id="line-696"><code>		// Unfortunately, apt-get does, or sometimes does.</code></span>
<span class="codeline" id="line-697"><code>		// New Go 1.11 behavior: don't fire CloseNotify or cancel</code></span>
<span class="codeline" id="line-698"><code>		// contexts on pipelined requests. Shouldn't affect people, but</code></span>
<span class="codeline" id="line-699"><code>		// fixes cases like Issue 23921. This does mean that a client</code></span>
<span class="codeline" id="line-700"><code>		// closing their TCP connection after sending a pipelined</code></span>
<span class="codeline" id="line-701"><code>		// request won't cancel the context, but we'll catch that on any</code></span>
<span class="codeline" id="line-702"><code>		// write failure (in checkConnErrorWriter.Write).</code></span>
<span class="codeline" id="line-703"><code>		// If the server never writes, yes, there are still contrived</code></span>
<span class="codeline" id="line-704"><code>		// server &amp; client behaviors where this fails to ever cancel the</code></span>
<span class="codeline" id="line-705"><code>		// context, but that's kinda why HTTP/1.x pipelining died</code></span>
<span class="codeline" id="line-706"><code>		// anyway.</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	if ne, ok := err.(net.Error); ok &amp;&amp; cr.aborted &amp;&amp; ne.Timeout() {</code></span>
<span class="codeline" id="line-709"><code>		// Ignore this error. It's the expected error from</code></span>
<span class="codeline" id="line-710"><code>		// another goroutine calling abortPendingRead.</code></span>
<span class="codeline" id="line-711"><code>	} else if err != nil {</code></span>
<span class="codeline" id="line-712"><code>		cr.handleReadError(err)</code></span>
<span class="codeline" id="line-713"><code>	}</code></span>
<span class="codeline" id="line-714"><code>	cr.aborted = false</code></span>
<span class="codeline" id="line-715"><code>	cr.inRead = false</code></span>
<span class="codeline" id="line-716"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-717"><code>	cr.cond.Broadcast()</code></span>
<span class="codeline" id="line-718"><code>}</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>func (cr *connReader) abortPendingRead() {</code></span>
<span class="codeline" id="line-721"><code>	cr.lock()</code></span>
<span class="codeline" id="line-722"><code>	defer cr.unlock()</code></span>
<span class="codeline" id="line-723"><code>	if !cr.inRead {</code></span>
<span class="codeline" id="line-724"><code>		return</code></span>
<span class="codeline" id="line-725"><code>	}</code></span>
<span class="codeline" id="line-726"><code>	cr.aborted = true</code></span>
<span class="codeline" id="line-727"><code>	cr.conn.rwc.SetReadDeadline(aLongTimeAgo)</code></span>
<span class="codeline" id="line-728"><code>	for cr.inRead {</code></span>
<span class="codeline" id="line-729"><code>		cr.cond.Wait()</code></span>
<span class="codeline" id="line-730"><code>	}</code></span>
<span class="codeline" id="line-731"><code>	cr.conn.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-732"><code>}</code></span>
<span class="codeline" id="line-733"><code></code></span>
<span class="codeline" id="line-734"><code>func (cr *connReader) setReadLimit(remain int64) { cr.remain = remain }</code></span>
<span class="codeline" id="line-735"><code>func (cr *connReader) setInfiniteReadLimit()     { cr.remain = maxInt64 }</code></span>
<span class="codeline" id="line-736"><code>func (cr *connReader) hitReadLimit() bool        { return cr.remain &lt;= 0 }</code></span>
<span class="codeline" id="line-737"><code></code></span>
<span class="codeline" id="line-738"><code>// handleReadError is called whenever a Read from the client returns a</code></span>
<span class="codeline" id="line-739"><code>// non-nil error.</code></span>
<span class="codeline" id="line-740"><code>//</code></span>
<span class="codeline" id="line-741"><code>// The provided non-nil err is almost always io.EOF or a "use of</code></span>
<span class="codeline" id="line-742"><code>// closed network connection". In any case, the error is not</code></span>
<span class="codeline" id="line-743"><code>// particularly interesting, except perhaps for debugging during</code></span>
<span class="codeline" id="line-744"><code>// development. Any error means the connection is dead and we should</code></span>
<span class="codeline" id="line-745"><code>// down its context.</code></span>
<span class="codeline" id="line-746"><code>//</code></span>
<span class="codeline" id="line-747"><code>// It may be called from multiple goroutines.</code></span>
<span class="codeline" id="line-748"><code>func (cr *connReader) handleReadError(_ error) {</code></span>
<span class="codeline" id="line-749"><code>	cr.conn.cancelCtx()</code></span>
<span class="codeline" id="line-750"><code>	cr.closeNotify()</code></span>
<span class="codeline" id="line-751"><code>}</code></span>
<span class="codeline" id="line-752"><code></code></span>
<span class="codeline" id="line-753"><code>// may be called from multiple goroutines.</code></span>
<span class="codeline" id="line-754"><code>func (cr *connReader) closeNotify() {</code></span>
<span class="codeline" id="line-755"><code>	res := cr.conn.curReq.Load()</code></span>
<span class="codeline" id="line-756"><code>	if res != nil &amp;&amp; !res.didCloseNotify.Swap(true) {</code></span>
<span class="codeline" id="line-757"><code>		res.closeNotifyCh &lt;- true</code></span>
<span class="codeline" id="line-758"><code>	}</code></span>
<span class="codeline" id="line-759"><code>}</code></span>
<span class="codeline" id="line-760"><code></code></span>
<span class="codeline" id="line-761"><code>func (cr *connReader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-762"><code>	cr.lock()</code></span>
<span class="codeline" id="line-763"><code>	if cr.inRead {</code></span>
<span class="codeline" id="line-764"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-765"><code>		if cr.conn.hijacked() {</code></span>
<span class="codeline" id="line-766"><code>			panic("invalid Body.Read call. After hijacked, the original Request must not be used")</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code>		panic("invalid concurrent Body.Read call")</code></span>
<span class="codeline" id="line-769"><code>	}</code></span>
<span class="codeline" id="line-770"><code>	if cr.hitReadLimit() {</code></span>
<span class="codeline" id="line-771"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-772"><code>		return 0, io.EOF</code></span>
<span class="codeline" id="line-773"><code>	}</code></span>
<span class="codeline" id="line-774"><code>	if len(p) == 0 {</code></span>
<span class="codeline" id="line-775"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-776"><code>		return 0, nil</code></span>
<span class="codeline" id="line-777"><code>	}</code></span>
<span class="codeline" id="line-778"><code>	if int64(len(p)) &gt; cr.remain {</code></span>
<span class="codeline" id="line-779"><code>		p = p[:cr.remain]</code></span>
<span class="codeline" id="line-780"><code>	}</code></span>
<span class="codeline" id="line-781"><code>	if cr.hasByte {</code></span>
<span class="codeline" id="line-782"><code>		p[0] = cr.byteBuf[0]</code></span>
<span class="codeline" id="line-783"><code>		cr.hasByte = false</code></span>
<span class="codeline" id="line-784"><code>		cr.unlock()</code></span>
<span class="codeline" id="line-785"><code>		return 1, nil</code></span>
<span class="codeline" id="line-786"><code>	}</code></span>
<span class="codeline" id="line-787"><code>	cr.inRead = true</code></span>
<span class="codeline" id="line-788"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-789"><code>	n, err = cr.conn.rwc.Read(p)</code></span>
<span class="codeline" id="line-790"><code></code></span>
<span class="codeline" id="line-791"><code>	cr.lock()</code></span>
<span class="codeline" id="line-792"><code>	cr.inRead = false</code></span>
<span class="codeline" id="line-793"><code>	if err != nil {</code></span>
<span class="codeline" id="line-794"><code>		cr.handleReadError(err)</code></span>
<span class="codeline" id="line-795"><code>	}</code></span>
<span class="codeline" id="line-796"><code>	cr.remain -= int64(n)</code></span>
<span class="codeline" id="line-797"><code>	cr.unlock()</code></span>
<span class="codeline" id="line-798"><code></code></span>
<span class="codeline" id="line-799"><code>	cr.cond.Broadcast()</code></span>
<span class="codeline" id="line-800"><code>	return n, err</code></span>
<span class="codeline" id="line-801"><code>}</code></span>
<span class="codeline" id="line-802"><code></code></span>
<span class="codeline" id="line-803"><code>var (</code></span>
<span class="codeline" id="line-804"><code>	bufioReaderPool   sync.Pool</code></span>
<span class="codeline" id="line-805"><code>	bufioWriter2kPool sync.Pool</code></span>
<span class="codeline" id="line-806"><code>	bufioWriter4kPool sync.Pool</code></span>
<span class="codeline" id="line-807"><code>)</code></span>
<span class="codeline" id="line-808"><code></code></span>
<span class="codeline" id="line-809"><code>const copyBufPoolSize = 32 * 1024</code></span>
<span class="codeline" id="line-810"><code></code></span>
<span class="codeline" id="line-811"><code>var copyBufPool = sync.Pool{New: func() any { return new([copyBufPoolSize]byte) }}</code></span>
<span class="codeline" id="line-812"><code></code></span>
<span class="codeline" id="line-813"><code>func getCopyBuf() []byte {</code></span>
<span class="codeline" id="line-814"><code>	return copyBufPool.Get().(*[copyBufPoolSize]byte)[:]</code></span>
<span class="codeline" id="line-815"><code>}</code></span>
<span class="codeline" id="line-816"><code>func putCopyBuf(b []byte) {</code></span>
<span class="codeline" id="line-817"><code>	if len(b) != copyBufPoolSize {</code></span>
<span class="codeline" id="line-818"><code>		panic("trying to put back buffer of the wrong size in the copyBufPool")</code></span>
<span class="codeline" id="line-819"><code>	}</code></span>
<span class="codeline" id="line-820"><code>	copyBufPool.Put((*[copyBufPoolSize]byte)(b))</code></span>
<span class="codeline" id="line-821"><code>}</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>func bufioWriterPool(size int) *sync.Pool {</code></span>
<span class="codeline" id="line-824"><code>	switch size {</code></span>
<span class="codeline" id="line-825"><code>	case 2 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-826"><code>		return &amp;bufioWriter2kPool</code></span>
<span class="codeline" id="line-827"><code>	case 4 &lt;&lt; 10:</code></span>
<span class="codeline" id="line-828"><code>		return &amp;bufioWriter4kPool</code></span>
<span class="codeline" id="line-829"><code>	}</code></span>
<span class="codeline" id="line-830"><code>	return nil</code></span>
<span class="codeline" id="line-831"><code>}</code></span>
<span class="codeline" id="line-832"><code></code></span>
<span class="codeline" id="line-833"><code>func newBufioReader(r io.Reader) *bufio.Reader {</code></span>
<span class="codeline" id="line-834"><code>	if v := bufioReaderPool.Get(); v != nil {</code></span>
<span class="codeline" id="line-835"><code>		br := v.(*bufio.Reader)</code></span>
<span class="codeline" id="line-836"><code>		br.Reset(r)</code></span>
<span class="codeline" id="line-837"><code>		return br</code></span>
<span class="codeline" id="line-838"><code>	}</code></span>
<span class="codeline" id="line-839"><code>	// Note: if this reader size is ever changed, update</code></span>
<span class="codeline" id="line-840"><code>	// TestHandlerBodyClose's assumptions.</code></span>
<span class="codeline" id="line-841"><code>	return bufio.NewReader(r)</code></span>
<span class="codeline" id="line-842"><code>}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>func putBufioReader(br *bufio.Reader) {</code></span>
<span class="codeline" id="line-845"><code>	br.Reset(nil)</code></span>
<span class="codeline" id="line-846"><code>	bufioReaderPool.Put(br)</code></span>
<span class="codeline" id="line-847"><code>}</code></span>
<span class="codeline" id="line-848"><code></code></span>
<span class="codeline" id="line-849"><code>func newBufioWriterSize(w io.Writer, size int) *bufio.Writer {</code></span>
<span class="codeline" id="line-850"><code>	pool := bufioWriterPool(size)</code></span>
<span class="codeline" id="line-851"><code>	if pool != nil {</code></span>
<span class="codeline" id="line-852"><code>		if v := pool.Get(); v != nil {</code></span>
<span class="codeline" id="line-853"><code>			bw := v.(*bufio.Writer)</code></span>
<span class="codeline" id="line-854"><code>			bw.Reset(w)</code></span>
<span class="codeline" id="line-855"><code>			return bw</code></span>
<span class="codeline" id="line-856"><code>		}</code></span>
<span class="codeline" id="line-857"><code>	}</code></span>
<span class="codeline" id="line-858"><code>	return bufio.NewWriterSize(w, size)</code></span>
<span class="codeline" id="line-859"><code>}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>func putBufioWriter(bw *bufio.Writer) {</code></span>
<span class="codeline" id="line-862"><code>	bw.Reset(nil)</code></span>
<span class="codeline" id="line-863"><code>	if pool := bufioWriterPool(bw.Available()); pool != nil {</code></span>
<span class="codeline" id="line-864"><code>		pool.Put(bw)</code></span>
<span class="codeline" id="line-865"><code>	}</code></span>
<span class="codeline" id="line-866"><code>}</code></span>
<span class="codeline" id="line-867"><code></code></span>
<span class="codeline" id="line-868"><code>// DefaultMaxHeaderBytes is the maximum permitted size of the headers</code></span>
<span class="codeline" id="line-869"><code>// in an HTTP request.</code></span>
<span class="codeline" id="line-870"><code>// This can be overridden by setting [Server.MaxHeaderBytes].</code></span>
<span class="codeline" id="line-871"><code>const DefaultMaxHeaderBytes = 1 &lt;&lt; 20 // 1 MB</code></span>
<span class="codeline" id="line-872"><code></code></span>
<span class="codeline" id="line-873"><code>func (srv *Server) maxHeaderBytes() int {</code></span>
<span class="codeline" id="line-874"><code>	if srv.MaxHeaderBytes &gt; 0 {</code></span>
<span class="codeline" id="line-875"><code>		return srv.MaxHeaderBytes</code></span>
<span class="codeline" id="line-876"><code>	}</code></span>
<span class="codeline" id="line-877"><code>	return DefaultMaxHeaderBytes</code></span>
<span class="codeline" id="line-878"><code>}</code></span>
<span class="codeline" id="line-879"><code></code></span>
<span class="codeline" id="line-880"><code>func (srv *Server) initialReadLimitSize() int64 {</code></span>
<span class="codeline" id="line-881"><code>	return int64(srv.maxHeaderBytes()) + 4096 // bufio slop</code></span>
<span class="codeline" id="line-882"><code>}</code></span>
<span class="codeline" id="line-883"><code></code></span>
<span class="codeline" id="line-884"><code>// tlsHandshakeTimeout returns the time limit permitted for the TLS</code></span>
<span class="codeline" id="line-885"><code>// handshake, or zero for unlimited.</code></span>
<span class="codeline" id="line-886"><code>//</code></span>
<span class="codeline" id="line-887"><code>// It returns the minimum of any positive ReadHeaderTimeout,</code></span>
<span class="codeline" id="line-888"><code>// ReadTimeout, or WriteTimeout.</code></span>
<span class="codeline" id="line-889"><code>func (srv *Server) tlsHandshakeTimeout() time.Duration {</code></span>
<span class="codeline" id="line-890"><code>	var ret time.Duration</code></span>
<span class="codeline" id="line-891"><code>	for _, v := range [...]time.Duration{</code></span>
<span class="codeline" id="line-892"><code>		srv.ReadHeaderTimeout,</code></span>
<span class="codeline" id="line-893"><code>		srv.ReadTimeout,</code></span>
<span class="codeline" id="line-894"><code>		srv.WriteTimeout,</code></span>
<span class="codeline" id="line-895"><code>	} {</code></span>
<span class="codeline" id="line-896"><code>		if v &lt;= 0 {</code></span>
<span class="codeline" id="line-897"><code>			continue</code></span>
<span class="codeline" id="line-898"><code>		}</code></span>
<span class="codeline" id="line-899"><code>		if ret == 0 || v &lt; ret {</code></span>
<span class="codeline" id="line-900"><code>			ret = v</code></span>
<span class="codeline" id="line-901"><code>		}</code></span>
<span class="codeline" id="line-902"><code>	}</code></span>
<span class="codeline" id="line-903"><code>	return ret</code></span>
<span class="codeline" id="line-904"><code>}</code></span>
<span class="codeline" id="line-905"><code></code></span>
<span class="codeline" id="line-906"><code>// wrapper around io.ReadCloser which on first read, sends an</code></span>
<span class="codeline" id="line-907"><code>// HTTP/1.1 100 Continue header</code></span>
<span class="codeline" id="line-908"><code>type expectContinueReader struct {</code></span>
<span class="codeline" id="line-909"><code>	resp       *response</code></span>
<span class="codeline" id="line-910"><code>	readCloser io.ReadCloser</code></span>
<span class="codeline" id="line-911"><code>	closed     atomic.Bool</code></span>
<span class="codeline" id="line-912"><code>	sawEOF     atomic.Bool</code></span>
<span class="codeline" id="line-913"><code>}</code></span>
<span class="codeline" id="line-914"><code></code></span>
<span class="codeline" id="line-915"><code>func (ecr *expectContinueReader) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-916"><code>	if ecr.closed.Load() {</code></span>
<span class="codeline" id="line-917"><code>		return 0, ErrBodyReadAfterClose</code></span>
<span class="codeline" id="line-918"><code>	}</code></span>
<span class="codeline" id="line-919"><code>	w := ecr.resp</code></span>
<span class="codeline" id="line-920"><code>	if !w.wroteContinue &amp;&amp; w.canWriteContinue.Load() &amp;&amp; !w.conn.hijacked() {</code></span>
<span class="codeline" id="line-921"><code>		w.wroteContinue = true</code></span>
<span class="codeline" id="line-922"><code>		w.writeContinueMu.Lock()</code></span>
<span class="codeline" id="line-923"><code>		if w.canWriteContinue.Load() {</code></span>
<span class="codeline" id="line-924"><code>			w.conn.bufw.WriteString("HTTP/1.1 100 Continue\r\n\r\n")</code></span>
<span class="codeline" id="line-925"><code>			w.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-926"><code>			w.canWriteContinue.Store(false)</code></span>
<span class="codeline" id="line-927"><code>		}</code></span>
<span class="codeline" id="line-928"><code>		w.writeContinueMu.Unlock()</code></span>
<span class="codeline" id="line-929"><code>	}</code></span>
<span class="codeline" id="line-930"><code>	n, err = ecr.readCloser.Read(p)</code></span>
<span class="codeline" id="line-931"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-932"><code>		ecr.sawEOF.Store(true)</code></span>
<span class="codeline" id="line-933"><code>	}</code></span>
<span class="codeline" id="line-934"><code>	return</code></span>
<span class="codeline" id="line-935"><code>}</code></span>
<span class="codeline" id="line-936"><code></code></span>
<span class="codeline" id="line-937"><code>func (ecr *expectContinueReader) Close() error {</code></span>
<span class="codeline" id="line-938"><code>	ecr.closed.Store(true)</code></span>
<span class="codeline" id="line-939"><code>	return ecr.readCloser.Close()</code></span>
<span class="codeline" id="line-940"><code>}</code></span>
<span class="codeline" id="line-941"><code></code></span>
<span class="codeline" id="line-942"><code>// TimeFormat is the time format to use when generating times in HTTP</code></span>
<span class="codeline" id="line-943"><code>// headers. It is like [time.RFC1123] but hard-codes GMT as the time</code></span>
<span class="codeline" id="line-944"><code>// zone. The time being formatted must be in UTC for Format to</code></span>
<span class="codeline" id="line-945"><code>// generate the correct format.</code></span>
<span class="codeline" id="line-946"><code>//</code></span>
<span class="codeline" id="line-947"><code>// For parsing this time format, see [ParseTime].</code></span>
<span class="codeline" id="line-948"><code>const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"</code></span>
<span class="codeline" id="line-949"><code></code></span>
<span class="codeline" id="line-950"><code>// appendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat))</code></span>
<span class="codeline" id="line-951"><code>func appendTime(b []byte, t time.Time) []byte {</code></span>
<span class="codeline" id="line-952"><code>	const days = "SunMonTueWedThuFriSat"</code></span>
<span class="codeline" id="line-953"><code>	const months = "JanFebMarAprMayJunJulAugSepOctNovDec"</code></span>
<span class="codeline" id="line-954"><code></code></span>
<span class="codeline" id="line-955"><code>	t = t.UTC()</code></span>
<span class="codeline" id="line-956"><code>	yy, mm, dd := t.Date()</code></span>
<span class="codeline" id="line-957"><code>	hh, mn, ss := t.Clock()</code></span>
<span class="codeline" id="line-958"><code>	day := days[3*t.Weekday():]</code></span>
<span class="codeline" id="line-959"><code>	mon := months[3*(mm-1):]</code></span>
<span class="codeline" id="line-960"><code></code></span>
<span class="codeline" id="line-961"><code>	return append(b,</code></span>
<span class="codeline" id="line-962"><code>		day[0], day[1], day[2], ',', ' ',</code></span>
<span class="codeline" id="line-963"><code>		byte('0'+dd/10), byte('0'+dd%10), ' ',</code></span>
<span class="codeline" id="line-964"><code>		mon[0], mon[1], mon[2], ' ',</code></span>
<span class="codeline" id="line-965"><code>		byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',</code></span>
<span class="codeline" id="line-966"><code>		byte('0'+hh/10), byte('0'+hh%10), ':',</code></span>
<span class="codeline" id="line-967"><code>		byte('0'+mn/10), byte('0'+mn%10), ':',</code></span>
<span class="codeline" id="line-968"><code>		byte('0'+ss/10), byte('0'+ss%10), ' ',</code></span>
<span class="codeline" id="line-969"><code>		'G', 'M', 'T')</code></span>
<span class="codeline" id="line-970"><code>}</code></span>
<span class="codeline" id="line-971"><code></code></span>
<span class="codeline" id="line-972"><code>var errTooLarge = errors.New("http: request too large")</code></span>
<span class="codeline" id="line-973"><code></code></span>
<span class="codeline" id="line-974"><code>// Read next request from connection.</code></span>
<span class="codeline" id="line-975"><code>func (c *conn) readRequest(ctx context.Context) (w *response, err error) {</code></span>
<span class="codeline" id="line-976"><code>	if c.hijacked() {</code></span>
<span class="codeline" id="line-977"><code>		return nil, ErrHijacked</code></span>
<span class="codeline" id="line-978"><code>	}</code></span>
<span class="codeline" id="line-979"><code></code></span>
<span class="codeline" id="line-980"><code>	var (</code></span>
<span class="codeline" id="line-981"><code>		wholeReqDeadline time.Time // or zero if none</code></span>
<span class="codeline" id="line-982"><code>		hdrDeadline      time.Time // or zero if none</code></span>
<span class="codeline" id="line-983"><code>	)</code></span>
<span class="codeline" id="line-984"><code>	t0 := time.Now()</code></span>
<span class="codeline" id="line-985"><code>	if d := c.server.readHeaderTimeout(); d &gt; 0 {</code></span>
<span class="codeline" id="line-986"><code>		hdrDeadline = t0.Add(d)</code></span>
<span class="codeline" id="line-987"><code>	}</code></span>
<span class="codeline" id="line-988"><code>	if d := c.server.ReadTimeout; d &gt; 0 {</code></span>
<span class="codeline" id="line-989"><code>		wholeReqDeadline = t0.Add(d)</code></span>
<span class="codeline" id="line-990"><code>	}</code></span>
<span class="codeline" id="line-991"><code>	c.rwc.SetReadDeadline(hdrDeadline)</code></span>
<span class="codeline" id="line-992"><code>	if d := c.server.WriteTimeout; d &gt; 0 {</code></span>
<span class="codeline" id="line-993"><code>		defer func() {</code></span>
<span class="codeline" id="line-994"><code>			c.rwc.SetWriteDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-995"><code>		}()</code></span>
<span class="codeline" id="line-996"><code>	}</code></span>
<span class="codeline" id="line-997"><code></code></span>
<span class="codeline" id="line-998"><code>	c.r.setReadLimit(c.server.initialReadLimitSize())</code></span>
<span class="codeline" id="line-999"><code>	if c.lastMethod == "POST" {</code></span>
<span class="codeline" id="line-1000"><code>		// RFC 7230 section 3 tolerance for old buggy clients.</code></span>
<span class="codeline" id="line-1001"><code>		peek, _ := c.bufr.Peek(4) // ReadRequest will get err below</code></span>
<span class="codeline" id="line-1002"><code>		c.bufr.Discard(numLeadingCRorLF(peek))</code></span>
<span class="codeline" id="line-1003"><code>	}</code></span>
<span class="codeline" id="line-1004"><code>	req, err := readRequest(c.bufr)</code></span>
<span class="codeline" id="line-1005"><code>	if err != nil {</code></span>
<span class="codeline" id="line-1006"><code>		if c.r.hitReadLimit() {</code></span>
<span class="codeline" id="line-1007"><code>			return nil, errTooLarge</code></span>
<span class="codeline" id="line-1008"><code>		}</code></span>
<span class="codeline" id="line-1009"><code>		return nil, err</code></span>
<span class="codeline" id="line-1010"><code>	}</code></span>
<span class="codeline" id="line-1011"><code></code></span>
<span class="codeline" id="line-1012"><code>	if !http1ServerSupportsRequest(req) {</code></span>
<span class="codeline" id="line-1013"><code>		return nil, statusError{StatusHTTPVersionNotSupported, "unsupported protocol version"}</code></span>
<span class="codeline" id="line-1014"><code>	}</code></span>
<span class="codeline" id="line-1015"><code></code></span>
<span class="codeline" id="line-1016"><code>	c.lastMethod = req.Method</code></span>
<span class="codeline" id="line-1017"><code>	c.r.setInfiniteReadLimit()</code></span>
<span class="codeline" id="line-1018"><code></code></span>
<span class="codeline" id="line-1019"><code>	hosts, haveHost := req.Header["Host"]</code></span>
<span class="codeline" id="line-1020"><code>	isH2Upgrade := req.isH2Upgrade()</code></span>
<span class="codeline" id="line-1021"><code>	if req.ProtoAtLeast(1, 1) &amp;&amp; (!haveHost || len(hosts) == 0) &amp;&amp; !isH2Upgrade &amp;&amp; req.Method != "CONNECT" {</code></span>
<span class="codeline" id="line-1022"><code>		return nil, badRequestError("missing required Host header")</code></span>
<span class="codeline" id="line-1023"><code>	}</code></span>
<span class="codeline" id="line-1024"><code>	if len(hosts) == 1 &amp;&amp; !httpguts.ValidHostHeader(hosts[0]) {</code></span>
<span class="codeline" id="line-1025"><code>		return nil, badRequestError("malformed Host header")</code></span>
<span class="codeline" id="line-1026"><code>	}</code></span>
<span class="codeline" id="line-1027"><code>	for k, vv := range req.Header {</code></span>
<span class="codeline" id="line-1028"><code>		if !httpguts.ValidHeaderFieldName(k) {</code></span>
<span class="codeline" id="line-1029"><code>			return nil, badRequestError("invalid header name")</code></span>
<span class="codeline" id="line-1030"><code>		}</code></span>
<span class="codeline" id="line-1031"><code>		for _, v := range vv {</code></span>
<span class="codeline" id="line-1032"><code>			if !httpguts.ValidHeaderFieldValue(v) {</code></span>
<span class="codeline" id="line-1033"><code>				return nil, badRequestError("invalid header value")</code></span>
<span class="codeline" id="line-1034"><code>			}</code></span>
<span class="codeline" id="line-1035"><code>		}</code></span>
<span class="codeline" id="line-1036"><code>	}</code></span>
<span class="codeline" id="line-1037"><code>	delete(req.Header, "Host")</code></span>
<span class="codeline" id="line-1038"><code></code></span>
<span class="codeline" id="line-1039"><code>	ctx, cancelCtx := context.WithCancel(ctx)</code></span>
<span class="codeline" id="line-1040"><code>	req.ctx = ctx</code></span>
<span class="codeline" id="line-1041"><code>	req.RemoteAddr = c.remoteAddr</code></span>
<span class="codeline" id="line-1042"><code>	req.TLS = c.tlsState</code></span>
<span class="codeline" id="line-1043"><code>	if body, ok := req.Body.(*body); ok {</code></span>
<span class="codeline" id="line-1044"><code>		body.doEarlyClose = true</code></span>
<span class="codeline" id="line-1045"><code>	}</code></span>
<span class="codeline" id="line-1046"><code></code></span>
<span class="codeline" id="line-1047"><code>	// Adjust the read deadline if necessary.</code></span>
<span class="codeline" id="line-1048"><code>	if !hdrDeadline.Equal(wholeReqDeadline) {</code></span>
<span class="codeline" id="line-1049"><code>		c.rwc.SetReadDeadline(wholeReqDeadline)</code></span>
<span class="codeline" id="line-1050"><code>	}</code></span>
<span class="codeline" id="line-1051"><code></code></span>
<span class="codeline" id="line-1052"><code>	w = &amp;response{</code></span>
<span class="codeline" id="line-1053"><code>		conn:          c,</code></span>
<span class="codeline" id="line-1054"><code>		cancelCtx:     cancelCtx,</code></span>
<span class="codeline" id="line-1055"><code>		req:           req,</code></span>
<span class="codeline" id="line-1056"><code>		reqBody:       req.Body,</code></span>
<span class="codeline" id="line-1057"><code>		handlerHeader: make(Header),</code></span>
<span class="codeline" id="line-1058"><code>		contentLength: -1,</code></span>
<span class="codeline" id="line-1059"><code>		closeNotifyCh: make(chan bool, 1),</code></span>
<span class="codeline" id="line-1060"><code></code></span>
<span class="codeline" id="line-1061"><code>		// We populate these ahead of time so we're not</code></span>
<span class="codeline" id="line-1062"><code>		// reading from req.Header after their Handler starts</code></span>
<span class="codeline" id="line-1063"><code>		// and maybe mutates it (Issue 14940)</code></span>
<span class="codeline" id="line-1064"><code>		wants10KeepAlive: req.wantsHttp10KeepAlive(),</code></span>
<span class="codeline" id="line-1065"><code>		wantsClose:       req.wantsClose(),</code></span>
<span class="codeline" id="line-1066"><code>	}</code></span>
<span class="codeline" id="line-1067"><code>	if isH2Upgrade {</code></span>
<span class="codeline" id="line-1068"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1069"><code>	}</code></span>
<span class="codeline" id="line-1070"><code>	w.cw.res = w</code></span>
<span class="codeline" id="line-1071"><code>	w.w = newBufioWriterSize(&amp;w.cw, bufferBeforeChunkingSize)</code></span>
<span class="codeline" id="line-1072"><code>	return w, nil</code></span>
<span class="codeline" id="line-1073"><code>}</code></span>
<span class="codeline" id="line-1074"><code></code></span>
<span class="codeline" id="line-1075"><code>// http1ServerSupportsRequest reports whether Go's HTTP/1.x server</code></span>
<span class="codeline" id="line-1076"><code>// supports the given request.</code></span>
<span class="codeline" id="line-1077"><code>func http1ServerSupportsRequest(req *Request) bool {</code></span>
<span class="codeline" id="line-1078"><code>	if req.ProtoMajor == 1 {</code></span>
<span class="codeline" id="line-1079"><code>		return true</code></span>
<span class="codeline" id="line-1080"><code>	}</code></span>
<span class="codeline" id="line-1081"><code>	// Accept "PRI * HTTP/2.0" upgrade requests, so Handlers can</code></span>
<span class="codeline" id="line-1082"><code>	// wire up their own HTTP/2 upgrades.</code></span>
<span class="codeline" id="line-1083"><code>	if req.ProtoMajor == 2 &amp;&amp; req.ProtoMinor == 0 &amp;&amp;</code></span>
<span class="codeline" id="line-1084"><code>		req.Method == "PRI" &amp;&amp; req.RequestURI == "*" {</code></span>
<span class="codeline" id="line-1085"><code>		return true</code></span>
<span class="codeline" id="line-1086"><code>	}</code></span>
<span class="codeline" id="line-1087"><code>	// Reject HTTP/0.x, and all other HTTP/2+ requests (which</code></span>
<span class="codeline" id="line-1088"><code>	// aren't encoded in ASCII anyway).</code></span>
<span class="codeline" id="line-1089"><code>	return false</code></span>
<span class="codeline" id="line-1090"><code>}</code></span>
<span class="codeline" id="line-1091"><code></code></span>
<span class="codeline" id="line-1092"><code>func (w *response) Header() Header {</code></span>
<span class="codeline" id="line-1093"><code>	if w.cw.header == nil &amp;&amp; w.wroteHeader &amp;&amp; !w.cw.wroteHeader {</code></span>
<span class="codeline" id="line-1094"><code>		// Accessing the header between logically writing it</code></span>
<span class="codeline" id="line-1095"><code>		// and physically writing it means we need to allocate</code></span>
<span class="codeline" id="line-1096"><code>		// a clone to snapshot the logically written state.</code></span>
<span class="codeline" id="line-1097"><code>		w.cw.header = w.handlerHeader.Clone()</code></span>
<span class="codeline" id="line-1098"><code>	}</code></span>
<span class="codeline" id="line-1099"><code>	w.calledHeader = true</code></span>
<span class="codeline" id="line-1100"><code>	return w.handlerHeader</code></span>
<span class="codeline" id="line-1101"><code>}</code></span>
<span class="codeline" id="line-1102"><code></code></span>
<span class="codeline" id="line-1103"><code>// maxPostHandlerReadBytes is the max number of Request.Body bytes not</code></span>
<span class="codeline" id="line-1104"><code>// consumed by a handler that the server will read from the client</code></span>
<span class="codeline" id="line-1105"><code>// in order to keep a connection alive. If there are more bytes than</code></span>
<span class="codeline" id="line-1106"><code>// this then the server to be paranoid instead sends a "Connection:</code></span>
<span class="codeline" id="line-1107"><code>// close" response.</code></span>
<span class="codeline" id="line-1108"><code>//</code></span>
<span class="codeline" id="line-1109"><code>// This number is approximately what a typical machine's TCP buffer</code></span>
<span class="codeline" id="line-1110"><code>// size is anyway.  (if we have the bytes on the machine, we might as</code></span>
<span class="codeline" id="line-1111"><code>// well read them)</code></span>
<span class="codeline" id="line-1112"><code>const maxPostHandlerReadBytes = 256 &lt;&lt; 10</code></span>
<span class="codeline" id="line-1113"><code></code></span>
<span class="codeline" id="line-1114"><code>func checkWriteHeaderCode(code int) {</code></span>
<span class="codeline" id="line-1115"><code>	// Issue 22880: require valid WriteHeader status codes.</code></span>
<span class="codeline" id="line-1116"><code>	// For now we only enforce that it's three digits.</code></span>
<span class="codeline" id="line-1117"><code>	// In the future we might block things over 599 (600 and above aren't defined</code></span>
<span class="codeline" id="line-1118"><code>	// at https://httpwg.org/specs/rfc7231.html#status.codes).</code></span>
<span class="codeline" id="line-1119"><code>	// But for now any three digits.</code></span>
<span class="codeline" id="line-1120"><code>	//</code></span>
<span class="codeline" id="line-1121"><code>	// We used to send "HTTP/1.1 000 0" on the wire in responses but there's</code></span>
<span class="codeline" id="line-1122"><code>	// no equivalent bogus thing we can realistically send in HTTP/2,</code></span>
<span class="codeline" id="line-1123"><code>	// so we'll consistently panic instead and help people find their bugs</code></span>
<span class="codeline" id="line-1124"><code>	// early. (We can't return an error from WriteHeader even if we wanted to.)</code></span>
<span class="codeline" id="line-1125"><code>	if code &lt; 100 || code &gt; 999 {</code></span>
<span class="codeline" id="line-1126"><code>		panic(fmt.Sprintf("invalid WriteHeader code %v", code))</code></span>
<span class="codeline" id="line-1127"><code>	}</code></span>
<span class="codeline" id="line-1128"><code>}</code></span>
<span class="codeline" id="line-1129"><code></code></span>
<span class="codeline" id="line-1130"><code>// relevantCaller searches the call stack for the first function outside of net/http.</code></span>
<span class="codeline" id="line-1131"><code>// The purpose of this function is to provide more helpful error messages.</code></span>
<span class="codeline" id="line-1132"><code>func relevantCaller() runtime.Frame {</code></span>
<span class="codeline" id="line-1133"><code>	pc := make([]uintptr, 16)</code></span>
<span class="codeline" id="line-1134"><code>	n := runtime.Callers(1, pc)</code></span>
<span class="codeline" id="line-1135"><code>	frames := runtime.CallersFrames(pc[:n])</code></span>
<span class="codeline" id="line-1136"><code>	var frame runtime.Frame</code></span>
<span class="codeline" id="line-1137"><code>	for {</code></span>
<span class="codeline" id="line-1138"><code>		frame, more := frames.Next()</code></span>
<span class="codeline" id="line-1139"><code>		if !strings.HasPrefix(frame.Function, "net/http.") {</code></span>
<span class="codeline" id="line-1140"><code>			return frame</code></span>
<span class="codeline" id="line-1141"><code>		}</code></span>
<span class="codeline" id="line-1142"><code>		if !more {</code></span>
<span class="codeline" id="line-1143"><code>			break</code></span>
<span class="codeline" id="line-1144"><code>		}</code></span>
<span class="codeline" id="line-1145"><code>	}</code></span>
<span class="codeline" id="line-1146"><code>	return frame</code></span>
<span class="codeline" id="line-1147"><code>}</code></span>
<span class="codeline" id="line-1148"><code></code></span>
<span class="codeline" id="line-1149"><code>func (w *response) WriteHeader(code int) {</code></span>
<span class="codeline" id="line-1150"><code>	if w.conn.hijacked() {</code></span>
<span class="codeline" id="line-1151"><code>		caller := relevantCaller()</code></span>
<span class="codeline" id="line-1152"><code>		w.conn.server.logf("http: response.WriteHeader on hijacked connection from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1153"><code>		return</code></span>
<span class="codeline" id="line-1154"><code>	}</code></span>
<span class="codeline" id="line-1155"><code>	if w.wroteHeader {</code></span>
<span class="codeline" id="line-1156"><code>		caller := relevantCaller()</code></span>
<span class="codeline" id="line-1157"><code>		w.conn.server.logf("http: superfluous response.WriteHeader call from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1158"><code>		return</code></span>
<span class="codeline" id="line-1159"><code>	}</code></span>
<span class="codeline" id="line-1160"><code>	checkWriteHeaderCode(code)</code></span>
<span class="codeline" id="line-1161"><code></code></span>
<span class="codeline" id="line-1162"><code>	// Handle informational headers.</code></span>
<span class="codeline" id="line-1163"><code>	//</code></span>
<span class="codeline" id="line-1164"><code>	// We shouldn't send any further headers after 101 Switching Protocols,</code></span>
<span class="codeline" id="line-1165"><code>	// so it takes the non-informational path.</code></span>
<span class="codeline" id="line-1166"><code>	if code &gt;= 100 &amp;&amp; code &lt;= 199 &amp;&amp; code != StatusSwitchingProtocols {</code></span>
<span class="codeline" id="line-1167"><code>		// Prevent a potential race with an automatically-sent 100 Continue triggered by Request.Body.Read()</code></span>
<span class="codeline" id="line-1168"><code>		if code == 100 &amp;&amp; w.canWriteContinue.Load() {</code></span>
<span class="codeline" id="line-1169"><code>			w.writeContinueMu.Lock()</code></span>
<span class="codeline" id="line-1170"><code>			w.canWriteContinue.Store(false)</code></span>
<span class="codeline" id="line-1171"><code>			w.writeContinueMu.Unlock()</code></span>
<span class="codeline" id="line-1172"><code>		}</code></span>
<span class="codeline" id="line-1173"><code></code></span>
<span class="codeline" id="line-1174"><code>		writeStatusLine(w.conn.bufw, w.req.ProtoAtLeast(1, 1), code, w.statusBuf[:])</code></span>
<span class="codeline" id="line-1175"><code></code></span>
<span class="codeline" id="line-1176"><code>		// Per RFC 8297 we must not clear the current header map</code></span>
<span class="codeline" id="line-1177"><code>		w.handlerHeader.WriteSubset(w.conn.bufw, excludedHeadersNoBody)</code></span>
<span class="codeline" id="line-1178"><code>		w.conn.bufw.Write(crlf)</code></span>
<span class="codeline" id="line-1179"><code>		w.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-1180"><code></code></span>
<span class="codeline" id="line-1181"><code>		return</code></span>
<span class="codeline" id="line-1182"><code>	}</code></span>
<span class="codeline" id="line-1183"><code></code></span>
<span class="codeline" id="line-1184"><code>	w.wroteHeader = true</code></span>
<span class="codeline" id="line-1185"><code>	w.status = code</code></span>
<span class="codeline" id="line-1186"><code></code></span>
<span class="codeline" id="line-1187"><code>	if w.calledHeader &amp;&amp; w.cw.header == nil {</code></span>
<span class="codeline" id="line-1188"><code>		w.cw.header = w.handlerHeader.Clone()</code></span>
<span class="codeline" id="line-1189"><code>	}</code></span>
<span class="codeline" id="line-1190"><code></code></span>
<span class="codeline" id="line-1191"><code>	if cl := w.handlerHeader.get("Content-Length"); cl != "" {</code></span>
<span class="codeline" id="line-1192"><code>		v, err := strconv.ParseInt(cl, 10, 64)</code></span>
<span class="codeline" id="line-1193"><code>		if err == nil &amp;&amp; v &gt;= 0 {</code></span>
<span class="codeline" id="line-1194"><code>			w.contentLength = v</code></span>
<span class="codeline" id="line-1195"><code>		} else {</code></span>
<span class="codeline" id="line-1196"><code>			w.conn.server.logf("http: invalid Content-Length of %q", cl)</code></span>
<span class="codeline" id="line-1197"><code>			w.handlerHeader.Del("Content-Length")</code></span>
<span class="codeline" id="line-1198"><code>		}</code></span>
<span class="codeline" id="line-1199"><code>	}</code></span>
<span class="codeline" id="line-1200"><code>}</code></span>
<span class="codeline" id="line-1201"><code></code></span>
<span class="codeline" id="line-1202"><code>// extraHeader is the set of headers sometimes added by chunkWriter.writeHeader.</code></span>
<span class="codeline" id="line-1203"><code>// This type is used to avoid extra allocations from cloning and/or populating</code></span>
<span class="codeline" id="line-1204"><code>// the response Header map and all its 1-element slices.</code></span>
<span class="codeline" id="line-1205"><code>type extraHeader struct {</code></span>
<span class="codeline" id="line-1206"><code>	contentType      string</code></span>
<span class="codeline" id="line-1207"><code>	connection       string</code></span>
<span class="codeline" id="line-1208"><code>	transferEncoding string</code></span>
<span class="codeline" id="line-1209"><code>	date             []byte // written if not nil</code></span>
<span class="codeline" id="line-1210"><code>	contentLength    []byte // written if not nil</code></span>
<span class="codeline" id="line-1211"><code>}</code></span>
<span class="codeline" id="line-1212"><code></code></span>
<span class="codeline" id="line-1213"><code>// Sorted the same as extraHeader.Write's loop.</code></span>
<span class="codeline" id="line-1214"><code>var extraHeaderKeys = [][]byte{</code></span>
<span class="codeline" id="line-1215"><code>	[]byte("Content-Type"),</code></span>
<span class="codeline" id="line-1216"><code>	[]byte("Connection"),</code></span>
<span class="codeline" id="line-1217"><code>	[]byte("Transfer-Encoding"),</code></span>
<span class="codeline" id="line-1218"><code>}</code></span>
<span class="codeline" id="line-1219"><code></code></span>
<span class="codeline" id="line-1220"><code>var (</code></span>
<span class="codeline" id="line-1221"><code>	headerContentLength = []byte("Content-Length: ")</code></span>
<span class="codeline" id="line-1222"><code>	headerDate          = []byte("Date: ")</code></span>
<span class="codeline" id="line-1223"><code>)</code></span>
<span class="codeline" id="line-1224"><code></code></span>
<span class="codeline" id="line-1225"><code>// Write writes the headers described in h to w.</code></span>
<span class="codeline" id="line-1226"><code>//</code></span>
<span class="codeline" id="line-1227"><code>// This method has a value receiver, despite the somewhat large size</code></span>
<span class="codeline" id="line-1228"><code>// of h, because it prevents an allocation. The escape analysis isn't</code></span>
<span class="codeline" id="line-1229"><code>// smart enough to realize this function doesn't mutate h.</code></span>
<span class="codeline" id="line-1230"><code>func (h extraHeader) Write(w *bufio.Writer) {</code></span>
<span class="codeline" id="line-1231"><code>	if h.date != nil {</code></span>
<span class="codeline" id="line-1232"><code>		w.Write(headerDate)</code></span>
<span class="codeline" id="line-1233"><code>		w.Write(h.date)</code></span>
<span class="codeline" id="line-1234"><code>		w.Write(crlf)</code></span>
<span class="codeline" id="line-1235"><code>	}</code></span>
<span class="codeline" id="line-1236"><code>	if h.contentLength != nil {</code></span>
<span class="codeline" id="line-1237"><code>		w.Write(headerContentLength)</code></span>
<span class="codeline" id="line-1238"><code>		w.Write(h.contentLength)</code></span>
<span class="codeline" id="line-1239"><code>		w.Write(crlf)</code></span>
<span class="codeline" id="line-1240"><code>	}</code></span>
<span class="codeline" id="line-1241"><code>	for i, v := range []string{h.contentType, h.connection, h.transferEncoding} {</code></span>
<span class="codeline" id="line-1242"><code>		if v != "" {</code></span>
<span class="codeline" id="line-1243"><code>			w.Write(extraHeaderKeys[i])</code></span>
<span class="codeline" id="line-1244"><code>			w.Write(colonSpace)</code></span>
<span class="codeline" id="line-1245"><code>			w.WriteString(v)</code></span>
<span class="codeline" id="line-1246"><code>			w.Write(crlf)</code></span>
<span class="codeline" id="line-1247"><code>		}</code></span>
<span class="codeline" id="line-1248"><code>	}</code></span>
<span class="codeline" id="line-1249"><code>}</code></span>
<span class="codeline" id="line-1250"><code></code></span>
<span class="codeline" id="line-1251"><code>// writeHeader finalizes the header sent to the client and writes it</code></span>
<span class="codeline" id="line-1252"><code>// to cw.res.conn.bufw.</code></span>
<span class="codeline" id="line-1253"><code>//</code></span>
<span class="codeline" id="line-1254"><code>// p is not written by writeHeader, but is the first chunk of the body</code></span>
<span class="codeline" id="line-1255"><code>// that will be written. It is sniffed for a Content-Type if none is</code></span>
<span class="codeline" id="line-1256"><code>// set explicitly. It's also used to set the Content-Length, if the</code></span>
<span class="codeline" id="line-1257"><code>// total body size was small and the handler has already finished</code></span>
<span class="codeline" id="line-1258"><code>// running.</code></span>
<span class="codeline" id="line-1259"><code>func (cw *chunkWriter) writeHeader(p []byte) {</code></span>
<span class="codeline" id="line-1260"><code>	if cw.wroteHeader {</code></span>
<span class="codeline" id="line-1261"><code>		return</code></span>
<span class="codeline" id="line-1262"><code>	}</code></span>
<span class="codeline" id="line-1263"><code>	cw.wroteHeader = true</code></span>
<span class="codeline" id="line-1264"><code></code></span>
<span class="codeline" id="line-1265"><code>	w := cw.res</code></span>
<span class="codeline" id="line-1266"><code>	keepAlivesEnabled := w.conn.server.doKeepAlives()</code></span>
<span class="codeline" id="line-1267"><code>	isHEAD := w.req.Method == "HEAD"</code></span>
<span class="codeline" id="line-1268"><code></code></span>
<span class="codeline" id="line-1269"><code>	// header is written out to w.conn.buf below. Depending on the</code></span>
<span class="codeline" id="line-1270"><code>	// state of the handler, we either own the map or not. If we</code></span>
<span class="codeline" id="line-1271"><code>	// don't own it, the exclude map is created lazily for</code></span>
<span class="codeline" id="line-1272"><code>	// WriteSubset to remove headers. The setHeader struct holds</code></span>
<span class="codeline" id="line-1273"><code>	// headers we need to add.</code></span>
<span class="codeline" id="line-1274"><code>	header := cw.header</code></span>
<span class="codeline" id="line-1275"><code>	owned := header != nil</code></span>
<span class="codeline" id="line-1276"><code>	if !owned {</code></span>
<span class="codeline" id="line-1277"><code>		header = w.handlerHeader</code></span>
<span class="codeline" id="line-1278"><code>	}</code></span>
<span class="codeline" id="line-1279"><code>	var excludeHeader map[string]bool</code></span>
<span class="codeline" id="line-1280"><code>	delHeader := func(key string) {</code></span>
<span class="codeline" id="line-1281"><code>		if owned {</code></span>
<span class="codeline" id="line-1282"><code>			header.Del(key)</code></span>
<span class="codeline" id="line-1283"><code>			return</code></span>
<span class="codeline" id="line-1284"><code>		}</code></span>
<span class="codeline" id="line-1285"><code>		if _, ok := header[key]; !ok {</code></span>
<span class="codeline" id="line-1286"><code>			return</code></span>
<span class="codeline" id="line-1287"><code>		}</code></span>
<span class="codeline" id="line-1288"><code>		if excludeHeader == nil {</code></span>
<span class="codeline" id="line-1289"><code>			excludeHeader = make(map[string]bool)</code></span>
<span class="codeline" id="line-1290"><code>		}</code></span>
<span class="codeline" id="line-1291"><code>		excludeHeader[key] = true</code></span>
<span class="codeline" id="line-1292"><code>	}</code></span>
<span class="codeline" id="line-1293"><code>	var setHeader extraHeader</code></span>
<span class="codeline" id="line-1294"><code></code></span>
<span class="codeline" id="line-1295"><code>	// Don't write out the fake "Trailer:foo" keys. See TrailerPrefix.</code></span>
<span class="codeline" id="line-1296"><code>	trailers := false</code></span>
<span class="codeline" id="line-1297"><code>	for k := range cw.header {</code></span>
<span class="codeline" id="line-1298"><code>		if strings.HasPrefix(k, TrailerPrefix) {</code></span>
<span class="codeline" id="line-1299"><code>			if excludeHeader == nil {</code></span>
<span class="codeline" id="line-1300"><code>				excludeHeader = make(map[string]bool)</code></span>
<span class="codeline" id="line-1301"><code>			}</code></span>
<span class="codeline" id="line-1302"><code>			excludeHeader[k] = true</code></span>
<span class="codeline" id="line-1303"><code>			trailers = true</code></span>
<span class="codeline" id="line-1304"><code>		}</code></span>
<span class="codeline" id="line-1305"><code>	}</code></span>
<span class="codeline" id="line-1306"><code>	for _, v := range cw.header["Trailer"] {</code></span>
<span class="codeline" id="line-1307"><code>		trailers = true</code></span>
<span class="codeline" id="line-1308"><code>		foreachHeaderElement(v, cw.res.declareTrailer)</code></span>
<span class="codeline" id="line-1309"><code>	}</code></span>
<span class="codeline" id="line-1310"><code></code></span>
<span class="codeline" id="line-1311"><code>	te := header.get("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1312"><code>	hasTE := te != ""</code></span>
<span class="codeline" id="line-1313"><code></code></span>
<span class="codeline" id="line-1314"><code>	// If the handler is done but never sent a Content-Length</code></span>
<span class="codeline" id="line-1315"><code>	// response header and this is our first (and last) write, set</code></span>
<span class="codeline" id="line-1316"><code>	// it, even to zero. This helps HTTP/1.0 clients keep their</code></span>
<span class="codeline" id="line-1317"><code>	// "keep-alive" connections alive.</code></span>
<span class="codeline" id="line-1318"><code>	// Exceptions: 304/204/1xx responses never get Content-Length, and if</code></span>
<span class="codeline" id="line-1319"><code>	// it was a HEAD request, we don't know the difference between</code></span>
<span class="codeline" id="line-1320"><code>	// 0 actual bytes and 0 bytes because the handler noticed it</code></span>
<span class="codeline" id="line-1321"><code>	// was a HEAD request and chose not to write anything. So for</code></span>
<span class="codeline" id="line-1322"><code>	// HEAD, the handler should either write the Content-Length or</code></span>
<span class="codeline" id="line-1323"><code>	// write non-zero bytes. If it's actually 0 bytes and the</code></span>
<span class="codeline" id="line-1324"><code>	// handler never looked at the Request.Method, we just don't</code></span>
<span class="codeline" id="line-1325"><code>	// send a Content-Length header.</code></span>
<span class="codeline" id="line-1326"><code>	// Further, we don't send an automatic Content-Length if they</code></span>
<span class="codeline" id="line-1327"><code>	// set a Transfer-Encoding, because they're generally incompatible.</code></span>
<span class="codeline" id="line-1328"><code>	if w.handlerDone.Load() &amp;&amp; !trailers &amp;&amp; !hasTE &amp;&amp; bodyAllowedForStatus(w.status) &amp;&amp; !header.has("Content-Length") &amp;&amp; (!isHEAD || len(p) &gt; 0) {</code></span>
<span class="codeline" id="line-1329"><code>		w.contentLength = int64(len(p))</code></span>
<span class="codeline" id="line-1330"><code>		setHeader.contentLength = strconv.AppendInt(cw.res.clenBuf[:0], int64(len(p)), 10)</code></span>
<span class="codeline" id="line-1331"><code>	}</code></span>
<span class="codeline" id="line-1332"><code></code></span>
<span class="codeline" id="line-1333"><code>	// If this was an HTTP/1.0 request with keep-alive and we sent a</code></span>
<span class="codeline" id="line-1334"><code>	// Content-Length back, we can make this a keep-alive response ...</code></span>
<span class="codeline" id="line-1335"><code>	if w.wants10KeepAlive &amp;&amp; keepAlivesEnabled {</code></span>
<span class="codeline" id="line-1336"><code>		sentLength := header.get("Content-Length") != ""</code></span>
<span class="codeline" id="line-1337"><code>		if sentLength &amp;&amp; header.get("Connection") == "keep-alive" {</code></span>
<span class="codeline" id="line-1338"><code>			w.closeAfterReply = false</code></span>
<span class="codeline" id="line-1339"><code>		}</code></span>
<span class="codeline" id="line-1340"><code>	}</code></span>
<span class="codeline" id="line-1341"><code></code></span>
<span class="codeline" id="line-1342"><code>	// Check for an explicit (and valid) Content-Length header.</code></span>
<span class="codeline" id="line-1343"><code>	hasCL := w.contentLength != -1</code></span>
<span class="codeline" id="line-1344"><code></code></span>
<span class="codeline" id="line-1345"><code>	if w.wants10KeepAlive &amp;&amp; (isHEAD || hasCL || !bodyAllowedForStatus(w.status)) {</code></span>
<span class="codeline" id="line-1346"><code>		_, connectionHeaderSet := header["Connection"]</code></span>
<span class="codeline" id="line-1347"><code>		if !connectionHeaderSet {</code></span>
<span class="codeline" id="line-1348"><code>			setHeader.connection = "keep-alive"</code></span>
<span class="codeline" id="line-1349"><code>		}</code></span>
<span class="codeline" id="line-1350"><code>	} else if !w.req.ProtoAtLeast(1, 1) || w.wantsClose {</code></span>
<span class="codeline" id="line-1351"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1352"><code>	}</code></span>
<span class="codeline" id="line-1353"><code></code></span>
<span class="codeline" id="line-1354"><code>	if header.get("Connection") == "close" || !keepAlivesEnabled {</code></span>
<span class="codeline" id="line-1355"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1356"><code>	}</code></span>
<span class="codeline" id="line-1357"><code></code></span>
<span class="codeline" id="line-1358"><code>	// If the client wanted a 100-continue but we never sent it to</code></span>
<span class="codeline" id="line-1359"><code>	// them (or, more strictly: we never finished reading their</code></span>
<span class="codeline" id="line-1360"><code>	// request body), don't reuse this connection because it's now</code></span>
<span class="codeline" id="line-1361"><code>	// in an unknown state: we might be sending this response at</code></span>
<span class="codeline" id="line-1362"><code>	// the same time the client is now sending its request body</code></span>
<span class="codeline" id="line-1363"><code>	// after a timeout.  (Some HTTP clients send Expect:</code></span>
<span class="codeline" id="line-1364"><code>	// 100-continue but knowing that some servers don't support</code></span>
<span class="codeline" id="line-1365"><code>	// it, the clients set a timer and send the body later anyway)</code></span>
<span class="codeline" id="line-1366"><code>	// If we haven't seen EOF, we can't skip over the unread body</code></span>
<span class="codeline" id="line-1367"><code>	// because we don't know if the next bytes on the wire will be</code></span>
<span class="codeline" id="line-1368"><code>	// the body-following-the-timer or the subsequent request.</code></span>
<span class="codeline" id="line-1369"><code>	// See Issue 11549.</code></span>
<span class="codeline" id="line-1370"><code>	if ecr, ok := w.req.Body.(*expectContinueReader); ok &amp;&amp; !ecr.sawEOF.Load() {</code></span>
<span class="codeline" id="line-1371"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1372"><code>	}</code></span>
<span class="codeline" id="line-1373"><code></code></span>
<span class="codeline" id="line-1374"><code>	// We do this by default because there are a number of clients that</code></span>
<span class="codeline" id="line-1375"><code>	// send a full request before starting to read the response, and they</code></span>
<span class="codeline" id="line-1376"><code>	// can deadlock if we start writing the response with unconsumed body</code></span>
<span class="codeline" id="line-1377"><code>	// remaining. See Issue 15527 for some history.</code></span>
<span class="codeline" id="line-1378"><code>	//</code></span>
<span class="codeline" id="line-1379"><code>	// If full duplex mode has been enabled with ResponseController.EnableFullDuplex,</code></span>
<span class="codeline" id="line-1380"><code>	// then leave the request body alone.</code></span>
<span class="codeline" id="line-1381"><code>	if w.req.ContentLength != 0 &amp;&amp; !w.closeAfterReply &amp;&amp; !w.fullDuplex {</code></span>
<span class="codeline" id="line-1382"><code>		var discard, tooBig bool</code></span>
<span class="codeline" id="line-1383"><code></code></span>
<span class="codeline" id="line-1384"><code>		switch bdy := w.req.Body.(type) {</code></span>
<span class="codeline" id="line-1385"><code>		case *expectContinueReader:</code></span>
<span class="codeline" id="line-1386"><code>			if bdy.resp.wroteContinue {</code></span>
<span class="codeline" id="line-1387"><code>				discard = true</code></span>
<span class="codeline" id="line-1388"><code>			}</code></span>
<span class="codeline" id="line-1389"><code>		case *body:</code></span>
<span class="codeline" id="line-1390"><code>			bdy.mu.Lock()</code></span>
<span class="codeline" id="line-1391"><code>			switch {</code></span>
<span class="codeline" id="line-1392"><code>			case bdy.closed:</code></span>
<span class="codeline" id="line-1393"><code>				if !bdy.sawEOF {</code></span>
<span class="codeline" id="line-1394"><code>					// Body was closed in handler with non-EOF error.</code></span>
<span class="codeline" id="line-1395"><code>					w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1396"><code>				}</code></span>
<span class="codeline" id="line-1397"><code>			case bdy.unreadDataSizeLocked() &gt;= maxPostHandlerReadBytes:</code></span>
<span class="codeline" id="line-1398"><code>				tooBig = true</code></span>
<span class="codeline" id="line-1399"><code>			default:</code></span>
<span class="codeline" id="line-1400"><code>				discard = true</code></span>
<span class="codeline" id="line-1401"><code>			}</code></span>
<span class="codeline" id="line-1402"><code>			bdy.mu.Unlock()</code></span>
<span class="codeline" id="line-1403"><code>		default:</code></span>
<span class="codeline" id="line-1404"><code>			discard = true</code></span>
<span class="codeline" id="line-1405"><code>		}</code></span>
<span class="codeline" id="line-1406"><code></code></span>
<span class="codeline" id="line-1407"><code>		if discard {</code></span>
<span class="codeline" id="line-1408"><code>			_, err := io.CopyN(io.Discard, w.reqBody, maxPostHandlerReadBytes+1)</code></span>
<span class="codeline" id="line-1409"><code>			switch err {</code></span>
<span class="codeline" id="line-1410"><code>			case nil:</code></span>
<span class="codeline" id="line-1411"><code>				// There must be even more data left over.</code></span>
<span class="codeline" id="line-1412"><code>				tooBig = true</code></span>
<span class="codeline" id="line-1413"><code>			case ErrBodyReadAfterClose:</code></span>
<span class="codeline" id="line-1414"><code>				// Body was already consumed and closed.</code></span>
<span class="codeline" id="line-1415"><code>			case io.EOF:</code></span>
<span class="codeline" id="line-1416"><code>				// The remaining body was just consumed, close it.</code></span>
<span class="codeline" id="line-1417"><code>				err = w.reqBody.Close()</code></span>
<span class="codeline" id="line-1418"><code>				if err != nil {</code></span>
<span class="codeline" id="line-1419"><code>					w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1420"><code>				}</code></span>
<span class="codeline" id="line-1421"><code>			default:</code></span>
<span class="codeline" id="line-1422"><code>				// Some other kind of error occurred, like a read timeout, or</code></span>
<span class="codeline" id="line-1423"><code>				// corrupt chunked encoding. In any case, whatever remains</code></span>
<span class="codeline" id="line-1424"><code>				// on the wire must not be parsed as another HTTP request.</code></span>
<span class="codeline" id="line-1425"><code>				w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1426"><code>			}</code></span>
<span class="codeline" id="line-1427"><code>		}</code></span>
<span class="codeline" id="line-1428"><code></code></span>
<span class="codeline" id="line-1429"><code>		if tooBig {</code></span>
<span class="codeline" id="line-1430"><code>			w.requestTooLarge()</code></span>
<span class="codeline" id="line-1431"><code>			delHeader("Connection")</code></span>
<span class="codeline" id="line-1432"><code>			setHeader.connection = "close"</code></span>
<span class="codeline" id="line-1433"><code>		}</code></span>
<span class="codeline" id="line-1434"><code>	}</code></span>
<span class="codeline" id="line-1435"><code></code></span>
<span class="codeline" id="line-1436"><code>	code := w.status</code></span>
<span class="codeline" id="line-1437"><code>	if bodyAllowedForStatus(code) {</code></span>
<span class="codeline" id="line-1438"><code>		// If no content type, apply sniffing algorithm to body.</code></span>
<span class="codeline" id="line-1439"><code>		_, haveType := header["Content-Type"]</code></span>
<span class="codeline" id="line-1440"><code></code></span>
<span class="codeline" id="line-1441"><code>		// If the Content-Encoding was set and is non-blank,</code></span>
<span class="codeline" id="line-1442"><code>		// we shouldn't sniff the body. See Issue 31753.</code></span>
<span class="codeline" id="line-1443"><code>		ce := header.Get("Content-Encoding")</code></span>
<span class="codeline" id="line-1444"><code>		hasCE := len(ce) &gt; 0</code></span>
<span class="codeline" id="line-1445"><code>		if !hasCE &amp;&amp; !haveType &amp;&amp; !hasTE &amp;&amp; len(p) &gt; 0 {</code></span>
<span class="codeline" id="line-1446"><code>			setHeader.contentType = DetectContentType(p)</code></span>
<span class="codeline" id="line-1447"><code>		}</code></span>
<span class="codeline" id="line-1448"><code>	} else {</code></span>
<span class="codeline" id="line-1449"><code>		for _, k := range suppressedHeaders(code) {</code></span>
<span class="codeline" id="line-1450"><code>			delHeader(k)</code></span>
<span class="codeline" id="line-1451"><code>		}</code></span>
<span class="codeline" id="line-1452"><code>	}</code></span>
<span class="codeline" id="line-1453"><code></code></span>
<span class="codeline" id="line-1454"><code>	if !header.has("Date") {</code></span>
<span class="codeline" id="line-1455"><code>		setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())</code></span>
<span class="codeline" id="line-1456"><code>	}</code></span>
<span class="codeline" id="line-1457"><code></code></span>
<span class="codeline" id="line-1458"><code>	if hasCL &amp;&amp; hasTE &amp;&amp; te != "identity" {</code></span>
<span class="codeline" id="line-1459"><code>		// TODO: return an error if WriteHeader gets a return parameter</code></span>
<span class="codeline" id="line-1460"><code>		// For now just ignore the Content-Length.</code></span>
<span class="codeline" id="line-1461"><code>		w.conn.server.logf("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",</code></span>
<span class="codeline" id="line-1462"><code>			te, w.contentLength)</code></span>
<span class="codeline" id="line-1463"><code>		delHeader("Content-Length")</code></span>
<span class="codeline" id="line-1464"><code>		hasCL = false</code></span>
<span class="codeline" id="line-1465"><code>	}</code></span>
<span class="codeline" id="line-1466"><code></code></span>
<span class="codeline" id="line-1467"><code>	if w.req.Method == "HEAD" || !bodyAllowedForStatus(code) || code == StatusNoContent {</code></span>
<span class="codeline" id="line-1468"><code>		// Response has no body.</code></span>
<span class="codeline" id="line-1469"><code>		delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1470"><code>	} else if hasCL {</code></span>
<span class="codeline" id="line-1471"><code>		// Content-Length has been provided, so no chunking is to be done.</code></span>
<span class="codeline" id="line-1472"><code>		delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1473"><code>	} else if w.req.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-1474"><code>		// HTTP/1.1 or greater: Transfer-Encoding has been set to identity, and no</code></span>
<span class="codeline" id="line-1475"><code>		// content-length has been provided. The connection must be closed after the</code></span>
<span class="codeline" id="line-1476"><code>		// reply is written, and no chunking is to be done. This is the setup</code></span>
<span class="codeline" id="line-1477"><code>		// recommended in the Server-Sent Events candidate recommendation 11,</code></span>
<span class="codeline" id="line-1478"><code>		// section 8.</code></span>
<span class="codeline" id="line-1479"><code>		if hasTE &amp;&amp; te == "identity" {</code></span>
<span class="codeline" id="line-1480"><code>			cw.chunking = false</code></span>
<span class="codeline" id="line-1481"><code>			w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1482"><code>			delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1483"><code>		} else {</code></span>
<span class="codeline" id="line-1484"><code>			// HTTP/1.1 or greater: use chunked transfer encoding</code></span>
<span class="codeline" id="line-1485"><code>			// to avoid closing the connection at EOF.</code></span>
<span class="codeline" id="line-1486"><code>			cw.chunking = true</code></span>
<span class="codeline" id="line-1487"><code>			setHeader.transferEncoding = "chunked"</code></span>
<span class="codeline" id="line-1488"><code>			if hasTE &amp;&amp; te == "chunked" {</code></span>
<span class="codeline" id="line-1489"><code>				// We will send the chunked Transfer-Encoding header later.</code></span>
<span class="codeline" id="line-1490"><code>				delHeader("Transfer-Encoding")</code></span>
<span class="codeline" id="line-1491"><code>			}</code></span>
<span class="codeline" id="line-1492"><code>		}</code></span>
<span class="codeline" id="line-1493"><code>	} else {</code></span>
<span class="codeline" id="line-1494"><code>		// HTTP version &lt; 1.1: cannot do chunked transfer</code></span>
<span class="codeline" id="line-1495"><code>		// encoding and we don't know the Content-Length so</code></span>
<span class="codeline" id="line-1496"><code>		// signal EOF by closing connection.</code></span>
<span class="codeline" id="line-1497"><code>		w.closeAfterReply = true</code></span>
<span class="codeline" id="line-1498"><code>		delHeader("Transfer-Encoding") // in case already set</code></span>
<span class="codeline" id="line-1499"><code>	}</code></span>
<span class="codeline" id="line-1500"><code></code></span>
<span class="codeline" id="line-1501"><code>	// Cannot use Content-Length with non-identity Transfer-Encoding.</code></span>
<span class="codeline" id="line-1502"><code>	if cw.chunking {</code></span>
<span class="codeline" id="line-1503"><code>		delHeader("Content-Length")</code></span>
<span class="codeline" id="line-1504"><code>	}</code></span>
<span class="codeline" id="line-1505"><code>	if !w.req.ProtoAtLeast(1, 0) {</code></span>
<span class="codeline" id="line-1506"><code>		return</code></span>
<span class="codeline" id="line-1507"><code>	}</code></span>
<span class="codeline" id="line-1508"><code></code></span>
<span class="codeline" id="line-1509"><code>	// Only override the Connection header if it is not a successful</code></span>
<span class="codeline" id="line-1510"><code>	// protocol switch response and if KeepAlives are not enabled.</code></span>
<span class="codeline" id="line-1511"><code>	// See https://golang.org/issue/36381.</code></span>
<span class="codeline" id="line-1512"><code>	delConnectionHeader := w.closeAfterReply &amp;&amp;</code></span>
<span class="codeline" id="line-1513"><code>		(!keepAlivesEnabled || !hasToken(cw.header.get("Connection"), "close")) &amp;&amp;</code></span>
<span class="codeline" id="line-1514"><code>		!isProtocolSwitchResponse(w.status, header)</code></span>
<span class="codeline" id="line-1515"><code>	if delConnectionHeader {</code></span>
<span class="codeline" id="line-1516"><code>		delHeader("Connection")</code></span>
<span class="codeline" id="line-1517"><code>		if w.req.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-1518"><code>			setHeader.connection = "close"</code></span>
<span class="codeline" id="line-1519"><code>		}</code></span>
<span class="codeline" id="line-1520"><code>	}</code></span>
<span class="codeline" id="line-1521"><code></code></span>
<span class="codeline" id="line-1522"><code>	writeStatusLine(w.conn.bufw, w.req.ProtoAtLeast(1, 1), code, w.statusBuf[:])</code></span>
<span class="codeline" id="line-1523"><code>	cw.header.WriteSubset(w.conn.bufw, excludeHeader)</code></span>
<span class="codeline" id="line-1524"><code>	setHeader.Write(w.conn.bufw)</code></span>
<span class="codeline" id="line-1525"><code>	w.conn.bufw.Write(crlf)</code></span>
<span class="codeline" id="line-1526"><code>}</code></span>
<span class="codeline" id="line-1527"><code></code></span>
<span class="codeline" id="line-1528"><code>// foreachHeaderElement splits v according to the "#rule" construction</code></span>
<span class="codeline" id="line-1529"><code>// in RFC 7230 section 7 and calls fn for each non-empty element.</code></span>
<span class="codeline" id="line-1530"><code>func foreachHeaderElement(v string, fn func(string)) {</code></span>
<span class="codeline" id="line-1531"><code>	v = textproto.TrimString(v)</code></span>
<span class="codeline" id="line-1532"><code>	if v == "" {</code></span>
<span class="codeline" id="line-1533"><code>		return</code></span>
<span class="codeline" id="line-1534"><code>	}</code></span>
<span class="codeline" id="line-1535"><code>	if !strings.Contains(v, ",") {</code></span>
<span class="codeline" id="line-1536"><code>		fn(v)</code></span>
<span class="codeline" id="line-1537"><code>		return</code></span>
<span class="codeline" id="line-1538"><code>	}</code></span>
<span class="codeline" id="line-1539"><code>	for _, f := range strings.Split(v, ",") {</code></span>
<span class="codeline" id="line-1540"><code>		if f = textproto.TrimString(f); f != "" {</code></span>
<span class="codeline" id="line-1541"><code>			fn(f)</code></span>
<span class="codeline" id="line-1542"><code>		}</code></span>
<span class="codeline" id="line-1543"><code>	}</code></span>
<span class="codeline" id="line-1544"><code>}</code></span>
<span class="codeline" id="line-1545"><code></code></span>
<span class="codeline" id="line-1546"><code>// writeStatusLine writes an HTTP/1.x Status-Line (RFC 7230 Section 3.1.2)</code></span>
<span class="codeline" id="line-1547"><code>// to bw. is11 is whether the HTTP request is HTTP/1.1. false means HTTP/1.0.</code></span>
<span class="codeline" id="line-1548"><code>// code is the response status code.</code></span>
<span class="codeline" id="line-1549"><code>// scratch is an optional scratch buffer. If it has at least capacity 3, it's used.</code></span>
<span class="codeline" id="line-1550"><code>func writeStatusLine(bw *bufio.Writer, is11 bool, code int, scratch []byte) {</code></span>
<span class="codeline" id="line-1551"><code>	if is11 {</code></span>
<span class="codeline" id="line-1552"><code>		bw.WriteString("HTTP/1.1 ")</code></span>
<span class="codeline" id="line-1553"><code>	} else {</code></span>
<span class="codeline" id="line-1554"><code>		bw.WriteString("HTTP/1.0 ")</code></span>
<span class="codeline" id="line-1555"><code>	}</code></span>
<span class="codeline" id="line-1556"><code>	if text := StatusText(code); text != "" {</code></span>
<span class="codeline" id="line-1557"><code>		bw.Write(strconv.AppendInt(scratch[:0], int64(code), 10))</code></span>
<span class="codeline" id="line-1558"><code>		bw.WriteByte(' ')</code></span>
<span class="codeline" id="line-1559"><code>		bw.WriteString(text)</code></span>
<span class="codeline" id="line-1560"><code>		bw.WriteString("\r\n")</code></span>
<span class="codeline" id="line-1561"><code>	} else {</code></span>
<span class="codeline" id="line-1562"><code>		// don't worry about performance</code></span>
<span class="codeline" id="line-1563"><code>		fmt.Fprintf(bw, "%03d status code %d\r\n", code, code)</code></span>
<span class="codeline" id="line-1564"><code>	}</code></span>
<span class="codeline" id="line-1565"><code>}</code></span>
<span class="codeline" id="line-1566"><code></code></span>
<span class="codeline" id="line-1567"><code>// bodyAllowed reports whether a Write is allowed for this response type.</code></span>
<span class="codeline" id="line-1568"><code>// It's illegal to call this before the header has been flushed.</code></span>
<span class="codeline" id="line-1569"><code>func (w *response) bodyAllowed() bool {</code></span>
<span class="codeline" id="line-1570"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1571"><code>		panic("")</code></span>
<span class="codeline" id="line-1572"><code>	}</code></span>
<span class="codeline" id="line-1573"><code>	return bodyAllowedForStatus(w.status)</code></span>
<span class="codeline" id="line-1574"><code>}</code></span>
<span class="codeline" id="line-1575"><code></code></span>
<span class="codeline" id="line-1576"><code>// The Life Of A Write is like this:</code></span>
<span class="codeline" id="line-1577"><code>//</code></span>
<span class="codeline" id="line-1578"><code>// Handler starts. No header has been sent. The handler can either</code></span>
<span class="codeline" id="line-1579"><code>// write a header, or just start writing. Writing before sending a header</code></span>
<span class="codeline" id="line-1580"><code>// sends an implicitly empty 200 OK header.</code></span>
<span class="codeline" id="line-1581"><code>//</code></span>
<span class="codeline" id="line-1582"><code>// If the handler didn't declare a Content-Length up front, we either</code></span>
<span class="codeline" id="line-1583"><code>// go into chunking mode or, if the handler finishes running before</code></span>
<span class="codeline" id="line-1584"><code>// the chunking buffer size, we compute a Content-Length and send that</code></span>
<span class="codeline" id="line-1585"><code>// in the header instead.</code></span>
<span class="codeline" id="line-1586"><code>//</code></span>
<span class="codeline" id="line-1587"><code>// Likewise, if the handler didn't set a Content-Type, we sniff that</code></span>
<span class="codeline" id="line-1588"><code>// from the initial chunk of output.</code></span>
<span class="codeline" id="line-1589"><code>//</code></span>
<span class="codeline" id="line-1590"><code>// The Writers are wired together like:</code></span>
<span class="codeline" id="line-1591"><code>//</code></span>
<span class="codeline" id="line-1592"><code>//  1. *response (the ResponseWriter) -&gt;</code></span>
<span class="codeline" id="line-1593"><code>//  2. (*response).w, a [*bufio.Writer] of bufferBeforeChunkingSize bytes -&gt;</code></span>
<span class="codeline" id="line-1594"><code>//  3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type)</code></span>
<span class="codeline" id="line-1595"><code>//     and which writes the chunk headers, if needed -&gt;</code></span>
<span class="codeline" id="line-1596"><code>//  4. conn.bufw, a *bufio.Writer of default (4kB) bytes, writing to -&gt;</code></span>
<span class="codeline" id="line-1597"><code>//  5. checkConnErrorWriter{c}, which notes any non-nil error on Write</code></span>
<span class="codeline" id="line-1598"><code>//     and populates c.werr with it if so, but otherwise writes to -&gt;</code></span>
<span class="codeline" id="line-1599"><code>//  6. the rwc, the [net.Conn].</code></span>
<span class="codeline" id="line-1600"><code>//</code></span>
<span class="codeline" id="line-1601"><code>// TODO(bradfitz): short-circuit some of the buffering when the</code></span>
<span class="codeline" id="line-1602"><code>// initial header contains both a Content-Type and Content-Length.</code></span>
<span class="codeline" id="line-1603"><code>// Also short-circuit in (1) when the header's been sent and not in</code></span>
<span class="codeline" id="line-1604"><code>// chunking mode, writing directly to (4) instead, if (2) has no</code></span>
<span class="codeline" id="line-1605"><code>// buffered data. More generally, we could short-circuit from (1) to</code></span>
<span class="codeline" id="line-1606"><code>// (3) even in chunking mode if the write size from (1) is over some</code></span>
<span class="codeline" id="line-1607"><code>// threshold and nothing is in (2).  The answer might be mostly making</code></span>
<span class="codeline" id="line-1608"><code>// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal</code></span>
<span class="codeline" id="line-1609"><code>// with this instead.</code></span>
<span class="codeline" id="line-1610"><code>func (w *response) Write(data []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-1611"><code>	return w.write(len(data), data, "")</code></span>
<span class="codeline" id="line-1612"><code>}</code></span>
<span class="codeline" id="line-1613"><code></code></span>
<span class="codeline" id="line-1614"><code>func (w *response) WriteString(data string) (n int, err error) {</code></span>
<span class="codeline" id="line-1615"><code>	return w.write(len(data), nil, data)</code></span>
<span class="codeline" id="line-1616"><code>}</code></span>
<span class="codeline" id="line-1617"><code></code></span>
<span class="codeline" id="line-1618"><code>// either dataB or dataS is non-zero.</code></span>
<span class="codeline" id="line-1619"><code>func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) {</code></span>
<span class="codeline" id="line-1620"><code>	if w.conn.hijacked() {</code></span>
<span class="codeline" id="line-1621"><code>		if lenData &gt; 0 {</code></span>
<span class="codeline" id="line-1622"><code>			caller := relevantCaller()</code></span>
<span class="codeline" id="line-1623"><code>			w.conn.server.logf("http: response.Write on hijacked connection from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-1624"><code>		}</code></span>
<span class="codeline" id="line-1625"><code>		return 0, ErrHijacked</code></span>
<span class="codeline" id="line-1626"><code>	}</code></span>
<span class="codeline" id="line-1627"><code></code></span>
<span class="codeline" id="line-1628"><code>	if w.canWriteContinue.Load() {</code></span>
<span class="codeline" id="line-1629"><code>		// Body reader wants to write 100 Continue but hasn't yet.</code></span>
<span class="codeline" id="line-1630"><code>		// Tell it not to. The store must be done while holding the lock</code></span>
<span class="codeline" id="line-1631"><code>		// because the lock makes sure that there is not an active write</code></span>
<span class="codeline" id="line-1632"><code>		// this very moment.</code></span>
<span class="codeline" id="line-1633"><code>		w.writeContinueMu.Lock()</code></span>
<span class="codeline" id="line-1634"><code>		w.canWriteContinue.Store(false)</code></span>
<span class="codeline" id="line-1635"><code>		w.writeContinueMu.Unlock()</code></span>
<span class="codeline" id="line-1636"><code>	}</code></span>
<span class="codeline" id="line-1637"><code></code></span>
<span class="codeline" id="line-1638"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1639"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1640"><code>	}</code></span>
<span class="codeline" id="line-1641"><code>	if lenData == 0 {</code></span>
<span class="codeline" id="line-1642"><code>		return 0, nil</code></span>
<span class="codeline" id="line-1643"><code>	}</code></span>
<span class="codeline" id="line-1644"><code>	if !w.bodyAllowed() {</code></span>
<span class="codeline" id="line-1645"><code>		return 0, ErrBodyNotAllowed</code></span>
<span class="codeline" id="line-1646"><code>	}</code></span>
<span class="codeline" id="line-1647"><code></code></span>
<span class="codeline" id="line-1648"><code>	w.written += int64(lenData) // ignoring errors, for errorKludge</code></span>
<span class="codeline" id="line-1649"><code>	if w.contentLength != -1 &amp;&amp; w.written &gt; w.contentLength {</code></span>
<span class="codeline" id="line-1650"><code>		return 0, ErrContentLength</code></span>
<span class="codeline" id="line-1651"><code>	}</code></span>
<span class="codeline" id="line-1652"><code>	if dataB != nil {</code></span>
<span class="codeline" id="line-1653"><code>		return w.w.Write(dataB)</code></span>
<span class="codeline" id="line-1654"><code>	} else {</code></span>
<span class="codeline" id="line-1655"><code>		return w.w.WriteString(dataS)</code></span>
<span class="codeline" id="line-1656"><code>	}</code></span>
<span class="codeline" id="line-1657"><code>}</code></span>
<span class="codeline" id="line-1658"><code></code></span>
<span class="codeline" id="line-1659"><code>func (w *response) finishRequest() {</code></span>
<span class="codeline" id="line-1660"><code>	w.handlerDone.Store(true)</code></span>
<span class="codeline" id="line-1661"><code></code></span>
<span class="codeline" id="line-1662"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1663"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1664"><code>	}</code></span>
<span class="codeline" id="line-1665"><code></code></span>
<span class="codeline" id="line-1666"><code>	w.w.Flush()</code></span>
<span class="codeline" id="line-1667"><code>	putBufioWriter(w.w)</code></span>
<span class="codeline" id="line-1668"><code>	w.cw.close()</code></span>
<span class="codeline" id="line-1669"><code>	w.conn.bufw.Flush()</code></span>
<span class="codeline" id="line-1670"><code></code></span>
<span class="codeline" id="line-1671"><code>	w.conn.r.abortPendingRead()</code></span>
<span class="codeline" id="line-1672"><code></code></span>
<span class="codeline" id="line-1673"><code>	// Close the body (regardless of w.closeAfterReply) so we can</code></span>
<span class="codeline" id="line-1674"><code>	// re-use its bufio.Reader later safely.</code></span>
<span class="codeline" id="line-1675"><code>	w.reqBody.Close()</code></span>
<span class="codeline" id="line-1676"><code></code></span>
<span class="codeline" id="line-1677"><code>	if w.req.MultipartForm != nil {</code></span>
<span class="codeline" id="line-1678"><code>		w.req.MultipartForm.RemoveAll()</code></span>
<span class="codeline" id="line-1679"><code>	}</code></span>
<span class="codeline" id="line-1680"><code>}</code></span>
<span class="codeline" id="line-1681"><code></code></span>
<span class="codeline" id="line-1682"><code>// shouldReuseConnection reports whether the underlying TCP connection can be reused.</code></span>
<span class="codeline" id="line-1683"><code>// It must only be called after the handler is done executing.</code></span>
<span class="codeline" id="line-1684"><code>func (w *response) shouldReuseConnection() bool {</code></span>
<span class="codeline" id="line-1685"><code>	if w.closeAfterReply {</code></span>
<span class="codeline" id="line-1686"><code>		// The request or something set while executing the</code></span>
<span class="codeline" id="line-1687"><code>		// handler indicated we shouldn't reuse this</code></span>
<span class="codeline" id="line-1688"><code>		// connection.</code></span>
<span class="codeline" id="line-1689"><code>		return false</code></span>
<span class="codeline" id="line-1690"><code>	}</code></span>
<span class="codeline" id="line-1691"><code></code></span>
<span class="codeline" id="line-1692"><code>	if w.req.Method != "HEAD" &amp;&amp; w.contentLength != -1 &amp;&amp; w.bodyAllowed() &amp;&amp; w.contentLength != w.written {</code></span>
<span class="codeline" id="line-1693"><code>		// Did not write enough. Avoid getting out of sync.</code></span>
<span class="codeline" id="line-1694"><code>		return false</code></span>
<span class="codeline" id="line-1695"><code>	}</code></span>
<span class="codeline" id="line-1696"><code></code></span>
<span class="codeline" id="line-1697"><code>	// There was some error writing to the underlying connection</code></span>
<span class="codeline" id="line-1698"><code>	// during the request, so don't re-use this conn.</code></span>
<span class="codeline" id="line-1699"><code>	if w.conn.werr != nil {</code></span>
<span class="codeline" id="line-1700"><code>		return false</code></span>
<span class="codeline" id="line-1701"><code>	}</code></span>
<span class="codeline" id="line-1702"><code></code></span>
<span class="codeline" id="line-1703"><code>	if w.closedRequestBodyEarly() {</code></span>
<span class="codeline" id="line-1704"><code>		return false</code></span>
<span class="codeline" id="line-1705"><code>	}</code></span>
<span class="codeline" id="line-1706"><code></code></span>
<span class="codeline" id="line-1707"><code>	return true</code></span>
<span class="codeline" id="line-1708"><code>}</code></span>
<span class="codeline" id="line-1709"><code></code></span>
<span class="codeline" id="line-1710"><code>func (w *response) closedRequestBodyEarly() bool {</code></span>
<span class="codeline" id="line-1711"><code>	body, ok := w.req.Body.(*body)</code></span>
<span class="codeline" id="line-1712"><code>	return ok &amp;&amp; body.didEarlyClose()</code></span>
<span class="codeline" id="line-1713"><code>}</code></span>
<span class="codeline" id="line-1714"><code></code></span>
<span class="codeline" id="line-1715"><code>func (w *response) Flush() {</code></span>
<span class="codeline" id="line-1716"><code>	w.FlushError()</code></span>
<span class="codeline" id="line-1717"><code>}</code></span>
<span class="codeline" id="line-1718"><code></code></span>
<span class="codeline" id="line-1719"><code>func (w *response) FlushError() error {</code></span>
<span class="codeline" id="line-1720"><code>	if !w.wroteHeader {</code></span>
<span class="codeline" id="line-1721"><code>		w.WriteHeader(StatusOK)</code></span>
<span class="codeline" id="line-1722"><code>	}</code></span>
<span class="codeline" id="line-1723"><code>	err := w.w.Flush()</code></span>
<span class="codeline" id="line-1724"><code>	e2 := w.cw.flush()</code></span>
<span class="codeline" id="line-1725"><code>	if err == nil {</code></span>
<span class="codeline" id="line-1726"><code>		err = e2</code></span>
<span class="codeline" id="line-1727"><code>	}</code></span>
<span class="codeline" id="line-1728"><code>	return err</code></span>
<span class="codeline" id="line-1729"><code>}</code></span>
<span class="codeline" id="line-1730"><code></code></span>
<span class="codeline" id="line-1731"><code>func (c *conn) finalFlush() {</code></span>
<span class="codeline" id="line-1732"><code>	if c.bufr != nil {</code></span>
<span class="codeline" id="line-1733"><code>		// Steal the bufio.Reader (~4KB worth of memory) and its associated</code></span>
<span class="codeline" id="line-1734"><code>		// reader for a future connection.</code></span>
<span class="codeline" id="line-1735"><code>		putBufioReader(c.bufr)</code></span>
<span class="codeline" id="line-1736"><code>		c.bufr = nil</code></span>
<span class="codeline" id="line-1737"><code>	}</code></span>
<span class="codeline" id="line-1738"><code></code></span>
<span class="codeline" id="line-1739"><code>	if c.bufw != nil {</code></span>
<span class="codeline" id="line-1740"><code>		c.bufw.Flush()</code></span>
<span class="codeline" id="line-1741"><code>		// Steal the bufio.Writer (~4KB worth of memory) and its associated</code></span>
<span class="codeline" id="line-1742"><code>		// writer for a future connection.</code></span>
<span class="codeline" id="line-1743"><code>		putBufioWriter(c.bufw)</code></span>
<span class="codeline" id="line-1744"><code>		c.bufw = nil</code></span>
<span class="codeline" id="line-1745"><code>	}</code></span>
<span class="codeline" id="line-1746"><code>}</code></span>
<span class="codeline" id="line-1747"><code></code></span>
<span class="codeline" id="line-1748"><code>// Close the connection.</code></span>
<span class="codeline" id="line-1749"><code>func (c *conn) close() {</code></span>
<span class="codeline" id="line-1750"><code>	c.finalFlush()</code></span>
<span class="codeline" id="line-1751"><code>	c.rwc.Close()</code></span>
<span class="codeline" id="line-1752"><code>}</code></span>
<span class="codeline" id="line-1753"><code></code></span>
<span class="codeline" id="line-1754"><code>// rstAvoidanceDelay is the amount of time we sleep after closing the</code></span>
<span class="codeline" id="line-1755"><code>// write side of a TCP connection before closing the entire socket.</code></span>
<span class="codeline" id="line-1756"><code>// By sleeping, we increase the chances that the client sees our FIN</code></span>
<span class="codeline" id="line-1757"><code>// and processes its final data before they process the subsequent RST</code></span>
<span class="codeline" id="line-1758"><code>// from closing a connection with known unread data.</code></span>
<span class="codeline" id="line-1759"><code>// This RST seems to occur mostly on BSD systems. (And Windows?)</code></span>
<span class="codeline" id="line-1760"><code>// This timeout is somewhat arbitrary (~latency around the planet),</code></span>
<span class="codeline" id="line-1761"><code>// and may be modified by tests.</code></span>
<span class="codeline" id="line-1762"><code>//</code></span>
<span class="codeline" id="line-1763"><code>// TODO(bcmills): This should arguably be a server configuration parameter,</code></span>
<span class="codeline" id="line-1764"><code>// not a hard-coded value.</code></span>
<span class="codeline" id="line-1765"><code>var rstAvoidanceDelay = 500 * time.Millisecond</code></span>
<span class="codeline" id="line-1766"><code></code></span>
<span class="codeline" id="line-1767"><code>type closeWriter interface {</code></span>
<span class="codeline" id="line-1768"><code>	CloseWrite() error</code></span>
<span class="codeline" id="line-1769"><code>}</code></span>
<span class="codeline" id="line-1770"><code></code></span>
<span class="codeline" id="line-1771"><code>var _ closeWriter = (*net.TCPConn)(nil)</code></span>
<span class="codeline" id="line-1772"><code></code></span>
<span class="codeline" id="line-1773"><code>// closeWriteAndWait flushes any outstanding data and sends a FIN packet (if</code></span>
<span class="codeline" id="line-1774"><code>// client is connected via TCP), signaling that we're done. We then</code></span>
<span class="codeline" id="line-1775"><code>// pause for a bit, hoping the client processes it before any</code></span>
<span class="codeline" id="line-1776"><code>// subsequent RST.</code></span>
<span class="codeline" id="line-1777"><code>//</code></span>
<span class="codeline" id="line-1778"><code>// See https://golang.org/issue/3595</code></span>
<span class="codeline" id="line-1779"><code>func (c *conn) closeWriteAndWait() {</code></span>
<span class="codeline" id="line-1780"><code>	c.finalFlush()</code></span>
<span class="codeline" id="line-1781"><code>	if tcp, ok := c.rwc.(closeWriter); ok {</code></span>
<span class="codeline" id="line-1782"><code>		tcp.CloseWrite()</code></span>
<span class="codeline" id="line-1783"><code>	}</code></span>
<span class="codeline" id="line-1784"><code></code></span>
<span class="codeline" id="line-1785"><code>	// When we return from closeWriteAndWait, the caller will fully close the</code></span>
<span class="codeline" id="line-1786"><code>	// connection. If client is still writing to the connection, this will cause</code></span>
<span class="codeline" id="line-1787"><code>	// the write to fail with ECONNRESET or similar. Unfortunately, many TCP</code></span>
<span class="codeline" id="line-1788"><code>	// implementations will also drop unread packets from the client's read buffer</code></span>
<span class="codeline" id="line-1789"><code>	// when a write fails, causing our final response to be truncated away too.</code></span>
<span class="codeline" id="line-1790"><code>	//</code></span>
<span class="codeline" id="line-1791"><code>	// As a result, https://www.rfc-editor.org/rfc/rfc7230#section-6.6 recommends</code></span>
<span class="codeline" id="line-1792"><code>	// that “[t]he server … continues to read from the connection until it</code></span>
<span class="codeline" id="line-1793"><code>	// receives a corresponding close by the client, or until the server is</code></span>
<span class="codeline" id="line-1794"><code>	// reasonably certain that its own TCP stack has received the client's</code></span>
<span class="codeline" id="line-1795"><code>	// acknowledgement of the packet(s) containing the server's last response.”</code></span>
<span class="codeline" id="line-1796"><code>	//</code></span>
<span class="codeline" id="line-1797"><code>	// Unfortunately, we have no straightforward way to be “reasonably certain”</code></span>
<span class="codeline" id="line-1798"><code>	// that we have received the client's ACK, and at any rate we don't want to</code></span>
<span class="codeline" id="line-1799"><code>	// allow a misbehaving client to soak up server connections indefinitely by</code></span>
<span class="codeline" id="line-1800"><code>	// withholding an ACK, nor do we want to go through the complexity or overhead</code></span>
<span class="codeline" id="line-1801"><code>	// of using low-level APIs to figure out when a TCP round-trip has completed.</code></span>
<span class="codeline" id="line-1802"><code>	//</code></span>
<span class="codeline" id="line-1803"><code>	// Instead, we declare that we are “reasonably certain” that we received the</code></span>
<span class="codeline" id="line-1804"><code>	// ACK if maxRSTAvoidanceDelay has elapsed.</code></span>
<span class="codeline" id="line-1805"><code>	time.Sleep(rstAvoidanceDelay)</code></span>
<span class="codeline" id="line-1806"><code>}</code></span>
<span class="codeline" id="line-1807"><code></code></span>
<span class="codeline" id="line-1808"><code>// validNextProto reports whether the proto is a valid ALPN protocol name.</code></span>
<span class="codeline" id="line-1809"><code>// Everything is valid except the empty string and built-in protocol types,</code></span>
<span class="codeline" id="line-1810"><code>// so that those can't be overridden with alternate implementations.</code></span>
<span class="codeline" id="line-1811"><code>func validNextProto(proto string) bool {</code></span>
<span class="codeline" id="line-1812"><code>	switch proto {</code></span>
<span class="codeline" id="line-1813"><code>	case "", "http/1.1", "http/1.0":</code></span>
<span class="codeline" id="line-1814"><code>		return false</code></span>
<span class="codeline" id="line-1815"><code>	}</code></span>
<span class="codeline" id="line-1816"><code>	return true</code></span>
<span class="codeline" id="line-1817"><code>}</code></span>
<span class="codeline" id="line-1818"><code></code></span>
<span class="codeline" id="line-1819"><code>const (</code></span>
<span class="codeline" id="line-1820"><code>	runHooks  = true</code></span>
<span class="codeline" id="line-1821"><code>	skipHooks = false</code></span>
<span class="codeline" id="line-1822"><code>)</code></span>
<span class="codeline" id="line-1823"><code></code></span>
<span class="codeline" id="line-1824"><code>func (c *conn) setState(nc net.Conn, state ConnState, runHook bool) {</code></span>
<span class="codeline" id="line-1825"><code>	srv := c.server</code></span>
<span class="codeline" id="line-1826"><code>	switch state {</code></span>
<span class="codeline" id="line-1827"><code>	case StateNew:</code></span>
<span class="codeline" id="line-1828"><code>		srv.trackConn(c, true)</code></span>
<span class="codeline" id="line-1829"><code>	case StateHijacked, StateClosed:</code></span>
<span class="codeline" id="line-1830"><code>		srv.trackConn(c, false)</code></span>
<span class="codeline" id="line-1831"><code>	}</code></span>
<span class="codeline" id="line-1832"><code>	if state &gt; 0xff || state &lt; 0 {</code></span>
<span class="codeline" id="line-1833"><code>		panic("internal error")</code></span>
<span class="codeline" id="line-1834"><code>	}</code></span>
<span class="codeline" id="line-1835"><code>	packedState := uint64(time.Now().Unix()&lt;&lt;8) | uint64(state)</code></span>
<span class="codeline" id="line-1836"><code>	c.curState.Store(packedState)</code></span>
<span class="codeline" id="line-1837"><code>	if !runHook {</code></span>
<span class="codeline" id="line-1838"><code>		return</code></span>
<span class="codeline" id="line-1839"><code>	}</code></span>
<span class="codeline" id="line-1840"><code>	if hook := srv.ConnState; hook != nil {</code></span>
<span class="codeline" id="line-1841"><code>		hook(nc, state)</code></span>
<span class="codeline" id="line-1842"><code>	}</code></span>
<span class="codeline" id="line-1843"><code>}</code></span>
<span class="codeline" id="line-1844"><code></code></span>
<span class="codeline" id="line-1845"><code>func (c *conn) getState() (state ConnState, unixSec int64) {</code></span>
<span class="codeline" id="line-1846"><code>	packedState := c.curState.Load()</code></span>
<span class="codeline" id="line-1847"><code>	return ConnState(packedState &amp; 0xff), int64(packedState &gt;&gt; 8)</code></span>
<span class="codeline" id="line-1848"><code>}</code></span>
<span class="codeline" id="line-1849"><code></code></span>
<span class="codeline" id="line-1850"><code>// badRequestError is a literal string (used by in the server in HTML,</code></span>
<span class="codeline" id="line-1851"><code>// unescaped) to tell the user why their request was bad. It should</code></span>
<span class="codeline" id="line-1852"><code>// be plain text without user info or other embedded errors.</code></span>
<span class="codeline" id="line-1853"><code>func badRequestError(e string) error { return statusError{StatusBadRequest, e} }</code></span>
<span class="codeline" id="line-1854"><code></code></span>
<span class="codeline" id="line-1855"><code>// statusError is an error used to respond to a request with an HTTP status.</code></span>
<span class="codeline" id="line-1856"><code>// The text should be plain text without user info or other embedded errors.</code></span>
<span class="codeline" id="line-1857"><code>type statusError struct {</code></span>
<span class="codeline" id="line-1858"><code>	code int</code></span>
<span class="codeline" id="line-1859"><code>	text string</code></span>
<span class="codeline" id="line-1860"><code>}</code></span>
<span class="codeline" id="line-1861"><code></code></span>
<span class="codeline" id="line-1862"><code>func (e statusError) Error() string { return StatusText(e.code) + ": " + e.text }</code></span>
<span class="codeline" id="line-1863"><code></code></span>
<span class="codeline" id="line-1864"><code>// ErrAbortHandler is a sentinel panic value to abort a handler.</code></span>
<span class="codeline" id="line-1865"><code>// While any panic from ServeHTTP aborts the response to the client,</code></span>
<span class="codeline" id="line-1866"><code>// panicking with ErrAbortHandler also suppresses logging of a stack</code></span>
<span class="codeline" id="line-1867"><code>// trace to the server's error log.</code></span>
<span class="codeline" id="line-1868"><code>var ErrAbortHandler = errors.New("net/http: abort Handler")</code></span>
<span class="codeline" id="line-1869"><code></code></span>
<span class="codeline" id="line-1870"><code>// isCommonNetReadError reports whether err is a common error</code></span>
<span class="codeline" id="line-1871"><code>// encountered during reading a request off the network when the</code></span>
<span class="codeline" id="line-1872"><code>// client has gone away or had its read fail somehow. This is used to</code></span>
<span class="codeline" id="line-1873"><code>// determine which logs are interesting enough to log about.</code></span>
<span class="codeline" id="line-1874"><code>func isCommonNetReadError(err error) bool {</code></span>
<span class="codeline" id="line-1875"><code>	if err == io.EOF {</code></span>
<span class="codeline" id="line-1876"><code>		return true</code></span>
<span class="codeline" id="line-1877"><code>	}</code></span>
<span class="codeline" id="line-1878"><code>	if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() {</code></span>
<span class="codeline" id="line-1879"><code>		return true</code></span>
<span class="codeline" id="line-1880"><code>	}</code></span>
<span class="codeline" id="line-1881"><code>	if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == "read" {</code></span>
<span class="codeline" id="line-1882"><code>		return true</code></span>
<span class="codeline" id="line-1883"><code>	}</code></span>
<span class="codeline" id="line-1884"><code>	return false</code></span>
<span class="codeline" id="line-1885"><code>}</code></span>
<span class="codeline" id="line-1886"><code></code></span>
<span class="codeline" id="line-1887"><code>// Serve a new connection.</code></span>
<span class="codeline" id="line-1888"><code>func (c *conn) serve(ctx context.Context) {</code></span>
<span class="codeline" id="line-1889"><code>	if ra := c.rwc.RemoteAddr(); ra != nil {</code></span>
<span class="codeline" id="line-1890"><code>		c.remoteAddr = ra.String()</code></span>
<span class="codeline" id="line-1891"><code>	}</code></span>
<span class="codeline" id="line-1892"><code>	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</code></span>
<span class="codeline" id="line-1893"><code>	var inFlightResponse *response</code></span>
<span class="codeline" id="line-1894"><code>	defer func() {</code></span>
<span class="codeline" id="line-1895"><code>		if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {</code></span>
<span class="codeline" id="line-1896"><code>			const size = 64 &lt;&lt; 10</code></span>
<span class="codeline" id="line-1897"><code>			buf := make([]byte, size)</code></span>
<span class="codeline" id="line-1898"><code>			buf = buf[:runtime.Stack(buf, false)]</code></span>
<span class="codeline" id="line-1899"><code>			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)</code></span>
<span class="codeline" id="line-1900"><code>		}</code></span>
<span class="codeline" id="line-1901"><code>		if inFlightResponse != nil {</code></span>
<span class="codeline" id="line-1902"><code>			inFlightResponse.cancelCtx()</code></span>
<span class="codeline" id="line-1903"><code>		}</code></span>
<span class="codeline" id="line-1904"><code>		if !c.hijacked() {</code></span>
<span class="codeline" id="line-1905"><code>			if inFlightResponse != nil {</code></span>
<span class="codeline" id="line-1906"><code>				inFlightResponse.conn.r.abortPendingRead()</code></span>
<span class="codeline" id="line-1907"><code>				inFlightResponse.reqBody.Close()</code></span>
<span class="codeline" id="line-1908"><code>			}</code></span>
<span class="codeline" id="line-1909"><code>			c.close()</code></span>
<span class="codeline" id="line-1910"><code>			c.setState(c.rwc, StateClosed, runHooks)</code></span>
<span class="codeline" id="line-1911"><code>		}</code></span>
<span class="codeline" id="line-1912"><code>	}()</code></span>
<span class="codeline" id="line-1913"><code></code></span>
<span class="codeline" id="line-1914"><code>	if tlsConn, ok := c.rwc.(*tls.Conn); ok {</code></span>
<span class="codeline" id="line-1915"><code>		tlsTO := c.server.tlsHandshakeTimeout()</code></span>
<span class="codeline" id="line-1916"><code>		if tlsTO &gt; 0 {</code></span>
<span class="codeline" id="line-1917"><code>			dl := time.Now().Add(tlsTO)</code></span>
<span class="codeline" id="line-1918"><code>			c.rwc.SetReadDeadline(dl)</code></span>
<span class="codeline" id="line-1919"><code>			c.rwc.SetWriteDeadline(dl)</code></span>
<span class="codeline" id="line-1920"><code>		}</code></span>
<span class="codeline" id="line-1921"><code>		if err := tlsConn.HandshakeContext(ctx); err != nil {</code></span>
<span class="codeline" id="line-1922"><code>			// If the handshake failed due to the client not speaking</code></span>
<span class="codeline" id="line-1923"><code>			// TLS, assume they're speaking plaintext HTTP and write a</code></span>
<span class="codeline" id="line-1924"><code>			// 400 response on the TLS conn's underlying net.Conn.</code></span>
<span class="codeline" id="line-1925"><code>			if re, ok := err.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != nil &amp;&amp; tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {</code></span>
<span class="codeline" id="line-1926"><code>				io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")</code></span>
<span class="codeline" id="line-1927"><code>				re.Conn.Close()</code></span>
<span class="codeline" id="line-1928"><code>				return</code></span>
<span class="codeline" id="line-1929"><code>			}</code></span>
<span class="codeline" id="line-1930"><code>			c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)</code></span>
<span class="codeline" id="line-1931"><code>			return</code></span>
<span class="codeline" id="line-1932"><code>		}</code></span>
<span class="codeline" id="line-1933"><code>		// Restore Conn-level deadlines.</code></span>
<span class="codeline" id="line-1934"><code>		if tlsTO &gt; 0 {</code></span>
<span class="codeline" id="line-1935"><code>			c.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-1936"><code>			c.rwc.SetWriteDeadline(time.Time{})</code></span>
<span class="codeline" id="line-1937"><code>		}</code></span>
<span class="codeline" id="line-1938"><code>		c.tlsState = new(tls.ConnectionState)</code></span>
<span class="codeline" id="line-1939"><code>		*c.tlsState = tlsConn.ConnectionState()</code></span>
<span class="codeline" id="line-1940"><code>		if proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {</code></span>
<span class="codeline" id="line-1941"><code>			if fn := c.server.TLSNextProto[proto]; fn != nil {</code></span>
<span class="codeline" id="line-1942"><code>				h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}</code></span>
<span class="codeline" id="line-1943"><code>				// Mark freshly created HTTP/2 as active and prevent any server state hooks</code></span>
<span class="codeline" id="line-1944"><code>				// from being run on these connections. This prevents closeIdleConns from</code></span>
<span class="codeline" id="line-1945"><code>				// closing such connections. See issue https://golang.org/issue/39776.</code></span>
<span class="codeline" id="line-1946"><code>				c.setState(c.rwc, StateActive, skipHooks)</code></span>
<span class="codeline" id="line-1947"><code>				fn(c.server, tlsConn, h)</code></span>
<span class="codeline" id="line-1948"><code>			}</code></span>
<span class="codeline" id="line-1949"><code>			return</code></span>
<span class="codeline" id="line-1950"><code>		}</code></span>
<span class="codeline" id="line-1951"><code>	}</code></span>
<span class="codeline" id="line-1952"><code></code></span>
<span class="codeline" id="line-1953"><code>	// HTTP/1.x from here on.</code></span>
<span class="codeline" id="line-1954"><code></code></span>
<span class="codeline" id="line-1955"><code>	ctx, cancelCtx := context.WithCancel(ctx)</code></span>
<span class="codeline" id="line-1956"><code>	c.cancelCtx = cancelCtx</code></span>
<span class="codeline" id="line-1957"><code>	defer cancelCtx()</code></span>
<span class="codeline" id="line-1958"><code></code></span>
<span class="codeline" id="line-1959"><code>	c.r = &amp;connReader{conn: c}</code></span>
<span class="codeline" id="line-1960"><code>	c.bufr = newBufioReader(c.r)</code></span>
<span class="codeline" id="line-1961"><code>	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)</code></span>
<span class="codeline" id="line-1962"><code></code></span>
<span class="codeline" id="line-1963"><code>	for {</code></span>
<span class="codeline" id="line-1964"><code>		w, err := c.readRequest(ctx)</code></span>
<span class="codeline" id="line-1965"><code>		if c.r.remain != c.server.initialReadLimitSize() {</code></span>
<span class="codeline" id="line-1966"><code>			// If we read any bytes off the wire, we're active.</code></span>
<span class="codeline" id="line-1967"><code>			c.setState(c.rwc, StateActive, runHooks)</code></span>
<span class="codeline" id="line-1968"><code>		}</code></span>
<span class="codeline" id="line-1969"><code>		if err != nil {</code></span>
<span class="codeline" id="line-1970"><code>			const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"</code></span>
<span class="codeline" id="line-1971"><code></code></span>
<span class="codeline" id="line-1972"><code>			switch {</code></span>
<span class="codeline" id="line-1973"><code>			case err == errTooLarge:</code></span>
<span class="codeline" id="line-1974"><code>				// Their HTTP client may or may not be</code></span>
<span class="codeline" id="line-1975"><code>				// able to read this if we're</code></span>
<span class="codeline" id="line-1976"><code>				// responding to them and hanging up</code></span>
<span class="codeline" id="line-1977"><code>				// while they're still writing their</code></span>
<span class="codeline" id="line-1978"><code>				// request. Undefined behavior.</code></span>
<span class="codeline" id="line-1979"><code>				const publicErr = "431 Request Header Fields Too Large"</code></span>
<span class="codeline" id="line-1980"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)</code></span>
<span class="codeline" id="line-1981"><code>				c.closeWriteAndWait()</code></span>
<span class="codeline" id="line-1982"><code>				return</code></span>
<span class="codeline" id="line-1983"><code></code></span>
<span class="codeline" id="line-1984"><code>			case isUnsupportedTEError(err):</code></span>
<span class="codeline" id="line-1985"><code>				// Respond as per RFC 7230 Section 3.3.1 which says,</code></span>
<span class="codeline" id="line-1986"><code>				//      A server that receives a request message with a</code></span>
<span class="codeline" id="line-1987"><code>				//      transfer coding it does not understand SHOULD</code></span>
<span class="codeline" id="line-1988"><code>				//      respond with 501 (Unimplemented).</code></span>
<span class="codeline" id="line-1989"><code>				code := StatusNotImplemented</code></span>
<span class="codeline" id="line-1990"><code></code></span>
<span class="codeline" id="line-1991"><code>				// We purposefully aren't echoing back the transfer-encoding's value,</code></span>
<span class="codeline" id="line-1992"><code>				// so as to mitigate the risk of cross side scripting by an attacker.</code></span>
<span class="codeline" id="line-1993"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s%sUnsupported transfer encoding", code, StatusText(code), errorHeaders)</code></span>
<span class="codeline" id="line-1994"><code>				return</code></span>
<span class="codeline" id="line-1995"><code></code></span>
<span class="codeline" id="line-1996"><code>			case isCommonNetReadError(err):</code></span>
<span class="codeline" id="line-1997"><code>				return // don't reply</code></span>
<span class="codeline" id="line-1998"><code></code></span>
<span class="codeline" id="line-1999"><code>			default:</code></span>
<span class="codeline" id="line-2000"><code>				if v, ok := err.(statusError); ok {</code></span>
<span class="codeline" id="line-2001"><code>					fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s: %s%s%d %s: %s", v.code, StatusText(v.code), v.text, errorHeaders, v.code, StatusText(v.code), v.text)</code></span>
<span class="codeline" id="line-2002"><code>					return</code></span>
<span class="codeline" id="line-2003"><code>				}</code></span>
<span class="codeline" id="line-2004"><code>				const publicErr = "400 Bad Request"</code></span>
<span class="codeline" id="line-2005"><code>				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)</code></span>
<span class="codeline" id="line-2006"><code>				return</code></span>
<span class="codeline" id="line-2007"><code>			}</code></span>
<span class="codeline" id="line-2008"><code>		}</code></span>
<span class="codeline" id="line-2009"><code></code></span>
<span class="codeline" id="line-2010"><code>		// Expect 100 Continue support</code></span>
<span class="codeline" id="line-2011"><code>		req := w.req</code></span>
<span class="codeline" id="line-2012"><code>		if req.expectsContinue() {</code></span>
<span class="codeline" id="line-2013"><code>			if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {</code></span>
<span class="codeline" id="line-2014"><code>				// Wrap the Body reader with one that replies on the connection</code></span>
<span class="codeline" id="line-2015"><code>				req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}</code></span>
<span class="codeline" id="line-2016"><code>				w.canWriteContinue.Store(true)</code></span>
<span class="codeline" id="line-2017"><code>			}</code></span>
<span class="codeline" id="line-2018"><code>		} else if req.Header.get("Expect") != "" {</code></span>
<span class="codeline" id="line-2019"><code>			w.sendExpectationFailed()</code></span>
<span class="codeline" id="line-2020"><code>			return</code></span>
<span class="codeline" id="line-2021"><code>		}</code></span>
<span class="codeline" id="line-2022"><code></code></span>
<span class="codeline" id="line-2023"><code>		c.curReq.Store(w)</code></span>
<span class="codeline" id="line-2024"><code></code></span>
<span class="codeline" id="line-2025"><code>		if requestBodyRemains(req.Body) {</code></span>
<span class="codeline" id="line-2026"><code>			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</code></span>
<span class="codeline" id="line-2027"><code>		} else {</code></span>
<span class="codeline" id="line-2028"><code>			w.conn.r.startBackgroundRead()</code></span>
<span class="codeline" id="line-2029"><code>		}</code></span>
<span class="codeline" id="line-2030"><code></code></span>
<span class="codeline" id="line-2031"><code>		// HTTP cannot have multiple simultaneous active requests.[*]</code></span>
<span class="codeline" id="line-2032"><code>		// Until the server replies to this request, it can't read another,</code></span>
<span class="codeline" id="line-2033"><code>		// so we might as well run the handler in this goroutine.</code></span>
<span class="codeline" id="line-2034"><code>		// [*] Not strictly true: HTTP pipelining. We could let them all process</code></span>
<span class="codeline" id="line-2035"><code>		// in parallel even if their responses need to be serialized.</code></span>
<span class="codeline" id="line-2036"><code>		// But we're not going to implement HTTP pipelining because it</code></span>
<span class="codeline" id="line-2037"><code>		// was never deployed in the wild and the answer is HTTP/2.</code></span>
<span class="codeline" id="line-2038"><code>		inFlightResponse = w</code></span>
<span class="codeline" id="line-2039"><code>		serverHandler{c.server}.ServeHTTP(w, w.req)</code></span>
<span class="codeline" id="line-2040"><code>		inFlightResponse = nil</code></span>
<span class="codeline" id="line-2041"><code>		w.cancelCtx()</code></span>
<span class="codeline" id="line-2042"><code>		if c.hijacked() {</code></span>
<span class="codeline" id="line-2043"><code>			return</code></span>
<span class="codeline" id="line-2044"><code>		}</code></span>
<span class="codeline" id="line-2045"><code>		w.finishRequest()</code></span>
<span class="codeline" id="line-2046"><code>		c.rwc.SetWriteDeadline(time.Time{})</code></span>
<span class="codeline" id="line-2047"><code>		if !w.shouldReuseConnection() {</code></span>
<span class="codeline" id="line-2048"><code>			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {</code></span>
<span class="codeline" id="line-2049"><code>				c.closeWriteAndWait()</code></span>
<span class="codeline" id="line-2050"><code>			}</code></span>
<span class="codeline" id="line-2051"><code>			return</code></span>
<span class="codeline" id="line-2052"><code>		}</code></span>
<span class="codeline" id="line-2053"><code>		c.setState(c.rwc, StateIdle, runHooks)</code></span>
<span class="codeline" id="line-2054"><code>		c.curReq.Store(nil)</code></span>
<span class="codeline" id="line-2055"><code></code></span>
<span class="codeline" id="line-2056"><code>		if !w.conn.server.doKeepAlives() {</code></span>
<span class="codeline" id="line-2057"><code>			// We're in shutdown mode. We might've replied</code></span>
<span class="codeline" id="line-2058"><code>			// to the user without "Connection: close" and</code></span>
<span class="codeline" id="line-2059"><code>			// they might think they can send another</code></span>
<span class="codeline" id="line-2060"><code>			// request, but such is life with HTTP/1.1.</code></span>
<span class="codeline" id="line-2061"><code>			return</code></span>
<span class="codeline" id="line-2062"><code>		}</code></span>
<span class="codeline" id="line-2063"><code></code></span>
<span class="codeline" id="line-2064"><code>		if d := c.server.idleTimeout(); d != 0 {</code></span>
<span class="codeline" id="line-2065"><code>			c.rwc.SetReadDeadline(time.Now().Add(d))</code></span>
<span class="codeline" id="line-2066"><code>		} else {</code></span>
<span class="codeline" id="line-2067"><code>			c.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-2068"><code>		}</code></span>
<span class="codeline" id="line-2069"><code></code></span>
<span class="codeline" id="line-2070"><code>		// Wait for the connection to become readable again before trying to</code></span>
<span class="codeline" id="line-2071"><code>		// read the next request. This prevents a ReadHeaderTimeout or</code></span>
<span class="codeline" id="line-2072"><code>		// ReadTimeout from starting until the first bytes of the next request</code></span>
<span class="codeline" id="line-2073"><code>		// have been received.</code></span>
<span class="codeline" id="line-2074"><code>		if _, err := c.bufr.Peek(4); err != nil {</code></span>
<span class="codeline" id="line-2075"><code>			return</code></span>
<span class="codeline" id="line-2076"><code>		}</code></span>
<span class="codeline" id="line-2077"><code></code></span>
<span class="codeline" id="line-2078"><code>		c.rwc.SetReadDeadline(time.Time{})</code></span>
<span class="codeline" id="line-2079"><code>	}</code></span>
<span class="codeline" id="line-2080"><code>}</code></span>
<span class="codeline" id="line-2081"><code></code></span>
<span class="codeline" id="line-2082"><code>func (w *response) sendExpectationFailed() {</code></span>
<span class="codeline" id="line-2083"><code>	// TODO(bradfitz): let ServeHTTP handlers handle</code></span>
<span class="codeline" id="line-2084"><code>	// requests with non-standard expectation[s]? Seems</code></span>
<span class="codeline" id="line-2085"><code>	// theoretical at best, and doesn't fit into the</code></span>
<span class="codeline" id="line-2086"><code>	// current ServeHTTP model anyway. We'd need to</code></span>
<span class="codeline" id="line-2087"><code>	// make the ResponseWriter an optional</code></span>
<span class="codeline" id="line-2088"><code>	// "ExpectReplier" interface or something.</code></span>
<span class="codeline" id="line-2089"><code>	//</code></span>
<span class="codeline" id="line-2090"><code>	// For now we'll just obey RFC 7231 5.1.1 which says</code></span>
<span class="codeline" id="line-2091"><code>	// "A server that receives an Expect field-value other</code></span>
<span class="codeline" id="line-2092"><code>	// than 100-continue MAY respond with a 417 (Expectation</code></span>
<span class="codeline" id="line-2093"><code>	// Failed) status code to indicate that the unexpected</code></span>
<span class="codeline" id="line-2094"><code>	// expectation cannot be met."</code></span>
<span class="codeline" id="line-2095"><code>	w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-2096"><code>	w.WriteHeader(StatusExpectationFailed)</code></span>
<span class="codeline" id="line-2097"><code>	w.finishRequest()</code></span>
<span class="codeline" id="line-2098"><code>}</code></span>
<span class="codeline" id="line-2099"><code></code></span>
<span class="codeline" id="line-2100"><code>// Hijack implements the [Hijacker.Hijack] method. Our response is both a [ResponseWriter]</code></span>
<span class="codeline" id="line-2101"><code>// and a [Hijacker].</code></span>
<span class="codeline" id="line-2102"><code>func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error) {</code></span>
<span class="codeline" id="line-2103"><code>	if w.handlerDone.Load() {</code></span>
<span class="codeline" id="line-2104"><code>		panic("net/http: Hijack called after ServeHTTP finished")</code></span>
<span class="codeline" id="line-2105"><code>	}</code></span>
<span class="codeline" id="line-2106"><code>	if w.wroteHeader {</code></span>
<span class="codeline" id="line-2107"><code>		w.cw.flush()</code></span>
<span class="codeline" id="line-2108"><code>	}</code></span>
<span class="codeline" id="line-2109"><code></code></span>
<span class="codeline" id="line-2110"><code>	c := w.conn</code></span>
<span class="codeline" id="line-2111"><code>	c.mu.Lock()</code></span>
<span class="codeline" id="line-2112"><code>	defer c.mu.Unlock()</code></span>
<span class="codeline" id="line-2113"><code></code></span>
<span class="codeline" id="line-2114"><code>	// Release the bufioWriter that writes to the chunk writer, it is not</code></span>
<span class="codeline" id="line-2115"><code>	// used after a connection has been hijacked.</code></span>
<span class="codeline" id="line-2116"><code>	rwc, buf, err = c.hijackLocked()</code></span>
<span class="codeline" id="line-2117"><code>	if err == nil {</code></span>
<span class="codeline" id="line-2118"><code>		putBufioWriter(w.w)</code></span>
<span class="codeline" id="line-2119"><code>		w.w = nil</code></span>
<span class="codeline" id="line-2120"><code>	}</code></span>
<span class="codeline" id="line-2121"><code>	return rwc, buf, err</code></span>
<span class="codeline" id="line-2122"><code>}</code></span>
<span class="codeline" id="line-2123"><code></code></span>
<span class="codeline" id="line-2124"><code>func (w *response) CloseNotify() &lt;-chan bool {</code></span>
<span class="codeline" id="line-2125"><code>	if w.handlerDone.Load() {</code></span>
<span class="codeline" id="line-2126"><code>		panic("net/http: CloseNotify called after ServeHTTP finished")</code></span>
<span class="codeline" id="line-2127"><code>	}</code></span>
<span class="codeline" id="line-2128"><code>	return w.closeNotifyCh</code></span>
<span class="codeline" id="line-2129"><code>}</code></span>
<span class="codeline" id="line-2130"><code></code></span>
<span class="codeline" id="line-2131"><code>func registerOnHitEOF(rc io.ReadCloser, fn func()) {</code></span>
<span class="codeline" id="line-2132"><code>	switch v := rc.(type) {</code></span>
<span class="codeline" id="line-2133"><code>	case *expectContinueReader:</code></span>
<span class="codeline" id="line-2134"><code>		registerOnHitEOF(v.readCloser, fn)</code></span>
<span class="codeline" id="line-2135"><code>	case *body:</code></span>
<span class="codeline" id="line-2136"><code>		v.registerOnHitEOF(fn)</code></span>
<span class="codeline" id="line-2137"><code>	default:</code></span>
<span class="codeline" id="line-2138"><code>		panic("unexpected type " + fmt.Sprintf("%T", rc))</code></span>
<span class="codeline" id="line-2139"><code>	}</code></span>
<span class="codeline" id="line-2140"><code>}</code></span>
<span class="codeline" id="line-2141"><code></code></span>
<span class="codeline" id="line-2142"><code>// requestBodyRemains reports whether future calls to Read</code></span>
<span class="codeline" id="line-2143"><code>// on rc might yield more data.</code></span>
<span class="codeline" id="line-2144"><code>func requestBodyRemains(rc io.ReadCloser) bool {</code></span>
<span class="codeline" id="line-2145"><code>	if rc == NoBody {</code></span>
<span class="codeline" id="line-2146"><code>		return false</code></span>
<span class="codeline" id="line-2147"><code>	}</code></span>
<span class="codeline" id="line-2148"><code>	switch v := rc.(type) {</code></span>
<span class="codeline" id="line-2149"><code>	case *expectContinueReader:</code></span>
<span class="codeline" id="line-2150"><code>		return requestBodyRemains(v.readCloser)</code></span>
<span class="codeline" id="line-2151"><code>	case *body:</code></span>
<span class="codeline" id="line-2152"><code>		return v.bodyRemains()</code></span>
<span class="codeline" id="line-2153"><code>	default:</code></span>
<span class="codeline" id="line-2154"><code>		panic("unexpected type " + fmt.Sprintf("%T", rc))</code></span>
<span class="codeline" id="line-2155"><code>	}</code></span>
<span class="codeline" id="line-2156"><code>}</code></span>
<span class="codeline" id="line-2157"><code></code></span>
<span class="codeline" id="line-2158"><code>// The HandlerFunc type is an adapter to allow the use of</code></span>
<span class="codeline" id="line-2159"><code>// ordinary functions as HTTP handlers. If f is a function</code></span>
<span class="codeline" id="line-2160"><code>// with the appropriate signature, HandlerFunc(f) is a</code></span>
<span class="codeline" id="line-2161"><code>// [Handler] that calls f.</code></span>
<span class="codeline" id="line-2162"><code>type HandlerFunc func(ResponseWriter, *Request)</code></span>
<span class="codeline" id="line-2163"><code></code></span>
<span class="codeline" id="line-2164"><code>// ServeHTTP calls f(w, r).</code></span>
<span class="codeline" id="line-2165"><code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2166"><code>	f(w, r)</code></span>
<span class="codeline" id="line-2167"><code>}</code></span>
<span class="codeline" id="line-2168"><code></code></span>
<span class="codeline" id="line-2169"><code>// Helper handlers</code></span>
<span class="codeline" id="line-2170"><code></code></span>
<span class="codeline" id="line-2171"><code>// Error replies to the request with the specified error message and HTTP code.</code></span>
<span class="codeline" id="line-2172"><code>// It does not otherwise end the request; the caller should ensure no further</code></span>
<span class="codeline" id="line-2173"><code>// writes are done to w.</code></span>
<span class="codeline" id="line-2174"><code>// The error message should be plain text.</code></span>
<span class="codeline" id="line-2175"><code>func Error(w ResponseWriter, error string, code int) {</code></span>
<span class="codeline" id="line-2176"><code>	w.Header().Set("Content-Type", "text/plain; charset=utf-8")</code></span>
<span class="codeline" id="line-2177"><code>	w.Header().Set("X-Content-Type-Options", "nosniff")</code></span>
<span class="codeline" id="line-2178"><code>	w.WriteHeader(code)</code></span>
<span class="codeline" id="line-2179"><code>	fmt.Fprintln(w, error)</code></span>
<span class="codeline" id="line-2180"><code>}</code></span>
<span class="codeline" id="line-2181"><code></code></span>
<span class="codeline" id="line-2182"><code>// NotFound replies to the request with an HTTP 404 not found error.</code></span>
<span class="codeline" id="line-2183"><code>func NotFound(w ResponseWriter, r *Request) { Error(w, "404 page not found", StatusNotFound) }</code></span>
<span class="codeline" id="line-2184"><code></code></span>
<span class="codeline" id="line-2185"><code>// NotFoundHandler returns a simple request handler</code></span>
<span class="codeline" id="line-2186"><code>// that replies to each request with a “404 page not found” reply.</code></span>
<span class="codeline" id="line-2187"><code>func NotFoundHandler() Handler { return HandlerFunc(NotFound) }</code></span>
<span class="codeline" id="line-2188"><code></code></span>
<span class="codeline" id="line-2189"><code>// StripPrefix returns a handler that serves HTTP requests by removing the</code></span>
<span class="codeline" id="line-2190"><code>// given prefix from the request URL's Path (and RawPath if set) and invoking</code></span>
<span class="codeline" id="line-2191"><code>// the handler h. StripPrefix handles a request for a path that doesn't begin</code></span>
<span class="codeline" id="line-2192"><code>// with prefix by replying with an HTTP 404 not found error. The prefix must</code></span>
<span class="codeline" id="line-2193"><code>// match exactly: if the prefix in the request contains escaped characters</code></span>
<span class="codeline" id="line-2194"><code>// the reply is also an HTTP 404 not found error.</code></span>
<span class="codeline" id="line-2195"><code>func StripPrefix(prefix string, h Handler) Handler {</code></span>
<span class="codeline" id="line-2196"><code>	if prefix == "" {</code></span>
<span class="codeline" id="line-2197"><code>		return h</code></span>
<span class="codeline" id="line-2198"><code>	}</code></span>
<span class="codeline" id="line-2199"><code>	return HandlerFunc(func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2200"><code>		p := strings.TrimPrefix(r.URL.Path, prefix)</code></span>
<span class="codeline" id="line-2201"><code>		rp := strings.TrimPrefix(r.URL.RawPath, prefix)</code></span>
<span class="codeline" id="line-2202"><code>		if len(p) &lt; len(r.URL.Path) &amp;&amp; (r.URL.RawPath == "" || len(rp) &lt; len(r.URL.RawPath)) {</code></span>
<span class="codeline" id="line-2203"><code>			r2 := new(Request)</code></span>
<span class="codeline" id="line-2204"><code>			*r2 = *r</code></span>
<span class="codeline" id="line-2205"><code>			r2.URL = new(url.URL)</code></span>
<span class="codeline" id="line-2206"><code>			*r2.URL = *r.URL</code></span>
<span class="codeline" id="line-2207"><code>			r2.URL.Path = p</code></span>
<span class="codeline" id="line-2208"><code>			r2.URL.RawPath = rp</code></span>
<span class="codeline" id="line-2209"><code>			h.ServeHTTP(w, r2)</code></span>
<span class="codeline" id="line-2210"><code>		} else {</code></span>
<span class="codeline" id="line-2211"><code>			NotFound(w, r)</code></span>
<span class="codeline" id="line-2212"><code>		}</code></span>
<span class="codeline" id="line-2213"><code>	})</code></span>
<span class="codeline" id="line-2214"><code>}</code></span>
<span class="codeline" id="line-2215"><code></code></span>
<span class="codeline" id="line-2216"><code>// Redirect replies to the request with a redirect to url,</code></span>
<span class="codeline" id="line-2217"><code>// which may be a path relative to the request path.</code></span>
<span class="codeline" id="line-2218"><code>//</code></span>
<span class="codeline" id="line-2219"><code>// The provided code should be in the 3xx range and is usually</code></span>
<span class="codeline" id="line-2220"><code>// [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].</code></span>
<span class="codeline" id="line-2221"><code>//</code></span>
<span class="codeline" id="line-2222"><code>// If the Content-Type header has not been set, [Redirect] sets it</code></span>
<span class="codeline" id="line-2223"><code>// to "text/html; charset=utf-8" and writes a small HTML body.</code></span>
<span class="codeline" id="line-2224"><code>// Setting the Content-Type header to any value, including nil,</code></span>
<span class="codeline" id="line-2225"><code>// disables that behavior.</code></span>
<span class="codeline" id="line-2226"><code>func Redirect(w ResponseWriter, r *Request, url string, code int) {</code></span>
<span class="codeline" id="line-2227"><code>	if u, err := urlpkg.Parse(url); err == nil {</code></span>
<span class="codeline" id="line-2228"><code>		// If url was relative, make its path absolute by</code></span>
<span class="codeline" id="line-2229"><code>		// combining with request path.</code></span>
<span class="codeline" id="line-2230"><code>		// The client would probably do this for us,</code></span>
<span class="codeline" id="line-2231"><code>		// but doing it ourselves is more reliable.</code></span>
<span class="codeline" id="line-2232"><code>		// See RFC 7231, section 7.1.2</code></span>
<span class="codeline" id="line-2233"><code>		if u.Scheme == "" &amp;&amp; u.Host == "" {</code></span>
<span class="codeline" id="line-2234"><code>			oldpath := r.URL.Path</code></span>
<span class="codeline" id="line-2235"><code>			if oldpath == "" { // should not happen, but avoid a crash if it does</code></span>
<span class="codeline" id="line-2236"><code>				oldpath = "/"</code></span>
<span class="codeline" id="line-2237"><code>			}</code></span>
<span class="codeline" id="line-2238"><code></code></span>
<span class="codeline" id="line-2239"><code>			// no leading http://server</code></span>
<span class="codeline" id="line-2240"><code>			if url == "" || url[0] != '/' {</code></span>
<span class="codeline" id="line-2241"><code>				// make relative path absolute</code></span>
<span class="codeline" id="line-2242"><code>				olddir, _ := path.Split(oldpath)</code></span>
<span class="codeline" id="line-2243"><code>				url = olddir + url</code></span>
<span class="codeline" id="line-2244"><code>			}</code></span>
<span class="codeline" id="line-2245"><code></code></span>
<span class="codeline" id="line-2246"><code>			var query string</code></span>
<span class="codeline" id="line-2247"><code>			if i := strings.Index(url, "?"); i != -1 {</code></span>
<span class="codeline" id="line-2248"><code>				url, query = url[:i], url[i:]</code></span>
<span class="codeline" id="line-2249"><code>			}</code></span>
<span class="codeline" id="line-2250"><code></code></span>
<span class="codeline" id="line-2251"><code>			// clean up but preserve trailing slash</code></span>
<span class="codeline" id="line-2252"><code>			trailing := strings.HasSuffix(url, "/")</code></span>
<span class="codeline" id="line-2253"><code>			url = path.Clean(url)</code></span>
<span class="codeline" id="line-2254"><code>			if trailing &amp;&amp; !strings.HasSuffix(url, "/") {</code></span>
<span class="codeline" id="line-2255"><code>				url += "/"</code></span>
<span class="codeline" id="line-2256"><code>			}</code></span>
<span class="codeline" id="line-2257"><code>			url += query</code></span>
<span class="codeline" id="line-2258"><code>		}</code></span>
<span class="codeline" id="line-2259"><code>	}</code></span>
<span class="codeline" id="line-2260"><code></code></span>
<span class="codeline" id="line-2261"><code>	h := w.Header()</code></span>
<span class="codeline" id="line-2262"><code></code></span>
<span class="codeline" id="line-2263"><code>	// RFC 7231 notes that a short HTML body is usually included in</code></span>
<span class="codeline" id="line-2264"><code>	// the response because older user agents may not understand 301/307.</code></span>
<span class="codeline" id="line-2265"><code>	// Do it only if the request didn't already have a Content-Type header.</code></span>
<span class="codeline" id="line-2266"><code>	_, hadCT := h["Content-Type"]</code></span>
<span class="codeline" id="line-2267"><code></code></span>
<span class="codeline" id="line-2268"><code>	h.Set("Location", hexEscapeNonASCII(url))</code></span>
<span class="codeline" id="line-2269"><code>	if !hadCT &amp;&amp; (r.Method == "GET" || r.Method == "HEAD") {</code></span>
<span class="codeline" id="line-2270"><code>		h.Set("Content-Type", "text/html; charset=utf-8")</code></span>
<span class="codeline" id="line-2271"><code>	}</code></span>
<span class="codeline" id="line-2272"><code>	w.WriteHeader(code)</code></span>
<span class="codeline" id="line-2273"><code></code></span>
<span class="codeline" id="line-2274"><code>	// Shouldn't send the body for POST or HEAD; that leaves GET.</code></span>
<span class="codeline" id="line-2275"><code>	if !hadCT &amp;&amp; r.Method == "GET" {</code></span>
<span class="codeline" id="line-2276"><code>		body := "&lt;a href=\"" + htmlEscape(url) + "\"&gt;" + StatusText(code) + "&lt;/a&gt;.\n"</code></span>
<span class="codeline" id="line-2277"><code>		fmt.Fprintln(w, body)</code></span>
<span class="codeline" id="line-2278"><code>	}</code></span>
<span class="codeline" id="line-2279"><code>}</code></span>
<span class="codeline" id="line-2280"><code></code></span>
<span class="codeline" id="line-2281"><code>var htmlReplacer = strings.NewReplacer(</code></span>
<span class="codeline" id="line-2282"><code>	"&amp;", "&amp;amp;",</code></span>
<span class="codeline" id="line-2283"><code>	"&lt;", "&amp;lt;",</code></span>
<span class="codeline" id="line-2284"><code>	"&gt;", "&amp;gt;",</code></span>
<span class="codeline" id="line-2285"><code>	// "&amp;#34;" is shorter than "&amp;quot;".</code></span>
<span class="codeline" id="line-2286"><code>	`"`, "&amp;#34;",</code></span>
<span class="codeline" id="line-2287"><code>	// "&amp;#39;" is shorter than "&amp;apos;" and apos was not in HTML until HTML5.</code></span>
<span class="codeline" id="line-2288"><code>	"'", "&amp;#39;",</code></span>
<span class="codeline" id="line-2289"><code>)</code></span>
<span class="codeline" id="line-2290"><code></code></span>
<span class="codeline" id="line-2291"><code>func htmlEscape(s string) string {</code></span>
<span class="codeline" id="line-2292"><code>	return htmlReplacer.Replace(s)</code></span>
<span class="codeline" id="line-2293"><code>}</code></span>
<span class="codeline" id="line-2294"><code></code></span>
<span class="codeline" id="line-2295"><code>// Redirect to a fixed URL</code></span>
<span class="codeline" id="line-2296"><code>type redirectHandler struct {</code></span>
<span class="codeline" id="line-2297"><code>	url  string</code></span>
<span class="codeline" id="line-2298"><code>	code int</code></span>
<span class="codeline" id="line-2299"><code>}</code></span>
<span class="codeline" id="line-2300"><code></code></span>
<span class="codeline" id="line-2301"><code>func (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2302"><code>	Redirect(w, r, rh.url, rh.code)</code></span>
<span class="codeline" id="line-2303"><code>}</code></span>
<span class="codeline" id="line-2304"><code></code></span>
<span class="codeline" id="line-2305"><code>// RedirectHandler returns a request handler that redirects</code></span>
<span class="codeline" id="line-2306"><code>// each request it receives to the given url using the given</code></span>
<span class="codeline" id="line-2307"><code>// status code.</code></span>
<span class="codeline" id="line-2308"><code>//</code></span>
<span class="codeline" id="line-2309"><code>// The provided code should be in the 3xx range and is usually</code></span>
<span class="codeline" id="line-2310"><code>// [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].</code></span>
<span class="codeline" id="line-2311"><code>func RedirectHandler(url string, code int) Handler {</code></span>
<span class="codeline" id="line-2312"><code>	return &amp;redirectHandler{url, code}</code></span>
<span class="codeline" id="line-2313"><code>}</code></span>
<span class="codeline" id="line-2314"><code></code></span>
<span class="codeline" id="line-2315"><code>// ServeMux is an HTTP request multiplexer.</code></span>
<span class="codeline" id="line-2316"><code>// It matches the URL of each incoming request against a list of registered</code></span>
<span class="codeline" id="line-2317"><code>// patterns and calls the handler for the pattern that</code></span>
<span class="codeline" id="line-2318"><code>// most closely matches the URL.</code></span>
<span class="codeline" id="line-2319"><code>//</code></span>
<span class="codeline" id="line-2320"><code>// # Patterns</code></span>
<span class="codeline" id="line-2321"><code>//</code></span>
<span class="codeline" id="line-2322"><code>// Patterns can match the method, host and path of a request.</code></span>
<span class="codeline" id="line-2323"><code>// Some examples:</code></span>
<span class="codeline" id="line-2324"><code>//</code></span>
<span class="codeline" id="line-2325"><code>//   - "/index.html" matches the path "/index.html" for any host and method.</code></span>
<span class="codeline" id="line-2326"><code>//   - "GET /static/" matches a GET request whose path begins with "/static/".</code></span>
<span class="codeline" id="line-2327"><code>//   - "example.com/" matches any request to the host "example.com".</code></span>
<span class="codeline" id="line-2328"><code>//   - "example.com/{$}" matches requests with host "example.com" and path "/".</code></span>
<span class="codeline" id="line-2329"><code>//   - "/b/{bucket}/o/{objectname...}" matches paths whose first segment is "b"</code></span>
<span class="codeline" id="line-2330"><code>//     and whose third segment is "o". The name "bucket" denotes the second</code></span>
<span class="codeline" id="line-2331"><code>//     segment and "objectname" denotes the remainder of the path.</code></span>
<span class="codeline" id="line-2332"><code>//</code></span>
<span class="codeline" id="line-2333"><code>// In general, a pattern looks like</code></span>
<span class="codeline" id="line-2334"><code>//</code></span>
<span class="codeline" id="line-2335"><code>//	[METHOD ][HOST]/[PATH]</code></span>
<span class="codeline" id="line-2336"><code>//</code></span>
<span class="codeline" id="line-2337"><code>// All three parts are optional; "/" is a valid pattern.</code></span>
<span class="codeline" id="line-2338"><code>// If METHOD is present, it must be followed by a single space.</code></span>
<span class="codeline" id="line-2339"><code>//</code></span>
<span class="codeline" id="line-2340"><code>// Literal (that is, non-wildcard) parts of a pattern match</code></span>
<span class="codeline" id="line-2341"><code>// the corresponding parts of a request case-sensitively.</code></span>
<span class="codeline" id="line-2342"><code>//</code></span>
<span class="codeline" id="line-2343"><code>// A pattern with no method matches every method. A pattern</code></span>
<span class="codeline" id="line-2344"><code>// with the method GET matches both GET and HEAD requests.</code></span>
<span class="codeline" id="line-2345"><code>// Otherwise, the method must match exactly.</code></span>
<span class="codeline" id="line-2346"><code>//</code></span>
<span class="codeline" id="line-2347"><code>// A pattern with no host matches every host.</code></span>
<span class="codeline" id="line-2348"><code>// A pattern with a host matches URLs on that host only.</code></span>
<span class="codeline" id="line-2349"><code>//</code></span>
<span class="codeline" id="line-2350"><code>// A path can include wildcard segments of the form {NAME} or {NAME...}.</code></span>
<span class="codeline" id="line-2351"><code>// For example, "/b/{bucket}/o/{objectname...}".</code></span>
<span class="codeline" id="line-2352"><code>// The wildcard name must be a valid Go identifier.</code></span>
<span class="codeline" id="line-2353"><code>// Wildcards must be full path segments: they must be preceded by a slash and followed by</code></span>
<span class="codeline" id="line-2354"><code>// either a slash or the end of the string.</code></span>
<span class="codeline" id="line-2355"><code>// For example, "/b_{bucket}" is not a valid pattern.</code></span>
<span class="codeline" id="line-2356"><code>//</code></span>
<span class="codeline" id="line-2357"><code>// Normally a wildcard matches only a single path segment,</code></span>
<span class="codeline" id="line-2358"><code>// ending at the next literal slash (not %2F) in the request URL.</code></span>
<span class="codeline" id="line-2359"><code>// But if the "..." is present, then the wildcard matches the remainder of the URL path, including slashes.</code></span>
<span class="codeline" id="line-2360"><code>// (Therefore it is invalid for a "..." wildcard to appear anywhere but at the end of a pattern.)</code></span>
<span class="codeline" id="line-2361"><code>// The match for a wildcard can be obtained by calling [Request.PathValue] with the wildcard's name.</code></span>
<span class="codeline" id="line-2362"><code>// A trailing slash in a path acts as an anonymous "..." wildcard.</code></span>
<span class="codeline" id="line-2363"><code>//</code></span>
<span class="codeline" id="line-2364"><code>// The special wildcard {$} matches only the end of the URL.</code></span>
<span class="codeline" id="line-2365"><code>// For example, the pattern "/{$}" matches only the path "/",</code></span>
<span class="codeline" id="line-2366"><code>// whereas the pattern "/" matches every path.</code></span>
<span class="codeline" id="line-2367"><code>//</code></span>
<span class="codeline" id="line-2368"><code>// For matching, both pattern paths and incoming request paths are unescaped segment by segment.</code></span>
<span class="codeline" id="line-2369"><code>// So, for example, the path "/a%2Fb/100%25" is treated as having two segments, "a/b" and "100%".</code></span>
<span class="codeline" id="line-2370"><code>// The pattern "/a%2fb/" matches it, but the pattern "/a/b/" does not.</code></span>
<span class="codeline" id="line-2371"><code>//</code></span>
<span class="codeline" id="line-2372"><code>// # Precedence</code></span>
<span class="codeline" id="line-2373"><code>//</code></span>
<span class="codeline" id="line-2374"><code>// If two or more patterns match a request, then the most specific pattern takes precedence.</code></span>
<span class="codeline" id="line-2375"><code>// A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests;</code></span>
<span class="codeline" id="line-2376"><code>// that is, if P2 matches all the requests of P1 and more.</code></span>
<span class="codeline" id="line-2377"><code>// If neither is more specific, then the patterns conflict.</code></span>
<span class="codeline" id="line-2378"><code>// There is one exception to this rule, for backwards compatibility:</code></span>
<span class="codeline" id="line-2379"><code>// if two patterns would otherwise conflict and one has a host while the other does not,</code></span>
<span class="codeline" id="line-2380"><code>// then the pattern with the host takes precedence.</code></span>
<span class="codeline" id="line-2381"><code>// If a pattern passed [ServeMux.Handle] or [ServeMux.HandleFunc] conflicts with</code></span>
<span class="codeline" id="line-2382"><code>// another pattern that is already registered, those functions panic.</code></span>
<span class="codeline" id="line-2383"><code>//</code></span>
<span class="codeline" id="line-2384"><code>// As an example of the general rule, "/images/thumbnails/" is more specific than "/images/",</code></span>
<span class="codeline" id="line-2385"><code>// so both can be registered.</code></span>
<span class="codeline" id="line-2386"><code>// The former matches paths beginning with "/images/thumbnails/"</code></span>
<span class="codeline" id="line-2387"><code>// and the latter will match any other path in the "/images/" subtree.</code></span>
<span class="codeline" id="line-2388"><code>//</code></span>
<span class="codeline" id="line-2389"><code>// As another example, consider the patterns "GET /" and "/index.html":</code></span>
<span class="codeline" id="line-2390"><code>// both match a GET request for "/index.html", but the former pattern</code></span>
<span class="codeline" id="line-2391"><code>// matches all other GET and HEAD requests, while the latter matches any</code></span>
<span class="codeline" id="line-2392"><code>// request for "/index.html" that uses a different method.</code></span>
<span class="codeline" id="line-2393"><code>// The patterns conflict.</code></span>
<span class="codeline" id="line-2394"><code>//</code></span>
<span class="codeline" id="line-2395"><code>// # Trailing-slash redirection</code></span>
<span class="codeline" id="line-2396"><code>//</code></span>
<span class="codeline" id="line-2397"><code>// Consider a [ServeMux] with a handler for a subtree, registered using a trailing slash or "..." wildcard.</code></span>
<span class="codeline" id="line-2398"><code>// If the ServeMux receives a request for the subtree root without a trailing slash,</code></span>
<span class="codeline" id="line-2399"><code>// it redirects the request by adding the trailing slash.</code></span>
<span class="codeline" id="line-2400"><code>// This behavior can be overridden with a separate registration for the path without</code></span>
<span class="codeline" id="line-2401"><code>// the trailing slash or "..." wildcard. For example, registering "/images/" causes ServeMux</code></span>
<span class="codeline" id="line-2402"><code>// to redirect a request for "/images" to "/images/", unless "/images" has</code></span>
<span class="codeline" id="line-2403"><code>// been registered separately.</code></span>
<span class="codeline" id="line-2404"><code>//</code></span>
<span class="codeline" id="line-2405"><code>// # Request sanitizing</code></span>
<span class="codeline" id="line-2406"><code>//</code></span>
<span class="codeline" id="line-2407"><code>// ServeMux also takes care of sanitizing the URL request path and the Host</code></span>
<span class="codeline" id="line-2408"><code>// header, stripping the port number and redirecting any request containing . or</code></span>
<span class="codeline" id="line-2409"><code>// .. segments or repeated slashes to an equivalent, cleaner URL.</code></span>
<span class="codeline" id="line-2410"><code>//</code></span>
<span class="codeline" id="line-2411"><code>// # Compatibility</code></span>
<span class="codeline" id="line-2412"><code>//</code></span>
<span class="codeline" id="line-2413"><code>// The pattern syntax and matching behavior of ServeMux changed significantly</code></span>
<span class="codeline" id="line-2414"><code>// in Go 1.22. To restore the old behavior, set the GODEBUG environment variable</code></span>
<span class="codeline" id="line-2415"><code>// to "httpmuxgo121=1". This setting is read once, at program startup; changes</code></span>
<span class="codeline" id="line-2416"><code>// during execution will be ignored.</code></span>
<span class="codeline" id="line-2417"><code>//</code></span>
<span class="codeline" id="line-2418"><code>// The backwards-incompatible changes include:</code></span>
<span class="codeline" id="line-2419"><code>//   - Wildcards are just ordinary literal path segments in 1.21.</code></span>
<span class="codeline" id="line-2420"><code>//     For example, the pattern "/{x}" will match only that path in 1.21,</code></span>
<span class="codeline" id="line-2421"><code>//     but will match any one-segment path in 1.22.</code></span>
<span class="codeline" id="line-2422"><code>//   - In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern.</code></span>
<span class="codeline" id="line-2423"><code>//     In 1.22, syntactically invalid patterns will cause [ServeMux.Handle] and [ServeMux.HandleFunc] to panic.</code></span>
<span class="codeline" id="line-2424"><code>//     For example, in 1.21, the patterns "/{"  and "/a{x}" match themselves,</code></span>
<span class="codeline" id="line-2425"><code>//     but in 1.22 they are invalid and will cause a panic when registered.</code></span>
<span class="codeline" id="line-2426"><code>//   - In 1.22, each segment of a pattern is unescaped; this was not done in 1.21.</code></span>
<span class="codeline" id="line-2427"><code>//     For example, in 1.22 the pattern "/%61" matches the path "/a" ("%61" being the URL escape sequence for "a"),</code></span>
<span class="codeline" id="line-2428"><code>//     but in 1.21 it would match only the path "/%2561" (where "%25" is the escape for the percent sign).</code></span>
<span class="codeline" id="line-2429"><code>//   - When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped.</code></span>
<span class="codeline" id="line-2430"><code>//     This change mostly affects how paths with %2F escapes adjacent to slashes are treated.</code></span>
<span class="codeline" id="line-2431"><code>//     See https://go.dev/issue/21955 for details.</code></span>
<span class="codeline" id="line-2432"><code>type ServeMux struct {</code></span>
<span class="codeline" id="line-2433"><code>	mu       sync.RWMutex</code></span>
<span class="codeline" id="line-2434"><code>	tree     routingNode</code></span>
<span class="codeline" id="line-2435"><code>	index    routingIndex</code></span>
<span class="codeline" id="line-2436"><code>	patterns []*pattern  // TODO(jba): remove if possible</code></span>
<span class="codeline" id="line-2437"><code>	mux121   serveMux121 // used only when GODEBUG=httpmuxgo121=1</code></span>
<span class="codeline" id="line-2438"><code>}</code></span>
<span class="codeline" id="line-2439"><code></code></span>
<span class="codeline" id="line-2440"><code>// NewServeMux allocates and returns a new [ServeMux].</code></span>
<span class="codeline" id="line-2441"><code>func NewServeMux() *ServeMux {</code></span>
<span class="codeline" id="line-2442"><code>	return &amp;ServeMux{}</code></span>
<span class="codeline" id="line-2443"><code>}</code></span>
<span class="codeline" id="line-2444"><code></code></span>
<span class="codeline" id="line-2445"><code>// DefaultServeMux is the default [ServeMux] used by [Serve].</code></span>
<span class="codeline" id="line-2446"><code>var DefaultServeMux = &amp;defaultServeMux</code></span>
<span class="codeline" id="line-2447"><code></code></span>
<span class="codeline" id="line-2448"><code>var defaultServeMux ServeMux</code></span>
<span class="codeline" id="line-2449"><code></code></span>
<span class="codeline" id="line-2450"><code>// cleanPath returns the canonical path for p, eliminating . and .. elements.</code></span>
<span class="codeline" id="line-2451"><code>func cleanPath(p string) string {</code></span>
<span class="codeline" id="line-2452"><code>	if p == "" {</code></span>
<span class="codeline" id="line-2453"><code>		return "/"</code></span>
<span class="codeline" id="line-2454"><code>	}</code></span>
<span class="codeline" id="line-2455"><code>	if p[0] != '/' {</code></span>
<span class="codeline" id="line-2456"><code>		p = "/" + p</code></span>
<span class="codeline" id="line-2457"><code>	}</code></span>
<span class="codeline" id="line-2458"><code>	np := path.Clean(p)</code></span>
<span class="codeline" id="line-2459"><code>	// path.Clean removes trailing slash except for root;</code></span>
<span class="codeline" id="line-2460"><code>	// put the trailing slash back if necessary.</code></span>
<span class="codeline" id="line-2461"><code>	if p[len(p)-1] == '/' &amp;&amp; np != "/" {</code></span>
<span class="codeline" id="line-2462"><code>		// Fast path for common case of p being the string we want:</code></span>
<span class="codeline" id="line-2463"><code>		if len(p) == len(np)+1 &amp;&amp; strings.HasPrefix(p, np) {</code></span>
<span class="codeline" id="line-2464"><code>			np = p</code></span>
<span class="codeline" id="line-2465"><code>		} else {</code></span>
<span class="codeline" id="line-2466"><code>			np += "/"</code></span>
<span class="codeline" id="line-2467"><code>		}</code></span>
<span class="codeline" id="line-2468"><code>	}</code></span>
<span class="codeline" id="line-2469"><code>	return np</code></span>
<span class="codeline" id="line-2470"><code>}</code></span>
<span class="codeline" id="line-2471"><code></code></span>
<span class="codeline" id="line-2472"><code>// stripHostPort returns h without any trailing ":&lt;port&gt;".</code></span>
<span class="codeline" id="line-2473"><code>func stripHostPort(h string) string {</code></span>
<span class="codeline" id="line-2474"><code>	// If no port on host, return unchanged</code></span>
<span class="codeline" id="line-2475"><code>	if !strings.Contains(h, ":") {</code></span>
<span class="codeline" id="line-2476"><code>		return h</code></span>
<span class="codeline" id="line-2477"><code>	}</code></span>
<span class="codeline" id="line-2478"><code>	host, _, err := net.SplitHostPort(h)</code></span>
<span class="codeline" id="line-2479"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2480"><code>		return h // on error, return unchanged</code></span>
<span class="codeline" id="line-2481"><code>	}</code></span>
<span class="codeline" id="line-2482"><code>	return host</code></span>
<span class="codeline" id="line-2483"><code>}</code></span>
<span class="codeline" id="line-2484"><code></code></span>
<span class="codeline" id="line-2485"><code>// Handler returns the handler to use for the given request,</code></span>
<span class="codeline" id="line-2486"><code>// consulting r.Method, r.Host, and r.URL.Path. It always returns</code></span>
<span class="codeline" id="line-2487"><code>// a non-nil handler. If the path is not in its canonical form, the</code></span>
<span class="codeline" id="line-2488"><code>// handler will be an internally-generated handler that redirects</code></span>
<span class="codeline" id="line-2489"><code>// to the canonical path. If the host contains a port, it is ignored</code></span>
<span class="codeline" id="line-2490"><code>// when matching handlers.</code></span>
<span class="codeline" id="line-2491"><code>//</code></span>
<span class="codeline" id="line-2492"><code>// The path and host are used unchanged for CONNECT requests.</code></span>
<span class="codeline" id="line-2493"><code>//</code></span>
<span class="codeline" id="line-2494"><code>// Handler also returns the registered pattern that matches the</code></span>
<span class="codeline" id="line-2495"><code>// request or, in the case of internally-generated redirects,</code></span>
<span class="codeline" id="line-2496"><code>// the path that will match after following the redirect.</code></span>
<span class="codeline" id="line-2497"><code>//</code></span>
<span class="codeline" id="line-2498"><code>// If there is no registered handler that applies to the request,</code></span>
<span class="codeline" id="line-2499"><code>// Handler returns a “page not found” handler and an empty pattern.</code></span>
<span class="codeline" id="line-2500"><code>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {</code></span>
<span class="codeline" id="line-2501"><code>	if use121 {</code></span>
<span class="codeline" id="line-2502"><code>		return mux.mux121.findHandler(r)</code></span>
<span class="codeline" id="line-2503"><code>	}</code></span>
<span class="codeline" id="line-2504"><code>	h, p, _, _ := mux.findHandler(r)</code></span>
<span class="codeline" id="line-2505"><code>	return h, p</code></span>
<span class="codeline" id="line-2506"><code>}</code></span>
<span class="codeline" id="line-2507"><code></code></span>
<span class="codeline" id="line-2508"><code>// findHandler finds a handler for a request.</code></span>
<span class="codeline" id="line-2509"><code>// If there is a matching handler, it returns it and the pattern that matched.</code></span>
<span class="codeline" id="line-2510"><code>// Otherwise it returns a Redirect or NotFound handler with the path that would match</code></span>
<span class="codeline" id="line-2511"><code>// after the redirect.</code></span>
<span class="codeline" id="line-2512"><code>func (mux *ServeMux) findHandler(r *Request) (h Handler, patStr string, _ *pattern, matches []string) {</code></span>
<span class="codeline" id="line-2513"><code>	var n *routingNode</code></span>
<span class="codeline" id="line-2514"><code>	host := r.URL.Host</code></span>
<span class="codeline" id="line-2515"><code>	escapedPath := r.URL.EscapedPath()</code></span>
<span class="codeline" id="line-2516"><code>	path := escapedPath</code></span>
<span class="codeline" id="line-2517"><code>	// CONNECT requests are not canonicalized.</code></span>
<span class="codeline" id="line-2518"><code>	if r.Method == "CONNECT" {</code></span>
<span class="codeline" id="line-2519"><code>		// If r.URL.Path is /tree and its handler is not registered,</code></span>
<span class="codeline" id="line-2520"><code>		// the /tree -&gt; /tree/ redirect applies to CONNECT requests</code></span>
<span class="codeline" id="line-2521"><code>		// but the path canonicalization does not.</code></span>
<span class="codeline" id="line-2522"><code>		_, _, u := mux.matchOrRedirect(host, r.Method, path, r.URL)</code></span>
<span class="codeline" id="line-2523"><code>		if u != nil {</code></span>
<span class="codeline" id="line-2524"><code>			return RedirectHandler(u.String(), StatusMovedPermanently), u.Path, nil, nil</code></span>
<span class="codeline" id="line-2525"><code>		}</code></span>
<span class="codeline" id="line-2526"><code>		// Redo the match, this time with r.Host instead of r.URL.Host.</code></span>
<span class="codeline" id="line-2527"><code>		// Pass a nil URL to skip the trailing-slash redirect logic.</code></span>
<span class="codeline" id="line-2528"><code>		n, matches, _ = mux.matchOrRedirect(r.Host, r.Method, path, nil)</code></span>
<span class="codeline" id="line-2529"><code>	} else {</code></span>
<span class="codeline" id="line-2530"><code>		// All other requests have any port stripped and path cleaned</code></span>
<span class="codeline" id="line-2531"><code>		// before passing to mux.handler.</code></span>
<span class="codeline" id="line-2532"><code>		host = stripHostPort(r.Host)</code></span>
<span class="codeline" id="line-2533"><code>		path = cleanPath(path)</code></span>
<span class="codeline" id="line-2534"><code></code></span>
<span class="codeline" id="line-2535"><code>		// If the given path is /tree and its handler is not registered,</code></span>
<span class="codeline" id="line-2536"><code>		// redirect for /tree/.</code></span>
<span class="codeline" id="line-2537"><code>		var u *url.URL</code></span>
<span class="codeline" id="line-2538"><code>		n, matches, u = mux.matchOrRedirect(host, r.Method, path, r.URL)</code></span>
<span class="codeline" id="line-2539"><code>		if u != nil {</code></span>
<span class="codeline" id="line-2540"><code>			return RedirectHandler(u.String(), StatusMovedPermanently), u.Path, nil, nil</code></span>
<span class="codeline" id="line-2541"><code>		}</code></span>
<span class="codeline" id="line-2542"><code>		if path != escapedPath {</code></span>
<span class="codeline" id="line-2543"><code>			// Redirect to cleaned path.</code></span>
<span class="codeline" id="line-2544"><code>			patStr := ""</code></span>
<span class="codeline" id="line-2545"><code>			if n != nil {</code></span>
<span class="codeline" id="line-2546"><code>				patStr = n.pattern.String()</code></span>
<span class="codeline" id="line-2547"><code>			}</code></span>
<span class="codeline" id="line-2548"><code>			u := &amp;url.URL{Path: path, RawQuery: r.URL.RawQuery}</code></span>
<span class="codeline" id="line-2549"><code>			return RedirectHandler(u.String(), StatusMovedPermanently), patStr, nil, nil</code></span>
<span class="codeline" id="line-2550"><code>		}</code></span>
<span class="codeline" id="line-2551"><code>	}</code></span>
<span class="codeline" id="line-2552"><code>	if n == nil {</code></span>
<span class="codeline" id="line-2553"><code>		// We didn't find a match with the request method. To distinguish between</code></span>
<span class="codeline" id="line-2554"><code>		// Not Found and Method Not Allowed, see if there is another pattern that</code></span>
<span class="codeline" id="line-2555"><code>		// matches except for the method.</code></span>
<span class="codeline" id="line-2556"><code>		allowedMethods := mux.matchingMethods(host, path)</code></span>
<span class="codeline" id="line-2557"><code>		if len(allowedMethods) &gt; 0 {</code></span>
<span class="codeline" id="line-2558"><code>			return HandlerFunc(func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2559"><code>				w.Header().Set("Allow", strings.Join(allowedMethods, ", "))</code></span>
<span class="codeline" id="line-2560"><code>				Error(w, StatusText(StatusMethodNotAllowed), StatusMethodNotAllowed)</code></span>
<span class="codeline" id="line-2561"><code>			}), "", nil, nil</code></span>
<span class="codeline" id="line-2562"><code>		}</code></span>
<span class="codeline" id="line-2563"><code>		return NotFoundHandler(), "", nil, nil</code></span>
<span class="codeline" id="line-2564"><code>	}</code></span>
<span class="codeline" id="line-2565"><code>	return n.handler, n.pattern.String(), n.pattern, matches</code></span>
<span class="codeline" id="line-2566"><code>}</code></span>
<span class="codeline" id="line-2567"><code></code></span>
<span class="codeline" id="line-2568"><code>// matchOrRedirect looks up a node in the tree that matches the host, method and path.</code></span>
<span class="codeline" id="line-2569"><code>//</code></span>
<span class="codeline" id="line-2570"><code>// If the url argument is non-nil, handler also deals with trailing-slash</code></span>
<span class="codeline" id="line-2571"><code>// redirection: when a path doesn't match exactly, the match is tried again</code></span>
<span class="codeline" id="line-2572"><code>// after appending "/" to the path. If that second match succeeds, the last</code></span>
<span class="codeline" id="line-2573"><code>// return value is the URL to redirect to.</code></span>
<span class="codeline" id="line-2574"><code>func (mux *ServeMux) matchOrRedirect(host, method, path string, u *url.URL) (_ *routingNode, matches []string, redirectTo *url.URL) {</code></span>
<span class="codeline" id="line-2575"><code>	mux.mu.RLock()</code></span>
<span class="codeline" id="line-2576"><code>	defer mux.mu.RUnlock()</code></span>
<span class="codeline" id="line-2577"><code></code></span>
<span class="codeline" id="line-2578"><code>	n, matches := mux.tree.match(host, method, path)</code></span>
<span class="codeline" id="line-2579"><code>	// If we have an exact match, or we were asked not to try trailing-slash redirection,</code></span>
<span class="codeline" id="line-2580"><code>	// then we're done.</code></span>
<span class="codeline" id="line-2581"><code>	if !exactMatch(n, path) &amp;&amp; u != nil {</code></span>
<span class="codeline" id="line-2582"><code>		// If there is an exact match with a trailing slash, then redirect.</code></span>
<span class="codeline" id="line-2583"><code>		path += "/"</code></span>
<span class="codeline" id="line-2584"><code>		n2, _ := mux.tree.match(host, method, path)</code></span>
<span class="codeline" id="line-2585"><code>		if exactMatch(n2, path) {</code></span>
<span class="codeline" id="line-2586"><code>			return nil, nil, &amp;url.URL{Path: cleanPath(u.Path) + "/", RawQuery: u.RawQuery}</code></span>
<span class="codeline" id="line-2587"><code>		}</code></span>
<span class="codeline" id="line-2588"><code>	}</code></span>
<span class="codeline" id="line-2589"><code>	return n, matches, nil</code></span>
<span class="codeline" id="line-2590"><code>}</code></span>
<span class="codeline" id="line-2591"><code></code></span>
<span class="codeline" id="line-2592"><code>// exactMatch reports whether the node's pattern exactly matches the path.</code></span>
<span class="codeline" id="line-2593"><code>// As a special case, if the node is nil, exactMatch return false.</code></span>
<span class="codeline" id="line-2594"><code>//</code></span>
<span class="codeline" id="line-2595"><code>// Before wildcards were introduced, it was clear that an exact match meant</code></span>
<span class="codeline" id="line-2596"><code>// that the pattern and path were the same string. The only other possibility</code></span>
<span class="codeline" id="line-2597"><code>// was that a trailing-slash pattern, like "/", matched a path longer than</code></span>
<span class="codeline" id="line-2598"><code>// it, like "/a".</code></span>
<span class="codeline" id="line-2599"><code>//</code></span>
<span class="codeline" id="line-2600"><code>// With wildcards, we define an inexact match as any one where a multi wildcard</code></span>
<span class="codeline" id="line-2601"><code>// matches a non-empty string. All other matches are exact.</code></span>
<span class="codeline" id="line-2602"><code>// For example, these are all exact matches:</code></span>
<span class="codeline" id="line-2603"><code>//</code></span>
<span class="codeline" id="line-2604"><code>//	pattern   path</code></span>
<span class="codeline" id="line-2605"><code>//	/a        /a</code></span>
<span class="codeline" id="line-2606"><code>//	/{x}      /a</code></span>
<span class="codeline" id="line-2607"><code>//	/a/{$}    /a/</code></span>
<span class="codeline" id="line-2608"><code>//	/a/       /a/</code></span>
<span class="codeline" id="line-2609"><code>//</code></span>
<span class="codeline" id="line-2610"><code>// The last case has a multi wildcard (implicitly), but the match is exact because</code></span>
<span class="codeline" id="line-2611"><code>// the wildcard matches the empty string.</code></span>
<span class="codeline" id="line-2612"><code>//</code></span>
<span class="codeline" id="line-2613"><code>// Examples of matches that are not exact:</code></span>
<span class="codeline" id="line-2614"><code>//</code></span>
<span class="codeline" id="line-2615"><code>//	pattern   path</code></span>
<span class="codeline" id="line-2616"><code>//	/         /a</code></span>
<span class="codeline" id="line-2617"><code>//	/a/{x...} /a/b</code></span>
<span class="codeline" id="line-2618"><code>func exactMatch(n *routingNode, path string) bool {</code></span>
<span class="codeline" id="line-2619"><code>	if n == nil {</code></span>
<span class="codeline" id="line-2620"><code>		return false</code></span>
<span class="codeline" id="line-2621"><code>	}</code></span>
<span class="codeline" id="line-2622"><code>	// We can't directly implement the definition (empty match for multi</code></span>
<span class="codeline" id="line-2623"><code>	// wildcard) because we don't record a match for anonymous multis.</code></span>
<span class="codeline" id="line-2624"><code></code></span>
<span class="codeline" id="line-2625"><code>	// If there is no multi, the match is exact.</code></span>
<span class="codeline" id="line-2626"><code>	if !n.pattern.lastSegment().multi {</code></span>
<span class="codeline" id="line-2627"><code>		return true</code></span>
<span class="codeline" id="line-2628"><code>	}</code></span>
<span class="codeline" id="line-2629"><code></code></span>
<span class="codeline" id="line-2630"><code>	// If the path doesn't end in a trailing slash, then the multi match</code></span>
<span class="codeline" id="line-2631"><code>	// is non-empty.</code></span>
<span class="codeline" id="line-2632"><code>	if len(path) &gt; 0 &amp;&amp; path[len(path)-1] != '/' {</code></span>
<span class="codeline" id="line-2633"><code>		return false</code></span>
<span class="codeline" id="line-2634"><code>	}</code></span>
<span class="codeline" id="line-2635"><code>	// Only patterns ending in {$} or a multi wildcard can</code></span>
<span class="codeline" id="line-2636"><code>	// match a path with a trailing slash.</code></span>
<span class="codeline" id="line-2637"><code>	// For the match to be exact, the number of pattern</code></span>
<span class="codeline" id="line-2638"><code>	// segments should be the same as the number of slashes in the path.</code></span>
<span class="codeline" id="line-2639"><code>	// E.g. "/a/b/{$}" and "/a/b/{...}" exactly match "/a/b/", but "/a/" does not.</code></span>
<span class="codeline" id="line-2640"><code>	return len(n.pattern.segments) == strings.Count(path, "/")</code></span>
<span class="codeline" id="line-2641"><code>}</code></span>
<span class="codeline" id="line-2642"><code></code></span>
<span class="codeline" id="line-2643"><code>// matchingMethods return a sorted list of all methods that would match with the given host and path.</code></span>
<span class="codeline" id="line-2644"><code>func (mux *ServeMux) matchingMethods(host, path string) []string {</code></span>
<span class="codeline" id="line-2645"><code>	// Hold the read lock for the entire method so that the two matches are done</code></span>
<span class="codeline" id="line-2646"><code>	// on the same set of registered patterns.</code></span>
<span class="codeline" id="line-2647"><code>	mux.mu.RLock()</code></span>
<span class="codeline" id="line-2648"><code>	defer mux.mu.RUnlock()</code></span>
<span class="codeline" id="line-2649"><code>	ms := map[string]bool{}</code></span>
<span class="codeline" id="line-2650"><code>	mux.tree.matchingMethods(host, path, ms)</code></span>
<span class="codeline" id="line-2651"><code>	// matchOrRedirect will try appending a trailing slash if there is no match.</code></span>
<span class="codeline" id="line-2652"><code>	mux.tree.matchingMethods(host, path+"/", ms)</code></span>
<span class="codeline" id="line-2653"><code>	methods := mapKeys(ms)</code></span>
<span class="codeline" id="line-2654"><code>	sort.Strings(methods)</code></span>
<span class="codeline" id="line-2655"><code>	return methods</code></span>
<span class="codeline" id="line-2656"><code>}</code></span>
<span class="codeline" id="line-2657"><code></code></span>
<span class="codeline" id="line-2658"><code>// TODO(jba): replace with maps.Keys when it is defined.</code></span>
<span class="codeline" id="line-2659"><code>func mapKeys[K comparable, V any](m map[K]V) []K {</code></span>
<span class="codeline" id="line-2660"><code>	var ks []K</code></span>
<span class="codeline" id="line-2661"><code>	for k := range m {</code></span>
<span class="codeline" id="line-2662"><code>		ks = append(ks, k)</code></span>
<span class="codeline" id="line-2663"><code>	}</code></span>
<span class="codeline" id="line-2664"><code>	return ks</code></span>
<span class="codeline" id="line-2665"><code>}</code></span>
<span class="codeline" id="line-2666"><code></code></span>
<span class="codeline" id="line-2667"><code>// ServeHTTP dispatches the request to the handler whose</code></span>
<span class="codeline" id="line-2668"><code>// pattern most closely matches the request URL.</code></span>
<span class="codeline" id="line-2669"><code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-2670"><code>	if r.RequestURI == "*" {</code></span>
<span class="codeline" id="line-2671"><code>		if r.ProtoAtLeast(1, 1) {</code></span>
<span class="codeline" id="line-2672"><code>			w.Header().Set("Connection", "close")</code></span>
<span class="codeline" id="line-2673"><code>		}</code></span>
<span class="codeline" id="line-2674"><code>		w.WriteHeader(StatusBadRequest)</code></span>
<span class="codeline" id="line-2675"><code>		return</code></span>
<span class="codeline" id="line-2676"><code>	}</code></span>
<span class="codeline" id="line-2677"><code>	var h Handler</code></span>
<span class="codeline" id="line-2678"><code>	if use121 {</code></span>
<span class="codeline" id="line-2679"><code>		h, _ = mux.mux121.findHandler(r)</code></span>
<span class="codeline" id="line-2680"><code>	} else {</code></span>
<span class="codeline" id="line-2681"><code>		h, _, r.pat, r.matches = mux.findHandler(r)</code></span>
<span class="codeline" id="line-2682"><code>	}</code></span>
<span class="codeline" id="line-2683"><code>	h.ServeHTTP(w, r)</code></span>
<span class="codeline" id="line-2684"><code>}</code></span>
<span class="codeline" id="line-2685"><code></code></span>
<span class="codeline" id="line-2686"><code>// The four functions below all call ServeMux.register so that callerLocation</code></span>
<span class="codeline" id="line-2687"><code>// always refers to user code.</code></span>
<span class="codeline" id="line-2688"><code></code></span>
<span class="codeline" id="line-2689"><code>// Handle registers the handler for the given pattern.</code></span>
<span class="codeline" id="line-2690"><code>// If the given pattern conflicts, with one that is already registered, Handle</code></span>
<span class="codeline" id="line-2691"><code>// panics.</code></span>
<span class="codeline" id="line-2692"><code>func (mux *ServeMux) Handle(pattern string, handler Handler) {</code></span>
<span class="codeline" id="line-2693"><code>	if use121 {</code></span>
<span class="codeline" id="line-2694"><code>		mux.mux121.handle(pattern, handler)</code></span>
<span class="codeline" id="line-2695"><code>	} else {</code></span>
<span class="codeline" id="line-2696"><code>		mux.register(pattern, handler)</code></span>
<span class="codeline" id="line-2697"><code>	}</code></span>
<span class="codeline" id="line-2698"><code>}</code></span>
<span class="codeline" id="line-2699"><code></code></span>
<span class="codeline" id="line-2700"><code>// HandleFunc registers the handler function for the given pattern.</code></span>
<span class="codeline" id="line-2701"><code>// If the given pattern conflicts, with one that is already registered, HandleFunc</code></span>
<span class="codeline" id="line-2702"><code>// panics.</code></span>
<span class="codeline" id="line-2703"><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</code></span>
<span class="codeline" id="line-2704"><code>	if use121 {</code></span>
<span class="codeline" id="line-2705"><code>		mux.mux121.handleFunc(pattern, handler)</code></span>
<span class="codeline" id="line-2706"><code>	} else {</code></span>
<span class="codeline" id="line-2707"><code>		mux.register(pattern, HandlerFunc(handler))</code></span>
<span class="codeline" id="line-2708"><code>	}</code></span>
<span class="codeline" id="line-2709"><code>}</code></span>
<span class="codeline" id="line-2710"><code></code></span>
<span class="codeline" id="line-2711"><code>// Handle registers the handler for the given pattern in [DefaultServeMux].</code></span>
<span class="codeline" id="line-2712"><code>// The documentation for [ServeMux] explains how patterns are matched.</code></span>
<span class="codeline" id="line-2713"><code>func Handle(pattern string, handler Handler) {</code></span>
<span class="codeline" id="line-2714"><code>	if use121 {</code></span>
<span class="codeline" id="line-2715"><code>		DefaultServeMux.mux121.handle(pattern, handler)</code></span>
<span class="codeline" id="line-2716"><code>	} else {</code></span>
<span class="codeline" id="line-2717"><code>		DefaultServeMux.register(pattern, handler)</code></span>
<span class="codeline" id="line-2718"><code>	}</code></span>
<span class="codeline" id="line-2719"><code>}</code></span>
<span class="codeline" id="line-2720"><code></code></span>
<span class="codeline" id="line-2721"><code>// HandleFunc registers the handler function for the given pattern in [DefaultServeMux].</code></span>
<span class="codeline" id="line-2722"><code>// The documentation for [ServeMux] explains how patterns are matched.</code></span>
<span class="codeline" id="line-2723"><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {</code></span>
<span class="codeline" id="line-2724"><code>	if use121 {</code></span>
<span class="codeline" id="line-2725"><code>		DefaultServeMux.mux121.handleFunc(pattern, handler)</code></span>
<span class="codeline" id="line-2726"><code>	} else {</code></span>
<span class="codeline" id="line-2727"><code>		DefaultServeMux.register(pattern, HandlerFunc(handler))</code></span>
<span class="codeline" id="line-2728"><code>	}</code></span>
<span class="codeline" id="line-2729"><code>}</code></span>
<span class="codeline" id="line-2730"><code></code></span>
<span class="codeline" id="line-2731"><code>func (mux *ServeMux) register(pattern string, handler Handler) {</code></span>
<span class="codeline" id="line-2732"><code>	if err := mux.registerErr(pattern, handler); err != nil {</code></span>
<span class="codeline" id="line-2733"><code>		panic(err)</code></span>
<span class="codeline" id="line-2734"><code>	}</code></span>
<span class="codeline" id="line-2735"><code>}</code></span>
<span class="codeline" id="line-2736"><code></code></span>
<span class="codeline" id="line-2737"><code>func (mux *ServeMux) registerErr(patstr string, handler Handler) error {</code></span>
<span class="codeline" id="line-2738"><code>	if patstr == "" {</code></span>
<span class="codeline" id="line-2739"><code>		return errors.New("http: invalid pattern")</code></span>
<span class="codeline" id="line-2740"><code>	}</code></span>
<span class="codeline" id="line-2741"><code>	if handler == nil {</code></span>
<span class="codeline" id="line-2742"><code>		return errors.New("http: nil handler")</code></span>
<span class="codeline" id="line-2743"><code>	}</code></span>
<span class="codeline" id="line-2744"><code>	if f, ok := handler.(HandlerFunc); ok &amp;&amp; f == nil {</code></span>
<span class="codeline" id="line-2745"><code>		return errors.New("http: nil handler")</code></span>
<span class="codeline" id="line-2746"><code>	}</code></span>
<span class="codeline" id="line-2747"><code></code></span>
<span class="codeline" id="line-2748"><code>	pat, err := parsePattern(patstr)</code></span>
<span class="codeline" id="line-2749"><code>	if err != nil {</code></span>
<span class="codeline" id="line-2750"><code>		return fmt.Errorf("parsing %q: %w", patstr, err)</code></span>
<span class="codeline" id="line-2751"><code>	}</code></span>
<span class="codeline" id="line-2752"><code></code></span>
<span class="codeline" id="line-2753"><code>	// Get the caller's location, for better conflict error messages.</code></span>
<span class="codeline" id="line-2754"><code>	// Skip register and whatever calls it.</code></span>
<span class="codeline" id="line-2755"><code>	_, file, line, ok := runtime.Caller(3)</code></span>
<span class="codeline" id="line-2756"><code>	if !ok {</code></span>
<span class="codeline" id="line-2757"><code>		pat.loc = "unknown location"</code></span>
<span class="codeline" id="line-2758"><code>	} else {</code></span>
<span class="codeline" id="line-2759"><code>		pat.loc = fmt.Sprintf("%s:%d", file, line)</code></span>
<span class="codeline" id="line-2760"><code>	}</code></span>
<span class="codeline" id="line-2761"><code></code></span>
<span class="codeline" id="line-2762"><code>	mux.mu.Lock()</code></span>
<span class="codeline" id="line-2763"><code>	defer mux.mu.Unlock()</code></span>
<span class="codeline" id="line-2764"><code>	// Check for conflict.</code></span>
<span class="codeline" id="line-2765"><code>	if err := mux.index.possiblyConflictingPatterns(pat, func(pat2 *pattern) error {</code></span>
<span class="codeline" id="line-2766"><code>		if pat.conflictsWith(pat2) {</code></span>
<span class="codeline" id="line-2767"><code>			d := describeConflict(pat, pat2)</code></span>
<span class="codeline" id="line-2768"><code>			return fmt.Errorf("pattern %q (registered at %s) conflicts with pattern %q (registered at %s):\n%s",</code></span>
<span class="codeline" id="line-2769"><code>				pat, pat.loc, pat2, pat2.loc, d)</code></span>
<span class="codeline" id="line-2770"><code>		}</code></span>
<span class="codeline" id="line-2771"><code>		return nil</code></span>
<span class="codeline" id="line-2772"><code>	}); err != nil {</code></span>
<span class="codeline" id="line-2773"><code>		return err</code></span>
<span class="codeline" id="line-2774"><code>	}</code></span>
<span class="codeline" id="line-2775"><code>	mux.tree.addPattern(pat, handler)</code></span>
<span class="codeline" id="line-2776"><code>	mux.index.addPattern(pat)</code></span>
<span class="codeline" id="line-2777"><code>	mux.patterns = append(mux.patterns, pat)</code></span>
<span class="codeline" id="line-2778"><code>	return nil</code></span>
<span class="codeline" id="line-2779"><code>}</code></span>
<span class="codeline" id="line-2780"><code></code></span>
<span class="codeline" id="line-2781"><code>// Serve accepts incoming HTTP connections on the listener l,</code></span>
<span class="codeline" id="line-2782"><code>// creating a new service goroutine for each. The service goroutines</code></span>
<span class="codeline" id="line-2783"><code>// read requests and then call handler to reply to them.</code></span>
<span class="codeline" id="line-2784"><code>//</code></span>
<span class="codeline" id="line-2785"><code>// The handler is typically nil, in which case [DefaultServeMux] is used.</code></span>
<span class="codeline" id="line-2786"><code>//</code></span>
<span class="codeline" id="line-2787"><code>// HTTP/2 support is only enabled if the Listener returns [*tls.Conn]</code></span>
<span class="codeline" id="line-2788"><code>// connections and they were configured with "h2" in the TLS</code></span>
<span class="codeline" id="line-2789"><code>// Config.NextProtos.</code></span>
<span class="codeline" id="line-2790"><code>//</code></span>
<span class="codeline" id="line-2791"><code>// Serve always returns a non-nil error.</code></span>
<span class="codeline" id="line-2792"><code>func Serve(l net.Listener, handler Handler) error {</code></span>
<span class="codeline" id="line-2793"><code>	srv := &amp;Server{Handler: handler}</code></span>
<span class="codeline" id="line-2794"><code>	return srv.Serve(l)</code></span>
<span class="codeline" id="line-2795"><code>}</code></span>
<span class="codeline" id="line-2796"><code></code></span>
<span class="codeline" id="line-2797"><code>// ServeTLS accepts incoming HTTPS connections on the listener l,</code></span>
<span class="codeline" id="line-2798"><code>// creating a new service goroutine for each. The service goroutines</code></span>
<span class="codeline" id="line-2799"><code>// read requests and then call handler to reply to them.</code></span>
<span class="codeline" id="line-2800"><code>//</code></span>
<span class="codeline" id="line-2801"><code>// The handler is typically nil, in which case [DefaultServeMux] is used.</code></span>
<span class="codeline" id="line-2802"><code>//</code></span>
<span class="codeline" id="line-2803"><code>// Additionally, files containing a certificate and matching private key</code></span>
<span class="codeline" id="line-2804"><code>// for the server must be provided. If the certificate is signed by a</code></span>
<span class="codeline" id="line-2805"><code>// certificate authority, the certFile should be the concatenation</code></span>
<span class="codeline" id="line-2806"><code>// of the server's certificate, any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-2807"><code>//</code></span>
<span class="codeline" id="line-2808"><code>// ServeTLS always returns a non-nil error.</code></span>
<span class="codeline" id="line-2809"><code>func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-2810"><code>	srv := &amp;Server{Handler: handler}</code></span>
<span class="codeline" id="line-2811"><code>	return srv.ServeTLS(l, certFile, keyFile)</code></span>
<span class="codeline" id="line-2812"><code>}</code></span>
<span class="codeline" id="line-2813"><code></code></span>
<span class="codeline" id="line-2814"><code>// A Server defines parameters for running an HTTP server.</code></span>
<span class="codeline" id="line-2815"><code>// The zero value for Server is a valid configuration.</code></span>
<span class="codeline" id="line-2816"><code>type Server struct {</code></span>
<span class="codeline" id="line-2817"><code>	// Addr optionally specifies the TCP address for the server to listen on,</code></span>
<span class="codeline" id="line-2818"><code>	// in the form "host:port". If empty, ":http" (port 80) is used.</code></span>
<span class="codeline" id="line-2819"><code>	// The service names are defined in RFC 6335 and assigned by IANA.</code></span>
<span class="codeline" id="line-2820"><code>	// See net.Dial for details of the address format.</code></span>
<span class="codeline" id="line-2821"><code>	Addr string</code></span>
<span class="codeline" id="line-2822"><code></code></span>
<span class="codeline" id="line-2823"><code>	Handler Handler // handler to invoke, http.DefaultServeMux if nil</code></span>
<span class="codeline" id="line-2824"><code></code></span>
<span class="codeline" id="line-2825"><code>	// DisableGeneralOptionsHandler, if true, passes "OPTIONS *" requests to the Handler,</code></span>
<span class="codeline" id="line-2826"><code>	// otherwise responds with 200 OK and Content-Length: 0.</code></span>
<span class="codeline" id="line-2827"><code>	DisableGeneralOptionsHandler bool</code></span>
<span class="codeline" id="line-2828"><code></code></span>
<span class="codeline" id="line-2829"><code>	// TLSConfig optionally provides a TLS configuration for use</code></span>
<span class="codeline" id="line-2830"><code>	// by ServeTLS and ListenAndServeTLS. Note that this value is</code></span>
<span class="codeline" id="line-2831"><code>	// cloned by ServeTLS and ListenAndServeTLS, so it's not</code></span>
<span class="codeline" id="line-2832"><code>	// possible to modify the configuration with methods like</code></span>
<span class="codeline" id="line-2833"><code>	// tls.Config.SetSessionTicketKeys. To use</code></span>
<span class="codeline" id="line-2834"><code>	// SetSessionTicketKeys, use Server.Serve with a TLS Listener</code></span>
<span class="codeline" id="line-2835"><code>	// instead.</code></span>
<span class="codeline" id="line-2836"><code>	TLSConfig *tls.Config</code></span>
<span class="codeline" id="line-2837"><code></code></span>
<span class="codeline" id="line-2838"><code>	// ReadTimeout is the maximum duration for reading the entire</code></span>
<span class="codeline" id="line-2839"><code>	// request, including the body. A zero or negative value means</code></span>
<span class="codeline" id="line-2840"><code>	// there will be no timeout.</code></span>
<span class="codeline" id="line-2841"><code>	//</code></span>
<span class="codeline" id="line-2842"><code>	// Because ReadTimeout does not let Handlers make per-request</code></span>
<span class="codeline" id="line-2843"><code>	// decisions on each request body's acceptable deadline or</code></span>
<span class="codeline" id="line-2844"><code>	// upload rate, most users will prefer to use</code></span>
<span class="codeline" id="line-2845"><code>	// ReadHeaderTimeout. It is valid to use them both.</code></span>
<span class="codeline" id="line-2846"><code>	ReadTimeout time.Duration</code></span>
<span class="codeline" id="line-2847"><code></code></span>
<span class="codeline" id="line-2848"><code>	// ReadHeaderTimeout is the amount of time allowed to read</code></span>
<span class="codeline" id="line-2849"><code>	// request headers. The connection's read deadline is reset</code></span>
<span class="codeline" id="line-2850"><code>	// after reading the headers and the Handler can decide what</code></span>
<span class="codeline" id="line-2851"><code>	// is considered too slow for the body. If ReadHeaderTimeout</code></span>
<span class="codeline" id="line-2852"><code>	// is zero, the value of ReadTimeout is used. If both are</code></span>
<span class="codeline" id="line-2853"><code>	// zero, there is no timeout.</code></span>
<span class="codeline" id="line-2854"><code>	ReadHeaderTimeout time.Duration</code></span>
<span class="codeline" id="line-2855"><code></code></span>
<span class="codeline" id="line-2856"><code>	// WriteTimeout is the maximum duration before timing out</code></span>
<span class="codeline" id="line-2857"><code>	// writes of the response. It is reset whenever a new</code></span>
<span class="codeline" id="line-2858"><code>	// request's header is read. Like ReadTimeout, it does not</code></span>
<span class="codeline" id="line-2859"><code>	// let Handlers make decisions on a per-request basis.</code></span>
<span class="codeline" id="line-2860"><code>	// A zero or negative value means there will be no timeout.</code></span>
<span class="codeline" id="line-2861"><code>	WriteTimeout time.Duration</code></span>
<span class="codeline" id="line-2862"><code></code></span>
<span class="codeline" id="line-2863"><code>	// IdleTimeout is the maximum amount of time to wait for the</code></span>
<span class="codeline" id="line-2864"><code>	// next request when keep-alives are enabled. If IdleTimeout</code></span>
<span class="codeline" id="line-2865"><code>	// is zero, the value of ReadTimeout is used. If both are</code></span>
<span class="codeline" id="line-2866"><code>	// zero, there is no timeout.</code></span>
<span class="codeline" id="line-2867"><code>	IdleTimeout time.Duration</code></span>
<span class="codeline" id="line-2868"><code></code></span>
<span class="codeline" id="line-2869"><code>	// MaxHeaderBytes controls the maximum number of bytes the</code></span>
<span class="codeline" id="line-2870"><code>	// server will read parsing the request header's keys and</code></span>
<span class="codeline" id="line-2871"><code>	// values, including the request line. It does not limit the</code></span>
<span class="codeline" id="line-2872"><code>	// size of the request body.</code></span>
<span class="codeline" id="line-2873"><code>	// If zero, DefaultMaxHeaderBytes is used.</code></span>
<span class="codeline" id="line-2874"><code>	MaxHeaderBytes int</code></span>
<span class="codeline" id="line-2875"><code></code></span>
<span class="codeline" id="line-2876"><code>	// TLSNextProto optionally specifies a function to take over</code></span>
<span class="codeline" id="line-2877"><code>	// ownership of the provided TLS connection when an ALPN</code></span>
<span class="codeline" id="line-2878"><code>	// protocol upgrade has occurred. The map key is the protocol</code></span>
<span class="codeline" id="line-2879"><code>	// name negotiated. The Handler argument should be used to</code></span>
<span class="codeline" id="line-2880"><code>	// handle HTTP requests and will initialize the Request's TLS</code></span>
<span class="codeline" id="line-2881"><code>	// and RemoteAddr if not already set. The connection is</code></span>
<span class="codeline" id="line-2882"><code>	// automatically closed when the function returns.</code></span>
<span class="codeline" id="line-2883"><code>	// If TLSNextProto is not nil, HTTP/2 support is not enabled</code></span>
<span class="codeline" id="line-2884"><code>	// automatically.</code></span>
<span class="codeline" id="line-2885"><code>	TLSNextProto map[string]func(*Server, *tls.Conn, Handler)</code></span>
<span class="codeline" id="line-2886"><code></code></span>
<span class="codeline" id="line-2887"><code>	// ConnState specifies an optional callback function that is</code></span>
<span class="codeline" id="line-2888"><code>	// called when a client connection changes state. See the</code></span>
<span class="codeline" id="line-2889"><code>	// ConnState type and associated constants for details.</code></span>
<span class="codeline" id="line-2890"><code>	ConnState func(net.Conn, ConnState)</code></span>
<span class="codeline" id="line-2891"><code></code></span>
<span class="codeline" id="line-2892"><code>	// ErrorLog specifies an optional logger for errors accepting</code></span>
<span class="codeline" id="line-2893"><code>	// connections, unexpected behavior from handlers, and</code></span>
<span class="codeline" id="line-2894"><code>	// underlying FileSystem errors.</code></span>
<span class="codeline" id="line-2895"><code>	// If nil, logging is done via the log package's standard logger.</code></span>
<span class="codeline" id="line-2896"><code>	ErrorLog *log.Logger</code></span>
<span class="codeline" id="line-2897"><code></code></span>
<span class="codeline" id="line-2898"><code>	// BaseContext optionally specifies a function that returns</code></span>
<span class="codeline" id="line-2899"><code>	// the base context for incoming requests on this server.</code></span>
<span class="codeline" id="line-2900"><code>	// The provided Listener is the specific Listener that's</code></span>
<span class="codeline" id="line-2901"><code>	// about to start accepting requests.</code></span>
<span class="codeline" id="line-2902"><code>	// If BaseContext is nil, the default is context.Background().</code></span>
<span class="codeline" id="line-2903"><code>	// If non-nil, it must return a non-nil context.</code></span>
<span class="codeline" id="line-2904"><code>	BaseContext func(net.Listener) context.Context</code></span>
<span class="codeline" id="line-2905"><code></code></span>
<span class="codeline" id="line-2906"><code>	// ConnContext optionally specifies a function that modifies</code></span>
<span class="codeline" id="line-2907"><code>	// the context used for a new connection c. The provided ctx</code></span>
<span class="codeline" id="line-2908"><code>	// is derived from the base context and has a ServerContextKey</code></span>
<span class="codeline" id="line-2909"><code>	// value.</code></span>
<span class="codeline" id="line-2910"><code>	ConnContext func(ctx context.Context, c net.Conn) context.Context</code></span>
<span class="codeline" id="line-2911"><code></code></span>
<span class="codeline" id="line-2912"><code>	inShutdown atomic.Bool // true when server is in shutdown</code></span>
<span class="codeline" id="line-2913"><code></code></span>
<span class="codeline" id="line-2914"><code>	disableKeepAlives atomic.Bool</code></span>
<span class="codeline" id="line-2915"><code>	nextProtoOnce     sync.Once // guards setupHTTP2_* init</code></span>
<span class="codeline" id="line-2916"><code>	nextProtoErr      error     // result of http2.ConfigureServer if used</code></span>
<span class="codeline" id="line-2917"><code></code></span>
<span class="codeline" id="line-2918"><code>	mu         sync.Mutex</code></span>
<span class="codeline" id="line-2919"><code>	listeners  map[*net.Listener]struct{}</code></span>
<span class="codeline" id="line-2920"><code>	activeConn map[*conn]struct{}</code></span>
<span class="codeline" id="line-2921"><code>	onShutdown []func()</code></span>
<span class="codeline" id="line-2922"><code></code></span>
<span class="codeline" id="line-2923"><code>	listenerGroup sync.WaitGroup</code></span>
<span class="codeline" id="line-2924"><code>}</code></span>
<span class="codeline" id="line-2925"><code></code></span>
<span class="codeline" id="line-2926"><code>// Close immediately closes all active net.Listeners and any</code></span>
<span class="codeline" id="line-2927"><code>// connections in state [StateNew], [StateActive], or [StateIdle]. For a</code></span>
<span class="codeline" id="line-2928"><code>// graceful shutdown, use [Server.Shutdown].</code></span>
<span class="codeline" id="line-2929"><code>//</code></span>
<span class="codeline" id="line-2930"><code>// Close does not attempt to close (and does not even know about)</code></span>
<span class="codeline" id="line-2931"><code>// any hijacked connections, such as WebSockets.</code></span>
<span class="codeline" id="line-2932"><code>//</code></span>
<span class="codeline" id="line-2933"><code>// Close returns any error returned from closing the [Server]'s</code></span>
<span class="codeline" id="line-2934"><code>// underlying Listener(s).</code></span>
<span class="codeline" id="line-2935"><code>func (srv *Server) Close() error {</code></span>
<span class="codeline" id="line-2936"><code>	srv.inShutdown.Store(true)</code></span>
<span class="codeline" id="line-2937"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2938"><code>	defer srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2939"><code>	err := srv.closeListenersLocked()</code></span>
<span class="codeline" id="line-2940"><code></code></span>
<span class="codeline" id="line-2941"><code>	// Unlock srv.mu while waiting for listenerGroup.</code></span>
<span class="codeline" id="line-2942"><code>	// The group Add and Done calls are made with srv.mu held,</code></span>
<span class="codeline" id="line-2943"><code>	// to avoid adding a new listener in the window between</code></span>
<span class="codeline" id="line-2944"><code>	// us setting inShutdown above and waiting here.</code></span>
<span class="codeline" id="line-2945"><code>	srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2946"><code>	srv.listenerGroup.Wait()</code></span>
<span class="codeline" id="line-2947"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2948"><code></code></span>
<span class="codeline" id="line-2949"><code>	for c := range srv.activeConn {</code></span>
<span class="codeline" id="line-2950"><code>		c.rwc.Close()</code></span>
<span class="codeline" id="line-2951"><code>		delete(srv.activeConn, c)</code></span>
<span class="codeline" id="line-2952"><code>	}</code></span>
<span class="codeline" id="line-2953"><code>	return err</code></span>
<span class="codeline" id="line-2954"><code>}</code></span>
<span class="codeline" id="line-2955"><code></code></span>
<span class="codeline" id="line-2956"><code>// shutdownPollIntervalMax is the max polling interval when checking</code></span>
<span class="codeline" id="line-2957"><code>// quiescence during Server.Shutdown. Polling starts with a small</code></span>
<span class="codeline" id="line-2958"><code>// interval and backs off to the max.</code></span>
<span class="codeline" id="line-2959"><code>// Ideally we could find a solution that doesn't involve polling,</code></span>
<span class="codeline" id="line-2960"><code>// but which also doesn't have a high runtime cost (and doesn't</code></span>
<span class="codeline" id="line-2961"><code>// involve any contentious mutexes), but that is left as an</code></span>
<span class="codeline" id="line-2962"><code>// exercise for the reader.</code></span>
<span class="codeline" id="line-2963"><code>const shutdownPollIntervalMax = 500 * time.Millisecond</code></span>
<span class="codeline" id="line-2964"><code></code></span>
<span class="codeline" id="line-2965"><code>// Shutdown gracefully shuts down the server without interrupting any</code></span>
<span class="codeline" id="line-2966"><code>// active connections. Shutdown works by first closing all open</code></span>
<span class="codeline" id="line-2967"><code>// listeners, then closing all idle connections, and then waiting</code></span>
<span class="codeline" id="line-2968"><code>// indefinitely for connections to return to idle and then shut down.</code></span>
<span class="codeline" id="line-2969"><code>// If the provided context expires before the shutdown is complete,</code></span>
<span class="codeline" id="line-2970"><code>// Shutdown returns the context's error, otherwise it returns any</code></span>
<span class="codeline" id="line-2971"><code>// error returned from closing the [Server]'s underlying Listener(s).</code></span>
<span class="codeline" id="line-2972"><code>//</code></span>
<span class="codeline" id="line-2973"><code>// When Shutdown is called, [Serve], [ListenAndServe], and</code></span>
<span class="codeline" id="line-2974"><code>// [ListenAndServeTLS] immediately return [ErrServerClosed]. Make sure the</code></span>
<span class="codeline" id="line-2975"><code>// program doesn't exit and waits instead for Shutdown to return.</code></span>
<span class="codeline" id="line-2976"><code>//</code></span>
<span class="codeline" id="line-2977"><code>// Shutdown does not attempt to close nor wait for hijacked</code></span>
<span class="codeline" id="line-2978"><code>// connections such as WebSockets. The caller of Shutdown should</code></span>
<span class="codeline" id="line-2979"><code>// separately notify such long-lived connections of shutdown and wait</code></span>
<span class="codeline" id="line-2980"><code>// for them to close, if desired. See [Server.RegisterOnShutdown] for a way to</code></span>
<span class="codeline" id="line-2981"><code>// register shutdown notification functions.</code></span>
<span class="codeline" id="line-2982"><code>//</code></span>
<span class="codeline" id="line-2983"><code>// Once Shutdown has been called on a server, it may not be reused;</code></span>
<span class="codeline" id="line-2984"><code>// future calls to methods such as Serve will return ErrServerClosed.</code></span>
<span class="codeline" id="line-2985"><code>func (srv *Server) Shutdown(ctx context.Context) error {</code></span>
<span class="codeline" id="line-2986"><code>	srv.inShutdown.Store(true)</code></span>
<span class="codeline" id="line-2987"><code></code></span>
<span class="codeline" id="line-2988"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-2989"><code>	lnerr := srv.closeListenersLocked()</code></span>
<span class="codeline" id="line-2990"><code>	for _, f := range srv.onShutdown {</code></span>
<span class="codeline" id="line-2991"><code>		go f()</code></span>
<span class="codeline" id="line-2992"><code>	}</code></span>
<span class="codeline" id="line-2993"><code>	srv.mu.Unlock()</code></span>
<span class="codeline" id="line-2994"><code>	srv.listenerGroup.Wait()</code></span>
<span class="codeline" id="line-2995"><code></code></span>
<span class="codeline" id="line-2996"><code>	pollIntervalBase := time.Millisecond</code></span>
<span class="codeline" id="line-2997"><code>	nextPollInterval := func() time.Duration {</code></span>
<span class="codeline" id="line-2998"><code>		// Add 10% jitter.</code></span>
<span class="codeline" id="line-2999"><code>		interval := pollIntervalBase + time.Duration(rand.Intn(int(pollIntervalBase/10)))</code></span>
<span class="codeline" id="line-3000"><code>		// Double and clamp for next time.</code></span>
<span class="codeline" id="line-3001"><code>		pollIntervalBase *= 2</code></span>
<span class="codeline" id="line-3002"><code>		if pollIntervalBase &gt; shutdownPollIntervalMax {</code></span>
<span class="codeline" id="line-3003"><code>			pollIntervalBase = shutdownPollIntervalMax</code></span>
<span class="codeline" id="line-3004"><code>		}</code></span>
<span class="codeline" id="line-3005"><code>		return interval</code></span>
<span class="codeline" id="line-3006"><code>	}</code></span>
<span class="codeline" id="line-3007"><code></code></span>
<span class="codeline" id="line-3008"><code>	timer := time.NewTimer(nextPollInterval())</code></span>
<span class="codeline" id="line-3009"><code>	defer timer.Stop()</code></span>
<span class="codeline" id="line-3010"><code>	for {</code></span>
<span class="codeline" id="line-3011"><code>		if srv.closeIdleConns() {</code></span>
<span class="codeline" id="line-3012"><code>			return lnerr</code></span>
<span class="codeline" id="line-3013"><code>		}</code></span>
<span class="codeline" id="line-3014"><code>		select {</code></span>
<span class="codeline" id="line-3015"><code>		case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-3016"><code>			return ctx.Err()</code></span>
<span class="codeline" id="line-3017"><code>		case &lt;-timer.C:</code></span>
<span class="codeline" id="line-3018"><code>			timer.Reset(nextPollInterval())</code></span>
<span class="codeline" id="line-3019"><code>		}</code></span>
<span class="codeline" id="line-3020"><code>	}</code></span>
<span class="codeline" id="line-3021"><code>}</code></span>
<span class="codeline" id="line-3022"><code></code></span>
<span class="codeline" id="line-3023"><code>// RegisterOnShutdown registers a function to call on [Server.Shutdown].</code></span>
<span class="codeline" id="line-3024"><code>// This can be used to gracefully shutdown connections that have</code></span>
<span class="codeline" id="line-3025"><code>// undergone ALPN protocol upgrade or that have been hijacked.</code></span>
<span class="codeline" id="line-3026"><code>// This function should start protocol-specific graceful shutdown,</code></span>
<span class="codeline" id="line-3027"><code>// but should not wait for shutdown to complete.</code></span>
<span class="codeline" id="line-3028"><code>func (srv *Server) RegisterOnShutdown(f func()) {</code></span>
<span class="codeline" id="line-3029"><code>	srv.mu.Lock()</code></span>
<span class="codeline" id="line-3030"><code>	srv.onShutdown = append(srv.onShutdown, f)</code></span>
<span class="codeline" id="line-3031"><code>	srv.mu.Unlock()</code></span>
<span class="codeline" id="line-3032"><code>}</code></span>
<span class="codeline" id="line-3033"><code></code></span>
<span class="codeline" id="line-3034"><code>// closeIdleConns closes all idle connections and reports whether the</code></span>
<span class="codeline" id="line-3035"><code>// server is quiescent.</code></span>
<span class="codeline" id="line-3036"><code>func (s *Server) closeIdleConns() bool {</code></span>
<span class="codeline" id="line-3037"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-3038"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-3039"><code>	quiescent := true</code></span>
<span class="codeline" id="line-3040"><code>	for c := range s.activeConn {</code></span>
<span class="codeline" id="line-3041"><code>		st, unixSec := c.getState()</code></span>
<span class="codeline" id="line-3042"><code>		// Issue 22682: treat StateNew connections as if</code></span>
<span class="codeline" id="line-3043"><code>		// they're idle if we haven't read the first request's</code></span>
<span class="codeline" id="line-3044"><code>		// header in over 5 seconds.</code></span>
<span class="codeline" id="line-3045"><code>		if st == StateNew &amp;&amp; unixSec &lt; time.Now().Unix()-5 {</code></span>
<span class="codeline" id="line-3046"><code>			st = StateIdle</code></span>
<span class="codeline" id="line-3047"><code>		}</code></span>
<span class="codeline" id="line-3048"><code>		if st != StateIdle || unixSec == 0 {</code></span>
<span class="codeline" id="line-3049"><code>			// Assume unixSec == 0 means it's a very new</code></span>
<span class="codeline" id="line-3050"><code>			// connection, without state set yet.</code></span>
<span class="codeline" id="line-3051"><code>			quiescent = false</code></span>
<span class="codeline" id="line-3052"><code>			continue</code></span>
<span class="codeline" id="line-3053"><code>		}</code></span>
<span class="codeline" id="line-3054"><code>		c.rwc.Close()</code></span>
<span class="codeline" id="line-3055"><code>		delete(s.activeConn, c)</code></span>
<span class="codeline" id="line-3056"><code>	}</code></span>
<span class="codeline" id="line-3057"><code>	return quiescent</code></span>
<span class="codeline" id="line-3058"><code>}</code></span>
<span class="codeline" id="line-3059"><code></code></span>
<span class="codeline" id="line-3060"><code>func (s *Server) closeListenersLocked() error {</code></span>
<span class="codeline" id="line-3061"><code>	var err error</code></span>
<span class="codeline" id="line-3062"><code>	for ln := range s.listeners {</code></span>
<span class="codeline" id="line-3063"><code>		if cerr := (*ln).Close(); cerr != nil &amp;&amp; err == nil {</code></span>
<span class="codeline" id="line-3064"><code>			err = cerr</code></span>
<span class="codeline" id="line-3065"><code>		}</code></span>
<span class="codeline" id="line-3066"><code>	}</code></span>
<span class="codeline" id="line-3067"><code>	return err</code></span>
<span class="codeline" id="line-3068"><code>}</code></span>
<span class="codeline" id="line-3069"><code></code></span>
<span class="codeline" id="line-3070"><code>// A ConnState represents the state of a client connection to a server.</code></span>
<span class="codeline" id="line-3071"><code>// It's used by the optional [Server.ConnState] hook.</code></span>
<span class="codeline" id="line-3072"><code>type ConnState int</code></span>
<span class="codeline" id="line-3073"><code></code></span>
<span class="codeline" id="line-3074"><code>const (</code></span>
<span class="codeline" id="line-3075"><code>	// StateNew represents a new connection that is expected to</code></span>
<span class="codeline" id="line-3076"><code>	// send a request immediately. Connections begin at this</code></span>
<span class="codeline" id="line-3077"><code>	// state and then transition to either StateActive or</code></span>
<span class="codeline" id="line-3078"><code>	// StateClosed.</code></span>
<span class="codeline" id="line-3079"><code>	StateNew ConnState = iota</code></span>
<span class="codeline" id="line-3080"><code></code></span>
<span class="codeline" id="line-3081"><code>	// StateActive represents a connection that has read 1 or more</code></span>
<span class="codeline" id="line-3082"><code>	// bytes of a request. The Server.ConnState hook for</code></span>
<span class="codeline" id="line-3083"><code>	// StateActive fires before the request has entered a handler</code></span>
<span class="codeline" id="line-3084"><code>	// and doesn't fire again until the request has been</code></span>
<span class="codeline" id="line-3085"><code>	// handled. After the request is handled, the state</code></span>
<span class="codeline" id="line-3086"><code>	// transitions to StateClosed, StateHijacked, or StateIdle.</code></span>
<span class="codeline" id="line-3087"><code>	// For HTTP/2, StateActive fires on the transition from zero</code></span>
<span class="codeline" id="line-3088"><code>	// to one active request, and only transitions away once all</code></span>
<span class="codeline" id="line-3089"><code>	// active requests are complete. That means that ConnState</code></span>
<span class="codeline" id="line-3090"><code>	// cannot be used to do per-request work; ConnState only notes</code></span>
<span class="codeline" id="line-3091"><code>	// the overall state of the connection.</code></span>
<span class="codeline" id="line-3092"><code>	StateActive</code></span>
<span class="codeline" id="line-3093"><code></code></span>
<span class="codeline" id="line-3094"><code>	// StateIdle represents a connection that has finished</code></span>
<span class="codeline" id="line-3095"><code>	// handling a request and is in the keep-alive state, waiting</code></span>
<span class="codeline" id="line-3096"><code>	// for a new request. Connections transition from StateIdle</code></span>
<span class="codeline" id="line-3097"><code>	// to either StateActive or StateClosed.</code></span>
<span class="codeline" id="line-3098"><code>	StateIdle</code></span>
<span class="codeline" id="line-3099"><code></code></span>
<span class="codeline" id="line-3100"><code>	// StateHijacked represents a hijacked connection.</code></span>
<span class="codeline" id="line-3101"><code>	// This is a terminal state. It does not transition to StateClosed.</code></span>
<span class="codeline" id="line-3102"><code>	StateHijacked</code></span>
<span class="codeline" id="line-3103"><code></code></span>
<span class="codeline" id="line-3104"><code>	// StateClosed represents a closed connection.</code></span>
<span class="codeline" id="line-3105"><code>	// This is a terminal state. Hijacked connections do not</code></span>
<span class="codeline" id="line-3106"><code>	// transition to StateClosed.</code></span>
<span class="codeline" id="line-3107"><code>	StateClosed</code></span>
<span class="codeline" id="line-3108"><code>)</code></span>
<span class="codeline" id="line-3109"><code></code></span>
<span class="codeline" id="line-3110"><code>var stateName = map[ConnState]string{</code></span>
<span class="codeline" id="line-3111"><code>	StateNew:      "new",</code></span>
<span class="codeline" id="line-3112"><code>	StateActive:   "active",</code></span>
<span class="codeline" id="line-3113"><code>	StateIdle:     "idle",</code></span>
<span class="codeline" id="line-3114"><code>	StateHijacked: "hijacked",</code></span>
<span class="codeline" id="line-3115"><code>	StateClosed:   "closed",</code></span>
<span class="codeline" id="line-3116"><code>}</code></span>
<span class="codeline" id="line-3117"><code></code></span>
<span class="codeline" id="line-3118"><code>func (c ConnState) String() string {</code></span>
<span class="codeline" id="line-3119"><code>	return stateName[c]</code></span>
<span class="codeline" id="line-3120"><code>}</code></span>
<span class="codeline" id="line-3121"><code></code></span>
<span class="codeline" id="line-3122"><code>// serverHandler delegates to either the server's Handler or</code></span>
<span class="codeline" id="line-3123"><code>// DefaultServeMux and also handles "OPTIONS *" requests.</code></span>
<span class="codeline" id="line-3124"><code>type serverHandler struct {</code></span>
<span class="codeline" id="line-3125"><code>	srv *Server</code></span>
<span class="codeline" id="line-3126"><code>}</code></span>
<span class="codeline" id="line-3127"><code></code></span>
<span class="codeline" id="line-3128"><code>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {</code></span>
<span class="codeline" id="line-3129"><code>	handler := sh.srv.Handler</code></span>
<span class="codeline" id="line-3130"><code>	if handler == nil {</code></span>
<span class="codeline" id="line-3131"><code>		handler = DefaultServeMux</code></span>
<span class="codeline" id="line-3132"><code>	}</code></span>
<span class="codeline" id="line-3133"><code>	if !sh.srv.DisableGeneralOptionsHandler &amp;&amp; req.RequestURI == "*" &amp;&amp; req.Method == "OPTIONS" {</code></span>
<span class="codeline" id="line-3134"><code>		handler = globalOptionsHandler{}</code></span>
<span class="codeline" id="line-3135"><code>	}</code></span>
<span class="codeline" id="line-3136"><code></code></span>
<span class="codeline" id="line-3137"><code>	handler.ServeHTTP(rw, req)</code></span>
<span class="codeline" id="line-3138"><code>}</code></span>
<span class="codeline" id="line-3139"><code></code></span>
<span class="codeline" id="line-3140"><code>// AllowQuerySemicolons returns a handler that serves requests by converting any</code></span>
<span class="codeline" id="line-3141"><code>// unescaped semicolons in the URL query to ampersands, and invoking the handler h.</code></span>
<span class="codeline" id="line-3142"><code>//</code></span>
<span class="codeline" id="line-3143"><code>// This restores the pre-Go 1.17 behavior of splitting query parameters on both</code></span>
<span class="codeline" id="line-3144"><code>// semicolons and ampersands. (See golang.org/issue/25192). Note that this</code></span>
<span class="codeline" id="line-3145"><code>// behavior doesn't match that of many proxies, and the mismatch can lead to</code></span>
<span class="codeline" id="line-3146"><code>// security issues.</code></span>
<span class="codeline" id="line-3147"><code>//</code></span>
<span class="codeline" id="line-3148"><code>// AllowQuerySemicolons should be invoked before [Request.ParseForm] is called.</code></span>
<span class="codeline" id="line-3149"><code>func AllowQuerySemicolons(h Handler) Handler {</code></span>
<span class="codeline" id="line-3150"><code>	return HandlerFunc(func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3151"><code>		if strings.Contains(r.URL.RawQuery, ";") {</code></span>
<span class="codeline" id="line-3152"><code>			r2 := new(Request)</code></span>
<span class="codeline" id="line-3153"><code>			*r2 = *r</code></span>
<span class="codeline" id="line-3154"><code>			r2.URL = new(url.URL)</code></span>
<span class="codeline" id="line-3155"><code>			*r2.URL = *r.URL</code></span>
<span class="codeline" id="line-3156"><code>			r2.URL.RawQuery = strings.ReplaceAll(r.URL.RawQuery, ";", "&amp;")</code></span>
<span class="codeline" id="line-3157"><code>			h.ServeHTTP(w, r2)</code></span>
<span class="codeline" id="line-3158"><code>		} else {</code></span>
<span class="codeline" id="line-3159"><code>			h.ServeHTTP(w, r)</code></span>
<span class="codeline" id="line-3160"><code>		}</code></span>
<span class="codeline" id="line-3161"><code>	})</code></span>
<span class="codeline" id="line-3162"><code>}</code></span>
<span class="codeline" id="line-3163"><code></code></span>
<span class="codeline" id="line-3164"><code>// ListenAndServe listens on the TCP network address srv.Addr and then</code></span>
<span class="codeline" id="line-3165"><code>// calls [Serve] to handle requests on incoming connections.</code></span>
<span class="codeline" id="line-3166"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-3167"><code>//</code></span>
<span class="codeline" id="line-3168"><code>// If srv.Addr is blank, ":http" is used.</code></span>
<span class="codeline" id="line-3169"><code>//</code></span>
<span class="codeline" id="line-3170"><code>// ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close],</code></span>
<span class="codeline" id="line-3171"><code>// the returned error is [ErrServerClosed].</code></span>
<span class="codeline" id="line-3172"><code>func (srv *Server) ListenAndServe() error {</code></span>
<span class="codeline" id="line-3173"><code>	if srv.shuttingDown() {</code></span>
<span class="codeline" id="line-3174"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-3175"><code>	}</code></span>
<span class="codeline" id="line-3176"><code>	addr := srv.Addr</code></span>
<span class="codeline" id="line-3177"><code>	if addr == "" {</code></span>
<span class="codeline" id="line-3178"><code>		addr = ":http"</code></span>
<span class="codeline" id="line-3179"><code>	}</code></span>
<span class="codeline" id="line-3180"><code>	ln, err := net.Listen("tcp", addr)</code></span>
<span class="codeline" id="line-3181"><code>	if err != nil {</code></span>
<span class="codeline" id="line-3182"><code>		return err</code></span>
<span class="codeline" id="line-3183"><code>	}</code></span>
<span class="codeline" id="line-3184"><code>	return srv.Serve(ln)</code></span>
<span class="codeline" id="line-3185"><code>}</code></span>
<span class="codeline" id="line-3186"><code></code></span>
<span class="codeline" id="line-3187"><code>var testHookServerServe func(*Server, net.Listener) // used if non-nil</code></span>
<span class="codeline" id="line-3188"><code></code></span>
<span class="codeline" id="line-3189"><code>// shouldConfigureHTTP2ForServe reports whether Server.Serve should configure</code></span>
<span class="codeline" id="line-3190"><code>// automatic HTTP/2. (which sets up the srv.TLSNextProto map)</code></span>
<span class="codeline" id="line-3191"><code>func (srv *Server) shouldConfigureHTTP2ForServe() bool {</code></span>
<span class="codeline" id="line-3192"><code>	if srv.TLSConfig == nil {</code></span>
<span class="codeline" id="line-3193"><code>		// Compatibility with Go 1.6:</code></span>
<span class="codeline" id="line-3194"><code>		// If there's no TLSConfig, it's possible that the user just</code></span>
<span class="codeline" id="line-3195"><code>		// didn't set it on the http.Server, but did pass it to</code></span>
<span class="codeline" id="line-3196"><code>		// tls.NewListener and passed that listener to Serve.</code></span>
<span class="codeline" id="line-3197"><code>		// So we should configure HTTP/2 (to set up srv.TLSNextProto)</code></span>
<span class="codeline" id="line-3198"><code>		// in case the listener returns an "h2" *tls.Conn.</code></span>
<span class="codeline" id="line-3199"><code>		return true</code></span>
<span class="codeline" id="line-3200"><code>	}</code></span>
<span class="codeline" id="line-3201"><code>	// The user specified a TLSConfig on their http.Server.</code></span>
<span class="codeline" id="line-3202"><code>	// In this, case, only configure HTTP/2 if their tls.Config</code></span>
<span class="codeline" id="line-3203"><code>	// explicitly mentions "h2". Otherwise http2.ConfigureServer</code></span>
<span class="codeline" id="line-3204"><code>	// would modify the tls.Config to add it, but they probably already</code></span>
<span class="codeline" id="line-3205"><code>	// passed this tls.Config to tls.NewListener. And if they did,</code></span>
<span class="codeline" id="line-3206"><code>	// it's too late anyway to fix it. It would only be potentially racy.</code></span>
<span class="codeline" id="line-3207"><code>	// See Issue 15908.</code></span>
<span class="codeline" id="line-3208"><code>	return strSliceContains(srv.TLSConfig.NextProtos, http2NextProtoTLS)</code></span>
<span class="codeline" id="line-3209"><code>}</code></span>
<span class="codeline" id="line-3210"><code></code></span>
<span class="codeline" id="line-3211"><code>// ErrServerClosed is returned by the [Server.Serve], [ServeTLS], [ListenAndServe],</code></span>
<span class="codeline" id="line-3212"><code>// and [ListenAndServeTLS] methods after a call to [Server.Shutdown] or [Server.Close].</code></span>
<span class="codeline" id="line-3213"><code>var ErrServerClosed = errors.New("http: Server closed")</code></span>
<span class="codeline" id="line-3214"><code></code></span>
<span class="codeline" id="line-3215"><code>// Serve accepts incoming connections on the Listener l, creating a</code></span>
<span class="codeline" id="line-3216"><code>// new service goroutine for each. The service goroutines read requests and</code></span>
<span class="codeline" id="line-3217"><code>// then call srv.Handler to reply to them.</code></span>
<span class="codeline" id="line-3218"><code>//</code></span>
<span class="codeline" id="line-3219"><code>// HTTP/2 support is only enabled if the Listener returns [*tls.Conn]</code></span>
<span class="codeline" id="line-3220"><code>// connections and they were configured with "h2" in the TLS</code></span>
<span class="codeline" id="line-3221"><code>// Config.NextProtos.</code></span>
<span class="codeline" id="line-3222"><code>//</code></span>
<span class="codeline" id="line-3223"><code>// Serve always returns a non-nil error and closes l.</code></span>
<span class="codeline" id="line-3224"><code>// After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed].</code></span>
<span class="codeline" id="line-3225"><code>func (srv *Server) Serve(l net.Listener) error {</code></span>
<span class="codeline" id="line-3226"><code>	if fn := testHookServerServe; fn != nil {</code></span>
<span class="codeline" id="line-3227"><code>		fn(srv, l) // call hook with unwrapped listener</code></span>
<span class="codeline" id="line-3228"><code>	}</code></span>
<span class="codeline" id="line-3229"><code></code></span>
<span class="codeline" id="line-3230"><code>	origListener := l</code></span>
<span class="codeline" id="line-3231"><code>	l = &amp;onceCloseListener{Listener: l}</code></span>
<span class="codeline" id="line-3232"><code>	defer l.Close()</code></span>
<span class="codeline" id="line-3233"><code></code></span>
<span class="codeline" id="line-3234"><code>	if err := srv.setupHTTP2_Serve(); err != nil {</code></span>
<span class="codeline" id="line-3235"><code>		return err</code></span>
<span class="codeline" id="line-3236"><code>	}</code></span>
<span class="codeline" id="line-3237"><code></code></span>
<span class="codeline" id="line-3238"><code>	if !srv.trackListener(&amp;l, true) {</code></span>
<span class="codeline" id="line-3239"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-3240"><code>	}</code></span>
<span class="codeline" id="line-3241"><code>	defer srv.trackListener(&amp;l, false)</code></span>
<span class="codeline" id="line-3242"><code></code></span>
<span class="codeline" id="line-3243"><code>	baseCtx := context.Background()</code></span>
<span class="codeline" id="line-3244"><code>	if srv.BaseContext != nil {</code></span>
<span class="codeline" id="line-3245"><code>		baseCtx = srv.BaseContext(origListener)</code></span>
<span class="codeline" id="line-3246"><code>		if baseCtx == nil {</code></span>
<span class="codeline" id="line-3247"><code>			panic("BaseContext returned a nil context")</code></span>
<span class="codeline" id="line-3248"><code>		}</code></span>
<span class="codeline" id="line-3249"><code>	}</code></span>
<span class="codeline" id="line-3250"><code></code></span>
<span class="codeline" id="line-3251"><code>	var tempDelay time.Duration // how long to sleep on accept failure</code></span>
<span class="codeline" id="line-3252"><code></code></span>
<span class="codeline" id="line-3253"><code>	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</code></span>
<span class="codeline" id="line-3254"><code>	for {</code></span>
<span class="codeline" id="line-3255"><code>		rw, err := l.Accept()</code></span>
<span class="codeline" id="line-3256"><code>		if err != nil {</code></span>
<span class="codeline" id="line-3257"><code>			if srv.shuttingDown() {</code></span>
<span class="codeline" id="line-3258"><code>				return ErrServerClosed</code></span>
<span class="codeline" id="line-3259"><code>			}</code></span>
<span class="codeline" id="line-3260"><code>			if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() {</code></span>
<span class="codeline" id="line-3261"><code>				if tempDelay == 0 {</code></span>
<span class="codeline" id="line-3262"><code>					tempDelay = 5 * time.Millisecond</code></span>
<span class="codeline" id="line-3263"><code>				} else {</code></span>
<span class="codeline" id="line-3264"><code>					tempDelay *= 2</code></span>
<span class="codeline" id="line-3265"><code>				}</code></span>
<span class="codeline" id="line-3266"><code>				if max := 1 * time.Second; tempDelay &gt; max {</code></span>
<span class="codeline" id="line-3267"><code>					tempDelay = max</code></span>
<span class="codeline" id="line-3268"><code>				}</code></span>
<span class="codeline" id="line-3269"><code>				srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)</code></span>
<span class="codeline" id="line-3270"><code>				time.Sleep(tempDelay)</code></span>
<span class="codeline" id="line-3271"><code>				continue</code></span>
<span class="codeline" id="line-3272"><code>			}</code></span>
<span class="codeline" id="line-3273"><code>			return err</code></span>
<span class="codeline" id="line-3274"><code>		}</code></span>
<span class="codeline" id="line-3275"><code>		connCtx := ctx</code></span>
<span class="codeline" id="line-3276"><code>		if cc := srv.ConnContext; cc != nil {</code></span>
<span class="codeline" id="line-3277"><code>			connCtx = cc(connCtx, rw)</code></span>
<span class="codeline" id="line-3278"><code>			if connCtx == nil {</code></span>
<span class="codeline" id="line-3279"><code>				panic("ConnContext returned nil")</code></span>
<span class="codeline" id="line-3280"><code>			}</code></span>
<span class="codeline" id="line-3281"><code>		}</code></span>
<span class="codeline" id="line-3282"><code>		tempDelay = 0</code></span>
<span class="codeline" id="line-3283"><code>		c := srv.newConn(rw)</code></span>
<span class="codeline" id="line-3284"><code>		c.setState(c.rwc, StateNew, runHooks) // before Serve can return</code></span>
<span class="codeline" id="line-3285"><code>		go c.serve(connCtx)</code></span>
<span class="codeline" id="line-3286"><code>	}</code></span>
<span class="codeline" id="line-3287"><code>}</code></span>
<span class="codeline" id="line-3288"><code></code></span>
<span class="codeline" id="line-3289"><code>// ServeTLS accepts incoming connections on the Listener l, creating a</code></span>
<span class="codeline" id="line-3290"><code>// new service goroutine for each. The service goroutines perform TLS</code></span>
<span class="codeline" id="line-3291"><code>// setup and then read requests, calling srv.Handler to reply to them.</code></span>
<span class="codeline" id="line-3292"><code>//</code></span>
<span class="codeline" id="line-3293"><code>// Files containing a certificate and matching private key for the</code></span>
<span class="codeline" id="line-3294"><code>// server must be provided if neither the [Server]'s</code></span>
<span class="codeline" id="line-3295"><code>// TLSConfig.Certificates nor TLSConfig.GetCertificate are populated.</code></span>
<span class="codeline" id="line-3296"><code>// If the certificate is signed by a certificate authority, the</code></span>
<span class="codeline" id="line-3297"><code>// certFile should be the concatenation of the server's certificate,</code></span>
<span class="codeline" id="line-3298"><code>// any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-3299"><code>//</code></span>
<span class="codeline" id="line-3300"><code>// ServeTLS always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the</code></span>
<span class="codeline" id="line-3301"><code>// returned error is [ErrServerClosed].</code></span>
<span class="codeline" id="line-3302"><code>func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-3303"><code>	// Setup HTTP/2 before srv.Serve, to initialize srv.TLSConfig</code></span>
<span class="codeline" id="line-3304"><code>	// before we clone it and create the TLS Listener.</code></span>
<span class="codeline" id="line-3305"><code>	if err := srv.setupHTTP2_ServeTLS(); err != nil {</code></span>
<span class="codeline" id="line-3306"><code>		return err</code></span>
<span class="codeline" id="line-3307"><code>	}</code></span>
<span class="codeline" id="line-3308"><code></code></span>
<span class="codeline" id="line-3309"><code>	config := cloneTLSConfig(srv.TLSConfig)</code></span>
<span class="codeline" id="line-3310"><code>	if !strSliceContains(config.NextProtos, "http/1.1") {</code></span>
<span class="codeline" id="line-3311"><code>		config.NextProtos = append(config.NextProtos, "http/1.1")</code></span>
<span class="codeline" id="line-3312"><code>	}</code></span>
<span class="codeline" id="line-3313"><code></code></span>
<span class="codeline" id="line-3314"><code>	configHasCert := len(config.Certificates) &gt; 0 || config.GetCertificate != nil</code></span>
<span class="codeline" id="line-3315"><code>	if !configHasCert || certFile != "" || keyFile != "" {</code></span>
<span class="codeline" id="line-3316"><code>		var err error</code></span>
<span class="codeline" id="line-3317"><code>		config.Certificates = make([]tls.Certificate, 1)</code></span>
<span class="codeline" id="line-3318"><code>		config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)</code></span>
<span class="codeline" id="line-3319"><code>		if err != nil {</code></span>
<span class="codeline" id="line-3320"><code>			return err</code></span>
<span class="codeline" id="line-3321"><code>		}</code></span>
<span class="codeline" id="line-3322"><code>	}</code></span>
<span class="codeline" id="line-3323"><code></code></span>
<span class="codeline" id="line-3324"><code>	tlsListener := tls.NewListener(l, config)</code></span>
<span class="codeline" id="line-3325"><code>	return srv.Serve(tlsListener)</code></span>
<span class="codeline" id="line-3326"><code>}</code></span>
<span class="codeline" id="line-3327"><code></code></span>
<span class="codeline" id="line-3328"><code>// trackListener adds or removes a net.Listener to the set of tracked</code></span>
<span class="codeline" id="line-3329"><code>// listeners.</code></span>
<span class="codeline" id="line-3330"><code>//</code></span>
<span class="codeline" id="line-3331"><code>// We store a pointer to interface in the map set, in case the</code></span>
<span class="codeline" id="line-3332"><code>// net.Listener is not comparable. This is safe because we only call</code></span>
<span class="codeline" id="line-3333"><code>// trackListener via Serve and can track+defer untrack the same</code></span>
<span class="codeline" id="line-3334"><code>// pointer to local variable there. We never need to compare a</code></span>
<span class="codeline" id="line-3335"><code>// Listener from another caller.</code></span>
<span class="codeline" id="line-3336"><code>//</code></span>
<span class="codeline" id="line-3337"><code>// It reports whether the server is still up (not Shutdown or Closed).</code></span>
<span class="codeline" id="line-3338"><code>func (s *Server) trackListener(ln *net.Listener, add bool) bool {</code></span>
<span class="codeline" id="line-3339"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-3340"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-3341"><code>	if s.listeners == nil {</code></span>
<span class="codeline" id="line-3342"><code>		s.listeners = make(map[*net.Listener]struct{})</code></span>
<span class="codeline" id="line-3343"><code>	}</code></span>
<span class="codeline" id="line-3344"><code>	if add {</code></span>
<span class="codeline" id="line-3345"><code>		if s.shuttingDown() {</code></span>
<span class="codeline" id="line-3346"><code>			return false</code></span>
<span class="codeline" id="line-3347"><code>		}</code></span>
<span class="codeline" id="line-3348"><code>		s.listeners[ln] = struct{}{}</code></span>
<span class="codeline" id="line-3349"><code>		s.listenerGroup.Add(1)</code></span>
<span class="codeline" id="line-3350"><code>	} else {</code></span>
<span class="codeline" id="line-3351"><code>		delete(s.listeners, ln)</code></span>
<span class="codeline" id="line-3352"><code>		s.listenerGroup.Done()</code></span>
<span class="codeline" id="line-3353"><code>	}</code></span>
<span class="codeline" id="line-3354"><code>	return true</code></span>
<span class="codeline" id="line-3355"><code>}</code></span>
<span class="codeline" id="line-3356"><code></code></span>
<span class="codeline" id="line-3357"><code>func (s *Server) trackConn(c *conn, add bool) {</code></span>
<span class="codeline" id="line-3358"><code>	s.mu.Lock()</code></span>
<span class="codeline" id="line-3359"><code>	defer s.mu.Unlock()</code></span>
<span class="codeline" id="line-3360"><code>	if s.activeConn == nil {</code></span>
<span class="codeline" id="line-3361"><code>		s.activeConn = make(map[*conn]struct{})</code></span>
<span class="codeline" id="line-3362"><code>	}</code></span>
<span class="codeline" id="line-3363"><code>	if add {</code></span>
<span class="codeline" id="line-3364"><code>		s.activeConn[c] = struct{}{}</code></span>
<span class="codeline" id="line-3365"><code>	} else {</code></span>
<span class="codeline" id="line-3366"><code>		delete(s.activeConn, c)</code></span>
<span class="codeline" id="line-3367"><code>	}</code></span>
<span class="codeline" id="line-3368"><code>}</code></span>
<span class="codeline" id="line-3369"><code></code></span>
<span class="codeline" id="line-3370"><code>func (s *Server) idleTimeout() time.Duration {</code></span>
<span class="codeline" id="line-3371"><code>	if s.IdleTimeout != 0 {</code></span>
<span class="codeline" id="line-3372"><code>		return s.IdleTimeout</code></span>
<span class="codeline" id="line-3373"><code>	}</code></span>
<span class="codeline" id="line-3374"><code>	return s.ReadTimeout</code></span>
<span class="codeline" id="line-3375"><code>}</code></span>
<span class="codeline" id="line-3376"><code></code></span>
<span class="codeline" id="line-3377"><code>func (s *Server) readHeaderTimeout() time.Duration {</code></span>
<span class="codeline" id="line-3378"><code>	if s.ReadHeaderTimeout != 0 {</code></span>
<span class="codeline" id="line-3379"><code>		return s.ReadHeaderTimeout</code></span>
<span class="codeline" id="line-3380"><code>	}</code></span>
<span class="codeline" id="line-3381"><code>	return s.ReadTimeout</code></span>
<span class="codeline" id="line-3382"><code>}</code></span>
<span class="codeline" id="line-3383"><code></code></span>
<span class="codeline" id="line-3384"><code>func (s *Server) doKeepAlives() bool {</code></span>
<span class="codeline" id="line-3385"><code>	return !s.disableKeepAlives.Load() &amp;&amp; !s.shuttingDown()</code></span>
<span class="codeline" id="line-3386"><code>}</code></span>
<span class="codeline" id="line-3387"><code></code></span>
<span class="codeline" id="line-3388"><code>func (s *Server) shuttingDown() bool {</code></span>
<span class="codeline" id="line-3389"><code>	return s.inShutdown.Load()</code></span>
<span class="codeline" id="line-3390"><code>}</code></span>
<span class="codeline" id="line-3391"><code></code></span>
<span class="codeline" id="line-3392"><code>// SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.</code></span>
<span class="codeline" id="line-3393"><code>// By default, keep-alives are always enabled. Only very</code></span>
<span class="codeline" id="line-3394"><code>// resource-constrained environments or servers in the process of</code></span>
<span class="codeline" id="line-3395"><code>// shutting down should disable them.</code></span>
<span class="codeline" id="line-3396"><code>func (srv *Server) SetKeepAlivesEnabled(v bool) {</code></span>
<span class="codeline" id="line-3397"><code>	if v {</code></span>
<span class="codeline" id="line-3398"><code>		srv.disableKeepAlives.Store(false)</code></span>
<span class="codeline" id="line-3399"><code>		return</code></span>
<span class="codeline" id="line-3400"><code>	}</code></span>
<span class="codeline" id="line-3401"><code>	srv.disableKeepAlives.Store(true)</code></span>
<span class="codeline" id="line-3402"><code></code></span>
<span class="codeline" id="line-3403"><code>	// Close idle HTTP/1 conns:</code></span>
<span class="codeline" id="line-3404"><code>	srv.closeIdleConns()</code></span>
<span class="codeline" id="line-3405"><code></code></span>
<span class="codeline" id="line-3406"><code>	// TODO: Issue 26303: close HTTP/2 conns as soon as they become idle.</code></span>
<span class="codeline" id="line-3407"><code>}</code></span>
<span class="codeline" id="line-3408"><code></code></span>
<span class="codeline" id="line-3409"><code>func (s *Server) logf(format string, args ...any) {</code></span>
<span class="codeline" id="line-3410"><code>	if s.ErrorLog != nil {</code></span>
<span class="codeline" id="line-3411"><code>		s.ErrorLog.Printf(format, args...)</code></span>
<span class="codeline" id="line-3412"><code>	} else {</code></span>
<span class="codeline" id="line-3413"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-3414"><code>	}</code></span>
<span class="codeline" id="line-3415"><code>}</code></span>
<span class="codeline" id="line-3416"><code></code></span>
<span class="codeline" id="line-3417"><code>// logf prints to the ErrorLog of the *Server associated with request r</code></span>
<span class="codeline" id="line-3418"><code>// via ServerContextKey. If there's no associated server, or if ErrorLog</code></span>
<span class="codeline" id="line-3419"><code>// is nil, logging is done via the log package's standard logger.</code></span>
<span class="codeline" id="line-3420"><code>func logf(r *Request, format string, args ...any) {</code></span>
<span class="codeline" id="line-3421"><code>	s, _ := r.Context().Value(ServerContextKey).(*Server)</code></span>
<span class="codeline" id="line-3422"><code>	if s != nil &amp;&amp; s.ErrorLog != nil {</code></span>
<span class="codeline" id="line-3423"><code>		s.ErrorLog.Printf(format, args...)</code></span>
<span class="codeline" id="line-3424"><code>	} else {</code></span>
<span class="codeline" id="line-3425"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-3426"><code>	}</code></span>
<span class="codeline" id="line-3427"><code>}</code></span>
<span class="codeline" id="line-3428"><code></code></span>
<span class="codeline" id="line-3429"><code>// ListenAndServe listens on the TCP network address addr and then calls</code></span>
<span class="codeline" id="line-3430"><code>// [Serve] with handler to handle requests on incoming connections.</code></span>
<span class="codeline" id="line-3431"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-3432"><code>//</code></span>
<span class="codeline" id="line-3433"><code>// The handler is typically nil, in which case [DefaultServeMux] is used.</code></span>
<span class="codeline" id="line-3434"><code>//</code></span>
<span class="codeline" id="line-3435"><code>// ListenAndServe always returns a non-nil error.</code></span>
<span class="codeline" id="line-3436"><code>func ListenAndServe(addr string, handler Handler) error {</code></span>
<span class="codeline" id="line-3437"><code>	server := &amp;Server{Addr: addr, Handler: handler}</code></span>
<span class="codeline" id="line-3438"><code>	return server.ListenAndServe()</code></span>
<span class="codeline" id="line-3439"><code>}</code></span>
<span class="codeline" id="line-3440"><code></code></span>
<span class="codeline" id="line-3441"><code>// ListenAndServeTLS acts identically to [ListenAndServe], except that it</code></span>
<span class="codeline" id="line-3442"><code>// expects HTTPS connections. Additionally, files containing a certificate and</code></span>
<span class="codeline" id="line-3443"><code>// matching private key for the server must be provided. If the certificate</code></span>
<span class="codeline" id="line-3444"><code>// is signed by a certificate authority, the certFile should be the concatenation</code></span>
<span class="codeline" id="line-3445"><code>// of the server's certificate, any intermediates, and the CA's certificate.</code></span>
<span class="codeline" id="line-3446"><code>func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {</code></span>
<span class="codeline" id="line-3447"><code>	server := &amp;Server{Addr: addr, Handler: handler}</code></span>
<span class="codeline" id="line-3448"><code>	return server.ListenAndServeTLS(certFile, keyFile)</code></span>
<span class="codeline" id="line-3449"><code>}</code></span>
<span class="codeline" id="line-3450"><code></code></span>
<span class="codeline" id="line-3451"><code>// ListenAndServeTLS listens on the TCP network address srv.Addr and</code></span>
<span class="codeline" id="line-3452"><code>// then calls [ServeTLS] to handle requests on incoming TLS connections.</code></span>
<span class="codeline" id="line-3453"><code>// Accepted connections are configured to enable TCP keep-alives.</code></span>
<span class="codeline" id="line-3454"><code>//</code></span>
<span class="codeline" id="line-3455"><code>// Filenames containing a certificate and matching private key for the</code></span>
<span class="codeline" id="line-3456"><code>// server must be provided if neither the [Server]'s TLSConfig.Certificates</code></span>
<span class="codeline" id="line-3457"><code>// nor TLSConfig.GetCertificate are populated. If the certificate is</code></span>
<span class="codeline" id="line-3458"><code>// signed by a certificate authority, the certFile should be the</code></span>
<span class="codeline" id="line-3459"><code>// concatenation of the server's certificate, any intermediates, and</code></span>
<span class="codeline" id="line-3460"><code>// the CA's certificate.</code></span>
<span class="codeline" id="line-3461"><code>//</code></span>
<span class="codeline" id="line-3462"><code>// If srv.Addr is blank, ":https" is used.</code></span>
<span class="codeline" id="line-3463"><code>//</code></span>
<span class="codeline" id="line-3464"><code>// ListenAndServeTLS always returns a non-nil error. After [Server.Shutdown] or</code></span>
<span class="codeline" id="line-3465"><code>// [Server.Close], the returned error is [ErrServerClosed].</code></span>
<span class="codeline" id="line-3466"><code>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {</code></span>
<span class="codeline" id="line-3467"><code>	if srv.shuttingDown() {</code></span>
<span class="codeline" id="line-3468"><code>		return ErrServerClosed</code></span>
<span class="codeline" id="line-3469"><code>	}</code></span>
<span class="codeline" id="line-3470"><code>	addr := srv.Addr</code></span>
<span class="codeline" id="line-3471"><code>	if addr == "" {</code></span>
<span class="codeline" id="line-3472"><code>		addr = ":https"</code></span>
<span class="codeline" id="line-3473"><code>	}</code></span>
<span class="codeline" id="line-3474"><code></code></span>
<span class="codeline" id="line-3475"><code>	ln, err := net.Listen("tcp", addr)</code></span>
<span class="codeline" id="line-3476"><code>	if err != nil {</code></span>
<span class="codeline" id="line-3477"><code>		return err</code></span>
<span class="codeline" id="line-3478"><code>	}</code></span>
<span class="codeline" id="line-3479"><code></code></span>
<span class="codeline" id="line-3480"><code>	defer ln.Close()</code></span>
<span class="codeline" id="line-3481"><code></code></span>
<span class="codeline" id="line-3482"><code>	return srv.ServeTLS(ln, certFile, keyFile)</code></span>
<span class="codeline" id="line-3483"><code>}</code></span>
<span class="codeline" id="line-3484"><code></code></span>
<span class="codeline" id="line-3485"><code>// setupHTTP2_ServeTLS conditionally configures HTTP/2 on</code></span>
<span class="codeline" id="line-3486"><code>// srv and reports whether there was an error setting it up. If it is</code></span>
<span class="codeline" id="line-3487"><code>// not configured for policy reasons, nil is returned.</code></span>
<span class="codeline" id="line-3488"><code>func (srv *Server) setupHTTP2_ServeTLS() error {</code></span>
<span class="codeline" id="line-3489"><code>	srv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults)</code></span>
<span class="codeline" id="line-3490"><code>	return srv.nextProtoErr</code></span>
<span class="codeline" id="line-3491"><code>}</code></span>
<span class="codeline" id="line-3492"><code></code></span>
<span class="codeline" id="line-3493"><code>// setupHTTP2_Serve is called from (*Server).Serve and conditionally</code></span>
<span class="codeline" id="line-3494"><code>// configures HTTP/2 on srv using a more conservative policy than</code></span>
<span class="codeline" id="line-3495"><code>// setupHTTP2_ServeTLS because Serve is called after tls.Listen,</code></span>
<span class="codeline" id="line-3496"><code>// and may be called concurrently. See shouldConfigureHTTP2ForServe.</code></span>
<span class="codeline" id="line-3497"><code>//</code></span>
<span class="codeline" id="line-3498"><code>// The tests named TestTransportAutomaticHTTP2* and</code></span>
<span class="codeline" id="line-3499"><code>// TestConcurrentServerServe in server_test.go demonstrate some</code></span>
<span class="codeline" id="line-3500"><code>// of the supported use cases and motivations.</code></span>
<span class="codeline" id="line-3501"><code>func (srv *Server) setupHTTP2_Serve() error {</code></span>
<span class="codeline" id="line-3502"><code>	srv.nextProtoOnce.Do(srv.onceSetNextProtoDefaults_Serve)</code></span>
<span class="codeline" id="line-3503"><code>	return srv.nextProtoErr</code></span>
<span class="codeline" id="line-3504"><code>}</code></span>
<span class="codeline" id="line-3505"><code></code></span>
<span class="codeline" id="line-3506"><code>func (srv *Server) onceSetNextProtoDefaults_Serve() {</code></span>
<span class="codeline" id="line-3507"><code>	if srv.shouldConfigureHTTP2ForServe() {</code></span>
<span class="codeline" id="line-3508"><code>		srv.onceSetNextProtoDefaults()</code></span>
<span class="codeline" id="line-3509"><code>	}</code></span>
<span class="codeline" id="line-3510"><code>}</code></span>
<span class="codeline" id="line-3511"><code></code></span>
<span class="codeline" id="line-3512"><code>var http2server = godebug.New("http2server")</code></span>
<span class="codeline" id="line-3513"><code></code></span>
<span class="codeline" id="line-3514"><code>// onceSetNextProtoDefaults configures HTTP/2, if the user hasn't</code></span>
<span class="codeline" id="line-3515"><code>// configured otherwise. (by setting srv.TLSNextProto non-nil)</code></span>
<span class="codeline" id="line-3516"><code>// It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*).</code></span>
<span class="codeline" id="line-3517"><code>func (srv *Server) onceSetNextProtoDefaults() {</code></span>
<span class="codeline" id="line-3518"><code>	if omitBundledHTTP2 {</code></span>
<span class="codeline" id="line-3519"><code>		return</code></span>
<span class="codeline" id="line-3520"><code>	}</code></span>
<span class="codeline" id="line-3521"><code>	if http2server.Value() == "0" {</code></span>
<span class="codeline" id="line-3522"><code>		http2server.IncNonDefault()</code></span>
<span class="codeline" id="line-3523"><code>		return</code></span>
<span class="codeline" id="line-3524"><code>	}</code></span>
<span class="codeline" id="line-3525"><code>	// Enable HTTP/2 by default if the user hasn't otherwise</code></span>
<span class="codeline" id="line-3526"><code>	// configured their TLSNextProto map.</code></span>
<span class="codeline" id="line-3527"><code>	if srv.TLSNextProto == nil {</code></span>
<span class="codeline" id="line-3528"><code>		conf := &amp;http2Server{</code></span>
<span class="codeline" id="line-3529"><code>			NewWriteScheduler: func() http2WriteScheduler { return http2NewPriorityWriteScheduler(nil) },</code></span>
<span class="codeline" id="line-3530"><code>		}</code></span>
<span class="codeline" id="line-3531"><code>		srv.nextProtoErr = http2ConfigureServer(srv, conf)</code></span>
<span class="codeline" id="line-3532"><code>	}</code></span>
<span class="codeline" id="line-3533"><code>}</code></span>
<span class="codeline" id="line-3534"><code></code></span>
<span class="codeline" id="line-3535"><code>// TimeoutHandler returns a [Handler] that runs h with the given time limit.</code></span>
<span class="codeline" id="line-3536"><code>//</code></span>
<span class="codeline" id="line-3537"><code>// The new Handler calls h.ServeHTTP to handle each request, but if a</code></span>
<span class="codeline" id="line-3538"><code>// call runs for longer than its time limit, the handler responds with</code></span>
<span class="codeline" id="line-3539"><code>// a 503 Service Unavailable error and the given message in its body.</code></span>
<span class="codeline" id="line-3540"><code>// (If msg is empty, a suitable default message will be sent.)</code></span>
<span class="codeline" id="line-3541"><code>// After such a timeout, writes by h to its [ResponseWriter] will return</code></span>
<span class="codeline" id="line-3542"><code>// [ErrHandlerTimeout].</code></span>
<span class="codeline" id="line-3543"><code>//</code></span>
<span class="codeline" id="line-3544"><code>// TimeoutHandler supports the [Pusher] interface but does not support</code></span>
<span class="codeline" id="line-3545"><code>// the [Hijacker] or [Flusher] interfaces.</code></span>
<span class="codeline" id="line-3546"><code>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler {</code></span>
<span class="codeline" id="line-3547"><code>	return &amp;timeoutHandler{</code></span>
<span class="codeline" id="line-3548"><code>		handler: h,</code></span>
<span class="codeline" id="line-3549"><code>		body:    msg,</code></span>
<span class="codeline" id="line-3550"><code>		dt:      dt,</code></span>
<span class="codeline" id="line-3551"><code>	}</code></span>
<span class="codeline" id="line-3552"><code>}</code></span>
<span class="codeline" id="line-3553"><code></code></span>
<span class="codeline" id="line-3554"><code>// ErrHandlerTimeout is returned on [ResponseWriter] Write calls</code></span>
<span class="codeline" id="line-3555"><code>// in handlers which have timed out.</code></span>
<span class="codeline" id="line-3556"><code>var ErrHandlerTimeout = errors.New("http: Handler timeout")</code></span>
<span class="codeline" id="line-3557"><code></code></span>
<span class="codeline" id="line-3558"><code>type timeoutHandler struct {</code></span>
<span class="codeline" id="line-3559"><code>	handler Handler</code></span>
<span class="codeline" id="line-3560"><code>	body    string</code></span>
<span class="codeline" id="line-3561"><code>	dt      time.Duration</code></span>
<span class="codeline" id="line-3562"><code></code></span>
<span class="codeline" id="line-3563"><code>	// When set, no context will be created and this context will</code></span>
<span class="codeline" id="line-3564"><code>	// be used instead.</code></span>
<span class="codeline" id="line-3565"><code>	testContext context.Context</code></span>
<span class="codeline" id="line-3566"><code>}</code></span>
<span class="codeline" id="line-3567"><code></code></span>
<span class="codeline" id="line-3568"><code>func (h *timeoutHandler) errorBody() string {</code></span>
<span class="codeline" id="line-3569"><code>	if h.body != "" {</code></span>
<span class="codeline" id="line-3570"><code>		return h.body</code></span>
<span class="codeline" id="line-3571"><code>	}</code></span>
<span class="codeline" id="line-3572"><code>	return "&lt;html&gt;&lt;head&gt;&lt;title&gt;Timeout&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Timeout&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</code></span>
<span class="codeline" id="line-3573"><code>}</code></span>
<span class="codeline" id="line-3574"><code></code></span>
<span class="codeline" id="line-3575"><code>func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3576"><code>	ctx := h.testContext</code></span>
<span class="codeline" id="line-3577"><code>	if ctx == nil {</code></span>
<span class="codeline" id="line-3578"><code>		var cancelCtx context.CancelFunc</code></span>
<span class="codeline" id="line-3579"><code>		ctx, cancelCtx = context.WithTimeout(r.Context(), h.dt)</code></span>
<span class="codeline" id="line-3580"><code>		defer cancelCtx()</code></span>
<span class="codeline" id="line-3581"><code>	}</code></span>
<span class="codeline" id="line-3582"><code>	r = r.WithContext(ctx)</code></span>
<span class="codeline" id="line-3583"><code>	done := make(chan struct{})</code></span>
<span class="codeline" id="line-3584"><code>	tw := &amp;timeoutWriter{</code></span>
<span class="codeline" id="line-3585"><code>		w:   w,</code></span>
<span class="codeline" id="line-3586"><code>		h:   make(Header),</code></span>
<span class="codeline" id="line-3587"><code>		req: r,</code></span>
<span class="codeline" id="line-3588"><code>	}</code></span>
<span class="codeline" id="line-3589"><code>	panicChan := make(chan any, 1)</code></span>
<span class="codeline" id="line-3590"><code>	go func() {</code></span>
<span class="codeline" id="line-3591"><code>		defer func() {</code></span>
<span class="codeline" id="line-3592"><code>			if p := recover(); p != nil {</code></span>
<span class="codeline" id="line-3593"><code>				panicChan &lt;- p</code></span>
<span class="codeline" id="line-3594"><code>			}</code></span>
<span class="codeline" id="line-3595"><code>		}()</code></span>
<span class="codeline" id="line-3596"><code>		h.handler.ServeHTTP(tw, r)</code></span>
<span class="codeline" id="line-3597"><code>		close(done)</code></span>
<span class="codeline" id="line-3598"><code>	}()</code></span>
<span class="codeline" id="line-3599"><code>	select {</code></span>
<span class="codeline" id="line-3600"><code>	case p := &lt;-panicChan:</code></span>
<span class="codeline" id="line-3601"><code>		panic(p)</code></span>
<span class="codeline" id="line-3602"><code>	case &lt;-done:</code></span>
<span class="codeline" id="line-3603"><code>		tw.mu.Lock()</code></span>
<span class="codeline" id="line-3604"><code>		defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3605"><code>		dst := w.Header()</code></span>
<span class="codeline" id="line-3606"><code>		for k, vv := range tw.h {</code></span>
<span class="codeline" id="line-3607"><code>			dst[k] = vv</code></span>
<span class="codeline" id="line-3608"><code>		}</code></span>
<span class="codeline" id="line-3609"><code>		if !tw.wroteHeader {</code></span>
<span class="codeline" id="line-3610"><code>			tw.code = StatusOK</code></span>
<span class="codeline" id="line-3611"><code>		}</code></span>
<span class="codeline" id="line-3612"><code>		w.WriteHeader(tw.code)</code></span>
<span class="codeline" id="line-3613"><code>		w.Write(tw.wbuf.Bytes())</code></span>
<span class="codeline" id="line-3614"><code>	case &lt;-ctx.Done():</code></span>
<span class="codeline" id="line-3615"><code>		tw.mu.Lock()</code></span>
<span class="codeline" id="line-3616"><code>		defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3617"><code>		switch err := ctx.Err(); err {</code></span>
<span class="codeline" id="line-3618"><code>		case context.DeadlineExceeded:</code></span>
<span class="codeline" id="line-3619"><code>			w.WriteHeader(StatusServiceUnavailable)</code></span>
<span class="codeline" id="line-3620"><code>			io.WriteString(w, h.errorBody())</code></span>
<span class="codeline" id="line-3621"><code>			tw.err = ErrHandlerTimeout</code></span>
<span class="codeline" id="line-3622"><code>		default:</code></span>
<span class="codeline" id="line-3623"><code>			w.WriteHeader(StatusServiceUnavailable)</code></span>
<span class="codeline" id="line-3624"><code>			tw.err = err</code></span>
<span class="codeline" id="line-3625"><code>		}</code></span>
<span class="codeline" id="line-3626"><code>	}</code></span>
<span class="codeline" id="line-3627"><code>}</code></span>
<span class="codeline" id="line-3628"><code></code></span>
<span class="codeline" id="line-3629"><code>type timeoutWriter struct {</code></span>
<span class="codeline" id="line-3630"><code>	w    ResponseWriter</code></span>
<span class="codeline" id="line-3631"><code>	h    Header</code></span>
<span class="codeline" id="line-3632"><code>	wbuf bytes.Buffer</code></span>
<span class="codeline" id="line-3633"><code>	req  *Request</code></span>
<span class="codeline" id="line-3634"><code></code></span>
<span class="codeline" id="line-3635"><code>	mu          sync.Mutex</code></span>
<span class="codeline" id="line-3636"><code>	err         error</code></span>
<span class="codeline" id="line-3637"><code>	wroteHeader bool</code></span>
<span class="codeline" id="line-3638"><code>	code        int</code></span>
<span class="codeline" id="line-3639"><code>}</code></span>
<span class="codeline" id="line-3640"><code></code></span>
<span class="codeline" id="line-3641"><code>var _ Pusher = (*timeoutWriter)(nil)</code></span>
<span class="codeline" id="line-3642"><code></code></span>
<span class="codeline" id="line-3643"><code>// Push implements the [Pusher] interface.</code></span>
<span class="codeline" id="line-3644"><code>func (tw *timeoutWriter) Push(target string, opts *PushOptions) error {</code></span>
<span class="codeline" id="line-3645"><code>	if pusher, ok := tw.w.(Pusher); ok {</code></span>
<span class="codeline" id="line-3646"><code>		return pusher.Push(target, opts)</code></span>
<span class="codeline" id="line-3647"><code>	}</code></span>
<span class="codeline" id="line-3648"><code>	return ErrNotSupported</code></span>
<span class="codeline" id="line-3649"><code>}</code></span>
<span class="codeline" id="line-3650"><code></code></span>
<span class="codeline" id="line-3651"><code>func (tw *timeoutWriter) Header() Header { return tw.h }</code></span>
<span class="codeline" id="line-3652"><code></code></span>
<span class="codeline" id="line-3653"><code>func (tw *timeoutWriter) Write(p []byte) (int, error) {</code></span>
<span class="codeline" id="line-3654"><code>	tw.mu.Lock()</code></span>
<span class="codeline" id="line-3655"><code>	defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3656"><code>	if tw.err != nil {</code></span>
<span class="codeline" id="line-3657"><code>		return 0, tw.err</code></span>
<span class="codeline" id="line-3658"><code>	}</code></span>
<span class="codeline" id="line-3659"><code>	if !tw.wroteHeader {</code></span>
<span class="codeline" id="line-3660"><code>		tw.writeHeaderLocked(StatusOK)</code></span>
<span class="codeline" id="line-3661"><code>	}</code></span>
<span class="codeline" id="line-3662"><code>	return tw.wbuf.Write(p)</code></span>
<span class="codeline" id="line-3663"><code>}</code></span>
<span class="codeline" id="line-3664"><code></code></span>
<span class="codeline" id="line-3665"><code>func (tw *timeoutWriter) writeHeaderLocked(code int) {</code></span>
<span class="codeline" id="line-3666"><code>	checkWriteHeaderCode(code)</code></span>
<span class="codeline" id="line-3667"><code></code></span>
<span class="codeline" id="line-3668"><code>	switch {</code></span>
<span class="codeline" id="line-3669"><code>	case tw.err != nil:</code></span>
<span class="codeline" id="line-3670"><code>		return</code></span>
<span class="codeline" id="line-3671"><code>	case tw.wroteHeader:</code></span>
<span class="codeline" id="line-3672"><code>		if tw.req != nil {</code></span>
<span class="codeline" id="line-3673"><code>			caller := relevantCaller()</code></span>
<span class="codeline" id="line-3674"><code>			logf(tw.req, "http: superfluous response.WriteHeader call from %s (%s:%d)", caller.Function, path.Base(caller.File), caller.Line)</code></span>
<span class="codeline" id="line-3675"><code>		}</code></span>
<span class="codeline" id="line-3676"><code>	default:</code></span>
<span class="codeline" id="line-3677"><code>		tw.wroteHeader = true</code></span>
<span class="codeline" id="line-3678"><code>		tw.code = code</code></span>
<span class="codeline" id="line-3679"><code>	}</code></span>
<span class="codeline" id="line-3680"><code>}</code></span>
<span class="codeline" id="line-3681"><code></code></span>
<span class="codeline" id="line-3682"><code>func (tw *timeoutWriter) WriteHeader(code int) {</code></span>
<span class="codeline" id="line-3683"><code>	tw.mu.Lock()</code></span>
<span class="codeline" id="line-3684"><code>	defer tw.mu.Unlock()</code></span>
<span class="codeline" id="line-3685"><code>	tw.writeHeaderLocked(code)</code></span>
<span class="codeline" id="line-3686"><code>}</code></span>
<span class="codeline" id="line-3687"><code></code></span>
<span class="codeline" id="line-3688"><code>// onceCloseListener wraps a net.Listener, protecting it from</code></span>
<span class="codeline" id="line-3689"><code>// multiple Close calls.</code></span>
<span class="codeline" id="line-3690"><code>type onceCloseListener struct {</code></span>
<span class="codeline" id="line-3691"><code>	net.Listener</code></span>
<span class="codeline" id="line-3692"><code>	once     sync.Once</code></span>
<span class="codeline" id="line-3693"><code>	closeErr error</code></span>
<span class="codeline" id="line-3694"><code>}</code></span>
<span class="codeline" id="line-3695"><code></code></span>
<span class="codeline" id="line-3696"><code>func (oc *onceCloseListener) Close() error {</code></span>
<span class="codeline" id="line-3697"><code>	oc.once.Do(oc.close)</code></span>
<span class="codeline" id="line-3698"><code>	return oc.closeErr</code></span>
<span class="codeline" id="line-3699"><code>}</code></span>
<span class="codeline" id="line-3700"><code></code></span>
<span class="codeline" id="line-3701"><code>func (oc *onceCloseListener) close() { oc.closeErr = oc.Listener.Close() }</code></span>
<span class="codeline" id="line-3702"><code></code></span>
<span class="codeline" id="line-3703"><code>// globalOptionsHandler responds to "OPTIONS *" requests.</code></span>
<span class="codeline" id="line-3704"><code>type globalOptionsHandler struct{}</code></span>
<span class="codeline" id="line-3705"><code></code></span>
<span class="codeline" id="line-3706"><code>func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3707"><code>	w.Header().Set("Content-Length", "0")</code></span>
<span class="codeline" id="line-3708"><code>	if r.ContentLength != 0 {</code></span>
<span class="codeline" id="line-3709"><code>		// Read up to 4KB of OPTIONS body (as mentioned in the</code></span>
<span class="codeline" id="line-3710"><code>		// spec as being reserved for future use), but anything</code></span>
<span class="codeline" id="line-3711"><code>		// over that is considered a waste of server resources</code></span>
<span class="codeline" id="line-3712"><code>		// (or an attack) and we abort and close the connection,</code></span>
<span class="codeline" id="line-3713"><code>		// courtesy of MaxBytesReader's EOF behavior.</code></span>
<span class="codeline" id="line-3714"><code>		mb := MaxBytesReader(w, r.Body, 4&lt;&lt;10)</code></span>
<span class="codeline" id="line-3715"><code>		io.Copy(io.Discard, mb)</code></span>
<span class="codeline" id="line-3716"><code>	}</code></span>
<span class="codeline" id="line-3717"><code>}</code></span>
<span class="codeline" id="line-3718"><code></code></span>
<span class="codeline" id="line-3719"><code>// initALPNRequest is an HTTP handler that initializes certain</code></span>
<span class="codeline" id="line-3720"><code>// uninitialized fields in its *Request. Such partially-initialized</code></span>
<span class="codeline" id="line-3721"><code>// Requests come from ALPN protocol handlers.</code></span>
<span class="codeline" id="line-3722"><code>type initALPNRequest struct {</code></span>
<span class="codeline" id="line-3723"><code>	ctx context.Context</code></span>
<span class="codeline" id="line-3724"><code>	c   *tls.Conn</code></span>
<span class="codeline" id="line-3725"><code>	h   serverHandler</code></span>
<span class="codeline" id="line-3726"><code>}</code></span>
<span class="codeline" id="line-3727"><code></code></span>
<span class="codeline" id="line-3728"><code>// BaseContext is an exported but unadvertised [http.Handler] method</code></span>
<span class="codeline" id="line-3729"><code>// recognized by x/net/http2 to pass down a context; the TLSNextProto</code></span>
<span class="codeline" id="line-3730"><code>// API predates context support so we shoehorn through the only</code></span>
<span class="codeline" id="line-3731"><code>// interface we have available.</code></span>
<span class="codeline" id="line-3732"><code>func (h initALPNRequest) BaseContext() context.Context { return h.ctx }</code></span>
<span class="codeline" id="line-3733"><code></code></span>
<span class="codeline" id="line-3734"><code>func (h initALPNRequest) ServeHTTP(rw ResponseWriter, req *Request) {</code></span>
<span class="codeline" id="line-3735"><code>	if req.TLS == nil {</code></span>
<span class="codeline" id="line-3736"><code>		req.TLS = &amp;tls.ConnectionState{}</code></span>
<span class="codeline" id="line-3737"><code>		*req.TLS = h.c.ConnectionState()</code></span>
<span class="codeline" id="line-3738"><code>	}</code></span>
<span class="codeline" id="line-3739"><code>	if req.Body == nil {</code></span>
<span class="codeline" id="line-3740"><code>		req.Body = NoBody</code></span>
<span class="codeline" id="line-3741"><code>	}</code></span>
<span class="codeline" id="line-3742"><code>	if req.RemoteAddr == "" {</code></span>
<span class="codeline" id="line-3743"><code>		req.RemoteAddr = h.c.RemoteAddr().String()</code></span>
<span class="codeline" id="line-3744"><code>	}</code></span>
<span class="codeline" id="line-3745"><code>	h.h.ServeHTTP(rw, req)</code></span>
<span class="codeline" id="line-3746"><code>}</code></span>
<span class="codeline" id="line-3747"><code></code></span>
<span class="codeline" id="line-3748"><code>// loggingConn is used for debugging.</code></span>
<span class="codeline" id="line-3749"><code>type loggingConn struct {</code></span>
<span class="codeline" id="line-3750"><code>	name string</code></span>
<span class="codeline" id="line-3751"><code>	net.Conn</code></span>
<span class="codeline" id="line-3752"><code>}</code></span>
<span class="codeline" id="line-3753"><code></code></span>
<span class="codeline" id="line-3754"><code>var (</code></span>
<span class="codeline" id="line-3755"><code>	uniqNameMu   sync.Mutex</code></span>
<span class="codeline" id="line-3756"><code>	uniqNameNext = make(map[string]int)</code></span>
<span class="codeline" id="line-3757"><code>)</code></span>
<span class="codeline" id="line-3758"><code></code></span>
<span class="codeline" id="line-3759"><code>func newLoggingConn(baseName string, c net.Conn) net.Conn {</code></span>
<span class="codeline" id="line-3760"><code>	uniqNameMu.Lock()</code></span>
<span class="codeline" id="line-3761"><code>	defer uniqNameMu.Unlock()</code></span>
<span class="codeline" id="line-3762"><code>	uniqNameNext[baseName]++</code></span>
<span class="codeline" id="line-3763"><code>	return &amp;loggingConn{</code></span>
<span class="codeline" id="line-3764"><code>		name: fmt.Sprintf("%s-%d", baseName, uniqNameNext[baseName]),</code></span>
<span class="codeline" id="line-3765"><code>		Conn: c,</code></span>
<span class="codeline" id="line-3766"><code>	}</code></span>
<span class="codeline" id="line-3767"><code>}</code></span>
<span class="codeline" id="line-3768"><code></code></span>
<span class="codeline" id="line-3769"><code>func (c *loggingConn) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3770"><code>	log.Printf("%s.Write(%d) = ....", c.name, len(p))</code></span>
<span class="codeline" id="line-3771"><code>	n, err = c.Conn.Write(p)</code></span>
<span class="codeline" id="line-3772"><code>	log.Printf("%s.Write(%d) = %d, %v", c.name, len(p), n, err)</code></span>
<span class="codeline" id="line-3773"><code>	return</code></span>
<span class="codeline" id="line-3774"><code>}</code></span>
<span class="codeline" id="line-3775"><code></code></span>
<span class="codeline" id="line-3776"><code>func (c *loggingConn) Read(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3777"><code>	log.Printf("%s.Read(%d) = ....", c.name, len(p))</code></span>
<span class="codeline" id="line-3778"><code>	n, err = c.Conn.Read(p)</code></span>
<span class="codeline" id="line-3779"><code>	log.Printf("%s.Read(%d) = %d, %v", c.name, len(p), n, err)</code></span>
<span class="codeline" id="line-3780"><code>	return</code></span>
<span class="codeline" id="line-3781"><code>}</code></span>
<span class="codeline" id="line-3782"><code></code></span>
<span class="codeline" id="line-3783"><code>func (c *loggingConn) Close() (err error) {</code></span>
<span class="codeline" id="line-3784"><code>	log.Printf("%s.Close() = ...", c.name)</code></span>
<span class="codeline" id="line-3785"><code>	err = c.Conn.Close()</code></span>
<span class="codeline" id="line-3786"><code>	log.Printf("%s.Close() = %v", c.name, err)</code></span>
<span class="codeline" id="line-3787"><code>	return</code></span>
<span class="codeline" id="line-3788"><code>}</code></span>
<span class="codeline" id="line-3789"><code></code></span>
<span class="codeline" id="line-3790"><code>// checkConnErrorWriter writes to c.rwc and records any write errors to c.werr.</code></span>
<span class="codeline" id="line-3791"><code>// It only contains one field (and a pointer field at that), so it</code></span>
<span class="codeline" id="line-3792"><code>// fits in an interface value without an extra allocation.</code></span>
<span class="codeline" id="line-3793"><code>type checkConnErrorWriter struct {</code></span>
<span class="codeline" id="line-3794"><code>	c *conn</code></span>
<span class="codeline" id="line-3795"><code>}</code></span>
<span class="codeline" id="line-3796"><code></code></span>
<span class="codeline" id="line-3797"><code>func (w checkConnErrorWriter) Write(p []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-3798"><code>	n, err = w.c.rwc.Write(p)</code></span>
<span class="codeline" id="line-3799"><code>	if err != nil &amp;&amp; w.c.werr == nil {</code></span>
<span class="codeline" id="line-3800"><code>		w.c.werr = err</code></span>
<span class="codeline" id="line-3801"><code>		w.c.cancelCtx()</code></span>
<span class="codeline" id="line-3802"><code>	}</code></span>
<span class="codeline" id="line-3803"><code>	return</code></span>
<span class="codeline" id="line-3804"><code>}</code></span>
<span class="codeline" id="line-3805"><code></code></span>
<span class="codeline" id="line-3806"><code>func numLeadingCRorLF(v []byte) (n int) {</code></span>
<span class="codeline" id="line-3807"><code>	for _, b := range v {</code></span>
<span class="codeline" id="line-3808"><code>		if b == '\r' || b == '\n' {</code></span>
<span class="codeline" id="line-3809"><code>			n++</code></span>
<span class="codeline" id="line-3810"><code>			continue</code></span>
<span class="codeline" id="line-3811"><code>		}</code></span>
<span class="codeline" id="line-3812"><code>		break</code></span>
<span class="codeline" id="line-3813"><code>	}</code></span>
<span class="codeline" id="line-3814"><code>	return</code></span>
<span class="codeline" id="line-3815"><code>}</code></span>
<span class="codeline" id="line-3816"><code></code></span>
<span class="codeline" id="line-3817"><code>func strSliceContains(ss []string, s string) bool {</code></span>
<span class="codeline" id="line-3818"><code>	for _, v := range ss {</code></span>
<span class="codeline" id="line-3819"><code>		if v == s {</code></span>
<span class="codeline" id="line-3820"><code>			return true</code></span>
<span class="codeline" id="line-3821"><code>		}</code></span>
<span class="codeline" id="line-3822"><code>	}</code></span>
<span class="codeline" id="line-3823"><code>	return false</code></span>
<span class="codeline" id="line-3824"><code>}</code></span>
<span class="codeline" id="line-3825"><code></code></span>
<span class="codeline" id="line-3826"><code>// tlsRecordHeaderLooksLikeHTTP reports whether a TLS record header</code></span>
<span class="codeline" id="line-3827"><code>// looks like it might've been a misdirected plaintext HTTP request.</code></span>
<span class="codeline" id="line-3828"><code>func tlsRecordHeaderLooksLikeHTTP(hdr [5]byte) bool {</code></span>
<span class="codeline" id="line-3829"><code>	switch string(hdr[:]) {</code></span>
<span class="codeline" id="line-3830"><code>	case "GET /", "HEAD ", "POST ", "PUT /", "OPTIO":</code></span>
<span class="codeline" id="line-3831"><code>		return true</code></span>
<span class="codeline" id="line-3832"><code>	}</code></span>
<span class="codeline" id="line-3833"><code>	return false</code></span>
<span class="codeline" id="line-3834"><code>}</code></span>
<span class="codeline" id="line-3835"><code></code></span>
<span class="codeline" id="line-3836"><code>// MaxBytesHandler returns a [Handler] that runs h with its [ResponseWriter] and [Request.Body] wrapped by a MaxBytesReader.</code></span>
<span class="codeline" id="line-3837"><code>func MaxBytesHandler(h Handler, n int64) Handler {</code></span>
<span class="codeline" id="line-3838"><code>	return HandlerFunc(func(w ResponseWriter, r *Request) {</code></span>
<span class="codeline" id="line-3839"><code>		r2 := *r</code></span>
<span class="codeline" id="line-3840"><code>		r2.Body = MaxBytesReader(w, r.Body, n)</code></span>
<span class="codeline" id="line-3841"><code>		h.ServeHTTP(w, &amp;r2)</code></span>
<span class="codeline" id="line-3842"><code>	})</code></span>
<span class="codeline" id="line-3843"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>