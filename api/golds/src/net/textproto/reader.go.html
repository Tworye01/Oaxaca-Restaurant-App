<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: reader.go in package net/textproto</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	reader.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/textproto.html">net/textproto</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2010 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>package textproto</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>import (</code></span>
<span class="codeline" id="line-8"><code>	"bufio"</code></span>
<span class="codeline" id="line-9"><code>	"bytes"</code></span>
<span class="codeline" id="line-10"><code>	"errors"</code></span>
<span class="codeline" id="line-11"><code>	"fmt"</code></span>
<span class="codeline" id="line-12"><code>	"io"</code></span>
<span class="codeline" id="line-13"><code>	"math"</code></span>
<span class="codeline" id="line-14"><code>	"strconv"</code></span>
<span class="codeline" id="line-15"><code>	"strings"</code></span>
<span class="codeline" id="line-16"><code>	"sync"</code></span>
<span class="codeline" id="line-17"><code>)</code></span>
<span class="codeline" id="line-18"><code></code></span>
<span class="codeline" id="line-19"><code>// TODO: This should be a distinguishable error (ErrMessageTooLarge)</code></span>
<span class="codeline" id="line-20"><code>// to allow mime/multipart to detect it.</code></span>
<span class="codeline" id="line-21"><code>var errMessageTooLarge = errors.New("message too large")</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code>// A Reader implements convenience methods for reading requests</code></span>
<span class="codeline" id="line-24"><code>// or responses from a text protocol network connection.</code></span>
<span class="codeline" id="line-25"><code>type Reader struct {</code></span>
<span class="codeline" id="line-26"><code>	R   *bufio.Reader</code></span>
<span class="codeline" id="line-27"><code>	dot *dotReader</code></span>
<span class="codeline" id="line-28"><code>	buf []byte // a re-usable buffer for readContinuedLineSlice</code></span>
<span class="codeline" id="line-29"><code>}</code></span>
<span class="codeline" id="line-30"><code></code></span>
<span class="codeline" id="line-31"><code>// NewReader returns a new [Reader] reading from r.</code></span>
<span class="codeline" id="line-32"><code>//</code></span>
<span class="codeline" id="line-33"><code>// To avoid denial of service attacks, the provided [bufio.Reader]</code></span>
<span class="codeline" id="line-34"><code>// should be reading from an [io.LimitReader] or similar Reader to bound</code></span>
<span class="codeline" id="line-35"><code>// the size of responses.</code></span>
<span class="codeline" id="line-36"><code>func NewReader(r *bufio.Reader) *Reader {</code></span>
<span class="codeline" id="line-37"><code>	return &amp;Reader{R: r}</code></span>
<span class="codeline" id="line-38"><code>}</code></span>
<span class="codeline" id="line-39"><code></code></span>
<span class="codeline" id="line-40"><code>// ReadLine reads a single line from r,</code></span>
<span class="codeline" id="line-41"><code>// eliding the final \n or \r\n from the returned string.</code></span>
<span class="codeline" id="line-42"><code>func (r *Reader) ReadLine() (string, error) {</code></span>
<span class="codeline" id="line-43"><code>	line, err := r.readLineSlice(-1)</code></span>
<span class="codeline" id="line-44"><code>	return string(line), err</code></span>
<span class="codeline" id="line-45"><code>}</code></span>
<span class="codeline" id="line-46"><code></code></span>
<span class="codeline" id="line-47"><code>// ReadLineBytes is like [Reader.ReadLine] but returns a []byte instead of a string.</code></span>
<span class="codeline" id="line-48"><code>func (r *Reader) ReadLineBytes() ([]byte, error) {</code></span>
<span class="codeline" id="line-49"><code>	line, err := r.readLineSlice(-1)</code></span>
<span class="codeline" id="line-50"><code>	if line != nil {</code></span>
<span class="codeline" id="line-51"><code>		line = bytes.Clone(line)</code></span>
<span class="codeline" id="line-52"><code>	}</code></span>
<span class="codeline" id="line-53"><code>	return line, err</code></span>
<span class="codeline" id="line-54"><code>}</code></span>
<span class="codeline" id="line-55"><code></code></span>
<span class="codeline" id="line-56"><code>// readLineSlice reads a single line from r,</code></span>
<span class="codeline" id="line-57"><code>// up to lim bytes long (or unlimited if lim is less than 0),</code></span>
<span class="codeline" id="line-58"><code>// eliding the final \r or \r\n from the returned string.</code></span>
<span class="codeline" id="line-59"><code>func (r *Reader) readLineSlice(lim int64) ([]byte, error) {</code></span>
<span class="codeline" id="line-60"><code>	r.closeDot()</code></span>
<span class="codeline" id="line-61"><code>	var line []byte</code></span>
<span class="codeline" id="line-62"><code>	for {</code></span>
<span class="codeline" id="line-63"><code>		l, more, err := r.R.ReadLine()</code></span>
<span class="codeline" id="line-64"><code>		if err != nil {</code></span>
<span class="codeline" id="line-65"><code>			return nil, err</code></span>
<span class="codeline" id="line-66"><code>		}</code></span>
<span class="codeline" id="line-67"><code>		if lim &gt;= 0 &amp;&amp; int64(len(line))+int64(len(l)) &gt; lim {</code></span>
<span class="codeline" id="line-68"><code>			return nil, errMessageTooLarge</code></span>
<span class="codeline" id="line-69"><code>		}</code></span>
<span class="codeline" id="line-70"><code>		// Avoid the copy if the first call produced a full line.</code></span>
<span class="codeline" id="line-71"><code>		if line == nil &amp;&amp; !more {</code></span>
<span class="codeline" id="line-72"><code>			return l, nil</code></span>
<span class="codeline" id="line-73"><code>		}</code></span>
<span class="codeline" id="line-74"><code>		line = append(line, l...)</code></span>
<span class="codeline" id="line-75"><code>		if !more {</code></span>
<span class="codeline" id="line-76"><code>			break</code></span>
<span class="codeline" id="line-77"><code>		}</code></span>
<span class="codeline" id="line-78"><code>	}</code></span>
<span class="codeline" id="line-79"><code>	return line, nil</code></span>
<span class="codeline" id="line-80"><code>}</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code>// ReadContinuedLine reads a possibly continued line from r,</code></span>
<span class="codeline" id="line-83"><code>// eliding the final trailing ASCII white space.</code></span>
<span class="codeline" id="line-84"><code>// Lines after the first are considered continuations if they</code></span>
<span class="codeline" id="line-85"><code>// begin with a space or tab character. In the returned data,</code></span>
<span class="codeline" id="line-86"><code>// continuation lines are separated from the previous line</code></span>
<span class="codeline" id="line-87"><code>// only by a single space: the newline and leading white space</code></span>
<span class="codeline" id="line-88"><code>// are removed.</code></span>
<span class="codeline" id="line-89"><code>//</code></span>
<span class="codeline" id="line-90"><code>// For example, consider this input:</code></span>
<span class="codeline" id="line-91"><code>//</code></span>
<span class="codeline" id="line-92"><code>//	Line 1</code></span>
<span class="codeline" id="line-93"><code>//	  continued...</code></span>
<span class="codeline" id="line-94"><code>//	Line 2</code></span>
<span class="codeline" id="line-95"><code>//</code></span>
<span class="codeline" id="line-96"><code>// The first call to ReadContinuedLine will return "Line 1 continued..."</code></span>
<span class="codeline" id="line-97"><code>// and the second will return "Line 2".</code></span>
<span class="codeline" id="line-98"><code>//</code></span>
<span class="codeline" id="line-99"><code>// Empty lines are never continued.</code></span>
<span class="codeline" id="line-100"><code>func (r *Reader) ReadContinuedLine() (string, error) {</code></span>
<span class="codeline" id="line-101"><code>	line, err := r.readContinuedLineSlice(-1, noValidation)</code></span>
<span class="codeline" id="line-102"><code>	return string(line), err</code></span>
<span class="codeline" id="line-103"><code>}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>// trim returns s with leading and trailing spaces and tabs removed.</code></span>
<span class="codeline" id="line-106"><code>// It does not assume Unicode or UTF-8.</code></span>
<span class="codeline" id="line-107"><code>func trim(s []byte) []byte {</code></span>
<span class="codeline" id="line-108"><code>	i := 0</code></span>
<span class="codeline" id="line-109"><code>	for i &lt; len(s) &amp;&amp; (s[i] == ' ' || s[i] == '\t') {</code></span>
<span class="codeline" id="line-110"><code>		i++</code></span>
<span class="codeline" id="line-111"><code>	}</code></span>
<span class="codeline" id="line-112"><code>	n := len(s)</code></span>
<span class="codeline" id="line-113"><code>	for n &gt; i &amp;&amp; (s[n-1] == ' ' || s[n-1] == '\t') {</code></span>
<span class="codeline" id="line-114"><code>		n--</code></span>
<span class="codeline" id="line-115"><code>	}</code></span>
<span class="codeline" id="line-116"><code>	return s[i:n]</code></span>
<span class="codeline" id="line-117"><code>}</code></span>
<span class="codeline" id="line-118"><code></code></span>
<span class="codeline" id="line-119"><code>// ReadContinuedLineBytes is like [Reader.ReadContinuedLine] but</code></span>
<span class="codeline" id="line-120"><code>// returns a []byte instead of a string.</code></span>
<span class="codeline" id="line-121"><code>func (r *Reader) ReadContinuedLineBytes() ([]byte, error) {</code></span>
<span class="codeline" id="line-122"><code>	line, err := r.readContinuedLineSlice(-1, noValidation)</code></span>
<span class="codeline" id="line-123"><code>	if line != nil {</code></span>
<span class="codeline" id="line-124"><code>		line = bytes.Clone(line)</code></span>
<span class="codeline" id="line-125"><code>	}</code></span>
<span class="codeline" id="line-126"><code>	return line, err</code></span>
<span class="codeline" id="line-127"><code>}</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code>// readContinuedLineSlice reads continued lines from the reader buffer,</code></span>
<span class="codeline" id="line-130"><code>// returning a byte slice with all lines. The validateFirstLine function</code></span>
<span class="codeline" id="line-131"><code>// is run on the first read line, and if it returns an error then this</code></span>
<span class="codeline" id="line-132"><code>// error is returned from readContinuedLineSlice.</code></span>
<span class="codeline" id="line-133"><code>// It reads up to lim bytes of data (or unlimited if lim is less than 0).</code></span>
<span class="codeline" id="line-134"><code>func (r *Reader) readContinuedLineSlice(lim int64, validateFirstLine func([]byte) error) ([]byte, error) {</code></span>
<span class="codeline" id="line-135"><code>	if validateFirstLine == nil {</code></span>
<span class="codeline" id="line-136"><code>		return nil, fmt.Errorf("missing validateFirstLine func")</code></span>
<span class="codeline" id="line-137"><code>	}</code></span>
<span class="codeline" id="line-138"><code></code></span>
<span class="codeline" id="line-139"><code>	// Read the first line.</code></span>
<span class="codeline" id="line-140"><code>	line, err := r.readLineSlice(lim)</code></span>
<span class="codeline" id="line-141"><code>	if err != nil {</code></span>
<span class="codeline" id="line-142"><code>		return nil, err</code></span>
<span class="codeline" id="line-143"><code>	}</code></span>
<span class="codeline" id="line-144"><code>	if len(line) == 0 { // blank line - no continuation</code></span>
<span class="codeline" id="line-145"><code>		return line, nil</code></span>
<span class="codeline" id="line-146"><code>	}</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>	if err := validateFirstLine(line); err != nil {</code></span>
<span class="codeline" id="line-149"><code>		return nil, err</code></span>
<span class="codeline" id="line-150"><code>	}</code></span>
<span class="codeline" id="line-151"><code></code></span>
<span class="codeline" id="line-152"><code>	// Optimistically assume that we have started to buffer the next line</code></span>
<span class="codeline" id="line-153"><code>	// and it starts with an ASCII letter (the next header key), or a blank</code></span>
<span class="codeline" id="line-154"><code>	// line, so we can avoid copying that buffered data around in memory</code></span>
<span class="codeline" id="line-155"><code>	// and skipping over non-existent whitespace.</code></span>
<span class="codeline" id="line-156"><code>	if r.R.Buffered() &gt; 1 {</code></span>
<span class="codeline" id="line-157"><code>		peek, _ := r.R.Peek(2)</code></span>
<span class="codeline" id="line-158"><code>		if len(peek) &gt; 0 &amp;&amp; (isASCIILetter(peek[0]) || peek[0] == '\n') ||</code></span>
<span class="codeline" id="line-159"><code>			len(peek) == 2 &amp;&amp; peek[0] == '\r' &amp;&amp; peek[1] == '\n' {</code></span>
<span class="codeline" id="line-160"><code>			return trim(line), nil</code></span>
<span class="codeline" id="line-161"><code>		}</code></span>
<span class="codeline" id="line-162"><code>	}</code></span>
<span class="codeline" id="line-163"><code></code></span>
<span class="codeline" id="line-164"><code>	// ReadByte or the next readLineSlice will flush the read buffer;</code></span>
<span class="codeline" id="line-165"><code>	// copy the slice into buf.</code></span>
<span class="codeline" id="line-166"><code>	r.buf = append(r.buf[:0], trim(line)...)</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>	if lim &lt; 0 {</code></span>
<span class="codeline" id="line-169"><code>		lim = math.MaxInt64</code></span>
<span class="codeline" id="line-170"><code>	}</code></span>
<span class="codeline" id="line-171"><code>	lim -= int64(len(r.buf))</code></span>
<span class="codeline" id="line-172"><code></code></span>
<span class="codeline" id="line-173"><code>	// Read continuation lines.</code></span>
<span class="codeline" id="line-174"><code>	for r.skipSpace() &gt; 0 {</code></span>
<span class="codeline" id="line-175"><code>		r.buf = append(r.buf, ' ')</code></span>
<span class="codeline" id="line-176"><code>		if int64(len(r.buf)) &gt;= lim {</code></span>
<span class="codeline" id="line-177"><code>			return nil, errMessageTooLarge</code></span>
<span class="codeline" id="line-178"><code>		}</code></span>
<span class="codeline" id="line-179"><code>		line, err := r.readLineSlice(lim - int64(len(r.buf)))</code></span>
<span class="codeline" id="line-180"><code>		if err != nil {</code></span>
<span class="codeline" id="line-181"><code>			break</code></span>
<span class="codeline" id="line-182"><code>		}</code></span>
<span class="codeline" id="line-183"><code>		r.buf = append(r.buf, trim(line)...)</code></span>
<span class="codeline" id="line-184"><code>	}</code></span>
<span class="codeline" id="line-185"><code>	return r.buf, nil</code></span>
<span class="codeline" id="line-186"><code>}</code></span>
<span class="codeline" id="line-187"><code></code></span>
<span class="codeline" id="line-188"><code>// skipSpace skips R over all spaces and returns the number of bytes skipped.</code></span>
<span class="codeline" id="line-189"><code>func (r *Reader) skipSpace() int {</code></span>
<span class="codeline" id="line-190"><code>	n := 0</code></span>
<span class="codeline" id="line-191"><code>	for {</code></span>
<span class="codeline" id="line-192"><code>		c, err := r.R.ReadByte()</code></span>
<span class="codeline" id="line-193"><code>		if err != nil {</code></span>
<span class="codeline" id="line-194"><code>			// Bufio will keep err until next read.</code></span>
<span class="codeline" id="line-195"><code>			break</code></span>
<span class="codeline" id="line-196"><code>		}</code></span>
<span class="codeline" id="line-197"><code>		if c != ' ' &amp;&amp; c != '\t' {</code></span>
<span class="codeline" id="line-198"><code>			r.R.UnreadByte()</code></span>
<span class="codeline" id="line-199"><code>			break</code></span>
<span class="codeline" id="line-200"><code>		}</code></span>
<span class="codeline" id="line-201"><code>		n++</code></span>
<span class="codeline" id="line-202"><code>	}</code></span>
<span class="codeline" id="line-203"><code>	return n</code></span>
<span class="codeline" id="line-204"><code>}</code></span>
<span class="codeline" id="line-205"><code></code></span>
<span class="codeline" id="line-206"><code>func (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) {</code></span>
<span class="codeline" id="line-207"><code>	line, err := r.ReadLine()</code></span>
<span class="codeline" id="line-208"><code>	if err != nil {</code></span>
<span class="codeline" id="line-209"><code>		return</code></span>
<span class="codeline" id="line-210"><code>	}</code></span>
<span class="codeline" id="line-211"><code>	return parseCodeLine(line, expectCode)</code></span>
<span class="codeline" id="line-212"><code>}</code></span>
<span class="codeline" id="line-213"><code></code></span>
<span class="codeline" id="line-214"><code>func parseCodeLine(line string, expectCode int) (code int, continued bool, message string, err error) {</code></span>
<span class="codeline" id="line-215"><code>	if len(line) &lt; 4 || line[3] != ' ' &amp;&amp; line[3] != '-' {</code></span>
<span class="codeline" id="line-216"><code>		err = ProtocolError("short response: " + line)</code></span>
<span class="codeline" id="line-217"><code>		return</code></span>
<span class="codeline" id="line-218"><code>	}</code></span>
<span class="codeline" id="line-219"><code>	continued = line[3] == '-'</code></span>
<span class="codeline" id="line-220"><code>	code, err = strconv.Atoi(line[0:3])</code></span>
<span class="codeline" id="line-221"><code>	if err != nil || code &lt; 100 {</code></span>
<span class="codeline" id="line-222"><code>		err = ProtocolError("invalid response code: " + line)</code></span>
<span class="codeline" id="line-223"><code>		return</code></span>
<span class="codeline" id="line-224"><code>	}</code></span>
<span class="codeline" id="line-225"><code>	message = line[4:]</code></span>
<span class="codeline" id="line-226"><code>	if 1 &lt;= expectCode &amp;&amp; expectCode &lt; 10 &amp;&amp; code/100 != expectCode ||</code></span>
<span class="codeline" id="line-227"><code>		10 &lt;= expectCode &amp;&amp; expectCode &lt; 100 &amp;&amp; code/10 != expectCode ||</code></span>
<span class="codeline" id="line-228"><code>		100 &lt;= expectCode &amp;&amp; expectCode &lt; 1000 &amp;&amp; code != expectCode {</code></span>
<span class="codeline" id="line-229"><code>		err = &amp;Error{code, message}</code></span>
<span class="codeline" id="line-230"><code>	}</code></span>
<span class="codeline" id="line-231"><code>	return</code></span>
<span class="codeline" id="line-232"><code>}</code></span>
<span class="codeline" id="line-233"><code></code></span>
<span class="codeline" id="line-234"><code>// ReadCodeLine reads a response code line of the form</code></span>
<span class="codeline" id="line-235"><code>//</code></span>
<span class="codeline" id="line-236"><code>//	code message</code></span>
<span class="codeline" id="line-237"><code>//</code></span>
<span class="codeline" id="line-238"><code>// where code is a three-digit status code and the message</code></span>
<span class="codeline" id="line-239"><code>// extends to the rest of the line. An example of such a line is:</code></span>
<span class="codeline" id="line-240"><code>//</code></span>
<span class="codeline" id="line-241"><code>//	220 plan9.bell-labs.com ESMTP</code></span>
<span class="codeline" id="line-242"><code>//</code></span>
<span class="codeline" id="line-243"><code>// If the prefix of the status does not match the digits in expectCode,</code></span>
<span class="codeline" id="line-244"><code>// ReadCodeLine returns with err set to &amp;Error{code, message}.</code></span>
<span class="codeline" id="line-245"><code>// For example, if expectCode is 31, an error will be returned if</code></span>
<span class="codeline" id="line-246"><code>// the status is not in the range [310,319].</code></span>
<span class="codeline" id="line-247"><code>//</code></span>
<span class="codeline" id="line-248"><code>// If the response is multi-line, ReadCodeLine returns an error.</code></span>
<span class="codeline" id="line-249"><code>//</code></span>
<span class="codeline" id="line-250"><code>// An expectCode &lt;= 0 disables the check of the status code.</code></span>
<span class="codeline" id="line-251"><code>func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error) {</code></span>
<span class="codeline" id="line-252"><code>	code, continued, message, err := r.readCodeLine(expectCode)</code></span>
<span class="codeline" id="line-253"><code>	if err == nil &amp;&amp; continued {</code></span>
<span class="codeline" id="line-254"><code>		err = ProtocolError("unexpected multi-line response: " + message)</code></span>
<span class="codeline" id="line-255"><code>	}</code></span>
<span class="codeline" id="line-256"><code>	return</code></span>
<span class="codeline" id="line-257"><code>}</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>// ReadResponse reads a multi-line response of the form:</code></span>
<span class="codeline" id="line-260"><code>//</code></span>
<span class="codeline" id="line-261"><code>//	code-message line 1</code></span>
<span class="codeline" id="line-262"><code>//	code-message line 2</code></span>
<span class="codeline" id="line-263"><code>//	...</code></span>
<span class="codeline" id="line-264"><code>//	code message line n</code></span>
<span class="codeline" id="line-265"><code>//</code></span>
<span class="codeline" id="line-266"><code>// where code is a three-digit status code. The first line starts with the</code></span>
<span class="codeline" id="line-267"><code>// code and a hyphen. The response is terminated by a line that starts</code></span>
<span class="codeline" id="line-268"><code>// with the same code followed by a space. Each line in message is</code></span>
<span class="codeline" id="line-269"><code>// separated by a newline (\n).</code></span>
<span class="codeline" id="line-270"><code>//</code></span>
<span class="codeline" id="line-271"><code>// See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for</code></span>
<span class="codeline" id="line-272"><code>// details of another form of response accepted:</code></span>
<span class="codeline" id="line-273"><code>//</code></span>
<span class="codeline" id="line-274"><code>//	code-message line 1</code></span>
<span class="codeline" id="line-275"><code>//	message line 2</code></span>
<span class="codeline" id="line-276"><code>//	...</code></span>
<span class="codeline" id="line-277"><code>//	code message line n</code></span>
<span class="codeline" id="line-278"><code>//</code></span>
<span class="codeline" id="line-279"><code>// If the prefix of the status does not match the digits in expectCode,</code></span>
<span class="codeline" id="line-280"><code>// ReadResponse returns with err set to &amp;Error{code, message}.</code></span>
<span class="codeline" id="line-281"><code>// For example, if expectCode is 31, an error will be returned if</code></span>
<span class="codeline" id="line-282"><code>// the status is not in the range [310,319].</code></span>
<span class="codeline" id="line-283"><code>//</code></span>
<span class="codeline" id="line-284"><code>// An expectCode &lt;= 0 disables the check of the status code.</code></span>
<span class="codeline" id="line-285"><code>func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error) {</code></span>
<span class="codeline" id="line-286"><code>	code, continued, message, err := r.readCodeLine(expectCode)</code></span>
<span class="codeline" id="line-287"><code>	multi := continued</code></span>
<span class="codeline" id="line-288"><code>	for continued {</code></span>
<span class="codeline" id="line-289"><code>		line, err := r.ReadLine()</code></span>
<span class="codeline" id="line-290"><code>		if err != nil {</code></span>
<span class="codeline" id="line-291"><code>			return 0, "", err</code></span>
<span class="codeline" id="line-292"><code>		}</code></span>
<span class="codeline" id="line-293"><code></code></span>
<span class="codeline" id="line-294"><code>		var code2 int</code></span>
<span class="codeline" id="line-295"><code>		var moreMessage string</code></span>
<span class="codeline" id="line-296"><code>		code2, continued, moreMessage, err = parseCodeLine(line, 0)</code></span>
<span class="codeline" id="line-297"><code>		if err != nil || code2 != code {</code></span>
<span class="codeline" id="line-298"><code>			message += "\n" + strings.TrimRight(line, "\r\n")</code></span>
<span class="codeline" id="line-299"><code>			continued = true</code></span>
<span class="codeline" id="line-300"><code>			continue</code></span>
<span class="codeline" id="line-301"><code>		}</code></span>
<span class="codeline" id="line-302"><code>		message += "\n" + moreMessage</code></span>
<span class="codeline" id="line-303"><code>	}</code></span>
<span class="codeline" id="line-304"><code>	if err != nil &amp;&amp; multi &amp;&amp; message != "" {</code></span>
<span class="codeline" id="line-305"><code>		// replace one line error message with all lines (full message)</code></span>
<span class="codeline" id="line-306"><code>		err = &amp;Error{code, message}</code></span>
<span class="codeline" id="line-307"><code>	}</code></span>
<span class="codeline" id="line-308"><code>	return</code></span>
<span class="codeline" id="line-309"><code>}</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>// DotReader returns a new [Reader] that satisfies Reads using the</code></span>
<span class="codeline" id="line-312"><code>// decoded text of a dot-encoded block read from r.</code></span>
<span class="codeline" id="line-313"><code>// The returned Reader is only valid until the next call</code></span>
<span class="codeline" id="line-314"><code>// to a method on r.</code></span>
<span class="codeline" id="line-315"><code>//</code></span>
<span class="codeline" id="line-316"><code>// Dot encoding is a common framing used for data blocks</code></span>
<span class="codeline" id="line-317"><code>// in text protocols such as SMTP.  The data consists of a sequence</code></span>
<span class="codeline" id="line-318"><code>// of lines, each of which ends in "\r\n".  The sequence itself</code></span>
<span class="codeline" id="line-319"><code>// ends at a line containing just a dot: ".\r\n".  Lines beginning</code></span>
<span class="codeline" id="line-320"><code>// with a dot are escaped with an additional dot to avoid</code></span>
<span class="codeline" id="line-321"><code>// looking like the end of the sequence.</code></span>
<span class="codeline" id="line-322"><code>//</code></span>
<span class="codeline" id="line-323"><code>// The decoded form returned by the Reader's Read method</code></span>
<span class="codeline" id="line-324"><code>// rewrites the "\r\n" line endings into the simpler "\n",</code></span>
<span class="codeline" id="line-325"><code>// removes leading dot escapes if present, and stops with error [io.EOF]</code></span>
<span class="codeline" id="line-326"><code>// after consuming (and discarding) the end-of-sequence line.</code></span>
<span class="codeline" id="line-327"><code>func (r *Reader) DotReader() io.Reader {</code></span>
<span class="codeline" id="line-328"><code>	r.closeDot()</code></span>
<span class="codeline" id="line-329"><code>	r.dot = &amp;dotReader{r: r}</code></span>
<span class="codeline" id="line-330"><code>	return r.dot</code></span>
<span class="codeline" id="line-331"><code>}</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code>type dotReader struct {</code></span>
<span class="codeline" id="line-334"><code>	r     *Reader</code></span>
<span class="codeline" id="line-335"><code>	state int</code></span>
<span class="codeline" id="line-336"><code>}</code></span>
<span class="codeline" id="line-337"><code></code></span>
<span class="codeline" id="line-338"><code>// Read satisfies reads by decoding dot-encoded data read from d.r.</code></span>
<span class="codeline" id="line-339"><code>func (d *dotReader) Read(b []byte) (n int, err error) {</code></span>
<span class="codeline" id="line-340"><code>	// Run data through a simple state machine to</code></span>
<span class="codeline" id="line-341"><code>	// elide leading dots, rewrite trailing \r\n into \n,</code></span>
<span class="codeline" id="line-342"><code>	// and detect ending .\r\n line.</code></span>
<span class="codeline" id="line-343"><code>	const (</code></span>
<span class="codeline" id="line-344"><code>		stateBeginLine = iota // beginning of line; initial state; must be zero</code></span>
<span class="codeline" id="line-345"><code>		stateDot              // read . at beginning of line</code></span>
<span class="codeline" id="line-346"><code>		stateDotCR            // read .\r at beginning of line</code></span>
<span class="codeline" id="line-347"><code>		stateCR               // read \r (possibly at end of line)</code></span>
<span class="codeline" id="line-348"><code>		stateData             // reading data in middle of line</code></span>
<span class="codeline" id="line-349"><code>		stateEOF              // reached .\r\n end marker line</code></span>
<span class="codeline" id="line-350"><code>	)</code></span>
<span class="codeline" id="line-351"><code>	br := d.r.R</code></span>
<span class="codeline" id="line-352"><code>	for n &lt; len(b) &amp;&amp; d.state != stateEOF {</code></span>
<span class="codeline" id="line-353"><code>		var c byte</code></span>
<span class="codeline" id="line-354"><code>		c, err = br.ReadByte()</code></span>
<span class="codeline" id="line-355"><code>		if err != nil {</code></span>
<span class="codeline" id="line-356"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-357"><code>				err = io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-358"><code>			}</code></span>
<span class="codeline" id="line-359"><code>			break</code></span>
<span class="codeline" id="line-360"><code>		}</code></span>
<span class="codeline" id="line-361"><code>		switch d.state {</code></span>
<span class="codeline" id="line-362"><code>		case stateBeginLine:</code></span>
<span class="codeline" id="line-363"><code>			if c == '.' {</code></span>
<span class="codeline" id="line-364"><code>				d.state = stateDot</code></span>
<span class="codeline" id="line-365"><code>				continue</code></span>
<span class="codeline" id="line-366"><code>			}</code></span>
<span class="codeline" id="line-367"><code>			if c == '\r' {</code></span>
<span class="codeline" id="line-368"><code>				d.state = stateCR</code></span>
<span class="codeline" id="line-369"><code>				continue</code></span>
<span class="codeline" id="line-370"><code>			}</code></span>
<span class="codeline" id="line-371"><code>			d.state = stateData</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>		case stateDot:</code></span>
<span class="codeline" id="line-374"><code>			if c == '\r' {</code></span>
<span class="codeline" id="line-375"><code>				d.state = stateDotCR</code></span>
<span class="codeline" id="line-376"><code>				continue</code></span>
<span class="codeline" id="line-377"><code>			}</code></span>
<span class="codeline" id="line-378"><code>			if c == '\n' {</code></span>
<span class="codeline" id="line-379"><code>				d.state = stateEOF</code></span>
<span class="codeline" id="line-380"><code>				continue</code></span>
<span class="codeline" id="line-381"><code>			}</code></span>
<span class="codeline" id="line-382"><code>			d.state = stateData</code></span>
<span class="codeline" id="line-383"><code></code></span>
<span class="codeline" id="line-384"><code>		case stateDotCR:</code></span>
<span class="codeline" id="line-385"><code>			if c == '\n' {</code></span>
<span class="codeline" id="line-386"><code>				d.state = stateEOF</code></span>
<span class="codeline" id="line-387"><code>				continue</code></span>
<span class="codeline" id="line-388"><code>			}</code></span>
<span class="codeline" id="line-389"><code>			// Not part of .\r\n.</code></span>
<span class="codeline" id="line-390"><code>			// Consume leading dot and emit saved \r.</code></span>
<span class="codeline" id="line-391"><code>			br.UnreadByte()</code></span>
<span class="codeline" id="line-392"><code>			c = '\r'</code></span>
<span class="codeline" id="line-393"><code>			d.state = stateData</code></span>
<span class="codeline" id="line-394"><code></code></span>
<span class="codeline" id="line-395"><code>		case stateCR:</code></span>
<span class="codeline" id="line-396"><code>			if c == '\n' {</code></span>
<span class="codeline" id="line-397"><code>				d.state = stateBeginLine</code></span>
<span class="codeline" id="line-398"><code>				break</code></span>
<span class="codeline" id="line-399"><code>			}</code></span>
<span class="codeline" id="line-400"><code>			// Not part of \r\n. Emit saved \r</code></span>
<span class="codeline" id="line-401"><code>			br.UnreadByte()</code></span>
<span class="codeline" id="line-402"><code>			c = '\r'</code></span>
<span class="codeline" id="line-403"><code>			d.state = stateData</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>		case stateData:</code></span>
<span class="codeline" id="line-406"><code>			if c == '\r' {</code></span>
<span class="codeline" id="line-407"><code>				d.state = stateCR</code></span>
<span class="codeline" id="line-408"><code>				continue</code></span>
<span class="codeline" id="line-409"><code>			}</code></span>
<span class="codeline" id="line-410"><code>			if c == '\n' {</code></span>
<span class="codeline" id="line-411"><code>				d.state = stateBeginLine</code></span>
<span class="codeline" id="line-412"><code>			}</code></span>
<span class="codeline" id="line-413"><code>		}</code></span>
<span class="codeline" id="line-414"><code>		b[n] = c</code></span>
<span class="codeline" id="line-415"><code>		n++</code></span>
<span class="codeline" id="line-416"><code>	}</code></span>
<span class="codeline" id="line-417"><code>	if err == nil &amp;&amp; d.state == stateEOF {</code></span>
<span class="codeline" id="line-418"><code>		err = io.EOF</code></span>
<span class="codeline" id="line-419"><code>	}</code></span>
<span class="codeline" id="line-420"><code>	if err != nil &amp;&amp; d.r.dot == d {</code></span>
<span class="codeline" id="line-421"><code>		d.r.dot = nil</code></span>
<span class="codeline" id="line-422"><code>	}</code></span>
<span class="codeline" id="line-423"><code>	return</code></span>
<span class="codeline" id="line-424"><code>}</code></span>
<span class="codeline" id="line-425"><code></code></span>
<span class="codeline" id="line-426"><code>// closeDot drains the current DotReader if any,</code></span>
<span class="codeline" id="line-427"><code>// making sure that it reads until the ending dot line.</code></span>
<span class="codeline" id="line-428"><code>func (r *Reader) closeDot() {</code></span>
<span class="codeline" id="line-429"><code>	if r.dot == nil {</code></span>
<span class="codeline" id="line-430"><code>		return</code></span>
<span class="codeline" id="line-431"><code>	}</code></span>
<span class="codeline" id="line-432"><code>	buf := make([]byte, 128)</code></span>
<span class="codeline" id="line-433"><code>	for r.dot != nil {</code></span>
<span class="codeline" id="line-434"><code>		// When Read reaches EOF or an error,</code></span>
<span class="codeline" id="line-435"><code>		// it will set r.dot == nil.</code></span>
<span class="codeline" id="line-436"><code>		r.dot.Read(buf)</code></span>
<span class="codeline" id="line-437"><code>	}</code></span>
<span class="codeline" id="line-438"><code>}</code></span>
<span class="codeline" id="line-439"><code></code></span>
<span class="codeline" id="line-440"><code>// ReadDotBytes reads a dot-encoding and returns the decoded data.</code></span>
<span class="codeline" id="line-441"><code>//</code></span>
<span class="codeline" id="line-442"><code>// See the documentation for the [Reader.DotReader] method for details about dot-encoding.</code></span>
<span class="codeline" id="line-443"><code>func (r *Reader) ReadDotBytes() ([]byte, error) {</code></span>
<span class="codeline" id="line-444"><code>	return io.ReadAll(r.DotReader())</code></span>
<span class="codeline" id="line-445"><code>}</code></span>
<span class="codeline" id="line-446"><code></code></span>
<span class="codeline" id="line-447"><code>// ReadDotLines reads a dot-encoding and returns a slice</code></span>
<span class="codeline" id="line-448"><code>// containing the decoded lines, with the final \r\n or \n elided from each.</code></span>
<span class="codeline" id="line-449"><code>//</code></span>
<span class="codeline" id="line-450"><code>// See the documentation for the [Reader.DotReader] method for details about dot-encoding.</code></span>
<span class="codeline" id="line-451"><code>func (r *Reader) ReadDotLines() ([]string, error) {</code></span>
<span class="codeline" id="line-452"><code>	// We could use ReadDotBytes and then Split it,</code></span>
<span class="codeline" id="line-453"><code>	// but reading a line at a time avoids needing a</code></span>
<span class="codeline" id="line-454"><code>	// large contiguous block of memory and is simpler.</code></span>
<span class="codeline" id="line-455"><code>	var v []string</code></span>
<span class="codeline" id="line-456"><code>	var err error</code></span>
<span class="codeline" id="line-457"><code>	for {</code></span>
<span class="codeline" id="line-458"><code>		var line string</code></span>
<span class="codeline" id="line-459"><code>		line, err = r.ReadLine()</code></span>
<span class="codeline" id="line-460"><code>		if err != nil {</code></span>
<span class="codeline" id="line-461"><code>			if err == io.EOF {</code></span>
<span class="codeline" id="line-462"><code>				err = io.ErrUnexpectedEOF</code></span>
<span class="codeline" id="line-463"><code>			}</code></span>
<span class="codeline" id="line-464"><code>			break</code></span>
<span class="codeline" id="line-465"><code>		}</code></span>
<span class="codeline" id="line-466"><code></code></span>
<span class="codeline" id="line-467"><code>		// Dot by itself marks end; otherwise cut one dot.</code></span>
<span class="codeline" id="line-468"><code>		if len(line) &gt; 0 &amp;&amp; line[0] == '.' {</code></span>
<span class="codeline" id="line-469"><code>			if len(line) == 1 {</code></span>
<span class="codeline" id="line-470"><code>				break</code></span>
<span class="codeline" id="line-471"><code>			}</code></span>
<span class="codeline" id="line-472"><code>			line = line[1:]</code></span>
<span class="codeline" id="line-473"><code>		}</code></span>
<span class="codeline" id="line-474"><code>		v = append(v, line)</code></span>
<span class="codeline" id="line-475"><code>	}</code></span>
<span class="codeline" id="line-476"><code>	return v, err</code></span>
<span class="codeline" id="line-477"><code>}</code></span>
<span class="codeline" id="line-478"><code></code></span>
<span class="codeline" id="line-479"><code>var colon = []byte(":")</code></span>
<span class="codeline" id="line-480"><code></code></span>
<span class="codeline" id="line-481"><code>// ReadMIMEHeader reads a MIME-style header from r.</code></span>
<span class="codeline" id="line-482"><code>// The header is a sequence of possibly continued Key: Value lines</code></span>
<span class="codeline" id="line-483"><code>// ending in a blank line.</code></span>
<span class="codeline" id="line-484"><code>// The returned map m maps [CanonicalMIMEHeaderKey](key) to a</code></span>
<span class="codeline" id="line-485"><code>// sequence of values in the same order encountered in the input.</code></span>
<span class="codeline" id="line-486"><code>//</code></span>
<span class="codeline" id="line-487"><code>// For example, consider this input:</code></span>
<span class="codeline" id="line-488"><code>//</code></span>
<span class="codeline" id="line-489"><code>//	My-Key: Value 1</code></span>
<span class="codeline" id="line-490"><code>//	Long-Key: Even</code></span>
<span class="codeline" id="line-491"><code>//	       Longer Value</code></span>
<span class="codeline" id="line-492"><code>//	My-Key: Value 2</code></span>
<span class="codeline" id="line-493"><code>//</code></span>
<span class="codeline" id="line-494"><code>// Given that input, ReadMIMEHeader returns the map:</code></span>
<span class="codeline" id="line-495"><code>//</code></span>
<span class="codeline" id="line-496"><code>//	map[string][]string{</code></span>
<span class="codeline" id="line-497"><code>//		"My-Key": {"Value 1", "Value 2"},</code></span>
<span class="codeline" id="line-498"><code>//		"Long-Key": {"Even Longer Value"},</code></span>
<span class="codeline" id="line-499"><code>//	}</code></span>
<span class="codeline" id="line-500"><code>func (r *Reader) ReadMIMEHeader() (MIMEHeader, error) {</code></span>
<span class="codeline" id="line-501"><code>	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)</code></span>
<span class="codeline" id="line-502"><code>}</code></span>
<span class="codeline" id="line-503"><code></code></span>
<span class="codeline" id="line-504"><code>// readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.</code></span>
<span class="codeline" id="line-505"><code>// It is called by the mime/multipart package.</code></span>
<span class="codeline" id="line-506"><code>func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {</code></span>
<span class="codeline" id="line-507"><code>	// Avoid lots of small slice allocations later by allocating one</code></span>
<span class="codeline" id="line-508"><code>	// large one ahead of time which we'll cut up into smaller</code></span>
<span class="codeline" id="line-509"><code>	// slices. If this isn't big enough later, we allocate small ones.</code></span>
<span class="codeline" id="line-510"><code>	var strs []string</code></span>
<span class="codeline" id="line-511"><code>	hint := r.upcomingHeaderKeys()</code></span>
<span class="codeline" id="line-512"><code>	if hint &gt; 0 {</code></span>
<span class="codeline" id="line-513"><code>		if hint &gt; 1000 {</code></span>
<span class="codeline" id="line-514"><code>			hint = 1000 // set a cap to avoid overallocation</code></span>
<span class="codeline" id="line-515"><code>		}</code></span>
<span class="codeline" id="line-516"><code>		strs = make([]string, hint)</code></span>
<span class="codeline" id="line-517"><code>	}</code></span>
<span class="codeline" id="line-518"><code></code></span>
<span class="codeline" id="line-519"><code>	m := make(MIMEHeader, hint)</code></span>
<span class="codeline" id="line-520"><code></code></span>
<span class="codeline" id="line-521"><code>	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.</code></span>
<span class="codeline" id="line-522"><code>	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large</code></span>
<span class="codeline" id="line-523"><code>	// MIMEHeaders average about 200 bytes per entry.</code></span>
<span class="codeline" id="line-524"><code>	maxMemory -= 400</code></span>
<span class="codeline" id="line-525"><code>	const mapEntryOverhead = 200</code></span>
<span class="codeline" id="line-526"><code></code></span>
<span class="codeline" id="line-527"><code>	// The first line cannot start with a leading space.</code></span>
<span class="codeline" id="line-528"><code>	if buf, err := r.R.Peek(1); err == nil &amp;&amp; (buf[0] == ' ' || buf[0] == '\t') {</code></span>
<span class="codeline" id="line-529"><code>		const errorLimit = 80 // arbitrary limit on how much of the line we'll quote</code></span>
<span class="codeline" id="line-530"><code>		line, err := r.readLineSlice(errorLimit)</code></span>
<span class="codeline" id="line-531"><code>		if err != nil {</code></span>
<span class="codeline" id="line-532"><code>			return m, err</code></span>
<span class="codeline" id="line-533"><code>		}</code></span>
<span class="codeline" id="line-534"><code>		return m, ProtocolError("malformed MIME header initial line: " + string(line))</code></span>
<span class="codeline" id="line-535"><code>	}</code></span>
<span class="codeline" id="line-536"><code></code></span>
<span class="codeline" id="line-537"><code>	for {</code></span>
<span class="codeline" id="line-538"><code>		kv, err := r.readContinuedLineSlice(maxMemory, mustHaveFieldNameColon)</code></span>
<span class="codeline" id="line-539"><code>		if len(kv) == 0 {</code></span>
<span class="codeline" id="line-540"><code>			return m, err</code></span>
<span class="codeline" id="line-541"><code>		}</code></span>
<span class="codeline" id="line-542"><code></code></span>
<span class="codeline" id="line-543"><code>		// Key ends at first colon.</code></span>
<span class="codeline" id="line-544"><code>		k, v, ok := bytes.Cut(kv, colon)</code></span>
<span class="codeline" id="line-545"><code>		if !ok {</code></span>
<span class="codeline" id="line-546"><code>			return m, ProtocolError("malformed MIME header line: " + string(kv))</code></span>
<span class="codeline" id="line-547"><code>		}</code></span>
<span class="codeline" id="line-548"><code>		key, ok := canonicalMIMEHeaderKey(k)</code></span>
<span class="codeline" id="line-549"><code>		if !ok {</code></span>
<span class="codeline" id="line-550"><code>			return m, ProtocolError("malformed MIME header line: " + string(kv))</code></span>
<span class="codeline" id="line-551"><code>		}</code></span>
<span class="codeline" id="line-552"><code>		for _, c := range v {</code></span>
<span class="codeline" id="line-553"><code>			if !validHeaderValueByte(c) {</code></span>
<span class="codeline" id="line-554"><code>				return m, ProtocolError("malformed MIME header line: " + string(kv))</code></span>
<span class="codeline" id="line-555"><code>			}</code></span>
<span class="codeline" id="line-556"><code>		}</code></span>
<span class="codeline" id="line-557"><code></code></span>
<span class="codeline" id="line-558"><code>		// As per RFC 7230 field-name is a token, tokens consist of one or more chars.</code></span>
<span class="codeline" id="line-559"><code>		// We could return a ProtocolError here, but better to be liberal in what we</code></span>
<span class="codeline" id="line-560"><code>		// accept, so if we get an empty key, skip it.</code></span>
<span class="codeline" id="line-561"><code>		if key == "" {</code></span>
<span class="codeline" id="line-562"><code>			continue</code></span>
<span class="codeline" id="line-563"><code>		}</code></span>
<span class="codeline" id="line-564"><code></code></span>
<span class="codeline" id="line-565"><code>		maxHeaders--</code></span>
<span class="codeline" id="line-566"><code>		if maxHeaders &lt; 0 {</code></span>
<span class="codeline" id="line-567"><code>			return nil, errMessageTooLarge</code></span>
<span class="codeline" id="line-568"><code>		}</code></span>
<span class="codeline" id="line-569"><code></code></span>
<span class="codeline" id="line-570"><code>		// Skip initial spaces in value.</code></span>
<span class="codeline" id="line-571"><code>		value := string(bytes.TrimLeft(v, " \t"))</code></span>
<span class="codeline" id="line-572"><code></code></span>
<span class="codeline" id="line-573"><code>		vv := m[key]</code></span>
<span class="codeline" id="line-574"><code>		if vv == nil {</code></span>
<span class="codeline" id="line-575"><code>			maxMemory -= int64(len(key))</code></span>
<span class="codeline" id="line-576"><code>			maxMemory -= mapEntryOverhead</code></span>
<span class="codeline" id="line-577"><code>		}</code></span>
<span class="codeline" id="line-578"><code>		maxMemory -= int64(len(value))</code></span>
<span class="codeline" id="line-579"><code>		if maxMemory &lt; 0 {</code></span>
<span class="codeline" id="line-580"><code>			return m, errMessageTooLarge</code></span>
<span class="codeline" id="line-581"><code>		}</code></span>
<span class="codeline" id="line-582"><code>		if vv == nil &amp;&amp; len(strs) &gt; 0 {</code></span>
<span class="codeline" id="line-583"><code>			// More than likely this will be a single-element key.</code></span>
<span class="codeline" id="line-584"><code>			// Most headers aren't multi-valued.</code></span>
<span class="codeline" id="line-585"><code>			// Set the capacity on strs[0] to 1, so any future append</code></span>
<span class="codeline" id="line-586"><code>			// won't extend the slice into the other strings.</code></span>
<span class="codeline" id="line-587"><code>			vv, strs = strs[:1:1], strs[1:]</code></span>
<span class="codeline" id="line-588"><code>			vv[0] = value</code></span>
<span class="codeline" id="line-589"><code>			m[key] = vv</code></span>
<span class="codeline" id="line-590"><code>		} else {</code></span>
<span class="codeline" id="line-591"><code>			m[key] = append(vv, value)</code></span>
<span class="codeline" id="line-592"><code>		}</code></span>
<span class="codeline" id="line-593"><code></code></span>
<span class="codeline" id="line-594"><code>		if err != nil {</code></span>
<span class="codeline" id="line-595"><code>			return m, err</code></span>
<span class="codeline" id="line-596"><code>		}</code></span>
<span class="codeline" id="line-597"><code>	}</code></span>
<span class="codeline" id="line-598"><code>}</code></span>
<span class="codeline" id="line-599"><code></code></span>
<span class="codeline" id="line-600"><code>// noValidation is a no-op validation func for readContinuedLineSlice</code></span>
<span class="codeline" id="line-601"><code>// that permits any lines.</code></span>
<span class="codeline" id="line-602"><code>func noValidation(_ []byte) error { return nil }</code></span>
<span class="codeline" id="line-603"><code></code></span>
<span class="codeline" id="line-604"><code>// mustHaveFieldNameColon ensures that, per RFC 7230, the</code></span>
<span class="codeline" id="line-605"><code>// field-name is on a single line, so the first line must</code></span>
<span class="codeline" id="line-606"><code>// contain a colon.</code></span>
<span class="codeline" id="line-607"><code>func mustHaveFieldNameColon(line []byte) error {</code></span>
<span class="codeline" id="line-608"><code>	if bytes.IndexByte(line, ':') &lt; 0 {</code></span>
<span class="codeline" id="line-609"><code>		return ProtocolError(fmt.Sprintf("malformed MIME header: missing colon: %q", line))</code></span>
<span class="codeline" id="line-610"><code>	}</code></span>
<span class="codeline" id="line-611"><code>	return nil</code></span>
<span class="codeline" id="line-612"><code>}</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>var nl = []byte("\n")</code></span>
<span class="codeline" id="line-615"><code></code></span>
<span class="codeline" id="line-616"><code>// upcomingHeaderKeys returns an approximation of the number of keys</code></span>
<span class="codeline" id="line-617"><code>// that will be in this header. If it gets confused, it returns 0.</code></span>
<span class="codeline" id="line-618"><code>func (r *Reader) upcomingHeaderKeys() (n int) {</code></span>
<span class="codeline" id="line-619"><code>	// Try to determine the 'hint' size.</code></span>
<span class="codeline" id="line-620"><code>	r.R.Peek(1) // force a buffer load if empty</code></span>
<span class="codeline" id="line-621"><code>	s := r.R.Buffered()</code></span>
<span class="codeline" id="line-622"><code>	if s == 0 {</code></span>
<span class="codeline" id="line-623"><code>		return</code></span>
<span class="codeline" id="line-624"><code>	}</code></span>
<span class="codeline" id="line-625"><code>	peek, _ := r.R.Peek(s)</code></span>
<span class="codeline" id="line-626"><code>	for len(peek) &gt; 0 &amp;&amp; n &lt; 1000 {</code></span>
<span class="codeline" id="line-627"><code>		var line []byte</code></span>
<span class="codeline" id="line-628"><code>		line, peek, _ = bytes.Cut(peek, nl)</code></span>
<span class="codeline" id="line-629"><code>		if len(line) == 0 || (len(line) == 1 &amp;&amp; line[0] == '\r') {</code></span>
<span class="codeline" id="line-630"><code>			// Blank line separating headers from the body.</code></span>
<span class="codeline" id="line-631"><code>			break</code></span>
<span class="codeline" id="line-632"><code>		}</code></span>
<span class="codeline" id="line-633"><code>		if line[0] == ' ' || line[0] == '\t' {</code></span>
<span class="codeline" id="line-634"><code>			// Folded continuation of the previous line.</code></span>
<span class="codeline" id="line-635"><code>			continue</code></span>
<span class="codeline" id="line-636"><code>		}</code></span>
<span class="codeline" id="line-637"><code>		n++</code></span>
<span class="codeline" id="line-638"><code>	}</code></span>
<span class="codeline" id="line-639"><code>	return n</code></span>
<span class="codeline" id="line-640"><code>}</code></span>
<span class="codeline" id="line-641"><code></code></span>
<span class="codeline" id="line-642"><code>// CanonicalMIMEHeaderKey returns the canonical format of the</code></span>
<span class="codeline" id="line-643"><code>// MIME header key s. The canonicalization converts the first</code></span>
<span class="codeline" id="line-644"><code>// letter and any letter following a hyphen to upper case;</code></span>
<span class="codeline" id="line-645"><code>// the rest are converted to lowercase. For example, the</code></span>
<span class="codeline" id="line-646"><code>// canonical key for "accept-encoding" is "Accept-Encoding".</code></span>
<span class="codeline" id="line-647"><code>// MIME header keys are assumed to be ASCII only.</code></span>
<span class="codeline" id="line-648"><code>// If s contains a space or invalid header field bytes, it is</code></span>
<span class="codeline" id="line-649"><code>// returned without modifications.</code></span>
<span class="codeline" id="line-650"><code>func CanonicalMIMEHeaderKey(s string) string {</code></span>
<span class="codeline" id="line-651"><code>	// Quick check for canonical encoding.</code></span>
<span class="codeline" id="line-652"><code>	upper := true</code></span>
<span class="codeline" id="line-653"><code>	for i := 0; i &lt; len(s); i++ {</code></span>
<span class="codeline" id="line-654"><code>		c := s[i]</code></span>
<span class="codeline" id="line-655"><code>		if !validHeaderFieldByte(c) {</code></span>
<span class="codeline" id="line-656"><code>			return s</code></span>
<span class="codeline" id="line-657"><code>		}</code></span>
<span class="codeline" id="line-658"><code>		if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' {</code></span>
<span class="codeline" id="line-659"><code>			s, _ = canonicalMIMEHeaderKey([]byte(s))</code></span>
<span class="codeline" id="line-660"><code>			return s</code></span>
<span class="codeline" id="line-661"><code>		}</code></span>
<span class="codeline" id="line-662"><code>		if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-663"><code>			s, _ = canonicalMIMEHeaderKey([]byte(s))</code></span>
<span class="codeline" id="line-664"><code>			return s</code></span>
<span class="codeline" id="line-665"><code>		}</code></span>
<span class="codeline" id="line-666"><code>		upper = c == '-'</code></span>
<span class="codeline" id="line-667"><code>	}</code></span>
<span class="codeline" id="line-668"><code>	return s</code></span>
<span class="codeline" id="line-669"><code>}</code></span>
<span class="codeline" id="line-670"><code></code></span>
<span class="codeline" id="line-671"><code>const toLower = 'a' - 'A'</code></span>
<span class="codeline" id="line-672"><code></code></span>
<span class="codeline" id="line-673"><code>// validHeaderFieldByte reports whether c is a valid byte in a header</code></span>
<span class="codeline" id="line-674"><code>// field name. RFC 7230 says:</code></span>
<span class="codeline" id="line-675"><code>//</code></span>
<span class="codeline" id="line-676"><code>//	header-field   = field-name ":" OWS field-value OWS</code></span>
<span class="codeline" id="line-677"><code>//	field-name     = token</code></span>
<span class="codeline" id="line-678"><code>//	tchar = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*" / "+" / "-" / "." /</code></span>
<span class="codeline" id="line-679"><code>//	        "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA</code></span>
<span class="codeline" id="line-680"><code>//	token = 1*tchar</code></span>
<span class="codeline" id="line-681"><code>func validHeaderFieldByte(c byte) bool {</code></span>
<span class="codeline" id="line-682"><code>	// mask is a 128-bit bitmap with 1s for allowed bytes,</code></span>
<span class="codeline" id="line-683"><code>	// so that the byte c can be tested with a shift and an and.</code></span>
<span class="codeline" id="line-684"><code>	// If c &gt;= 128, then 1&lt;&lt;c and 1&lt;&lt;(c-64) will both be zero,</code></span>
<span class="codeline" id="line-685"><code>	// and this function will return false.</code></span>
<span class="codeline" id="line-686"><code>	const mask = 0 |</code></span>
<span class="codeline" id="line-687"><code>		(1&lt;&lt;(10)-1)&lt;&lt;'0' |</code></span>
<span class="codeline" id="line-688"><code>		(1&lt;&lt;(26)-1)&lt;&lt;'a' |</code></span>
<span class="codeline" id="line-689"><code>		(1&lt;&lt;(26)-1)&lt;&lt;'A' |</code></span>
<span class="codeline" id="line-690"><code>		1&lt;&lt;'!' |</code></span>
<span class="codeline" id="line-691"><code>		1&lt;&lt;'#' |</code></span>
<span class="codeline" id="line-692"><code>		1&lt;&lt;'$' |</code></span>
<span class="codeline" id="line-693"><code>		1&lt;&lt;'%' |</code></span>
<span class="codeline" id="line-694"><code>		1&lt;&lt;'&amp;' |</code></span>
<span class="codeline" id="line-695"><code>		1&lt;&lt;'\'' |</code></span>
<span class="codeline" id="line-696"><code>		1&lt;&lt;'*' |</code></span>
<span class="codeline" id="line-697"><code>		1&lt;&lt;'+' |</code></span>
<span class="codeline" id="line-698"><code>		1&lt;&lt;'-' |</code></span>
<span class="codeline" id="line-699"><code>		1&lt;&lt;'.' |</code></span>
<span class="codeline" id="line-700"><code>		1&lt;&lt;'^' |</code></span>
<span class="codeline" id="line-701"><code>		1&lt;&lt;'_' |</code></span>
<span class="codeline" id="line-702"><code>		1&lt;&lt;'`' |</code></span>
<span class="codeline" id="line-703"><code>		1&lt;&lt;'|' |</code></span>
<span class="codeline" id="line-704"><code>		1&lt;&lt;'~'</code></span>
<span class="codeline" id="line-705"><code>	return ((uint64(1)&lt;&lt;c)&amp;(mask&amp;(1&lt;&lt;64-1)) |</code></span>
<span class="codeline" id="line-706"><code>		(uint64(1)&lt;&lt;(c-64))&amp;(mask&gt;&gt;64)) != 0</code></span>
<span class="codeline" id="line-707"><code>}</code></span>
<span class="codeline" id="line-708"><code></code></span>
<span class="codeline" id="line-709"><code>// validHeaderValueByte reports whether c is a valid byte in a header</code></span>
<span class="codeline" id="line-710"><code>// field value. RFC 7230 says:</code></span>
<span class="codeline" id="line-711"><code>//</code></span>
<span class="codeline" id="line-712"><code>//	field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]</code></span>
<span class="codeline" id="line-713"><code>//	field-vchar    = VCHAR / obs-text</code></span>
<span class="codeline" id="line-714"><code>//	obs-text       = %x80-FF</code></span>
<span class="codeline" id="line-715"><code>//</code></span>
<span class="codeline" id="line-716"><code>// RFC 5234 says:</code></span>
<span class="codeline" id="line-717"><code>//</code></span>
<span class="codeline" id="line-718"><code>//	HTAB           =  %x09</code></span>
<span class="codeline" id="line-719"><code>//	SP             =  %x20</code></span>
<span class="codeline" id="line-720"><code>//	VCHAR          =  %x21-7E</code></span>
<span class="codeline" id="line-721"><code>func validHeaderValueByte(c byte) bool {</code></span>
<span class="codeline" id="line-722"><code>	// mask is a 128-bit bitmap with 1s for allowed bytes,</code></span>
<span class="codeline" id="line-723"><code>	// so that the byte c can be tested with a shift and an and.</code></span>
<span class="codeline" id="line-724"><code>	// If c &gt;= 128, then 1&lt;&lt;c and 1&lt;&lt;(c-64) will both be zero.</code></span>
<span class="codeline" id="line-725"><code>	// Since this is the obs-text range, we invert the mask to</code></span>
<span class="codeline" id="line-726"><code>	// create a bitmap with 1s for disallowed bytes.</code></span>
<span class="codeline" id="line-727"><code>	const mask = 0 |</code></span>
<span class="codeline" id="line-728"><code>		(1&lt;&lt;(0x7f-0x21)-1)&lt;&lt;0x21 | // VCHAR: %x21-7E</code></span>
<span class="codeline" id="line-729"><code>		1&lt;&lt;0x20 | // SP: %x20</code></span>
<span class="codeline" id="line-730"><code>		1&lt;&lt;0x09 // HTAB: %x09</code></span>
<span class="codeline" id="line-731"><code>	return ((uint64(1)&lt;&lt;c)&amp;^(mask&amp;(1&lt;&lt;64-1)) |</code></span>
<span class="codeline" id="line-732"><code>		(uint64(1)&lt;&lt;(c-64))&amp;^(mask&gt;&gt;64)) == 0</code></span>
<span class="codeline" id="line-733"><code>}</code></span>
<span class="codeline" id="line-734"><code></code></span>
<span class="codeline" id="line-735"><code>// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is</code></span>
<span class="codeline" id="line-736"><code>// allowed to mutate the provided byte slice before returning the</code></span>
<span class="codeline" id="line-737"><code>// string.</code></span>
<span class="codeline" id="line-738"><code>//</code></span>
<span class="codeline" id="line-739"><code>// For invalid inputs (if a contains spaces or non-token bytes), a</code></span>
<span class="codeline" id="line-740"><code>// is unchanged and a string copy is returned.</code></span>
<span class="codeline" id="line-741"><code>//</code></span>
<span class="codeline" id="line-742"><code>// ok is true if the header key contains only valid characters and spaces.</code></span>
<span class="codeline" id="line-743"><code>// ReadMIMEHeader accepts header keys containing spaces, but does not</code></span>
<span class="codeline" id="line-744"><code>// canonicalize them.</code></span>
<span class="codeline" id="line-745"><code>func canonicalMIMEHeaderKey(a []byte) (_ string, ok bool) {</code></span>
<span class="codeline" id="line-746"><code>	// See if a looks like a header key. If not, return it unchanged.</code></span>
<span class="codeline" id="line-747"><code>	noCanon := false</code></span>
<span class="codeline" id="line-748"><code>	for _, c := range a {</code></span>
<span class="codeline" id="line-749"><code>		if validHeaderFieldByte(c) {</code></span>
<span class="codeline" id="line-750"><code>			continue</code></span>
<span class="codeline" id="line-751"><code>		}</code></span>
<span class="codeline" id="line-752"><code>		// Don't canonicalize.</code></span>
<span class="codeline" id="line-753"><code>		if c == ' ' {</code></span>
<span class="codeline" id="line-754"><code>			// We accept invalid headers with a space before the</code></span>
<span class="codeline" id="line-755"><code>			// colon, but must not canonicalize them.</code></span>
<span class="codeline" id="line-756"><code>			// See https://go.dev/issue/34540.</code></span>
<span class="codeline" id="line-757"><code>			noCanon = true</code></span>
<span class="codeline" id="line-758"><code>			continue</code></span>
<span class="codeline" id="line-759"><code>		}</code></span>
<span class="codeline" id="line-760"><code>		return string(a), false</code></span>
<span class="codeline" id="line-761"><code>	}</code></span>
<span class="codeline" id="line-762"><code>	if noCanon {</code></span>
<span class="codeline" id="line-763"><code>		return string(a), true</code></span>
<span class="codeline" id="line-764"><code>	}</code></span>
<span class="codeline" id="line-765"><code></code></span>
<span class="codeline" id="line-766"><code>	upper := true</code></span>
<span class="codeline" id="line-767"><code>	for i, c := range a {</code></span>
<span class="codeline" id="line-768"><code>		// Canonicalize: first letter upper case</code></span>
<span class="codeline" id="line-769"><code>		// and upper case after each dash.</code></span>
<span class="codeline" id="line-770"><code>		// (Host, User-Agent, If-Modified-Since).</code></span>
<span class="codeline" id="line-771"><code>		// MIME headers are ASCII only, so no Unicode issues.</code></span>
<span class="codeline" id="line-772"><code>		if upper &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z' {</code></span>
<span class="codeline" id="line-773"><code>			c -= toLower</code></span>
<span class="codeline" id="line-774"><code>		} else if !upper &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z' {</code></span>
<span class="codeline" id="line-775"><code>			c += toLower</code></span>
<span class="codeline" id="line-776"><code>		}</code></span>
<span class="codeline" id="line-777"><code>		a[i] = c</code></span>
<span class="codeline" id="line-778"><code>		upper = c == '-' // for next time</code></span>
<span class="codeline" id="line-779"><code>	}</code></span>
<span class="codeline" id="line-780"><code>	commonHeaderOnce.Do(initCommonHeader)</code></span>
<span class="codeline" id="line-781"><code>	// The compiler recognizes m[string(byteSlice)] as a special</code></span>
<span class="codeline" id="line-782"><code>	// case, so a copy of a's bytes into a new string does not</code></span>
<span class="codeline" id="line-783"><code>	// happen in this map lookup:</code></span>
<span class="codeline" id="line-784"><code>	if v := commonHeader[string(a)]; v != "" {</code></span>
<span class="codeline" id="line-785"><code>		return v, true</code></span>
<span class="codeline" id="line-786"><code>	}</code></span>
<span class="codeline" id="line-787"><code>	return string(a), true</code></span>
<span class="codeline" id="line-788"><code>}</code></span>
<span class="codeline" id="line-789"><code></code></span>
<span class="codeline" id="line-790"><code>// commonHeader interns common header strings.</code></span>
<span class="codeline" id="line-791"><code>var commonHeader map[string]string</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>var commonHeaderOnce sync.Once</code></span>
<span class="codeline" id="line-794"><code></code></span>
<span class="codeline" id="line-795"><code>func initCommonHeader() {</code></span>
<span class="codeline" id="line-796"><code>	commonHeader = make(map[string]string)</code></span>
<span class="codeline" id="line-797"><code>	for _, v := range []string{</code></span>
<span class="codeline" id="line-798"><code>		"Accept",</code></span>
<span class="codeline" id="line-799"><code>		"Accept-Charset",</code></span>
<span class="codeline" id="line-800"><code>		"Accept-Encoding",</code></span>
<span class="codeline" id="line-801"><code>		"Accept-Language",</code></span>
<span class="codeline" id="line-802"><code>		"Accept-Ranges",</code></span>
<span class="codeline" id="line-803"><code>		"Cache-Control",</code></span>
<span class="codeline" id="line-804"><code>		"Cc",</code></span>
<span class="codeline" id="line-805"><code>		"Connection",</code></span>
<span class="codeline" id="line-806"><code>		"Content-Id",</code></span>
<span class="codeline" id="line-807"><code>		"Content-Language",</code></span>
<span class="codeline" id="line-808"><code>		"Content-Length",</code></span>
<span class="codeline" id="line-809"><code>		"Content-Transfer-Encoding",</code></span>
<span class="codeline" id="line-810"><code>		"Content-Type",</code></span>
<span class="codeline" id="line-811"><code>		"Cookie",</code></span>
<span class="codeline" id="line-812"><code>		"Date",</code></span>
<span class="codeline" id="line-813"><code>		"Dkim-Signature",</code></span>
<span class="codeline" id="line-814"><code>		"Etag",</code></span>
<span class="codeline" id="line-815"><code>		"Expires",</code></span>
<span class="codeline" id="line-816"><code>		"From",</code></span>
<span class="codeline" id="line-817"><code>		"Host",</code></span>
<span class="codeline" id="line-818"><code>		"If-Modified-Since",</code></span>
<span class="codeline" id="line-819"><code>		"If-None-Match",</code></span>
<span class="codeline" id="line-820"><code>		"In-Reply-To",</code></span>
<span class="codeline" id="line-821"><code>		"Last-Modified",</code></span>
<span class="codeline" id="line-822"><code>		"Location",</code></span>
<span class="codeline" id="line-823"><code>		"Message-Id",</code></span>
<span class="codeline" id="line-824"><code>		"Mime-Version",</code></span>
<span class="codeline" id="line-825"><code>		"Pragma",</code></span>
<span class="codeline" id="line-826"><code>		"Received",</code></span>
<span class="codeline" id="line-827"><code>		"Return-Path",</code></span>
<span class="codeline" id="line-828"><code>		"Server",</code></span>
<span class="codeline" id="line-829"><code>		"Set-Cookie",</code></span>
<span class="codeline" id="line-830"><code>		"Subject",</code></span>
<span class="codeline" id="line-831"><code>		"To",</code></span>
<span class="codeline" id="line-832"><code>		"User-Agent",</code></span>
<span class="codeline" id="line-833"><code>		"Via",</code></span>
<span class="codeline" id="line-834"><code>		"X-Forwarded-For",</code></span>
<span class="codeline" id="line-835"><code>		"X-Imforwards",</code></span>
<span class="codeline" id="line-836"><code>		"X-Powered-By",</code></span>
<span class="codeline" id="line-837"><code>	} {</code></span>
<span class="codeline" id="line-838"><code>		commonHeader[v] = v</code></span>
<span class="codeline" id="line-839"><code>	}</code></span>
<span class="codeline" id="line-840"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>