<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: message.go in package net/mail</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	message.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/net/mail.html">net/mail</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2011 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code>Package mail implements parsing of mail messages.</code></span>
<span class="codeline" id="line-7"><code></code></span>
<span class="codeline" id="line-8"><code>For the most part, this package follows the syntax as specified by RFC 5322 and</code></span>
<span class="codeline" id="line-9"><code>extended by RFC 6532.</code></span>
<span class="codeline" id="line-10"><code>Notable divergences:</code></span>
<span class="codeline" id="line-11"><code>  - Obsolete address formats are not parsed, including addresses with</code></span>
<span class="codeline" id="line-12"><code>    embedded route information.</code></span>
<span class="codeline" id="line-13"><code>  - The full range of spacing (the CFWS syntax element) is not supported,</code></span>
<span class="codeline" id="line-14"><code>    such as breaking addresses across lines.</code></span>
<span class="codeline" id="line-15"><code>  - No unicode normalization is performed.</code></span>
<span class="codeline" id="line-16"><code>  - The special characters ()[]:;@\, are allowed to appear unquoted in names.</code></span>
<span class="codeline" id="line-17"><code>  - A leading From line is permitted, as in mbox format (RFC 4155).</code></span>
<span class="codeline" id="line-18"><code>*/</code></span></div><span class="codeline" id="line-19"><code>package mail</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>import (</code></span>
<span class="codeline" id="line-22"><code>	"bufio"</code></span>
<span class="codeline" id="line-23"><code>	"errors"</code></span>
<span class="codeline" id="line-24"><code>	"fmt"</code></span>
<span class="codeline" id="line-25"><code>	"io"</code></span>
<span class="codeline" id="line-26"><code>	"log"</code></span>
<span class="codeline" id="line-27"><code>	"mime"</code></span>
<span class="codeline" id="line-28"><code>	"net/textproto"</code></span>
<span class="codeline" id="line-29"><code>	"strings"</code></span>
<span class="codeline" id="line-30"><code>	"sync"</code></span>
<span class="codeline" id="line-31"><code>	"time"</code></span>
<span class="codeline" id="line-32"><code>	"unicode/utf8"</code></span>
<span class="codeline" id="line-33"><code>)</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>var debug = debugT(false)</code></span>
<span class="codeline" id="line-36"><code></code></span>
<span class="codeline" id="line-37"><code>type debugT bool</code></span>
<span class="codeline" id="line-38"><code></code></span>
<span class="codeline" id="line-39"><code>func (d debugT) Printf(format string, args ...any) {</code></span>
<span class="codeline" id="line-40"><code>	if d {</code></span>
<span class="codeline" id="line-41"><code>		log.Printf(format, args...)</code></span>
<span class="codeline" id="line-42"><code>	}</code></span>
<span class="codeline" id="line-43"><code>}</code></span>
<span class="codeline" id="line-44"><code></code></span>
<span class="codeline" id="line-45"><code>// A Message represents a parsed mail message.</code></span>
<span class="codeline" id="line-46"><code>type Message struct {</code></span>
<span class="codeline" id="line-47"><code>	Header Header</code></span>
<span class="codeline" id="line-48"><code>	Body   io.Reader</code></span>
<span class="codeline" id="line-49"><code>}</code></span>
<span class="codeline" id="line-50"><code></code></span>
<span class="codeline" id="line-51"><code>// ReadMessage reads a message from r.</code></span>
<span class="codeline" id="line-52"><code>// The headers are parsed, and the body of the message will be available</code></span>
<span class="codeline" id="line-53"><code>// for reading from msg.Body.</code></span>
<span class="codeline" id="line-54"><code>func ReadMessage(r io.Reader) (msg *Message, err error) {</code></span>
<span class="codeline" id="line-55"><code>	tp := textproto.NewReader(bufio.NewReader(r))</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>	hdr, err := readHeader(tp)</code></span>
<span class="codeline" id="line-58"><code>	if err != nil &amp;&amp; (err != io.EOF || len(hdr) == 0) {</code></span>
<span class="codeline" id="line-59"><code>		return nil, err</code></span>
<span class="codeline" id="line-60"><code>	}</code></span>
<span class="codeline" id="line-61"><code></code></span>
<span class="codeline" id="line-62"><code>	return &amp;Message{</code></span>
<span class="codeline" id="line-63"><code>		Header: Header(hdr),</code></span>
<span class="codeline" id="line-64"><code>		Body:   tp.R,</code></span>
<span class="codeline" id="line-65"><code>	}, nil</code></span>
<span class="codeline" id="line-66"><code>}</code></span>
<span class="codeline" id="line-67"><code></code></span>
<span class="codeline" id="line-68"><code>// readHeader reads the message headers from r.</code></span>
<span class="codeline" id="line-69"><code>// This is like textproto.ReadMIMEHeader, but doesn't validate.</code></span>
<span class="codeline" id="line-70"><code>// The fix for issue #53188 tightened up net/textproto to enforce</code></span>
<span class="codeline" id="line-71"><code>// restrictions of RFC 7230.</code></span>
<span class="codeline" id="line-72"><code>// This package implements RFC 5322, which does not have those restrictions.</code></span>
<span class="codeline" id="line-73"><code>// This function copies the relevant code from net/textproto,</code></span>
<span class="codeline" id="line-74"><code>// simplified for RFC 5322.</code></span>
<span class="codeline" id="line-75"><code>func readHeader(r *textproto.Reader) (map[string][]string, error) {</code></span>
<span class="codeline" id="line-76"><code>	m := make(map[string][]string)</code></span>
<span class="codeline" id="line-77"><code></code></span>
<span class="codeline" id="line-78"><code>	// The first line cannot start with a leading space.</code></span>
<span class="codeline" id="line-79"><code>	if buf, err := r.R.Peek(1); err == nil &amp;&amp; (buf[0] == ' ' || buf[0] == '\t') {</code></span>
<span class="codeline" id="line-80"><code>		line, err := r.ReadLine()</code></span>
<span class="codeline" id="line-81"><code>		if err != nil {</code></span>
<span class="codeline" id="line-82"><code>			return m, err</code></span>
<span class="codeline" id="line-83"><code>		}</code></span>
<span class="codeline" id="line-84"><code>		return m, errors.New("malformed initial line: " + line)</code></span>
<span class="codeline" id="line-85"><code>	}</code></span>
<span class="codeline" id="line-86"><code></code></span>
<span class="codeline" id="line-87"><code>	for {</code></span>
<span class="codeline" id="line-88"><code>		kv, err := r.ReadContinuedLine()</code></span>
<span class="codeline" id="line-89"><code>		if kv == "" {</code></span>
<span class="codeline" id="line-90"><code>			return m, err</code></span>
<span class="codeline" id="line-91"><code>		}</code></span>
<span class="codeline" id="line-92"><code></code></span>
<span class="codeline" id="line-93"><code>		// Key ends at first colon.</code></span>
<span class="codeline" id="line-94"><code>		k, v, ok := strings.Cut(kv, ":")</code></span>
<span class="codeline" id="line-95"><code>		if !ok {</code></span>
<span class="codeline" id="line-96"><code>			return m, errors.New("malformed header line: " + kv)</code></span>
<span class="codeline" id="line-97"><code>		}</code></span>
<span class="codeline" id="line-98"><code>		key := textproto.CanonicalMIMEHeaderKey(k)</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>		// Permit empty key, because that is what we did in the past.</code></span>
<span class="codeline" id="line-101"><code>		if key == "" {</code></span>
<span class="codeline" id="line-102"><code>			continue</code></span>
<span class="codeline" id="line-103"><code>		}</code></span>
<span class="codeline" id="line-104"><code></code></span>
<span class="codeline" id="line-105"><code>		// Skip initial spaces in value.</code></span>
<span class="codeline" id="line-106"><code>		value := strings.TrimLeft(v, " \t")</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>		m[key] = append(m[key], value)</code></span>
<span class="codeline" id="line-109"><code></code></span>
<span class="codeline" id="line-110"><code>		if err != nil {</code></span>
<span class="codeline" id="line-111"><code>			return m, err</code></span>
<span class="codeline" id="line-112"><code>		}</code></span>
<span class="codeline" id="line-113"><code>	}</code></span>
<span class="codeline" id="line-114"><code>}</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>// Layouts suitable for passing to time.Parse.</code></span>
<span class="codeline" id="line-117"><code>// These are tried in order.</code></span>
<span class="codeline" id="line-118"><code>var (</code></span>
<span class="codeline" id="line-119"><code>	dateLayoutsBuildOnce sync.Once</code></span>
<span class="codeline" id="line-120"><code>	dateLayouts          []string</code></span>
<span class="codeline" id="line-121"><code>)</code></span>
<span class="codeline" id="line-122"><code></code></span>
<span class="codeline" id="line-123"><code>func buildDateLayouts() {</code></span>
<span class="codeline" id="line-124"><code>	// Generate layouts based on RFC 5322, section 3.3.</code></span>
<span class="codeline" id="line-125"><code></code></span>
<span class="codeline" id="line-126"><code>	dows := [...]string{"", "Mon, "}   // day-of-week</code></span>
<span class="codeline" id="line-127"><code>	days := [...]string{"2", "02"}     // day = 1*2DIGIT</code></span>
<span class="codeline" id="line-128"><code>	years := [...]string{"2006", "06"} // year = 4*DIGIT / 2*DIGIT</code></span>
<span class="codeline" id="line-129"><code>	seconds := [...]string{":05", ""}  // second</code></span>
<span class="codeline" id="line-130"><code>	// "-0700 (MST)" is not in RFC 5322, but is common.</code></span>
<span class="codeline" id="line-131"><code>	zones := [...]string{"-0700", "MST", "UT"} // zone = (("+" / "-") 4DIGIT) / "UT" / "GMT" / ...</code></span>
<span class="codeline" id="line-132"><code></code></span>
<span class="codeline" id="line-133"><code>	for _, dow := range dows {</code></span>
<span class="codeline" id="line-134"><code>		for _, day := range days {</code></span>
<span class="codeline" id="line-135"><code>			for _, year := range years {</code></span>
<span class="codeline" id="line-136"><code>				for _, second := range seconds {</code></span>
<span class="codeline" id="line-137"><code>					for _, zone := range zones {</code></span>
<span class="codeline" id="line-138"><code>						s := dow + day + " Jan " + year + " 15:04" + second + " " + zone</code></span>
<span class="codeline" id="line-139"><code>						dateLayouts = append(dateLayouts, s)</code></span>
<span class="codeline" id="line-140"><code>					}</code></span>
<span class="codeline" id="line-141"><code>				}</code></span>
<span class="codeline" id="line-142"><code>			}</code></span>
<span class="codeline" id="line-143"><code>		}</code></span>
<span class="codeline" id="line-144"><code>	}</code></span>
<span class="codeline" id="line-145"><code>}</code></span>
<span class="codeline" id="line-146"><code></code></span>
<span class="codeline" id="line-147"><code>// ParseDate parses an RFC 5322 date string.</code></span>
<span class="codeline" id="line-148"><code>func ParseDate(date string) (time.Time, error) {</code></span>
<span class="codeline" id="line-149"><code>	dateLayoutsBuildOnce.Do(buildDateLayouts)</code></span>
<span class="codeline" id="line-150"><code>	// CR and LF must match and are tolerated anywhere in the date field.</code></span>
<span class="codeline" id="line-151"><code>	date = strings.ReplaceAll(date, "\r\n", "")</code></span>
<span class="codeline" id="line-152"><code>	if strings.Contains(date, "\r") {</code></span>
<span class="codeline" id="line-153"><code>		return time.Time{}, errors.New("mail: header has a CR without LF")</code></span>
<span class="codeline" id="line-154"><code>	}</code></span>
<span class="codeline" id="line-155"><code>	// Re-using some addrParser methods which support obsolete text, i.e. non-printable ASCII</code></span>
<span class="codeline" id="line-156"><code>	p := addrParser{date, nil}</code></span>
<span class="codeline" id="line-157"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-158"><code></code></span>
<span class="codeline" id="line-159"><code>	// RFC 5322: zone = (FWS ( "+" / "-" ) 4DIGIT) / obs-zone</code></span>
<span class="codeline" id="line-160"><code>	// zone length is always 5 chars unless obsolete (obs-zone)</code></span>
<span class="codeline" id="line-161"><code>	if ind := strings.IndexAny(p.s, "+-"); ind != -1 &amp;&amp; len(p.s) &gt;= ind+5 {</code></span>
<span class="codeline" id="line-162"><code>		date = p.s[:ind+5]</code></span>
<span class="codeline" id="line-163"><code>		p.s = p.s[ind+5:]</code></span>
<span class="codeline" id="line-164"><code>	} else {</code></span>
<span class="codeline" id="line-165"><code>		ind := strings.Index(p.s, "T")</code></span>
<span class="codeline" id="line-166"><code>		if ind == 0 {</code></span>
<span class="codeline" id="line-167"><code>			// In this case we have the following date formats:</code></span>
<span class="codeline" id="line-168"><code>			// * Thu, 20 Nov 1997 09:55:06 MDT</code></span>
<span class="codeline" id="line-169"><code>			// * Thu, 20 Nov 1997 09:55:06 MDT (MDT)</code></span>
<span class="codeline" id="line-170"><code>			// * Thu, 20 Nov 1997 09:55:06 MDT (This comment)</code></span>
<span class="codeline" id="line-171"><code>			ind = strings.Index(p.s[1:], "T")</code></span>
<span class="codeline" id="line-172"><code>			if ind != -1 {</code></span>
<span class="codeline" id="line-173"><code>				ind++</code></span>
<span class="codeline" id="line-174"><code>			}</code></span>
<span class="codeline" id="line-175"><code>		}</code></span>
<span class="codeline" id="line-176"><code></code></span>
<span class="codeline" id="line-177"><code>		if ind != -1 &amp;&amp; len(p.s) &gt;= ind+5 {</code></span>
<span class="codeline" id="line-178"><code>			// The last letter T of the obsolete time zone is checked when no standard time zone is found.</code></span>
<span class="codeline" id="line-179"><code>			// If T is misplaced, the date to parse is garbage.</code></span>
<span class="codeline" id="line-180"><code>			date = p.s[:ind+1]</code></span>
<span class="codeline" id="line-181"><code>			p.s = p.s[ind+1:]</code></span>
<span class="codeline" id="line-182"><code>		}</code></span>
<span class="codeline" id="line-183"><code>	}</code></span>
<span class="codeline" id="line-184"><code>	if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-185"><code>		return time.Time{}, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-186"><code>	}</code></span>
<span class="codeline" id="line-187"><code>	for _, layout := range dateLayouts {</code></span>
<span class="codeline" id="line-188"><code>		t, err := time.Parse(layout, date)</code></span>
<span class="codeline" id="line-189"><code>		if err == nil {</code></span>
<span class="codeline" id="line-190"><code>			return t, nil</code></span>
<span class="codeline" id="line-191"><code>		}</code></span>
<span class="codeline" id="line-192"><code>	}</code></span>
<span class="codeline" id="line-193"><code>	return time.Time{}, errors.New("mail: header could not be parsed")</code></span>
<span class="codeline" id="line-194"><code>}</code></span>
<span class="codeline" id="line-195"><code></code></span>
<span class="codeline" id="line-196"><code>// A Header represents the key-value pairs in a mail message header.</code></span>
<span class="codeline" id="line-197"><code>type Header map[string][]string</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>// Get gets the first value associated with the given key.</code></span>
<span class="codeline" id="line-200"><code>// It is case insensitive; CanonicalMIMEHeaderKey is used</code></span>
<span class="codeline" id="line-201"><code>// to canonicalize the provided key.</code></span>
<span class="codeline" id="line-202"><code>// If there are no values associated with the key, Get returns "".</code></span>
<span class="codeline" id="line-203"><code>// To access multiple values of a key, or to use non-canonical keys,</code></span>
<span class="codeline" id="line-204"><code>// access the map directly.</code></span>
<span class="codeline" id="line-205"><code>func (h Header) Get(key string) string {</code></span>
<span class="codeline" id="line-206"><code>	return textproto.MIMEHeader(h).Get(key)</code></span>
<span class="codeline" id="line-207"><code>}</code></span>
<span class="codeline" id="line-208"><code></code></span>
<span class="codeline" id="line-209"><code>var ErrHeaderNotPresent = errors.New("mail: header not in message")</code></span>
<span class="codeline" id="line-210"><code></code></span>
<span class="codeline" id="line-211"><code>// Date parses the Date header field.</code></span>
<span class="codeline" id="line-212"><code>func (h Header) Date() (time.Time, error) {</code></span>
<span class="codeline" id="line-213"><code>	hdr := h.Get("Date")</code></span>
<span class="codeline" id="line-214"><code>	if hdr == "" {</code></span>
<span class="codeline" id="line-215"><code>		return time.Time{}, ErrHeaderNotPresent</code></span>
<span class="codeline" id="line-216"><code>	}</code></span>
<span class="codeline" id="line-217"><code>	return ParseDate(hdr)</code></span>
<span class="codeline" id="line-218"><code>}</code></span>
<span class="codeline" id="line-219"><code></code></span>
<span class="codeline" id="line-220"><code>// AddressList parses the named header field as a list of addresses.</code></span>
<span class="codeline" id="line-221"><code>func (h Header) AddressList(key string) ([]*Address, error) {</code></span>
<span class="codeline" id="line-222"><code>	hdr := h.Get(key)</code></span>
<span class="codeline" id="line-223"><code>	if hdr == "" {</code></span>
<span class="codeline" id="line-224"><code>		return nil, ErrHeaderNotPresent</code></span>
<span class="codeline" id="line-225"><code>	}</code></span>
<span class="codeline" id="line-226"><code>	return ParseAddressList(hdr)</code></span>
<span class="codeline" id="line-227"><code>}</code></span>
<span class="codeline" id="line-228"><code></code></span>
<span class="codeline" id="line-229"><code>// Address represents a single mail address.</code></span>
<span class="codeline" id="line-230"><code>// An address such as "Barry Gibbs &lt;bg@example.com&gt;" is represented</code></span>
<span class="codeline" id="line-231"><code>// as Address{Name: "Barry Gibbs", Address: "bg@example.com"}.</code></span>
<span class="codeline" id="line-232"><code>type Address struct {</code></span>
<span class="codeline" id="line-233"><code>	Name    string // Proper name; may be empty.</code></span>
<span class="codeline" id="line-234"><code>	Address string // user@domain</code></span>
<span class="codeline" id="line-235"><code>}</code></span>
<span class="codeline" id="line-236"><code></code></span>
<span class="codeline" id="line-237"><code>// ParseAddress parses a single RFC 5322 address, e.g. "Barry Gibbs &lt;bg@example.com&gt;"</code></span>
<span class="codeline" id="line-238"><code>func ParseAddress(address string) (*Address, error) {</code></span>
<span class="codeline" id="line-239"><code>	return (&amp;addrParser{s: address}).parseSingleAddress()</code></span>
<span class="codeline" id="line-240"><code>}</code></span>
<span class="codeline" id="line-241"><code></code></span>
<span class="codeline" id="line-242"><code>// ParseAddressList parses the given string as a list of addresses.</code></span>
<span class="codeline" id="line-243"><code>func ParseAddressList(list string) ([]*Address, error) {</code></span>
<span class="codeline" id="line-244"><code>	return (&amp;addrParser{s: list}).parseAddressList()</code></span>
<span class="codeline" id="line-245"><code>}</code></span>
<span class="codeline" id="line-246"><code></code></span>
<span class="codeline" id="line-247"><code>// An AddressParser is an RFC 5322 address parser.</code></span>
<span class="codeline" id="line-248"><code>type AddressParser struct {</code></span>
<span class="codeline" id="line-249"><code>	// WordDecoder optionally specifies a decoder for RFC 2047 encoded-words.</code></span>
<span class="codeline" id="line-250"><code>	WordDecoder *mime.WordDecoder</code></span>
<span class="codeline" id="line-251"><code>}</code></span>
<span class="codeline" id="line-252"><code></code></span>
<span class="codeline" id="line-253"><code>// Parse parses a single RFC 5322 address of the</code></span>
<span class="codeline" id="line-254"><code>// form "Gogh Fir &lt;gf@example.com&gt;" or "foo@example.com".</code></span>
<span class="codeline" id="line-255"><code>func (p *AddressParser) Parse(address string) (*Address, error) {</code></span>
<span class="codeline" id="line-256"><code>	return (&amp;addrParser{s: address, dec: p.WordDecoder}).parseSingleAddress()</code></span>
<span class="codeline" id="line-257"><code>}</code></span>
<span class="codeline" id="line-258"><code></code></span>
<span class="codeline" id="line-259"><code>// ParseList parses the given string as a list of comma-separated addresses</code></span>
<span class="codeline" id="line-260"><code>// of the form "Gogh Fir &lt;gf@example.com&gt;" or "foo@example.com".</code></span>
<span class="codeline" id="line-261"><code>func (p *AddressParser) ParseList(list string) ([]*Address, error) {</code></span>
<span class="codeline" id="line-262"><code>	return (&amp;addrParser{s: list, dec: p.WordDecoder}).parseAddressList()</code></span>
<span class="codeline" id="line-263"><code>}</code></span>
<span class="codeline" id="line-264"><code></code></span>
<span class="codeline" id="line-265"><code>// String formats the address as a valid RFC 5322 address.</code></span>
<span class="codeline" id="line-266"><code>// If the address's name contains non-ASCII characters</code></span>
<span class="codeline" id="line-267"><code>// the name will be rendered according to RFC 2047.</code></span>
<span class="codeline" id="line-268"><code>func (a *Address) String() string {</code></span>
<span class="codeline" id="line-269"><code>	// Format address local@domain</code></span>
<span class="codeline" id="line-270"><code>	at := strings.LastIndex(a.Address, "@")</code></span>
<span class="codeline" id="line-271"><code>	var local, domain string</code></span>
<span class="codeline" id="line-272"><code>	if at &lt; 0 {</code></span>
<span class="codeline" id="line-273"><code>		// This is a malformed address ("@" is required in addr-spec);</code></span>
<span class="codeline" id="line-274"><code>		// treat the whole address as local-part.</code></span>
<span class="codeline" id="line-275"><code>		local = a.Address</code></span>
<span class="codeline" id="line-276"><code>	} else {</code></span>
<span class="codeline" id="line-277"><code>		local, domain = a.Address[:at], a.Address[at+1:]</code></span>
<span class="codeline" id="line-278"><code>	}</code></span>
<span class="codeline" id="line-279"><code></code></span>
<span class="codeline" id="line-280"><code>	// Add quotes if needed</code></span>
<span class="codeline" id="line-281"><code>	quoteLocal := false</code></span>
<span class="codeline" id="line-282"><code>	for i, r := range local {</code></span>
<span class="codeline" id="line-283"><code>		if isAtext(r, false) {</code></span>
<span class="codeline" id="line-284"><code>			continue</code></span>
<span class="codeline" id="line-285"><code>		}</code></span>
<span class="codeline" id="line-286"><code>		if r == '.' {</code></span>
<span class="codeline" id="line-287"><code>			// Dots are okay if they are surrounded by atext.</code></span>
<span class="codeline" id="line-288"><code>			// We only need to check that the previous byte is</code></span>
<span class="codeline" id="line-289"><code>			// not a dot, and this isn't the end of the string.</code></span>
<span class="codeline" id="line-290"><code>			if i &gt; 0 &amp;&amp; local[i-1] != '.' &amp;&amp; i &lt; len(local)-1 {</code></span>
<span class="codeline" id="line-291"><code>				continue</code></span>
<span class="codeline" id="line-292"><code>			}</code></span>
<span class="codeline" id="line-293"><code>		}</code></span>
<span class="codeline" id="line-294"><code>		quoteLocal = true</code></span>
<span class="codeline" id="line-295"><code>		break</code></span>
<span class="codeline" id="line-296"><code>	}</code></span>
<span class="codeline" id="line-297"><code>	if quoteLocal {</code></span>
<span class="codeline" id="line-298"><code>		local = quoteString(local)</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code>	}</code></span>
<span class="codeline" id="line-301"><code></code></span>
<span class="codeline" id="line-302"><code>	s := "&lt;" + local + "@" + domain + "&gt;"</code></span>
<span class="codeline" id="line-303"><code></code></span>
<span class="codeline" id="line-304"><code>	if a.Name == "" {</code></span>
<span class="codeline" id="line-305"><code>		return s</code></span>
<span class="codeline" id="line-306"><code>	}</code></span>
<span class="codeline" id="line-307"><code></code></span>
<span class="codeline" id="line-308"><code>	// If every character is printable ASCII, quoting is simple.</code></span>
<span class="codeline" id="line-309"><code>	allPrintable := true</code></span>
<span class="codeline" id="line-310"><code>	for _, r := range a.Name {</code></span>
<span class="codeline" id="line-311"><code>		// isWSP here should actually be isFWS,</code></span>
<span class="codeline" id="line-312"><code>		// but we don't support folding yet.</code></span>
<span class="codeline" id="line-313"><code>		if !isVchar(r) &amp;&amp; !isWSP(r) || isMultibyte(r) {</code></span>
<span class="codeline" id="line-314"><code>			allPrintable = false</code></span>
<span class="codeline" id="line-315"><code>			break</code></span>
<span class="codeline" id="line-316"><code>		}</code></span>
<span class="codeline" id="line-317"><code>	}</code></span>
<span class="codeline" id="line-318"><code>	if allPrintable {</code></span>
<span class="codeline" id="line-319"><code>		return quoteString(a.Name) + " " + s</code></span>
<span class="codeline" id="line-320"><code>	}</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>	// Text in an encoded-word in a display-name must not contain certain</code></span>
<span class="codeline" id="line-323"><code>	// characters like quotes or parentheses (see RFC 2047 section 5.3).</code></span>
<span class="codeline" id="line-324"><code>	// When this is the case encode the name using base64 encoding.</code></span>
<span class="codeline" id="line-325"><code>	if strings.ContainsAny(a.Name, "\"#$%&amp;'(),.:;&lt;&gt;@[]^`{|}~") {</code></span>
<span class="codeline" id="line-326"><code>		return mime.BEncoding.Encode("utf-8", a.Name) + " " + s</code></span>
<span class="codeline" id="line-327"><code>	}</code></span>
<span class="codeline" id="line-328"><code>	return mime.QEncoding.Encode("utf-8", a.Name) + " " + s</code></span>
<span class="codeline" id="line-329"><code>}</code></span>
<span class="codeline" id="line-330"><code></code></span>
<span class="codeline" id="line-331"><code>type addrParser struct {</code></span>
<span class="codeline" id="line-332"><code>	s   string</code></span>
<span class="codeline" id="line-333"><code>	dec *mime.WordDecoder // may be nil</code></span>
<span class="codeline" id="line-334"><code>}</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>func (p *addrParser) parseAddressList() ([]*Address, error) {</code></span>
<span class="codeline" id="line-337"><code>	var list []*Address</code></span>
<span class="codeline" id="line-338"><code>	for {</code></span>
<span class="codeline" id="line-339"><code>		p.skipSpace()</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>		// allow skipping empty entries (RFC5322 obs-addr-list)</code></span>
<span class="codeline" id="line-342"><code>		if p.consume(',') {</code></span>
<span class="codeline" id="line-343"><code>			continue</code></span>
<span class="codeline" id="line-344"><code>		}</code></span>
<span class="codeline" id="line-345"><code></code></span>
<span class="codeline" id="line-346"><code>		addrs, err := p.parseAddress(true)</code></span>
<span class="codeline" id="line-347"><code>		if err != nil {</code></span>
<span class="codeline" id="line-348"><code>			return nil, err</code></span>
<span class="codeline" id="line-349"><code>		}</code></span>
<span class="codeline" id="line-350"><code>		list = append(list, addrs...)</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>		if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-353"><code>			return nil, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-354"><code>		}</code></span>
<span class="codeline" id="line-355"><code>		if p.empty() {</code></span>
<span class="codeline" id="line-356"><code>			break</code></span>
<span class="codeline" id="line-357"><code>		}</code></span>
<span class="codeline" id="line-358"><code>		if p.peek() != ',' {</code></span>
<span class="codeline" id="line-359"><code>			return nil, errors.New("mail: expected comma")</code></span>
<span class="codeline" id="line-360"><code>		}</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>		// Skip empty entries for obs-addr-list.</code></span>
<span class="codeline" id="line-363"><code>		for p.consume(',') {</code></span>
<span class="codeline" id="line-364"><code>			p.skipSpace()</code></span>
<span class="codeline" id="line-365"><code>		}</code></span>
<span class="codeline" id="line-366"><code>		if p.empty() {</code></span>
<span class="codeline" id="line-367"><code>			break</code></span>
<span class="codeline" id="line-368"><code>		}</code></span>
<span class="codeline" id="line-369"><code>	}</code></span>
<span class="codeline" id="line-370"><code>	return list, nil</code></span>
<span class="codeline" id="line-371"><code>}</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>func (p *addrParser) parseSingleAddress() (*Address, error) {</code></span>
<span class="codeline" id="line-374"><code>	addrs, err := p.parseAddress(true)</code></span>
<span class="codeline" id="line-375"><code>	if err != nil {</code></span>
<span class="codeline" id="line-376"><code>		return nil, err</code></span>
<span class="codeline" id="line-377"><code>	}</code></span>
<span class="codeline" id="line-378"><code>	if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-379"><code>		return nil, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-380"><code>	}</code></span>
<span class="codeline" id="line-381"><code>	if !p.empty() {</code></span>
<span class="codeline" id="line-382"><code>		return nil, fmt.Errorf("mail: expected single address, got %q", p.s)</code></span>
<span class="codeline" id="line-383"><code>	}</code></span>
<span class="codeline" id="line-384"><code>	if len(addrs) == 0 {</code></span>
<span class="codeline" id="line-385"><code>		return nil, errors.New("mail: empty group")</code></span>
<span class="codeline" id="line-386"><code>	}</code></span>
<span class="codeline" id="line-387"><code>	if len(addrs) &gt; 1 {</code></span>
<span class="codeline" id="line-388"><code>		return nil, errors.New("mail: group with multiple addresses")</code></span>
<span class="codeline" id="line-389"><code>	}</code></span>
<span class="codeline" id="line-390"><code>	return addrs[0], nil</code></span>
<span class="codeline" id="line-391"><code>}</code></span>
<span class="codeline" id="line-392"><code></code></span>
<span class="codeline" id="line-393"><code>// parseAddress parses a single RFC 5322 address at the start of p.</code></span>
<span class="codeline" id="line-394"><code>func (p *addrParser) parseAddress(handleGroup bool) ([]*Address, error) {</code></span>
<span class="codeline" id="line-395"><code>	debug.Printf("parseAddress: %q", p.s)</code></span>
<span class="codeline" id="line-396"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-397"><code>	if p.empty() {</code></span>
<span class="codeline" id="line-398"><code>		return nil, errors.New("mail: no address")</code></span>
<span class="codeline" id="line-399"><code>	}</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>	// address = mailbox / group</code></span>
<span class="codeline" id="line-402"><code>	// mailbox = name-addr / addr-spec</code></span>
<span class="codeline" id="line-403"><code>	// group = display-name ":" [group-list] ";" [CFWS]</code></span>
<span class="codeline" id="line-404"><code></code></span>
<span class="codeline" id="line-405"><code>	// addr-spec has a more restricted grammar than name-addr,</code></span>
<span class="codeline" id="line-406"><code>	// so try parsing it first, and fallback to name-addr.</code></span>
<span class="codeline" id="line-407"><code>	// TODO(dsymonds): Is this really correct?</code></span>
<span class="codeline" id="line-408"><code>	spec, err := p.consumeAddrSpec()</code></span>
<span class="codeline" id="line-409"><code>	if err == nil {</code></span>
<span class="codeline" id="line-410"><code>		var displayName string</code></span>
<span class="codeline" id="line-411"><code>		p.skipSpace()</code></span>
<span class="codeline" id="line-412"><code>		if !p.empty() &amp;&amp; p.peek() == '(' {</code></span>
<span class="codeline" id="line-413"><code>			displayName, err = p.consumeDisplayNameComment()</code></span>
<span class="codeline" id="line-414"><code>			if err != nil {</code></span>
<span class="codeline" id="line-415"><code>				return nil, err</code></span>
<span class="codeline" id="line-416"><code>			}</code></span>
<span class="codeline" id="line-417"><code>		}</code></span>
<span class="codeline" id="line-418"><code></code></span>
<span class="codeline" id="line-419"><code>		return []*Address{{</code></span>
<span class="codeline" id="line-420"><code>			Name:    displayName,</code></span>
<span class="codeline" id="line-421"><code>			Address: spec,</code></span>
<span class="codeline" id="line-422"><code>		}}, err</code></span>
<span class="codeline" id="line-423"><code>	}</code></span>
<span class="codeline" id="line-424"><code>	debug.Printf("parseAddress: not an addr-spec: %v", err)</code></span>
<span class="codeline" id="line-425"><code>	debug.Printf("parseAddress: state is now %q", p.s)</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>	// display-name</code></span>
<span class="codeline" id="line-428"><code>	var displayName string</code></span>
<span class="codeline" id="line-429"><code>	if p.peek() != '&lt;' {</code></span>
<span class="codeline" id="line-430"><code>		displayName, err = p.consumePhrase()</code></span>
<span class="codeline" id="line-431"><code>		if err != nil {</code></span>
<span class="codeline" id="line-432"><code>			return nil, err</code></span>
<span class="codeline" id="line-433"><code>		}</code></span>
<span class="codeline" id="line-434"><code>	}</code></span>
<span class="codeline" id="line-435"><code>	debug.Printf("parseAddress: displayName=%q", displayName)</code></span>
<span class="codeline" id="line-436"><code></code></span>
<span class="codeline" id="line-437"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-438"><code>	if handleGroup {</code></span>
<span class="codeline" id="line-439"><code>		if p.consume(':') {</code></span>
<span class="codeline" id="line-440"><code>			return p.consumeGroupList()</code></span>
<span class="codeline" id="line-441"><code>		}</code></span>
<span class="codeline" id="line-442"><code>	}</code></span>
<span class="codeline" id="line-443"><code>	// angle-addr = "&lt;" addr-spec "&gt;"</code></span>
<span class="codeline" id="line-444"><code>	if !p.consume('&lt;') {</code></span>
<span class="codeline" id="line-445"><code>		atext := true</code></span>
<span class="codeline" id="line-446"><code>		for _, r := range displayName {</code></span>
<span class="codeline" id="line-447"><code>			if !isAtext(r, true) {</code></span>
<span class="codeline" id="line-448"><code>				atext = false</code></span>
<span class="codeline" id="line-449"><code>				break</code></span>
<span class="codeline" id="line-450"><code>			}</code></span>
<span class="codeline" id="line-451"><code>		}</code></span>
<span class="codeline" id="line-452"><code>		if atext {</code></span>
<span class="codeline" id="line-453"><code>			// The input is like "foo.bar"; it's possible the input</code></span>
<span class="codeline" id="line-454"><code>			// meant to be "foo.bar@domain", or "foo.bar &lt;...&gt;".</code></span>
<span class="codeline" id="line-455"><code>			return nil, errors.New("mail: missing '@' or angle-addr")</code></span>
<span class="codeline" id="line-456"><code>		}</code></span>
<span class="codeline" id="line-457"><code>		// The input is like "Full Name", which couldn't possibly be a</code></span>
<span class="codeline" id="line-458"><code>		// valid email address if followed by "@domain"; the input</code></span>
<span class="codeline" id="line-459"><code>		// likely meant to be "Full Name &lt;...&gt;".</code></span>
<span class="codeline" id="line-460"><code>		return nil, errors.New("mail: no angle-addr")</code></span>
<span class="codeline" id="line-461"><code>	}</code></span>
<span class="codeline" id="line-462"><code>	spec, err = p.consumeAddrSpec()</code></span>
<span class="codeline" id="line-463"><code>	if err != nil {</code></span>
<span class="codeline" id="line-464"><code>		return nil, err</code></span>
<span class="codeline" id="line-465"><code>	}</code></span>
<span class="codeline" id="line-466"><code>	if !p.consume('&gt;') {</code></span>
<span class="codeline" id="line-467"><code>		return nil, errors.New("mail: unclosed angle-addr")</code></span>
<span class="codeline" id="line-468"><code>	}</code></span>
<span class="codeline" id="line-469"><code>	debug.Printf("parseAddress: spec=%q", spec)</code></span>
<span class="codeline" id="line-470"><code></code></span>
<span class="codeline" id="line-471"><code>	return []*Address{{</code></span>
<span class="codeline" id="line-472"><code>		Name:    displayName,</code></span>
<span class="codeline" id="line-473"><code>		Address: spec,</code></span>
<span class="codeline" id="line-474"><code>	}}, nil</code></span>
<span class="codeline" id="line-475"><code>}</code></span>
<span class="codeline" id="line-476"><code></code></span>
<span class="codeline" id="line-477"><code>func (p *addrParser) consumeGroupList() ([]*Address, error) {</code></span>
<span class="codeline" id="line-478"><code>	var group []*Address</code></span>
<span class="codeline" id="line-479"><code>	// handle empty group.</code></span>
<span class="codeline" id="line-480"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-481"><code>	if p.consume(';') {</code></span>
<span class="codeline" id="line-482"><code>		if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-483"><code>			return nil, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-484"><code>		}</code></span>
<span class="codeline" id="line-485"><code>		return group, nil</code></span>
<span class="codeline" id="line-486"><code>	}</code></span>
<span class="codeline" id="line-487"><code></code></span>
<span class="codeline" id="line-488"><code>	for {</code></span>
<span class="codeline" id="line-489"><code>		p.skipSpace()</code></span>
<span class="codeline" id="line-490"><code>		// embedded groups not allowed.</code></span>
<span class="codeline" id="line-491"><code>		addrs, err := p.parseAddress(false)</code></span>
<span class="codeline" id="line-492"><code>		if err != nil {</code></span>
<span class="codeline" id="line-493"><code>			return nil, err</code></span>
<span class="codeline" id="line-494"><code>		}</code></span>
<span class="codeline" id="line-495"><code>		group = append(group, addrs...)</code></span>
<span class="codeline" id="line-496"><code></code></span>
<span class="codeline" id="line-497"><code>		if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-498"><code>			return nil, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-499"><code>		}</code></span>
<span class="codeline" id="line-500"><code>		if p.consume(';') {</code></span>
<span class="codeline" id="line-501"><code>			if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-502"><code>				return nil, errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-503"><code>			}</code></span>
<span class="codeline" id="line-504"><code>			break</code></span>
<span class="codeline" id="line-505"><code>		}</code></span>
<span class="codeline" id="line-506"><code>		if !p.consume(',') {</code></span>
<span class="codeline" id="line-507"><code>			return nil, errors.New("mail: expected comma")</code></span>
<span class="codeline" id="line-508"><code>		}</code></span>
<span class="codeline" id="line-509"><code>	}</code></span>
<span class="codeline" id="line-510"><code>	return group, nil</code></span>
<span class="codeline" id="line-511"><code>}</code></span>
<span class="codeline" id="line-512"><code></code></span>
<span class="codeline" id="line-513"><code>// consumeAddrSpec parses a single RFC 5322 addr-spec at the start of p.</code></span>
<span class="codeline" id="line-514"><code>func (p *addrParser) consumeAddrSpec() (spec string, err error) {</code></span>
<span class="codeline" id="line-515"><code>	debug.Printf("consumeAddrSpec: %q", p.s)</code></span>
<span class="codeline" id="line-516"><code></code></span>
<span class="codeline" id="line-517"><code>	orig := *p</code></span>
<span class="codeline" id="line-518"><code>	defer func() {</code></span>
<span class="codeline" id="line-519"><code>		if err != nil {</code></span>
<span class="codeline" id="line-520"><code>			*p = orig</code></span>
<span class="codeline" id="line-521"><code>		}</code></span>
<span class="codeline" id="line-522"><code>	}()</code></span>
<span class="codeline" id="line-523"><code></code></span>
<span class="codeline" id="line-524"><code>	// local-part = dot-atom / quoted-string</code></span>
<span class="codeline" id="line-525"><code>	var localPart string</code></span>
<span class="codeline" id="line-526"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-527"><code>	if p.empty() {</code></span>
<span class="codeline" id="line-528"><code>		return "", errors.New("mail: no addr-spec")</code></span>
<span class="codeline" id="line-529"><code>	}</code></span>
<span class="codeline" id="line-530"><code>	if p.peek() == '"' {</code></span>
<span class="codeline" id="line-531"><code>		// quoted-string</code></span>
<span class="codeline" id="line-532"><code>		debug.Printf("consumeAddrSpec: parsing quoted-string")</code></span>
<span class="codeline" id="line-533"><code>		localPart, err = p.consumeQuotedString()</code></span>
<span class="codeline" id="line-534"><code>		if localPart == "" {</code></span>
<span class="codeline" id="line-535"><code>			err = errors.New("mail: empty quoted string in addr-spec")</code></span>
<span class="codeline" id="line-536"><code>		}</code></span>
<span class="codeline" id="line-537"><code>	} else {</code></span>
<span class="codeline" id="line-538"><code>		// dot-atom</code></span>
<span class="codeline" id="line-539"><code>		debug.Printf("consumeAddrSpec: parsing dot-atom")</code></span>
<span class="codeline" id="line-540"><code>		localPart, err = p.consumeAtom(true, false)</code></span>
<span class="codeline" id="line-541"><code>	}</code></span>
<span class="codeline" id="line-542"><code>	if err != nil {</code></span>
<span class="codeline" id="line-543"><code>		debug.Printf("consumeAddrSpec: failed: %v", err)</code></span>
<span class="codeline" id="line-544"><code>		return "", err</code></span>
<span class="codeline" id="line-545"><code>	}</code></span>
<span class="codeline" id="line-546"><code></code></span>
<span class="codeline" id="line-547"><code>	if !p.consume('@') {</code></span>
<span class="codeline" id="line-548"><code>		return "", errors.New("mail: missing @ in addr-spec")</code></span>
<span class="codeline" id="line-549"><code>	}</code></span>
<span class="codeline" id="line-550"><code></code></span>
<span class="codeline" id="line-551"><code>	// domain = dot-atom / domain-literal</code></span>
<span class="codeline" id="line-552"><code>	var domain string</code></span>
<span class="codeline" id="line-553"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-554"><code>	if p.empty() {</code></span>
<span class="codeline" id="line-555"><code>		return "", errors.New("mail: no domain in addr-spec")</code></span>
<span class="codeline" id="line-556"><code>	}</code></span>
<span class="codeline" id="line-557"><code>	// TODO(dsymonds): Handle domain-literal</code></span>
<span class="codeline" id="line-558"><code>	domain, err = p.consumeAtom(true, false)</code></span>
<span class="codeline" id="line-559"><code>	if err != nil {</code></span>
<span class="codeline" id="line-560"><code>		return "", err</code></span>
<span class="codeline" id="line-561"><code>	}</code></span>
<span class="codeline" id="line-562"><code></code></span>
<span class="codeline" id="line-563"><code>	return localPart + "@" + domain, nil</code></span>
<span class="codeline" id="line-564"><code>}</code></span>
<span class="codeline" id="line-565"><code></code></span>
<span class="codeline" id="line-566"><code>// consumePhrase parses the RFC 5322 phrase at the start of p.</code></span>
<span class="codeline" id="line-567"><code>func (p *addrParser) consumePhrase() (phrase string, err error) {</code></span>
<span class="codeline" id="line-568"><code>	debug.Printf("consumePhrase: [%s]", p.s)</code></span>
<span class="codeline" id="line-569"><code>	// phrase = 1*word</code></span>
<span class="codeline" id="line-570"><code>	var words []string</code></span>
<span class="codeline" id="line-571"><code>	var isPrevEncoded bool</code></span>
<span class="codeline" id="line-572"><code>	for {</code></span>
<span class="codeline" id="line-573"><code>		// obs-phrase allows CFWS after one word</code></span>
<span class="codeline" id="line-574"><code>		if len(words) &gt; 0 {</code></span>
<span class="codeline" id="line-575"><code>			if !p.skipCFWS() {</code></span>
<span class="codeline" id="line-576"><code>				return "", errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-577"><code>			}</code></span>
<span class="codeline" id="line-578"><code>		}</code></span>
<span class="codeline" id="line-579"><code>		// word = atom / quoted-string</code></span>
<span class="codeline" id="line-580"><code>		var word string</code></span>
<span class="codeline" id="line-581"><code>		p.skipSpace()</code></span>
<span class="codeline" id="line-582"><code>		if p.empty() {</code></span>
<span class="codeline" id="line-583"><code>			break</code></span>
<span class="codeline" id="line-584"><code>		}</code></span>
<span class="codeline" id="line-585"><code>		isEncoded := false</code></span>
<span class="codeline" id="line-586"><code>		if p.peek() == '"' {</code></span>
<span class="codeline" id="line-587"><code>			// quoted-string</code></span>
<span class="codeline" id="line-588"><code>			word, err = p.consumeQuotedString()</code></span>
<span class="codeline" id="line-589"><code>		} else {</code></span>
<span class="codeline" id="line-590"><code>			// atom</code></span>
<span class="codeline" id="line-591"><code>			// We actually parse dot-atom here to be more permissive</code></span>
<span class="codeline" id="line-592"><code>			// than what RFC 5322 specifies.</code></span>
<span class="codeline" id="line-593"><code>			word, err = p.consumeAtom(true, true)</code></span>
<span class="codeline" id="line-594"><code>			if err == nil {</code></span>
<span class="codeline" id="line-595"><code>				word, isEncoded, err = p.decodeRFC2047Word(word)</code></span>
<span class="codeline" id="line-596"><code>			}</code></span>
<span class="codeline" id="line-597"><code>		}</code></span>
<span class="codeline" id="line-598"><code></code></span>
<span class="codeline" id="line-599"><code>		if err != nil {</code></span>
<span class="codeline" id="line-600"><code>			break</code></span>
<span class="codeline" id="line-601"><code>		}</code></span>
<span class="codeline" id="line-602"><code>		debug.Printf("consumePhrase: consumed %q", word)</code></span>
<span class="codeline" id="line-603"><code>		if isPrevEncoded &amp;&amp; isEncoded {</code></span>
<span class="codeline" id="line-604"><code>			words[len(words)-1] += word</code></span>
<span class="codeline" id="line-605"><code>		} else {</code></span>
<span class="codeline" id="line-606"><code>			words = append(words, word)</code></span>
<span class="codeline" id="line-607"><code>		}</code></span>
<span class="codeline" id="line-608"><code>		isPrevEncoded = isEncoded</code></span>
<span class="codeline" id="line-609"><code>	}</code></span>
<span class="codeline" id="line-610"><code>	// Ignore any error if we got at least one word.</code></span>
<span class="codeline" id="line-611"><code>	if err != nil &amp;&amp; len(words) == 0 {</code></span>
<span class="codeline" id="line-612"><code>		debug.Printf("consumePhrase: hit err: %v", err)</code></span>
<span class="codeline" id="line-613"><code>		return "", fmt.Errorf("mail: missing word in phrase: %v", err)</code></span>
<span class="codeline" id="line-614"><code>	}</code></span>
<span class="codeline" id="line-615"><code>	phrase = strings.Join(words, " ")</code></span>
<span class="codeline" id="line-616"><code>	return phrase, nil</code></span>
<span class="codeline" id="line-617"><code>}</code></span>
<span class="codeline" id="line-618"><code></code></span>
<span class="codeline" id="line-619"><code>// consumeQuotedString parses the quoted string at the start of p.</code></span>
<span class="codeline" id="line-620"><code>func (p *addrParser) consumeQuotedString() (qs string, err error) {</code></span>
<span class="codeline" id="line-621"><code>	// Assume first byte is '"'.</code></span>
<span class="codeline" id="line-622"><code>	i := 1</code></span>
<span class="codeline" id="line-623"><code>	qsb := make([]rune, 0, 10)</code></span>
<span class="codeline" id="line-624"><code></code></span>
<span class="codeline" id="line-625"><code>	escaped := false</code></span>
<span class="codeline" id="line-626"><code></code></span>
<span class="codeline" id="line-627"><code>Loop:</code></span>
<span class="codeline" id="line-628"><code>	for {</code></span>
<span class="codeline" id="line-629"><code>		r, size := utf8.DecodeRuneInString(p.s[i:])</code></span>
<span class="codeline" id="line-630"><code></code></span>
<span class="codeline" id="line-631"><code>		switch {</code></span>
<span class="codeline" id="line-632"><code>		case size == 0:</code></span>
<span class="codeline" id="line-633"><code>			return "", errors.New("mail: unclosed quoted-string")</code></span>
<span class="codeline" id="line-634"><code></code></span>
<span class="codeline" id="line-635"><code>		case size == 1 &amp;&amp; r == utf8.RuneError:</code></span>
<span class="codeline" id="line-636"><code>			return "", fmt.Errorf("mail: invalid utf-8 in quoted-string: %q", p.s)</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>		case escaped:</code></span>
<span class="codeline" id="line-639"><code>			//  quoted-pair = ("\" (VCHAR / WSP))</code></span>
<span class="codeline" id="line-640"><code></code></span>
<span class="codeline" id="line-641"><code>			if !isVchar(r) &amp;&amp; !isWSP(r) {</code></span>
<span class="codeline" id="line-642"><code>				return "", fmt.Errorf("mail: bad character in quoted-string: %q", r)</code></span>
<span class="codeline" id="line-643"><code>			}</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>			qsb = append(qsb, r)</code></span>
<span class="codeline" id="line-646"><code>			escaped = false</code></span>
<span class="codeline" id="line-647"><code></code></span>
<span class="codeline" id="line-648"><code>		case isQtext(r) || isWSP(r):</code></span>
<span class="codeline" id="line-649"><code>			// qtext (printable US-ASCII excluding " and \), or</code></span>
<span class="codeline" id="line-650"><code>			// FWS (almost; we're ignoring CRLF)</code></span>
<span class="codeline" id="line-651"><code>			qsb = append(qsb, r)</code></span>
<span class="codeline" id="line-652"><code></code></span>
<span class="codeline" id="line-653"><code>		case r == '"':</code></span>
<span class="codeline" id="line-654"><code>			break Loop</code></span>
<span class="codeline" id="line-655"><code></code></span>
<span class="codeline" id="line-656"><code>		case r == '\\':</code></span>
<span class="codeline" id="line-657"><code>			escaped = true</code></span>
<span class="codeline" id="line-658"><code></code></span>
<span class="codeline" id="line-659"><code>		default:</code></span>
<span class="codeline" id="line-660"><code>			return "", fmt.Errorf("mail: bad character in quoted-string: %q", r)</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>		}</code></span>
<span class="codeline" id="line-663"><code></code></span>
<span class="codeline" id="line-664"><code>		i += size</code></span>
<span class="codeline" id="line-665"><code>	}</code></span>
<span class="codeline" id="line-666"><code>	p.s = p.s[i+1:]</code></span>
<span class="codeline" id="line-667"><code>	return string(qsb), nil</code></span>
<span class="codeline" id="line-668"><code>}</code></span>
<span class="codeline" id="line-669"><code></code></span>
<span class="codeline" id="line-670"><code>// consumeAtom parses an RFC 5322 atom at the start of p.</code></span>
<span class="codeline" id="line-671"><code>// If dot is true, consumeAtom parses an RFC 5322 dot-atom instead.</code></span>
<span class="codeline" id="line-672"><code>// If permissive is true, consumeAtom will not fail on:</code></span>
<span class="codeline" id="line-673"><code>// - leading/trailing/double dots in the atom (see golang.org/issue/4938)</code></span>
<span class="codeline" id="line-674"><code>func (p *addrParser) consumeAtom(dot bool, permissive bool) (atom string, err error) {</code></span>
<span class="codeline" id="line-675"><code>	i := 0</code></span>
<span class="codeline" id="line-676"><code></code></span>
<span class="codeline" id="line-677"><code>Loop:</code></span>
<span class="codeline" id="line-678"><code>	for {</code></span>
<span class="codeline" id="line-679"><code>		r, size := utf8.DecodeRuneInString(p.s[i:])</code></span>
<span class="codeline" id="line-680"><code>		switch {</code></span>
<span class="codeline" id="line-681"><code>		case size == 1 &amp;&amp; r == utf8.RuneError:</code></span>
<span class="codeline" id="line-682"><code>			return "", fmt.Errorf("mail: invalid utf-8 in address: %q", p.s)</code></span>
<span class="codeline" id="line-683"><code></code></span>
<span class="codeline" id="line-684"><code>		case size == 0 || !isAtext(r, dot):</code></span>
<span class="codeline" id="line-685"><code>			break Loop</code></span>
<span class="codeline" id="line-686"><code></code></span>
<span class="codeline" id="line-687"><code>		default:</code></span>
<span class="codeline" id="line-688"><code>			i += size</code></span>
<span class="codeline" id="line-689"><code></code></span>
<span class="codeline" id="line-690"><code>		}</code></span>
<span class="codeline" id="line-691"><code>	}</code></span>
<span class="codeline" id="line-692"><code></code></span>
<span class="codeline" id="line-693"><code>	if i == 0 {</code></span>
<span class="codeline" id="line-694"><code>		return "", errors.New("mail: invalid string")</code></span>
<span class="codeline" id="line-695"><code>	}</code></span>
<span class="codeline" id="line-696"><code>	atom, p.s = p.s[:i], p.s[i:]</code></span>
<span class="codeline" id="line-697"><code>	if !permissive {</code></span>
<span class="codeline" id="line-698"><code>		if strings.HasPrefix(atom, ".") {</code></span>
<span class="codeline" id="line-699"><code>			return "", errors.New("mail: leading dot in atom")</code></span>
<span class="codeline" id="line-700"><code>		}</code></span>
<span class="codeline" id="line-701"><code>		if strings.Contains(atom, "..") {</code></span>
<span class="codeline" id="line-702"><code>			return "", errors.New("mail: double dot in atom")</code></span>
<span class="codeline" id="line-703"><code>		}</code></span>
<span class="codeline" id="line-704"><code>		if strings.HasSuffix(atom, ".") {</code></span>
<span class="codeline" id="line-705"><code>			return "", errors.New("mail: trailing dot in atom")</code></span>
<span class="codeline" id="line-706"><code>		}</code></span>
<span class="codeline" id="line-707"><code>	}</code></span>
<span class="codeline" id="line-708"><code>	return atom, nil</code></span>
<span class="codeline" id="line-709"><code>}</code></span>
<span class="codeline" id="line-710"><code></code></span>
<span class="codeline" id="line-711"><code>func (p *addrParser) consumeDisplayNameComment() (string, error) {</code></span>
<span class="codeline" id="line-712"><code>	if !p.consume('(') {</code></span>
<span class="codeline" id="line-713"><code>		return "", errors.New("mail: comment does not start with (")</code></span>
<span class="codeline" id="line-714"><code>	}</code></span>
<span class="codeline" id="line-715"><code>	comment, ok := p.consumeComment()</code></span>
<span class="codeline" id="line-716"><code>	if !ok {</code></span>
<span class="codeline" id="line-717"><code>		return "", errors.New("mail: misformatted parenthetical comment")</code></span>
<span class="codeline" id="line-718"><code>	}</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>	// TODO(stapelberg): parse quoted-string within comment</code></span>
<span class="codeline" id="line-721"><code>	words := strings.FieldsFunc(comment, func(r rune) bool { return r == ' ' || r == '\t' })</code></span>
<span class="codeline" id="line-722"><code>	for idx, word := range words {</code></span>
<span class="codeline" id="line-723"><code>		decoded, isEncoded, err := p.decodeRFC2047Word(word)</code></span>
<span class="codeline" id="line-724"><code>		if err != nil {</code></span>
<span class="codeline" id="line-725"><code>			return "", err</code></span>
<span class="codeline" id="line-726"><code>		}</code></span>
<span class="codeline" id="line-727"><code>		if isEncoded {</code></span>
<span class="codeline" id="line-728"><code>			words[idx] = decoded</code></span>
<span class="codeline" id="line-729"><code>		}</code></span>
<span class="codeline" id="line-730"><code>	}</code></span>
<span class="codeline" id="line-731"><code></code></span>
<span class="codeline" id="line-732"><code>	return strings.Join(words, " "), nil</code></span>
<span class="codeline" id="line-733"><code>}</code></span>
<span class="codeline" id="line-734"><code></code></span>
<span class="codeline" id="line-735"><code>func (p *addrParser) consume(c byte) bool {</code></span>
<span class="codeline" id="line-736"><code>	if p.empty() || p.peek() != c {</code></span>
<span class="codeline" id="line-737"><code>		return false</code></span>
<span class="codeline" id="line-738"><code>	}</code></span>
<span class="codeline" id="line-739"><code>	p.s = p.s[1:]</code></span>
<span class="codeline" id="line-740"><code>	return true</code></span>
<span class="codeline" id="line-741"><code>}</code></span>
<span class="codeline" id="line-742"><code></code></span>
<span class="codeline" id="line-743"><code>// skipSpace skips the leading space and tab characters.</code></span>
<span class="codeline" id="line-744"><code>func (p *addrParser) skipSpace() {</code></span>
<span class="codeline" id="line-745"><code>	p.s = strings.TrimLeft(p.s, " \t")</code></span>
<span class="codeline" id="line-746"><code>}</code></span>
<span class="codeline" id="line-747"><code></code></span>
<span class="codeline" id="line-748"><code>func (p *addrParser) peek() byte {</code></span>
<span class="codeline" id="line-749"><code>	return p.s[0]</code></span>
<span class="codeline" id="line-750"><code>}</code></span>
<span class="codeline" id="line-751"><code></code></span>
<span class="codeline" id="line-752"><code>func (p *addrParser) empty() bool {</code></span>
<span class="codeline" id="line-753"><code>	return p.len() == 0</code></span>
<span class="codeline" id="line-754"><code>}</code></span>
<span class="codeline" id="line-755"><code></code></span>
<span class="codeline" id="line-756"><code>func (p *addrParser) len() int {</code></span>
<span class="codeline" id="line-757"><code>	return len(p.s)</code></span>
<span class="codeline" id="line-758"><code>}</code></span>
<span class="codeline" id="line-759"><code></code></span>
<span class="codeline" id="line-760"><code>// skipCFWS skips CFWS as defined in RFC5322.</code></span>
<span class="codeline" id="line-761"><code>func (p *addrParser) skipCFWS() bool {</code></span>
<span class="codeline" id="line-762"><code>	p.skipSpace()</code></span>
<span class="codeline" id="line-763"><code></code></span>
<span class="codeline" id="line-764"><code>	for {</code></span>
<span class="codeline" id="line-765"><code>		if !p.consume('(') {</code></span>
<span class="codeline" id="line-766"><code>			break</code></span>
<span class="codeline" id="line-767"><code>		}</code></span>
<span class="codeline" id="line-768"><code></code></span>
<span class="codeline" id="line-769"><code>		if _, ok := p.consumeComment(); !ok {</code></span>
<span class="codeline" id="line-770"><code>			return false</code></span>
<span class="codeline" id="line-771"><code>		}</code></span>
<span class="codeline" id="line-772"><code></code></span>
<span class="codeline" id="line-773"><code>		p.skipSpace()</code></span>
<span class="codeline" id="line-774"><code>	}</code></span>
<span class="codeline" id="line-775"><code></code></span>
<span class="codeline" id="line-776"><code>	return true</code></span>
<span class="codeline" id="line-777"><code>}</code></span>
<span class="codeline" id="line-778"><code></code></span>
<span class="codeline" id="line-779"><code>func (p *addrParser) consumeComment() (string, bool) {</code></span>
<span class="codeline" id="line-780"><code>	// '(' already consumed.</code></span>
<span class="codeline" id="line-781"><code>	depth := 1</code></span>
<span class="codeline" id="line-782"><code></code></span>
<span class="codeline" id="line-783"><code>	var comment string</code></span>
<span class="codeline" id="line-784"><code>	for {</code></span>
<span class="codeline" id="line-785"><code>		if p.empty() || depth == 0 {</code></span>
<span class="codeline" id="line-786"><code>			break</code></span>
<span class="codeline" id="line-787"><code>		}</code></span>
<span class="codeline" id="line-788"><code></code></span>
<span class="codeline" id="line-789"><code>		if p.peek() == '\\' &amp;&amp; p.len() &gt; 1 {</code></span>
<span class="codeline" id="line-790"><code>			p.s = p.s[1:]</code></span>
<span class="codeline" id="line-791"><code>		} else if p.peek() == '(' {</code></span>
<span class="codeline" id="line-792"><code>			depth++</code></span>
<span class="codeline" id="line-793"><code>		} else if p.peek() == ')' {</code></span>
<span class="codeline" id="line-794"><code>			depth--</code></span>
<span class="codeline" id="line-795"><code>		}</code></span>
<span class="codeline" id="line-796"><code>		if depth &gt; 0 {</code></span>
<span class="codeline" id="line-797"><code>			comment += p.s[:1]</code></span>
<span class="codeline" id="line-798"><code>		}</code></span>
<span class="codeline" id="line-799"><code>		p.s = p.s[1:]</code></span>
<span class="codeline" id="line-800"><code>	}</code></span>
<span class="codeline" id="line-801"><code></code></span>
<span class="codeline" id="line-802"><code>	return comment, depth == 0</code></span>
<span class="codeline" id="line-803"><code>}</code></span>
<span class="codeline" id="line-804"><code></code></span>
<span class="codeline" id="line-805"><code>func (p *addrParser) decodeRFC2047Word(s string) (word string, isEncoded bool, err error) {</code></span>
<span class="codeline" id="line-806"><code>	dec := p.dec</code></span>
<span class="codeline" id="line-807"><code>	if dec == nil {</code></span>
<span class="codeline" id="line-808"><code>		dec = &amp;rfc2047Decoder</code></span>
<span class="codeline" id="line-809"><code>	}</code></span>
<span class="codeline" id="line-810"><code></code></span>
<span class="codeline" id="line-811"><code>	// Substitute our own CharsetReader function so that we can tell</code></span>
<span class="codeline" id="line-812"><code>	// whether an error from the Decode method was due to the</code></span>
<span class="codeline" id="line-813"><code>	// CharsetReader (meaning the charset is invalid).</code></span>
<span class="codeline" id="line-814"><code>	// We used to look for the charsetError type in the error result,</code></span>
<span class="codeline" id="line-815"><code>	// but that behaves badly with CharsetReaders other than the</code></span>
<span class="codeline" id="line-816"><code>	// one in rfc2047Decoder.</code></span>
<span class="codeline" id="line-817"><code>	adec := *dec</code></span>
<span class="codeline" id="line-818"><code>	charsetReaderError := false</code></span>
<span class="codeline" id="line-819"><code>	adec.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {</code></span>
<span class="codeline" id="line-820"><code>		if dec.CharsetReader == nil {</code></span>
<span class="codeline" id="line-821"><code>			charsetReaderError = true</code></span>
<span class="codeline" id="line-822"><code>			return nil, charsetError(charset)</code></span>
<span class="codeline" id="line-823"><code>		}</code></span>
<span class="codeline" id="line-824"><code>		r, err := dec.CharsetReader(charset, input)</code></span>
<span class="codeline" id="line-825"><code>		if err != nil {</code></span>
<span class="codeline" id="line-826"><code>			charsetReaderError = true</code></span>
<span class="codeline" id="line-827"><code>		}</code></span>
<span class="codeline" id="line-828"><code>		return r, err</code></span>
<span class="codeline" id="line-829"><code>	}</code></span>
<span class="codeline" id="line-830"><code>	word, err = adec.Decode(s)</code></span>
<span class="codeline" id="line-831"><code>	if err == nil {</code></span>
<span class="codeline" id="line-832"><code>		return word, true, nil</code></span>
<span class="codeline" id="line-833"><code>	}</code></span>
<span class="codeline" id="line-834"><code></code></span>
<span class="codeline" id="line-835"><code>	// If the error came from the character set reader</code></span>
<span class="codeline" id="line-836"><code>	// (meaning the character set itself is invalid</code></span>
<span class="codeline" id="line-837"><code>	// but the decoding worked fine until then),</code></span>
<span class="codeline" id="line-838"><code>	// return the original text and the error,</code></span>
<span class="codeline" id="line-839"><code>	// with isEncoded=true.</code></span>
<span class="codeline" id="line-840"><code>	if charsetReaderError {</code></span>
<span class="codeline" id="line-841"><code>		return s, true, err</code></span>
<span class="codeline" id="line-842"><code>	}</code></span>
<span class="codeline" id="line-843"><code></code></span>
<span class="codeline" id="line-844"><code>	// Ignore invalid RFC 2047 encoded-word errors.</code></span>
<span class="codeline" id="line-845"><code>	return s, false, nil</code></span>
<span class="codeline" id="line-846"><code>}</code></span>
<span class="codeline" id="line-847"><code></code></span>
<span class="codeline" id="line-848"><code>var rfc2047Decoder = mime.WordDecoder{</code></span>
<span class="codeline" id="line-849"><code>	CharsetReader: func(charset string, input io.Reader) (io.Reader, error) {</code></span>
<span class="codeline" id="line-850"><code>		return nil, charsetError(charset)</code></span>
<span class="codeline" id="line-851"><code>	},</code></span>
<span class="codeline" id="line-852"><code>}</code></span>
<span class="codeline" id="line-853"><code></code></span>
<span class="codeline" id="line-854"><code>type charsetError string</code></span>
<span class="codeline" id="line-855"><code></code></span>
<span class="codeline" id="line-856"><code>func (e charsetError) Error() string {</code></span>
<span class="codeline" id="line-857"><code>	return fmt.Sprintf("charset not supported: %q", string(e))</code></span>
<span class="codeline" id="line-858"><code>}</code></span>
<span class="codeline" id="line-859"><code></code></span>
<span class="codeline" id="line-860"><code>// isAtext reports whether r is an RFC 5322 atext character.</code></span>
<span class="codeline" id="line-861"><code>// If dot is true, period is included.</code></span>
<span class="codeline" id="line-862"><code>func isAtext(r rune, dot bool) bool {</code></span>
<span class="codeline" id="line-863"><code>	switch r {</code></span>
<span class="codeline" id="line-864"><code>	case '.':</code></span>
<span class="codeline" id="line-865"><code>		return dot</code></span>
<span class="codeline" id="line-866"><code></code></span>
<span class="codeline" id="line-867"><code>	// RFC 5322 3.2.3. specials</code></span>
<span class="codeline" id="line-868"><code>	case '(', ')', '&lt;', '&gt;', '[', ']', ':', ';', '@', '\\', ',', '"': // RFC 5322 3.2.3. specials</code></span>
<span class="codeline" id="line-869"><code>		return false</code></span>
<span class="codeline" id="line-870"><code>	}</code></span>
<span class="codeline" id="line-871"><code>	return isVchar(r)</code></span>
<span class="codeline" id="line-872"><code>}</code></span>
<span class="codeline" id="line-873"><code></code></span>
<span class="codeline" id="line-874"><code>// isQtext reports whether r is an RFC 5322 qtext character.</code></span>
<span class="codeline" id="line-875"><code>func isQtext(r rune) bool {</code></span>
<span class="codeline" id="line-876"><code>	// Printable US-ASCII, excluding backslash or quote.</code></span>
<span class="codeline" id="line-877"><code>	if r == '\\' || r == '"' {</code></span>
<span class="codeline" id="line-878"><code>		return false</code></span>
<span class="codeline" id="line-879"><code>	}</code></span>
<span class="codeline" id="line-880"><code>	return isVchar(r)</code></span>
<span class="codeline" id="line-881"><code>}</code></span>
<span class="codeline" id="line-882"><code></code></span>
<span class="codeline" id="line-883"><code>// quoteString renders a string as an RFC 5322 quoted-string.</code></span>
<span class="codeline" id="line-884"><code>func quoteString(s string) string {</code></span>
<span class="codeline" id="line-885"><code>	var b strings.Builder</code></span>
<span class="codeline" id="line-886"><code>	b.WriteByte('"')</code></span>
<span class="codeline" id="line-887"><code>	for _, r := range s {</code></span>
<span class="codeline" id="line-888"><code>		if isQtext(r) || isWSP(r) {</code></span>
<span class="codeline" id="line-889"><code>			b.WriteRune(r)</code></span>
<span class="codeline" id="line-890"><code>		} else if isVchar(r) {</code></span>
<span class="codeline" id="line-891"><code>			b.WriteByte('\\')</code></span>
<span class="codeline" id="line-892"><code>			b.WriteRune(r)</code></span>
<span class="codeline" id="line-893"><code>		}</code></span>
<span class="codeline" id="line-894"><code>	}</code></span>
<span class="codeline" id="line-895"><code>	b.WriteByte('"')</code></span>
<span class="codeline" id="line-896"><code>	return b.String()</code></span>
<span class="codeline" id="line-897"><code>}</code></span>
<span class="codeline" id="line-898"><code></code></span>
<span class="codeline" id="line-899"><code>// isVchar reports whether r is an RFC 5322 VCHAR character.</code></span>
<span class="codeline" id="line-900"><code>func isVchar(r rune) bool {</code></span>
<span class="codeline" id="line-901"><code>	// Visible (printing) characters.</code></span>
<span class="codeline" id="line-902"><code>	return '!' &lt;= r &amp;&amp; r &lt;= '~' || isMultibyte(r)</code></span>
<span class="codeline" id="line-903"><code>}</code></span>
<span class="codeline" id="line-904"><code></code></span>
<span class="codeline" id="line-905"><code>// isMultibyte reports whether r is a multi-byte UTF-8 character</code></span>
<span class="codeline" id="line-906"><code>// as supported by RFC 6532.</code></span>
<span class="codeline" id="line-907"><code>func isMultibyte(r rune) bool {</code></span>
<span class="codeline" id="line-908"><code>	return r &gt;= utf8.RuneSelf</code></span>
<span class="codeline" id="line-909"><code>}</code></span>
<span class="codeline" id="line-910"><code></code></span>
<span class="codeline" id="line-911"><code>// isWSP reports whether r is a WSP (white space).</code></span>
<span class="codeline" id="line-912"><code>// WSP is a space or horizontal tab (RFC 5234 Appendix B).</code></span>
<span class="codeline" id="line-913"><code>func isWSP(r rune) bool {</code></span>
<span class="codeline" id="line-914"><code>	return r == ' ' || r == '\t'</code></span>
<span class="codeline" id="line-915"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>