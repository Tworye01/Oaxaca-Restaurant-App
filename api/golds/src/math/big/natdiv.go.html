<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: natdiv.go in package math/big</title>
<link href="../../../css/dark-v0.6.8.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.6.8.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	natdiv.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/math/big.html">math/big</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code>// Copyright 2009 The Go Authors. All rights reserved.</code></span>
<span class="codeline" id="line-2"><code>// Use of this source code is governed by a BSD-style</code></span>
<span class="codeline" id="line-3"><code>// license that can be found in the LICENSE file.</code></span>
<span class="codeline" id="line-4"><code></code></span>
<span class="codeline" id="line-5"><code>/*</code></span>
<span class="codeline" id="line-6"><code></code></span>
<span class="codeline" id="line-7"><code>Multi-precision division. Here be dragons.</code></span>
<span class="codeline" id="line-8"><code></code></span>
<span class="codeline" id="line-9"><code>Given u and v, where u is n+m digits, and v is n digits (with no leading zeros),</code></span>
<span class="codeline" id="line-10"><code>the goal is to return quo, rem such that u = quo*v + rem, where 0 ≤ rem &lt; v.</code></span>
<span class="codeline" id="line-11"><code>That is, quo = ⌊u/v⌋ where ⌊x⌋ denotes the floor (truncation to integer) of x,</code></span>
<span class="codeline" id="line-12"><code>and rem = u - quo·v.</code></span>
<span class="codeline" id="line-13"><code></code></span>
<span class="codeline" id="line-14"><code></code></span>
<span class="codeline" id="line-15"><code>Long Division</code></span>
<span class="codeline" id="line-16"><code></code></span>
<span class="codeline" id="line-17"><code>Division in a computer proceeds the same as long division in elementary school,</code></span>
<span class="codeline" id="line-18"><code>but computers are not as good as schoolchildren at following vague directions,</code></span>
<span class="codeline" id="line-19"><code>so we have to be much more precise about the actual steps and what can happen.</code></span>
<span class="codeline" id="line-20"><code></code></span>
<span class="codeline" id="line-21"><code>We work from most to least significant digit of the quotient, doing:</code></span>
<span class="codeline" id="line-22"><code></code></span>
<span class="codeline" id="line-23"><code> • Guess a digit q, the number of v to subtract from the current</code></span>
<span class="codeline" id="line-24"><code>   section of u to zero out the topmost digit.</code></span>
<span class="codeline" id="line-25"><code> • Check the guess by multiplying q·v and comparing it against</code></span>
<span class="codeline" id="line-26"><code>   the current section of u, adjusting the guess as needed.</code></span>
<span class="codeline" id="line-27"><code> • Subtract q·v from the current section of u.</code></span>
<span class="codeline" id="line-28"><code> • Add q to the corresponding section of the result quo.</code></span>
<span class="codeline" id="line-29"><code></code></span>
<span class="codeline" id="line-30"><code>When all digits have been processed, the final remainder is left in u</code></span>
<span class="codeline" id="line-31"><code>and returned as rem.</code></span>
<span class="codeline" id="line-32"><code></code></span>
<span class="codeline" id="line-33"><code>For example, here is a sketch of dividing 5 digits by 3 digits (n=3, m=2).</code></span>
<span class="codeline" id="line-34"><code></code></span>
<span class="codeline" id="line-35"><code>	                 q₂ q₁ q₀</code></span>
<span class="codeline" id="line-36"><code>	         _________________</code></span>
<span class="codeline" id="line-37"><code>	v₂ v₁ v₀ ) u₄ u₃ u₂ u₁ u₀</code></span>
<span class="codeline" id="line-38"><code>	           ↓  ↓  ↓  |  |</code></span>
<span class="codeline" id="line-39"><code>	          [u₄ u₃ u₂]|  |</code></span>
<span class="codeline" id="line-40"><code>	        - [  q₂·v  ]|  |</code></span>
<span class="codeline" id="line-41"><code>	        ----------- ↓  |</code></span>
<span class="codeline" id="line-42"><code>	          [  rem  | u₁]|</code></span>
<span class="codeline" id="line-43"><code>	        - [    q₁·v   ]|</code></span>
<span class="codeline" id="line-44"><code>	           ----------- ↓</code></span>
<span class="codeline" id="line-45"><code>	             [  rem  | u₀]</code></span>
<span class="codeline" id="line-46"><code>	           - [    q₀·v   ]</code></span>
<span class="codeline" id="line-47"><code>	              ------------</code></span>
<span class="codeline" id="line-48"><code>	                [  rem   ]</code></span>
<span class="codeline" id="line-49"><code></code></span>
<span class="codeline" id="line-50"><code>Instead of creating new storage for the remainders and copying digits from u</code></span>
<span class="codeline" id="line-51"><code>as indicated by the arrows, we use u's storage directly as both the source</code></span>
<span class="codeline" id="line-52"><code>and destination of the subtractions, so that the remainders overwrite</code></span>
<span class="codeline" id="line-53"><code>successive overlapping sections of u as the division proceeds, using a slice</code></span>
<span class="codeline" id="line-54"><code>of u to identify the current section. This avoids all the copying as well as</code></span>
<span class="codeline" id="line-55"><code>shifting of remainders.</code></span>
<span class="codeline" id="line-56"><code></code></span>
<span class="codeline" id="line-57"><code>Division of u with n+m digits by v with n digits (in base B) can in general</code></span>
<span class="codeline" id="line-58"><code>produce at most m+1 digits, because:</code></span>
<span class="codeline" id="line-59"><code></code></span>
<span class="codeline" id="line-60"><code>  • u &lt; B^(n+m)               [B^(n+m) has n+m+1 digits]</code></span>
<span class="codeline" id="line-61"><code>  • v ≥ B^(n-1)               [B^(n-1) is the smallest n-digit number]</code></span>
<span class="codeline" id="line-62"><code>  • u/v &lt; B^(n+m) / B^(n-1)   [divide bounds for u, v]</code></span>
<span class="codeline" id="line-63"><code>  • u/v &lt; B^(m+1)             [simplify]</code></span>
<span class="codeline" id="line-64"><code></code></span>
<span class="codeline" id="line-65"><code>The first step is special: it takes the top n digits of u and divides them by</code></span>
<span class="codeline" id="line-66"><code>the n digits of v, producing the first quotient digit and an n-digit remainder.</code></span>
<span class="codeline" id="line-67"><code>In the example, q₂ = ⌊u₄u₃u₂ / v⌋.</code></span>
<span class="codeline" id="line-68"><code></code></span>
<span class="codeline" id="line-69"><code>The first step divides n digits by n digits to ensure that it produces only a</code></span>
<span class="codeline" id="line-70"><code>single digit.</code></span>
<span class="codeline" id="line-71"><code></code></span>
<span class="codeline" id="line-72"><code>Each subsequent step appends the next digit from u to the remainder and divides</code></span>
<span class="codeline" id="line-73"><code>those n+1 digits by the n digits of v, producing another quotient digit and a</code></span>
<span class="codeline" id="line-74"><code>new n-digit remainder.</code></span>
<span class="codeline" id="line-75"><code></code></span>
<span class="codeline" id="line-76"><code>Subsequent steps divide n+1 digits by n digits, an operation that in general</code></span>
<span class="codeline" id="line-77"><code>might produce two digits. However, as used in the algorithm, that division is</code></span>
<span class="codeline" id="line-78"><code>guaranteed to produce only a single digit. The dividend is of the form</code></span>
<span class="codeline" id="line-79"><code>rem·B + d, where rem is a remainder from the previous step and d is a single</code></span>
<span class="codeline" id="line-80"><code>digit, so:</code></span>
<span class="codeline" id="line-81"><code></code></span>
<span class="codeline" id="line-82"><code> • rem ≤ v - 1                 [rem is a remainder from dividing by v]</code></span>
<span class="codeline" id="line-83"><code> • rem·B ≤ v·B - B             [multiply by B]</code></span>
<span class="codeline" id="line-84"><code> • d ≤ B - 1                   [d is a single digit]</code></span>
<span class="codeline" id="line-85"><code> • rem·B + d ≤ v·B - 1         [add]</code></span>
<span class="codeline" id="line-86"><code> • rem·B + d &lt; v·B             [change ≤ to &lt;]</code></span>
<span class="codeline" id="line-87"><code> • (rem·B + d)/v &lt; B           [divide by v]</code></span>
<span class="codeline" id="line-88"><code></code></span>
<span class="codeline" id="line-89"><code></code></span>
<span class="codeline" id="line-90"><code>Guess and Check</code></span>
<span class="codeline" id="line-91"><code></code></span>
<span class="codeline" id="line-92"><code>At each step we need to divide n+1 digits by n digits, but this is for the</code></span>
<span class="codeline" id="line-93"><code>implementation of division by n digits, so we can't just invoke a division</code></span>
<span class="codeline" id="line-94"><code>routine: we _are_ the division routine. Instead, we guess at the answer and</code></span>
<span class="codeline" id="line-95"><code>then check it using multiplication. If the guess is wrong, we correct it.</code></span>
<span class="codeline" id="line-96"><code></code></span>
<span class="codeline" id="line-97"><code>How can this guessing possibly be efficient? It turns out that the following</code></span>
<span class="codeline" id="line-98"><code>statement (let's call it the Good Guess Guarantee) is true.</code></span>
<span class="codeline" id="line-99"><code></code></span>
<span class="codeline" id="line-100"><code>If</code></span>
<span class="codeline" id="line-101"><code></code></span>
<span class="codeline" id="line-102"><code> • q = ⌊u/v⌋ where u is n+1 digits and v is n digits,</code></span>
<span class="codeline" id="line-103"><code> • q &lt; B, and</code></span>
<span class="codeline" id="line-104"><code> • the topmost digit of v = vₙ₋₁ ≥ B/2,</code></span>
<span class="codeline" id="line-105"><code></code></span>
<span class="codeline" id="line-106"><code>then q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ satisfies q ≤ q̂ ≤ q+2. (Proof below.)</code></span>
<span class="codeline" id="line-107"><code></code></span>
<span class="codeline" id="line-108"><code>That is, if we know the answer has only a single digit and we guess an answer</code></span>
<span class="codeline" id="line-109"><code>by ignoring the bottom n-1 digits of u and v, using a 2-by-1-digit division,</code></span>
<span class="codeline" id="line-110"><code>then that guess is at least as large as the correct answer. It is also not</code></span>
<span class="codeline" id="line-111"><code>too much larger: it is off by at most two from the correct answer.</code></span>
<span class="codeline" id="line-112"><code></code></span>
<span class="codeline" id="line-113"><code>Note that in the first step of the overall division, which is an n-by-n-digit</code></span>
<span class="codeline" id="line-114"><code>division, the 2-by-1 guess uses an implicit uₙ = 0.</code></span>
<span class="codeline" id="line-115"><code></code></span>
<span class="codeline" id="line-116"><code>Note that using a 2-by-1-digit division here does not mean calling ourselves</code></span>
<span class="codeline" id="line-117"><code>recursively. Instead, we use an efficient direct hardware implementation of</code></span>
<span class="codeline" id="line-118"><code>that operation.</code></span>
<span class="codeline" id="line-119"><code></code></span>
<span class="codeline" id="line-120"><code>Note that because q is u/v rounded down, q·v must not exceed u: u ≥ q·v.</code></span>
<span class="codeline" id="line-121"><code>If a guess q̂ is too big, it will not satisfy this test. Viewed a different way,</code></span>
<span class="codeline" id="line-122"><code>the remainder r̂ for a given q̂ is u - q̂·v, which must be positive. If it is</code></span>
<span class="codeline" id="line-123"><code>negative, then the guess q̂ is too big.</code></span>
<span class="codeline" id="line-124"><code></code></span>
<span class="codeline" id="line-125"><code>This gives us a way to compute q. First compute q̂ with 2-by-1-digit division.</code></span>
<span class="codeline" id="line-126"><code>Then, while u &lt; q̂·v, decrement q̂; this loop executes at most twice, because</code></span>
<span class="codeline" id="line-127"><code>q̂ ≤ q+2.</code></span>
<span class="codeline" id="line-128"><code></code></span>
<span class="codeline" id="line-129"><code></code></span>
<span class="codeline" id="line-130"><code>Scaling Inputs</code></span>
<span class="codeline" id="line-131"><code></code></span>
<span class="codeline" id="line-132"><code>The Good Guess Guarantee requires that the top digit of v (vₙ₋₁) be at least B/2.</code></span>
<span class="codeline" id="line-133"><code>For example in base 10, ⌊172/19⌋ = 9, but ⌊18/1⌋ = 18: the guess is wildly off</code></span>
<span class="codeline" id="line-134"><code>because the first digit 1 is smaller than B/2 = 5.</code></span>
<span class="codeline" id="line-135"><code></code></span>
<span class="codeline" id="line-136"><code>We can ensure that v has a large top digit by multiplying both u and v by the</code></span>
<span class="codeline" id="line-137"><code>right amount. Continuing the example, if we multiply both 172 and 19 by 3, we</code></span>
<span class="codeline" id="line-138"><code>now have ⌊516/57⌋, the leading digit of v is now ≥ 5, and sure enough</code></span>
<span class="codeline" id="line-139"><code>⌊51/5⌋ = 10 is much closer to the correct answer 9. It would be easier here</code></span>
<span class="codeline" id="line-140"><code>to multiply by 4, because that can be done with a shift. Specifically, we can</code></span>
<span class="codeline" id="line-141"><code>always count the number of leading zeros i in the first digit of v and then</code></span>
<span class="codeline" id="line-142"><code>shift both u and v left by i bits.</code></span>
<span class="codeline" id="line-143"><code></code></span>
<span class="codeline" id="line-144"><code>Having scaled u and v, the value ⌊u/v⌋ is unchanged, but the remainder will</code></span>
<span class="codeline" id="line-145"><code>be scaled: 172 mod 19 is 1, but 516 mod 57 is 3. We have to divide the remainder</code></span>
<span class="codeline" id="line-146"><code>by the scaling factor (shifting right i bits) when we finish.</code></span>
<span class="codeline" id="line-147"><code></code></span>
<span class="codeline" id="line-148"><code>Note that these shifts happen before and after the entire division algorithm,</code></span>
<span class="codeline" id="line-149"><code>not at each step in the per-digit iteration.</code></span>
<span class="codeline" id="line-150"><code></code></span>
<span class="codeline" id="line-151"><code>Note the effect of scaling inputs on the size of the possible quotient.</code></span>
<span class="codeline" id="line-152"><code>In the scaled u/v, u can gain a digit from scaling; v never does, because we</code></span>
<span class="codeline" id="line-153"><code>pick the scaling factor to make v's top digit larger but without overflowing.</code></span>
<span class="codeline" id="line-154"><code>If u and v have n+m and n digits after scaling, then:</code></span>
<span class="codeline" id="line-155"><code></code></span>
<span class="codeline" id="line-156"><code>  • u &lt; B^(n+m)               [B^(n+m) has n+m+1 digits]</code></span>
<span class="codeline" id="line-157"><code>  • v ≥ B^n / 2               [vₙ₋₁ ≥ B/2, so vₙ₋₁·B^(n-1) ≥ B^n/2]</code></span>
<span class="codeline" id="line-158"><code>  • u/v &lt; B^(n+m) / (B^n / 2) [divide bounds for u, v]</code></span>
<span class="codeline" id="line-159"><code>  • u/v &lt; 2 B^m               [simplify]</code></span>
<span class="codeline" id="line-160"><code></code></span>
<span class="codeline" id="line-161"><code>The quotient can still have m+1 significant digits, but if so the top digit</code></span>
<span class="codeline" id="line-162"><code>must be a 1. This provides a different way to handle the first digit of the</code></span>
<span class="codeline" id="line-163"><code>result: compare the top n digits of u against v and fill in either a 0 or a 1.</code></span>
<span class="codeline" id="line-164"><code></code></span>
<span class="codeline" id="line-165"><code></code></span>
<span class="codeline" id="line-166"><code>Refining Guesses</code></span>
<span class="codeline" id="line-167"><code></code></span>
<span class="codeline" id="line-168"><code>Before we check whether u &lt; q̂·v, we can adjust our guess to change it from</code></span>
<span class="codeline" id="line-169"><code>q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ into the refined guess ⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋.</code></span>
<span class="codeline" id="line-170"><code>Although not mentioned above, the Good Guess Guarantee also promises that this</code></span>
<span class="codeline" id="line-171"><code>3-by-2-digit division guess is more precise and at most one away from the real</code></span>
<span class="codeline" id="line-172"><code>answer q. The improvement from the 2-by-1 to the 3-by-2 guess can also be done</code></span>
<span class="codeline" id="line-173"><code>without n-digit math.</code></span>
<span class="codeline" id="line-174"><code></code></span>
<span class="codeline" id="line-175"><code>If we have a guess q̂ = ⌊uₙuₙ₋₁ / vₙ₋₁⌋ and we want to see if it also equal to</code></span>
<span class="codeline" id="line-176"><code>⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋, we can use the same check we would for the full division:</code></span>
<span class="codeline" id="line-177"><code>if uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂, then the guess is too large and should be reduced.</code></span>
<span class="codeline" id="line-178"><code></code></span>
<span class="codeline" id="line-179"><code>Checking uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂ is the same as uₙuₙ₋₁uₙ₋₂ - q̂·vₙ₋₁vₙ₋₂ &lt; 0,</code></span>
<span class="codeline" id="line-180"><code>and</code></span>
<span class="codeline" id="line-181"><code></code></span>
<span class="codeline" id="line-182"><code>	uₙuₙ₋₁uₙ₋₂ - q̂·vₙ₋₁vₙ₋₂ = (uₙuₙ₋₁·B + uₙ₋₂) - q̂·(vₙ₋₁·B + vₙ₋₂)</code></span>
<span class="codeline" id="line-183"><code>	                          [splitting off the bottom digit]</code></span>
<span class="codeline" id="line-184"><code>	                      = (uₙuₙ₋₁ - q̂·vₙ₋₁)·B + uₙ₋₂ - q̂·vₙ₋₂</code></span>
<span class="codeline" id="line-185"><code>	                          [regrouping]</code></span>
<span class="codeline" id="line-186"><code></code></span>
<span class="codeline" id="line-187"><code>The expression (uₙuₙ₋₁ - q̂·vₙ₋₁) is the remainder of uₙuₙ₋₁ / vₙ₋₁.</code></span>
<span class="codeline" id="line-188"><code>If the initial guess returns both q̂ and its remainder r̂, then checking</code></span>
<span class="codeline" id="line-189"><code>whether uₙuₙ₋₁uₙ₋₂ &lt; q̂·vₙ₋₁vₙ₋₂ is the same as checking r̂·B + uₙ₋₂ &lt; q̂·vₙ₋₂.</code></span>
<span class="codeline" id="line-190"><code></code></span>
<span class="codeline" id="line-191"><code>If we find that r̂·B + uₙ₋₂ &lt; q̂·vₙ₋₂, then we can adjust the guess by</code></span>
<span class="codeline" id="line-192"><code>decrementing q̂ and adding vₙ₋₁ to r̂. We repeat until r̂·B + uₙ₋₂ ≥ q̂·vₙ₋₂.</code></span>
<span class="codeline" id="line-193"><code>(As before, this fixup is only needed at most twice.)</code></span>
<span class="codeline" id="line-194"><code></code></span>
<span class="codeline" id="line-195"><code>Now that q̂ = ⌊uₙuₙ₋₁uₙ₋₂ / vₙ₋₁vₙ₋₂⌋, as mentioned above it is at most one</code></span>
<span class="codeline" id="line-196"><code>away from the correct q, and we've avoided doing any n-digit math.</code></span>
<span class="codeline" id="line-197"><code>(If we need the new remainder, it can be computed as r̂·B + uₙ₋₂ - q̂·vₙ₋₂.)</code></span>
<span class="codeline" id="line-198"><code></code></span>
<span class="codeline" id="line-199"><code>The final check u &lt; q̂·v and the possible fixup must be done at full precision.</code></span>
<span class="codeline" id="line-200"><code>For random inputs, a fixup at this step is exceedingly rare: the 3-by-2 guess</code></span>
<span class="codeline" id="line-201"><code>is not often wrong at all. But still we must do the check. Note that since the</code></span>
<span class="codeline" id="line-202"><code>3-by-2 guess is off by at most 1, it can be convenient to perform the final</code></span>
<span class="codeline" id="line-203"><code>u &lt; q̂·v as part of the computation of the remainder r = u - q̂·v. If the</code></span>
<span class="codeline" id="line-204"><code>subtraction underflows, decremeting q̂ and adding one v back to r is enough to</code></span>
<span class="codeline" id="line-205"><code>arrive at the final q, r.</code></span>
<span class="codeline" id="line-206"><code></code></span>
<span class="codeline" id="line-207"><code>That's the entirety of long division: scale the inputs, and then loop over</code></span>
<span class="codeline" id="line-208"><code>each output position, guessing, checking, and correcting the next output digit.</code></span>
<span class="codeline" id="line-209"><code></code></span>
<span class="codeline" id="line-210"><code>For a 2n-digit number divided by an n-digit number (the worst size-n case for</code></span>
<span class="codeline" id="line-211"><code>division complexity), this algorithm uses n+1 iterations, each of which must do</code></span>
<span class="codeline" id="line-212"><code>at least the 1-by-n-digit multiplication q̂·v. That's O(n) iterations of</code></span>
<span class="codeline" id="line-213"><code>O(n) time each, so O(n²) time overall.</code></span>
<span class="codeline" id="line-214"><code></code></span>
<span class="codeline" id="line-215"><code></code></span>
<span class="codeline" id="line-216"><code>Recursive Division</code></span>
<span class="codeline" id="line-217"><code></code></span>
<span class="codeline" id="line-218"><code>For very large inputs, it is possible to improve on the O(n²) algorithm.</code></span>
<span class="codeline" id="line-219"><code>Let's call a group of n/2 real digits a (very) “wide digit”. We can run the</code></span>
<span class="codeline" id="line-220"><code>standard long division algorithm explained above over the wide digits instead of</code></span>
<span class="codeline" id="line-221"><code>the actual digits. This will result in many fewer steps, but the math involved in</code></span>
<span class="codeline" id="line-222"><code>each step is more work.</code></span>
<span class="codeline" id="line-223"><code></code></span>
<span class="codeline" id="line-224"><code>Where basic long division uses a 2-by-1-digit division to guess the initial q̂,</code></span>
<span class="codeline" id="line-225"><code>the new algorithm must use a 2-by-1-wide-digit division, which is of course</code></span>
<span class="codeline" id="line-226"><code>really an n-by-n/2-digit division. That's OK: if we implement n-digit division</code></span>
<span class="codeline" id="line-227"><code>in terms of n/2-digit division, the recursion will terminate when the divisor</code></span>
<span class="codeline" id="line-228"><code>becomes small enough to handle with standard long division or even with the</code></span>
<span class="codeline" id="line-229"><code>2-by-1 hardware instruction.</code></span>
<span class="codeline" id="line-230"><code></code></span>
<span class="codeline" id="line-231"><code>For example, here is a sketch of dividing 10 digits by 4, proceeding with</code></span>
<span class="codeline" id="line-232"><code>wide digits corresponding to two regular digits. The first step, still special,</code></span>
<span class="codeline" id="line-233"><code>must leave off a (regular) digit, dividing 5 by 4 and producing a 4-digit</code></span>
<span class="codeline" id="line-234"><code>remainder less than v. The middle steps divide 6 digits by 4, guaranteed to</code></span>
<span class="codeline" id="line-235"><code>produce two output digits each (one wide digit) with 4-digit remainders.</code></span>
<span class="codeline" id="line-236"><code>The final step must use what it has: the 4-digit remainder plus one more,</code></span>
<span class="codeline" id="line-237"><code>5 digits to divide by 4.</code></span>
<span class="codeline" id="line-238"><code></code></span>
<span class="codeline" id="line-239"><code>	                       q₆ q₅ q₄ q₃ q₂ q₁ q₀</code></span>
<span class="codeline" id="line-240"><code>	            _______________________________</code></span>
<span class="codeline" id="line-241"><code>	v₃ v₂ v₁ v₀ ) u₉ u₈ u₇ u₆ u₅ u₄ u₃ u₂ u₁ u₀</code></span>
<span class="codeline" id="line-242"><code>	              ↓  ↓  ↓  ↓  ↓  |  |  |  |  |</code></span>
<span class="codeline" id="line-243"><code>	             [u₉ u₈ u₇ u₆ u₅]|  |  |  |  |</code></span>
<span class="codeline" id="line-244"><code>	           - [    q₆q₅·v    ]|  |  |  |  |</code></span>
<span class="codeline" id="line-245"><code>	           ----------------- ↓  ↓  |  |  |</code></span>
<span class="codeline" id="line-246"><code>	                [    rem    |u₄ u₃]|  |  |</code></span>
<span class="codeline" id="line-247"><code>	              - [     q₄q₃·v      ]|  |  |</code></span>
<span class="codeline" id="line-248"><code>	              -------------------- ↓  ↓  |</code></span>
<span class="codeline" id="line-249"><code>	                      [    rem    |u₂ u₁]|</code></span>
<span class="codeline" id="line-250"><code>	                    - [     q₂q₁·v      ]|</code></span>
<span class="codeline" id="line-251"><code>	                    -------------------- ↓</code></span>
<span class="codeline" id="line-252"><code>	                            [    rem    |u₀]</code></span>
<span class="codeline" id="line-253"><code>	                          - [     q₀·v     ]</code></span>
<span class="codeline" id="line-254"><code>	                          ------------------</code></span>
<span class="codeline" id="line-255"><code>	                               [    rem    ]</code></span>
<span class="codeline" id="line-256"><code></code></span>
<span class="codeline" id="line-257"><code>An alternative would be to look ahead to how well n/2 divides into n+m and</code></span>
<span class="codeline" id="line-258"><code>adjust the first step to use fewer digits as needed, making the first step</code></span>
<span class="codeline" id="line-259"><code>more special to make the last step not special at all. For example, using the</code></span>
<span class="codeline" id="line-260"><code>same input, we could choose to use only 4 digits in the first step, leaving</code></span>
<span class="codeline" id="line-261"><code>a full wide digit for the last step:</code></span>
<span class="codeline" id="line-262"><code></code></span>
<span class="codeline" id="line-263"><code>	                       q₆ q₅ q₄ q₃ q₂ q₁ q₀</code></span>
<span class="codeline" id="line-264"><code>	            _______________________________</code></span>
<span class="codeline" id="line-265"><code>	v₃ v₂ v₁ v₀ ) u₉ u₈ u₇ u₆ u₅ u₄ u₃ u₂ u₁ u₀</code></span>
<span class="codeline" id="line-266"><code>	              ↓  ↓  ↓  ↓  |  |  |  |  |  |</code></span>
<span class="codeline" id="line-267"><code>	             [u₉ u₈ u₇ u₆]|  |  |  |  |  |</code></span>
<span class="codeline" id="line-268"><code>	           - [    q₆·v   ]|  |  |  |  |  |</code></span>
<span class="codeline" id="line-269"><code>	           -------------- ↓  ↓  |  |  |  |</code></span>
<span class="codeline" id="line-270"><code>	             [    rem    |u₅ u₄]|  |  |  |</code></span>
<span class="codeline" id="line-271"><code>	           - [     q₅q₄·v      ]|  |  |  |</code></span>
<span class="codeline" id="line-272"><code>	           -------------------- ↓  ↓  |  |</code></span>
<span class="codeline" id="line-273"><code>	                   [    rem    |u₃ u₂]|  |</code></span>
<span class="codeline" id="line-274"><code>	                 - [     q₃q₂·v      ]|  |</code></span>
<span class="codeline" id="line-275"><code>	                 -------------------- ↓  ↓</code></span>
<span class="codeline" id="line-276"><code>	                         [    rem    |u₁ u₀]</code></span>
<span class="codeline" id="line-277"><code>	                       - [     q₁q₀·v      ]</code></span>
<span class="codeline" id="line-278"><code>	                       ---------------------</code></span>
<span class="codeline" id="line-279"><code>	                               [    rem    ]</code></span>
<span class="codeline" id="line-280"><code></code></span>
<span class="codeline" id="line-281"><code>Today, the code in divRecursiveStep works like the first example. Perhaps in</code></span>
<span class="codeline" id="line-282"><code>the future we will make it work like the alternative, to avoid a special case</code></span>
<span class="codeline" id="line-283"><code>in the final iteration.</code></span>
<span class="codeline" id="line-284"><code></code></span>
<span class="codeline" id="line-285"><code>Either way, each step is a 3-by-2-wide-digit division approximated first by</code></span>
<span class="codeline" id="line-286"><code>a 2-by-1-wide-digit division, just as we did for regular digits in long division.</code></span>
<span class="codeline" id="line-287"><code>Because the actual answer we want is a 3-by-2-wide-digit division, instead of</code></span>
<span class="codeline" id="line-288"><code>multiplying q̂·v directly during the fixup, we can use the quick refinement</code></span>
<span class="codeline" id="line-289"><code>from long division (an n/2-by-n/2 multiply) to correct q to its actual value</code></span>
<span class="codeline" id="line-290"><code>and also compute the remainder (as mentioned above), and then stop after that,</code></span>
<span class="codeline" id="line-291"><code>never doing a full n-by-n multiply.</code></span>
<span class="codeline" id="line-292"><code></code></span>
<span class="codeline" id="line-293"><code>Instead of using an n-by-n/2-digit division to produce n/2 digits, we can add</code></span>
<span class="codeline" id="line-294"><code>(not discard) one more real digit, doing an (n+1)-by-(n/2+1)-digit division that</code></span>
<span class="codeline" id="line-295"><code>produces n/2+1 digits. That single extra digit tightens the Good Guess Guarantee</code></span>
<span class="codeline" id="line-296"><code>to q ≤ q̂ ≤ q+1 and lets us drop long division's special treatment of the first</code></span>
<span class="codeline" id="line-297"><code>digit. These benefits are discussed more after the Good Guess Guarantee proof</code></span>
<span class="codeline" id="line-298"><code>below.</code></span>
<span class="codeline" id="line-299"><code></code></span>
<span class="codeline" id="line-300"><code></code></span>
<span class="codeline" id="line-301"><code>How Fast is Recursive Division?</code></span>
<span class="codeline" id="line-302"><code></code></span>
<span class="codeline" id="line-303"><code>For a 2n-by-n-digit division, this algorithm runs a 4-by-2 long division over</code></span>
<span class="codeline" id="line-304"><code>wide digits, producing two wide digits plus a possible leading regular digit 1,</code></span>
<span class="codeline" id="line-305"><code>which can be handled without a recursive call. That is, the algorithm uses two</code></span>
<span class="codeline" id="line-306"><code>full iterations, each using an n-by-n/2-digit division and an n/2-by-n/2-digit</code></span>
<span class="codeline" id="line-307"><code>multiplication, along with a few n-digit additions and subtractions. The standard</code></span>
<span class="codeline" id="line-308"><code>n-by-n-digit multiplication algorithm requires O(n²) time, making the overall</code></span>
<span class="codeline" id="line-309"><code>algorithm require time T(n) where</code></span>
<span class="codeline" id="line-310"><code></code></span>
<span class="codeline" id="line-311"><code>	T(n) = 2T(n/2) + O(n) + O(n²)</code></span>
<span class="codeline" id="line-312"><code></code></span>
<span class="codeline" id="line-313"><code>which, by the Bentley-Haken-Saxe theorem, ends up reducing to T(n) = O(n²).</code></span>
<span class="codeline" id="line-314"><code>This is not an improvement over regular long division.</code></span>
<span class="codeline" id="line-315"><code></code></span>
<span class="codeline" id="line-316"><code>When the number of digits n becomes large enough, Karatsuba's algorithm for</code></span>
<span class="codeline" id="line-317"><code>multiplication can be used instead, which takes O(n^log₂3) = O(n^1.6) time.</code></span>
<span class="codeline" id="line-318"><code>(Karatsuba multiplication is implemented in func karatsuba in nat.go.)</code></span>
<span class="codeline" id="line-319"><code>That makes the overall recursive division algorithm take O(n^1.6) time as well,</code></span>
<span class="codeline" id="line-320"><code>which is an improvement, but again only for large enough numbers.</code></span>
<span class="codeline" id="line-321"><code></code></span>
<span class="codeline" id="line-322"><code>It is not critical to make sure that every recursion does only two recursive</code></span>
<span class="codeline" id="line-323"><code>calls. While in general the number of recursive calls can change the time</code></span>
<span class="codeline" id="line-324"><code>analysis, in this case doing three calls does not change the analysis:</code></span>
<span class="codeline" id="line-325"><code></code></span>
<span class="codeline" id="line-326"><code>	T(n) = 3T(n/2) + O(n) + O(n^log₂3)</code></span>
<span class="codeline" id="line-327"><code></code></span>
<span class="codeline" id="line-328"><code>ends up being T(n) = O(n^log₂3). Because the Karatsuba multiplication taking</code></span>
<span class="codeline" id="line-329"><code>time O(n^log₂3) is itself doing 3 half-sized recursions, doing three for the</code></span>
<span class="codeline" id="line-330"><code>division does not hurt the asymptotic performance. Of course, it is likely</code></span>
<span class="codeline" id="line-331"><code>still faster in practice to do two.</code></span>
<span class="codeline" id="line-332"><code></code></span>
<span class="codeline" id="line-333"><code></code></span>
<span class="codeline" id="line-334"><code>Proof of the Good Guess Guarantee</code></span>
<span class="codeline" id="line-335"><code></code></span>
<span class="codeline" id="line-336"><code>Given numbers x, y, let us break them into the quotients and remainders when</code></span>
<span class="codeline" id="line-337"><code>divided by some scaling factor S, with the added constraints that the quotient</code></span>
<span class="codeline" id="line-338"><code>x/y and the high part of y are both less than some limit T, and that the high</code></span>
<span class="codeline" id="line-339"><code>part of y is at least half as big as T.</code></span>
<span class="codeline" id="line-340"><code></code></span>
<span class="codeline" id="line-341"><code>	x₁ = ⌊x/S⌋        y₁ = ⌊y/S⌋</code></span>
<span class="codeline" id="line-342"><code>	x₀ = x mod S      y₀ = y mod S</code></span>
<span class="codeline" id="line-343"><code></code></span>
<span class="codeline" id="line-344"><code>	x  = x₁·S + x₀    0 ≤ x₀ &lt; S    x/y &lt; T</code></span>
<span class="codeline" id="line-345"><code>	y  = y₁·S + y₀    0 ≤ y₀ &lt; S    T/2 ≤ y₁ &lt; T</code></span>
<span class="codeline" id="line-346"><code></code></span>
<span class="codeline" id="line-347"><code>And consider the two truncated quotients:</code></span>
<span class="codeline" id="line-348"><code></code></span>
<span class="codeline" id="line-349"><code>	q = ⌊x/y⌋</code></span>
<span class="codeline" id="line-350"><code>	q̂ = ⌊x₁/y₁⌋</code></span>
<span class="codeline" id="line-351"><code></code></span>
<span class="codeline" id="line-352"><code>We will prove that q ≤ q̂ ≤ q+2.</code></span>
<span class="codeline" id="line-353"><code></code></span>
<span class="codeline" id="line-354"><code>The guarantee makes no real demands on the scaling factor S: it is simply the</code></span>
<span class="codeline" id="line-355"><code>magnitude of the digits cut from both x and y to produce x₁ and y₁.</code></span>
<span class="codeline" id="line-356"><code>The guarantee makes only limited demands on T: it must be large enough to hold</code></span>
<span class="codeline" id="line-357"><code>the quotient x/y, and y₁ must have roughly the same size.</code></span>
<span class="codeline" id="line-358"><code></code></span>
<span class="codeline" id="line-359"><code>To apply to the earlier discussion of 2-by-1 guesses in long division,</code></span>
<span class="codeline" id="line-360"><code>we would choose:</code></span>
<span class="codeline" id="line-361"><code></code></span>
<span class="codeline" id="line-362"><code>	S  = Bⁿ⁻¹</code></span>
<span class="codeline" id="line-363"><code>	T  = B</code></span>
<span class="codeline" id="line-364"><code>	x  = u</code></span>
<span class="codeline" id="line-365"><code>	x₁ = uₙuₙ₋₁</code></span>
<span class="codeline" id="line-366"><code>	x₀ = uₙ₋₂...u₀</code></span>
<span class="codeline" id="line-367"><code>	y  = v</code></span>
<span class="codeline" id="line-368"><code>	y₁ = vₙ₋₁</code></span>
<span class="codeline" id="line-369"><code>	y₀ = vₙ₋₂...u₀</code></span>
<span class="codeline" id="line-370"><code></code></span>
<span class="codeline" id="line-371"><code>These simpler variables avoid repeating those longer expressions in the proof.</code></span>
<span class="codeline" id="line-372"><code></code></span>
<span class="codeline" id="line-373"><code>Note also that, by definition, truncating division ⌊x/y⌋ satisfies</code></span>
<span class="codeline" id="line-374"><code></code></span>
<span class="codeline" id="line-375"><code>	x/y - 1 &lt; ⌊x/y⌋ ≤ x/y.</code></span>
<span class="codeline" id="line-376"><code></code></span>
<span class="codeline" id="line-377"><code>This fact will be used a few times in the proofs.</code></span>
<span class="codeline" id="line-378"><code></code></span>
<span class="codeline" id="line-379"><code>Proof that q ≤ q̂:</code></span>
<span class="codeline" id="line-380"><code></code></span>
<span class="codeline" id="line-381"><code>	q̂·y₁ = ⌊x₁/y₁⌋·y₁                      [by definition, q̂ = ⌊x₁/y₁⌋]</code></span>
<span class="codeline" id="line-382"><code>	     &gt; (x₁/y₁ - 1)·y₁                  [x₁/y₁ - 1 &lt; ⌊x₁/y₁⌋]</code></span>
<span class="codeline" id="line-383"><code>	     = x₁ - y₁                         [distribute y₁]</code></span>
<span class="codeline" id="line-384"><code></code></span>
<span class="codeline" id="line-385"><code>	So q̂·y₁ &gt; x₁ - y₁.</code></span>
<span class="codeline" id="line-386"><code>	Since q̂·y₁ is an integer, q̂·y₁ ≥ x₁ - y₁ + 1.</code></span>
<span class="codeline" id="line-387"><code></code></span>
<span class="codeline" id="line-388"><code>	q̂ - q = q̂ - ⌊x/y⌋                      [by definition, q = ⌊x/y⌋]</code></span>
<span class="codeline" id="line-389"><code>	      ≥ q̂ - x/y                        [⌊x/y⌋ &lt; x/y]</code></span>
<span class="codeline" id="line-390"><code>	      = (1/y)·(q̂·y - x)                [factor out 1/y]</code></span>
<span class="codeline" id="line-391"><code>	      ≥ (1/y)·(q̂·y₁·S - x)             [y = y₁·S + y₀ ≥ y₁·S]</code></span>
<span class="codeline" id="line-392"><code>	      ≥ (1/y)·((x₁ - y₁ + 1)·S - x)    [above: q̂·y₁ ≥ x₁ - y₁ + 1]</code></span>
<span class="codeline" id="line-393"><code>	      = (1/y)·(x₁·S - y₁·S + S - x)    [distribute S]</code></span>
<span class="codeline" id="line-394"><code>	      = (1/y)·(S - x₀ - y₁·S)          [-x = -x₁·S - x₀]</code></span>
<span class="codeline" id="line-395"><code>	      &gt; -y₁·S / y                      [x₀ &lt; S, so S - x₀ &lt; 0; drop it]</code></span>
<span class="codeline" id="line-396"><code>	      ≥ -1                             [y₁·S ≤ y]</code></span>
<span class="codeline" id="line-397"><code></code></span>
<span class="codeline" id="line-398"><code>	So q̂ - q &gt; -1.</code></span>
<span class="codeline" id="line-399"><code>	Since q̂ - q is an integer, q̂ - q ≥ 0, or equivalently q ≤ q̂.</code></span>
<span class="codeline" id="line-400"><code></code></span>
<span class="codeline" id="line-401"><code>Proof that q̂ ≤ q+2:</code></span>
<span class="codeline" id="line-402"><code></code></span>
<span class="codeline" id="line-403"><code>	x₁/y₁ - x/y = x₁·S/y₁·S - x/y          [multiply left term by S/S]</code></span>
<span class="codeline" id="line-404"><code>	            ≤ x/y₁·S - x/y             [x₁S ≤ x]</code></span>
<span class="codeline" id="line-405"><code>	            = (x/y)·(y/y₁·S - 1)       [factor out x/y]</code></span>
<span class="codeline" id="line-406"><code>	            = (x/y)·((y - y₁·S)/y₁·S)  [move -1 into y/y₁·S fraction]</code></span>
<span class="codeline" id="line-407"><code>	            = (x/y)·(y₀/y₁·S)          [y - y₁·S = y₀]</code></span>
<span class="codeline" id="line-408"><code>	            = (x/y)·(1/y₁)·(y₀/S)      [factor out 1/y₁]</code></span>
<span class="codeline" id="line-409"><code>	            &lt; (x/y)·(1/y₁)             [y₀ &lt; S, so y₀/S &lt; 1]</code></span>
<span class="codeline" id="line-410"><code>	            ≤ (x/y)·(2/T)              [y₁ ≥ T/2, so 1/y₁ ≤ 2/T]</code></span>
<span class="codeline" id="line-411"><code>	            &lt; T·(2/T)                  [x/y &lt; T]</code></span>
<span class="codeline" id="line-412"><code>	            = 2                        [T·(2/T) = 2]</code></span>
<span class="codeline" id="line-413"><code></code></span>
<span class="codeline" id="line-414"><code>	So x₁/y₁ - x/y &lt; 2.</code></span>
<span class="codeline" id="line-415"><code></code></span>
<span class="codeline" id="line-416"><code>	q̂ - q = ⌊x₁/y₁⌋ - q                    [by definition, q̂ = ⌊x₁/y₁⌋]</code></span>
<span class="codeline" id="line-417"><code>	      = ⌊x₁/y₁⌋ - ⌊x/y⌋                [by definition, q = ⌊x/y⌋]</code></span>
<span class="codeline" id="line-418"><code>	      ≤ x₁/y₁ - ⌊x/y⌋                  [⌊x₁/y₁⌋ ≤ x₁/y₁]</code></span>
<span class="codeline" id="line-419"><code>	      &lt; x₁/y₁ - (x/y - 1)              [⌊x/y⌋ &gt; x/y - 1]</code></span>
<span class="codeline" id="line-420"><code>	      = (x₁/y₁ - x/y) + 1              [regrouping]</code></span>
<span class="codeline" id="line-421"><code>	      &lt; 2 + 1                          [above: x₁/y₁ - x/y &lt; 2]</code></span>
<span class="codeline" id="line-422"><code>	      = 3</code></span>
<span class="codeline" id="line-423"><code></code></span>
<span class="codeline" id="line-424"><code>	So q̂ - q &lt; 3.</code></span>
<span class="codeline" id="line-425"><code>	Since q̂ - q is an integer, q̂ - q ≤ 2.</code></span>
<span class="codeline" id="line-426"><code></code></span>
<span class="codeline" id="line-427"><code>Note that when x/y &lt; T/2, the bounds tighten to x₁/y₁ - x/y &lt; 1 and therefore</code></span>
<span class="codeline" id="line-428"><code>q̂ - q ≤ 1.</code></span>
<span class="codeline" id="line-429"><code></code></span>
<span class="codeline" id="line-430"><code>Note also that in the general case 2n-by-n division where we don't know that</code></span>
<span class="codeline" id="line-431"><code>x/y &lt; T, we do know that x/y &lt; 2T, yielding the bound q̂ - q ≤ 4. So we could</code></span>
<span class="codeline" id="line-432"><code>remove the special case first step of long division as long as we allow the</code></span>
<span class="codeline" id="line-433"><code>first fixup loop to run up to four times. (Using a simple comparison to decide</code></span>
<span class="codeline" id="line-434"><code>whether the first digit is 0 or 1 is still more efficient, though.)</code></span>
<span class="codeline" id="line-435"><code></code></span>
<span class="codeline" id="line-436"><code>Finally, note that when dividing three leading base-B digits by two (scaled),</code></span>
<span class="codeline" id="line-437"><code>we have T = B² and x/y &lt; B = T/B, a much tighter bound than x/y &lt; T.</code></span>
<span class="codeline" id="line-438"><code>This in turn yields the much tighter bound x₁/y₁ - x/y &lt; 2/B. This means that</code></span>
<span class="codeline" id="line-439"><code>⌊x₁/y₁⌋ and ⌊x/y⌋ can only differ when x/y is less than 2/B greater than an</code></span>
<span class="codeline" id="line-440"><code>integer. For random x and y, the chance of this is 2/B, or, for large B,</code></span>
<span class="codeline" id="line-441"><code>approximately zero. This means that after we produce the 3-by-2 guess in the</code></span>
<span class="codeline" id="line-442"><code>long division algorithm, the fixup loop essentially never runs.</code></span>
<span class="codeline" id="line-443"><code></code></span>
<span class="codeline" id="line-444"><code>In the recursive algorithm, the extra digit in (2·⌊n/2⌋+1)-by-(⌊n/2⌋+1)-digit</code></span>
<span class="codeline" id="line-445"><code>division has exactly the same effect: the probability of needing a fixup is the</code></span>
<span class="codeline" id="line-446"><code>same 2/B. Even better, we can allow the general case x/y &lt; 2T and the fixup</code></span>
<span class="codeline" id="line-447"><code>probability only grows to 4/B, still essentially zero.</code></span>
<span class="codeline" id="line-448"><code></code></span>
<span class="codeline" id="line-449"><code></code></span>
<span class="codeline" id="line-450"><code>References</code></span>
<span class="codeline" id="line-451"><code></code></span>
<span class="codeline" id="line-452"><code>There are no great references for implementing long division; thus this comment.</code></span>
<span class="codeline" id="line-453"><code>Here are some notes about what to expect from the obvious references.</code></span>
<span class="codeline" id="line-454"><code></code></span>
<span class="codeline" id="line-455"><code>Knuth Volume 2 (Seminumerical Algorithms) section 4.3.1 is the usual canonical</code></span>
<span class="codeline" id="line-456"><code>reference for long division, but that entire series is highly compressed, never</code></span>
<span class="codeline" id="line-457"><code>repeating a necessary fact and leaving important insights to the exercises.</code></span>
<span class="codeline" id="line-458"><code>For example, no rationale whatsoever is given for the calculation that extends</code></span>
<span class="codeline" id="line-459"><code>q̂ from a 2-by-1 to a 3-by-2 guess, nor why it reduces the error bound.</code></span>
<span class="codeline" id="line-460"><code>The proof that the calculation even has the desired effect is left to exercises.</code></span>
<span class="codeline" id="line-461"><code>The solutions to those exercises provided at the back of the book are entirely</code></span>
<span class="codeline" id="line-462"><code>calculations, still with no explanation as to what is going on or how you would</code></span>
<span class="codeline" id="line-463"><code>arrive at the idea of doing those exact calculations. Nowhere is it mentioned</code></span>
<span class="codeline" id="line-464"><code>that this test extends the 2-by-1 guess into a 3-by-2 guess. The proof of the</code></span>
<span class="codeline" id="line-465"><code>Good Guess Guarantee is only for the 2-by-1 guess and argues by contradiction,</code></span>
<span class="codeline" id="line-466"><code>making it difficult to understand how modifications like adding another digit</code></span>
<span class="codeline" id="line-467"><code>or adjusting the quotient range affects the overall bound.</code></span>
<span class="codeline" id="line-468"><code></code></span>
<span class="codeline" id="line-469"><code>All that said, Knuth remains the canonical reference. It is dense but packed</code></span>
<span class="codeline" id="line-470"><code>full of information and references, and the proofs are simpler than many other</code></span>
<span class="codeline" id="line-471"><code>presentations. The proofs above are reworkings of Knuth's to remove the</code></span>
<span class="codeline" id="line-472"><code>arguments by contradiction and add explanations or steps that Knuth omitted.</code></span>
<span class="codeline" id="line-473"><code>But beware of errors in older printings. Take the published errata with you.</code></span>
<span class="codeline" id="line-474"><code></code></span>
<span class="codeline" id="line-475"><code>Brinch Hansen's “Multiple-length Division Revisited: a Tour of the Minefield”</code></span>
<span class="codeline" id="line-476"><code>starts with a blunt critique of Knuth's presentation (among others) and then</code></span>
<span class="codeline" id="line-477"><code>presents a more detailed and easier to follow treatment of long division,</code></span>
<span class="codeline" id="line-478"><code>including an implementation in Pascal. But the algorithm and implementation</code></span>
<span class="codeline" id="line-479"><code>work entirely in terms of 3-by-2 division, which is much less useful on modern</code></span>
<span class="codeline" id="line-480"><code>hardware than an algorithm using 2-by-1 division. The proofs are a bit too</code></span>
<span class="codeline" id="line-481"><code>focused on digit counting and seem needlessly complex, especially compared to</code></span>
<span class="codeline" id="line-482"><code>the ones given above.</code></span>
<span class="codeline" id="line-483"><code></code></span>
<span class="codeline" id="line-484"><code>Burnikel and Ziegler's “Fast Recursive Division” introduced the key insight of</code></span>
<span class="codeline" id="line-485"><code>implementing division by an n-digit divisor using recursive calls to division</code></span>
<span class="codeline" id="line-486"><code>by an n/2-digit divisor, relying on Karatsuba multiplication to yield a</code></span>
<span class="codeline" id="line-487"><code>sub-quadratic run time. However, the presentation decisions are made almost</code></span>
<span class="codeline" id="line-488"><code>entirely for the purpose of simplifying the run-time analysis, rather than</code></span>
<span class="codeline" id="line-489"><code>simplifying the presentation. Instead of a single algorithm that loops over</code></span>
<span class="codeline" id="line-490"><code>quotient digits, the paper presents two mutually-recursive algorithms, for</code></span>
<span class="codeline" id="line-491"><code>2n-by-n and 3n-by-2n. The paper also does not present any general (n+m)-by-n</code></span>
<span class="codeline" id="line-492"><code>algorithm.</code></span>
<span class="codeline" id="line-493"><code></code></span>
<span class="codeline" id="line-494"><code>The proofs in the paper are remarkably complex, especially considering that</code></span>
<span class="codeline" id="line-495"><code>the algorithm is at its core just long division on wide digits, so that the</code></span>
<span class="codeline" id="line-496"><code>usual long division proofs apply essentially unaltered.</code></span>
<span class="codeline" id="line-497"><code>*/</code></span>
<span class="codeline" id="line-498"><code></code></span>
<span class="codeline" id="line-499"><code>package big</code></span>
<span class="codeline" id="line-500"><code></code></span>
<span class="codeline" id="line-501"><code>import "math/bits"</code></span>
<span class="codeline" id="line-502"><code></code></span>
<span class="codeline" id="line-503"><code>// rem returns r such that r = u%v.</code></span>
<span class="codeline" id="line-504"><code>// It uses z as the storage for r.</code></span>
<span class="codeline" id="line-505"><code>func (z nat) rem(u, v nat) (r nat) {</code></span>
<span class="codeline" id="line-506"><code>	if alias(z, u) {</code></span>
<span class="codeline" id="line-507"><code>		z = nil</code></span>
<span class="codeline" id="line-508"><code>	}</code></span>
<span class="codeline" id="line-509"><code>	qp := getNat(0)</code></span>
<span class="codeline" id="line-510"><code>	q, r := qp.div(z, u, v)</code></span>
<span class="codeline" id="line-511"><code>	*qp = q</code></span>
<span class="codeline" id="line-512"><code>	putNat(qp)</code></span>
<span class="codeline" id="line-513"><code>	return r</code></span>
<span class="codeline" id="line-514"><code>}</code></span>
<span class="codeline" id="line-515"><code></code></span>
<span class="codeline" id="line-516"><code>// div returns q, r such that q = ⌊u/v⌋ and r = u%v = u - q·v.</code></span>
<span class="codeline" id="line-517"><code>// It uses z and z2 as the storage for q and r.</code></span>
<span class="codeline" id="line-518"><code>func (z nat) div(z2, u, v nat) (q, r nat) {</code></span>
<span class="codeline" id="line-519"><code>	if len(v) == 0 {</code></span>
<span class="codeline" id="line-520"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-521"><code>	}</code></span>
<span class="codeline" id="line-522"><code></code></span>
<span class="codeline" id="line-523"><code>	if u.cmp(v) &lt; 0 {</code></span>
<span class="codeline" id="line-524"><code>		q = z[:0]</code></span>
<span class="codeline" id="line-525"><code>		r = z2.set(u)</code></span>
<span class="codeline" id="line-526"><code>		return</code></span>
<span class="codeline" id="line-527"><code>	}</code></span>
<span class="codeline" id="line-528"><code></code></span>
<span class="codeline" id="line-529"><code>	if len(v) == 1 {</code></span>
<span class="codeline" id="line-530"><code>		// Short division: long optimized for a single-word divisor.</code></span>
<span class="codeline" id="line-531"><code>		// In that case, the 2-by-1 guess is all we need at each step.</code></span>
<span class="codeline" id="line-532"><code>		var r2 Word</code></span>
<span class="codeline" id="line-533"><code>		q, r2 = z.divW(u, v[0])</code></span>
<span class="codeline" id="line-534"><code>		r = z2.setWord(r2)</code></span>
<span class="codeline" id="line-535"><code>		return</code></span>
<span class="codeline" id="line-536"><code>	}</code></span>
<span class="codeline" id="line-537"><code></code></span>
<span class="codeline" id="line-538"><code>	q, r = z.divLarge(z2, u, v)</code></span>
<span class="codeline" id="line-539"><code>	return</code></span>
<span class="codeline" id="line-540"><code>}</code></span>
<span class="codeline" id="line-541"><code></code></span>
<span class="codeline" id="line-542"><code>// divW returns q, r such that q = ⌊x/y⌋ and r = x%y = x - q·y.</code></span>
<span class="codeline" id="line-543"><code>// It uses z as the storage for q.</code></span>
<span class="codeline" id="line-544"><code>// Note that y is a single digit (Word), not a big number.</code></span>
<span class="codeline" id="line-545"><code>func (z nat) divW(x nat, y Word) (q nat, r Word) {</code></span>
<span class="codeline" id="line-546"><code>	m := len(x)</code></span>
<span class="codeline" id="line-547"><code>	switch {</code></span>
<span class="codeline" id="line-548"><code>	case y == 0:</code></span>
<span class="codeline" id="line-549"><code>		panic("division by zero")</code></span>
<span class="codeline" id="line-550"><code>	case y == 1:</code></span>
<span class="codeline" id="line-551"><code>		q = z.set(x) // result is x</code></span>
<span class="codeline" id="line-552"><code>		return</code></span>
<span class="codeline" id="line-553"><code>	case m == 0:</code></span>
<span class="codeline" id="line-554"><code>		q = z[:0] // result is 0</code></span>
<span class="codeline" id="line-555"><code>		return</code></span>
<span class="codeline" id="line-556"><code>	}</code></span>
<span class="codeline" id="line-557"><code>	// m &gt; 0</code></span>
<span class="codeline" id="line-558"><code>	z = z.make(m)</code></span>
<span class="codeline" id="line-559"><code>	r = divWVW(z, 0, x, y)</code></span>
<span class="codeline" id="line-560"><code>	q = z.norm()</code></span>
<span class="codeline" id="line-561"><code>	return</code></span>
<span class="codeline" id="line-562"><code>}</code></span>
<span class="codeline" id="line-563"><code></code></span>
<span class="codeline" id="line-564"><code>// modW returns x % d.</code></span>
<span class="codeline" id="line-565"><code>func (x nat) modW(d Word) (r Word) {</code></span>
<span class="codeline" id="line-566"><code>	// TODO(agl): we don't actually need to store the q value.</code></span>
<span class="codeline" id="line-567"><code>	var q nat</code></span>
<span class="codeline" id="line-568"><code>	q = q.make(len(x))</code></span>
<span class="codeline" id="line-569"><code>	return divWVW(q, 0, x, d)</code></span>
<span class="codeline" id="line-570"><code>}</code></span>
<span class="codeline" id="line-571"><code></code></span>
<span class="codeline" id="line-572"><code>// divWVW overwrites z with ⌊x/y⌋, returning the remainder r.</code></span>
<span class="codeline" id="line-573"><code>// The caller must ensure that len(z) = len(x).</code></span>
<span class="codeline" id="line-574"><code>func divWVW(z []Word, xn Word, x []Word, y Word) (r Word) {</code></span>
<span class="codeline" id="line-575"><code>	r = xn</code></span>
<span class="codeline" id="line-576"><code>	if len(x) == 1 {</code></span>
<span class="codeline" id="line-577"><code>		qq, rr := bits.Div(uint(r), uint(x[0]), uint(y))</code></span>
<span class="codeline" id="line-578"><code>		z[0] = Word(qq)</code></span>
<span class="codeline" id="line-579"><code>		return Word(rr)</code></span>
<span class="codeline" id="line-580"><code>	}</code></span>
<span class="codeline" id="line-581"><code>	rec := reciprocalWord(y)</code></span>
<span class="codeline" id="line-582"><code>	for i := len(z) - 1; i &gt;= 0; i-- {</code></span>
<span class="codeline" id="line-583"><code>		z[i], r = divWW(r, x[i], y, rec)</code></span>
<span class="codeline" id="line-584"><code>	}</code></span>
<span class="codeline" id="line-585"><code>	return r</code></span>
<span class="codeline" id="line-586"><code>}</code></span>
<span class="codeline" id="line-587"><code></code></span>
<span class="codeline" id="line-588"><code>// div returns q, r such that q = ⌊uIn/vIn⌋ and r = uIn%vIn = uIn - q·vIn.</code></span>
<span class="codeline" id="line-589"><code>// It uses z and u as the storage for q and r.</code></span>
<span class="codeline" id="line-590"><code>// The caller must ensure that len(vIn) ≥ 2 (use divW otherwise)</code></span>
<span class="codeline" id="line-591"><code>// and that len(uIn) ≥ len(vIn) (the answer is 0, uIn otherwise).</code></span>
<span class="codeline" id="line-592"><code>func (z nat) divLarge(u, uIn, vIn nat) (q, r nat) {</code></span>
<span class="codeline" id="line-593"><code>	n := len(vIn)</code></span>
<span class="codeline" id="line-594"><code>	m := len(uIn) - n</code></span>
<span class="codeline" id="line-595"><code></code></span>
<span class="codeline" id="line-596"><code>	// Scale the inputs so vIn's top bit is 1 (see “Scaling Inputs” above).</code></span>
<span class="codeline" id="line-597"><code>	// vIn is treated as a read-only input (it may be in use by another</code></span>
<span class="codeline" id="line-598"><code>	// goroutine), so we must make a copy.</code></span>
<span class="codeline" id="line-599"><code>	// uIn is copied to u.</code></span>
<span class="codeline" id="line-600"><code>	shift := nlz(vIn[n-1])</code></span>
<span class="codeline" id="line-601"><code>	vp := getNat(n)</code></span>
<span class="codeline" id="line-602"><code>	v := *vp</code></span>
<span class="codeline" id="line-603"><code>	shlVU(v, vIn, shift)</code></span>
<span class="codeline" id="line-604"><code>	u = u.make(len(uIn) + 1)</code></span>
<span class="codeline" id="line-605"><code>	u[len(uIn)] = shlVU(u[0:len(uIn)], uIn, shift)</code></span>
<span class="codeline" id="line-606"><code></code></span>
<span class="codeline" id="line-607"><code>	// The caller should not pass aliased z and u, since those are</code></span>
<span class="codeline" id="line-608"><code>	// the two different outputs, but correct just in case.</code></span>
<span class="codeline" id="line-609"><code>	if alias(z, u) {</code></span>
<span class="codeline" id="line-610"><code>		z = nil</code></span>
<span class="codeline" id="line-611"><code>	}</code></span>
<span class="codeline" id="line-612"><code>	q = z.make(m + 1)</code></span>
<span class="codeline" id="line-613"><code></code></span>
<span class="codeline" id="line-614"><code>	// Use basic or recursive long division depending on size.</code></span>
<span class="codeline" id="line-615"><code>	if n &lt; divRecursiveThreshold {</code></span>
<span class="codeline" id="line-616"><code>		q.divBasic(u, v)</code></span>
<span class="codeline" id="line-617"><code>	} else {</code></span>
<span class="codeline" id="line-618"><code>		q.divRecursive(u, v)</code></span>
<span class="codeline" id="line-619"><code>	}</code></span>
<span class="codeline" id="line-620"><code>	putNat(vp)</code></span>
<span class="codeline" id="line-621"><code></code></span>
<span class="codeline" id="line-622"><code>	q = q.norm()</code></span>
<span class="codeline" id="line-623"><code></code></span>
<span class="codeline" id="line-624"><code>	// Undo scaling of remainder.</code></span>
<span class="codeline" id="line-625"><code>	shrVU(u, u, shift)</code></span>
<span class="codeline" id="line-626"><code>	r = u.norm()</code></span>
<span class="codeline" id="line-627"><code></code></span>
<span class="codeline" id="line-628"><code>	return q, r</code></span>
<span class="codeline" id="line-629"><code>}</code></span>
<span class="codeline" id="line-630"><code></code></span>
<span class="codeline" id="line-631"><code>// divBasic implements long division as described above.</code></span>
<span class="codeline" id="line-632"><code>// It overwrites q with ⌊u/v⌋ and overwrites u with the remainder r.</code></span>
<span class="codeline" id="line-633"><code>// q must be large enough to hold ⌊u/v⌋.</code></span>
<span class="codeline" id="line-634"><code>func (q nat) divBasic(u, v nat) {</code></span>
<span class="codeline" id="line-635"><code>	n := len(v)</code></span>
<span class="codeline" id="line-636"><code>	m := len(u) - n</code></span>
<span class="codeline" id="line-637"><code></code></span>
<span class="codeline" id="line-638"><code>	qhatvp := getNat(n + 1)</code></span>
<span class="codeline" id="line-639"><code>	qhatv := *qhatvp</code></span>
<span class="codeline" id="line-640"><code></code></span>
<span class="codeline" id="line-641"><code>	// Set up for divWW below, precomputing reciprocal argument.</code></span>
<span class="codeline" id="line-642"><code>	vn1 := v[n-1]</code></span>
<span class="codeline" id="line-643"><code>	rec := reciprocalWord(vn1)</code></span>
<span class="codeline" id="line-644"><code></code></span>
<span class="codeline" id="line-645"><code>	// Compute each digit of quotient.</code></span>
<span class="codeline" id="line-646"><code>	for j := m; j &gt;= 0; j-- {</code></span>
<span class="codeline" id="line-647"><code>		// Compute the 2-by-1 guess q̂.</code></span>
<span class="codeline" id="line-648"><code>		// The first iteration must invent a leading 0 for u.</code></span>
<span class="codeline" id="line-649"><code>		qhat := Word(_M)</code></span>
<span class="codeline" id="line-650"><code>		var ujn Word</code></span>
<span class="codeline" id="line-651"><code>		if j+n &lt; len(u) {</code></span>
<span class="codeline" id="line-652"><code>			ujn = u[j+n]</code></span>
<span class="codeline" id="line-653"><code>		}</code></span>
<span class="codeline" id="line-654"><code></code></span>
<span class="codeline" id="line-655"><code>		// ujn ≤ vn1, or else q̂ would be more than one digit.</code></span>
<span class="codeline" id="line-656"><code>		// For ujn == vn1, we set q̂ to the max digit M above.</code></span>
<span class="codeline" id="line-657"><code>		// Otherwise, we compute the 2-by-1 guess.</code></span>
<span class="codeline" id="line-658"><code>		if ujn != vn1 {</code></span>
<span class="codeline" id="line-659"><code>			var rhat Word</code></span>
<span class="codeline" id="line-660"><code>			qhat, rhat = divWW(ujn, u[j+n-1], vn1, rec)</code></span>
<span class="codeline" id="line-661"><code></code></span>
<span class="codeline" id="line-662"><code>			// Refine q̂ to a 3-by-2 guess. See “Refining Guesses” above.</code></span>
<span class="codeline" id="line-663"><code>			vn2 := v[n-2]</code></span>
<span class="codeline" id="line-664"><code>			x1, x2 := mulWW(qhat, vn2)</code></span>
<span class="codeline" id="line-665"><code>			ujn2 := u[j+n-2]</code></span>
<span class="codeline" id="line-666"><code>			for greaterThan(x1, x2, rhat, ujn2) { // x1x2 &gt; r̂ u[j+n-2]</code></span>
<span class="codeline" id="line-667"><code>				qhat--</code></span>
<span class="codeline" id="line-668"><code>				prevRhat := rhat</code></span>
<span class="codeline" id="line-669"><code>				rhat += vn1</code></span>
<span class="codeline" id="line-670"><code>				// If r̂  overflows, then</code></span>
<span class="codeline" id="line-671"><code>				// r̂ u[j+n-2]v[n-1] is now definitely &gt; x1 x2.</code></span>
<span class="codeline" id="line-672"><code>				if rhat &lt; prevRhat {</code></span>
<span class="codeline" id="line-673"><code>					break</code></span>
<span class="codeline" id="line-674"><code>				}</code></span>
<span class="codeline" id="line-675"><code>				// TODO(rsc): No need for a full mulWW.</code></span>
<span class="codeline" id="line-676"><code>				// x2 += vn2; if x2 overflows, x1++</code></span>
<span class="codeline" id="line-677"><code>				x1, x2 = mulWW(qhat, vn2)</code></span>
<span class="codeline" id="line-678"><code>			}</code></span>
<span class="codeline" id="line-679"><code>		}</code></span>
<span class="codeline" id="line-680"><code></code></span>
<span class="codeline" id="line-681"><code>		// Compute q̂·v.</code></span>
<span class="codeline" id="line-682"><code>		qhatv[n] = mulAddVWW(qhatv[0:n], v, qhat, 0)</code></span>
<span class="codeline" id="line-683"><code>		qhl := len(qhatv)</code></span>
<span class="codeline" id="line-684"><code>		if j+qhl &gt; len(u) &amp;&amp; qhatv[n] == 0 {</code></span>
<span class="codeline" id="line-685"><code>			qhl--</code></span>
<span class="codeline" id="line-686"><code>		}</code></span>
<span class="codeline" id="line-687"><code></code></span>
<span class="codeline" id="line-688"><code>		// Subtract q̂·v from the current section of u.</code></span>
<span class="codeline" id="line-689"><code>		// If it underflows, q̂·v &gt; u, which we fix up</code></span>
<span class="codeline" id="line-690"><code>		// by decrementing q̂ and adding v back.</code></span>
<span class="codeline" id="line-691"><code>		c := subVV(u[j:j+qhl], u[j:], qhatv)</code></span>
<span class="codeline" id="line-692"><code>		if c != 0 {</code></span>
<span class="codeline" id="line-693"><code>			c := addVV(u[j:j+n], u[j:], v)</code></span>
<span class="codeline" id="line-694"><code>			// If n == qhl, the carry from subVV and the carry from addVV</code></span>
<span class="codeline" id="line-695"><code>			// cancel out and don't affect u[j+n].</code></span>
<span class="codeline" id="line-696"><code>			if n &lt; qhl {</code></span>
<span class="codeline" id="line-697"><code>				u[j+n] += c</code></span>
<span class="codeline" id="line-698"><code>			}</code></span>
<span class="codeline" id="line-699"><code>			qhat--</code></span>
<span class="codeline" id="line-700"><code>		}</code></span>
<span class="codeline" id="line-701"><code></code></span>
<span class="codeline" id="line-702"><code>		// Save quotient digit.</code></span>
<span class="codeline" id="line-703"><code>		// Caller may know the top digit is zero and not leave room for it.</code></span>
<span class="codeline" id="line-704"><code>		if j == m &amp;&amp; m == len(q) &amp;&amp; qhat == 0 {</code></span>
<span class="codeline" id="line-705"><code>			continue</code></span>
<span class="codeline" id="line-706"><code>		}</code></span>
<span class="codeline" id="line-707"><code>		q[j] = qhat</code></span>
<span class="codeline" id="line-708"><code>	}</code></span>
<span class="codeline" id="line-709"><code></code></span>
<span class="codeline" id="line-710"><code>	putNat(qhatvp)</code></span>
<span class="codeline" id="line-711"><code>}</code></span>
<span class="codeline" id="line-712"><code></code></span>
<span class="codeline" id="line-713"><code>// greaterThan reports whether the two digit numbers x1 x2 &gt; y1 y2.</code></span>
<span class="codeline" id="line-714"><code>// TODO(rsc): In contradiction to most of this file, x1 is the high</code></span>
<span class="codeline" id="line-715"><code>// digit and x2 is the low digit. This should be fixed.</code></span>
<span class="codeline" id="line-716"><code>func greaterThan(x1, x2, y1, y2 Word) bool {</code></span>
<span class="codeline" id="line-717"><code>	return x1 &gt; y1 || x1 == y1 &amp;&amp; x2 &gt; y2</code></span>
<span class="codeline" id="line-718"><code>}</code></span>
<span class="codeline" id="line-719"><code></code></span>
<span class="codeline" id="line-720"><code>// divRecursiveThreshold is the number of divisor digits</code></span>
<span class="codeline" id="line-721"><code>// at which point divRecursive is faster than divBasic.</code></span>
<span class="codeline" id="line-722"><code>const divRecursiveThreshold = 100</code></span>
<span class="codeline" id="line-723"><code></code></span>
<span class="codeline" id="line-724"><code>// divRecursive implements recursive division as described above.</code></span>
<span class="codeline" id="line-725"><code>// It overwrites z with ⌊u/v⌋ and overwrites u with the remainder r.</code></span>
<span class="codeline" id="line-726"><code>// z must be large enough to hold ⌊u/v⌋.</code></span>
<span class="codeline" id="line-727"><code>// This function is just for allocating and freeing temporaries</code></span>
<span class="codeline" id="line-728"><code>// around divRecursiveStep, the real implementation.</code></span>
<span class="codeline" id="line-729"><code>func (z nat) divRecursive(u, v nat) {</code></span>
<span class="codeline" id="line-730"><code>	// Recursion depth is (much) less than 2 log₂(len(v)).</code></span>
<span class="codeline" id="line-731"><code>	// Allocate a slice of temporaries to be reused across recursion,</code></span>
<span class="codeline" id="line-732"><code>	// plus one extra temporary not live across the recursion.</code></span>
<span class="codeline" id="line-733"><code>	recDepth := 2 * bits.Len(uint(len(v)))</code></span>
<span class="codeline" id="line-734"><code>	tmp := getNat(3 * len(v))</code></span>
<span class="codeline" id="line-735"><code>	temps := make([]*nat, recDepth)</code></span>
<span class="codeline" id="line-736"><code></code></span>
<span class="codeline" id="line-737"><code>	z.clear()</code></span>
<span class="codeline" id="line-738"><code>	z.divRecursiveStep(u, v, 0, tmp, temps)</code></span>
<span class="codeline" id="line-739"><code></code></span>
<span class="codeline" id="line-740"><code>	// Free temporaries.</code></span>
<span class="codeline" id="line-741"><code>	for _, n := range temps {</code></span>
<span class="codeline" id="line-742"><code>		if n != nil {</code></span>
<span class="codeline" id="line-743"><code>			putNat(n)</code></span>
<span class="codeline" id="line-744"><code>		}</code></span>
<span class="codeline" id="line-745"><code>	}</code></span>
<span class="codeline" id="line-746"><code>	putNat(tmp)</code></span>
<span class="codeline" id="line-747"><code>}</code></span>
<span class="codeline" id="line-748"><code></code></span>
<span class="codeline" id="line-749"><code>// divRecursiveStep is the actual implementation of recursive division.</code></span>
<span class="codeline" id="line-750"><code>// It adds ⌊u/v⌋ to z and overwrites u with the remainder r.</code></span>
<span class="codeline" id="line-751"><code>// z must be large enough to hold ⌊u/v⌋.</code></span>
<span class="codeline" id="line-752"><code>// It uses temps[depth] (allocating if needed) as a temporary live across</code></span>
<span class="codeline" id="line-753"><code>// the recursive call. It also uses tmp, but not live across the recursion.</code></span>
<span class="codeline" id="line-754"><code>func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat) {</code></span>
<span class="codeline" id="line-755"><code>	// u is a subsection of the original and may have leading zeros.</code></span>
<span class="codeline" id="line-756"><code>	// TODO(rsc): The v = v.norm() is useless and should be removed.</code></span>
<span class="codeline" id="line-757"><code>	// We know (and require) that v's top digit is ≥ B/2.</code></span>
<span class="codeline" id="line-758"><code>	u = u.norm()</code></span>
<span class="codeline" id="line-759"><code>	v = v.norm()</code></span>
<span class="codeline" id="line-760"><code>	if len(u) == 0 {</code></span>
<span class="codeline" id="line-761"><code>		z.clear()</code></span>
<span class="codeline" id="line-762"><code>		return</code></span>
<span class="codeline" id="line-763"><code>	}</code></span>
<span class="codeline" id="line-764"><code></code></span>
<span class="codeline" id="line-765"><code>	// Fall back to basic division if the problem is now small enough.</code></span>
<span class="codeline" id="line-766"><code>	n := len(v)</code></span>
<span class="codeline" id="line-767"><code>	if n &lt; divRecursiveThreshold {</code></span>
<span class="codeline" id="line-768"><code>		z.divBasic(u, v)</code></span>
<span class="codeline" id="line-769"><code>		return</code></span>
<span class="codeline" id="line-770"><code>	}</code></span>
<span class="codeline" id="line-771"><code></code></span>
<span class="codeline" id="line-772"><code>	// Nothing to do if u is shorter than v (implies u &lt; v).</code></span>
<span class="codeline" id="line-773"><code>	m := len(u) - n</code></span>
<span class="codeline" id="line-774"><code>	if m &lt; 0 {</code></span>
<span class="codeline" id="line-775"><code>		return</code></span>
<span class="codeline" id="line-776"><code>	}</code></span>
<span class="codeline" id="line-777"><code></code></span>
<span class="codeline" id="line-778"><code>	// We consider B digits in a row as a single wide digit.</code></span>
<span class="codeline" id="line-779"><code>	// (See “Recursive Division” above.)</code></span>
<span class="codeline" id="line-780"><code>	//</code></span>
<span class="codeline" id="line-781"><code>	// TODO(rsc): rename B to Wide, to avoid confusion with _B,</code></span>
<span class="codeline" id="line-782"><code>	// which is something entirely different.</code></span>
<span class="codeline" id="line-783"><code>	// TODO(rsc): Look into whether using ⌈n/2⌉ is better than ⌊n/2⌋.</code></span>
<span class="codeline" id="line-784"><code>	B := n / 2</code></span>
<span class="codeline" id="line-785"><code></code></span>
<span class="codeline" id="line-786"><code>	// Allocate a nat for qhat below.</code></span>
<span class="codeline" id="line-787"><code>	if temps[depth] == nil {</code></span>
<span class="codeline" id="line-788"><code>		temps[depth] = getNat(n) // TODO(rsc): Can be just B+1.</code></span>
<span class="codeline" id="line-789"><code>	} else {</code></span>
<span class="codeline" id="line-790"><code>		*temps[depth] = temps[depth].make(B + 1)</code></span>
<span class="codeline" id="line-791"><code>	}</code></span>
<span class="codeline" id="line-792"><code></code></span>
<span class="codeline" id="line-793"><code>	// Compute each wide digit of the quotient.</code></span>
<span class="codeline" id="line-794"><code>	//</code></span>
<span class="codeline" id="line-795"><code>	// TODO(rsc): Change the loop to be</code></span>
<span class="codeline" id="line-796"><code>	//	for j := (m+B-1)/B*B; j &gt; 0; j -= B {</code></span>
<span class="codeline" id="line-797"><code>	// which will make the final step a regular step, letting us</code></span>
<span class="codeline" id="line-798"><code>	// delete what amounts to an extra copy of the loop body below.</code></span>
<span class="codeline" id="line-799"><code>	j := m</code></span>
<span class="codeline" id="line-800"><code>	for j &gt; B {</code></span>
<span class="codeline" id="line-801"><code>		// Divide u[j-B:j+n] (3 wide digits) by v (2 wide digits).</code></span>
<span class="codeline" id="line-802"><code>		// First make the 2-by-1-wide-digit guess using a recursive call.</code></span>
<span class="codeline" id="line-803"><code>		// Then extend the guess to the full 3-by-2 (see “Refining Guesses”).</code></span>
<span class="codeline" id="line-804"><code>		//</code></span>
<span class="codeline" id="line-805"><code>		// For the 2-by-1-wide-digit guess, instead of doing 2B-by-B-digit,</code></span>
<span class="codeline" id="line-806"><code>		// we use a (2B+1)-by-(B+1) digit, which handles the possibility that</code></span>
<span class="codeline" id="line-807"><code>		// the result has an extra leading 1 digit as well as guaranteeing</code></span>
<span class="codeline" id="line-808"><code>		// that the computed q̂ will be off by at most 1 instead of 2.</code></span>
<span class="codeline" id="line-809"><code></code></span>
<span class="codeline" id="line-810"><code>		// s is the number of digits to drop from the 3B- and 2B-digit chunks.</code></span>
<span class="codeline" id="line-811"><code>		// We drop B-1 to be left with 2B+1 and B+1.</code></span>
<span class="codeline" id="line-812"><code>		s := (B - 1)</code></span>
<span class="codeline" id="line-813"><code></code></span>
<span class="codeline" id="line-814"><code>		// uu is the up-to-3B-digit section of u we are working on.</code></span>
<span class="codeline" id="line-815"><code>		uu := u[j-B:]</code></span>
<span class="codeline" id="line-816"><code></code></span>
<span class="codeline" id="line-817"><code>		// Compute the 2-by-1 guess q̂, leaving r̂ in uu[s:B+n].</code></span>
<span class="codeline" id="line-818"><code>		qhat := *temps[depth]</code></span>
<span class="codeline" id="line-819"><code>		qhat.clear()</code></span>
<span class="codeline" id="line-820"><code>		qhat.divRecursiveStep(uu[s:B+n], v[s:], depth+1, tmp, temps)</code></span>
<span class="codeline" id="line-821"><code>		qhat = qhat.norm()</code></span>
<span class="codeline" id="line-822"><code></code></span>
<span class="codeline" id="line-823"><code>		// Extend to a 3-by-2 quotient and remainder.</code></span>
<span class="codeline" id="line-824"><code>		// Because divRecursiveStep overwrote the top part of uu with</code></span>
<span class="codeline" id="line-825"><code>		// the remainder r̂, the full uu already contains the equivalent</code></span>
<span class="codeline" id="line-826"><code>		// of r̂·B + uₙ₋₂ from the “Refining Guesses” discussion.</code></span>
<span class="codeline" id="line-827"><code>		// Subtracting q̂·vₙ₋₂ from it will compute the full-length remainder.</code></span>
<span class="codeline" id="line-828"><code>		// If that subtraction underflows, q̂·v &gt; u, which we fix up</code></span>
<span class="codeline" id="line-829"><code>		// by decrementing q̂ and adding v back, same as in long division.</code></span>
<span class="codeline" id="line-830"><code></code></span>
<span class="codeline" id="line-831"><code>		// TODO(rsc): Instead of subtract and fix-up, this code is computing</code></span>
<span class="codeline" id="line-832"><code>		// q̂·vₙ₋₂ and decrementing q̂ until that product is ≤ u.</code></span>
<span class="codeline" id="line-833"><code>		// But we can do the subtraction directly, as in the comment above</code></span>
<span class="codeline" id="line-834"><code>		// and in long division, because we know that q̂ is wrong by at most one.</code></span>
<span class="codeline" id="line-835"><code>		qhatv := tmp.make(3 * n)</code></span>
<span class="codeline" id="line-836"><code>		qhatv.clear()</code></span>
<span class="codeline" id="line-837"><code>		qhatv = qhatv.mul(qhat, v[:s])</code></span>
<span class="codeline" id="line-838"><code>		for i := 0; i &lt; 2; i++ {</code></span>
<span class="codeline" id="line-839"><code>			e := qhatv.cmp(uu.norm())</code></span>
<span class="codeline" id="line-840"><code>			if e &lt;= 0 {</code></span>
<span class="codeline" id="line-841"><code>				break</code></span>
<span class="codeline" id="line-842"><code>			}</code></span>
<span class="codeline" id="line-843"><code>			subVW(qhat, qhat, 1)</code></span>
<span class="codeline" id="line-844"><code>			c := subVV(qhatv[:s], qhatv[:s], v[:s])</code></span>
<span class="codeline" id="line-845"><code>			if len(qhatv) &gt; s {</code></span>
<span class="codeline" id="line-846"><code>				subVW(qhatv[s:], qhatv[s:], c)</code></span>
<span class="codeline" id="line-847"><code>			}</code></span>
<span class="codeline" id="line-848"><code>			addAt(uu[s:], v[s:], 0)</code></span>
<span class="codeline" id="line-849"><code>		}</code></span>
<span class="codeline" id="line-850"><code>		if qhatv.cmp(uu.norm()) &gt; 0 {</code></span>
<span class="codeline" id="line-851"><code>			panic("impossible")</code></span>
<span class="codeline" id="line-852"><code>		}</code></span>
<span class="codeline" id="line-853"><code>		c := subVV(uu[:len(qhatv)], uu[:len(qhatv)], qhatv)</code></span>
<span class="codeline" id="line-854"><code>		if c &gt; 0 {</code></span>
<span class="codeline" id="line-855"><code>			subVW(uu[len(qhatv):], uu[len(qhatv):], c)</code></span>
<span class="codeline" id="line-856"><code>		}</code></span>
<span class="codeline" id="line-857"><code>		addAt(z, qhat, j-B)</code></span>
<span class="codeline" id="line-858"><code>		j -= B</code></span>
<span class="codeline" id="line-859"><code>	}</code></span>
<span class="codeline" id="line-860"><code></code></span>
<span class="codeline" id="line-861"><code>	// TODO(rsc): Rewrite loop as described above and delete all this code.</code></span>
<span class="codeline" id="line-862"><code></code></span>
<span class="codeline" id="line-863"><code>	// Now u &lt; (v&lt;&lt;B), compute lower bits in the same way.</code></span>
<span class="codeline" id="line-864"><code>	// Choose shift = B-1 again.</code></span>
<span class="codeline" id="line-865"><code>	s := B - 1</code></span>
<span class="codeline" id="line-866"><code>	qhat := *temps[depth]</code></span>
<span class="codeline" id="line-867"><code>	qhat.clear()</code></span>
<span class="codeline" id="line-868"><code>	qhat.divRecursiveStep(u[s:].norm(), v[s:], depth+1, tmp, temps)</code></span>
<span class="codeline" id="line-869"><code>	qhat = qhat.norm()</code></span>
<span class="codeline" id="line-870"><code>	qhatv := tmp.make(3 * n)</code></span>
<span class="codeline" id="line-871"><code>	qhatv.clear()</code></span>
<span class="codeline" id="line-872"><code>	qhatv = qhatv.mul(qhat, v[:s])</code></span>
<span class="codeline" id="line-873"><code>	// Set the correct remainder as before.</code></span>
<span class="codeline" id="line-874"><code>	for i := 0; i &lt; 2; i++ {</code></span>
<span class="codeline" id="line-875"><code>		if e := qhatv.cmp(u.norm()); e &gt; 0 {</code></span>
<span class="codeline" id="line-876"><code>			subVW(qhat, qhat, 1)</code></span>
<span class="codeline" id="line-877"><code>			c := subVV(qhatv[:s], qhatv[:s], v[:s])</code></span>
<span class="codeline" id="line-878"><code>			if len(qhatv) &gt; s {</code></span>
<span class="codeline" id="line-879"><code>				subVW(qhatv[s:], qhatv[s:], c)</code></span>
<span class="codeline" id="line-880"><code>			}</code></span>
<span class="codeline" id="line-881"><code>			addAt(u[s:], v[s:], 0)</code></span>
<span class="codeline" id="line-882"><code>		}</code></span>
<span class="codeline" id="line-883"><code>	}</code></span>
<span class="codeline" id="line-884"><code>	if qhatv.cmp(u.norm()) &gt; 0 {</code></span>
<span class="codeline" id="line-885"><code>		panic("impossible")</code></span>
<span class="codeline" id="line-886"><code>	}</code></span>
<span class="codeline" id="line-887"><code>	c := subVV(u[0:len(qhatv)], u[0:len(qhatv)], qhatv)</code></span>
<span class="codeline" id="line-888"><code>	if c &gt; 0 {</code></span>
<span class="codeline" id="line-889"><code>		c = subVW(u[len(qhatv):], u[len(qhatv):], c)</code></span>
<span class="codeline" id="line-890"><code>	}</code></span>
<span class="codeline" id="line-891"><code>	if c &gt; 0 {</code></span>
<span class="codeline" id="line-892"><code>		panic("impossible")</code></span>
<span class="codeline" id="line-893"><code>	}</code></span>
<span class="codeline" id="line-894"><code></code></span>
<span class="codeline" id="line-895"><code>	// Done!</code></span>
<span class="codeline" id="line-896"><code>	addAt(z, qhat.norm(), 0)</code></span>
<span class="codeline" id="line-897"><code>}</code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.8</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>